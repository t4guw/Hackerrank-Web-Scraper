
----------
DATA-STRUCTURES.1
easy
----------
PROBLEM STATEMENT:
An array is a type of data structure that stores elements of the same type in a contiguous block of memory. In an array, [expression]).

Given an array, [expression] integers, print each element in reverse order as a single line of space-separated integers.

Note: If you've already solved our C++ domain's Arrays Introduction challenge, you may want to skip this.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
            int N;
            cin>>N;
    
            vector<int> arr(N);
    
            for (int i=0;i<N;i++)
                cin>>arr[i];
    
            reverse(arr.begin(),arr.end());
    
                for (int i=0;i<N;i++)
                cout<<arr[i]<<" ";
    
            return 0;
}

----------
====================
----------
DATA-STRUCTURES.2
easy
----------
PROBLEM STATEMENT:
Given a [expression]: 

1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0


We define an hourglass in [expression]'s graphical representation:

a b c
  d
e f g


There are [expression], then print the maximum hourglass sum.

For example, given the 2D array:

-9 -9 -9  1 1 1 
 0 -9  0  4 3 2
-9 -9 -9  1 2 3
 0  0  8  6 6 0
 0  0  0 -2 0 0
 0  0  1  2 4 0


We calculate the following [expression] hourglass values:

-63, -34, -9, 12, 
-10, 0, 28, 23, 
-27, -11, -2, 10, 
9, 17, 25, 18


Our highest hourglass value is [expression] from the hourglass:

0 4 3
  1
8 6 6


Note: If you have already solved the Java domain's Java 2D Array challenge, you may wish to skip this challenge.

Function Description

Complete the function hourglassSum in the editor below.  It should return an integer, the maximum hourglass sum in the array.  

hourglassSum has the following parameter(s):


arr: an array of integers 

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <climits>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int a[6][6],s;
    int m=INT_MIN;
    //int s;
    for(int i=0;i<6;i++)
        {
        for(int j=0;j<6;j++)
            {
            cin>>a[i][j];
        }
    }
  // int j;
    for(int i=0;i<4;i++)
        {
         // j=0;
        for(int j=0;j<4;j++)
            {
            s=(a[i][j]+a[i][j+1]+a[i][j+2]+a[i+1][j+1]+a[i+2][j]+a[i+2][j+1]+a[i+2][j+2]);
            if(s>m)
                m=s;
        }
        
        
            }
    cout<<m;
    
    
    
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.3
easy
----------
PROBLEM STATEMENT:

Create a list, [expression]-indexing.
Create an integer, [expression].
The [expression]) are described below:
Query: 1 x y
Find the sequence, [expression].
Append integer [expression].
Query: 2 x y
Find the sequence, [expression].
Find the value of element [expression].
Print the new value of [expression] on a new line


Task 
Given [expression] queries, execute each query.

Note: [expression] is the bitwise XOR operation, which corresponds to the ^ operator in most languages. Learn more about it on Wikipedia. 
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main()
{
	int n, q;
	int lastans = 0;
	cin >> n >> q;
	vector<vector<int>>sqces(n);
	while (q--)
	{
		int a;
		long long x, y;
		cin >> a >> x >> y;
		long long t = (x^lastans) % n;
		if (a == 1)
		{
			sqces[t].push_back(y);
		}
		else
		{
			long long size = sqces[t].size();
			long long b;
			if (size != 0)
				b = y%size;
			else
				continue;
			cout << sqces[t][b] << endl;
			lastans =sqces[t][b];
		}
	}
	return 0;
}


----------
====================
----------
DATA-STRUCTURES.4
easy
----------
PROBLEM STATEMENT:
A left rotation operation on an array of size [expression].

Given an array of [expression] left rotations on the array. Then print the updated array as a single line of space-separated integers.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int n,d;
    cin>>n>>d;
    int a[n];
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    for(int i=d;i<n;i++){
        cout<<a[i]<<" ";
    }
    for(int i=0;i<d;i++){
        cout<<a[i]<<" ";
    }
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.5
medium
----------
PROBLEM STATEMENT:
There is a collection of input strings and a collection of query strings.  For each query string, determine how many times it occurs in the list of input strings.  

For example, given input [expression].  

Function Description

Complete the function matchingStrings in the editor below.  The function must return an array of integers representing the frequency of occurrence of each query string in strings.

matchingStrings has the following parameters:


strings - an array of strings to search  
queries - an array of query strings  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include<map>
#include<string>
using namespace std;


int main()
{
	
	int n;
	cin >> n;
	map<string, int>mp;
	while (n--)
	{
		string t;
		cin >> t;
		mp[t]++;
	}
	int a;
	cin >> a;
	while (a--)
	{
		string t;
		cin >> t;
		cout << mp[t] << endl;
	}
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.6
hard
----------
PROBLEM STATEMENT:
Starting with a 1-indexed array of zeros and a list of operations, for each operation add a value to each of the array element between two given indices, inclusive.  Once all operations have been performed, return the maximum value in your array.  

For example, the length of your array of zeros [expression].  Your list of queries is as follows:  

[expression]
    [expression]
    [expression]
    [expression]



Add the values of [expression] inclusive:

[expression]
	[expression]
	[expression]
	[expression]
	[expression]



The largest value is [expression] after all operations are performed.  

Function Description  

Complete the function arrayManipulation in the editor below.  It must return an integer, the maximum value in the resulting array.  

arrayManipulation has the following parameters:


n - the number of elements in your array  
queries - a two dimensional array of queries where each queries[i] contains three integers, a, b, and k.  

----------
TOP SOLUTION:
----------
#include <cstring>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>

using namespace std;
typedef long long int64;
typedef pair<int, int> PII;
const int MOD = 1000000007;
const double EPSILON = 1e-10;

#define FORU(i, a, b) for (int i = (a); i <= (b); ++i)
#define FORD(i, a, b) for (int i = (a); i >= (b); --i)
#define REPU(i, a, b) for (int i = (a); i < (b); ++i)
#define REPD(i, a, b) for (int i = (a); i > (b); --i)
#define SIZE(A) ((int) A.size())
#define PB(X) push_back(X)
#define MP(A, B) make_pair(A, B)

template<class T> inline T tmin(T a, T b) {return (a < b) ? a : b;}
template<class T> inline T tmax(T a, T b) {return (a > b) ? a : b;}
template<class T> inline T tabs(T a) {return (a > 0) ? a : -a;}
template<class T> T gcd(T a, T b) {if (b == 0) return a; return gcd(b, a % b);}

struct Point {
    int ind, type, val;
};

Point pt[400001];

bool comp(Point x, Point y)
{
    if (x.ind != y.ind) return x.ind < y.ind;
    return x.type < y.type;
}

int main(int argc, char const *argv[])
{	
	ios_base::sync_with_stdio(false);
	int N, M, k, x, y;
    
	cin >> N >> M;
    int cnt = 0;
    REPU(i, 0, M) {
        cin >> x >> y >> k;
        pt[cnt].ind = x;
        pt[cnt].type = 1;
        pt[cnt++].val = k;
        pt[cnt].ind = y+1;
        pt[cnt].type = -1;
        pt[cnt++].val = -k;
    }
    sort(pt, pt + cnt, comp);
    int64 ans = 0, tot = 0;
    REPU(i, 0, cnt) {
        tot += pt[i].val;
        ans = tmax(ans, tot);
    }
    cout << ans << endl;
	return 0;
}
----------
====================
----------
DATA-STRUCTURES.7
easy
----------
PROBLEM STATEMENT:
This challenge is part of a MyCodeSchool tutorial track and is accompanied by a video lesson.



If you're new to linked lists, this is a great exercise for learning about them. Given a pointer to the head node of a linked list, print its elements in order, one element per line. If the head pointer is null (indicating the list is empty), don’t print anything.
----------
TOP SOLUTION:
----------
/*
  Print elements of a linked list on console 
  head pointer input could be NULL as well for empty list
  Node is defined as 
  struct Node
  {
     int data;
     struct Node *next;
  }
*/
void Print(Node *head)
{
     while(head!=NULL)
     {
         cout << head->data << "\n";
         head = head->next;
     }
}
----------
====================
----------
DATA-STRUCTURES.8
easy
----------
PROBLEM STATEMENT:
This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.

You are given the pointer to the head node of a linked list and an integer to add to the list. Create a new node with the given integer. Insert this node at the tail of the linked list and return the head node of the linked list formed after inserting this new node. The given head pointer may be null, meaning that the initial list is empty.
----------
TOP SOLUTION:
----------
/*
  Insert Node at the end of a linked list 
  head pointer input could be NULL as well for empty list
  Node is defined as 
  struct Node
  {
     int data;
     struct Node *next;
  }
*/
Node* Insert(Node *head,int data)
{
    Node * temp=head;
    Node * newN=new Node;
    newN->next=NULL;
    newN->data=data;
    if(temp==NULL)
        return newN;
    while(temp->next!=NULL)
        temp=temp->next;
    temp->next=newN;
    return head;
}
----------
====================
----------
DATA-STRUCTURES.9
easy
----------
PROBLEM STATEMENT:
This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson. 

You’re given the pointer to the head node of a linked list and an integer to add to the list. Create a new node with the given integer, insert this node at the head of the linked list and return the new head node. The head pointer given may be null meaning that the initial list is empty.
----------
TOP SOLUTION:
----------
/*
  Insert Node at the begining of a linked list
  Initially head pointer argument could be NULL for empty list
  Node is defined as 
  struct Node
  {
     int data;
     struct Node *next;
  }
return back the pointer to the head of the linked list in the below method.
*/
Node* Insert(Node *head,int data)
{
    Node *newN=new Node;
    newN->data=data;
    newN->next=head;
    return newN;
    
}
----------
====================
----------
DATA-STRUCTURES.10
easy
----------
PROBLEM STATEMENT:
This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.

You’re given the pointer to the head node of a linked list, an integer to add to the list and the position at which the integer must be inserted. Create a new node with the given integer, insert this node at the desired position and return the head node.  

A position of 0 indicates head, a position of 1 indicates one node away from the head and so on. The head pointer given may be null meaning that the initial list is empty.  

As an example, if your list starts as [expression]

Function Description
Complete the function insertNodeAtPosition in the editor below.  It must return a reference to the head node of your finished list.

insertNodeAtPosition has the following parameters:


head: a SinglyLinkedListNode pointer to the head of the list
data: an integer value to insert as data in your new node
position: an integer position to insert the new node, zero based indexing

----------
TOP SOLUTION:
----------
/*
  Insert Node at a given position in a linked list 
  The linked list will not be empty and position will always be valid
  First element in the linked list is at position 0
  Node is defined as 
  struct Node
  {
     int data;
     struct Node *next;
  }
*/
Node* InsertNth(Node *head, int data, int position)
{
    if(position == 0){
        Node* a = (Node*)malloc(sizeof(Node));
        a->data = data;
        a->next = head;
        return a;
    }else{
        int i;
        Node* a = head;
        for(i = 1; i < position; i++)
            a = a->next;
        Node* tmp = (Node*)malloc(sizeof(Node));
        tmp->data = data;
        tmp->next = a->next;
        a->next = tmp;
        return head;
    }
}
----------
====================
----------
DATA-STRUCTURES.11
easy
----------
PROBLEM STATEMENT:
This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.

You’re given the pointer to the head node of a linked list and the position of a node to delete. Delete the node at the given position and return the head node. A position of 0 indicates head, a position of 1 indicates one node away from the head and so on. The list may become empty after you delete the node.
----------
TOP SOLUTION:
----------
/*
  Delete Node at a given position in a linked list 
  Node is defined as 
  struct Node
  {
     int data;
     struct Node *next;
  }
*/
Node* Delete(Node *head, int position)
{
  // Complete this method
    Node *prev = NULL;
    Node *ptr = head;
    
    int pos = 0;
    
    if(position==0)
    {
        head=head->next;
        delete (ptr);
    }
    else
    {
        while(position!=pos)
        {
            ++pos;
            prev=ptr;
            ptr=ptr->next;
        }
        
        if(ptr!=NULL)
        {
            prev->next=ptr->next;
            delete (ptr);
        }
    }
    return head;
}
----------
====================
----------
DATA-STRUCTURES.12
easy
----------
PROBLEM STATEMENT:
This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.

You are given the pointer to the head node of a linked list and you need to print all its elements in reverse order from tail to head, one element per line. The head pointer may be null meaning that the list is empty - in that case, do not print anything!
----------
TOP SOLUTION:
----------
/*
  Print elements of a linked list in reverse order as standard output
  head pointer could be NULL as well for empty list
  Node is defined as 
  struct Node
  {
     int data;
     struct Node *next;
  }
*/
void ReversePrint(Node *head)
{
  // This is a "method-only" submission. 
  // You only need to complete this method. 
    if(head!=NULL)
    {
        ReversePrint(head->next);
        cout<<head->data<<"\n";
    }
   
}
----------
====================
----------
DATA-STRUCTURES.13
easy
----------
PROBLEM STATEMENT:
This challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.

You’re given the pointer to the head node of a linked list. Change the next pointers of the nodes so that their order is reversed. The head pointer given may be null meaning that the initial list is empty.
----------
TOP SOLUTION:
----------
/*
  Reverse a linked list and return pointer to the head
  The input list will have at least one element  
  Node is defined as 
  struct Node
  {
     int data;
     struct Node *next;
  }
*/
Node* Reverse(Node *head)
{
  // Complete this method
    Node* prev   = NULL;
    Node* current = head;
    Node* next;
    
    while (current != NULL)
    {
        next  = current->next;  
        current->next = prev;   
        prev = current;
        current = next;
    }
    
    return prev;
}
----------
====================
----------
DATA-STRUCTURES.14
easy
----------
PROBLEM STATEMENT:
This challenge is part of a tutorial track by MyCodeSchool

You’re given the pointer to the head nodes of two linked lists. Compare the data in the nodes of the linked lists to check if they are equal. The lists are equal only if they have the same number of nodes and corresponding nodes contain the same data. Either head pointer given may be null meaning that the corresponding list is empty.
----------
TOP SOLUTION:
----------
/*
  Compare two linked lists A and B
  Return 1 if they are identical and 0 if they are not. 
  Node is defined as 
  struct Node
  {
     int data;
     struct Node *next;
  }
*/
int CompareLists(Node *headA, Node* headB)
{
  // This is a "method-only" submission. 
  // You only need to complete this method 
    int flag=0;
    
    while(headA != NULL && headB != NULL)
    {
        if(headA->data!=headB->data)
        {
            flag=1;
            break;
        }
        headA = headA->next;
        headB = headB->next;
    }
    
    if(flag==1 || headA!=NULL || headB!=NULL)
        return 0;
    else
        return 1;
        
        
}
----------
====================
----------
DATA-STRUCTURES.15
easy
----------
PROBLEM STATEMENT:
This challenge is part of a tutorial track by MyCodeSchool

You’re given the pointer to the head nodes of two sorted linked lists. The data in both lists will be sorted in ascending order. Change the next pointers to obtain a single, merged linked list which also has data in ascending order. Either head pointer given may be null meaning that the corresponding list is empty.
----------
TOP SOLUTION:
----------
/*
  Merge two sorted lists A and B as one linked list
  Node is defined as 
  struct Node
  {
     int data;
     struct Node *next;
  }
*/
Node* MergeLists(Node *a, Node*b)
{
  // This is a "method-only" submission. 
  // You only need to complete this method 
    Node* result = NULL;
 
  /* Base cases */
  if (a == NULL) 
     return(b);
  else if (b==NULL) 
     return(a);
 
  /* Pick either a or b, and recur */
  if (a->data <= b->data) 
  {
     result = a;
     result->next = MergeLists(a->next, b);
  }
  else
  {
     result = b;
     result->next = MergeLists(a, b->next);
  }
  return(result);
}
----------
====================
----------
DATA-STRUCTURES.16
easy
----------
PROBLEM STATEMENT:
This challenge is part of a tutorial track by MyCodeSchool

You’re given the pointer to the head node of a linked list and a specific position. Counting backwards from the tail node of the linked list, get the value of the node at the given position. A position of 0 corresponds to the tail, 1 corresponds to the node before the tail and so on.
----------
TOP SOLUTION:
----------
/*
  Get Nth element from the end in a linked list of integers
  Number of elements in the list will always be greater than N.
  Node is defined as 
  struct Node
  {
     int data;
     struct Node *next;
  }
*/
int GetNode(Node *head,int positionFromTail)
{
  // This is a "method-only" submission. 
  // You only need to complete this method. 
    
    int count = 0;
    
    Node *ptr = head;
    
    while(ptr!=NULL)
    {
        ++count;
        ptr=ptr->next;
    }
    
    count = count-positionFromTail;
    
    ptr=head;
    --count;
    
    while(count!=0)
    {
        --count;
        ptr=ptr->next;
    }
    
    return ptr->data;
}
----------
====================
----------
DATA-STRUCTURES.17
easy
----------
PROBLEM STATEMENT:
This challenge is part of a tutorial track by MyCodeSchool

You're given the pointer to the head node of a sorted linked list, where the data in the nodes is in ascending order. Delete as few nodes as possible so that the list does not contain any value more than once. The given head pointer may be null indicating that the list is empty.
----------
TOP SOLUTION:
----------
/*
  Remove all duplicate elements from a sorted linked list
  Node is defined as 
  struct Node
  {
     int data;
     struct Node *next;
  }
*/
Node* RemoveDuplicates(Node *head)
{
  // This is a "method-only" submission. 
  // You only need to complete this method. 
    
    Node *ptr = head,*temp=NULL,*tmp=NULL;
    
    while(ptr!=NULL && ptr->next!=NULL)
    {
        temp = ptr->next;
        ptr->next=NULL;
        
        while(temp!=NULL && ptr->data == temp->data)
        {
            tmp=temp;
            temp=temp->next;
            
            tmp->next=NULL;
            delete(tmp);
        }
        ptr->next = temp;
        ptr = temp;
    }
    
    return head;
}
----------
====================
----------
DATA-STRUCTURES.18
medium
----------
PROBLEM STATEMENT:
A linked list is said to contain a cycle if any node is visited more than once while traversing the list. 

Complete the function provided for you in your editor. It has one parameter: a pointer to a Node object named [expression] that points to the head of a linked list. Your function must return a boolean denoting whether or not there is a cycle in the list. If there is a cycle, return true; otherwise, return false.

Note: If the list is empty, [expression] will be null.
----------
TOP SOLUTION:
----------
/*
  Detect loop in a linked list 
  List could be empty also
  Node is defined as 
  struct Node
  {
     int data;
     struct Node *next;
  }
*/
int HasCycle(Node* head)
{
   // Complete this function
   // Do not write the main method
    Node  *slowp = head, *fastp = head;
 
    while (slowp && fastp && fastp->next)
    {
        slowp = slowp->next;
        fastp  = fastp->next->next;
 
        if (slowp == fastp)
        {
            return 1;
        }
    }

    return 0;
}
----------
====================
----------
DATA-STRUCTURES.19
easy
----------
PROBLEM STATEMENT:
This challenge is part of a tutorial track by MyCodeSchool



Given pointers to the head nodes of [expression] linked lists that merge together at some point, find the Node where the two lists merge. It is guaranteed that the two head Nodes will be different, and neither will be NULL.

In the diagram below, the two lists converge at Node x:

[List #1] a---b---c
                     \
                      x---y---z---NULL
                     /
     [List #2] p---q


Complete the int findMergeNode(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) method so that it finds and returns the data value of the Node where the two lists merge. 
----------
TOP SOLUTION:
----------
/*
   Find merge point of two linked lists
   Node is defined as
   struct Node
   {
       int data;
       Node* next;
   }
*/
int getCount(Node* head)
{
  Node* current = head;
  int count = 0;
 
  while (current != NULL)
  {
    count++;
    current = current->next;
  }
 
  return count;
}

int getNode(int d, Node* head1, Node* head2)
{
  int i;
  Node* current1 = head1;
  Node* current2 = head2;
 
  for(i = 0; i < d; i++)
  {
    if(current1 == NULL)
    {  return -1; }
    current1 = current1->next;
  }
 
  while(current1 !=  NULL && current2 != NULL)
  {
    if(current1 == current2)
      return current1->data;
    current1= current1->next;
    current2= current2->next;
  }
 
  return -1;
}

int FindMergeNode(Node *headA, Node *headB)
{
    // Complete this function
    // Do not write the main method. 
    int c1 = getCount(headA);
  int c2 = getCount(headB);
  int d;
 
  if(c1 > c2)
  {
    d = c1 - c2;
    return getNode(d, headA, headB);
  }
  else
  {
    d = c2 - c1;
    return getNode(d, headB, headA);
  }
}
----------
====================
----------
DATA-STRUCTURES.20
easy
----------
PROBLEM STATEMENT:
Given a reference to the head of a doubly-linked list and an integer, [expression] and insert it into a sorted linked list while maintaining the sort.

Function Description

Complete the sortedInsert function in the editor below. It must return a reference to the head of your modified DoublyLinkedList.

sortedInsert has two parameters:


head: A reference to the head of a doubly-linked list of DoublyLinkedListNode objects.
data: An integer denoting the value of the [expression] field for the DoublyLinkedListNode you must insert into the list.


Note: Recall that an empty list (i.e., where [expression]) and a list with one element are sorted lists. 
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
DATA-STRUCTURES.21
easy
----------
PROBLEM STATEMENT:
This challenge is part of a tutorial track by MyCodeSchool

You’re given the pointer to the head node of a doubly linked list. Reverse the order of the nodes in the list. The head node might be NULL to indicate that the list is empty.  Change the next and prev pointers of all the nodes so that the direction of the list is reversed. Return a reference to the head node of the reversed list. 

Function Description

Complete the reverse function in the editor below.  It should return a reference to the head of your reversed list.

reverse has the following parameter(s):


head: a reference to the head of a DoublyLinkedList

----------
TOP SOLUTION:
----------
/*
   Reverse a doubly linked list, input list may also be empty
   Node is defined as
   struct Node
   {
     int data;
     Node *next;
     Node *prev
   }
*/
Node* Reverse(Node* head)
{
    // Complete this function
    // Do not write the main method. 
    
    Node *temp = NULL;  
     Node *current = head;
      
     /* swap next and prev for all nodes of 
       doubly linked list */
     while (current !=  NULL)
     {
       temp = current->prev;
       current->prev = current->next;
       current->next = temp;              
       current = current->prev;
     }      
      
     /* Before changing head, check for the cases like empty 
        list and list with only one node */
     if(temp != NULL )
        head = temp->prev;
    
    return head;
}
----------
====================
----------
DATA-STRUCTURES.22
easy
----------
PROBLEM STATEMENT:
Complete the preOrder function in your editor below, which has [expression] parameter: a pointer to the root of a binary tree. It must print the values in the tree's preorder traversal as a single line of space-separated values.  
----------
TOP SOLUTION:
----------
void Preorder(node *root) {
    if (!root) return;
    printf("%d ", root->data);
    Preorder(root->left);
    Preorder(root->right);
}

----------
====================
----------
DATA-STRUCTURES.23
easy
----------
PROBLEM STATEMENT:
Complete the postOrder function in your editor below, which has [expression] parameter: a pointer to the root of a binary tree. It must print the values in the tree's postorder traversal as a single line of space-separated values.  
----------
TOP SOLUTION:
----------
/* you only have to complete the function given below.  
Node is defined as  

struct node
{
    int data;
    node* left;
    node* right;
};

*/


void Postorder(node *root) {
    if (!root) return;
    Postorder(root->left);
    Postorder(root->right);
    printf("%d ", root->data);
}

----------
====================
----------
DATA-STRUCTURES.24
easy
----------
PROBLEM STATEMENT:
Complete the inOrder function in your editor below, which has [expression] parameter: a pointer to the root of a binary tree. It must print the values in the tree's inorder traversal as a single line of space-separated values.  
----------
TOP SOLUTION:
----------
/* you only have to complete the function given below.  
Node is defined as  

struct node
{
    int data;
    node* left;
    node* right;
};

*/

void Inorder(node *root) {
    if (!root) return;
    Inorder(root->left);
    printf("%d ", root->data);
    Inorder(root->right);
}

----------
====================
----------
DATA-STRUCTURES.25
easy
----------
PROBLEM STATEMENT:
The height of a binary tree is the number of edges between the tree's root and its furthest leaf.  For example, the following binary tree is of height [expression]:

 
Function Description

Complete the getHeight or height function in the editor.  It must return the height of a binary tree as an integer.

getHeight or height has the following parameter(s):


root: a reference to the root of a binary tree.    


Note -The Height of binary tree with single node is taken as zero.  
----------
TOP SOLUTION:
----------

/*The tree node has data, left child and right child 
struct node
{
    int data;
    node* left;
    node* right;
};

*/
int height(node * root)
{
  if(root==NULL) return 0;
    else
        {
        int l=height(root->left);
        int r=height(root->right);
        if(l>r)
            return l+1;
        else
            return r+1;
    }
}
  

----------
====================
----------
DATA-STRUCTURES.26
easy
----------
PROBLEM STATEMENT:
You are given a pointer to the root of a binary tree. Print the top view of the binary tree. 
Top view means when you look the tree from the top the nodes, what you will see will be called the top view of the tree. See the example below. 
You only have to complete the function. 
For example :

   1
    \
     2
      \
       5
      /  \
     3    6
      \
       4


Top View : 1 - 2 - 5 - 6
----------
TOP SOLUTION:
----------
/*
struct node
{
    int data;
    node* left;
    node* right;
};

*/

int w_min=-1,w_max=1,w=0;
void inorder(node *root,int w)
    { 
    if(root==NULL) return;
    if(w<w_min) w_min=w;
    if(w>w_max) w_max=w;
    if(root->left!=NULL) inorder(root->left,w-1);
    if(root->right!=NULL) inorder(root->right,w+1);
}
void top(node *root,int arr[],int w,int h,int arr2[])
    {
    if(root==NULL) return;
    if(arr[w-w_min]==0 || h<arr2[w-w_min])
        {
        arr2[w-w_min]=h;
       arr[w-w_min]=root->data;     
        }
    if(root->left!=NULL) top(root->left,arr,w-1,h+1,arr2);
    if(root->right!=NULL) top(root->right,arr,w+1,h+1,arr2);
}
void top_view(node * root)
{   
 inorder(root,0);
    int arr[w_max-w_min+1],arr1[w_max-w_min+1];
    for(int i=0;i<w_max-w_min+1;i++)
        {
        arr[i]=0;
        arr1[i]=90;
    }
  top(root,arr,0,1,arr1);
  for(int i=0;i<w_max-w_min+1;i++)
        {
      cout<<arr[i]<<" ";
    }  
}


----------
====================
----------
DATA-STRUCTURES.27
easy
----------
PROBLEM STATEMENT:
You are given a pointer to the root of a binary tree. You need to print the level order traversal of this tree. In level order traversal, we visit the nodes level by level from left to right. 
You only have to complete the function. 
For example:

     1
      \
       2
        \
         5
        /  \
       3    6
        \
         4  


For the above tree, the level order traversal is 1 - 2 - 5 - 3 - 6 - 4.
----------
TOP SOLUTION:
----------

/*
struct node
{
    int data;
    node* left;
    node* right;
}*/
int height(node * root)
{
  if(!root)
      return 0;
    int lleft=height(root->left);
    int rright=height(root->right);
    if(lleft > rright)
        return(lleft+1);
    else
        return (rright+1);
}
  void level(node *root,int h){
      if(!root)
          return ;
      if(h==1)
          cout<<root->data<<" ";
      level(root->left,h-1);
      level(root->right,h-1);
  }
void LevelOrder(node * root)
{
  int n=height(root);
    for(int i=1;i<=n;i++){
        level(root,i);
        
    }
  
}

----------
====================
----------
DATA-STRUCTURES.28
easy
----------
PROBLEM STATEMENT:
You are given a pointer to the root of a binary search tree and values to be inserted into the tree. Insert the values into their appropriate position in the binary search tree and return the root of the updated binary tree.
You just have to complete the function.
----------
TOP SOLUTION:
----------
/*
Node is defined as 

typedef struct node
{
   int data;
   node * left;
   node * right;
}node;

*/
#include<queue>
queue<node *> Queue;

node * insert(node * root, int value)
{
   node *n=new node();
    n->data=value;
    n->left=NULL;
    n->right=NULL;
    if(!root){
        root=n;
        return root;
    }
    node *temp=root;   
    while(1){
        if(temp->data > n->data){
            if(temp->left)
                temp=temp->left;
               else{
                temp->left=n;
                break;
            }
        }
        else
            {
            if(temp->right)
                temp=temp->right;
            else
                {
                temp->right=n;
                break;
            }
        }
    }
   return root;
}

----------
====================
----------
DATA-STRUCTURES.29
medium
----------
PROBLEM STATEMENT:
Huffman coding assigns variable length codewords to fixed length input characters based on their frequencies. More frequent characters are assigned shorter codewords and less frequent characters are assigned longer codewords. All edges along the path to a character contain a code digit.  If they are on the left side of the tree, they will be a 0 (zero).  If on the right, they'll be a 1 (one).  Only the leaves will contain a letter and its frequency count.  All other nodes will contain a null instead of a character, and the count of the frequency of all of it and its descendant characters.

For instance, consider the string ABRACADABRA.  There are a total of [expression]'s for the edges.  The finished graph looks like:  



Input characters are only present in the leaves. Internal nodes have a character value of ϕ (NULL).  We can determine that our values for characters are:  

A - 0
B - 111
C - 1100
D - 1101
R - 10


Our Huffman encoded string is:

A B    R  A C     A D     A B    R  A
0 111 10 0 1100 0 1101 0 111 10 0
or
01111001100011010111100


To avoid ambiguity, Huffman encoding is a prefix free encoding technique.  No codeword appears as a prefix of any other codeword.  

To decode the encoded string, follow the zeros and ones to a leaf and return the character there.  

You are given pointer to the root of the Huffman tree and a binary coded string to decode. You need to print the decoded string.

Function Description

Complete the function decode_huff in the editor below.  It must return the decoded string.

decode_huff has the following parameters:  


root: a reference to the root node of the Huffman tree
s: a Huffman encoded string

----------
TOP SOLUTION:
----------
/* 
The structure of the node is

typedef struct node
{
    int freq;
    char data;
    node * left;
    node * right;
    
}node;

*/


void decode_huff(node * root,string s)
{
   
   node *treeroot = root;
  // char *result = (char*)malloc(sizeof(char)*len);
    int i=0,k=0;
   while (s[i]!='\0'){
    //   printf("s[%d]%c\n", i, s[i]);
      
       if (s[i]== '1' ){
          
           root=root->right;
         //  printf("i was here");
           if (root->data != '\0'){
           //    printf("i was here");
                 printf("%c", root->data);
                 root = treeroot;
                 
                             
            }
          i++;
       }
       else {
          
           root=root->left;
            if (root->data != '\0'){
                 printf("%c", root->data);
                root = treeroot;
                 
                             
            }
          i++;
       }
       
       
       
       
       
   }
    
    
    
}

----------
====================
----------
DATA-STRUCTURES.30
easy
----------
PROBLEM STATEMENT:
You are given pointer to the root of the binary search tree and two values [expression] in the binary search tree.  

 
In the diagram above, the lowest common ancestor of the nodes [expression] as descendants.

Function Description  

Complete the function lca in the editor below.  It should return a pointer to the lowest common ancestor node of the two values given.  

lca has the following parameters: 
-  root: a pointer to the root node of a binary search tree 
-  v1: a node.data value 
-  v2: a node.data value  
----------
TOP SOLUTION:
----------
/*
Node is defined as 

typedef struct node
{
   int data;
   node * left;
   node * right;
}node;

*/
bool isPresent(struct node* tree, int k)
{
	if(tree==NULL)
		return false;
	if(tree->data==k)
		return true;
	return isPresent(tree->left,k) || isPresent(tree->right,k);
}


node * lca(node * tree, int m,int n)
{
    
	if(tree==NULL)
		return NULL;
	if(tree->data>m && tree->data>n)
		return lca(tree->left,m,n);
	if(tree->data<m && tree->data<n)
		return lca(tree->right,m,n);
	if(tree->data<m && tree->data>n)
	{
		if(isPresent(tree->left,n) && isPresent(tree->right,m))
		{
			return tree;
		}
		else 
			return NULL;
	}
	if(tree->data>m && tree->data<n)
	{
		if(isPresent(tree->left,m) && isPresent(tree->right,n))
		{
			return tree;
		}
		else 
			return NULL;
	}
	if(tree->data==m)
	{
		if(tree->data<n)
		{
			if(isPresent(tree->right,n))
				return tree;
			else
				return NULL;
		}
		if(tree->data>n)
		{
			if(isPresent(tree->left,n))
				return tree;
			else
				return NULL;
		}
		if(tree->data==n)
			return tree;
	}
	if(tree->data==n)
	{
		if(tree->data<m)
		{
			if(isPresent(tree->right,m))
				return tree;
			else
				return NULL;
		}
		if(tree->data>m)
		{
			if(isPresent(tree->left,m))
				return tree;
			else
				return NULL;
		}
		if(tree->data==m)
			return tree;
	}

    
	return NULL;
	
}


   

----------
====================
----------
DATA-STRUCTURES.31
medium
----------
PROBLEM STATEMENT:
A binary tree is a tree which is characterized by one of the following properties:


It can be empty (null).
It contains a root node only.
It contains a root node with a left subtree, a right subtree, or both. These subtrees are also binary trees.


In-order traversal is performed as


Traverse the left subtree.
Visit root.
Traverse the right subtree.


For this in-order traversal, start from the left child of the root node and keep exploring the left subtree until you reach a leaf.  When you reach a leaf, back up to its parent, check for a right child and visit it if there is one.  If there is not a child, you've explored its left and right subtrees fully. If there is a right child, traverse its left subtree then its right in the same manner.  Keep doing this until you have traversed the entire tree.  You will only store the values of a node as you visit when one of the following is true:


it is the first node visited, the first time visited 
it is a leaf, should only be visited once  
all of its subtrees have been explored, should only be visited once while this is true  
it is the root of the tree, the first time visited  


Swapping: Swapping subtrees of a node means that if initially node has left subtree L and right subtree R, then after swapping, the left subtree will be R and the right subtree, L.

For example, in the following tree, we swap children of node 1.

                                Depth
    1               1            [1]
   / \             / \
  2   3     -    3   2          [2]
   \   \           \   \
    4   5           5   4        [3]


In-order traversal of left tree is 2 4 1 3 5 and of right tree is 3 5 1 2 4.

Swap operation: 

We define depth of a node as follows:


The root node is at depth 1.
If the depth of the parent node is d, then the depth of current node will be d+1.


Given a tree and an integer, k, in one operation, we need to swap the subtrees of all the nodes at each depth h, where h ∈ [k, 2k, 3k,...].  In other words, if h is a multiple of k, swap the left and right subtrees of that level.

You are given a tree of n nodes where nodes are indexed from [1..n] and it is rooted at 1. You have to perform t swap operations on it, and after each swap operation print the in-order traversal of the current state of the tree.

Function Description

Complete the swapNodes function in the editor below.  It should return a two-dimensional array where each element is an array of integers representing the node indices of an in-order traversal after a swap operation.

swapNodes has the following parameter(s): 
- indexes: an array of integers representing index values of each [expression], the first element, as the root. 
- queries: an array of integers, each representing a [expression] value.

Input Format 
The first line contains n, number of nodes in the tree.   

Each of the next n lines contains two integers, a b, where a is the index of left child, and b is the index of right child of ith node.   

Note: -1 is used to represent a null node.   

The next line contains an integer, t, the size of [expression]. 
Each of the next t lines contains an integer [expression].  

Output Format 
For each k, perform the swap operation and store the indices of your in-order traversal to your result array.  After all swap operations have been performed, return your result array for printing.  

Constraints  


[expression]    
[expression]  
[expression]  
Either [expression]  
Either [expression]  
The index of a non-null child will always be greater than that of its parent.  


Sample Input 0  

3
2 3
-1 -1
-1 -1
2
1
1


Sample Output 0  

3 1 2
2 1 3


Explanation 0

As nodes 2 and 3 have no children, swapping will not have any effect on them. We only have to swap the child nodes of the root node.

    1   [s]       1    [s]       1   
   / \      -   / \        -  / \  
  2   3 [s]     3   2  [s]     2   3


Note:  [s] indicates that a swap operation is done at this depth.

Sample Input 1  

5
2 3
-1 4
-1 5
-1 -1
-1 -1
1
2


Sample Output 1  

4 2 1 5 3


Explanation 1

Swapping child nodes of node 2 and 3 we get

    1                  1  
   / \                / \ 
  2   3   [s]  -    2   3
   \   \            /   / 
    4   5          4   5  


Sample Input 2  

11
2 3
4 -1
5 -1
6 -1
7 8
-1 9
-1 -1
10 11
-1 -1
-1 -1
-1 -1
2
2
4


Sample Output 2  

2 9 6 4 1 3 7 5 11 8 10
2 6 9 4 1 3 7 5 10 8 11


Explanation 2  

Here we perform swap operations at the nodes whose depth is either 2 or 4 for [expression].

         1                     1                          1             
        / \                   / \                        / \            
       /   \                 /   \                      /   \           
      2     3    [s]        2     3                    2     3          
     /      /                \     \                    \     \         
    /      /                  \     \                    \     \        
   4      5          -        4     5          -        4     5       
  /      / \                  /     / \                  /     / \      
 /      /   \                /     /   \                /     /   \     
6      7     8   [s]        6     7     8   [s]        6     7     8
 \          / \            /           / \              \         / \   
  \        /   \          /           /   \              \       /   \  
   9      10   11        9           11   10              9     10   11 

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
vector<int> leftNode, rightNode;
int swapLevel;

void traverse(int node=1){
    if (node == -1) return;
    traverse(leftNode[node]);
    cout << node << " ";
    traverse(rightNode[node]);
    if (node == 1) cout << endl;
}

void swap(int level=1, int node=1) {
	if (node == -1) return;
	if (level % swapLevel == 0) {
		int tmp = leftNode[node];
		leftNode[node] = rightNode[node];
		rightNode[node] = tmp;
	}
	swap(level+1, leftNode[node]);
	swap(level+1, rightNode[node]);
}

int main() {
    int count;    
    cin>>count;
	leftNode.push_back(0);
    rightNode.push_back(0);
    while(count--){
        int L, R;
        cin>>L>>R;
        leftNode.push_back(L);
        rightNode.push_back(R);
    }
    cin>>count;
    while(count--){
		cin >> swapLevel;
		swap();
		traverse();
	}
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.32
advanced
----------
PROBLEM STATEMENT:
Kitty has a tree, [expression] distinct nodes. Kitty needs to calculate the following expression on each set:

[expression]

where:


[expression] denotes an unordered pair of nodes belonging to the set.
[expression].


Given [expression] on a new line.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

const int mod = 1e9 + 7;

const int maxn = 2e5 + 10;

vector<int> G[maxn];
vector<int> Q[maxn];
map<int, pair<int, int> > Node[maxn];
int dis[maxn];
int ans[maxn];

void update(int &a, int b)
{
	a += b;
	if (a >= mod)
		a -= mod;
}

void dfs(int u, int fa)
{
	for (int v : G[u])
	{
		if (v == fa)
			continue;
		dis[v] = dis[u] + 1;
		dfs(v, u);
	}
	for (int v : Q[u])
		Node[u][v] = make_pair(u, 1ll * dis[u] * u % mod);
	for (int v : G[u])
	{
		if (Node[u].size() < Node[v].size())
			swap(Node[u], Node[v]);
		for (auto p : Node[v])
		{
			int i = p.first;
			auto it = Node[u].find(i);
			if (it == Node[u].end())
			{
				Node[u].insert(p);
				continue;
			}
			long long a = p.second.first, b = p.second.second, c = it->second.first, d = it->second.second;
			update(ans[i], (a * d % mod + b * c % mod + mod - (2 * dis[u] * a % mod * c % mod) % mod) % mod);
			update(it->second.first, a);
			update(it->second.second, b);
		}
	}
}

int main()
{
	int n, q;
	scanf("%d %d", &n, &q);
	for (int i = 1; i < n; ++i)
	{
		int u, v;
		scanf("%d %d", &u, &v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	for (int i = 0; i < q; ++i)
	{
		int k;
		scanf("%d", &k);
		while (k--)
		{
			int u;
			scanf("%d", &u);
			Q[u].push_back(i);
		}
	}
	dfs(1, 0);
	for (int i = 0; i < q; ++i)
		printf("%d\n", ans[i]);
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.33
medium
----------
PROBLEM STATEMENT:
For the purposes of this challenge, we define a binary tree to be a binary search tree with the following ordering requirements:


The [expression] value of every node in a node's left subtree is less than the data value of that node.
The [expression] value of every node in a node's right subtree is greater than the data value of that node.


Given the root node of a binary tree, can you determine if it's also a binary search tree? 

Complete the function in your editor below, which has [expression] parameter: a pointer to the root of a binary tree. It must return a boolean denoting whether or not the binary tree is a binary search tree. You may have to write one or more helper functions to complete this challenge.
----------
TOP SOLUTION:
----------
/* Hidden stub code will pass a root argument to the function below. Complete the function to solve the challenge. Hint: you may want to write one or more helper functions.  

The Node struct is defined as follows:
	struct Node {
		int data;
		Node* left;
		Node* right;
	}
*/
 
    /* Returns true if root is a BST, with min <= values <= max */
    bool checkBSTUtil(struct Node* node, int min, int max) { 
      if (node==NULL) 
         return true;

      if (node->data < min || node->data > max) 
         return false; 

      return checkBSTUtil(node->left, min, node->data-1) && checkBSTUtil(node->right, node->data+1, max); 
    } 

	bool checkBST(Node* root) {
        return (checkBSTUtil(root, -1, 1000000)); 
	}
----------
====================
----------
DATA-STRUCTURES.34
hard
----------
PROBLEM STATEMENT:
The square-ten tree decomposition of an array is defined as follows:


The lowest ([expression]) level of the square-ten tree consists of single array elements in their natural order.
The [expression], etc.


In other words, every [expression]) of square-ten tree consists of array subsegments indexed as: 
[expression]
Level [expression].

The image below depicts the bottom-left corner (i.e., the first [expression] array elements) of the table representing a square-ten tree. The levels are numbered from bottom to top:



Task 
Given the borders of array subsegment [expression] is minimal amongst all such variants.
----------
TOP SOLUTION:
----------
//#pragma comment(linker, "/STACK:60777216")  

#include <cassert>
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<complex>
#include<vector>
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<string>
#include<cstdlib>
#include<memory.h>
#include<ctime>
#include<bitset>
#include<fstream>
#include<queue>
#include<stack>
#include <unordered_map>

using namespace std;

typedef long double ld;

typedef long long ll;
typedef pair<int,int>	pii;
typedef pair<ld,ld>	pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
typedef pair<ll,ll> pl;

#define FOR(i,a,b)		for(int i=(a);i<(b);i++)
#define REP(i,n)		FOR(i,0,n)
#define R(i,n)			REP(i,n)
#define SORT(v)			sort((v).begin(),(v).end())
#define UN(v)			SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b)				memset(a,b,sizeof a)
#define pb				push_back

const int LIM = 2000000;
struct BigInt{
	int a[LIM+1];
	BigInt(){
		CL(a,0);
	}
};

vi res_level;
vector<string> res_number; 


string l,r;


string sub(string t1,string t2){
	REP(i,t1.size()) {
		t1[i]-=(t2[i]-'0');
		if(t1[i]<'0'){
			t1[i]+=10;
			t1[i+1]--;
		}
	}
	return t1;
}
void sub1(string& s){
	s[0]--;
	REP(i,s.size()){
		if(s[i]<'0'){
			s[i]+=10;
			s[i+1]--;
		}else break;
	}
	while(s.size()>1 && s.back()=='0')s.pop_back();
}

void add1(string& t){
	t.pb('0');
	t[0]++;
	REP(i,t.size()){
		if(t[i]>'9'){
			t[i]-=10;
			t[i+1]++;
		}else break;
	}
	while(t.back()=='0')t.pop_back();
}

void solve(string l, string r, int level){
	if(l.empty()) return;
	while(l.size() > 1 && r.size() > 0 && l.back()=='0' && r.back()=='0')l.pop_back(),r.pop_back();
	int len = level == 0 ? 1 : ((1<<(level-1))+1);
	//cout<<level<<' '<<len<<' '<<l.size()<<' '<<r.size()<<' '<<l<<' '<<r<<endl;
	
	if(l == string(len-1,'0') && r==string(len-1,'9')){
		res_level.pb(level);
		res_number.pb("1");
		return;
	}

	if (l.size() < len) {
		solve(l,r,level-1);
		return;
	}


	string s1 = l.substr(len-1);
	string s2 = r.substr(len-1);
	l=l.substr(0,len-1);
	r=r.substr(0,len-1);
			
	if (s1 == s2) {
		if (level==0){
			//cout<<s1<<' '<<s2<<' '<<l<<' '<<r<<endl;
			res_level.pb(0);
			res_number.pb("1");
		}else{
			solve(l,r,level-1);
		}
		return;
	}else{
		string t = sub(s2,s1);
		sub1(t);

		if (l == string(len-1,'0')) {
			add1(t);
		} else solve(l,string(len-1,'9'),level-1);

		if (r == string(len-1,'9')) add1(t);


		if(t==string(t.size(),'0')){
		}else{
			res_level.pb(level);
			res_number.pb(t);
		}

		if(r==string(len-1,'9'));
		else solve(string(len-1,'0'),r,level-1);
	}
}


int main(){	
#ifdef LocalHost
	freopen("input.txt","r",stdin);
	//1freopen("output.txt","w",stdout);
#endif
	
	getline(cin,l);
	getline(cin,r);

	reverse(l.begin(),l.end());
	reverse(r.begin(),r.end());

	sub1(l);
	sub1(r);

	l = l+string(r.size()-l.size(),'0');
	solve(l,r,20);


	cout<<res_level.size()<<endl;
	REP(i,res_level.size()){
		string t = res_number[i];
		while(t.size()>0 && t.back()=='0')t.pop_back();
		reverse(t.begin(),t.end());
		printf("%d %s\n",res_level[i],t.c_str());
	}

#ifdef LocalHost
	printf("TIME: %.3lf\n",ld(clock())/CLOCKS_PER_SEC);
#endif
	return 0;
}
----------
====================
----------
DATA-STRUCTURES.35
hard
----------
PROBLEM STATEMENT:
Greg has a tree of nodes containing integer data.  He wants to insert a node with some non-zero integer value somewhere into the tree.  His goal is to be able to cut two edges and have the values of each of the three new trees sum to the same amount.  This is called a balanced forest.  Being frugal, the data value he inserts should be minimal.  Determine the minimal amount that a new node can have to allow creation of a balanced forest.  If it's not possible to create a balanced forest, return -1.

For example, you are given node values [expression].  It is the following tree:  

  

The blue node is root, the first number in a node is node number and the second is its value.  Cuts can be made between nodes [expression] to the third tree completes the solution.  

Function Description

Complete the balancedForest function in the editor below.  It must return an integer representing the minimum value of [expression] if it is not possible.  

balancedForest has the following parameter(s):


c: an array of integers, the data values for each node  
edges: an array of 2 element arrays, the node pairs per edge  

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <vector>
#include <map>
#include <set>
#include <string>
#include <cstdlib>
#include <ctime>
#include <deque>
#include <unordered_set>
using namespace std;

int q;
map <long long, int> Map1, Map2;
long long ctot;
int c[110000];
vector <int> ve[110000];
long long ans;
int n;
long long sum[1100000];

void dfs1(int x, int f) {
	sum[x] = c[x];
	for (int i = 0; i < (int) ve[x].size(); i++)
		if (ve[x][i] != f) {
			dfs1(ve[x][i], x);
			sum[x] += sum[ve[x][i]];
		}
	Map1[sum[x]] += 1;
}

void test(long long x) {
	long long y = ctot - 2 * x;
	if (y > 0 && y <= x)
		ans = min(ans, x - y);
}

void dfs2(int x, int f) {
	

	
	if (Map2[2 * sum[x]])
		test(sum[x]);
	if (Map2[ctot - sum[x]])
		test(sum[x]);
	if ((ctot - sum[x]) % 2 == 0 && Map2[ctot - (ctot - sum[x]) / 2])
		test((ctot - sum[x]) / 2);

	Map2[sum[x]] += 1;

	if (Map1[sum[x]] > Map2[sum[x]])
		test(sum[x]);

	if (ctot - 2 * sum[x] >= sum[x] && Map1[ctot - 2 * sum[x]] > Map2[ctot - 2 * sum[x]])
		test(sum[x]);

	if ((ctot - sum[x]) % 2 == 0 && (ctot - sum[x]) / 2 >= sum[x] && Map1[(ctot - sum[x]) / 2] > Map2[(ctot - sum[x]) / 2])
		test((ctot - sum[x]) / 2);

	if (sum[x] * 2 == ctot)
		ans = min(ans, sum[x]);
	
	for (int i = 0; i < (int) ve[x].size(); i++)
		if (ve[x][i] != f) {
			dfs2(ve[x][i], x);
		}

	Map2[sum[x]] -= 1;
}

int main() {
	scanf("%d", &q);
	while (q--) {
		Map1.clear();
		Map2.clear();
		ans = 1e18;
		scanf("%d", &n);
		ctot = 0;
		for (int i = 1; i <= n; i++) {
			scanf("%d", &c[i]);
			ctot += c[i];
		}
		for (int i = 1; i <= n; i++)
			ve[i].clear();
		for (int i = 1; i < n; i++) {
			int x, y;
			scanf("%d%d", &x, &y);
			ve[x].push_back(y);
			ve[y].push_back(x);
		}
		dfs1(1, 0);
		dfs2(1, 0);
		if (ans == 1e18)
			printf("-1\n");
		else
			printf("%lld\n", ans);
	}
}
----------
====================
----------
DATA-STRUCTURES.36
hard
----------
PROBLEM STATEMENT:
Jenny loves experimenting with trees. Her favorite tree has [expression] from this tree by performing the following two steps:


Choose a node, [expression], from the tree.
Cut a subtree consisting of all nodes which are not further than [expression]. 


For example, the blue nodes in the diagram below depict a subtree centered at [expression]:



Given [expression], and the definition of Jenny's tree, find and print the number of different subtrees she can cut out. Two subtrees are considered to be different if they are not  isomorphic.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <algorithm>
#include <set>
#include <vector>
#include <cstdio>
#include <utility>

using namespace std;

class InputReader {
public:
    InputReader() {
        input_file = stdin;
        cursor = 0;
        fread(buffer, SIZE, 1, input_file);
    }
    inline InputReader &operator >>(int &n) {
        while(buffer[cursor] < '0' || buffer[cursor] > '9') {
            advance();
        }
        n = 0;
        while('0' <= buffer[cursor] && buffer[cursor] <= '9') {
            n = n * 10 + buffer[cursor] - '0';
            advance();
        }
        return *this;
    }
private:
    FILE *input_file;
    static const int SIZE = 1 << 17;
    int cursor;
    char buffer[SIZE];
    inline void advance() {
        ++ cursor;
        if(cursor == SIZE) {
            cursor = 0;
            fread(buffer, SIZE, 1, input_file);
        }
    }
};

const int NMAX = 50000 + 5;

int szzz;
vector <int> tree[NMAX];

int n;
vector <int> graph[NMAX];
int sz[NMAX];

void buildTree(int node, int father, int rem) {
    ++ szzz;
    if (!rem)
        return ;

    for (auto it: graph[node])
        if (it != father) {
            tree[node].push_back(it);
            tree[it].push_back(node);
            buildTree(it, node, rem - 1);
        }
}

vector <int> centroids;

void dfsCentroids(int node, int father) {
    sz[node] = 1;
    int maxSon = -1;
    for (vector <int> :: iterator it = tree[node].begin(); it != tree[node].end(); ++ it)
        if (*it != father) {
            dfsCentroids(*it, node);
            sz[node] += sz[*it];
            if (sz[*it] > maxSon)
                maxSon = sz[*it];
        }

    int maximum = max(maxSon, szzz - sz[node]);
    if (maximum <= szzz / 2)
        centroids.push_back(node);
}

const int MOD1 = 1000000000 + 7;
const int MOD2 = 1000000000 + 21;
const int C1 = 633;
const int C2 = 67;

int powC1[2 * NMAX];
int powC2[2 * NMAX];

pair <int, int> hs[NMAX];

bool cmp(const int &a, const int &b) {
    return hs[a] < hs[b];
}

int ans;
void dfsMorph(int node, int father) {
    //Delete father from adjacency list
    vector <int> :: iterator it = find(tree[node].begin(), tree[node].end(), father);
    if (it != tree[node].end())
        tree[node].erase(it);

    //Solve sons
    sz[node] = 1;
    for (vector <int> :: iterator it = tree[node].begin(); it != tree[node].end(); ++ it) {
        dfsMorph(*it, node);
        sz[node] += sz[*it];
    }

    //Find hash of node
    sort(tree[node].begin(), tree[node].end(), cmp);
    for (vector <int> :: iterator it = tree[node].begin(); it != tree[node].end(); ++ it) {
        hs[node].first = (1LL * powC1[2 * sz[*it]] * hs[node].first + hs[*it].first) % MOD1;
        hs[node].second = (1LL * powC2[2 * sz[*it]] * hs[node].second + hs[*it].second) % MOD2;
    }

    hs[node].first = (1LL * hs[node].first * C1 + 1) % MOD1;
    hs[node].second = (1LL * hs[node].second * C2 + 1) % MOD2;

    if (father != 0)
        tree[node].push_back(father);
}

set <pair <pair <int, int>, pair <int, int> > > Set;

int main()
{
    //freopen("input.in", "r", stdin);
    //InputReader cin;

    int raza;
    cin >> n >> raza;

    powC1[0] = powC2[0] = 1;
    for (int i = 1; i <= 2 * n; ++ i) {
        powC1[i] = (1LL * C1 * powC1[i - 1]) % MOD1;
        powC2[i] = (1LL * C2 * powC2[i - 1]) % MOD2;
    }

    for (int i = 1; i < n; ++ i) {
        int a, b;
        cin >> a >> b;

        graph[a].push_back(b);
        graph[b].push_back(a);
    }

    for (int i = 1; i <= n; ++ i) {
        for (int j = 1; j <= n; ++ j) {
            tree[j].clear();
            hs[j] = make_pair(0, 0);
            sz[j] = 0;
        }
        szzz = 0;
        buildTree(i, 0, raza);

        centroids.clear();
        dfsCentroids(i, 0);

        pair <int, int> h1, h2 = make_pair(-1, -1);
        dfsMorph(centroids[0], 0);
        h1 = hs[centroids[0]];

        if (centroids.size() == 2) {
            for (int j = 1; j <= n; ++ j) {
                hs[j] = make_pair(0, 0);
                sz[j] = 0;
            }

            dfsMorph(centroids[1], 0);
            h2 = hs[centroids[1]];
        }

        if (h2 < h1)
            swap(h2, h1);

        Set.insert(make_pair(h1, h2));
    }

    cout << Set.size() << '\n';
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.37
expert
----------
PROBLEM STATEMENT:
We consider metric space to be a pair, [expression] such that the following conditions hold:


[expression]
[expression]
[expression]
[expression]


where [expression].

Let's define the product of two metric spaces, [expression] such that:


[expression]
[expression].


So, it follows logically that [expression].

For example, [expression].



In this challenge, we need a tree-space. You're given a tree, [expression] is a metric space.

You are given a tree, [expression]. Find and print the distance between the two furthest points in this metric space!
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <vector>
#include <map>
#include <set>
#include <string>
#include <cstdlib>
#include <ctime>
#include <deque>
using namespace std;

#define N 200000

int fa[N][21], dep[N], L[N], R[N], Time, n, m;
vector <int> ve[N], ve1[N];
bool used[N];
int zx, sz;
int sum[N], l[N], c[N];
int ans;
int ma1[N], ma2[N], c1[N], c2[N];
int zhan[N], zhan1[N];

void dfs1(int k, int f) {
	fa[k][0] = f;
	dep[k] = dep[f] + 1;
	for (int i = 1; i <= 20; i++)
		fa[k][i] = fa[fa[k][i - 1]][i - 1];
	L[k] = ++Time;
	for (int i = 0; i < (int) ve[k].size(); i++)
		if (ve[k][i] != f)
			dfs1(ve[k][i], k);
	R[k] = Time;
}

void dfs_size(int k) {
	sum[k] = 1;
	used[k] = true;
	for (int i = 0; i < (int) ve[k].size(); i++)
		if (!used[ve[k][i]]) {
			dfs_size(ve[k][i]);
			sum[k] += sum[ve[k][i]];
		}
	used[k] = false;
}

void dfs_zx(int k) {
	// printf("?? %d %d\n", k, sz);
	bool ok = (sz - sum[k] <= sz / 2);
	used[k] = true;
	for (int i = 0; i < (int) ve[k].size(); i++)
		if (!used[ve[k][i]]) {
			if (sum[ve[k][i]] > sz / 2)
				ok = false;
			dfs_zx(ve[k][i]);
		}
	used[k] = false;
	if (ok)
		zx = k;
}

void dfs_l(int k) {
	used[k] = true;
	for (int i = 0; i < (int) ve[k].size(); i++)
		if (!used[ve[k][i]]) {
			l[ve[k][i]] = l[k] + 1;
			dfs_l(ve[k][i]);
		}
	used[k] = false;
}

void dfs_c(int k) {
	used[k] = true;
	for (int i = 0; i < (int) ve[k].size(); i++)
		if (!used[ve[k][i]]) {
			c[ve[k][i]] = c[k];
			dfs_c(ve[k][i]);
		}
	used[k] = false;
}

bool cmp_c(pair<int, int> x, pair<int, int> y) {
	return c[x.first] < c[y.first];
}

bool cmp_L(int x, int y) {
	return L[x] < L[y];
}

int dist(int x, int y) {
	int ans = 0;
	if (dep[x] < dep[y])
		swap(x, y);
	for (int i = 20; i >= 0; i--)
		if (dep[fa[x][i]] >= dep[y])
			ans += (1 << i), x = fa[x][i];
	if (x == y)
		return ans;
	for (int i = 20; i >= 0; i--)
		if (fa[x][i] != fa[y][i])
			ans += 1 << (i + 1), x = fa[x][i], y = fa[y][i];
	return ans + 2;
}

int lca(int x, int y) {
	int ans = 0;
	if (dep[x] < dep[y])
		swap(x, y);
	for (int i = 20; i >= 0; i--)
		if (dep[fa[x][i]] >= dep[y])
			ans += (1 << i), x = fa[x][i];
	if (x == y)
		return x;
	for (int i = 20; i >= 0; i--)
		if (fa[x][i] != fa[y][i])
			ans += 1 << (i + 1), x = fa[x][i], y = fa[y][i];
	return fa[x][0];
}

void dfs_d(int k) {
	// ma1[k] = -1000000000;
	// ma2[k] = -1000000000;
	// ma1[k] = v[k];
	// c1[k] = c[k];
	// printf("?? %d\n", k);
	for (int i = 0; i < (int) ve1[k].size(); i++) {
		int t = ve1[k][i];
		dfs_d(t);
		ma1[t] += dep[t] - dep[k];
		ma2[t] += dep[t] - dep[k];
		if (c1[k] != c1[t] || !c1[k] || !c1[t])
			ans = max(ans, ma1[k] + ma1[t]);
		if (c1[k] != c2[t] || !c1[k] || !c2[t])
			ans = max(ans, ma1[k] + ma2[t]);

		if (c2[k] != c1[t] || !c2[k] || !c1[t])
			ans = max(ans, ma2[k] + ma1[t]);

		if (c2[k] != c2[t] || !c2[k] || !c2[t])
			ans = max(ans, ma2[k] + ma2[t]);
		
		if (ma1[t] > ma1[k]) {
			if (c1[t] == c1[k])
				ma1[k] = ma1[t];
			else {
				ma2[k] = ma1[k];
				c2[k] = c1[k];
				ma1[k] = ma1[t];
				c1[k] = c1[t];
			}
		}else if (ma1[t] > ma2[k] && c1[t] != c1[k]) {
			ma2[k] = ma1[t];
			c2[k] = c1[t];
		}
		if (ma2[t] > ma1[k]) {
			if (c2[t] == c1[k])
				ma1[k] = ma2[t];
			else {
				ma2[k] = ma1[k];
				c2[k] = c1[k];
				ma1[k] = ma2[t];
				c1[k] = c2[t];
			}
		}else if (ma2[t] > ma2[k] && c2[t] != c1[k]) {
			ma2[k] = ma2[t];
			c2[k] = c2[t];
		}

	}
}

void doit(vector <pair<int, int> > V) {
	int len = 0;
	// printf("%d\n", ans);
	for (int i = 0; i < (int) V.size(); i++) {
		zhan[++len] = V[i].second;


		if (c[V[i].first] != c1[V[i].second] || !c[V[i].first] || !c1[V[i].second]) {
			ans = max(ans, ma1[V[i].second] + l[V[i].first]);
		}
		if (c[V[i].first] != c2[V[i].second] || !c[V[i].first] || !c2[V[i].second]) {
			ans = max(ans, ma2[V[i].second] + l[V[i].first]);
		}
		
		if (l[V[i].first] > ma1[V[i].second]) {
			if (c[V[i].first] != c1[V[i].second]) {
				ma2[V[i].second] = ma1[V[i].second];
				c2[V[i].second] = c1[V[i].second];
				ma1[V[i].second] = l[V[i].first];
				c1[V[i].second] = c[V[i].first];
			}else {
				ma1[V[i].second] = l[V[i].first];
			}
		}else if (l[V[i].first] > ma2[V[i].second] && c[V[i].first] != c1[V[i].second]) {
			ma2[V[i].second] = l[V[i].first];
			c2[V[i].second] = c[V[i].first];
		}

	}
	// printf("%d\n", ans);
	sort(zhan + 1, zhan + len + 1, cmp_L);

	for (int i = len; i > 1; i--) {
		zhan[++len] = lca(zhan[i - 1], zhan[i]);
	}
	sort(zhan + 1, zhan + len + 1, cmp_L);

	for (int i = 1; i < len; i++) {
		ve1[zhan[i]].clear();
	}
	// for (int i = 1; i <= len; i++)
	// 	printf("%d ", zhan[i]);
	// printf("\n");
	int len1 = 0;
	zhan1[len1 = 1] = zhan[1];
	for (int i = 2; i <= len; i++)
		if (zhan[i] != zhan[i - 1]) {
			while (len1 > 0 && R[zhan1[len1]] < L[zhan[i]])
				len1 --;
			zhan1[++len1] = zhan[i];
			ve1[zhan1[len1 - 1]].push_back(zhan1[len1]);
		}
	dfs_d(zhan[1]);
	// for (int i = 0; i < (int) V.size(); i++)
	// 	for (int j = 0; j < i; j++)
	// 		if (c[V[i].first] != c[V[j].first] || !c[V[i].first] || !c[V[j].first]) {
	// 			// printf("xx %d %d\n", l[V[i].first] + l[V[j].first], dist(V[i].second, V[j].second));
	// 			ans = max(ans, l[V[i].first] + l[V[j].first] + dist(V[i].second, V[j].second));
	// 		}
	for (int i = 1; i <= len; i++) {
		// v[V[i].second] = -1000000000;
		ma1[zhan[i]] = ma2[zhan[i]] = -1000000000;
	}
}

void doit1(vector <pair<int, int> > V) {
	for (int i = 0; i < (int) V.size(); i++)
		for (int j = 0; j < i; j++)
			// if (c[V[i].first] != c[V[j].first] || !c[V[i].first] || !c[V[j].first]) {
				// printf("xx %d %d\n", l[V[i].first] + l[V[j].first], dist(V[i].second, V[j].second));
				ans = max(ans, dist(V[i].first, V[j].first) + dist(V[i].second, V[j].second));
			// }
}

void dfs(int k, vector <pair<int, int> > V) {
	// printf("?? %d\n", k);
	if (V.size() <= 1)
		return ;
	if (V.size() <= 100) {
		doit1(V);
		return ;
	}
	dfs_size(k);
	sz = sum[k];
	dfs_zx(k);
	k = zx;
	l[k] = 0;
	dfs_l(k);
	c[k] = 0;
	used[k] = true;
	int tot = 0;
	for (int i = 0; i < (int) ve[k].size(); i++)
		if (!used[ve[k][i]]) {
			tot += 1;
			c[ve[k][i]] = tot;
			dfs_c(ve[k][i]);
		}
	used[k] = false;

	
	doit(V);


	sort(V.begin(), V.end(), cmp_c);
	int q = 0;
	used[k] = true;
	vector <int> vv;
	for (int i = 0; i <= tot; i++) {
		while (q < (int) V.size() && c[V[q].first] <= i)
			q += 1;
		vv.push_back(q);
	}
	tot = 0;
	for (int i = 0; i < (int) ve[k].size(); i++)
		if (!used[ve[k][i]]) {
			tot += 1;
			vector <pair<int, int> > V1;
			// printf("?? %d %d %u\n", vv[tot - 1], vv[tot], V.size());
			for (int j = vv[tot - 1]; j < vv[tot]; j++)
				V1.push_back(V[j]);
			dfs(ve[k][i], V1);
		}
	used[k] = false;
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i < n; i++) {
		int x, y;
		scanf("%d%d", &x, &y);
		// x = i;
		// y = i + 1;
		ve[x].push_back(y);
		ve[y].push_back(x);
	}
	vector <pair<int, int> > V;
	for (int i = 1; i <= m; i++) {
		int x, y;
		scanf("%d%d", &x, &y);
		V.push_back(make_pair(x, y));
	}
	dfs1(1, 0);
	for (int i = 1; i <= n; i++)
		ma1[i] = ma2[i] = -1000000000;
	dfs(1, V);
	printf("%d\n", ans);
}
----------
====================
----------
DATA-STRUCTURES.38
advanced
----------
PROBLEM STATEMENT:
Consider an array of [expression]. 
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
DATA-STRUCTURES.39
medium
----------
PROBLEM STATEMENT:
An AVL tree (Georgy Adelson-Velsky and Landis' tree, named after the inventors) is a self-balancing binary search tree.  In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property.

We define balance factor for each node as :

balanceFactor = height(left subtree) - height(right subtree)


The balance factor of any node of an AVL tree is in the integer range [-1,+1]. If after any modification in the tree, the balance factor becomes less than −1 or greater than +1, the subtree rooted at this node is unbalanced, and a rotation is needed.



(https://en.wikipedia.org/wiki/AVL_tree)        

You are given a pointer to the root of an AVL tree. You need to insert a value into this tree and perform the necessary rotations to ensure that it remains balanced. 

Input Format  

You are given a function,

node *insert(node * root,int new_val)
{


}


'node' is defined as :

struct node
{
int val;            //value
struct node* left;  //left child
struct node* right; //right child
int ht;             //height of the node
} node;


You only need to complete the function.     

Note: All the values in the tree will be distinct. Height of a Null node is -1 and the height of the leaf node is 0.


Output Format  

Insert the new value into the tree and return a pointer to the root of the tree. Ensure that the tree remains balanced.

Sample Input  

    3
  /  \
 2    4
       \
        5


The value to be inserted is 6.

Sample Output

    3
  /  \
 2    5
     / \
    4   6


Explanation

After inserting 6 in the tree. the tree becomes:

    3 (Balance Factor = -2)
  /  \
 2    4 (Balance Factor = -2)
       \
        5 (Balance Factor = -1)
         \
          6 (Balance Factor = 0)


Balance Factor of nodes 3 and 4 is no longer in the range [-1,1]. We need to perform a rotation to balance the tree. This is the right right case. We perform a single rotation to balance the tree.

After performing the rotation, the tree becomes : 

                              3 (Balance Factor = -1)
                            /   \
      (Balance Factor = 0) 2     5 (Balance Factor = 0)
                                / \
           (Balance Factor = 0)4   6 (Balance Factor = 0)

----------
TOP SOLUTION:
----------
/* Node is defined as :
typedef struct node
{
    int val;
    struct node* left;
    struct node* right;
    int ht;
} node; */


node * insert(node * T,int x)
{
    if (T == NULL)
    {
        T = (node*)malloc(sizeof(node));
        T->val = x;
        T->left = NULL;
        T->right = NULL;
    }
    else if (x > T->val)
    {
        T->right = insert_hidden(T->right, x);
        if (BF_hidden(T) == -2)
        {
            if (x > T->right->val)
            {
                T = RR_hidden(T);
            }
            else
            {
                T = RL_hidden(T);
            }
        }
    }
    else if (x < T->val)
    {
        T->left = insert_hidden(T->left, x);
        if (BF_hidden(T) == 2){
            if (x < T->left->val)
            {
                T = LL_hidden(T);
            }
            else
            {
                T = LR_hidden(T);
            }
        }
    }
    T->ht = ht_hidden(T);
    return(T);
   
  
}

----------
====================
----------
DATA-STRUCTURES.40
hard
----------
PROBLEM STATEMENT:
Given two numbers [expression].  

You are given [expression] queries. Queries can be of two types, type 1 and type 2.  


Type 1 queries are represented as 1 i j : Modify the given array by removing elements from [expression] and adding them to the front.  
Type 2 queries are represented as 2 i j : Modify the given array by removing elements from [expression] and adding them to the back.  


Your task is to simply print [expression] queries followed by the resulting array.  

Note While adding at back or front the order of elements is preserved.  
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <memory.h>
#include <algorithm>
#include <vector>
#include <set>
#include <map>

#define f(i,s,e) for(unsigned int i=s;i<e;++i)
#define fe(i,s,e) for(unsigned int i=s;i<=e;++i)

typedef unsigned long long int llu;
typedef long long int lls;

char* read_int(char* pC, unsigned int & res) {
	unsigned int r = 0; char c = 0; bool digit = false;
	while (c = *pC++) { if (c <= '9' && c >= '0') { digit = true; r = (r << 3) + (r << 1) + (c - '0'); } else if (digit) { break; } }
	res = r;
	return pC;
}
unsigned int * A;
int * R;
int RndCount = 0;

struct treap {
	treap(unsigned int v, unsigned int rndv) : nodeValue(v), count(1), prio(rndv), l(0), r(0) {  }
	unsigned int nodeValue;
	int count;
	int prio;
	treap *l;
	treap *r;
};

treap * T = 0;

static int getCount(treap* root) {
	return root ? root->count : 0;
}

void update(treap *root) {
	if (!root) return;
	root->count = 1 + getCount(root->l) + getCount(root->r);
}

void merge(treap* &t, treap* l, treap* r) {
	if (!l)
		t = r;
	else if (!r)
		t = l;
	else if (l->prio < r->prio)
		merge(l->r, l->r, r), t = l;
	else
		merge(r->l, l, r->l), t = r;
	update(t);
}

void split(treap* t, treap* &l, treap* &r, int key) {
	if (!t)
		l = r = NULL;
	else if (key <= getCount(t->l))
		split(t->l, l, t->l, key), r = t;
	else
		split(t->r, t->r, r, key - getCount(t->l) - 1), l = t;
	update(t);
}

int get(treap* t, int index) {
	if (index < getCount(t->l))
		return get(t->l, index);
	else if (index > getCount(t->l))
		return get(t->r, index - getCount(t->l) - 1);
	return t->nodeValue;
}

void insert(treap* &t, treap* item, int index) {
	if (!t)
		t = item;
	else if (item->prio < t->prio)
		split(t, item->l, item->r, index), t = item;
	else if (index <= getCount(t->l))
		insert(t->l, item, index);
	else
		insert(t->r, item, index - getCount(t->l) - 1);
	update(t);// not necessary if existed...
}

void insert(treap* &root, int index, int value, int rndv) {
	treap *item = new treap(value, rndv);
	item->nodeValue = value;
	item->count = 1;
	item->prio = rndv;
	insert(root, item, index);
}

void remove(treap* &t, int index) {
	if (index == getCount(t->l))
		merge(t, t->l, t->r);
	else
		if (index < getCount(t->l))
			remove(t->l, index);
		else
			remove(t->r, index - getCount(t->l) - 1);
	update(t); // not necessary if existed...
}

void shift_front(treap* &root, unsigned int a, unsigned int b) {
	treap *l1, *r1;
	split(root, l1, r1, b + 1);
	treap *l2, *r2;
	split(l1, l2, r2, a);

	treap *t;
	merge(t, r2, l2);
	merge(root, t, r1);
}
void shift_back(treap* &root, unsigned int a, unsigned int b) {
	treap *l1, *r1;
	split(root, l1, r1, b + 1);
	treap *l2, *r2;
	split(l1, l2, r2, a);
	treap *t;
	merge(t, l2, r1);
	merge(root, t, r2);
}

int main(int argc, char ** argv) {
	if (argc >1) {
		freopen(argv[1], "r", stdin);
	}
	char*sLine = new char[12000000];
	gets(sLine);
	char * pC = sLine;
	unsigned int N, Q;
	pC = read_int(pC, N);
	pC = read_int(pC, Q);
	
	R = new int[N+1];
	fe(i, 0, N) {R[i] = i;}
	std::random_shuffle(R, R+N+1);

	gets(sLine);
	pC = sLine;
	f(i, 0, N){
		unsigned int x;
		pC = read_int(pC, x);
		insert(T, i, x, R[RndCount++]);
	}
	unsigned int q, l, r;
	f(i, 0, Q){
		gets(sLine);
		pC = sLine;
		pC = read_int(pC, q);
		pC = read_int(pC, l);
		pC = read_int(pC, r);
		if (q == 1) {
			shift_front(T, l - 1, r - 1);
		}
		else if (q == 2) {
			shift_back(T, l - 1, r - 1);
		}
	}
	int x1 = get(T, 0);
	int x2 = get(T, N-1);
	printf("%u\n%u", std::abs(x1 - x2), x1);
	f(i, 1, N) {
		printf(" %u", get(T, i));
	}
	printf("\n");
	return 0;
} 


----------
====================
----------
DATA-STRUCTURES.41
hard
----------
PROBLEM STATEMENT:
The median of [expression] is even. You start with an empty number list. Then, you can add numbers to the list, or remove existing numbers from it. After each add or remove operation, output the median.

Example: 
For a set of [expression]. &nbsp;

Input: 
The first line is an integer, [expression] is removed from the set.

Output: 
For each operation: If the operation is add, output the median after adding [expression] in a single line. (If the result is an integer DO NOT output decimal point. And if the result is a real number, DO NOT output trailing 0s.)

Note 
If your median is 3.0, print only 3. And if your median is 3.50, print only 3.5. Whenever you need to print the median and the list is empty, print Wrong!

Constraints: 
[expression] 
For each a x or r x, [expression] will always be a signed integer (which will fit in 32 bits).

Sample Input:  

7  
r 1  
a 1  
a 2  
a 1  
r 1  
r 2  
r 1  


Sample Output:  

Wrong!  
1  
1.5  
1  
1.5  
1  
Wrong!


Note: As evident from the last line of the input, if after remove operation the list becomes empty, you have to print Wrong!.&nbsp;
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <set>
#include <cstring>
#include <string>

using namespace std;

multiset<int> s1,s2;  //0<=|s1|-|s2|<=1
char s[55];

void gao() {
int a,b;
bool f1,f2;	
	if (s1.empty()) {
		puts("Wrong!");
		return;
	}
	if (s1.size()==s2.size()) {
		a=*s1.rbegin();
		b=*s2.begin();
		f1=a%2;
		f2=b%2;
		if (f1==f2) {
			printf("%.0lf\n",(a*1.+b)/2.);
		}
		else {
			printf("%.1lf\n",(a*1.+b)/2.);
		}
	}
	else {
		printf("%d\n",*s1.rbegin());
	}
}

void gao1(int x) { //add x
	if (s1.empty()) {
		s1.insert(x);
	}
	else if (s1.size()==s2.size()) {
		s2.insert(x);
		s1.insert(*s2.begin());
		s2.erase(s2.begin());
	}
	else {
		s1.insert(x);
		s2.insert(*s1.rbegin());
		s1.erase(s1.find(*s1.rbegin()));
	}
	gao();

}

void gao2(int x) {
multiset<int>::iterator t1=s1.find(x),t2=s2.find(x);
	if ((t1==s1.end()) && (t2==s2.end())) {
		puts("Wrong!");
		return;
	}
	if (s1.size()==s2.size()) {
		if (t2!=s2.end()) {
			s2.erase(t2);
		}
		else {
			s1.erase(t1);
			s1.insert(*s2.begin());
			s2.erase(s2.begin());
		}
	}
	else if (t1!=s1.end()) {
		s1.erase(t1);
	}
	else {
		s2.erase(t2);
		s2.insert(*s1.rbegin());
		s1.erase(s1.find(*s1.rbegin()));
	}
	gao();
}

int main() {
int i,x;

	/*s1.clear();
	s2.clear();*/
	for (scanf("%d",&i);i;--i) {
		scanf("%s%d",s,&x);
		if (s[0]=='a') {
			gao1(x);
		}
		else {
			gao2(x);
		}
	}
	return 0;

}



----------
====================
----------
DATA-STRUCTURES.42
hard
----------
PROBLEM STATEMENT:
People connect with each other in a social network. A connection between Person [expression] belongs to. 

At the beginning, there are [expression] will belong to the same community.

There are two type of queries:


[expression] merged (if they belong to different communities).
[expression] belongs. 

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int f[100005], s[100005];
int find(int x) {
    if (x == f[x]) return x;
    return f[x] = find(f[x]);
}
void merge(int x, int y) {
    int fx = find(x), fy = find(y);
    if (fx == fy) return;
    if (s[fx] > s[fy]) {
        f[fy] = fx;
        s[fx] += s[fy];
    } else {
        f[fx] = fy;
        s[fy] += s[fx];
    }
}
int Q, N;
char c[5];
int main() {
    scanf("%d%d", &N, &Q);
    for (int i = 1; i <= N; ++i) f[i] = i, s[i] = 1;
    for (int i = 0; i < Q; ++i) {
        scanf("%s", c);
        if (c[0] == 'M') {
            int x, y; scanf("%d%d", &x, &y);
            merge(x, y);
        } else {
            int x; scanf("%d", &x);
            printf("%d\n", s[find(x)]);
        }
    }
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.43
easy
----------
PROBLEM STATEMENT:
This question is designed to help you get a better understanding of basic heap operations. 
You will be given queries of [expression] types:


"[expression] to the heap.  
"[expression] from the heap.  
"[expression]" - Print the minimum of all the elements in the heap.


NOTE: It is guaranteed that the element to be deleted will be there in the heap. Also, at any instant, only distinct elements will be in the heap.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

vector<int> heapArray = {};

int parentIndexOfIndex(int index) {
    int oneBasedIndex = index + 1;
    int oneBasedParentIndex = floor(oneBasedIndex / 2);
    return oneBasedParentIndex - 1;
}

vector<int> childIndicesOfParentIndex(int parentIndex) {
    int oneBasedIndex = parentIndex + 1;
    int childFirstIndex = oneBasedIndex * 2;
    vector<int> indices = {};
    if (heapArray.size() > childFirstIndex - 1) {
        indices.push_back(childFirstIndex - 1);
        if (heapArray.size() > childFirstIndex) {
            indices.push_back(childFirstIndex);
        }
    }
    return indices;
}

void addValueToHeap(int value) {
    for (int i = 0; i < heapArray.size(); i++) {
        if (heapArray[i] == value) {
            return;
        }
    }
    
    int newValueIndex = heapArray.size();
    heapArray.push_back(value);
    
    //Rebalance if required
    int parentIndex = parentIndexOfIndex(newValueIndex);
    int childIndex = newValueIndex;
    while (parentIndex >= 0) {
        //If value is smaller then we bubble up
        if (value < heapArray[parentIndex]) {
            heapArray[childIndex] = heapArray[parentIndex];
            heapArray[parentIndex] = value;
            childIndex = parentIndex;
            parentIndex = parentIndexOfIndex(childIndex);
        }
        else {
            break;
        }
    }
}

void moveIndexToAppropriateChildOrParent(int indexToMove) {
    int parentIndex = parentIndexOfIndex(indexToMove);
    if (parentIndex >= 0 && heapArray[indexToMove] < heapArray[parentIndex]) {
        int parentValue = heapArray[parentIndex];
        heapArray[parentIndex] = heapArray[indexToMove];
        heapArray[indexToMove] = parentValue;
        moveIndexToAppropriateChildOrParent(parentIndex);
    }
    else {
        vector<int> childIndices = childIndicesOfParentIndex(indexToMove);
        if (childIndices.size() > 0) {
            int childIndex = childIndices[0];
            if (childIndices.size() == 2) {
                if (heapArray[childIndex] > heapArray[childIndices[1]]) {
                    childIndex = childIndices[1];
                }
            }
            if (heapArray[indexToMove] > heapArray[childIndex]) {
                int childValue = heapArray[childIndex];
                heapArray[childIndex] = heapArray[indexToMove];
                heapArray[indexToMove] = childValue;
                moveIndexToAppropriateChildOrParent(childIndex);
            }
        }
    }
}

void replaceIndexWithLastElement(int indexToReplace) {
    heapArray[indexToReplace] = heapArray[heapArray.size() - 1];
    heapArray.pop_back();
}

void deleteValueFromHeap(int value) {
    int indexToDelete = -1;
    for (int i = 0; i < heapArray.size(); i++) {
        if (heapArray[i] == value) {
            indexToDelete = i;
            break;
        }
    }
    if (indexToDelete == -1) {
        cout << "did not find value";
        return;
    }
    
    replaceIndexWithLastElement(indexToDelete);
    moveIndexToAppropriateChildOrParent(indexToDelete);
}

int currentHeapMin() {
    return heapArray[0];
}

int main() {
    
    int numQueries;
    cin >> numQueries;
    
    for (int i = 0; i < numQueries; i++) {
        int operationType, value;
        cin >> operationType;
        if (operationType == 1) {
            cin >> value;
            addValueToHeap(value);
        }
        else if (operationType == 2) {
            cin >> value;
            deleteValueFromHeap(value);
        }
        else {
            cout << currentHeapMin() << "\n";
        }
    }
    
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.44
easy
----------
PROBLEM STATEMENT:
You have an empty sequence, and you will be given [expression] queries. Each query is one of these three types:

1 x  -Push the element x into the stack.
2    -Delete the element present at the top of the stack.
3    -Print the maximum element in the stack.

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <stack>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    stack<int> max;
    stack<int> s;
    max.push(0);
    int n;
    cin>>n;
    while (n--){
        int a;
        cin>>a;
        if(a==1){
            cin>>a;
            if(a>=max.top()) max.push(a);
            s.push(a);
        }
        else if(a==2){
            if(s.top()==max.top()) max.pop();
            s.pop();
        } 
        else if(a==3) cout<<max.top()<<endl;
    }
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.45
medium
----------
PROBLEM STATEMENT:
A queue is an abstract data type that maintains the order in which elements were added to it, allowing the oldest elements to be removed from the front and new elements to be added to the rear. This is called a First-In-First-Out (FIFO) data structure because the first element added to the queue (i.e., the one that has been waiting the longest) is always the first one to be removed.

A basic queue has the following operations:


Enqueue: add a new element to the end of the queue.
Dequeue: remove the element from the front of the queue and return it.


In this challenge, you must first implement a queue using two stacks. Then process [expression] types: 


1 x: Enqueue element [expression] into the end of the queue.
2: Dequeue the element at the front of the queue.
3: Print the element at the front of the queue.

----------
TOP SOLUTION:
----------
#include <iostream>
#include <stack>

using namespace std;

int main() 
{
  int q, type, value;
  char operation;
  stack<int> S1, S2;
  stack<char> S3, S4;
    
  cin >> q;
  while(q--)
  {
    cin >> type;
    if(type == 1)
    {
      cin >> value;
      S1.push(value);
    }
    else if(type == 2)
    {
      S3.push('d');
    }
    else
    {
      S3.push('p');
    }
  }

  // Perform the actual operations.
  while(!S1.empty())
  {
    value = S1.top();
    S1.pop();
    S2.push(value);
  }

  while(!S3.empty())
  {
    value = S3.top();
    S3.pop();
    S4.push(value);
  }

  while(!S2.empty())
  {
    operation = S4.top();
    value = S2.top();
    S4.pop();

    if(operation == 'p')
    {
      // Print.
      cout << value << endl;
    }
    else
    {
      // Dequeue.
      S2.pop();
    }
  }

  return 0;
}
----------
====================
----------
DATA-STRUCTURES.46
medium
----------
PROBLEM STATEMENT:
There are [expression](inclusive). Same value can be chosen any number of times.  

Here [expression] represents the edges of the graph.  

Your task is to print the number of vertices in the smallest and the largest connected components of the graph.  

Note
Single nodes should not be considered in the answer. 

For more clarity look at the following figure.  



For the above graph smallest connected component is 7 and largest connected component is 17.  
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
#include<fstream>
using namespace std;
int t, n, m, i, j, parent[30005], sum[30005], ans,ans1;
int a, b;
int find(int x)
{
    if (x == parent[x])
        return parent[x];
    else
        return parent[x]=find(parent[x]);
}
int main()
{
        //ifstream inp;
        //ofstream out;
        ans = 2,ans1=200000000;
        cin>>n;
        assert(n<=15000);
        for (i = 1; i <= 2*n; i ++)
        {
            parent[i] = i;
            sum[i] = 1;
        }
        for (i = 0; i < n; i++)
        {
            cin>>a>>b;
            assert(a<=n&&a>=1);
            assert(b>=(n+1)&&b<=2*n);
            int pa = find(a);
            int pb = find(b);
            if (pa != pb)
            {
                parent[pa] = pb;
                sum[pb] += sum[pa];
            }
        }
        for (i = 1; i <= 2*n; i ++)
        {
            if(sum[i]!=1){
            int ind=find(i);
            ans1=min(sum[ind],ans1);
            }
        }
        for (i = 1; i <= 2*n; i ++)
        {
            if(sum[i]!=1){
            int ind1=find(i);
            ans=max(sum[ind1],ans);
            }
        }
        cout<<ans1<<" "<<ans<<endl;

        //printf("%d\n", ans);
    return 0;
}


----------
====================
----------
DATA-STRUCTURES.47
medium
----------
PROBLEM STATEMENT:
A bracket is considered to be any one of the following characters: (, ), {, }, [, or ]. 

Two brackets are considered to be a matched pair if the an opening bracket (i.e., (, [, or {) occurs to the left of a closing bracket (i.e., ), ], or }) of the exact same type. There are three types of matched pairs of brackets: [], {}, and ().

A matching pair of brackets is not balanced if the set of brackets it encloses are not matched. For example, {[(])} is not balanced because the contents in between { and } are not balanced. The pair of square brackets encloses a single, unbalanced opening bracket, (, and the pair of parentheses encloses a single, unbalanced closing square bracket, ].

By this logic, we say a sequence of brackets is balanced if the following conditions are met:


It contains no unmatched brackets.
The subset of brackets enclosed within the confines of a matched pair of brackets  is also a matched pair of brackets.


Given [expression] strings of brackets, determine whether each sequence of brackets is balanced. If a string is balanced, return YES.  Otherwise, return NO.  

Function Description  

Complete the function isBalanced in the editor below.  It must return a string: YES if the sequence is balanced or NO if it is not.  

isBalanced has the following parameter(s):


s: a string of brackets

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include<stack>
using namespace std;
#include<map>


int main() {
    map<char,char>lol;
    lol[')']='(';
    lol[']']='[';
    lol['}']='{';
    int t;
    cin >> t;
    while(t--)
        {
        string s;
        stack<char>st;
        cin >> s;
        int flag=0;
        for(int i=0;s[i]!='\0';i++)
            {
            if(s[i]=='(' || s[i]=='{' || s[i]=='[')
                st.push(s[i]);
            else{
                if(!st.empty() and lol[s[i]]==st.top())
                 st.pop();
                else
                {
                    flag=1;
                    break;
                }
            }
        }
        
        if(!flag and st.empty())
        cout << "YES" << endl;
        else
        cout << "NO " << endl;
    }
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.48
medium
----------
PROBLEM STATEMENT:
You are given a square grid with some cells open (.) and some blocked (X).  Your playing piece can move along any row or column until it reaches the edge of the grid or a blocked cell.  Given a grid, a start and an end position, determine the number of moves it will take to get to the end position.  

For example, you are given a grid with sides [expression] described as follows:

...
.X.
...


Your starting position [expression] moves to get to the goal.

Function Description 
Complete the minimumMoves function in the editor.  It must print an integer denoting the minimum moves required to get from the starting position to the goal.

minimumMoves has the following parameter(s):


grid: an array of strings representing the rows of the grid  
startX: an integer  
startY: an integer  
goalX: an integer  
goalY: an integer  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
	 //Enter your code here. Read input from STDIN. Print output to STDOUT 
	struct Point {
		int x;
		int y;
		Point(int _x, int _y) {
			x = _x;
			y = _y;
		};
	};
	int n;
	cin >> n;
	char z[100][100];
	for (int x = 0; x < 100; x++) {
		for (int y = 0; y < 100; y++) {
			z[x][y] = 0;
		};
	};
	for (int x = 0; x < n; x++) {
		for (int y = 0; y < n; y++) {
			cin >> z[x][y];
		};
	};
	int a, b, c, d;
	cin >> a; cin >> b; cin >> c; cin >> d;
	if (a == c && b == d) {
		printf("0\n"); return 0;
	}
	// 
	z[a][b] = 'A';
	z[c][d] = 'B';
	vector<Point> q[2];
	char s = -1;
	q[(-s) % 2].push_back(Point(a, b));
	while (1) {
		for (vector<Point>::iterator i = q[(-s) % 2].begin(); i != q[(-s) % 2].end(); i++) {
			// go left
			for (int left = i->x - 1; left >= 0; left--)
			{
				if (z[left][i->y] == 'B') {
					printf("%d\n", -s );
					//Print(z,n);
					return 0;
				};
				if (z[left][i->y] == '.') {
					z[left][i->y] = s;
					//Print(z, n);
					q[(-s + 1) % 2].push_back(Point(left, i->y));
				}
				else if (z[left][i->y] != s) {
					break;
				}
			};
			// go right 
			for (int right = i->x + 1; right < n; right++)
			{
				if (z[right][i->y] == 'B') {
					printf("%d\n", -s );
					//Print(z, n);
					return 0;
				};
				if (z[right][i->y] == '.') {
					z[right][i->y] = s;
					//Print(z, n);
					q[(-s + 1) % 2].push_back(Point(right, i->y));
				}
				else if (z[right][i->y] !=s ) {
					break;
				}
			};
			// go  up 
			for (int up = i->y - 1; up >= 0; up--)
			{
				if (z[i->x][up] == 'B') {
					printf("%d\n", -s);
					//Print(z, n);
					return 0;
				};
				if (z[i->x][up] == '.') {
					z[i->x][up] = s;
					//Print(z, n);
					q[(-s + 1) % 2].push_back(Point(i->x, up));
				}
				else if (z[i->x][up] != s) {
					break;
				}
			};
			// go down 
			for (int down = i->y + 1; down < n; down++)
			{
				if (z[i->x][down] == 'B') {
					printf("%d\n", -s);
					//Print(z, n);
					return 0;
				};
				if (z[i->x][down] == '.') {
					z[i->x][down] = s;
					//Print(z, n);
					q[(-s + 1) % 2].push_back(Point(i->x, down));
				}
				else if (z[i->x][down] != s) {
					break;
				}
			};
		};
		s--;
	};
};

----------
====================
----------
DATA-STRUCTURES.49
easy
----------
PROBLEM STATEMENT:
Jesse loves cookies. He wants the sweetness of all his cookies to be greater than value [expression]. To do this, Jesse repeatedly mixes two cookies with the least sweetness. He creates a special combined cookie with:

sweetness [expression] 2nd least sweet cookie).

He repeats this procedure until all the cookies in his collection have a sweetness  [expression]. 
You are given Jesse's cookies. Print the number of operations required to give the cookies a sweetness  [expression] if this isn't possible. 
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>

#include <queue>

using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
    
    int n, k, operations = 0;;
    cin >> n;
    cin >> k;
    
    priority_queue<int> p;
    
    for (int a = 0; a < n; a++) {
        int cookie;
        cin >> cookie;
        p.push(cookie * -1);
    }
    
    while (p.top() > k * -1 && p.size() > 1) {
        int cookie1, cookie2, newCookie;
        
        cookie1 = p.top();
        p.pop();
        
        cookie2 = p.top();
        p.pop();
        
        newCookie = cookie1 + 2 * cookie2;
        p.push(newCookie);
        
        operations++;
    }
    
    if (p.top() > k * -1) cout << "-1";
    else cout << operations;
    
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.50
hard
----------
PROBLEM STATEMENT:
Kundu is true tree lover. Tree is a connected graph having N vertices and N-1  edges. Today when he got a tree, he colored each edge with one of either red(r) or black(b) color. He is interested in knowing how many triplets(a,b,c) of vertices are there , such that, there is atleast one edge having red color on all the three paths i.e. from vertex a to b, vertex b to c and vertex c to a . Note that (a,b,c), (b,a,c) and all such permutations will be considered as the same triplet. 

If the answer is greater than 109 + 7, print the answer modulo (%) 109 + 7.

Input Format 
The first line contains an integer N, i.e., the number of vertices in tree. 
The next N-1 lines represent edges:  2 space separated integers denoting an edge followed by a color of the edge. A color of an edge is denoted by a small letter of English alphabet, and it can be either red(r) or black(b).  

Output Format 
Print a single number i.e. the number of triplets.  

Constraints 
1 ≤ N ≤ 105 
A node is numbered between 1 to N.  

Sample Input  

5
1 2 b
2 3 r
3 4 r
4 5 b


Sample Output  

4


Explanation

Given tree is something like this.


(2,3,4) is one such triplet because on all paths i.e 2 to 3, 3 to 4 and 2 to 4 there is atleast one edge having red color.
(2,3,5), (1,3,4) and (1,3,5) are other such triplets. 
Note that (1,2,3) is NOT a triplet, because the path from 1 to 2 does not have an edge with red color.
----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <iterator>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt(): x(0) { }
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }
	
	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }
	
	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
	
	ModInt inverse() const {
		long long a = x, b = MOD, u = 1, v = 0;
		while(b) {
			long long t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		return ModInt(u);
	}
};
typedef ModInt<1000000007> mint;

struct UnionFind {
	vector<int> data;
	void init(int n) { data.assign(n, -1); }
	bool unionSet(int x, int y) {
		x = root(x); y = root(y);
		if(x != y) {
			if(data[y] < data[x]) swap(x, y);
			data[x] += data[y]; data[y] = x;
		}
		return x != y;
	}
	bool findSet(int x, int y) { return root(x) == root(y); }
	int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }
	int size(int x) { return -data[root(x)]; }
};

mint dp[100001][4];
int main() {
	int N;
	scanf("%d", &N);
	UnionFind uf; uf.init(N);
	rep(i, N-1) {
		int a, b;
		char rb[2];
		scanf("%d%d%s", &a, &b, rb), a --, b --;
		if(*rb == 'b')
			uf.unionSet(a, b);
	}
	vector<int> components;
	rep(i, N) if(uf.root(i) == i)
		components.push_back(uf.size(i));
	mset(dp, 0);
	dp[0][0] = 1;
	rep(i, components.size()) rep(j, 4) {
		mint x = dp[i][j];
		if(x.get() == 0) continue;
		dp[i+1][j] += x;
		if(j < 3) dp[i+1][j+1] += x * components[i];
	}
	mint ans = dp[components.size()][3];
	printf("%d\n", ans.get());
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.51
hard
----------
PROBLEM STATEMENT:
The median of a set of integers is the midpoint value of the data set for which an equal number of integers are less than and greater than the value. To find the median, you must first sort your set of integers in non-decreasing order, then:


If your set contains an odd number of elements, the median is the middle element of the sorted sample. In the sorted set [expression] is the median.
If your set contains an even number of elements, the median is the average of the two middle elements of the sorted sample. In the sorted set [expression] is the median.


Given an input stream of [expression] integer:


Add the [expression] integer to a running list of integers.
Find the median of the updated list (i.e., for the first element through the [expression] element).
Print the list's updated median on a new line. The printed value must be a double-precision number scaled to [expression] format).

----------
TOP SOLUTION:
----------
#include <set>
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int N;
multiset<int> r;
multiset<int, greater<int> > l;
int main() {
    scanf("%d", &N);
    for (int i = 0; i < N; ++i) {
        int a; scanf("%d", &a);
        if (l.empty()) l.insert(a);
        else {
            if (a > *l.begin()) r.insert(a);
            else l.insert(a);
        }
        if (l.size() > r.size() + 1) {
            r.insert(*l.begin());
            l.erase(l.begin());
        } else if (r.size() > l.size()) {
            l.insert(*r.begin());
            r.erase(r.begin());
        }
        if (l.size() > r.size())
            printf("%d.0\n", *l.begin());
        else
            printf("%d.%c\n", (*l.begin() + *r.begin()) / 2, ((*l.begin() + *r.begin()) & 1) ? '5': '0');
    }
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.52
medium
----------
PROBLEM STATEMENT:
You are given [expression] in each move:

1: If we take 2 integers [expression]

2: Decrease the value of [expression]. 

Determine the minimum number of moves required to reduce the value of [expression].
----------
TOP SOLUTION:
----------
#include <iostream>
#include <queue>

using namespace std ;

int main ()
{
    int q ;
    cin >> q ;
    while ( q -- )
    {
        int n ;
        cin >> n ;
        int steps = 0 ;
        if ( n == 0 )
        {
            cout << 0 << endl ;
            continue ;
        }
        if ( n == 1 )
        {
            cout << 1 << endl ;
            continue ;
        }
        vector < int > dist ( n + 1 , 0 ) ;
        queue < int > q ;
        q.push ( n ) ;
        dist [ n ] = 1 ;
        while ( 1 )
        {
            int element = q.front () ;  // using queue same as bfs hence if any node / no appears first then its dist will be the minimum at that time !! 
            q.pop () ;
            if ( element == 2 ) // from 2 only one way 2 -> 1 -> 0
            {
                cout << dist [ 2 ] + 1 << endl ;
                break ;
            }
            // else explore both the conditions !!
            if ( dist [ element - 1 ] == 0 )   
            {
                dist [ element - 1 ] = dist [ element ] + 1 ;
                q.push ( element - 1 ) ;
            }
            for ( int i = 2 ; i * i <= element ; i ++ )
            {
                if ( element % i == 0 )
                {
                    int maxfrac = element / i ; // time complexcity , we will have at leat one fraction as >= 2 hence the no will be halved each time 10 ^ 6 -> 10 ^ 3 ->... hence in lg ( n ) and max 10 ^ 3 ( i * i hence max 2 * i  factors so q * 10 ^ 3 * lg ( 10 ^ 6 ) <= 10 ^ 8 hence solvable )
                    if ( dist [ maxfrac ] == 0 )
                    {
                        dist [ maxfrac ] = dist [ element ] + 1 ;
                        q.push ( maxfrac ) ;
                    }
                }
            }
        }
    }
    return 0 ;
}
----------
====================
----------
DATA-STRUCTURES.53
easy
----------
PROBLEM STATEMENT:
You have three stacks of cylinders where each cylinder has the same diameter, but they may vary in height. You can change the height of a stack by removing and discarding its topmost cylinder any number of times. 

Find the maximum possible height of the stacks such that all of the stacks are exactly the same height. This means you must remove zero or more cylinders from the top of zero or more of the three stacks until they're all the same height, then print the height. The removals must be performed in such a way as to maximize the height. 

Note: An empty stack is still a stack.
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }

int main() {
	int n1; int n2; int n3;
	while(~scanf("%d%d%d", &n1, &n2, &n3)) {
		vector<int> a(n1);
		for(int i = 0; i < n1; ++ i)
			scanf("%d", &a[i]);
		vector<int> b(n2);
		for(int i = 0; i < n2; ++ i)
			scanf("%d", &b[i]);
		vector<int> c(n3);
		for(int i = 0; i < n3; ++ i)
			scanf("%d", &c[i]);
		reverse(a.begin(), a.end());
		reverse(b.begin(), b.end());
		reverse(c.begin(), c.end());
		map<int, int> t;
		rep(k, 3) {
			const vi &v = k == 0 ? a : k == 1 ? b : c;
			int sum = 0;
			for(int x : v) {
				sum += x;
				++ t[sum];
			}
		}
		int ans = 0;
		for(auto p : t) if(p.second == 3)
			amax(ans, p.first);
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.54
hard
----------
PROBLEM STATEMENT:
Tieu owns a pizza restaurant and he manages it in his own way.  While in a normal restaurant, a customer is served by following the first-come, first-served rule, Tieu simply minimizes the average waiting time of his customers. So he gets to decide who is served first, regardless of how sooner or later a person comes. 

Different kinds of pizzas take different amounts of time to cook. Also, once he starts cooking a pizza, he cannot cook another pizza until the first pizza is completely cooked. Let's say we have three customers who come at time t=0, t=1, & t=2 respectively, and the time needed to cook their pizzas is 3, 9, & 6 respectively. If Tieu applies first-come, first-served rule, then the waiting time of three customers is 3, 11, & 16  respectively. The average waiting time in this case is (3 + 11 + 16) / 3 = 10. This is not an optimized solution. After serving the first customer at time t=3, Tieu can choose to serve the third customer. In that case, the waiting time will be 3, 7, & 17 respectively. Hence the average waiting time is (3 + 7 + 17) / 3 = 9.

Help Tieu achieve the minimum average waiting time. For the sake of simplicity, just find the integer part of the minimum average waiting time.

Input Format


The first line contains an integer N, which is the number of customers. 
In the next N lines, the ith line contains two space separated numbers Ti and Li. Ti is the time when ith customer order a pizza, and Li is the time required to cook that pizza.  
The [expression] arrival time. 


Output Format


Display the integer part of the minimum average waiting time.


Constraints


1 ≤ N ≤ 105
0 ≤ Ti ≤ 109
1 ≤ Li ≤ 109


Note


The waiting time is calculated as the difference between the time a customer orders pizza (the time at which they enter the shop) and the time she is served.
Cook does not know about the future orders.


Sample Input #00

3
0 3
1 9
2 6


Sample Output #00

9


Sample Input #01

3
0 3
1 9
2 5


Sample Output #01

8


Explanation #01

Let's call the person ordering at time = 0 as A, time = 1 as B and time = 2 as C. By delivering pizza for A, C and B we get the minimum average wait time to be 

(3 + 6 + 16)/3 = 25/3 = 8.33 


the integer part is 8 and hence the answer. 
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <iostream>
#include <set>
#include <vector>
#include <cstring>
#include <string>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <complex>
#include <map>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vi> vvi;
typedef vector<double> vd;
typedef pair<ll, ll> pll;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef vector<pll> vll;
typedef vector<string> vs;

int main() {
    int n;
    cin >> n;
    vll v(n);
    for (int i = 0; i < n; ++i) {
        scanf("%lld%lld", &v[i].first, &v[i].second);        
    }
    sort(v.begin(), v.end());
    ll sum = 0;
    set<pii> q;
    ll t = v[0].first;
    int it = 0;
    while (it < n || q.size()) {
        while (it < n && v[it].first <= t) {
            q.insert(pii(v[it].second, it));
            ++it;
        }
        if (q.empty()) {
            t = v[it].first;
        } else {
            int i = q.begin()->second;
            q.erase(q.begin());
            t += v[i].second;
            sum += t-v[i].first;
        }
    }
    cout << sum / n << endl;
    return 0;
}
----------
====================
----------
DATA-STRUCTURES.55
hard
----------
PROBLEM STATEMENT:
Suppose there is a circle. There are [expression] (both inclusive). You have two pieces of information corresponding to each of the petrol pump: (1) the amount of petrol that particular petrol pump will give, and (2) the distance from that petrol pump to the next petrol pump. 

Initially, you have a tank of infinite capacity carrying no petrol. You can start the tour at any of the petrol pumps. Calculate the first point from where the truck will be able to complete the circle. Consider that the truck will stop at each of the petrol pumps. The truck will move one kilometer for each litre of the petrol.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int n, p[100005], d[100005];
int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) scanf("%d%d", &p[i], &d[i]);
    int ret = 0, amount = 0, sum = 0;
    for (int i = 0; i < n; ++i) {
        p[i] -= d[i];
        sum += p[i];
        if (amount + p[i] < 0) {
            amount = 0;
            ret = i + 1;
        } else amount += p[i];
    }
    printf("%d\n", sum >= 0 ? ret : -1);
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.56
medium
----------
PROBLEM STATEMENT:
Alexa has two stacks of non-negative integers, stack [expression] denotes the top of the stack. Alexa challenges Nick to play the following game:


In each move, Nick can remove one integer from the top of either stack [expression].
Nick keeps a running sum of the integers he removes from the two stacks.
Nick is disqualified from the game if, at any point, his running sum becomes greater than some integer [expression] given at the beginning of the game.
Nick's final score is the total number of integers he has removed from the two stacks.


Given [expression] games, find the maximum possible score Nick can achieve (i.e., the maximum number of integers he can remove without being disqualified) during each game and print it on a new line.
----------
TOP SOLUTION:
----------
// author: gary
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;

#define ALL(x) (x).begin(), x.end()

const int inf = 1e9;
const int maxn = 1e5 + 10;

ll a[maxn];
ll b[maxn];
int T, n, m, x;

int main() {
  scanf("%d", &T);
  while(T--) {
    scanf("%d%d%d", &n, &m, &x);
    for(int i = 1; i <= n; i++) scanf("%lld", a + i);
    for(int i = 1; i <= m; i++) scanf("%lld", b + i);

    for(int i = 1; i <= n; i++) a[i] += a[i-1];
    for(int i = 1; i <= m; i++) b[i] += b[i-1];

    int res = 0;
    for(int i = 0, j = m; i <= n && a[i] <= x; i++) {
      while(a[i] + b[j] > x && j >= 1)
        j --;
      res = max(res, i + j);
    }
    printf("%d\n", res);
  }
  return 0;
}

----------
====================
----------
DATA-STRUCTURES.57
medium
----------
PROBLEM STATEMENT:
Skyline Real Estate Developers is planning to demolish a number of old, unoccupied buildings and construct a shopping mall in their place. Your task is to find the largest solid area in which the mall can be constructed.

There are a number of buildings in a certain two-dimensional landscape. Each building has a height, given by [expression].  

For example, the heights array [expression].  

Function Description

Complete the function largestRectangle int the editor below.  It should return an integer representing the largest rectangle that can be formed within the bounds of consecutive buildings.  

largestRectangle has the following parameter(s):


h: an array of integers representing building heights

----------
TOP SOLUTION:
----------
#include <stack>
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int N, h[100005];
int p = 1, s[100005];
int main() {
    scanf("%d", &N);
    for (int i = 1; i <= N; ++i) scanf("%d", &h[i]);
    int ans = 0;
    for (int i = 0; i < N + 2; ++i) {
        while (h[i] < h[s[p - 1]]) {
            int y = h[s[p - 1]];
            p--;
            ans = max(ans, (i - s[p - 1] - 1) * y);
        }
        s[p++] = i;
    }
    printf("%d\n", ans);
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.58
hard
----------
PROBLEM STATEMENT:
Consider an [expression], to calculate the result of the following expression:

[expression]

In other words, if we let [expression].  

Given [expression]), print the result of each query on a new line.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <stack>
#include <climits>
using namespace std;

int getMax(int input[],int k,int n)
{
	int i;
	int min = INT_MAX;
	deque<int> d1;
		
	for(i=0;i<k;i++)
	{
		//while((!d1.empty()) && input[d1.back()] < input[i])
		while ( (!d1.empty()) && input[i] >= input[d1.back()])
		{
			d1.pop_back();
			//cout << "popped" << endl;
			}
			
		d1.push_back(i);
		}
		
	for(;i<n;i++)
	{
		//cout << input[d1.front()] << " front" << endl;
		min = min < input[d1.front()] ? min : input[d1.front()];
		
		while(!(d1.empty()) && d1.front() <= i-k)
			d1.pop_front();
			
		while(!(d1.empty()) && input[d1.back()] < input[i])
			d1.pop_back();
			
		d1.push_back(i);
		}
	
	min = min < input[d1.front()] ? min : input[d1.front()];
	
	return min;
	}
	
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
     int n,q;
     int *input;
     int query;
     
     cin >> n;
     cin >> q;
	 input = new int[n];
	 
	 for(int i=0;i<n;i++)
	 {
		 cin >> input[i];
		 }
	 
	 for(int i=0;i<q;i++)
	 {
		 cin >> query;
		 cout << getMax(input,query,n) << endl;
		}
	 delete[] input;
		 
    return 0;
}


----------
====================
----------
DATA-STRUCTURES.59
hard
----------
PROBLEM STATEMENT:
Victoria has a tree, [expression].

Let's define the cost, [expression].

Victoria wants your help processing [expression].

It should be noted that path from some node [expression]. 
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

struct UnionFind {
	vector<int> data;
	void init(int n) { data.assign(n, -1); }
	bool unionSet(int x, int y) {
		x = root(x); y = root(y);
		if(x != y) {
			if(data[y] < data[x]) swap(x, y);
			data[x] += data[y]; data[y] = x;
		}
		return x != y;
	}
	bool findSet(int x, int y) { return root(x) == root(y); }
	int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }
	int size(int x) { return -data[root(x)]; }
};

int main() {
	int N; int Q;
	while(~scanf("%d%d", &N, &Q)) {
		vector<pair<int,pair<int, int> > > edges;
		for(int i = 0; i < N - 1; ++ i) {
			int u, v, w;
			scanf("%d%d%d", &u, &v, &w), -- u, -- v;
			edges.emplace_back(w, mp(u, v));
		}
		sort(all(edges));
		map<int, ll> num;
		UnionFind uf; uf.init(N);
		for(auto e : edges) {
			int u, v; tie(u, v) = e.second;
			num[e.first] += (ll)uf.size(u) * uf.size(v);
			uf.unionSet(u, v);
		}
		map<int, ll> sum; 
		sum[-1] = 0;
		ll t = 0;
		for(auto p : num) {
			t += p.second;
			sum[p.first] = t;
		}
		rep(i, Q) {
			int L; int R;
			scanf("%d%d", &L, &R);
			ll ans = (-- sum.upper_bound(R))->second - (-- sum.upper_bound(L - 1))->second;
			printf("%lld\n", ans);
		}
	}
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.60
medium
----------
PROBLEM STATEMENT:
In this challenge, you must implement a simple text editor. Initially, your editor contains an empty string, [expression] types:


append[expression].
delete[expression].
print[expression].
undo[expression] to the state it was in prior to that operation. 

----------
TOP SOLUTION:
----------
#include <iostream>
#include <string>
#include <stack>

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    std::string text, arg;
    int cmd;
    std::stack<std::string> history;
    
    std::cin >> cmd;
    while (std::cin >> cmd) {
        switch (cmd) {
            case 1: // Append
                std::cin >> arg;
                history.push(text);
                text.append(arg);
                break;
            case 2: // Erase
                std::cin >> cmd;
                history.push(text);
                text.erase(text.length() - cmd);
                break;
            case 3: // Get
                std::cin >> cmd;
                std::cout << text[cmd - 1] << '\n';
                break;
            case 4: // Undo
                text = std::move(history.top());
                history.pop();
                break;
        }        
    }
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.61
hard
----------
PROBLEM STATEMENT:
There are a number of plants in a garden. Each of these plants has been treated with some amount of pesticide. After each day, if any plant has more pesticide than the plant on its left, being weaker than the left one, it dies.  

You are given the initial values of the pesticide in each of the plants. Print the number of days after which no plant dies, i.e. the time after which there are no plants with more pesticide content than the plant to their left.  

For example, pesticide levels [expression].  

Function Description 
Complete the function poisonousPlants in the editor below.  It must return an integer representing the number of days until plants no longer die from pesticide.

poisonousPlants has the following parameter(s):


p: an array of integers representing pesticide levels in each plant

----------
TOP SOLUTION:
----------
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<set>
#include<map>
#include<queue>
#include<cassert>
#define PB push_back
#define MP make_pair
#define sz(v) (in((v).size()))
#define forn(i,n) for(in i=0;i<(n);++i)
#define forv(i,v) forn(i,sz(v))
#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)
#define all(v) (v).begin(),(v).end()
using namespace std;
typedef long long in;
typedef vector<in> VI;
typedef vector<VI> VVI;
in dct=0;
map<in,in> mar;
set<in> td;
void proc(in id){
  auto it=mar.find(id);
  auto it2=it;
  ++it2;
  mar.erase(it);
  if(it2!=mar.end() && it2!=mar.begin()){
    it=it2;
    --it;
    if(it2->second>it->second)
      td.insert(it2->first);
    else{
      if(td.count(it2->first))
	td.erase(it2->first);
    }
  }
}
VI otd;
int main(){
  ios::sync_with_stdio(0);
  cin.tie(0);
  in n;
  cin>>n;
  in ta;
  forn(i,n){
    cin>>ta;
    mar[i]=ta;
    if(i>0 && mar[i]>mar[i-1])
      td.insert(i);
  }
  while(!td.empty()){
    dct++;
    otd.clear();
    fors(i,td)
      otd.PB(*i);
    td.clear();
    reverse(all(otd));
    forv(i,otd){
      proc(otd[i]);
    }
  }
  cout<<dct<<endl;
  return 0;
}

----------
====================
----------
DATA-STRUCTURES.62
hard
----------
PROBLEM STATEMENT:
Given an array [expression].  

[expression].  

where [expression] respectively. 
Your task is to find the maximum possible value of [expression].
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <stack>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
    
    
    int n;
    cin>>n;
    
    int * arr;
    
    
    arr =  new int[n];
    
    
    for(int i=0;i<n;i++)cin>>arr[i];
    
    stack<int> S;
    
    int m = 0;
    
    for(int i=0;i<n;i++)
    {
        while(true)
        {
            if(S.empty())
            {
                S.push(arr[i]);
                break;
            }
            
            else if(S.top() < arr[i] )
            {
                m = max(m, S.top()^arr[i]);
                S.push(arr[i]);
                break;
            }
            else
            {
                S.pop();
            }
        }        
    }
    
    
    stack<int> S2;
    
    
    for(int i=n-1;i>=0;i--)
    {
        while(true)
        {
            if(S.empty())
            {
                S.push(arr[i]);
                break;
            }
            
            else if(S.top() < arr[i] )
            {
                m = max(m, S.top()^arr[i]);
                S.push(arr[i]);
                break;
            }
            else
            {
                S.pop();
            }
        }        
    }
    
    
    
    cout<<m<<endl;
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.63
medium
----------
PROBLEM STATEMENT:
You are a waiter at a party.
There are [expression].
Each plate has a number written on it.
Then there will be [expression]-th iteration,
you start picking up the plates in [expression]-th prime.
If the number is divisible, you stack that plate on pile [expression].
Otherwise, you stack that plate on pile [expression].
After [expression].
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <climits>
#include <set>
#include <map>
using namespace std;

int m, n;

const int mycount = 10000;
vector<int> prime_results;
vector<int> sieve(int n)
{
    set<int> primes;
    vector<int> vec;

    primes.insert(2);

    for(int i=3; i<=n ; i+=2)
    {
        primes.insert(i);
    }       

    int p=*primes.begin();
    vec.push_back(p);
    primes.erase(p);

    int maxRoot = sqrt(*(primes.rbegin()));

    while(primes.size() > 0)
    {
        if(p > maxRoot)
        {
            while(primes.size() > 0)
            {
                p=*primes.begin();
                vec.push_back(p);
                primes.erase(p);        
            }
            break;
        }

        int i = p*p;  
        int temp = (*(primes.rbegin()));

        while(i<=temp)
        {
            primes.erase(i);
            i += p;
            i += p;
        }

        p=*primes.begin();
        vec.push_back(p);
        primes.erase(p);
    }

    return vec;
}

void prepare() {
	prime_results = sieve(mycount);
}

int a[100005];
vector<int> thearray[mycount];
void process() {
    int i, j, k, q, l;
    
    prepare();
    scanf("%d %d", &n, &q);
    
    for (i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    
    for (i = 0; i < n; i++) {
        for (j = 0; j < q; j++) {
            k = prime_results[j];
            if (a[i] % k == 0) {
                thearray[j].push_back(a[i]);
                break;
            }
        }
        
        if (j == q) {
            thearray[j].push_back(a[i]);
        }
    }
    
    for (i = 0; i < q; i++) {
        if ((i & 1) == 0) {
            for (j = 0; j < thearray[i].size(); j++) {
                printf("%d\n", thearray[i][j]);
            }
        } else {
            for (j = thearray[i].size() - 1; j >= 0;j--) {
                printf("%d\n", thearray[i][j]);
            }
        }
    }
    
    if (q & 1) {
        for (j = 0; j < thearray[i].size(); j++) {
            printf("%d\n", thearray[i][j]);
        }
    } else {
        for (j = thearray[i].size() - 1; j >= 0;j--) {
            printf("%d\n", thearray[i][j]);
        }
    }
    
}

int main() {
    process();
    
    return 0;
}


----------
====================
----------
DATA-STRUCTURES.64
medium
----------
PROBLEM STATEMENT:
We're going to make our own Contacts application! The application must perform two types of operations:


add name, where [expression] as a new contact in the application.  
find partial, where [expression] and print the count on a new line.


Given [expression] sequential add and find operations, perform each operation in order.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
struct node{
    int h[26],n,f;
};
node null;
vector<node>trie;
void add(string &A){
    int i,j,p,q,act=0;
    for(i=0;i<A.size();i++){
        p=A[i]-'a';
        if(!trie[act].h[p]){
            trie[act].h[p]=trie.size();
            trie.push_back(null);
        }
        act=trie[act].h[p];
        trie[act].n++;
    }
}
int findi(string &A){
    int i,j,p,q,act=0;
    for(i=0;i<A.size();i++){
        p=A[i]-'a';
        if(!trie[act].h[p])return 0;
        act=trie[act].h[p];
    }
    return trie[act].n;
}
int main(){
    int i,j,p,q,N;
    string A,B;
    null.n=null.f=0;
    for(i=0;i<26;i++)null.h[i]=0;
    trie.push_back(null);
    cin>>N;
    for(i=0;i<N;i++){
        cin>>A>>B;
        if(A=="add")add(B);
        else cout<<findi(B)<<"\n";
    }
}

----------
====================
----------
DATA-STRUCTURES.65
hard
----------
PROBLEM STATEMENT:
Given [expression] strings is said to be GOOD SET if no string is prefix of another string else, it is BAD SET. (If two strings are identical, they are considered prefixes of each other.)

For example, aab, abcde, aabcd is BAD SET because aab is prefix of aabcd.  

Print GOOD SET if it satisfies the problem requirement. 
Else, print BAD SET and the first string for which the condition fails.  

Input Format 
First line contains [expression], the number of strings in the set. 
Then next [expression] string.  

Constraints 
[expression] 
[expression]  

Output Format 
Output GOOD SET if the set is valid. 
Else, output BAD SET followed by the first string for which the condition fails.  

Sample Input00  

7
aab
defgab
abcde
aabcde
cedaaa
bbbbbbbbbb
jabjjjad


Sample Output00  

BAD SET
aabcde


Sample Input01

4
aab
aac
aacghgh
aabghgh


Sample Output01  

BAD SET
aacghgh


Explanation 
aab is prefix of aabcde. So set is BAD SET and it fails at string aabcde.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

struct node {
    char end;
    struct node * next[10];
} head;

int check_prefix(string str){
    struct node *nptr = &head; 
    int i;
    int index;
    int new_node = 0;

    for(i=0;i<str.size();i++){
        index = ((int)str[i])%'a';
        if(nptr->next[index]==0) {
            nptr->next[index] = new node;
            nptr = nptr->next[index];
            memset (nptr,0,sizeof(struct node));
            new_node = 1;
        }
        else {
            nptr = nptr->next[index];
        }
        if(nptr->end == 1) {cout <<"BAD SET"<<endl; return 1;}
    }
    if(new_node == 0) {cout <<"BAD SET"<<endl; return 1;}
    nptr->end = 1; 
    return 0;
}


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    string str;
    int n;
    int i;
    
    cin >>n;
    for (i=0;i<n;i++){
        cin >> str;
        if (check_prefix(str))  break;
    }
    if(i!=n) cout << str <<endl;
    else cout << "GOOD SET" <<endl;
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.66
medium
----------
PROBLEM STATEMENT:
Meera teaches a class of [expression] students, and every day in her classroom is an adventure. Today is drawing day!

The students are sitting around a round table, and they are numbered from [expression] are sitting next to each other.

After letting the students draw for a certain period of time, Meera starts collecting their work to ensure she has time to review all the drawings before the end of the day. However, some of her students aren't finished drawing! Each student [expression] extra minutes to complete their drawing. 

Meera collects the drawings sequentially in the clockwise direction, starting with student ID [expression] minute for each student even if the drawing isn't ready. 

Given the values of [expression] on a new line. If there are multiple such IDs, select the smallest one.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;

typedef int _loop_int;
#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)
#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)
#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)

#define DEBUG(x) cout<<#x<<": "<<x<<endl
#define DEBUG_VEC(v) cout<<#v<<":";REP(i,v.size())cout<<" "<<v[i];cout<<endl
#define ALL(a) (a).begin(),(a).end()

#define CHMIN(a,b) a=min((a),(b))
#define CHMAX(a,b) a=max((a),(b))

// mod
const ll MOD = 1000000007ll;
#define FIX(a) ((a)%MOD+MOD)%MOD

// floating
typedef double Real;
const Real EPS = 1e-11;
#define EQ0(x) (abs(x)<EPS)
#define EQ(a,b) (abs(a-b)<EPS)
typedef complex<Real> P;

int n;
int t[125252];
int imos[125252];

int main(){
  scanf("%d",&n);
  REP(i,n)scanf("%d",t+i);
  REP(i,n){
    int tt = t[i];
    int from = i+1;
    int to = (i-tt+n)%n;
    if(from<=to){
      imos[from]++;
      imos[to+1]--;
    }else{
      imos[0]++;
      imos[to+1]--;
      imos[from]++;
      imos[n]--;
    }
  }
  REP(i,n+1)imos[i+1]+=imos[i];
  int ans = -1;
  int val = -1;
  REP(i,n){
    if(imos[i]>val){
      ans = i;
      val = imos[i];
    }
  }
  printf("%d\n",ans+1);
  return 0;
}

----------
====================
----------
DATA-STRUCTURES.67
hard
----------
PROBLEM STATEMENT:
Chinese Version
Russian Version

You are given a 3-D Matrix in which each block contains 0 initially. The first block is defined by the coordinate (1,1,1) and the last block is defined by the coordinate (N,N,N). There are two types of queries.

UPDATE x y z W


updates the value of block (x,y,z) to W.

QUERY x1 y1 z1 x2 y2 z2


calculates the sum of the value of blocks whose x coordinate is between x1 and x2 (inclusive), y coordinate between y1 and y2 (inclusive) and z coordinate between z1 and z2 (inclusive). 

Input Format 
The first line contains an integer T, the number of test-cases. T testcases follow. 
For each test case, the first line will contain two integers N and M separated by a single space. 
N defines the N * N * N matrix. 
M defines the number of operations. 
The next M lines will contain either  

 1. UPDATE x y z W
 2. QUERY  x1 y1 z1 x2 y2 z2 


Output Format 
Print the result for each QUERY.

Constrains 
1 
1 
1 
1 
1 
1 
1 
-109 9  

Sample Input

2
4 5
UPDATE 2 2 2 4
QUERY 1 1 1 3 3 3
UPDATE 1 1 1 23
QUERY 2 2 2 4 4 4
QUERY 1 1 1 3 3 3
2 4
UPDATE 2 2 2 1
QUERY 1 1 1 1 1 1
QUERY 1 1 1 2 2 2
QUERY 2 2 2 2 2 2


Sample Output

4
4
27
0
1
1


Explanation 
First test case, we are given a cube of 4 * 4 * 4 and 5 queries.  Initially all the cells (1,1,1) to (4,4,4) are 0. 
UPDATE 2 2 2 4 makes the cell (2,2,2) = 4 
QUERY 1 1 1 3 3 3. As (2,2,2) is updated to 4 and the rest are all 0. The answer to this query is 4. 
UPDATE 1 1 1 23. updates the cell (1,1,1) to 23. 
QUERY 2 2 2 4 4 4. Only the cell (1,1,1) and (2,2,2) are non-zero and (1,1,1) is not between (2,2,2) and (4,4,4). So, the answer is 4. 
QUERY 1 1 1 3 3 3. 2 cells are non-zero and their sum is 23+4 = 27. 
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
struct _ { ios_base::Init i; _() { cin.sync_with_stdio(0); cin.tie(0); } } _;

const int N = 102;
long long bit[N][N][N];

long long que(int x, int y, int z)
{
    long long ret = 0;
    for(int i = x; i >= 0; i = (i&(i+1))-1)
        for(int j = y; j >= 0; j = (j&(j+1))-1)
            for(int k = z; k >= 0; k = (k&(k+1))-1)
                ret += bit[i][j][k];
    return ret;
}

int main()
{
    int t; cin >> t;
    while(t--)
    {
        int n, m; cin >> n >> m;
        for(int i = 0; i < N; ++i)
            for(int j = 0; j < N; ++j)
                for(int k = 0; k < N; ++k)
                    bit[i][j][k] = 0;

        while(m--)
        {
            string a; cin >> a;
            if(a == "UPDATE")
            {
                int x, y, z; cin >> x >> y >> z;
                long long val; cin >> val;

                long long cur;
                {
                    long long x1 = x, y1 = y, z1 = z;
                    long long x2 = x, y2 = y, z2 = z;
                    cur = que(x2, y2, z2);
                    cur -= (x1 == 0) ? 0 : que(x1-1, y2, z2);
                    cur -= (y1 == 0) ? 0 : que(x2, y1-1, z2);
                    cur -= (z1 == 0) ? 0 : que(x2, y2, z1-1);
                    cur += (x1 == 0 or y1 == 0) ? 0 : que(x1-1, y1-1, z2);
                    cur += (x1 == 0 or z1 == 0) ? 0 : que(x1-1, y2, z1-1);
                    cur += (y1 == 0 or z1 == 0) ? 0 : que(x2, y1-1, z1-1);
                    cur -= (x1 == 0 or y1 == 0 or z1 == 0) ? 0 : que(x1-1, y1-1, z1-1);
                }

                val = val - cur;
                for(int i = x; i < N; i |= (i+1))
                    for(int j = y; j < N; j |= (j+1))
                        for(int k = z; k < N; k |= (k+1))
                            bit[i][j][k] += val;
            }
            else
            {
                int x1, y1, z1; cin >> x1 >> y1 >> z1;
                int x2, y2, z2; cin >> x2 >> y2 >> z2;

                long long ret = que(x2, y2, z2);
                ret -= (x1 == 0) ? 0 : que(x1-1, y2, z2);
                ret -= (y1 == 0) ? 0 : que(x2, y1-1, z2);
                ret -= (z1 == 0) ? 0 : que(x2, y2, z1-1);
                ret += (x1 == 0 or y1 == 0) ? 0 : que(x1-1, y1-1, z2);
                ret += (x1 == 0 or z1 == 0) ? 0 : que(x1-1, y2, z1-1);
                ret += (y1 == 0 or z1 == 0) ? 0 : que(x2, y1-1, z1-1);
                ret -= (x1 == 0 or y1 == 0 or z1 == 0) ? 0 : que(x1-1, y1-1, z1-1);

                cout << ret << '\n';
            }
        }
    }
    return 0;
}
----------
====================
----------
DATA-STRUCTURES.68
medium
----------
PROBLEM STATEMENT:
A cricket match is going to be held. The field is represented by a 1D plane. A cricketer, Mr. X has [expression] favorite shots. Each shot has a particular range.
The range of the  [expression]i. That means his favorite shot can be anywhere in this range. Each player on the opposite team 
can field only in a particular range. Player [expression] players. 
[expression] can stop. 
Your task is to find:

[expression].

Game Rules: A player can stop the [expression] shot if the range overlaps with the player's fielding range.
For more clarity about overlapping, study the following figure:  


----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std ;

struct segment 
{
    bool isleft ;
    int point ;
    bool isfielder ;
} ;
vector < segment > v ( 400010 ) ;
vector < segment > :: iterator it ;

bool cmpr ( segment & a , segment & b )
{
    if ( a.point != b.point )
    {
        return a.point < b.point ;
    }
    if ( a.isleft != b.isleft )
    {
        return a.isleft ;
    }
    return ! ( a.isfielder ) ;
}

int main ()
{
    int n , m ;
    cin >> n >> m ;
    int counter = 0 ;
    for ( int i = 0 ; i < n ; i ++ )
    {
        int a , b;
        cin >> a >> b ;
        segment temp ;
        temp.isleft = true ;
        temp.point = a ;
        temp.isfielder = false ;
        v [ counter ++ ] = temp ;
        temp.isleft = false ;
        temp.point = b ;
        v [ counter ++ ] = temp ;
    }
    for ( int i = 0 ; i < m ; i ++ )
    {
        int a , b;
        cin >> a >> b ;
        segment temp ;
        temp.isleft = true ;
        temp.point = a ;
        temp.isfielder = true ;
        v [ counter ++ ] = temp ;
        temp.isleft = false ;
        temp.point = b ;
        v [ counter ++ ] = temp ;
    }
    it = v.begin () ;
    advance ( it , counter ) ;
    sort ( v.begin () , it , cmpr ) ;       // segment intersection problem 
    int bat = 0 , field = 0 ;
    long long int ans = 0 ;
    for ( int i = 0 ; i < counter ; i ++ )
    {
        if ( v [ i ].isleft == true )
        {
            if ( v [ i ].isfielder )
            {
                ans += bat ;                // intersects with all the batsman 
                field ++ ;
            }
            else 
            {
                ans += field ;
                bat ++ ;
            }
        }
        else
        {
            if ( v [ i ].isfielder )
            {
                field -- ;    
            }
            else
            {
                bat -- ;    
            }
        }
    }
    cout << ans ;
    return 0 ;
}
----------
====================
----------
DATA-STRUCTURES.69
hard
----------
PROBLEM STATEMENT:
Enter-View [expression], the distance from the left borderline of the country. You can treat all cities as single points.

Unfortunately, the dictator of telecommunication of EV (Mr. S. Treat Jr.) doesn't know anything about the modern telecom technologies, except for peer-to-peer connections. Even worse, his thoughts on peer-to-peer connections are extremely faulty: he believes that, if [expression] to every other city of EV - this way he can guarantee no congestion will ever occur!

Mr. Treat hires you to find out how much cable they need to implement this telecommunication system, given the coordination of the cities and their respective population. 

Note that The connections between the cities can be shared. Look at the example for the detailed explanation.

Input Format  

A number [expression] blocks, each representing a scenario.

Each scenario consists of three lines. The first line indicates the number of cities (N). The second line indicates the coordinates of the N cities. The third line contains the population of each of the cities. The cities needn't be in increasing order in the input.

Output Format  

For each scenario of the input, write the length of cable needed in a single line modulo [expression].

Constraints  

[expression] 
[expression] 
[expression] 
Border to border length of the country [expression]

Sample Input  

2  
3  
1 3 6  
10 20 30  
5  
5 55 555 55555 555555  
3333 333 333 33 35


Sample Output  

280  
463055586

----------
TOP SOLUTION:
----------

#include <algorithm>
#include <map>

#include <iostream>
#include <istream>
#include <ostream>

using namespace std;

#define M 1000000007LL

typedef long long mint;

class any_node
{
	public:

	mint min_x_, max_x_;

	mint cities_;
	mint dist_l_, dist_r_;

	any_node(mint min_x, mint max_x, mint cities, mint dist_l, mint dist_r): min_x_(min_x), max_x_(max_x), cities_(cities), dist_l_(dist_l), dist_r_(dist_r)
	{
	}

	virtual ~any_node()
	{
	}

	virtual any_node *ins(any_node *l) = 0;
	virtual any_node *drop(mint x) = 0;
	virtual mint part(mint x) = 0;
	virtual bool in(mint x) = 0;
};

class node : public any_node
{
	public:

	bool banzai_;

	any_node *left_;
	any_node *right_;

	node(any_node *l, any_node *r): any_node(min(l->min_x_, r->min_x_), max(l->max_x_, r->max_x_), 0, 0, 0), banzai_(true)
	{
		if (l->max_x_ < r->min_x_)
		{
			left_ = l;
			right_ = r;
		}
		else
		{
			left_ = r;
			right_ = l;
		}

		cities_ = r->cities_ + l->cities_;
		//dist_ = (((((((l->cities_ * r->cities_) % M) * (r->min_x_ - l->max_x_)) % M) + l->dist_) % M) + r->dist_) % M;
		dist_l_ = (((left_->dist_l_ + right_->dist_l_) % M) + (((right_->min_x_ - left_->min_x_) * right_->cities_) % M)) % M;
		dist_r_ = (((left_->dist_r_ + right_->dist_r_) % M) + (((right_->max_x_ - left_->max_x_) * left_->cities_) % M)) % M;
	}

	virtual ~node()
	{
		if (banzai_)
		{
			delete left_;
			delete right_;
		}
	}

	virtual any_node *ins(any_node *l)
	{
		if (left_->max_x_ > l->min_x_)
		{
			left_ = left_->ins(l);
		}
		else if (right_->min_x_ < l->max_x_)
		{
			right_ = right_->ins(l);
		}
		else
		{
			left_ = left_->ins(l);
		}

		min_x_ = min(left_->min_x_, right_->min_x_);
		max_x_ = max(left_->max_x_, right_->max_x_);
		cities_ = right_->cities_ + left_->cities_;
		//dist_ = (((((((left_->cities_ * right_->cities_) % M) * (right_->min_x_ - left_->max_x_)) % M) + right_->dist_) % M) + left_->dist_) % M;
		dist_l_ = (((left_->dist_l_ + right_->dist_l_) % M) + (((right_->min_x_ - left_->min_x_) * right_->cities_) % M)) % M;
		dist_r_ = (((left_->dist_r_ + right_->dist_r_) % M) + (((right_->max_x_ - left_->max_x_) * left_->cities_) % M)) % M;

		return this;
	}

	virtual any_node *drop(mint x)
	{
		if ((max_x_ < x) || (min_x_ > x))
		{
			return this;
		}

		left_ = left_->drop(x);
		right_ = right_->drop(x);

		banzai_ = false;

		if ((left_ == NULL) && (right_ == NULL))
		{
			delete this;

			return NULL;
		}
		else if ((left_ == NULL) && (right_ != NULL))
		{
			delete this;

			return right_;
		}
		else if ((left_ != NULL) && (right_ == NULL))
		{
			delete this;

			return left_;
		}
		else
		{
			min_x_ = min(left_->min_x_, right_->min_x_);
			max_x_ = max(left_->max_x_, right_->max_x_);
			cities_ = right_->cities_ + left_->cities_;
			//dist_ = (((((((left_->cities_ * right_->cities_) % M) * (right_->min_x_ - left_->max_x_)) % M) + right_->dist_) % M) + left_->dist_) % M;
			dist_l_ = (((left_->dist_l_ + right_->dist_l_) % M) + (((right_->min_x_ - left_->min_x_) * right_->cities_) % M)) % M;
			dist_r_ = (((left_->dist_r_ + right_->dist_r_) % M) + (((right_->max_x_ - left_->max_x_) * left_->cities_) % M)) % M;

			banzai_ = true;

			return this;
		}
	}

	virtual mint part(mint x)
	{
		mint left_part, right_part;

		if (left_->in(x))
		{
			left_part = left_->part(x);
		}
		else
		{
			if (x < left_->min_x_)
			{
				left_part = ((((left_->min_x_ - x) * left_->cities_) % M) + left_->dist_l_) % M;
			}
			else
			{
				left_part = ((((x - left_->max_x_) * left_->cities_) % M) + left_->dist_r_) % M;
			}
		}

		if (right_->in(x))
		{
			right_part = right_->part(x);
		}
		else
		{
			if (x < right_->min_x_)
			{
				right_part = ((((right_->min_x_ - x) * right_->cities_) % M) + right_->dist_l_) % M;
			}
			else
			{
				right_part = ((((x - right_->max_x_) * right_->cities_) % M) + right_->dist_r_) % M;
			}
		}

		return left_part + right_part % M;
	}

	virtual bool in(mint x)
	{
		return (min_x_ <= x) && (x <= max_x_);
	}
};

class leaf : public any_node
{
	public:

	leaf(mint x): any_node(x, x, 1, 0, 0)
	{
	}

	virtual ~leaf()
	{
	}

	virtual any_node *ins(any_node *l)
	{
		return new node(this, l);
	}

	virtual any_node *drop(mint x)
	{
		if (min_x_ == x)
		{
			delete this;

			return NULL;
		}

		return this;
	}

	virtual mint part(mint x)
	{
		if (x > max_x_)
		{
			return x - max_x_;
		}

		return min_x_ - x;
	}

	virtual bool in(mint x)
	{
		return x == max_x_;
	}
};

class tree
{
	public:

	any_node *root_;

	tree(): root_(NULL)
	{
	}

	~tree()
	{
		if (root_ != NULL)
		{
			delete root_;
		}
	}

	void ins(mint x)
	{
		leaf *nl = new leaf(x);

		if (root_ == NULL)
		{
			root_ = nl;

			return;
		}

		root_ = root_->ins(nl);
	}

	void drop(mint x)
	{
		/*
		if (root_ == NULL)
		{
			return;
		}
		*/

		root_ = root_->drop(x);
	}

	mint part(mint x)
	{
		if (root_ == NULL)
		{
			return 0;
		}

		return root_->part(x);
	}
};

int main()
{
	mint t;

	cin >> t;

	for (; t; --t)
	{
		mint n;

		cin >> n;

		mint *x = new mint[n];
		mint *p = new mint[n];

		for (mint i = 0; i != n; ++i)
		{
			cin >> x[i];
		}

		for (mint i = 0; i != n; ++i)
		{
			cin >> p[i];
		}

		tree coord;
		map<pair<mint, mint>, mint> pop;

		for (mint i = 0; i != n; ++i)
		{
			pair<mint, mint> key(p[i], 0);
			
			map<pair<mint, mint>, mint>::iterator k;

			while ((k = pop.find(key)) != pop.end())
			{
				++key.second;
			}

			pop[key] = x[i];

			coord.ins(x[i]);
		}

		mint total = 0;

		for (map<pair<mint, mint>, mint>::reverse_iterator i = pop.rbegin(); i != pop.rend(); ++i)
		{
			coord.drop(i->second);

			total = (((coord.part(i->second) * (i->first).first) % M) + total) % M;
		}

		cout << total << endl;

		delete[] x;
		delete[] p;
	}

	return 0;
}

----------
====================
----------
DATA-STRUCTURES.70
advanced
----------
PROBLEM STATEMENT:
A subsequence of a sequence is a sequence which is obtained by deleting zero or more elements from the sequence.&nbsp;

You are given a sequence A in which every element is a pair of integers &nbsp;i.e &nbsp;A = [(a1, w1), (a2, w2),..., (aN, wN)].

For a subseqence B = [(b1, v1), (b2, v2), ...., (bM, vM)] of the given sequence :&nbsp;


We call it increasing if for every i (1 i M ) , bi i+1.
Weight(B) = v1 + v2 + ... + vM.  


Task: 
Given a sequence, output the maximum weight formed by an increasing subsequence.

Input: 
The first line of input contains a single integer T. T test-cases follow. The first line of each test-case contains an integer N. The next line contains a1, a2 ,... , aN&nbsp;separated by a single space. The next line contains w1, w2, ..., wN&nbsp;separated by a single space.

Output: 
For each test-case output a single integer: The maximum weight of increasing subsequences of the given sequence.  

Constraints: 
1 T 
1 N 
1 ai 9, where i ∈ [1..N] 
1 wi 9, where i ∈ [1..N]  

Sample Input:

2  
4  
1 2 3 4  
10 20 30 40  
8  
1 2 3 4 1 2 3 4  
10 20 30 40 15 15 15 50


Sample Output:

100  
110


Explanation: 
In the first sequence, the maximum size increasing subsequence is 4, and there's only one of them. We choose B = [(1, 10), (2, 20), (3, 30), (4, 40)], and we have Weight(B) = 100.

In the second sequence, the maximum size increasing subsequence is still 4, but there are now 5 possible subsequences:

1 2 3 4  
10 20 30 40

1 2 3 4  
10 20 30 50

1 2 3 4  
10 20 15 50

1 2 3 4  
10 15 15 50

1 2 3 4  
15 15 15 50


Of those, the one with the greatest weight is B = [(1, 10), (2, 20), (3, 30), (4, 50)], with Weight(B) = 110.

Please note that this is not the maximum weight generated from picking the highest value element of each index. That value, 115, comes from&nbsp;[(1, 15), (2, 20), (3, 30), (4, 50)], which is not a valid subsequence because it cannot be created by only deleting elements in the original sequence.
----------
TOP SOLUTION:
----------

#include <algorithm>

#include <iostream>
#include <istream>
#include <ostream>

using namespace std;

typedef long long mint;

class any_node
{
    public:

    mint depth_;
    mint max_depth_;

    mint min_a_, max_a_;
    mint min_w_, max_w_;

    any_node(mint depth, mint max_depth): depth_(depth), max_depth_(max_depth)
    {
    }

    virtual ~any_node()
    {
    }

    virtual any_node *ins(any_node *l) = 0;
    virtual mint max_w(mint a) = 0;
    virtual any_node *drop(mint a, mint w) = 0;
};

class node : public any_node
{
    public:

    bool banzai_;

    any_node *left_;
    any_node *right_;

    node(mint depth, mint max_depth, any_node *l, any_node *r): any_node(depth, max_depth), banzai_(true)
    {
        min_a_ = min(l->min_a_, r->min_a_);
        max_a_ = max(l->max_a_, r->max_a_);
        min_w_ = min(l->min_w_, r->min_w_);
        max_w_ = max(l->max_w_, r->max_w_);

        if (l->max_a_ < r->min_a_)
        {
            left_ = l;
            right_ = r;
        }
        else
        {
            left_ = r;
            right_ = l;
        }
    }

    virtual ~node()
    {
        if (banzai_)
        {
            delete left_;
            delete right_;
        }
    }

    virtual any_node *ins(any_node *l)
    {
        ++(l->depth_);

        if (left_->max_a_ > l->min_a_)
        {
            left_ = left_->ins(l);
        }
        else if (right_->min_a_ < l->max_a_)
        {
            right_ = right_->ins(l);
        }
        else if (left_->max_depth_ < right_->max_depth_)
        {
            left_ = left_->ins(l);
        }
        else
        {
            right_ = right_->ins(l);
        }

        max_depth_ = max(left_->max_depth_, right_->max_depth_);

        min_a_ = min(left_->min_a_, right_->min_a_);
        max_a_ = max(left_->max_a_, right_->max_a_);
        min_w_ = min(left_->min_w_, right_->min_w_);
        max_w_ = max(left_->max_w_, right_->max_w_);

        return this;
    }

    virtual mint max_w(mint a)
    {
        mint left_max_w = (a < left_->min_a_ ? 0 : (a > left_->max_a_ ? left_->max_w_ : left_->max_w(a)));
        mint right_max_w = (a < right_->min_a_ ? 0 : (a > right_->max_a_ ? right_->max_w_ : right_->max_w(a)));

        return max(left_max_w, right_max_w);
    }

    // does not update depth_ or max_depth_ which might screw up later insertions
    virtual any_node *drop(mint a, mint w)
    {
        if ((max_a_ < a) || (min_w_ > w))
        {
            return this;
        }

        left_ = left_->drop(a, w);
        right_ = right_->drop(a, w);

        banzai_ = false;

        if ((left_ == NULL) && (right_ == NULL))
        {
            delete this;

            return NULL;
        }
        else if ((left_ == NULL) && (right_ != NULL))
        {
            delete this;

            return right_;
        }
        else if ((left_ != NULL) && (right_ == NULL))
        {
            delete this;

            return left_;
        }
        else
        {
            min_a_ = min(left_->min_a_, right_->min_a_);
            max_a_ = max(left_->max_a_, right_->max_a_);
            min_w_ = min(left_->min_w_, right_->min_w_);
            max_w_ = max(left_->max_w_, right_->max_w_);

            banzai_ = true;

            return this;
        }
    }
};

class leaf : public any_node
{
    public:

    leaf(mint depth, mint max_depth): any_node(depth, max_depth)
    {
    }

    virtual ~leaf()
    {
    }

    virtual any_node *ins(any_node *l)
    {
        if (l->min_a_ == min_a_)
        {
            min_w_ = max_w_ = max(l->min_w_, max_w_);

            delete l;

            return this;
        }

        ++(l->depth_);
        ++(l->max_depth_);

        return new node(depth_++, max_depth_++, this, l);
    }

    virtual mint max_w(mint a)
    {
        return a > max_a_ ? max_w_ : 0;
    }

    virtual any_node *drop(mint a, mint w)
    {
        if ((max_a_ <= a) || (max_w_ > w))
        {
            return this;
        }

        delete this;

        return NULL;
    }
};

class tree
{
    public:

    any_node *root_;

    tree(): root_(NULL)
    {
    }

    ~tree()
    {
        if (root_ != NULL)
        {
            delete root_;
        }
    }

    void prc(mint a, mint w)
    {
        mint wmax = max_w(a) + w;
        drop(a, wmax);
        ins(a, wmax);
    }

    void ins(mint a, mint w)
    {
        leaf *nl = new leaf(0, 0);

        nl->min_a_ = nl->max_a_ = a;
        nl->min_w_ = nl->max_w_ = w;

        if (root_ == NULL)
        {
            root_ = nl;

            return;
        }

        root_ = root_->ins(nl);
    }

    mint max_w(mint a)
    {
        if (root_ == NULL)
        {
            return 0;
        }

        return root_->max_w(a);
    }

    void drop(mint a, mint w)
    {
        if (root_ == NULL)
        {
            return;
        }

        root_ = root_->drop(a, w);
    }
};

int main()
{
    mint c;

    cin >> c;

    for (; c; --c)
    {
        mint n;

        cin >> n;

        mint *a = new mint[n];
        mint *w = new mint[n];

        for (mint i = 0; i != n; ++i)
        {
            cin >> a[i];
        }

        for (mint i = 0; i != n; ++i)
        {
            cin >> w[i];
        }

        tree tr;

        for (mint i = 0; i != n; ++i)
        {
            tr.prc(a[i], w[i]);
        }

        cout << tr.root_->max_w_ << endl;

        delete[] a;
        delete[] w;
    }

    return 0;
}

----------
====================
----------
DATA-STRUCTURES.71
medium
----------
PROBLEM STATEMENT:
Jim has invented a new flying object called HZ42. HZ42 is like a broom and can only fly horizontally, independent of the environment. One day, Jim started his flight from Dubai's highest skyscraper, traveled some distance and landed on another skyscraper of same height! So much fun! But unfortunately, new skyscrapers have been built recently.

Let us describe the problem in one dimensional space. We have in total [expression].

Help Jim in counting the number of valid paths represented by ordered pairs [expression].  

Input Format

The first line contains [expression] space separated integers representing the heights of the skyscrapers. 

Output Format

Print an integer that denotes the number of valid routes.

Constraints

[expression].

Sample Input #00

6
3 2 1 2 3 3


Sample Output #00

8


Sample Input #01

3
1 1000 1


Sample Output #01

0


Explanation

First testcase: (1, 5), (1, 6) (5, 6) and (2, 4) and the routes in the opposite directions are the only valid routes. 

Second testcase: (1, 3) and (3, 1) could have been valid, if there wasn't a big skyscraper with height 1000 between them.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <vector>
#include <stack>
#include <algorithm>
using namespace std;

const int NMAX = 300010, CMAX = 1000010;

int N, V[NMAX], Right[NMAX];
stack<int> S;
vector<int> Val[CMAX];
long long Ans;

int main()
{
  //  freopen("c.in", "r", stdin);
   // freopen("c.out", "w", stdout);

    scanf("%i", &N);
    for(int i = 1; i <= N; ++ i)
    {
        scanf("%i", &V[i]);
        Val[V[i]].push_back(i);
    }

    V[N + 1] = CMAX;

    S.push(N + 1);
    for(int i = N; i; -- i)
    {
        while(!S.empty() && V[S.top()] <= V[i]) S.pop();
        Right[i] = S.top();
        S.push(i);
    }

    for(int i = CMAX - 1; i >= 1; -- i)
    {
        int Ptr = 0;
        for(int j = 0; j < Val[i].size(); )
        {
            while(Ptr < Val[i].size() && Val[i][Ptr] <= Right[ Val[i][j] ]) Ptr ++;
            int Len = Ptr - j;
            Ans += 1LL * Len * (Len - 1);
            j = Ptr;
        }
    }

    printf("%lld", Ans);
}

----------
====================
----------
DATA-STRUCTURES.72
hard
----------
PROBLEM STATEMENT:
Consider a lowercase English alphabetic letter character denoted by [expression] . 

Given a zero-indexed string, [expression] where each query takes one of the following two forms:


1 i j t: All letters in the inclusive range from [expression] times.  
2 i j: Consider all indices in the inclusive range from [expression] on a new line. Two palindromic subsets are considered to be different if their component characters came from different indices in the original string.


Note
Two palindromic subsets are considered to be different if their component characters came from different indices in the original string.
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) { }
	ModInt(signed sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
};
typedef ModInt<1000000007> mint;

const int Alphas = 26;
struct Val {
	int alpha;
};
struct Sum {
	int cnt[Alphas];
	Sum() : cnt{} {}
	Sum(const Val &val, int pos) : cnt{} { ++cnt[val.alpha]; }
	Sum &operator+=(const Sum &that) {
		rep(a, Alphas)
			cnt[a] += that.cnt[a];
		return *this;
	}
	Sum operator+(const Sum &that) const { return Sum(*this) += that; }
};
struct Add {
	int shift;
	Add(): shift(0) { }
	Add &operator+=(const Add &that) {
		(shift += that.shift) %= Alphas;
		return *this;
	}
	void addToVal(Val &val, int pos) const {
		(val.alpha += shift) %= Alphas;
	}
	void addToSum(Sum &sum, int left, int right) const {
		rotate(sum.cnt, sum.cnt + (Alphas - shift) % Alphas, sum.cnt + Alphas);
	}
};

struct SegmentTree {
	vector<Val> leafs;
	vector<Sum> nodes;
	vector<Add> add;
	vector<int> leftpos, rightpos;
	int n, n2;
	void init(int n_, const Val &v = Val()) { init(vector<Val>(n_, v)); }
	void init(const vector<Val> &u) {
		n = 1; while (n < (int)u.size()) n *= 2;
		n2 = (n - 1) / 2 + 1;
		leafs = u; leafs.resize(n, Val());
		nodes.resize(n);
		for (int i = n - 1; i >= n2; --i)
			nodes[i] = Sum(leafs[i * 2 - n], i * 2 - n) + Sum(leafs[i * 2 + 1 - n], i * 2 + 1 - n);
		for (int i = n2 - 1; i > 0; --i)
			nodes[i] = nodes[i * 2] + nodes[i * 2 + 1];
		add.assign(n, Add());

		leftpos.resize(n); rightpos.resize(n);
		for (int i = n - 1; i >= n2; --i) {
			leftpos[i] = i * 2 - n;
			rightpos[i] = (i * 2 + 1 - n) + 1;
		}
		for (int i = n2 - 1; i > 0; --i) {
			leftpos[i] = leftpos[i * 2];
			rightpos[i] = rightpos[i * 2 + 1];
		}
	}
	Val get(int i) {
		int indices[128];
		int k = getIndices(indices, i, i + 1);
		propagateRange(indices, k);
		return leafs[i];
	}
	Sum getRangeCommutative(int i, int j) {
		int indices[128];
		int k = getIndices(indices, i, j);
		propagateRange(indices, k);
		Sum res = Sum();
		for (int l = i + n, r = j + n; l < r; l >>= 1, r >>= 1) {
			if (l & 1) res += sum(l++);
			if (r & 1) res += sum(--r);
		}
		return res;
	}
	Sum getRange(int i, int j) {
		int indices[128];
		int k = getIndices(indices, i, j);
		propagateRange(indices, k);
		Sum res = Sum();
		for (; i && i + (i&-i) <= j; i += i&-i)
			res += sum((n + i) / (i&-i));
		for (k = 0; i < j; j -= j&-j)
			indices[k++] = (n + j) / (j&-j) - 1;
		while (--k >= 0) res += sum(indices[k]);
		return res;
	}
	void set(int i, const Val &x) {
		int indices[128];
		int k = getIndices(indices, i, i + 1);
		propagateRange(indices, k);
		leafs[i] = x;
		mergeRange(indices, k);
	}
	void addToRange(int i, int j, const Add &x) {
		if (i >= j) return;
		int indices[128];
		int k = getIndices(indices, i, j);
		propagateRange(indices, k);
		int l = i + n, r = j + n;
		if (l & 1) { int p = (l++) - n; x.addToVal(leafs[p], p); }
		if (r & 1) { int p = (--r) - n; x.addToVal(leafs[p], p); }
		for (l >>= 1, r >>= 1; l < r; l >>= 1, r >>= 1) {
			if (l & 1) add[l++] += x;
			if (r & 1) add[--r] += x;
		}
		mergeRange(indices, k);
	}
private:
	int getIndices(int indices[], int i, int j) const {
		int k = 0, l, r;
		if (i >= j) return 0;
		for (l = (n + i) >> 1, r = (n + j - 1) >> 1; l != r; l >>= 1, r >>= 1) {
			indices[k++] = l;
			indices[k++] = r;
		}
		for (; l; l >>= 1) indices[k++] = l;
		return k;
	}
	void propagateRange(int indices[], int k) {
		for (int i = k - 1; i >= 0; --i)
			propagate(indices[i]);
	}
	void mergeRange(int indices[], int k) {
		for (int i = 0; i < k; ++i)
			merge(indices[i]);
	}
	inline void propagate(int i) {
		if (i >= n) return;
		add[i].addToSum(nodes[i], leftpos[i], rightpos[i]);
		if (i * 2 < n) {
			add[i * 2] += add[i];
			add[i * 2 + 1] += add[i];
		}
		else {
			add[i].addToVal(leafs[i * 2 - n], i * 2 - n);
			add[i].addToVal(leafs[i * 2 + 1 - n], i * 2 + 1 - n);
		}
		add[i] = Add();
	}
	inline void merge(int i) {
		if (i >= n) return;
		nodes[i] = sum(i * 2) + sum(i * 2 + 1);
	}
	inline Sum sum(int i) {
		propagate(i);
		return i < n ? nodes[i] : Sum(leafs[i - n], i - n);
	}
};

int main() {
	int n; int q;
	while (~scanf("%d%d", &n, &q)) {
		vector<mint> pow2s(n + 1);
		pow2s[0] = 1;
		rer(i, 1, n)
			pow2s[i] = pow2s[i - 1] + pow2s[i - 1];
		vector<mint> evenWays(n + 1);
		evenWays[0] = 1;
		rer(i, 1, n)
			evenWays[i] = pow2s[i - 1];
		char S[100001];
		scanf("%s", S);
		vector<Val> init(n);
		rep(i, n)
			init[i].alpha = S[i] - 'a';
		SegmentTree segt;
		segt.init(init);
		for (int ii = 0; ii < q; ++ii) {
			int ty;
			scanf("%d", &ty);
			if (ty == 1) {
				int l; int r; int t;
				scanf("%d%d%d", &l, &r, &t), ++r;
				Add add;
				add.shift = t % Alphas;
				segt.addToRange(l, r, add);
			}
			else if (ty == 2) {
				int l; int r;
				scanf("%d%d", &l, &r), ++r;
				Sum sum = segt.getRangeCommutative(l, r);
				mint prefix[Alphas + 1], suffix[Alphas + 1];
				prefix[0] = suffix[Alphas] = 1;
				rep(a, Alphas)
					prefix[a + 1] = prefix[a] * evenWays[sum.cnt[a]];
				for (int a = Alphas - 1; a >= 0; --a)
					suffix[a] = suffix[a + 1] * evenWays[sum.cnt[a]];
				mint ans = prefix[Alphas];
				rep(a, Alphas)
					ans += prefix[a] * suffix[a + 1] *
						(pow2s[sum.cnt[a]] - evenWays[sum.cnt[a]]);
				ans -= 1;
				printf("%d\n", ans.get());
			}
			else abort();
		}
	}
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.73
expert
----------
PROBLEM STATEMENT:
Taylor loves trees, and this new challenge has him stumped!

Consider a tree, [expression], attached to it. 

A query on tree [expression] such that the following four conditions are all satisfied: 


[expression]
[expression].
[expression].
[expression]  


Given [expression] queries, process each query in order, printing the pair count for each query on a new line.
----------
TOP SOLUTION:
----------
#include <cstdlib>
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
#include <cstring>
#include <cassert>

using namespace std;

typedef long long LL;
typedef unsigned long long ULL;

#define SIZE(x) (int((x).size()))
#define rep(i,l,r) for (int i=(l); i<=(r); i++)
#define repd(i,r,l) for (int i=(r); i>=(l); i--)
#define rept(i,c) for (__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)

#ifndef ONLINE_JUDGE
#define debug(x) { cerr<<#x<<" = "<<(x)<<endl; }
#else
#define debug(x) {}
#endif

#define maxn 100010
#define LIM 100

int ta[maxn];

void ta_modify(int x, int y)
{
	while (x<maxn) ta[x]+=y, x+=x&-x;
}

int ta_query(int x)
{
	int ret=0;
	while (x) ret+=ta[x], x-=x&-x;
	return ret;
}

void ds_modify(int l, int r, int c)
{
	ta_modify(l,c);
	ta_modify(r+1,-c);
}

int ds_query(int v)
{
	return ta_query(v);
}

int dfsN;
int dfsLeft[maxn], dfsRight[maxn];
int lg2[maxn], p[maxn][17], depth[maxn];
vector<int> e[maxn];

void dfs(int cur, int pre, int dep)
{
	dfsN++; dfsLeft[cur]=dfsN;
	depth[cur]=dep;
	p[cur][0]=pre;
	rep(i,1,lg2[dep]) p[cur][i]=p[p[cur][i-1]][i-1];
	rept(it,e[cur]) if (*it!=pre) dfs(*it,cur,dep+1);
	dfsRight[cur]=dfsN;
}

int movedep(int x, int y)
{
	if (y<0) return 0;
	while (y) x=p[x][lg2[y&-y]], y-=y&-y;
	return x;
}

int lca(int x, int y)
{
	if (depth[x]<depth[y]) swap(x,y);
	x=movedep(x,depth[x]-depth[y]);
	repd(i,16,0)
		if (p[x][i]!=p[y][i])
		{
			x=p[x][i]; y=p[y][i];
		}
	if (x==y) return x;
	return p[x][0];
}

int get_dist(int x, int y)
{
	int z=lca(x,y);
	return depth[x]+depth[y]-2*depth[z]+1;
}

int all, ti[5][2];

void check_intersect(int p1, int p2, int q1, int q2)
{
	if (depth[p2]>depth[q2])
	{
		swap(p1,q1); swap(p2,q2);
	}
	if (depth[p1]<depth[q2]) return;
	if (lca(p1,q2)!=q2 || lca(q2,p2)!=p2) return;
	int z=lca(p1,q1);
	rep(i,1,all) if (ti[i][0]==z && ti[i][1]==q2) return;
	rep(i,1,all) if (ti[i][1]==z && ti[i][0]==q2) return;
	//if (z==q2) rep(i,1,all) if (ti[i][0]==z || ti[i][1]==z) return;
	all++; ti[all][0]=z; ti[all][1]=q2;
}

struct tasktype
{
	int x, y, c;
	tasktype() {}
	tasktype(int x, int y, int c): x(x), y(y), c(c) {}
};

vector<tasktype> eventAddList[maxn], eventQueryList[maxn];

void addQueryEvent(int i, int p1, int q1, int c)
{
	p1=dfsLeft[p1]; q1=dfsLeft[q1];
	eventQueryList[p1].push_back(tasktype(q1,i,c));
}

void addContributionEvent(int p1, int p2, int q1, int q2)
{
	eventAddList[p1].push_back(tasktype(q1,q2,1));
	eventAddList[p2+1].push_back(tasktype(q1,q2,-1));
}

void add_task(int i, int p1, int p2, int q1, int q2)
{
	if (!p1 || !p2 || !q1 || !q2) return;
	addQueryEvent(i,p1,q1,1);
	if (p[q2][0]) addQueryEvent(i,p1,p[q2][0],-1);
	if (p[p2][0]) addQueryEvent(i,p[p2][0],q1,-1);
	if (p[p2][0] && p[q2][0]) addQueryEvent(i,p[p2][0],p[q2][0],1);
}

map<int, vector<int> > clist;
int color[maxn];
int q[maxn][6];
int ans[maxn];

void lemon()
{
	lg2[1]=0; rep(i,2,maxn-1) lg2[i]=lg2[i>>1]+1;
	int n,qa; scanf("%d%d",&n,&qa);
	rep(i,1,n) 
	{
		scanf("%d",&color[i]);
		clist[color[i]].push_back(i);
	}
	rep(i,1,n-1)
	{
		int x,y; scanf("%d%d",&x,&y);
		e[x].push_back(y);
		e[y].push_back(x);
	}
	rep(i,1,qa)
	{
		scanf("%d%d%d%d",&q[i][0],&q[i][1],&q[i][2],&q[i][3]);
	}
	dfsN=0;
	dfs(1,0,0);
	rep(i,1,qa) ans[i]=0;
	rep(i,1,qa)
	{
		all=0;
		int z1=lca(q[i][0],q[i][1]);
		int z2=lca(q[i][2],q[i][3]);
		
		q[i][4]=z1; q[i][5]=z2;
		
		check_intersect(q[i][0],z1,q[i][2],z2);
		check_intersect(q[i][0],z1,q[i][3],z2);
		check_intersect(q[i][1],z1,q[i][2],z2);
		check_intersect(q[i][1],z1,q[i][3],z2);
		
		int t1=movedep(q[i][1],depth[q[i][1]]-depth[z1]-1);
		int t2=movedep(q[i][3],depth[q[i][3]]-depth[z2]-1);
		
		add_task(i,q[i][0],z1,q[i][2],z2);
		add_task(i,q[i][0],z1,q[i][3],t2);
		add_task(i,q[i][1],t1,q[i][2],z2);
		add_task(i,q[i][1],t1,q[i][3],t2);
		
		if (all>0)
		{
			rep(k,1,all)
				ans[i]-=get_dist(ti[k][0],ti[k][1]);
				
			ans[i]+=all-1;
		}
	}
	
	rept(it,clist)
	{
		int cl=it->first;
		if (it->second.size()<=LIM)
		{
			int s=it->second.size();
			rep(i,0,s-1)
				rep(j,0,s-1)
				{
					int i1=it->second[i], j1=it->second[j];
					addContributionEvent(dfsLeft[i1], dfsRight[i1], dfsLeft[j1], dfsRight[j1]);
				}
		}
		else
		{
			rept(it2,it->second)
				ds_modify(dfsLeft[*it2],dfsRight[*it2],1);
				
			rep(i,1,qa)
			{
				int x1=ds_query(dfsLeft[q[i][0]])+ds_query(dfsLeft[q[i][1]])-2*ds_query(dfsLeft[q[i][4]]);
				if (color[q[i][4]]==cl) x1++;
				//printf("%d: %d %d %d\n",cl,q[i][0],q[i][1],x1);
				int x2=ds_query(dfsLeft[q[i][2]])+ds_query(dfsLeft[q[i][3]])-2*ds_query(dfsLeft[q[i][5]]);
				if (color[q[i][5]]==cl) x2++;
				//printf("%d: %d %d %d\n",cl,q[i][2],q[i][3],x2);
				ans[i]+=x1*x2;
			}
			
			rept(it2,it->second)
				ds_modify(dfsLeft[*it2],dfsRight[*it2],-1);
			
		}
	}
	
	rep(i,1,n)
	{
		rept(it,eventAddList[i]) ds_modify(it->x,it->y,it->c);
		rept(it,eventQueryList[i]) ans[it->y]+=it->c*ds_query(it->x);
	}
	
	rep(i,1,qa) printf("%d\n",ans[i]);
}

int main()
{
	ios::sync_with_stdio(true);
	#ifndef ONLINE_JUDGE
		//freopen("8.in","r",stdin);
	#endif
	lemon();
	return 0;
}


----------
====================
----------
DATA-STRUCTURES.74
hard
----------
PROBLEM STATEMENT:
Consider a sequence, [expression] queries on the sequence, where each query is one of the following two types:


1 i x: Replace [expression].
2 l r: Consider the polynomial [expression] exists, print Yes on a new line; otherwise, print No.


Given the values of [expression] queries, perform each query in order.
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }
template<typename T>T gcd(T x, T y) { if (y == 0)return x; else return gcd(y, x%y); }


template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) { }
	ModInt(signed sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }

	ModInt inverse() const {
		signed a = x, b = MOD, u = 1, v = 0;
		while (b) {
			signed t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		if (u < 0) u += Mod;
		ModInt res; res.x = (unsigned)u;
		return res;
	}

	ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }
};
typedef ModInt<1000000007> mint;

struct Val {
	mint val;
	mint prod;
	Val operator*(const Val &that) const {
		return Val{ val + that.val * prod, prod * that.prod };
	}
};
struct GetRangeSegmentTree {
	static Val combineVal(const Val &x, const Val &y) {
		return x * y;
	}
	static void assignCombineVal(Val &x, const Val &y) {
		x = x * y;
	}
	static Val identityVal() { return Val{0, 1}; }

	vector<Val> nodes;
	int n;
	void init(int n_, const Val &v = Val()) { init(vector<Val>(n_, v)); }
	void init(const vector<Val> &u) {
		n = 1; while (n < (int)u.size()) n *= 2;
		nodes.resize(n, identityVal());
		nodes.insert(nodes.end(), u.begin(), u.end());
		nodes.resize(n * 2, identityVal());
		for (int i = n - 1; i > 0; -- i)
			nodes[i] = combineVal(nodes[i * 2], nodes[i * 2 + 1]);
	}
	Val get(int i) {
		return nodes[i + n];
	}
	Val getWhole() const {
		return nodes[1];
	}
	Val getRange(int l, int r) const {
		Val m = identityVal();
		int indices[64]; int k = 0;
		for (; l && l + (l&-l) <= r; l += l&-l)
			assignCombineVal(m, nodes[(n + l) / (l&-l)]);
		for (; l < r; r -= r&-r)
			indices[k ++] = (n + r) / (r&-r) - 1;
		while (-- k >= 0) assignCombineVal(m, nodes[indices[k]]);
		return m;
	}
	void set(int i, const Val &x) {
		i += n; nodes[i] = x;
		for (i >>= 1; i > 0; i >>= 1)
			nodes[i] = combineVal(nodes[i * 2], nodes[i * 2 + 1]);
	}
};

int main() {
	int n;
	while (~scanf("%d", &n)) {
		int aa; int bb;
		scanf("%d%d", &aa, &bb);
		mint x = -mint(bb) / mint(aa);
		int q;
		scanf("%d", &q);
		vector<Val> initVals(n);
		rep(i, n) {
			int c;
			scanf("%d", &c);
			initVals[i] = Val{ c, x };
		}
		GetRangeSegmentTree segt;
		segt.init(initVals);
		for (int ii = 0; ii < q; ++ ii) {
			int ty;
			scanf("%d", &ty);
			if (ty == 1) {
				int i; int c;
				scanf("%d%d", &i, &c);
				segt.set(i, Val{ c, x });
			} else if (ty == 2) {
				int l; int r;
				scanf("%d%d", &l, &r), ++ r;
				mint rem = segt.getRange(l, r).val;
				bool ans = rem.get() == 0;
				puts(ans ? "Yes" : "No");
			} else abort();
		}
	}
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.75
hard
----------
PROBLEM STATEMENT:
Given an array, your goal is to find, for each element, the largest subarray containing it whose cost is at least [expression].

Specifically, let [expression]. Also,


Let [expression].
Let [expression].
Let [expression].
Let [expression].


The cost of [expression].  

You are given the array [expression].

Consider, array [expression]. The possible sub-arrays and their costs would be as follows: 



Complete the function costlyIntervals which takes two integers [expression] if there is no such subarray.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
//-------------------------------------------------------

template<class V,int NV> class SegTree_max {
public:
	vector<V> val;
	static V const def=0;
	V comp(V l,V r){ return max(l,r);};
	
	SegTree_max(){val=vector<V>(NV*2,def);};
	V getval(int x,int y,int l=0,int r=NV,int k=1) { // x<=i<y
		if(r<=x || y<=l) return def;
		if(x<=l && r<=y) return val[k];
		return comp(getval(x,y,l,(l+r)/2,k*2),getval(x,y,(l+r)/2,r,k*2+1));
	}
	void update(int entry, V v) {
		entry += NV;
		val[entry]=v;
		while(entry>1) entry>>=1, val[entry]=comp(val[entry*2],val[entry*2+1]);
	}
};
template<class V,int NV> class SegTree_min {
public:
	vector<V> val;
	static V const def=1<<30;
	V comp(V l,V r){ return min(l,r);};
	
	SegTree_min(){val=vector<V>(NV*2,def);};
	V getval(int x,int y,int l=0,int r=NV,int k=1) { // x<=i<y
		if(r<=x || y<=l) return def;
		if(x<=l && r<=y) return val[k];
		return comp(getval(x,y,l,(l+r)/2,k*2),getval(x,y,(l+r)/2,r,k*2+1));
	}
	void update(int entry, V v) {
		entry += NV;
		val[entry]=v;
		while(entry>1) entry>>=1, val[entry]=comp(val[entry*2],val[entry*2+1]);
	}
};

template<class V,int NV> class SegTree_or {
public:
	vector<V> val;
	static V const def=0;
	V comp(V l,V r){ return l | r;};
	
	SegTree_or(){val=vector<V>(NV*2,def);};
	V getval(int x,int y,int l=0,int r=NV,int k=1) { // x<=i<y
		if(r<=x || y<=l) return def;
		if(x<=l && r<=y) return val[k];
		return comp(getval(x,y,l,(l+r)/2,k*2),getval(x,y,(l+r)/2,r,k*2+1));
	}
	void update(int entry, V v) {
		entry += NV;
		val[entry]=v;
		while(entry>1) entry>>=1, val[entry]=comp(val[entry*2],val[entry*2+1]);
	}
};

template<class V,int NV> class SegTree_and {
public:
	vector<V> val;
	static V const def=0x7FFFFFFF;
	V comp(V l,V r){ return l & r;};
	
	SegTree_and(){val=vector<V>(NV*2,def);};
	V getval(int x,int y,int l=0,int r=NV,int k=1) { // x<=i<y
		if(r<=x || y<=l) return def;
		if(x<=l && r<=y) return val[k];
		return comp(getval(x,y,l,(l+r)/2,k*2),getval(x,y,(l+r)/2,r,k*2+1));
	}
	void update(int entry, V v) {
		entry += NV;
		val[entry]=v;
		while(entry>1) entry>>=1, val[entry]=comp(val[entry*2],val[entry*2+1]);
	}
};



int N,K;
int A[101010];
SegTree_max<int,1<<18> stma;
SegTree_min<int,1<<18> stmi;
SegTree_or<int,1<<18> stor;
SegTree_and<int,1<<18> stand;

int nex[31][2];

int ret[101010];
vector<int> add[101010],del[101010];
set<int> cand[101010];

void solve() {
	int i,j,k,l,r,x,y; string s;
	
	MINUS(ret);
	cin>>N>>K;
	FOR(i,N) {
		cin>>A[i];
		stma.update(i,A[i]);
		stmi.update(i,A[i]);
		stor.update(i,A[i]);
		stand.update(i,A[i]);
	}
	
	FOR(i,30) nex[i][0]=nex[i][1]=N;
	for(i=N-1;i>=0;i--) {
		FOR(j,30) {
			if(A[i]&(1<<j)) nex[j][1]=i;
			else nex[j][0]=i;
			cand[i].insert(nex[j][0]);
			cand[i].insert(nex[j][1]);
		}
		cand[i].erase(N);
		y=-1;
		FORR(e,cand[i]) {
			x=e;
			int ma=stma.getval(i,x+1);
			int mi=stmi.getval(i,x+1);
			int mor=stor.getval(i,x+1);
			int mand=stand.getval(i,x+1);
			int val=mor-mand-(ma-mi);
			if(val>=K) {
				y=x;
			}
		}
		if(y==-1) continue;
		for(j=19;j>=0;j--) {
			if(y+(1<<j)>=N) continue;
			y+=(1<<j);
			int ma=stma.getval(i,y+1);
			int mi=stmi.getval(i,y+1);
			int mor=stor.getval(i,y+1);
			int mand=stand.getval(i,y+1);
			int val=mor-mand-(ma-mi);
			if(val<K) y-=1<<j;
		}
		add[i].push_back(y-i+1);
		del[y+1].push_back(y-i+1);
		
	}
	
	
	
	map<int,int> MP;
	MP[-1]=1;
	FOR(i,N) {
		FORR(e,add[i]) MP[e]++;
		FORR(e,del[i]) {
			MP[e]--;
			if(MP[e]==0) MP.erase(e);
		}
		cout<<MP.rbegin()->first<<endl;
	}
}


int main(int argc,char** argv){
	string s;int i;
	if(argc==1) ios::sync_with_stdio(false), cin.tie(0);
	FOR(i,argc-1) s+=argv[i+1],s+='\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);
	cout.tie(0); solve(); return 0;
}

----------
====================
----------
DATA-STRUCTURES.76
hard
----------
PROBLEM STATEMENT:
One of the most important skills a programmer needs to learn early on is the ability to pose a problem in an abstract way. This skill is important not just for researchers but also in applied fields like software engineering and web development.  

You are able to solve most of a problem, except for one last subproblem, which you have posed in an abstract way as follows: Given an array consisting of [expression]

For example, for an input array [ 10, -5, 5, 20 ], a subsegment [expression] would be computed as follows: 

 

What is [expression]?  

Complete the function maximumValue which takes an integer array as input and returns the maximum value of [expression].

Note that:


[expression]
[expression]

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

template<class T>
T gcd(T a, T b) {
	T t;
	while (a) {
		t = a;
		a = b % a;
		b = t;
	}
	return b;
}

ll a[50005];
int n;

template<int MAXN>
struct segtree_lazy {

	struct updater {
		/* DATA MEMBERS */
		ll x;

		updater(ll x = 0) : x(x) {}

		updater& operator+= (const updater& other) {
			/* ADDITION */
			x += other.x;

			return *this;
		}

		operator bool () const {
			/* BOOL CAST */
			return x != 0;
		}
	};
	
	struct node_t {
		/* DATA MEMBERS */
		ll x;

		/* CONSTRUCTOR */
		node_t(ll x = 0) : x(x) {}

		node_t& operator+= (const node_t& other) {
			/* ADDITION */
			x = max(x, other.x);

			return *this;
		}

		node_t& operator+= (const updater& other) {
			/* UPDATE ADDITION */
			x += other.x;

			return *this;
		}

		node_t operator+ (const node_t& other) const {
			node_t tmp = *this;
			tmp += other;
			return tmp;
		}
	};

	node_t a[2*MAXN];
	updater b[2*MAXN];

	void init() {
		for (int i=1; i<=MAXN; i++) {
			/* KOPIRAJ NEKI EKSTERNI NIZ OVDE */
			a[i + MAXN - 1] = node_t();
		}
		for (int i=MAXN-1; i>0; i--) {
			a[i] = a[2*i] + a[2*i+1];
		}
	}

	void push(int i) {
		if (b[i]) {
			a[i] += b[i];
			if (i < MAXN) {
				b[2*i] += b[i];
				b[2*i+1] += b[i];
			}
			b[i] = updater();
		}
	}

	node_t get(int l, int r, int node=1, int nl=1, int nr=MAXN) {
		push(node);

		if (r < nl || nr < l) {
			return node_t();
		}
		if (l <= nl && nr <= r) {
			return a[node];
		}

		int nm = (nl + nr) >> 1;
		return get(l, r, 2*node, nl, nm) + get(l, r, 2*node+1, nm+1, nr);
	}

	void update(int l, int r, updater val, int node=1, int nl=1, int nr=MAXN) {
		push(node);

		if (r < nl || nr < l) {
			return;
		}
		if (l <= nl && nr <= r) {
			b[node] += val;
			push(node);
			return;
		}

		int nm = (nl + nr) >> 1;
		update(l, r, val, 2*node, nl, nm);
		update(l, r, val, 2*node+1, nm+1, nr);
		a[node] = a[2*node] + a[2*node+1];
	}
};

segtree_lazy<65536> drvo;

struct triple {
	ll v, l, r;
};

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cerr.tie(nullptr);

	cin >> n;
	for (int i=1; i<=n; i++) {
		cin >> a[i];
	}

	ll sol = 0;

	vector<triple> gcd_stack;
	vector<triple> max_stack;

	for (int i=1; i<=n; i++) {
		// primeni nzd na sve elemente niza
		for (auto& p : gcd_stack) {
			p.v = gcd(p.v, abs(a[i]));
		}
		// dodaj sebe
		gcd_stack.push_back({abs(a[i]), i, i});

		// skupi
		vector<triple> tmp;
		for (auto& p : gcd_stack) {
			if (tmp.empty() || tmp.back().v != p.v) {
				tmp.push_back(p);
			} else if (tmp.back().v == p.v) {
				tmp.back().r = p.r;
			}
		}

		swap(tmp, gcd_stack);	

		// povecavam sumu
		drvo.update(1, i, a[i]);

		// sredim maximum

		while (max_stack.size() && a[i] >= max_stack.back().v) {
			drvo.update(max_stack.back().l, max_stack.back().r, 
				max_stack.back().v);
			max_stack.pop_back();
		}

		int ls = max_stack.size() ? max_stack.back().r + 1 : 1;
		max_stack.push_back({a[i], ls, i});
		drvo.update(ls, i, -a[i]);

		/*
		cerr << i << '\n';
		for (auto g : max_stack) {
			cerr << "d " << g.l << ' ' << g.r << ' ' << g.v << '\n';
		}
		*/


		for (auto& g : gcd_stack) {
			// cerr << "drvo get " << drvo.get(g.l, g.r).x << '\n';
			sol = max(sol, g.v * drvo.get(g.l, g.r).x);
		}
	}

	cout << sol << '\n';
}
----------
====================
----------
DATA-STRUCTURES.77
advanced
----------
PROBLEM STATEMENT:
Treeland is a country with [expression] roads. There is exactly one path between any two cities.  

The ruler of Treeland wants to implement a self-driving bus system and asks tree-loving Alex to plan the bus routes. Alex decides that each route must contain a subset of connected cities; a subset of cities is connected if the following two conditions are true:


There is a path between every pair of cities which belongs to the subset.
Every city in the path must belong to the subset.




In the figure above, [expression] would need to be part of the subset).

Each self-driving bus will operate within a connected segment of Treeland. A connected segment [expression]. 

In the figure above, [expression]. Note that a single city can be a segment too.

Help Alex to find number of connected segments in Treeland.
----------
TOP SOLUTION:
----------
#pragma comment (linker, "/STACK:256000000")
#define _CRT_SECURE_NO_WARNINGS
//#include "testlib.h"
#include <cstdio>
#include <cassert>
#include <algorithm>
#include <iostream>
#include <memory.h>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <cmath>
#include <bitset>
#include <deque>
#include <unordered_map>
#include <unordered_set>
#include <ctime>
#include <stack>
#include <queue>
#include <fstream>
#include <sstream>
#include <complex>
using namespace std;
//#define FILENAME ""
#define mp make_pair
#define all(a) a.begin(), a.end()
typedef long long li;
typedef long double ld;
void solve();
void precalc();
clock_t start;
//int timer = 1;

int testNumber = 1;

bool todo = true;

int main() {
#ifdef room111
	freopen("in.txt", "r", stdin);
	//freopen("out.txt", "w", stdout);
#else
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	//freopen(FILENAME".in", "r", stdin);
	//freopen(FILENAME ".out", "w", stdout);
#endif
	start = clock();
	int t = 1;
	cout.sync_with_stdio(0);
	cin.tie(0);
	precalc();
	cout.precision(10);
	cout << fixed;
	//cin >> t;
	int testNum = 1;
	while (t--) {
		//cerr << testNum << endl;
		//cout << "Case #" << testNum++ << ": ";
		solve();
		++testNumber;
		//++timer;
	}

#ifdef room111
	cerr << "\n\n" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << "\n\n";
#endif

	return 0;
}

//BE CAREFUL: IS INT REALLY INT?

//#define int li

/*int pr[] = { 97, 2011 };
int mods[] = { 1000000007, 1000000009 };

const int C = 300500;
int powers[2][C];*/

//int MOD = 1000000007;

//int c[5010][5010];

template<typename T>
T binpow(T q, T w, T mod) {
	if (!w)
		return 1 % mod;
	if (w & 1)
		return q * 1LL * binpow(q, w - 1, mod) % mod;
	return binpow(q * 1LL * q % mod, w / 2, mod);
}

/*int curMod = 1000000009;

int fact[100500], revfact[100500];

int getC(int n, int k) {
int res = fact[n] * revfact[n - k] % curMod * revfact[k] % curMod;
return res;
}*/

/*const int C = 7000500;

int least_prime[C];*/


void precalc() {

	/*for (int i = 2; i < C; ++i) {
	if (!least_prime[i]) {
	least_prime[i] = i;
	for (li j = i * 1LL * i; j < C; j += i) {
	least_prime[j] = i;
	}
	}
	}*/

	/*fact[0] = revfact[0] = 1;
	for (int i = 1; i < 100500; ++i) {
	fact[i] = fact[i - 1] * i % curMod;
	revfact[i] = binpow(fact[i], curMod - 2, curMod);
	}*/

	/*for (int w = 0; w < 2; ++w) {
	powers[w][0] = 1;
	for (int j = 1; j < C; ++j) {
	powers[w][j] = (powers[w][j - 1] * 1LL * pr[w]) % mods[w];
	}
	}*/
	/*for (int i = 0; i < 5010; ++i) {
	c[i][i] = c[i][0] = 1;
	for (int j = 1; j < i; ++j) {
	c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
	}
	}*/
}

template<typename T>
T gcd(T q, T w) {
	while (w) {
		q %= w;
		swap(q, w);
	}
	return q;
}
template<typename T>
T lcm(T q, T w) {
	return q / gcd(q, w) * w;
}

//#define int li

//const int mod = 1000000007;

const int L = 18;

vector<vector<int>> g;
vector<vector<int>> parent, jump_mx, jump_mn;

int tim = 1;

vector<int> tin, tout;

void dfs(int v, int p) {
	tin[v] = tim++;
	parent[0][v] = p;
	jump_mx[0][v] = v;
	jump_mn[0][v] = v;
	for (int j = 1; j < L; ++j) {
		parent[j][v] = parent[j - 1][parent[j - 1][v]];
		jump_mx[j][v] = max(jump_mx[j - 1][v], jump_mx[j - 1][parent[j - 1][v]]);
		jump_mn[j][v] = min(jump_mn[j - 1][v], jump_mn[j - 1][parent[j - 1][v]]);
	}
	for (int to : g[v]) {
		if (to == p) {
			continue;
		}
		dfs(to, v);
	}
	tout[v] = tim++;
}

bool upper(int a, int b) {
	return tin[a] <= tin[b] && tout[a] >= tout[b];
}

pair<int, int> get_vals(int a, int b) {
	pair<int, int> res(1e9, -1e9);
	for (int j = L - 1; j >= 0; --j) {
		if (!upper(parent[j][a], b)) {
			res.first = min(res.first, jump_mn[j][a]);
			res.second = max(res.second, jump_mx[j][a]);
			a = parent[j][a];
		}
	}
	for (int j = L - 1; j >= 0; --j) {
		if (!upper(parent[j][b], a)) {
			res.first = min(res.first, jump_mn[j][b]);
			res.second = max(res.second, jump_mx[j][b]);
			b = parent[j][b];
		}
	}
	res.first = min(res.first, b);
	res.second = max(res.second, b);
	res.first = min(res.first, a);
	res.second = max(res.second, a);
	if (!upper(a, b) && !upper(b, a)) {
		int c = parent[0][a];
		res.first = min(res.first, c);
		res.second = max(res.second, c);
	}
	return res;
}
class Treap {
public:
	typedef struct _node {
		int key;
		int cnt;
		int prior;
		_node* l;
		_node* r;
		_node(int key) :key(key), l(nullptr), r(nullptr), cnt(1) { prior = (rand() << 16) | rand(); }

		void push() {

		}

		void recalc() {
			cnt = 1 + Cnt(l) + Cnt(r);
		}

		static int Cnt(_node* v) {
			if (!v)
				return 0;
			return v->cnt;
		}
	}*node;

	static int Cnt(node v) {
		if (!v)
			return 0;
		return v->cnt;
	}

	node root;

	size_t Size;

	node merge(node l, node r) {
		if (!l)
			return r;
		if (!r)
			return l;
		if (l->prior < r->prior) {
			l->push();
			l->r = merge(l->r, r);
			l->recalc();
			return l;
		}
		else {
			r->push();
			r->l = merge(l, r->l);
			r->recalc();
			return r;
		}
	}

	void split(node v, int key, node& l, node& r) {
		l = r = nullptr;
		if (!v)
			return;
		v->push();
		if (v->key < key) {
			l = v;
			split(l->r, key, l->r, r);
			l->recalc();
		}
		else {
			r = v;
			split(r->l, key, l, r->l);
			r->recalc();
		}
	}

public:
	Treap() {
		root = nullptr;
		Size = 0;
	}

	size_t size() const {
		return Size;
	}

	void insert(int key) { //insert at the idx - position
		node l = nullptr, r = nullptr;
		split(root, key, l, r);
		node cur_node = new _node(key);
		root = merge(merge(l, cur_node), r);
		++Size;
	}

	node operator [] (int key) {
		node l = nullptr, m = nullptr, r = nullptr;
		split(root, key, l, r);
		split(r, key + 1, m, r);
		if (m == nullptr) {
			throw runtime_error("IndexTreapOutOfBound");
		}
		root = merge(merge(l, m), r);
		return m;
	}

	int get_size(int L) {
		node l = 0, r = 0;
		split(root, L, l, r);
		int ans = Cnt(l);
		root = merge(l, r);
		return ans;
	}

};


li get_result(const vector<int>& mxs, const vector<int>& mns, int l, int r) {
	if (l >= r) {
		return 0;
	}
	if (l + 1 == r) {
		return mns[l] == l && mxs[l] == r;
	}
	int m = (l + r) / 2;
	li res = get_result(mxs, mns, l, m) + get_result(mxs, mns, m, r);

	int right_mx = mxs[m], right_mn = mns[m];
	vector<pair<int, int>> right_queries;
	for (int i = m + 1; i <= r; ++i) {
		if (right_mx == i) {
			right_queries.push_back(mp(right_mn, i));
		}
		if (i < r) {
			right_mn = min(right_mn, mns[i]);
			right_mx = max(right_mx, mxs[i]);
		}
	}

	int left_mx = mxs[m - 1], left_mn = mns[m - 1];
	vector<pair<int, int>> left_queries;
	for (int i = m - 1; i >= l; --i) {
		if (left_mn == i) {
			left_queries.push_back(mp(i, left_mx));
		}
		if (i > l) {
			left_mn = min(left_mn, mns[i - 1]);
			left_mx = max(left_mx, mxs[i - 1]);
		}
	}

	sort(all(left_queries));
	sort(all(right_queries));
	Treap tree;

	int j = 0;
	for (auto R : right_queries) {
		while (j < left_queries.size() && left_queries[j].first <= R.first) {
			tree.insert(left_queries[j].second);
			++j;
		}
		res += tree.get_size(R.second + 1);
	}

	/*for (auto L : left_queries) {
		for (auto R : right_queries) {
			if (L.first <= R.first && L.second <= R.second) {
				++res;
			}
		}
	}*/
	return res;
}

void solve() {
	int n;
	cin >> n;
	g.resize(n);
	tin.resize(n);
	tout.resize(n); 
	parent.assign(L, vector<int>(n));
	jump_mx.assign(L, vector<int>(n));
	jump_mn.assign(L, vector<int>(n));

	for (int i = 1; i < n; ++i) {
		int a, b;
		cin >> a >> b;
		--a; --b;
		g[a].push_back(b);
		g[b].push_back(a);
	}
	dfs(0, 0);

	vector<int> mxs(n - 1), mns(n - 1);
	for (int i = 0; i + 1 < n; ++i) {
		auto cur_res = get_vals(i, i + 1);
		mxs[i] = cur_res.second;
		mns[i] = cur_res.first;
	}

	li result = n + get_result(mxs, mns, 0, mxs.size());

	cout << result << "\n";

}
----------
====================
----------
DATA-STRUCTURES.78
advanced
----------
PROBLEM STATEMENT:
You are given an unrooted tree of [expression]. 

Let [expression], defined as follows:

[expression]

Your task is to print the value of [expression].
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <iostream>
#include <ctime>
#include <iomanip>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
#include <string>
#include <cstring>
using namespace std;

vector <int> ve[110000], V[110000];
long long ans[110000], Base, del[410000];
int sum[110000], L[110000], R[110000], st[110000], Time, n, x, y;

bool cmp(int x, int y) {
	return L[x] > L[y];
}

void dfs(int k, int f) {
	L[k] = ++Time;
	sum[k] = 1;
	for (int i = 0; i < (int) ve[k].size(); i++)
		if (ve[k][i] != f)
			dfs(ve[k][i], k), sum[k] += sum[ve[k][i]];
	R[k] = Time;
}

void modify(int k, int q, int h, int l, int r, int d) {
	if (l <= q && h <= r)
		del[k] += d;
	else {
		if (r <= (q + h) / 2)
			modify(k * 2, q, (q + h) / 2, l, r, d);
		else if ((q + h) / 2 < l)
			modify(k * 2 + 1, (q + h) / 2 + 1, h, l, r, d);
		else
			modify(k * 2, q, (q + h) / 2, l, r, d), modify(k * 2 + 1, (q + h) / 2 + 1, h, l, r, d);
	}
}

void dfs(int k, int q, int h, long long now) {
	now += del[k];
	if (q == h)
		ans[q] = now;
	else {
		dfs(k * 2, q, (q + h) / 2, now);
		dfs(k * 2 + 1, (q + h) / 2 + 1, h, now);
	}
}

void doit(vector <int> V) {
	if (V.size() == 0)
		return ;
	Base += n;
	sort(V.begin(), V.end(), cmp);
	int len = 0;
	// printf("xx ");
	// for (int i = 0; i < (int) V.size(); i++)
	// 	printf("%d ", V[i]);
	// printf("\n");
	for (int i = 0; i < (int) V.size(); i++) {
		vector <int> T;
		while (len && L[V[i]] <= L[st[len]] && L[st[len]] <= R[V[i]]) {
			T.push_back(st[len]);
			len--;
		}

		st[++len] = V[i];
		int r = T.size() - 1;
		for (int p = ((int) ve[V[i]].size()) - 1; p >= 0; p--)
			if (sum[ve[V[i]][p]] < sum[V[i]]) {
				int q = ve[V[i]][p];
				int kk = sum[q];
				int RR = r;
				while (RR >= 0 && L[q] <= L[T[RR]] && L[T[RR]] <= R[q])
					RR -= 1;
				for (int j = RR + 1; j <= r; j++)
					kk -= sum[T[j]];
				// kk -= 1;
				// printf("%d %d\n", V[i], kk);
				// if (L[V[i]] != R[V[i]])
				modify(1, 1, n, L[q], R[q], kk);
				for (int j = RR + 1; j <= r; j++)
					modify(1, 1, n, L[T[j]], R[T[j]], -kk);
				r = RR;
			}
		
	}
	// for (int i = 1; i <= len; i++)
	// 	printf("%d ", st[i]);
	// printf("\n");
	int kk = n;
	for (int j = 1; j <= len; j++)
		kk -= sum[st[j]];
	modify(1, 1, n, 1, n, kk);
	for (int j = 1; j <= len; j++)
		modify(1, 1, n, L[st[j]], R[st[j]], -kk);
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%d", &x), V[x].push_back(i);
	for (int i = 1; i < n; i++) {
		scanf("%d%d", &x, &y);
		ve[x].push_back(y);
		ve[y].push_back(x);
	}
	dfs(1, 0);
	for (int i = 1; i <= 100000; i++) {
		doit(V[i]);
	}
	dfs(1, 1, n, 0);
	for (int i = 1 ; i <= n; i++)
		printf("%lld\n", Base - ans[L[i]]);
}

----------
====================
----------
DATA-STRUCTURES.79
expert
----------
PROBLEM STATEMENT:
Shashank loves trees and math. He has a rooted tree, [expression]). 

Let's define [expression]:


[expression]
Update the subtree rooted at node [expression] Fibonacci number added to them.
[expression]
Find the sum of all values associated with the nodes on the unique path from [expression] on a new line.


Given the configuration for tree [expression] operations, perform all the operations efficiently.

Note: [expression].
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
#define DEBUG(x) cerr << #x << " = " << x << endl;

typedef long long LL;
typedef pair<LL, LL> II;

#ifndef _WIN32
    #define getchar getchar_unlocked
    #define putchar putchar_unlocked
#endif
void Read(int &n) {
    char c; n = 0;
    do {
        c = getchar();
    } while (!isdigit(c));
    do {
        n = n * 10 + c - 48;
        c = getchar();
    } while (isdigit(c));
}
void Read(LL &n) {
    char c; n = 0;
    do {
        c = getchar();
    } while (!isdigit(c));
    do {
        n = n * 10 + c - 48;
        c = getchar();
    } while (isdigit(c));
}
void Write(int n) {
	if (n == 0) {
		putchar('0'); putchar('\n');
		return;
	}
	char c[13];
	int cnt = 0;
	while (n) {
		c[cnt++] = n % 10;
		n /= 10;
	}
	for (int i = cnt - 1; i >= 0; --i) putchar(c[i] + 48); putchar('\n');
}

const int N = (int) 1e5 + 10;
const int P = (int) 1e9 + 7;
int fib[N * 5];

void Multiply(int a[2][2], int b[2][2], int c[2][2]) {
	LL x[2][2];
	for (int i = 0; i < 2; ++i)
		for (int j = 0; j < 2; ++j) {
			x[i][j] = 0;
			for (int k = 0; k < 2; ++k) x[i][j] += a[i][k] * LL(b[k][j]);
		}
	for (int i = 0; i < 2; ++i)
		for (int j = 0; j < 2; ++j)
			c[i][j] = x[i][j] % P;
}

void Power(int a[2][2], LL k, int ans[2][2]) {
	k--; for (int i = 0; i < 2; ++i) for (int j = 0; j < 2; ++j) ans[i][j] = a[i][j];
	while (k) {
		if (k & 1) Multiply(ans, a, ans);
		Multiply(a, a, a);
		k >>= 1;
	}
}

LL Fibonacci(LL k) {
	if (k < 0) return fib[k + N];
	if (k == 0) return 0;
	int t[2][2];
	t[0][0] = 0; t[0][1] = 1;
	t[1][0] = 1; t[1][1] = 1;
	int ans[2][2]; Power(t, k, ans);
	return ans[1][0];
}

int n, q, h[N], p[N][21], x[N], y[N], timer;
vector<int> adj[N];

void DFS(int u) {
	x[u] = ++timer;
	for (int i = 0; i < (int) adj[u].size(); ++i) {
		int v = adj[u][i];
		h[v] = h[u] + 1; p[v][0] = u;
		DFS(v);
	}
	y[u] = timer;
}

void Prepare() {
	for (int j = 1; 1 << j <= n; ++j)
		for (int i = 1; i <= n; ++i)
			p[i][j] = p[p[i][j - 1]][j - 1];
}

int LCA(int u, int v) {
	if (h[u] < h[v]) swap(u, v);
	for (int i = 20; i >= 0; --i) if (h[u] - (1 << i) >= h[v]) u = p[u][i];
	if (u == v) return u;
	for (int i = 20; i >= 0; --i) if (p[u][i] != p[v][i]) {
		u = p[u][i];
		v = p[v][i];
	}
	return p[u][0];
}

int ft[3][N];

void Update(int *ft, int l, int r, int v) {
	r++;
	for (; l <= n; l += l & -l) { ft[l] += v; if (ft[l] >= P) ft[l] -= P; }
	for (; r <= n; r += r & -r) { ft[r] -= v; if (ft[r] <  0) ft[r] += P; }
}

LL Query(int *ft, int i) {
	int ans = 0;
	while (i) {
		ans += ft[i]; if (ans >= P) ans -= P;
		i -= i & -i;
	}
	return ans;
}

LL Get(int i) {
	LL ans = fib[h[i] + N] * Query(ft[0], x[i]) + fib[h[i] - 1 + N] * Query(ft[1], x[i]) - Query(ft[2], x[i]);
	ans = (ans % P + P) % P;
	return ans;
}

int main() {
#ifdef LOCAL
	freopen("Data.inp", "r", stdin);
	freopen("Data.out", "w", stdout);
#endif

	Read(n); Read(q);
	for (int i = 2; i <= n; ++i) {
		int p; Read(p);
		adj[p].push_back(i);
	}
	DFS(1);
	Prepare();

	fib[0 + N] = 0; fib[1 + N] = 1;
	for (int i =  2; i <=  n + 3; ++i) fib[i + N] = (fib[i + N - 1] + fib[i + N - 2]) % P;
	for (int i = -1; i >= -n - 3; --i) fib[i + N] = (fib[i + N + 2] - fib[i + N + 1] + P) % P;

	for (int z = 0; z < q; ++z) {
		char st[10]; scanf("%s", st);
		if (st[0] == 'Q') {
			int x, y; Read(x); Read(y);
			int w = LCA(x, y);
			LL ans = Get(x) + Get(y) - Get(w) - Get(p[w][0]);
			Write((ans % P + P) % P);
		}
		else {
			int u;
			LL k; Read(u); Read(k);
			Update(ft[0], x[u], y[u], Fibonacci(k - h[u] + 3));
			Update(ft[1], x[u], y[u], Fibonacci(k - h[u] + 2));
			Update(ft[2], x[u], y[u], Fibonacci(k + 1));
		}
	}
	
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.80
expert
----------
PROBLEM STATEMENT:
Given an array, we define its value to be the value obtained by following these instructions:


Write down all pairs of numbers from this array.  
Compute the product of each pair.  
Find the sum of all the products.


For example, for a given array, for a given array [[expression]], 




  Pairs
  (7, 2), (7, -1), (7, 2), (2, -1), (2, 2), (-1, 2)



  Products of the pairs
  14, -7, 14, -2, 4, -2


  Sum of the products
  14 + (-7) + 14 + (-2) + 4 + (-2) = [expression]




Note that [expression].  

Given an array of integers, find the largest value of any of its nonempty subarrays.

Note: A subarray is a contiguous subsequence of the array.

Complete the function largestValue which takes an array and returns an integer denoting the largest value of any of the array's nonempty subarrays.  
----------
TOP SOLUTION:
----------
#pragma GCC optimize("O3","unroll-loops")
#pragma GCC target("sse4,tune=native")
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef double ld;

const int INF = (int) 1e9 + 1e6;
const ll LINF = (ll) 1e18 + 1e9;
const ld EPS = (ld) 1e-10;
const ll MOD = (ll) 1e9 + 7;

#define sz(x) (int) (x).size()
#define mp(x, y) make_pair(x, y)
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define lb(s, t, x) (int) (lower_bound(s, t, x) - s)
#define ub(s, t, x) (int) (upper_bound(s, t, x) - s)
#define rep(i, f, t) for (auto i = f; i < t; ++(i))
#define per(i, f, t) for (auto i = (f); i >= (t); --(i))

ll power(ll x, ll y, ll mod = MOD) {
    if (y == 0) {
        return 1;
    }
    if (y & 1) {
        return power(x, y - 1, mod) * x % mod;
    } else {
        ll tmp = power(x, y / 2, mod);
        return tmp * tmp % mod;
    }
}

template<typename A, typename B> bool mini(A &x, const B &y) {
    if (y < x) {
        x = y;
        return true;
    }
    return false;
}

template<typename A, typename B> bool maxi(A &x, const B &y) {
    if (y > x) {
        x = y;
        return true;
    }
    return false;
}

void run();

#define TASK ""

int main() {
#ifdef LOCAL
    if (strlen(TASK) > 0) {
        cerr << "Reminder: you are using file i/o, filename: " TASK "!" << endl << endl;
    }
#endif
#ifndef LOCAL
    if (strlen(TASK)) {
        freopen(TASK ".in", "r", stdin);
        freopen(TASK ".out", "w", stdout);
    }
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
#endif
    cout << fixed << setprecision(12);
    run();
    return 0;
}

// == SOLUTION == //

struct Line {
    ll k, b;
    
    ll value(ll x) const {
        return k * x + b;
    }
    
    bool operator<(const Line &l) const {
        if (k != l.k) {
            return k < l.k;
        }
        return b > l.b;
    }
};

const int N = (int) 5e5 + 123;

int n;
int a[N];
ll ans = -LINF;

vector<Line> tmp;
vector<Line> lines;
vector<ll> points;

ll div_up(ll x, ll y) {
    if (y < 0) {
        x = -x;
        y = -y;
    }
    if (x < 0) {
        return x / y;
    } else {
        return (x + y - 1) / y;
    }
}

ll inter(Line a, Line b) {
    return div_up(b.b - a.b, a.k - b.k);
}

void add(Line l) {
    if (sz(lines) && lines.back().k == l.k) {
        return;
    }
    
    while (sz(points) && points.back() >= inter(l, lines.back())) {
        points.pop_back();
        lines.pop_back();
    }
    
    if (sz(lines)) {
        points.pb(inter(lines.back(), l));
    }
    lines.pb(l);
}

ll get(ll x) {
    int ind = (int) (upper_bound(all(points), x) - points.begin());
    return lines[ind].value(x);
}

void build() {
    lines.clear();
    points.clear();
    sort(all(tmp));
    for (auto &l : tmp) add(l);
    tmp.clear();
}

void solve(int l, int r) {
    if (l >= r) return;
    if (r - l <= 5) {
        rep(i, l, r) {
            ll res = 0;
            ll sum = 0;
            rep(j, i, r) {
                res += a[j] * sum;
                sum += a[j];
                maxi(ans, res);
            }
        }
        return;
    }
    
    int mid = (l + r) / 2;
    solve(l, mid);
    solve(mid, r);
    
    ll res = 0;
    ll sum = 0;
    
    per(i, mid - 1, l) {
        res += a[i] * sum;
        sum += a[i];
        tmp.pb({sum, res});
    }
    
    build();
    
    res = 0;
    sum = 0;
    rep(i, mid, r) {
        res += a[i] * sum;
        sum += a[i];
        ll cur = res + get(sum);
        maxi(ans, cur);
    }
}

void run() {
    cin >> n;
    rep(i, 0, n) {
        cin >> a[i];
    }
    solve(0, n);
    cout << ans << "\n";
}

----------
====================
----------
DATA-STRUCTURES.81
advanced
----------
PROBLEM STATEMENT:
Let's define a function, [expression] as follows:

[expression]

where [expression]. 

Nikita has a string, [expression] instead.
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }


template<typename Val, typename Compare = std::less<Val>, int BlockSize = 10>
class DirectRMQ {
public:
	typedef int Index;	
	typedef char InBlockIndex;
	typedef InBlockIndex(*BlockTypeRef)[BlockSize];

	DirectRMQ(Compare comp_ = Compare()) :
		blockTypes(0), innerBlockTable(0), sparseTable(0) {
		comp = comp_;
		calcBallotNumbers();
		buildInnerBlockTable();
	}
	~DirectRMQ() {
		delete[] innerBlockTable;
		delete[] blockTypes; delete[] sparseTable;
	}

	void build(const Val *a, Index n) {
		blocks = (n + BlockSize - 1) / BlockSize;
		stHeight = 0; while(1 << stHeight < blocks) ++ stHeight;
		delete[] blockTypes; delete[] sparseTable;

		blockTypes = new BlockTypeRef[blocks];
		calcBlockTypes(a, n);
		buildInnerBlockTable(a, n);
		sparseTable = new Index[blocks * stHeight];
		buildSparseTable(a);
	}

	
	Index query(const Val *a, Index l, Index r) const {
		Index x = l / BlockSize, y = r / BlockSize, z = y - x;
		if(z == 0) return x * BlockSize + blockTypes[x][l % BlockSize][r % BlockSize];
		if(z == 1) return assumeleft_minIndex(a,
			x * BlockSize + blockTypes[x][l % BlockSize][BlockSize - 1],
			y * BlockSize + blockTypes[y][0][r % BlockSize]);
		z -= 2;
		Index k = 0, s;
		s = ((z & 0xffff0000) != 0) << 4; z >>= s; k |= s;
		s = ((z & 0x0000ff00) != 0) << 3; z >>= s; k |= s;
		s = ((z & 0x000000f0) != 0) << 2; z >>= s; k |= s;
		s = ((z & 0x0000000c) != 0) << 1; z >>= s; k |= s;
		s = ((z & 0x00000002) != 0) << 0; z >>= s; k |= s;
		return assumeleft_minIndex(a
			, assumeleft_minIndex(a,
				x * BlockSize + blockTypes[x][l % BlockSize][BlockSize - 1],
				sparseTable[x + 1 + blocks * k])
			, assumeleft_minIndex(a,
				sparseTable[y + blocks * k - (1 << k)],
				y * BlockSize + blockTypes[y][0][r % BlockSize])
		);
	}

	Val queryVal(const Val *a, Index l, Index r) const {
		Index x = l / BlockSize, y = r / BlockSize, z = y - x;
		if(z == 0) return a[x * BlockSize + blockTypes[x][l % BlockSize][r % BlockSize]];
		Val edge = minVal(
			a[x * BlockSize + blockTypes[x][l % BlockSize][BlockSize - 1]],
			a[y * BlockSize + blockTypes[y][0][r % BlockSize]]);
		if(z == 1) return edge;
		z -= 2;
		Index k = 0, s;
		s = ((z & 0xffff0000) != 0) << 4; z >>= s; k |= s;
		s = ((z & 0x0000ff00) != 0) << 3; z >>= s; k |= s;
		s = ((z & 0x000000f0) != 0) << 2; z >>= s; k |= s;
		s = ((z & 0x0000000c) != 0) << 1; z >>= s; k |= s;
		s = ((z & 0x00000002) != 0) << 0; z >>= s; k |= s;
		return minVal(edge, minVal(
			a[sparseTable[x + 1 + blocks * k]],
			a[sparseTable[y + blocks * k - (1 << k)]]));
	}
private:
	Compare comp;

	int ballotNumbers[BlockSize + 1][BlockSize + 1];
	InBlockIndex(*innerBlockTable)[BlockSize][BlockSize];

	Index blocks;
	int stHeight;
	BlockTypeRef *blockTypes;
	Index *sparseTable;

	inline Index minIndex(const Val *a, Index x, Index y) const {
		return comp(a[x], a[y]) || (a[x] == a[y] && x < y) ? x : y;
	}
	inline Index assumeleft_minIndex(const Val *a, Index x, Index y) const {
		return comp(a[y], a[x]) ? y : x;
	}

	inline Val minVal(Val x, Val y) const {
		return comp(y, x) ? y : x;
	}

	void buildSparseTable(const Val *a) {
		Index *b = sparseTable;
		if(stHeight) for(Index i = 0; i < blocks; i ++)
			b[i] = i * BlockSize + blockTypes[i][0][BlockSize - 1];
		for(Index t = 1; t * 2 < blocks; t *= 2) {
			std::memcpy(b + blocks, b, blocks * sizeof(Index));
			b += blocks;
			for(Index i = 0; i < blocks - t; ++ i)
				b[i] = assumeleft_minIndex(a, b[i], b[i + t]);
		}
	}

	void buildInnerBlockTable(const Val *a, Index n) {
		for(Index i = 0; i < blocks; i ++) {
			BlockTypeRef table = blockTypes[i];
			if(table[0][0] != -1) continue;
			const Val *p = getBlock(a, n, i);
			for(InBlockIndex left = 0; left < BlockSize; left ++) {
				Val minV = p[left];
				InBlockIndex minI = left;
				for(InBlockIndex right = left; right < BlockSize; right ++) {
					if(comp(p[right], minV)) {
						minV = p[right];
						minI = right;
					}
					table[left][right] = minI;
				}
			}
		}
	}

	
	const Val *getBlock(const Val *a, Index n, Index i) {
		Index offset = i * BlockSize;
		if(offset + BlockSize <= n)
			return a + offset;
		else {
			static Val tmp_a[BlockSize];
			std::copy(a + offset, a + n, tmp_a);
			Val maxVal = Val();
			for(Index j = i; j < n; j ++)	
				if(comp(maxVal, a[j])) maxVal = a[j];
			std::fill(tmp_a + (n - offset), tmp_a + BlockSize, maxVal);
			return tmp_a;
		}
	}

	void calcBlockTypes(const Val *a, Index n) {
		Val tmp_rp[BlockSize + 1];
		for(Index i = 0; i < blocks; i ++)
			blockTypes[i] = calcBlockType(getBlock(a, n, i), tmp_rp);
	}

	BlockTypeRef calcBlockType(const Val *a, Val *rp) {
		int q = BlockSize, N = 0;
		for(int i = 0; i < BlockSize; i ++) {
			while(q + i - BlockSize > 0 && comp(a[i], rp[q + i - BlockSize])) {
				N += ballotNumbers[BlockSize - i - 1][q];
				q --;
			}
			rp[q + i + 1 - BlockSize] = a[i];
		}
		return innerBlockTable[N];
	}

	void calcBallotNumbers() {
		for(int p = 0; p <= BlockSize; p ++) {
			for(int q = 0; q <= BlockSize; q ++) {
				if(p == 0 && q == 0)
					ballotNumbers[p][q] = 1;
				else if(p <= q)
					ballotNumbers[p][q] =
					(q ? ballotNumbers[p][q - 1] : 0) +
					(p ? ballotNumbers[p - 1][q] : 0);
				else
					ballotNumbers[p][q] = 0;
			}
		}
	}

	void buildInnerBlockTable() {
		int numberOfTrees = ballotNumbers[BlockSize][BlockSize];
		innerBlockTable = new InBlockIndex[numberOfTrees][BlockSize][BlockSize];
		for(int i = 0; i < numberOfTrees; i ++)
			innerBlockTable[i][0][0] = -1;
	}
};

class SuffixArray {
public:
	typedef char Alpha;
	typedef int Index;

	void build(const Alpha *str, Index n, int AlphaSize);
	void build(const Alpha *str, Index n);
	void buildAll(const Alpha *str, Index n);
	inline Index getKThSuffix(Index k) const { return suffixArray[k]; }
	inline Index length() const { return static_cast<Index>(suffixArray.size() - 1); }
	std::vector<Index> suffixArray;
	template<typename AlphaT> void sa_is(const AlphaT *str, Index n, int AlphaSize, Index *sa, std::vector<Index> &bucketOffsets);
	template<typename AlphaT> void inducedSort(const AlphaT *str, Index n, int AlphaSize, const std::vector<bool> &types, Index *sa, std::vector<Index> &bucketOffsets);
	template<typename AlphaT> void countAlphabets(const AlphaT *str, Index n, int AlphaSize, std::vector<Index> &bucketOffsets, bool b = false);
	template<typename AlphaT> void getBucketOffsets(const AlphaT *str, Index n, bool dir, int AlphaSize, std::vector<Index> &bucketOffsets);
	void buildInverseSuffixArray();
	std::vector<Index> inverseSuffixArray;
	void computeLCPArray(const Alpha *str);
	std::vector<Index> lcpArray;
	typedef DirectRMQ<Index> LCPArrayRMQ;
	LCPArrayRMQ lcpArrayRMQ;
	void preprocessLCPArrayRMQ() {
		lcpArrayRMQ.build(&lcpArray[0], length() + 1);
	}
	Index computeLCP(Index i, Index j) const;
};

void SuffixArray::build(const Alpha *str, Index n, int AlphaSize) {
	suffixArray.resize(n + 1);
	if(n == 0) suffixArray[0] = 0;
	else {
		
		
		
		
		
		std::vector<Index> bucketOffsets(std::max(AlphaSize, (n + 1) / 2) + 1);
		sa_is<Alpha>(str, n, AlphaSize, &suffixArray[0], bucketOffsets);
	}
}

void SuffixArray::build(const Alpha *str, Index n) {
	Alpha maxElem = *std::max_element(str, str + n);
	assert(maxElem + 0 < std::numeric_limits<int>::max());
	build(str, n, (int)(maxElem + 1));
}

void SuffixArray::buildAll(const Alpha *str, Index n) {
	build(str, n);
	buildInverseSuffixArray();
	computeLCPArray(str);
	preprocessLCPArrayRMQ();
}


template<typename AlphaT>
void SuffixArray::sa_is(const AlphaT *str, Index n, int AlphaSize, Index *sa, std::vector<Index> &bucketOffsets) {
	std::vector<bool> types(n + 1);
	types[n - 1] = 0; types[n] = 1;
	for(Index i = n - 2; i >= 0; i --)
		types[i] = str[i] < str[i + 1] || (str[i] == str[i + 1] && types[i + 1]);

	countAlphabets(str, n, AlphaSize, bucketOffsets);
	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	std::fill(sa, sa + n + 1, -1);
	for(Index i = 1; i < n; i ++)
		if(types[i] && !types[i - 1]) sa[-- bucketOffsets[(int)str[i]]] = i;
	sa[0] = n;
	inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);

	Index n1 = 0;
	for(Index i = 0; i <= n; i ++) {
		Index j = sa[i];
		if(j > 0 && types[j] && !types[j - 1]) sa[n1 ++] = j;
	}

	
	
	
	
	Index *buffer = sa + n1;
	std::fill(buffer, sa + n + 1, -1);
	Index uniqueLMSCount = 0, prevPos = -1;
	assert(sa[0] == n);
	buffer[sa[0] / 2] = uniqueLMSCount ++;	
	for(Index i = 1; i < n1; i ++) {
		Index pos = sa[i]; bool diff = false;
		if(prevPos == -1) diff = true;
		else for(Index j = pos, k = prevPos; ; j ++, k ++) {
			if(str[j] != str[k] || types[j] != types[k]) {
				diff = true;
				break;
			} else if(j != pos && ((types[j] && !types[j - 1]) || (types[k] && !types[k - 1])))
				break;
		}
		if(diff) {
			uniqueLMSCount ++;
			prevPos = pos;
		}
		buffer[pos / 2] = uniqueLMSCount - 1;
	}
	for(Index i = n, j = n; i >= n1; i --)
		if(sa[i] >= 0) sa[j --] = sa[i];

	Index *sa1 = sa, *s1 = sa + n + 1 - n1;
	if(uniqueLMSCount == n1)
		for(Index i = 0; i < n1; i ++) sa1[s1[i]] = i;
	else
		sa_is<Index>(s1, n1 - 1, uniqueLMSCount, sa1, bucketOffsets);

	countAlphabets(str, n, AlphaSize, bucketOffsets);
	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	for(Index i = 1, j = 0; i <= n; i ++)
		if(types[i] && !types[i - 1]) s1[j ++] = i;
	for(Index i = 0; i < n1; i ++) sa1[i] = s1[sa1[i]];
	std::fill(sa + n1, sa + n + 1, -1);
	for(Index i = n1 - 1; i >= 1; i --) {
		Index j = sa[i]; sa[i] = -1;
		sa[-- bucketOffsets[(int)str[j]]] = j;
	}
	inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);
}

template<typename AlphaT>
void SuffixArray::inducedSort(const AlphaT *str, Index n, int AlphaSize, const std::vector<bool> &types, Index *sa, std::vector<Index> &bucketOffsets) {
	getBucketOffsets(str, n, false, AlphaSize, bucketOffsets);
	for(Index i = 0; i < n; i ++) {
		Index j = sa[i] - 1;
		if(j >= 0 && !types[j]) sa[bucketOffsets[(int)str[j]] ++] = j;
	}

	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	for(Index i = n; i >= 1; i --) {
		Index j = sa[i] - 1;
		if(j >= 0 && types[j]) sa[-- bucketOffsets[(int)str[j]]] = j;
	}
}

template<typename AlphaT>
void SuffixArray::countAlphabets(const AlphaT *str, Index n, int AlphaSize, std::vector<Index> &bucketOffsets, bool b) {
	if(b || (int)bucketOffsets.size() / 2 >= AlphaSize) {
		std::vector<Index>::iterator alphabetCounts =
			b ? bucketOffsets.begin() : bucketOffsets.begin() + AlphaSize;
		std::fill(alphabetCounts, alphabetCounts + AlphaSize, 0);
		for(Index i = 0; i < n; i ++)
			alphabetCounts[(int)str[i]] ++;
	}
}

template<typename AlphaT>
void SuffixArray::getBucketOffsets(const AlphaT *str, Index n, bool dir, int AlphaSize, std::vector<Index> &bucketOffsets) {
	
	
	std::vector<Index>::iterator alphabetCounts;
	if((int)bucketOffsets.size() / 2 < AlphaSize) {
		countAlphabets(str, n, AlphaSize, bucketOffsets, true);
		alphabetCounts = bucketOffsets.begin();
	} else alphabetCounts = bucketOffsets.begin() + AlphaSize;
	Index cumsum = 1;	
	if(dir) {
		for(int i = 0; i < AlphaSize; i ++) {
			cumsum += alphabetCounts[i];
			bucketOffsets[i] = cumsum;
		}
	} else {
		for(int i = 0; i < AlphaSize; i ++) {
			Index x = alphabetCounts[i];
			bucketOffsets[i] = cumsum;
			cumsum += x;
		}
	}
}

void SuffixArray::buildInverseSuffixArray() {
	Index n = length();
	inverseSuffixArray.resize(n + 1);
	for(Index i = 0; i <= n; i ++)
		inverseSuffixArray[suffixArray[i]] = i;
}

void SuffixArray::computeLCPArray(const Alpha *str) {
	int n = length();
	lcpArray.resize(n + 2);
	Index h = 0;
	for(Index i = 0; i < n; i ++) {
		Index pos = inverseSuffixArray[i];
		Index j = suffixArray[pos - 1];
		Index hbound = std::min(n - j, n - i);
		for(Index k = 0; h < hbound && str[i + h] == str[j + h]; ++ h);
		lcpArray[pos - 1] = h;
		if(h > 0) -- h;
	}
	lcpArray[n] = lcpArray[n + 1] = 0;
}

SuffixArray::Index SuffixArray::computeLCP(Index i, Index j) const {
	Index n = length();
	if(i == j) return n - i;
	Index x = inverseSuffixArray[i], y = inverseSuffixArray[j];
	if(x > y) std::swap(x, y);
	return lcpArrayRMQ.queryVal(&lcpArray[0], x, y - 1);
}


bool compareJoinedStrings(int K1, pii s1[/*K1*/], int K2, pii s2[/*K2*/], const SuffixArray &sa, const SuffixArray::Alpha *S) {
	int i1 = 0, o1 = 0, i2 = 0, o2 = 0;
	while(i1 < K1 && i2 < K2) {
		int p1 = s1[i1].first + o1, p2 = s2[i2].first + o2;
		int c = sa.computeLCP(p1, p2);
		int r1 = s1[i1].second - o1, r2 = s2[i2].second - o2;
		int d = min(c, min(r1, r2));
		o1 += d, o2 += d;
		if(d < r1 && d < r2)
			return S[p1 + d] < S[p2 + d];
		if(d == r1) ++ i1, o1 = 0;
		if(d == r2) ++ i2, o2 = 0;
	}
	while(i1 < K1 && s1[i1].second == 0) ++ i1;
	while(i2 < K2 && s2[i2].second == 0) ++ i2;
	return (i1 < K1) < (i2 < K2);
}


struct PalindromicTree {
	typedef int Index;
	typedef char Alpha;
	struct Node {
		
		Index length;
		
		Alpha border;
		Index head, next;
		
		Index suffix;

		Index examplePos;
		Node() {}
		Node(Index length_, Alpha border_, Index next_, Index suffix_, Index examplePos_) :
			length(length_), border(border_), head(-1), next(next_), suffix(suffix_), examplePos(examplePos_) {
		}
	};

	Index nNodes;
	
	vector<Node> nodes;
	vector<Alpha> alphas;

	void init(Index n) {
		assert(n >= 0);
		nodes.resize(n + 2);
		nodes[0] = Node(-1, '\0', -1, -1, 0);
		nodes[1] = Node(0, '\0', -1, 0, 0);
		nNodes = 2;
		alphas.resize(n);
	}

	
	Index getOddRoot() const { return 0; }
	
	
	Index getEvenRoot() const { return 1; }

	Index findChild(Index i, Alpha alpha) const {
		Index c = nodes[i].head;
		while(c != -1) {
			if(nodes[c].border == alpha)
				return c;
			c = nodes[c].next;
		}
		return -1;
	}

	Index findSuffixExtension(Index i, Index pos, Index beginningPos) const {
		while(1) {
			Index len = nodes[i].length, left = pos - 1 - len;
			if(beginningPos <= left && alphas[left] == alphas[pos])
				return i;
			i = nodes[i].suffix;
		}
	}

	bool processAlphabet(Index &activeIndex, Index pos, Index beginningPos) {
		Alpha alpha = alphas[pos];
		Index parentIndex = findSuffixExtension(activeIndex, pos, beginningPos);
		Index childIndex = findChild(parentIndex, alpha);

		if(childIndex != -1) {
			activeIndex = childIndex;
			return false;
		}
		Node &parent = nodes[parentIndex];

		Index suffixIndex;
		if(parent.length == -1) {
			suffixIndex = getEvenRoot();
		} else {
			Index suffixParentIndex = findSuffixExtension(parent.suffix, pos, beginningPos);
			suffixIndex = findChild(suffixParentIndex, alpha);
		}

		childIndex = nNodes ++;
		nodes[childIndex] = Node(parent.length + 2, alpha, parent.head, suffixIndex,
			pos + 1 - parent.length - 2);
		activeIndex = parent.head = childIndex;
		return true;
	}

	
	
	void addString(const Alpha *str, Index len, Index beginningPos = 0) {
		Index activeIndex = getEvenRoot();
		for(Index i = 0; i < len; ++ i) {
			alphas[beginningPos + i] = str[i];
			processAlphabet(activeIndex, beginningPos + i, beginningPos);
		}
	}

	
	void addStringCountFreq(const Alpha *str, Index len, vector<Index> &freq, Index beginningPos = 0) {
		freq.assign(nodes.size(), 0);
		Index activeIndex = getEvenRoot();
		for(Index i = 0; i < len; ++ i) {
			alphas[beginningPos + i] = str[i];
			processAlphabet(activeIndex, beginningPos + i, beginningPos);
			++ freq[activeIndex];
		}
		
		for(Index i = nNodes - 1; i > 0; -- i)
			freq[nodes[i].suffix] += freq[i];
	}
};


template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
};
typedef ModInt<1000000007> mint;

int main() {
	int n; int q;
	while(~scanf("%d%d", &n, &q)) {
		char s[100001];
		scanf("%s", s);
		const mint A = 100001;
		vector<mint> pow(n + 1);
		pow[0] = 1;
		rep(i, n) pow[i + 1] = pow[i] * A;
		vector<mint> hash(n + 1);
		rep(i, n)
			hash[i + 1] = hash[i] * A + mint(s[i]);
		PalindromicTree pt;
		pt.init(n);
		vector<int> freq;
		pt.addStringCountFreq(s, n, freq);
		vector<pair<pii, int>> palins(pt.nNodes - 2);
		reu(i, 2, pt.nNodes) {
			int pos = pt.nodes[i].examplePos;
			int len = pt.nodes[i].length;
			int f = freq[i];
			palins[i - 2] = { {pos, len}, f };
		}
		SuffixArray sa;
		sa.buildAll(s, n);
		sort(palins.begin(), palins.end(), [&](pair<pii, int> p, pair<pii, int> q) {
			return compareJoinedStrings(1, &p.first, 1, &q.first, sa, s);
		});
		vector<ll> pre(palins.size() + 1);
		rep(i, palins.size())
			pre[i + 1] = pre[i] + palins[i].second;
		rep(ii, q) {
			long long k;
			scanf("%lld", &k), -- k;
			int i = (int)(upper_bound(pre.begin(), pre.end(), k) - pre.begin()) - 1;
			if(i == palins.size()) {
				puts("-1");
			} else {
				pii p = palins[i].first;
				mint ans = hash[p.first + p.second] - hash[p.first] * pow[p.second];
				printf("%d\n", ans.get());
			}
		}
	}
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.82
hard
----------
PROBLEM STATEMENT:
White Falcon just solved the data structure problem below using heavy-light decomposition. Can you help her find a new solution that doesn't require implementing any fancy techniques? 

There are [expression] types of query operations that can be performed on a tree:


1 u x: Assign [expression].
2 u v: Print the sum of the node values in the unique path from node [expression].


Given a tree with [expression] queries. 
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>

using namespace std;

#define sgmn int v, int tl, int tr
#define tm  (tl + tr >> 1)
#define sol v*2, tl, tm
#define sag v*2+1, tm+1, tr
#define N 100005

vector < int > V[N];

int A[N],F[N],L[N][18],Dpt[N],MyCn[N],Hd[N],Dsc[N],Sz[N],Scld[N],T,no,n,w,i,h,u,v,x,y,hd,lc,t,ddd,asd;

int lca(){
	u = x;  v = y;
	if(Dpt[u] < Dpt[v])
		swap(u , v);

	t = Dpt[u] - Dpt[v];

	for(i=0;i<18;i++)
		if(t & (1 << i))
			u = L[u][i];

	if(u != v){
		for(i=17;i>=0;i--)
			if(L[u][i] != L[v][i]){
				u = L[u][i];
				v = L[v][i];
			}
		u = L[u][0];
	}
	return u;
}

void f(int x){

	if(!Hd[no]) Hd[no] = x;
	MyCn[x] = no;
	Dsc[x] = ++T;

	if(Scld[x]) f(Scld[x]);

	for(int i=0; i<V[x].size(); i++)
		if(!Dsc[ V[x][i] ]){
			no++;
			f( V[x][i] );
		}
}

void g(int x){

	Dpt[x] = t;
	Sz[x] = 1;

	for(i=1;i<17;i++)
		L[x][i] = L[ L[x][i-1] ][i-1];    t++;

	for(int i=0; i<V[x].size(); i++)
		if(!Sz[ V[x][i] ]){
			L[ V[x][i] ][0] = x;
			g( V[x][i] );
			Sz[x] += Sz[ V[x][i] ];
		}                                 t--;

	if(Sz[ Scld[ L[x][0] ] ] < Sz[x])
		Scld[ L[x][0] ] = x;
}

void up(){
	u = Dsc[x];
	for(; u < N ; u += u & -u)
		F[u] += y - A[ Dsc[x] ];
	A[ Dsc[x] ] = y;
}

int qry(){
	ddd = 0;
	for(; u ; u -= u & -u)
		ddd += F[u];
	return ddd;
}

void ff(){
	while(1){
		hd = Hd[ MyCn[v] ];
		if(Dpt[hd] < Dpt[lc])  hd = lc;
		u = Dsc[hd]-1;  asd -= qry();
		u = Dsc[v];     asd += qry();
		if(hd == lc) break;
		v = L[hd][0];
	}
}
int main(){

	scanf("%d%d",&n,&w);

	for(i=n;--i;){
		scanf("%d%d",&x,&y); x++; y++;
		V[x].push_back(y);
		V[y].push_back(x);
	}

	g(1);  f(1);

	while(w--){

		scanf("%d%d%d",&h,&x,&y);  x++; y++;

		if(h == 1)
			y--,  up();

		else{

			lc = lca();  asd = 0;

			v = x;  ff();

			v = y;  ff();

			asd -= A[ Dsc[lc] ];

			printf("%d\n",asd);
		}
	}

	return 0;
}


----------
====================
----------
DATA-STRUCTURES.83
expert
----------
PROBLEM STATEMENT:
Simon received the board game Ticket to Ride as a birthday present. After playing it with his friends, he decides to come up with a strategy for the game.

There are [expression] road plans. Each road plan consists of the following: 


Two cities which can be directly connected by a road.
The length of the proposed road. 


The entire road plan is designed in such a way that if one builds all the roads, it will be possible to travel between any pair of cities. 

A ticket enables you to travel between two different cities. There are [expression] tickets, and each ticket has a cost associated with it. A ticket is considered to be useful if there is a path between those cities.

Simon wants to choose two cities, [expression] are not necessarily unique and may be the same cities.

Given [expression] ticket prices, help Simon by printing the value of his maximum possible profit on a new line.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
int mod = (int) 1e9 + 7;
const int logN = 16;
const int inf = 1e9 + 9;
const int N = 2e5 + 6;

int d[N], ROOT, w[N], n, m, k, x, y, z, h[N], start[N], finish[N], T, sum[N];
ll ans, ST[N << 2], L[N << 2];
vector< pii > v[N], g[N];
vector< int > all;

void push(int k) {
    if(L[k]) {
        L[sol] += L[k]; L[sag] += L[k];
        ST[sol] += L[k]; ST[sag] += L[k];
        L[k] = 0;
    }
    return ;
}

ll query(int k, int bas, int son, int x, int y) {
    if(bas > y || son < x) return 0;
    if(x <= bas && son <= y) { return ST[k];}
    push(k);
    return max(query(sol, bas, orta, x, y), query(sag, orta + 1, son, x, y));
}

ll update(int k, int bas, int son, int x, int y, ll t) {
    if(bas > y || son < x) return ST[k];
    if(x <= bas && son <= y) { L[k] += t; return ST[k] += t; }
    push(k);
    return ST[k] = max(update(sol, bas, orta, x, y, t), update(sag, orta + 1, son, x, y, t));
}

ll assign(int k, int bas, int son, int x, ll t) {
    if(bas > x || son < x) return ST[k];
    if(bas == son) { L[k] = 0; return ST[k] = t; }
    push(k);
    return ST[k] = max(assign(sol, bas, orta, x, t), assign(sag, orta + 1, son, x, t));
}

int prep(int node, int root) {
    sum[node] = d[node];
    foreach(it, v[node])
        if(it->st != root && !h[it->st])
            sum[node] += prep(it->st, node);
    return sum[node];
}

int find(int node, int root, int S) {
    foreach(it, v[node])
        if(it->st != root && !h[it->st] && sum[it->st] > S)
            return find(it->st, node, S);
    return node;
}

void dfs(int node, int root, ll dist, int p) {
    start[node] = ++T;
    w[node] = p;
    foreach(it, v[node]) {
        if(it->st == root || h[it->st]) continue;
        if(root == 0) p++;
        dfs(it->st, node, dist + it->nd, p);
    } finish[node] = T;
    return ;
}

void get(int node, int root, ll dist, int pp) {
    foreach(it, g[node])
        if(w[it->st] && w[it->st] < w[node]) {
            update(1, 1, T, start[it->st], finish[it->st], it->nd);
        }
        else if(root && (ROOT == it->st || (w[it->st] == w[node] && start[it->st] <= start[node] && start[node] <= finish[it->st]))) {
            dist -= it->nd;
        }
    all.pb(node);
    assign(1, 1, T, start[node], -dist);
    ans = max(ans, -dist + query(1, 1, T, 1, start[pp] - 1));
    foreach(it, v[node]) {
        if(it->st == root || h[it->st]) continue;
        get(it->st, node, dist + it->nd, (root == 0 ? it->st : pp));
    }

    foreach(it, g[node])
        if(w[it->st] && w[it->st] < w[node]) {
            update(1, 1, T, start[it->st], finish[it->st], -it->nd);
        }
    return ;
}

void del(int k, int bas, int son) {
    ST[k] = L[k] = 0;
    if(bas == son) return ;
    del(sol, bas, orta);
    del(sag, orta + 1, son);
}

void solve(int node) {
    prep(node, 0);
    node = find(node, 0, sum[node] / 2);
    T = 0;
    all.clear();
    ROOT = node;
    dfs(node, 0, 0, 0);
    get(node, 0, 0, 1);
    h[node] = 1;
    foreach(it, all) w[*it] = 0;
    del(1, 1, T);
    foreach(it, v[node])
        if(!h[it->st])
            solve(it->st);
    return ;
}

int main() {

    scanf("%d", &n);

    FOR(i, 2, n) {
        scanf("%d %d %d", &x, &y, &z);
        v[x].pb(mp(y, z));
        v[y].pb(mp(x, z));
        d[i]++;
    } d[1]++;

    scanf("%d", &m);

    ll all = 0;

    FOR(i, 1, m) {
        scanf("%d %d %d", &x, &y, &z);
        if(x == y) { assert(0); all += z; continue; }
        d[x]++; d[y]++;
        g[x].pb(mp(y, z));
        g[y].pb(mp(x, z));
    }

    solve(1);

    cout << all + max(ans, 0LL) << endl;

    return 0;
}

----------
====================
----------
DATA-STRUCTURES.84
hard
----------
PROBLEM STATEMENT:
Our lazy white falcon finally decided to learn heavy-light decomposition. Her teacher gave an assignment for her to practice this new technique. Please help her by solving this problem. 

You are given a tree with [expression]. The problem asks you to operate the following two types of queries:


"1 u x" assign [expression].
"2 u v" print the maximum value of the nodes on the unique path between [expression].

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>

using namespace std;

#define sgmn int v, int tl, int tr
#define tm  (tl + tr >> 1)
#define sol v*2, tl, tm
#define sag v*2+1, tm+1, tr
#define N 100005

vector < int > V[N];

int s[4*N],L[N][18],Dpt[N],MyCn[N],Hd[N],Dsc[N],Sz[N],Scld[N],T,no,n,w,i,h,u,v,x,y,l,r,hd,lc,t,ddd,asd;

int lca(){
	u = x;  v = y;
	if(Dpt[u] < Dpt[v])
		swap(u , v);

	t = Dpt[u] - Dpt[v];

	for(i=0;i<18;i++)
		if(t & (1 << i))
			u = L[u][i];

	if(u != v){
		for(i=17;i>=0;i--)
			if(L[u][i] != L[v][i]){
				u = L[u][i];
				v = L[v][i];
			}
		u = L[u][0];
	}
	return u;
}

void f(int x){

	if(!Hd[no]) Hd[no] = x;
	MyCn[x] = no;
	Dsc[x] = ++T;

	if(Scld[x]) f(Scld[x]);

	for(int i=0; i<V[x].size(); i++)
		if(!Dsc[ V[x][i] ]){
			no++;
			f( V[x][i] );
		}
}

void g(int x){

	Dpt[x] = t;
	Sz[x] = 1;

	for(i=1;i<17;i++)
		L[x][i] = L[ L[x][i-1] ][i-1];    t++;

	for(int i=0; i<V[x].size(); i++)
		if(!Sz[ V[x][i] ]){
			L[ V[x][i] ][0] = x;
			g( V[x][i] );
			Sz[x] += Sz[ V[x][i] ];
		}                                 t--;

	if(Sz[ Scld[ L[x][0] ] ] < Sz[x])
		Scld[ L[x][0] ] = x;
}

void up(sgmn){
	if(tl == tr)
	{  s[v] = y;  return;  }
	if(Dsc[x] <= tm) up(sol);
	else             up(sag);
	s[v] = max(s[v*2] , s[v*2+1]);
}

int qry(sgmn){
	if(tl > r || tr < l)
		return 0;
	if(tl >= l && tr <= r)
		return s[v];
	return max( qry(sol) , qry(sag) );
}

void ff(){
	while(1){
		hd = Hd[ MyCn[v] ];
		if(Dpt[hd] < Dpt[lc])  hd = lc;
		l = Dsc[hd];
		r = Dsc[v];
		asd = max(asd , qry(1,1,n));
		if(hd == lc) break;
		v = L[hd][0];
	}
}
int main(){

	scanf("%d%d",&n,&w);

	for(i=n;--i;){
		scanf("%d%d",&x,&y); x++; y++;
		V[x].push_back(y);
		V[y].push_back(x);
	}

	g(1);  f(1);

	while(w--){

		scanf("%d%d%d",&h,&x,&y);  x++; y++;

		if(h == 1)
			y--,  up(1,1,n);

		else{

			lc = lca();  asd = 0;

			v = x;  ff();
			v = y;  ff();

			printf("%d\n",asd);
		}
	}

	return 0;
}


----------
====================
----------
DATA-STRUCTURES.85
advanced
----------
PROBLEM STATEMENT:
Alexey is playing with an array, [expression].

Alexey solved Ivan's challenge faster than expected, so Ivan decides to add another layer of difficulty by having Alexey answer [expression]. 

More formally, for each query [expression], Alexey must calculate the following function:

[expression].

Can you help Alexey solve this problem?
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }


template<typename InpIt, typename OutIt, typename Val, typename Cmp>
void stackAlgorithm(InpIt beg, InpIt end, OutIt out, Cmp cmp = Cmp()) {
	int n = (int)std::distance(beg, end);
	for(int i = 0; i < n; ++ i) {
		int k = i;
		while(k > 0 && cmp(beg[k - 1], beg[i]))
			k = out[k - 1];
		out[i] = k;
	}
}
template<typename InpIt, typename OutIt, typename Cmp>
void stackAlgorithm(InpIt it, InpIt end, OutIt out, Cmp cmp = Cmp()) {
	return stackAlgorithm<InpIt, OutIt, typename iterator_traits<InpIt>::value_type, Cmp>(it, end, out, cmp);
}

struct Sum {
	ll sum1, sumX, sumY, sumXY;
	Sum() : sum1(0), sumX(0), sumY(0), sumXY(0) {}
	Sum(ll sum1, ll sumX, ll sumY, ll sumXY) : sum1(sum1), sumX(sumX), sumY(sumY), sumXY(sumXY) {}
	Sum &operator+=(const Sum &that) {
		sum1 += that.sum1;
		sumX += that.sumX;
		sumY += that.sumY;
		sumXY += that.sumXY;
		return *this;
	}
	Sum operator+(const Sum &that) const {
		return Sum(*this) += that;
	}
	ll dot(const Sum &that) const {
		ll r = 0;
		r += sum1 * that.sum1;
		r += sumX * that.sumX;
		r += sumY * that.sumY;
		r += sumXY * that.sumXY;
		return r;
	}
	Sum operator-() const {
		return Sum(-sum1, -sumX, -sumY, -sumXY);
	}
};


struct RankDictionary {
	typedef unsigned u32;
	int length, blockslength, count;
	vector<u32> blocks; vector<int> ranktable;
	RankDictionary(int len) : length(len) {
		blocks.resize((blockslength = (len + 31) / 32) + 1);
	}
	inline void set(int i) { blocks[i / 32] |= 1 << i % 32; }
	void build() {
		if(length == 0) { count = 0; return; }
		ranktable.assign(blockslength + 1, 0);
		int count1 = 0;
		for(int i = 0; i < blockslength; i ++) {
			ranktable[i] = count1;
			count1 += popcount(blocks[i]);
		}
		ranktable[blockslength] = count1;
		count = count1;
	}
	inline bool access(int pos) const {
		return blocks[pos / 32] >> pos % 32 & 1;
	}
	inline int rank(int pos) const {	//
		int block_idx = pos / 32;
		return ranktable[block_idx] + popcount(blocks[block_idx] & (1U << pos % 32) - 1);
	}
	inline int rank(bool b, int pos) const { return b ? rank(pos) : pos - rank(pos); }
	inline int rank(bool b, int left, int right) const { return rank(b, right) - rank(b, left); }
private:
	static inline int popcount(u32 x) {
		x = x - ((x >> 1) & 0x55555555);
		x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
		return ((x + (x >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
	}
};


struct WaveletFenwickRangeTree {
	typedef int Pos;
	int length, bitsize; Pos maxy;
	vector<RankDictionary> dicts;
	vector<vector<Sum> > nodes;
	vector<Sum> allnodes;	//

	void init(const vector<Pos> &ys) {
		length = ys.size();
		if(length == 0) return;

		maxy = *max_element(ys.begin(), ys.end());
		assert(*min_element(ys.begin(), ys.end()) >= 0);

		for(bitsize = 0; Pos(1) << bitsize <= maxy; bitsize ++);

		dicts.assign(bitsize, length);
		nodes.assign(bitsize, vector<Sum>(length));

		vector<int> poses; poses.reserve(1 << bitsize);
		for(int bit = 0; bit < bitsize; bit ++) {
			RankDictionary& dict = dicts[bit];
			poses.assign(1 << bit, 0);
			for(int i = 0; i < length; i ++)
				poses[ys[i] >> (bitsize - bit)] ++;
			for(int i = 1; i < 1 << bit; i ++) poses[i] += poses[i - 1];
			for(int i = length - 1; i >= 0; i --) {
				int x = ys[i] >> (bitsize - bit);
				poses[x] --;
				if(ys[i] >> (bitsize - bit - 1) & 1)
					dict.set(poses[x]);
			}
			dict.build();

			vector<Sum> &cnodes = nodes[bit];
			for(int i = 0; i < length; i ++) {
				int x = poses[ys[i] >> (bitsize - bit)] ++;
			}
			for(int i = 0; i < 1 << bit; i ++) {
				int left = i == 0 ? 0 : poses[i - 1], h = poses[i] - left;
				for(int j = 0; j < h; ++ j) {
					int p = j | (j + 1);
					if(p < h)
						cnodes[left + p] += cnodes[left + j];
				}
			}
		}

		allnodes.assign(ys.size(), Sum());
	}
	Sum getRange(int pos, Pos bottom) const {
		if(bottom > maxy) return getRange1(&allnodes[0], pos);	//
		Sum res = Sum();
		int nodeleft = 0, noderight = length;
		for(int bit = 0; bit < bitsize; bit ++) {
			bool dir = bottom >> (bitsize - bit - 1) & 1;

			if(dir)	//
				res += getRange1(&nodes[bit][0] + nodeleft, pos - nodeleft);

			int leftcount = dicts[bit].rank(dir, nodeleft, pos);
			if(dir) nodeleft += dicts[bit].rank(false, nodeleft, noderight);
			else noderight -= dicts[bit].rank(true, nodeleft, noderight);
			pos = nodeleft + leftcount;
		}
		return res;
	}
	void add(int pos, const Sum &x) {
		add1(&allnodes[0], length, pos, x);

		int nodeleft = 0, noderight = length;
		for(int bit = 0; bit < bitsize; bit ++) {
			bool dir = dicts[bit].access(pos);

			if(!dir)	//
				add1(&nodes[bit][0] + nodeleft, noderight - nodeleft, pos - nodeleft, x);

			int leftcount = dicts[bit].rank(dir, nodeleft, pos);
			if(dir) nodeleft += dicts[bit].rank(false, nodeleft, noderight);
			else noderight -= dicts[bit].rank(true, nodeleft, noderight);
			pos = nodeleft + leftcount;
		}
	}
private:
	inline void add1(Sum *cnodes, int h, int i, const Sum &x) const {
		for(; i < h; i |= i + 1) cnodes[i] += x;
	}
	inline Sum getRange1(const Sum *cnodes, int i) const {
		Sum res = Sum();
		for(-- i; i >= 0; i = (i & (i + 1)) - 1) res += cnodes[i];
		return res;
	}
};



typedef WaveletFenwickRangeTree::Pos Pos;
struct Point3D {
	Pos x, y, z;
	Point3D() {}
	Point3D(Pos x_, Pos y_, Pos z_) : x(x_), y(y_), z(z_) {}
	bool operator<(const Point3D &that) const { return x < that.x; }
};
struct Rect3D {
	Pos xU;	//
	Pos yL, yU;
	Pos zU;
	Rect3D() {}
	Rect3D(Pos xU_, Pos yL_, Pos yU_, Pos zU_) :
		xU(xU_), yL(yL_), yU(yU_), zU(zU_) {
	}
};
void threeDimensionalRectangleSumQueryWithRangeTree(const vector<pair<Point3D, Sum> > &points, const vector<pair<Rect3D, pair<Sum,int> > > &queries, vector<ll> &ans) {
	int n = points.size(), m = queries.size();
	vector<pair<Pos, int> > sortedByX(n), sortedByY(n);
	rep(i, n) {
		sortedByX[i] = make_pair(points[i].first.x, i);
		sortedByY[i] = make_pair(points[i].first.y, i);
	}
	sort(sortedByX.begin(), sortedByX.end());
	sort(sortedByY.begin(), sortedByY.end());

	vector<Pos> yPoses(n), zPoses(n);
	vector<int> yIndices(n);
	rep(i, n) {
		yPoses[i] = sortedByY[i].first;
		zPoses[i] = points[sortedByY[i].second].first.z;
		yIndices[sortedByY[i].second] = i;
	}

	WaveletFenwickRangeTree rt;
	rt.init(zPoses);

	vector<pair<Pos, int> > qs(m);
	rep(i, m)
		qs[i] = make_pair(queries[i].first.xU, i);
	sort(qs.begin(), qs.end());

	int pi = 0, qi = 0;
	for(; ; ++ pi) {
		while(qi < m && (pi == n || qs[qi].first <= sortedByX[pi].first)) {
			int i = qs[qi].second;
			const Rect3D &rect = queries[i].first;
			int Li = lower_bound(yPoses.begin(), yPoses.end(), rect.yL) - yPoses.begin();
			int Ri = lower_bound(yPoses.begin(), yPoses.end(), rect.yU) - yPoses.begin();
//			ans[queries[i].second.second] += queries[i].second.first.dot(rt.getRange(Li, Ri, rect.zU));
			Sum sum;
			/*
			rep(ji, pi) {
				int j = sortedByX[ji].second;
				auto pos = points[j].first;
				if(rect.yL <= pos.y && pos.y < rect.yU && pos.z < rect.zU)
					sum += points[j].second;
			}*/
			sum += rt.getRange(Ri, rect.zU);
			sum += -rt.getRange(Li, rect.zU);
			ans[queries[i].second.second] += queries[i].second.first.dot(sum);

			++ qi;
		}
		if(pi == n) break;
		int j = sortedByX[pi].second, idx = yIndices[j];
		rt.add(idx, points[j].second);
	}
}

int main() {
	int n; int m;
	while(~scanf("%d%d", &n, &m)) {
//	while(1) {
//		n = rand() % 20 + 1, m = rand() % 20 + 1;
		vector<int> A(n);
		for(int i = 0; i < n; ++ i) {
			scanf("%d", &A[i]);
//			A[i] = rand() % 100;
		}
//		random_shuffle(all(A));

		vi orgA = A;

		vpii ord(n);
		rep(i, n) ord[i] = mp(A[i], i);
		sort(all(ord));
		rep(i, n)
			A[ord[i].second] = i;
		vector<int> L(n), R(n);
		stackAlgorithm(A.begin(), A.end(), L.begin(), less_equal<int>());
		stackAlgorithm(A.rbegin(), A.rend(), R.rbegin(), less_equal<int>());
		rep(i, n) R[i] = n - 1 - R[i];
		vector<pair<Point3D, Sum>> points[4];
		rep(k, 4)
			points[k].assign(n, make_pair(Point3D(), Sum()));
		rep(i, n) {
			rep(k, 4) {
				points[k][i].first = Point3D(L[i], i, R[i]);
				if(k == 2 || k == 3) (points[k][i].first.x *= -1) += n;
				if(k == 1 || k == 3) (points[k][i].first.z *= -1) += n;
			}
			int w = orgA[i];
			int l = L[i], r = R[i];

			points[0][i].second.sum1 += (ll)w * (i + 1) * (- i + 1);
			points[0][i].second.sum1 += (ll)w * (i + 1) * r;
			points[0][i].second.sumX += (ll)w * (- i + 1) * -1;
			points[0][i].second.sumX += (ll)w * -1 * r;

			points[1][i].second.sum1 += (ll)w * (i + 1) * (- i + 1);
			points[1][i].second.sumY += (ll)w * (i + 1) * 1;
			points[1][i].second.sumX += (ll)w * (- i + 1) * -1;
			points[1][i].second.sumXY += (ll)w * -1 * 1;

			points[2][i].second.sum1 += (ll)w * (i + 1) * (- i + 1);
			points[2][i].second.sum1 += (ll)w * (i + 1) * r;
			points[2][i].second.sum1 += (ll)w * (- i + 1) * -l;
			points[2][i].second.sum1 += (ll)w * -l * r;

			points[3][i].second.sum1 += (ll)w * (i + 1) * (- i + 1);
			points[3][i].second.sumY += (ll)w * (i + 1) * 1;
			points[3][i].second.sum1 += (ll)w * (- i + 1) * -l;
			points[3][i].second.sumY += (ll)w * -l * 1;
		}
		vector<pair<Rect3D, pair<Sum, int>>> queries[4];
		rep(k, 4)
			queries[k].resize(m);
		vector<int> Xs(m), Ys(m);
		rep(i, m) {
			int X; int Y;
			scanf("%d%d", &X, &Y), -- X, -- Y;
//			X = rand() % n, Y = rand() % n; if(X > Y)swap(X, Y);
			Xs[i] = X, Ys[i] = Y;

			auto mulidx = make_pair(Sum(1, X, Y, (ll)X * Y), i);

			ll ans = 0;
			rep(k, 4) {
				int sX = k == 0 || k == 1 ? X : -X + 1 + n;
				int sY = k == 0 || k == 2 ? Y : -Y + 1 + n;

				Rect3D rect(sX, X, Y + 1, sY);
				queries[k][i] = make_pair(rect, mulidx);
			}
		}

		vector<ll> ans(m, 0);
		rep(k, 4) {
			threeDimensionalRectangleSumQueryWithRangeTree(points[k], queries[k], ans);
/*
			for(auto q : queries[k]) {
				for(auto p : points[k]) {
					auto rect = q.first;
					auto pos = p.first;
					if(pos.x < rect.xU && rect.yL <= pos.y && pos.y < rect.yU && pos.z < rect.zU)
						ans[q.second.second] += q.second.first.dot(p.second);
				}
			}*/
		}

		rep(i, m) {
			printf("%lld\n", ans[i]);
			/*

			int X = Xs[i], Y = Ys[i];
			ll naiveans = 0;
			rer(j, X, Y) {
				int ma = -INF;
				rer(k, j, Y) {
					amax(ma, orgA[k]);
					naiveans += ma;
				}
			}
			if(naiveans != ans[i]) {
				cerr << n << " " << m << endl;
				rep(i, n) cerr << orgA[i] << " "; cerr << endl;
				rep(i, m) cerr << Xs[i] + 1 << " " << Ys[i] + 1 << endl;
				cerr << naiveans << " != " << ans[i] << endl;
			}*/
		}
	}
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.86
expert
----------
PROBLEM STATEMENT:
Andy and Lily love playing games with numbers and trees. Today they have a  tree consisting of [expression].

Before the game starts, Andy chooses an unordered pair of distinct nodes, [expression]:



Andy then uses this list to play the following game with Lily:


Two players move in alternating turns, and both players play optimally (meaning they will not make a move that causes them to lose the game if some better, winning move exists).
Andy always starts the game by removing a single integer from the list.
During each subsequent move, the current player removes an integer less than or equal to the integer removed in the last move.
The first player to be unable to move loses the game.


For example, if the list of integers is [expression]).

The two friends decide to play [expression] games, where each game is in the form of a tree. For each game, calculate the number of unordered pairs of nodes that Andy can choose to ensure he always wins the game.
----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#pragma comment(linker, "/stack:16777216")
#include <string>
#include <vector>
#include <map>
#include <list>
#include <iterator>
#include <set>
#include <queue>
#include <iostream>
#include <sstream>
#include <stack>
#include <deque>
#include <cmath>
#include <memory.h>
#include <cstdlib>
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <utility>
#include <assert.h>
#include <time.h>
#include <complex.h>


#include <fstream>
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>
using namespace std;

#define FOR(i, a, b) for(int i=(a);i<(b);i++)
#define RFOR(i, b, a) for(int i=(b)-1;i>=(a);--i)
#define FILL(A,value) memset(A,value,sizeof(A))
#define ALL(V) V.begin(), V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair
#define Pi 3.14159265358979

typedef long long Int;
typedef unsigned long long UInt;
typedef vector<int> VI;
typedef pair<Int, Int> PII;

const int INF = 1000000000;
const int MAX = 500007;
const int MAXD = 20;
const int MOD = 1000000007;

unsigned long long f(unsigned long long x)
{
    return x * 747474747 + 447474747;
}

vector<pair<int, unsigned long long> > G[MAX];

map<unsigned long long, int> M;

void dfs(int v, int p, unsigned long long hash)
{
    M[hash] ++;
    FOR(i,0,SZ(G[v]))
    {
        int to = G[v][i].first;
        if (to == p) continue;
        dfs(to , v , hash ^ G[v][i].second);
    }
}

int main()
{
    //freopen("in.txt" , "r" , stdin);
    //freopen("out.txt" , "w" , stdout);
    
    int t;
    cin >> t;
    FOR(tt,0,t)
    {
        int n;
        cin >> n;
        FOR(i,0,n)
        {
            G[i].clear();
        }
        FOR(i,0,n - 1)
        {
            int a , b , c;
            scanf("%d%d%d", &a , &b , &c);
            -- a; --b;
            G[a].push_back(MP(b , f(c)));
            G[b].push_back(MP(a , f(c)));
        }
        
        Int res = 1LL * n * (n - 1) / 2;
        M.clear();
    
        dfs(0,-1,0);
    
        for(map<unsigned long long, int>::iterator it = M.begin(); it != M.end(); ++it)
            res -= 1LL * it->second * (it->second - 1) / 2;
        cout << res << endl;
    }
    
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.87
hard
----------
PROBLEM STATEMENT:
White Falcon was amazed by what she can do with heavy-light decomposition on trees. As a resut, she wants to improve her expertise on heavy-light decomposition. Her teacher gave her an another assignment which requires path updates. As always, White Falcon needs your help with the assignment.

You are given a tree with [expression].

Let's denote the path from node [expression] are connected.  

The problem asks you to operate the following two types of queries on the tree:


"1 u v x" Add [expression]. 
"2 u v" print the sum of the nodes' values on the path between [expression].

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>

using namespace std;

#define sgmn int v, int tl, int tr
#define tm  (tl + tr >> 1)
#define sol v*2, tl, tm
#define sag v*2+1, tm+1, tr
#define md 1000000007
#define N 50004

vector < int > V[N];

int l1[4*N][32],l2[4*N][32],L[N][17],Dpt[N],MyCn[N],Hd[N],Dsc[N],Sz[N],Scld[N],T,no,n,w,i,h,val,u,v,x,y,l,r,hd,lc,ddd;

long long s[4*N][32],lz1[4*N][32],lz2[4*N][32],gom[32],asd,t;

bool hh;

int lca(){
	u = x;  v = y;
	if(Dpt[u] < Dpt[v])
		swap(u , v);

	t = Dpt[u] - Dpt[v];

	for(i=0;i<17;i++)
		if(t & (1 << i))
			u = L[u][i];

	if(u != v){
		for(i=16;i>=0;i--)
			if(L[u][i] != L[v][i]){
				u = L[u][i];
				v = L[v][i];
			}
		u = L[u][0];
	}
	return u;
}

void f(int x){

	if(!Hd[no]) Hd[no] = x;
	MyCn[x] = no;
	Dsc[x] = ++T;

	if(Scld[x]) f(Scld[x]);

	for(int i=0; i<V[x].size(); i++)
		if(!Dsc[ V[x][i] ]){
			no++;
			f( V[x][i] );
		}
}

void g(int x){

	Dpt[x] = t;
	Sz[x] = 1;

	for(i=1;i<17;i++)
		L[x][i] = L[ L[x][i-1] ][i-1];    t++;

	for(int i=0; i<V[x].size(); i++)
		if(!Sz[ V[x][i] ]){
			L[ V[x][i] ][0] = x;
			g( V[x][i] );
			Sz[x] += Sz[ V[x][i] ];
		}                                 t--;

	if(Sz[ Scld[ L[x][0] ] ] < Sz[x])
		Scld[ L[x][0] ] = x;
}


void push(sgmn){
	
//	cout << v << " " << tl << " " << tr << "  sgmn\n";
	if(!l1[v] && !l2[v]) return;
	for(i=0;i<31;i++){

//			cout << i << "  fff\n";
		if(l1[v][i]){
			s[v*2+1][i] = ( s[v*2+1][i] + (lz1[v][i] * 2 + l1[v][i] * (tr - tm - 1)) * (tr - tm) / 2 ) % md;
			s[v*2][i] = ( s[v*2][i] + (2*(lz1[v][i] + l1[v][i] * (tr - tm)) + l1[v][i]*(tm - tl)) * (tm - tl + 1) / 2 ) % md;
			lz1[v*2+1][i] = ( lz1[v*2+1][i] + lz1[v][i] ) % md;
			lz1[v*2][i] = ( lz1[v*2][i] + lz1[v][i] + l1[v][i] * (tr - tm) ) % md;
			l1[v*2][i] += l1[v][i];
	   	l1[v*2+1][i] += l1[v][i];
		}

		//			cout << i << "  fff\n";
		if(lz2[v][i] && l2[v]){
			s[v*2][i] = ( s[v*2][i] + (lz2[v][i] * 2 + l2[v][i] * (tm - tl)) * (tm - tl + 1) / 2 ) % md;
			s[v*2+1][i] = ( s[v*2+1][i] + (2*(lz2[v][i] + l2[v][i] * (tm - tl + 1)) + l2[v][i] * (tr - tm - 1)) * (tr - tm) / 2 ) % md;
			lz2[v*2][i] = ( lz2[v*2][i] + lz2[v][i] ) % md;
			lz2[v*2+1][i] = ( lz2[v*2+1][i] + lz2[v][i] + l2[v][i] * (tm - tl + 1) ) % md;
			l2[v*2][i] += l2[v][i];
			l2[v*2+1][i] += l2[v][i];
		}

		l1[v][i] = l2[v][i] = lz1[v][i] = lz2[v][i] = 0;
	}
}
void up(sgmn){
	if(tl > r || tr < l) return;
	if(tl >= l && tr <= r){
		if(hh){
			for(i=0;i<31;i++)
				if(val & (1 << i)){
//					cout << tl << " " << tr << " " << v << " " << i << " " << ddd + r - tr + 1 << " x\n";
					lz1[v][i] = ( lz1[v][i] + ddd + r - tr + 1 ) % md;
					l1[v][i]++;
					s[v][i] = ( s[v][i] + ((ddd + r - tr + 1) * 2 + tr - tl) * (tr - tl + 1) / 2 ) % md;
				}
		}

		else{
			for(i=0;i<31;i++)
				if(val & (1 << i)){
//					cout << tl << " " << tr << " " << v << " " << i << " " <<  ddd + tl - l + 2 << " y\n";
					lz2[v][i] = ( lz2[v][i] + ddd + tl - l + 1 ) % md;
					l2[v][i]++;
					s[v][i] = ( s[v][i] + ((ddd + tl - l + 1) * 2 + tr - tl) * (tr - tl + 1) / 2 ) % md; 
				}
		}
   
		return;  
	}
	push(v,tl,tr);  up(sol);  up(sag);
	for(i=0;i<31;i++)
		s[v][i] = ( s[v*2][i] + s[v*2+1][i] ) % md;
}

void qry(sgmn){
	if(tl > r || tr < l) return;  if(tl >= l && tr <= r) { for(i=0;i<31;i++) asd = ( asd + s[v][i] * gom[i] ) % md;  return; }
	push(v,tl,tr);  qry(sol);  qry(sag);
}

void ff(){
//	cout << v << " " << lc << " " << hh << " gg\n";
	while(1){
		hd = Hd[ MyCn[v] ];
		if(Dpt[hd] < Dpt[lc])  hd = lc;
		l = Dsc[hd];
		r = Dsc[v];
		//cout << hh << " " << ddd << " " << v << " " << hd << " " << l << " " << r << " FF\n";
		if(!hh) ddd -= r - l + 1;
		if(h)   qry(1,1,n);
		else    up(1,1,n); 
		if(hh)  ddd += r - l + 1;
		if(hd == lc) break;
		v = L[hd][0];
	}
}
int main(){

	scanf("%d%d",&n,&w);

	for(i=n;--i;){
		scanf("%d%d",&x,&y); x++; y++;
		V[x].push_back(y);
		V[y].push_back(x);
	}

	g(1);  f(1);

	for(t=1,i=0;i<31;i++){
		gom[i] = t;
		t = t*2 % md;
	}

	while(w--){

		scanf("%d%d%d",&h,&x,&y);  h--; x++; y++;

		if(!h)
			scanf("%d",&val);

		lc = lca();

		asd = ddd = 0; v = x;  hh = 1;  ff();

		if(y != lc){
			t = Dpt[y] - Dpt[lc] - 1;
			lc = y;
			for(i=0;i<17;i++)
				if(t & (1 << i))
					lc = L[lc][i];

			ddd = Dpt[x] + Dpt[y] - 2*(Dpt[lc]-1) + 1;  v = y;  hh = 0;  ff();
		}

		if(h)
			printf("%lld\n",asd);
	}

	return 0;
}

----------
====================
----------
DATA-STRUCTURES.88
advanced
----------
PROBLEM STATEMENT:
A giant library has just been inaugurated this week. It can be modeled as a sequence of N consecutive shelves with each shelf having some number of books. Now, being the geek that you are, you thought of the following two queries which can be performed on these shelves.


Change the number of books in one of the shelves.
Obtain the number of books on the shelf having the kth rank within 
the range of shelves. 


A shelf is said to have the kth rank if its position is k when the shelves are sorted based on the number of the books they contain, in ascending order.

Can you write a program to simulate the above queries?

Input Format 
The first line contains a single integer T, denoting the number of test cases. 
The first line of each test case contains an integer N denoting the number of shelves in the library. 
The next line contains N space separated integers where the ith integer represents the number of books on the ith shelf where 1
The next line contains an integer Q denoting the number of queries to be performed. Q lines follow with each line representing a query. 
Queries can be of two types:


1 x k - Update the number of books in the xth shelf to k (1 
0 x y k - Find the number of books on the shelf between the shelves x and y 
(both inclusive) with the kth rank (1 


Output Format 
For every test case, output the results of the queries in a new line.

Constraints 
1 
1 4 
1 4 
The number of books on each shelf is always guaranteed to be between 1 and 1000.

Sample Input

2
2
1 2
2
0 1 2 1
0 1 2 2
4
4 3 2 1
4
0 1 1 1
1 1 1
0 1 1 1
0 1 4 3


Sample Output

1
2
4
1
2


Explanation  

There are two test cases :


The first test case contains only two shelves which can be represented as [1, 2]. Two queries are to be processed : 

i) The first query asks for smallest number of books between the 1st and 2nd shevles which is 1.  

ii) The second query asks for the 2nd smallest number of books between the 1st and 2nd shevles which is 2.  
The second test case contains four shelves which can be represented as [4, 3, 2, 1]. Four queries are to be processed :  

i) The first query asks for the smallest number of books in the 1st shelf which is 4.  

ii) The second query updates the number of books in the 1st shelf to 1. Hence the shelves now look like [1, 3, 2, 1].  

iii) The third query asks for the smallest number of books in the 1st shelf which is now 1.  

iv) The last query asks for the 3rd smallest number of books between the 1st and 4th shelves which is 2.

----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <fstream>
#include <set>
#include <map>
#include <cmath>
#pragma comment(linker,"/STACK:16777216")
#define MAXN 100100

using namespace std;

string s1,s2;

int n,k,a[MAXN],x,q,l,r,cnt[1001],t;

int main()
{
    cin>>t;

    while(t--){
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
            scanf("%d",&a[i]);
        scanf("%d",&q);
        for(int i=0;i<q;i++)
        {
            scanf("%d",&x);
            if(x==1){
                scanf("%d %d",&l,&k);
                a[l]=k;
            }
            else
            {
                scanf("%d %d %d",&l,&r,&k);
                for(int j=1;j<1001;j++)
                    cnt[j]=0;

                for(int i=l;i<=r;i++)
                    cnt[a[i]]++;

                for(int j=1;j<1001;j++)
                    if(cnt[j]>=k)
                    {
                        printf("%d\n",j);
                        break;
                    }
                    else
                        k-=cnt[j];
            }
        }
    }

    return 0;
}

----------
====================
----------
DATA-STRUCTURES.89
advanced
----------
PROBLEM STATEMENT:
In a galaxy far away, there is a constant battle between the republic and the droid army. The droid army decided to launch their final attack on the republic. They have N space-fighters. 

Initially the ith fighter is located at (xi, yi). All of the space-fighters move with constant velocity V units/sec in the positive X direction. 
i.e., fighter at (xi, yi) moves to (xi+V, yi) in 1 second. 
The ith space-fighter broadcasts enemy information at a frequency fi.

The republic is not scared of the artificially intelligent droid force as they have Yoda. Yoda has a special power, at any time T he can choose a region of the droid army and block one specific frequency F. This power has one constraint; it can be applied only in the form of a two sided unbounded axis parallel rectangular box open towards the both the directions across X axis (refer image below for clarity). If a frequency (F) is blocked all the space-fighters in the region having the frequency F can’t communicate.



Given the initial positions of the space-fighters, and their velocity, you are to answer queries of the following form:

YU YD T

where YU, YD are the bounds on y-axis inside which YODA can block a frequency at time T. 
In the region described by the query, after a time T seconds from the start, if Yoda can chose one frequency (F) he wishes to, what is the maximum number of communications he can block?

Input Format 
Each test case is described as follows; the first line contains 3 space separated integers N - the number of space-fighters, Q - the number of queries you have to answer, and V - the velocity of the space-fighters separated by a single space. 

N lines follow, each containing 3 space separated integers xi, yi, and fi, denoting the x co-ordinate, y co-ordinate and the frequency at which the ith ship broadcasts respectively. Each of the next Q lines contain 3 space separated integers representing YU, YD, T respectively. Refer the figure for more clarity

Note: Points on the boundaries should be counted as well.

Output Format 
For each query you are to output a single integer denoting the result.

Constraints 
1 
1 
1 
-109 i 9
-109 i 9
1 i 9
-109 9
-109 9
1 
YU = YD

Sample Input

5 5 82
-4 1 4
-3 -2 2
-3 5 1
0 -5 2
1 -1 2
1 -1 57
-2 -5 11
5 -5 40
-1 -5 16
5 -1 93


Sample Output

1
2
3
3
1


Explanation
Consider the points ships in the Y-range 1 to -1, they are the (-4, 1) and (1, -1), and both operate on different frequencies, hence the most times a frequency is repeated is once.
----------
TOP SOLUTION:
----------
#include <stdio.h>
#include <algorithm>
#include <map>
#define STEP_SIZE 5000
#define MAXN 50005
using namespace std;

int N, Q, V;
int x[MAXN], y[MAXN], F[MAXN], f[MAXN];
int fN;

map<int, int> freqCompression;

int occur[15][15][50005];
int best[15][15];
pair<int, int> fp[MAXN];

int main()
{
	scanf("%d%d%d", &N, &Q, &V);
	fN=0;
	for(int i=0; i < N; ++i){
		scanf("%d%d%d", x+i, y+i, F+i);
		if(freqCompression[F[i]] == 0)
			freqCompression[F[i]]=++fN;
		F[i]=freqCompression[F[i]]-1;
		fp[i]=make_pair(y[i], F[i]);
	}
	sort(fp, fp+N);
	for(int i=0; i < N; ++i)
		f[i]=fp[i].second;
	for(int i=0; i <= N; i += STEP_SIZE)
		for(int j=i; j <= N; j += STEP_SIZE){
			int I=i/STEP_SIZE, J=j/STEP_SIZE;
			for(int k=0; k < 50000; ++k)
				occur[I][J][k]=0;
			best[I][J]=0;
			for(int k=i; k < j; ++k){
				++occur[I][J][f[k]];
				if(occur[I][J][f[k]] > best[I][J])
					best[I][J]=occur[I][J][f[k]];
			}
		}
	for(int i=0; i < Q; ++i){
		int a, b, t;
		scanf("%d%d%d", &a, &b, &t);
		int c=lower_bound(fp, fp+N, make_pair(b, -1))-fp;
		int d=lower_bound(fp, fp+N, make_pair(a, 999999999))-fp;
		int low=c/STEP_SIZE+1, upp=d/STEP_SIZE;
		int stop=min(low*STEP_SIZE, d);
		int start=max(upp*STEP_SIZE, stop);
		if(upp<low)
			upp=low;
		int B=best[low][upp];
		for(int j=c; j < stop; ++j){
			++occur[low][upp][f[j]];
			if(occur[low][upp][f[j]] > B)
				B=occur[low][upp][f[j]];
		}
		for(int j=start; j < d; ++j){
			++occur[low][upp][f[j]];
			if(occur[low][upp][f[j]] > B)
				B=occur[low][upp][f[j]];
		}
		printf("%d\n", B);
		for(int j=c; j < stop; ++j){
			--occur[low][upp][f[j]];
		}
		for(int j=start; j < d; ++j){
			--occur[low][upp][f[j]];
		}
	}
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.90
expert
----------
PROBLEM STATEMENT:
A Sumo wrestling championship is scheduled to be held this winter in the HackerCity where N wrestlers from different parts of the world are going to participate. The rules state that two wrestlers can fight against each other if and only if the difference in their height is less than or equal to K, 
(i.e) wrestler A and wrestler B can fight if and only if |height(A)-height(B)|.  



Given an array H[], where H[i] represents the height of the ith fighter, for a given l, r where 0 , can you count the number of pairs of fighters between l and r (both inclusive) who qualify to play a game?

Input Format 
The first line contains an integer N and K  separated by a single space representing the number of Sumo wrestlers who are going to participate and the height difference K. 
The second line contains N integers separated by a single space, representing their heights H[0] H[1] ... H[N - 1]. 
The third line contains Q, the number of queries. This is followed by Q lines each having two integers l and r separated by a space.  

Output Format 
For each query Q, output the corresponding value of the number of pairs of fighters for whom the absolute difference of height is not greater that K.  

Constraints 
1 
0 9 
0 9 
1 
0 

Sample Input

5 2
1 3 4 3 0
3
0 1
1 3
0 4


Sample Output  

1
3
6


Explanation 
Query #0: Between 0 and 1 we have i,j as (0,1) and |H[0]-H[1]|=2 therefore output is 1. 
Query #1: The pairs (H[1],H[2]) (H[1],H[3]) and (H[2],H[3]) are the pairs such that |H[i]-H[j]| 
Query #2: Apart from those in Query #1, we have (H[0],H[1]), (H[0], H[3]), (H[0], H[4]), hence 6.  

Timelimits

Timelimits are given here
----------
TOP SOLUTION:
----------
#include <iostream>
#include <algorithm>
#include <complex>
#include <cmath>
#include <cstring>

using namespace std;


#include <cstdio>
#include <iostream>
using std::string;

static struct IO {
	char tmp[1 << 10];

	// fast input routines
	char cur;

//#define nextChar() (cur = getc_unlocked(stdin))
//#define peekChar() (cur)
	inline char nextChar() { return cur = getc_unlocked(stdin); }
	inline char peekChar() { return cur; }

	inline operator bool() { return peekChar(); }
	inline static bool isBlank(char c) { return (c < '-' && c); }
	inline bool skipBlanks() { while (isBlank(nextChar())); return peekChar() != 0; }

	inline IO& operator >> (char & c) { c = nextChar(); return *this; }

	inline IO& operator >> (char * buf) {
		if (skipBlanks()) {
			if (peekChar()) {
				*(buf++) = peekChar();
				while (!isBlank(nextChar())) *(buf++) = peekChar();
			} *(buf++) = 0; } return *this; }

	inline IO& operator >> (string & s) {
		if (skipBlanks()) {	s.clear(); s += peekChar();
			while (!isBlank(nextChar())) s += peekChar(); }
		return *this; }

	inline IO& operator >> (double & d) { if ((*this) >> tmp) sscanf(tmp, "%lf", &d); return *this;	}

#define defineInFor(intType) \
	inline IO& operator >>(intType & n) { \
		if (skipBlanks()) { \
			int sign = +1; \
			if (peekChar() == '-') { \
				sign = -1; \
				n = nextChar() - '0'; \
			} else \
				n = peekChar() - '0'; \
			while (!isBlank(nextChar())) { \
				n += n + (n << 3) + peekChar() - 48; \
			} \
			n *= sign; \
		} \
		return *this; \
	}

defineInFor(int)
defineInFor(unsigned int)
defineInFor(long long)

	// fast output routines

//#define putChar(c) putc_unlocked((c), stdout)
	inline void putChar(char c) { putc_unlocked(c, stdout); }
	inline IO& operator << (char c) { putChar(c); return *this; }
	inline IO& operator << (const char * s) { while (*s) putChar(*s++); return *this; }

	inline IO& operator << (const string & s) { for (int i = 0; i < (int)s.size(); ++i) putChar(s[i]); return *this; }

	char * toString(double d) { sprintf(tmp, "%lf%c", d, '\0'); return tmp; }
	inline IO& operator << (double d) { return (*this) << toString(d); }


#define defineOutFor(intType) \
	inline char * toString(intType n) { \
		char * p = (tmp + 30); \
		if (n) { \
			bool isNeg = 0; \
			if (n < 0) isNeg = 1, n = -n; \
			while (n) \
				*--p = (n % 10) + '0', n /= 10; \
			if (isNeg) *--p = '-'; \
		} else *--p = '0'; \
		return p; \
	} \
	inline IO& operator << (intType n) { return (*this) << toString(n); }

defineOutFor(int)
defineOutFor(long long)

#define endl ('\n')
#define cout __io__
#define cin __io__
} __io__;


const int
	MAXQ = 1 << 17,
	MAXN = 1 << 17;

int N, K, Q;
int vals[MAXN];

int valsId[MAXN];
int valsHi[MAXN];
int valsLo[MAXN];

int C;
int coords[3 * MAXN];

int S;

long long answer[MAXQ];

struct query
{
	int lo, hi, id;
};

int value[MAXQ];
int order[MAXQ];

bool queryCmp(const int a, const int b)
{
	return value[a] < value[b];
}

query queries[MAXQ];


int T[3 * MAXN];

inline void updatePlus(register int x)
{
	for (++x; x <= C; x += (x & -x))
		++T[x];
}

inline void updateMinus(register int x)
{
	for (++x; x <= C; x += (x & -x))
		--T[x];
}

inline int querySum(register int x)
{
	int sum = 0;
	for (++x; x > 0; x -= (x & -x))
	{
		sum += T[x];
	}
	return sum;
}

inline int querySum(int lo, int hi)
{
	return querySum(hi) - querySum(lo - 1);
}

inline int queryElem(int pos)
{
	return querySum(valsLo[pos], valsHi[pos]);
}

long long answerSum;

inline void promote(int pos)
{
	//cerr << "promote " << pos << endl;
	answerSum += queryElem(pos);
	updatePlus(valsId[pos]);
}

inline void demote(int pos)
{
	//cerr << "demote " << pos << endl;
	updateMinus(valsId[pos]);
	answerSum -= queryElem(pos);
}

int main()
{
	ios::sync_with_stdio(false);

	cin >> N >> K;
	for (int i = 0; i < N; ++i)
	{
		cin >> vals[i];
		coords[C++] = vals[i];
	}

	// sentinels
	coords[C++] = -1 - K;
	coords[C++] = (int)1e9 + 1 + K;

	sort(coords, coords + C);

	//radixSort(coords, C);

	C = unique(coords, coords + C) - coords;

	for (int i = 0; i < N; ++i)
	{
		valsHi[i] = upper_bound(coords, coords + C, vals[i] + K) - coords - 1;//upper_bound(coords, coords + C, vals[i] + K) - coords - 1;
		valsLo[i] = lower_bound(coords, coords + valsHi[i] + 1, vals[i] - K) - coords;
		valsId[i] = lower_bound(coords + valsLo[i], coords + valsHi[i] + 1, vals[i]) - coords;
	}


	S = max(10, (int)sqrt(N));

	cin >> Q;
	for (int i = 0; i < Q; ++i)
	{
		int lo, hi;
		cin >> lo >> hi;
		queries[i] = (query){lo, hi, i};

		order[i] = i;

		value[i] = (lo / S + 1) * (100001) + hi;
	}

	sort(order, order + Q, queryCmp);

	register int lo = queries[ order[0] ].lo;
	register int hi = lo - 1;

	for (int __i = 0; __i < Q; ++__i)
	{
		int i = order[__i];
		//cerr << queries[i].lo << " " << queries[i].hi << endl;

		while (lo < queries[i].lo)
		{
			// remove values[lo]
			demote(lo);
			lo++;
		}

		while (lo > queries[i].lo)
		{
			--lo;
			// add values[lo]
			promote(lo);
		}

		while (hi > queries[i].hi)
		{
			// remove values[hi]
			demote(hi);
			hi--;
		}

		while (hi < queries[i].hi)
		{
			hi++;
			promote(hi);
		}

		answer[ queries[i].id ] = answerSum;
	}

	for (int i = 0; i < Q; ++i)
		cout << answer[i] << endl;

	return 0;
}
----------
====================
----------
DATA-STRUCTURES.91
expert
----------
PROBLEM STATEMENT:
Shik loves sorted intervals. But currently he does not have enough time to sort all the numbers. So he decided to use Almost sorted intervals. An Almost sorted interval is a consecutive subsequence in a sequence which satisfies the following property:


The first number is the smallest.
The last number is the largest.


Please help him count the number of almost sorted intervals in this permutation.  

Note: Two intervals are different if at least one of the starting or ending indices are different.

Input Format 
The first line contains an integer N. 
The second line contains a permutation from 1 to N.

Output Format 
Output the number of almost sorted intervals.  

Constraints 
1 ≤ N ≤ 106  

Sample Input  

5
3 1 2 5 4


Sample Output  

8


Explanation 
The subsequences [3], [1], [1 2], [1 2 5], [2], [2 5], [5], [4] are almost sorted intervals.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
typedef long long LL;
using namespace std;
const int SIZE = 1e6 + 5;
int a[SIZE];
int qq[SIZE],qn,rt[SIZE],lt[SIZE];
int BIT[SIZE];
void ins(int x,int v){
    x++;
    while(x<SIZE){
        BIT[x]+=v;
        x+=x&-x;
    }
}
int query(int x){
    x++;
    int res=0;
    while(x){
        res+=BIT[x];
        x-=x&-x;
    }
    return res;
}
int main(){
    DRI(N);
    REP(i,N){
        RI(a[i]);
    }
    REP(i,N){
        while(qn&&a[i]<a[qq[qn-1]]){
            rt[qq[qn-1]]=i-1;
            qn--;
        }
        qq[qn++]=i;
    }
    while(qn>0){
        rt[qq[qn-1]]=N-1;
        qn--;
    }
    qn=0;
    for(int i=N-1;i>=0;i--){
        while(qn&&a[i]>a[qq[qn-1]]){
            lt[qq[qn-1]]=i+1;
            qn--;
        }
        qq[qn++]=i;
    }
    while(qn>0){
        lt[qq[qn-1]]=0;
        qn--;
    }
    long long an=0;
    set<pair<int,int> >H;
    for(int i=N-1;i>=0;i--){
        an++;
        while(SZ(H)&&H.rbegin()->F>i){
            ins(H.rbegin()->S,-1);
            set<pair<int,int> >::iterator it = H.end();
            it--;
            H.erase(it);
        }
        an+=query(rt[i]);
        ins(i,1);
        H.insert(MP(lt[i],i));
    }
    cout<<an<<endl;
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.92
hard
----------
PROBLEM STATEMENT:
In Burger Town new burger restaurants will be opened! Concretely, [expression] coordinate.

Tim has just recently arrived the town after a very bad result in a programming contest. Thus he wants to cheer himself up by starting a trip to try out some new burgers. 

Every burger restaurant [expression], since Tim gets sad by only seeing the burgers. 

Tim's journey can start from any day [expression], Tim has the following options:


Stay at the previous restaurant [expression]. 
Or go to the new restaurant [expression] to eat a burger from there.


If he decides for the latter option, then on the path from [expression].

Since Tim is a very good friend of yours you should help him finding a trip that will maximize his happiness. If he should stay at home since no trip would cheer him up, then print 0. 

Note: Tim's happiness is 0 at the beginning of the trip and is allowed to be negative throughout the time. 

Input Format

[expression] separated by a single space.

Output Format

Output the maximium happiness on one line.

Constraints  


[expression]
[expression]
[expression]
[expression] coordinates.


Sample Input

 3
 2 -5 1
 1 5 1
 3 5 1


Sample Output

8


Sample Input

 4
 4 10 0
 1 -5 0
 3 0 10
 2 10 0


Sample Output

 15


Sample Input

 3
 1 -1 0
 2 -2 0
 3 -3 0


Sample Output

 0


First testcase: His trip starts on day 2 at restaurant 2 located at [expression] 8 and this is optimal.

Second testcase: His trip starts on day 1 at restaurant 1. Then his actions on day 2, 3 and 4 will be go to restaurant 2, stay at restaurant 2 and go to restaurant 4 respectively. The happiness of this optimal trip is equal to [expression] 15.

Third testcase: It's not worth to start the trip from any of the restaurant since he will only have negative happiness. That's why he should stay at home and 0 should be printed. 
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
typedef long long LL;
using namespace std;
const int MOD = 1e9+7;
const int SIZE = 1e5+2;
LL BIT[SIZE];
const LL INF = 1e18;
void ins(LL bit[],int x,LL v){
    for(;x<SIZE;x+=x&-x)bit[x]+=v;
}
LL qq(LL bit[],int x){
    LL res=0;
    for(;x;x-=x&-x)res+=bit[x];
    return res;
}
int X[SIZE],A[SIZE],B[SIZE],xx[SIZE];
struct SegTree{
    LL ma[SIZE<<2],pp[SIZE<<2];
    int N,ll,rr;
    LL v;
    void _init(int L,int R,int id){
        ma[id]=-INF;
        pp[id]=0;
        if(L==R)return;
        int mm=(L+R)>>1;
        _init(L,mm,id<<1);
        _init(mm+1,R,(id<<1)|1);
    }
    void init(int _N){
        N=_N;
        _init(0,N-1,1);
    }
    void push(int id){
        ma[id<<1]+=pp[id];
        ma[(id<<1)|1]+=pp[id];
        pp[id<<1]+=pp[id];
        pp[(id<<1)|1]+=pp[id];
        pp[id]=0;
    }
    void _ins(int L,int R,int id){
        if(R<ll||L>rr)return;
        if(L>=ll&&R<=rr){
            ma[id]+=v;
            pp[id]+=v;
            return;
        }
        int mm=(L+R)>>1;
        if(pp[id])push(id);
        _ins(L,mm,id<<1);
        _ins(mm+1,R,(id<<1)|1);
        ma[id]=max(ma[id<<1],ma[(id<<1)|1]);
    }
    void ins(int L,int R,LL V){
        ll=L;
        rr=R;
        v=V;
        _ins(1,N,1);
    }
    LL _qq(int L,int R,int id){
        if(R<ll||L>rr)return -INF;
        if(L>=ll&&R<=rr)return ma[id];
        int mm=(L+R)>>1;
        if(pp[id])push(id);
        LL res=max(_qq(L,mm,id<<1),_qq(mm+1,R,(id<<1)|1));
        ma[id]=max(ma[id<<1],ma[(id<<1)|1]);
        return res;
    }
    LL qq(int L,int R){
        ll=L;
        rr=R;
        return _qq(1,N,1);
    }
}le,ri;
int main(){
    DRI(N);
    REP(i,N){
        RIII(X[i],A[i],B[i]);
        xx[i]=X[i];
    }
    sort(xx,xx+N);
    REP(i,N){
        X[i]=lower_bound(xx,xx+N,X[i])-xx+1;
    }
    LL an=0;
    LL all=0;
    le.init(N);
    ri.init(N);
    REP(i,N){
        LL now=qq(BIT,X[i]);
        LL res=le.qq(1,X[i]-1)-now;
        res=max(res,ri.qq(X[i]+1,N)-(all-now));
        res=max(res,0LL)+A[i];
        an=max(an,res);
        all+=B[i];
        if(X[i]<N)le.ins(X[i]+1,N,B[i]);
        if(X[i]>1)ri.ins(1,X[i]-1,B[i]);
        le.ins(X[i],X[i],res+INF);
        ri.ins(X[i],X[i],res+INF);
        ins(BIT,X[i],B[i]);
    }
    cout<<an<<endl;
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.93
hard
----------
PROBLEM STATEMENT:
Roy has taken a liking to the Binary Search Trees(BST). He is interested in knowing the number of ways an array [expression] integers can be arranged to form a BST. Thus, he tries a few combinations, and notes down the numbers at the odd levels and the numbers at the even levels. 

You're given two values, alpha and beta. Can you calculate the sum of Liking of all possible BST's that can be formed from an array of [expression] integers? Liking of each BST is defined as follows 

(sum of numbers on even levels * alpha) - (sum of numbers on odd levels * beta)


Note 


The root element is at level [expression] ( Even )
The elements smaller or equal to the parent element are present in the left subtree, elements greater than or equal to the parent element are present in the right subtree.  Explained here


If the answer is no less than [expression]. 

(If the answer is less than [expression] until the value turns non negative.)

Input Format 
The first line of input file contains an integer, [expression], denoting the number of test cases to follow. 
Each testcase comprises of [expression] lines. 
The first line contains [expression], the number of integers. 
The second line contains two space separated integers, alpha and beta. 
The third line contains space separated [expression].  

Output Format 
Output [expression] lines. Each line contains the answer to its respective test case. 

Constraints  

[expression] 
[expression] 
[expression] 
[expression]  

Sample Input

4
1
1 1
1
2
1 1
1 2
3
1 1
1 2 3
5
1 1
1 2 3 4 5


Sample Output

1
0
6
54


Explanation

There are [expression] test cases in total. 


For the first test case, only [expression]. 
For the second test case, we get 2 BSTs of the form, the Liking of the first tree is [expression], hence the answer. 


1                  2 
 \                /
  2              1



For the third test case, we get [expression] and hence the answer.  


1            2                 3          3      1
 \          / \               /          /        \
  2        1   3             1          2          3
   \                          \        /          /
    3                          2      1          2



Similarly, for the fourth test case, the answer is [expression].  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
 
using namespace std;


long long mod = 1000000009;

struct data {
    long long ways;
    long long sum[2];

    data operator+(const data & r) const {
        data res;
        res.ways = (ways + r.ways) % mod;
        res.sum[0] = (sum[0] + r.sum[0]) % mod;
        res.sum[1] = (sum[1] + r.sum[1]) % mod;
        return res;
    }
};

data merge(const data & l, const data & r) {
    data res;
    res.sum[0] = (l.sum[0] * r.ways + r.sum[0] * l.ways) % mod;
    res.sum[1] = (l.sum[1] * r.ways + r.sum[1] * l.ways) % mod;
    res.ways = (l.ways * r.ways) % mod;
    return res;
}

data dp[200][200];


long long a[200];

data & solve(int l, int r) {
    if (dp[l][r].ways) {
        return dp[l][r];
    }

    data & res = dp[l][r];

    if (l == r) {
        res.ways = 1;
        return res;
    }

    for (int i = l; i < r; ++i) {
        /*int j = i;
        while (j < r && a[i] == a[j]) {
            ++j;
        }*/
        //i = j - 1;
        data tmp = merge(solve(l, i), solve(i + 1, r));
        swap(tmp.sum[0], tmp.sum[1]);
        tmp.sum[0] = (tmp.sum[0] + tmp.ways * a[i]);
        res = res + tmp;
    }
    return res;
}

int main() {
 
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
#else
    //freopen("2strings.in", "r", stdin);
    //freopen("2strings.out", "w", stdout);
#endif
    int t;

    scanf("%d", &t);

    while (t--) {
        int n;
        scanf("%d", &n);
        for (int i = 0; i <= n; ++i) {
            for (int j = 0; j <= n; ++j) {
                dp[i][j].ways = dp[i][j].sum[0] = dp[i][j].sum[1] = 0;
            }
        }
        long long alpha, beta;
        scanf("%lld%lld", &alpha, &beta);

        for (int i = 0; i < n; ++i) {
            scanf("%lld", a + i);
        }
        sort(a, a + n);

        data & ans = solve(0, n);
        long long v = ans.sum[0] * alpha - ans.sum[1] * beta;
        v %= mod;
        if (v < 0) {
            v += mod;
        }
        printf("%lld\n", v);
    }
    

    return 0;
}
----------
====================
----------
DATA-STRUCTURES.94
hard
----------
PROBLEM STATEMENT:
You are given a tree with N nodes with every node being colored. A color is represented by an integer ranging from 1 to 109. Can you find the number of distinct colors available in a subtree rooted at the node s? 

Input Format 
The first line contains three space separated integers representing the number of nodes in the tree (N), number of queries to answer (M) and the root of the tree. 

In each of the next N-1 lines, there are two space separated integers(a b) representing an edge from node a to Node b and vice-versa.   

N lines follow: N+ith line contains the color of the ith node.

M lines follow: Each line containg a single integer s.

Output Format 
Output exactly M lines, each line containing the output of the ith query.

Constraints 
0 5
1 5
1 
1 9

Example

Sample Input

4 2 1
1 2
2 4
2 3
10
20
20
30
1
2


Sample Output

3
2


Explanation

Query 1-Subtree rooted at 1 is the entire tree and colors used are 10 20 20 30 , so the answer is 3(10,20 and 30)

Query 2-Subtree rooted at 2 contains color 20 20 30, so the answer is 2(20 and 30)
----------
TOP SOLUTION:
----------
/*
Author:    Harhro94 [Harutyunyan Hrayr]
*/
#pragma comment(linker, "/STACK:66777216")
#define _CRT_SECURE_NO_WARNINGS
#include <functional>
#include <algorithm>
#include <iostream>
#include <sstream>
#include <fstream>
#include <cassert>
#include <iomanip>
#include <cstring>
#include <cstdio>
#include <string>
#include <vector>
#include <ctime>
#include <queue>
#include <stack>
#include <cmath>
#include <set>
#include <map>
using namespace std;

typedef long long LL;
typedef long double LD;
#define pb push_back
#define mp make_pair
#define all(v) (v).begin(), (v).end()
#define sz(v) (int)(v).size()

const int N = 100007;
int n, m, r, c[N], ans[N];
vector<int> G[N], Q[N];

set<int>* merge(set<int> *A, set<int> *B)
{
    if (A->size() > B->size()) swap(A, B);
    for (int i : *A) B->insert(i);
    delete A;
    return B;
}

set<int>* dfs(int u, int p = -1)
{
    set<int> *S = new set<int>();
    S->insert(c[u]);
    for (int to : G[u])
    {
        if (to == p) continue;
        S = merge(S, dfs(to, u));
    }
    for (int id : Q[u])
        ans[id] = S->size();
    return S;
}

int main()
{
#ifdef harhro94
    freopen("input.txt", "r", stdin);
    //freopen("output.txt", "w", stdout);
#else
    //freopen(task".in", "r", stdin);
    //freopen(task".out", "w", stdout);
#endif

    scanf("%d%d%d", &n, &m, &r);
    for (int i = 1; i < n; ++i)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        G[u].pb(v);
        G[v].pb(u);
    }
    for (int i = 1; i <= n; ++i) scanf("%d", &c[i]);
    for (int i = 0; i < m; ++i)
    {
        int u;
        scanf("%d", &u);
        Q[u].pb(i);
    }
    dfs(r);
    for (int i = 0; i < m; ++i) printf("%d\n", ans[i]);

#ifdef harhro94
    cerr << fixed << setprecision(3) << "\nExecution time = " << clock() / 1000.0 << "s\n";
#endif
    return 0;
}
----------
====================
----------
DATA-STRUCTURES.95
hard
----------
PROBLEM STATEMENT:
Chinese Version
Russian Version

You are given a tree with N nodes and each has a value associated with it. You are given Q queries, each of which is either an update or a retrieval operation. 

The update query is of the format

i j X


This means you'd have to add a GP series to the nodes which lie in the path from node i to node j (both inclusive) with first term of the GP as X on node i and the common ratio as R (given in the input)

The retrieval query is of the format

i j

You need to return the sum of the node values (S) lying in the path from node i to node j modulo 100711433. 

Input Format 
The first line contains two integers (N and R respectively) separated by a space. 
In the next N-1 lines, the ith line describes the ith edge: a line with two integers a b separated by a single space denotes an edge between a, b. 
The next line contains 2 space separated integers (U and Q respectively) representing the number of Update and Query operations to follow. 
U lines follow. Each of the next U lines contains 3 space separated integers (i,j, and X respectively). 
Each of the next Q lines contains 2 space separated integers, i and j respectively. 

Output Format 
It contains exactly Q lines and each line containing the answer of the ith query.

Constraints

2 
2 9 
1 
1 
1 
1 

Sample Input  

6 2
1 2
1 4
2 6
4 5
4 3
2 2
1 6 3
5 3 5
6 4
5 1


Sample Output

31
18


Explanation

The node values after the first updation becomes :  

3 6 0 0 0 12  


The node values after second updation becomes :  

3 6 20 10 5 12  


Answer to Query #1: 12 + 6 + 3 + 10 = 31 
Answer to Query #2: 5 + 10 +3 = 18  
----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <list>
#include <cassert>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
#define EPS 1e-9
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(x > y) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

struct CentroidPathDecomposition {
	vector<int> colors, positions;	//Vertex -> Color, Vertex -> Offset
	vector<int> lengths, parents, branches;	//Color -> Int, Color -> Color, Color -> Offset
	vector<int> parentnodes, depths;	//Vertex -> Vertex, Vertex -> Int
	//vector<...>????1???????????????sortNodes()??????
	vector<int> sortednodes, offsets;	//Index -> Vertex, Color -> Index

	//???????????????????????????(???)
	void build(const vector<vi> &g, int root) {
		int n = g.size();

		colors.assign(n, -1); positions.assign(n, -1);
		lengths.clear(); parents.clear(); branches.clear();
		parentnodes.assign(n, -1); depths.assign(n, -1);

		vector<int> subtreesizes;
		measure(g, root, subtreesizes);

		struct State {
			int i, len, parent;
			State() { }
			State(int i_, int l, int p): i(i_), len(l), parent(p) { }
		};
		depths[root] = 0;
		vector<State> s;
		s.push_back(State(root, 0, -1));
		while(!s.empty()) {
			State t = s.back(); s.pop_back();
			int i = t.i, len = t.len;
			int color = lengths.size();
			if(t.parent != -2) {
				assert(parents.size() == color);
				parents.push_back(t.parent);
				branches.push_back(len);
				len = 0;
			}
			colors[i] = color;
			positions[i] = len;

			int maxsize = -1, maxj = -1;
			each(j, g[i]) if(colors[*j] == -1) {
				if(maxsize < subtreesizes[*j]) {
					maxsize = subtreesizes[*j];
					maxj = *j;
				}
				parentnodes[*j] = i;
				depths[*j] = depths[i] + 1;
			}
			if(maxj == -1) {
				lengths.push_back(len + 1);
			}else {
				each(j, g[i]) if(colors[*j] == -1 && *j != maxj)
					s.push_back(State(*j, len, color));
				s.push_back(State(maxj, len + 1, -2));
			}
		}

		sortNodes();
	}

	void sortNodes() {
		int n = colors.size(), m = lengths.size();
		sortednodes.resize(n, -1);
		offsets.resize(m + 1);
		rep(i, m) offsets[i+1] = offsets[i] + lengths[i];
		rep(i, n) sortednodes[offsets[colors[i]] + positions[i]] = i;
	}

	void get(int v, int &c, int &p) const {
		c = colors[v]; p = positions[v];
	}
	bool go_up(int &c, int &p) const {
		p = branches[c]; c = parents[c];
		return c != -1;
	}

	inline const int *nodesBegin(int c) const { return &sortednodes[0] + offsets[c]; }
	inline const int *nodesEnd(int c) const { return &sortednodes[0] + offsets[c+1]; }

private:
	void measure(const vector<vi> &g, int root, vector<int> &out_subtreesizes) const {
		out_subtreesizes.assign(g.size(), -1);
		vector<int> s;
		s.push_back(root);
		while(!s.empty()) {
			int i = s.back(); s.pop_back();
			if(out_subtreesizes[i] == -2) {
				int s = 1;
				each(j, g[i]) if(out_subtreesizes[*j] != -2)
					s += out_subtreesizes[*j];
				out_subtreesizes[i] = s;
			}else {
				s.push_back(i);
				each(j, g[i]) if(out_subtreesizes[*j] == -1)
					s.push_back(*j);
				out_subtreesizes[i] = -2;
			}
		}
	}
};


typedef int Vertex;
struct Graph {
	typedef std::pair<Vertex, Vertex> Edge;
	struct To {
		Vertex to;
	};

	int n, m;

	Graph(int n_, const std::vector<Edge> &edges):
		n(n_), m(edges.size()), tos(m+1), offsets(n+1, 0) {
		for(int e = 0; e < m; e ++) offsets[edges[e].first] ++;
		for(int v = 1; v <= n; v ++) offsets[v] += offsets[v-1];
		for(int e = 0; e < m; e ++)
			tos[-- offsets[edges[e].first]].to = edges[e].second;
	}

	inline const To *edgesBegin(int v) const { return &tos[offsets[v]]; }
	inline const To *edgesEnd(int v) const { return &tos[offsets[v+1]]; }

	inline const int outDegree(int v) const { return offsets[v+1] - offsets[v]; }

private:
	std::vector<To> tos;
	std::vector<int> offsets;
};
	
class SchieberVishkinLCA {
public:
	typedef unsigned Word;
private:

	static inline Word lowestOneBit(Word v) {
		return v & (~v+1);
	}
	static inline Word highestOneBitMask(Word v) {
		v |= v >> 1;
		v |= v >> 2;
		v |= v >> 4;
		v |= v >> 8;
		v |= v >> 16;
		return v >> 1;
	}

	std::vector<Word> indices;			//Vertex -> index
	std::vector<Word> maxHIndices;		//Vertex -> index
	std::vector<Word> ancestorHeights;	//Vertex -> Word
	std::vector<Vertex> pathParents;	//index-1 -> Vertex
public:
	//g?????????????
	void build(const Graph &g, Vertex root) {
		assert(g.m == g.n - 1);

		ancestorHeights.resize(g.n);
		std::vector<Vertex> parents(g.n);
		maxHIndices.resize(g.n);
		std::vector<Vertex> vertices; vertices.reserve(g.n);
		indices.resize(g.n);

		//euler tour
		Word currentIndex = 1;
		parents[root] = root;	//???????
		vertices.push_back(root);
		while(!vertices.empty()) {
			Vertex v = vertices.back(); vertices.pop_back();
			indices[v] = currentIndex ++;
			for(const Graph::To *it = g.edgesBegin(v); it != g.edgesEnd(v); ++ it) {
				parents[it->to] = v;
				vertices.push_back(it->to);
			}
		}

		//BFS (???????????????)
		int head = 0, tail = 1;
		vertices.resize(g.n); vertices[0] = root;
		while(head != tail) {
			Vertex v = vertices[head ++];
			for(const Graph::To *it = g.edgesBegin(v); it != g.edgesEnd(v); ++ it)
				vertices[tail ++] = it->to;
		}

		//?????
		for(std::vector<Vertex>::const_iterator it = vertices.begin(); it != vertices.end(); ++ it)
			maxHIndices[*it] = indices[*it];
		for(std::vector<Vertex>::const_reverse_iterator it = vertices.rbegin(); it != vertices.rend(); ++ it) {
			Vertex v = *it, parent = parents[v];
			if(lowestOneBit(maxHIndices[parent]) < lowestOneBit(maxHIndices[v]))
				maxHIndices[parent] = maxHIndices[v];
		}

		//A????
		ancestorHeights[root] = 0;
		for(std::vector<Vertex>::const_iterator it = vertices.begin(); it != vertices.end(); ++ it) {
			Vertex v = *it;
			ancestorHeights[v] = ancestorHeights[parents[v]] | lowestOneBit(maxHIndices[v]);
		}

		pathParents.swap(parents);	//???????
		pathParents[indices[root]-1] = root;
		for(std::vector<Vertex>::const_iterator it = vertices.begin(); it != vertices.end(); ++ it) {
			Vertex v = *it;
			for(const Graph::To *jt = g.edgesBegin(v); jt != g.edgesEnd(v); ++ jt) {
				if(maxHIndices[v] != maxHIndices[jt->to])
					pathParents[indices[jt->to]-1] = v;
				else
					pathParents[indices[jt->to]-1] = pathParents[indices[v]-1];
			}
		}
	}

	Vertex query(Vertex v, Vertex u) const {
		//binary tree???LCA???????
		Word Iv = maxHIndices[v], Iu = maxHIndices[u];
		Word hIv = lowestOneBit(Iv), hIu = lowestOneBit(Iu);
		Word hbMask = highestOneBitMask((Iv ^ Iu) | hIv | hIu);
		Word j = lowestOneBit(ancestorHeights[v] & ancestorHeights[u] & ~hbMask);
		//j = hI(lca(v,u)) ??? (????hI(x) = 2^(complete binary tree???I(x)???), I(x) = maxHIndices[x])
		//(hI(lca(v,u)) = j)?hI(v)?hI(u)????????????????????????…
		Vertex x, y;
		if(j == hIv) x = v;
		else {			//lca?v????????
			Word kMask = highestOneBitMask(ancestorHeights[v] & (j-1));	//v?????j???????????????????
			x = pathParents[(indices[v] & ~kMask | (kMask+1))-1];	//indices[v]?k???????????
		}
		if(j == hIu) y = u;
		else {			//lca?u????????
			Word kMask = highestOneBitMask(ancestorHeights[u] & (j-1));	//u?????j???????????????????
			y = pathParents[(indices[u] & ~kMask | (kMask+1))-1];	//indices[u]?k???????????
		}
		return indices[x] < indices[y] ? x : y;	//in-order????????????????????
	}
};

void direct_tree(const vector<vi> &g, int i, int parent, vector<pii> &out_edges) {
	each(j, g[i]) if(*j != parent) {
		out_edges.pb(mp(i, *j));
		direct_tree(g, *j, i, out_edges);
	}
}


template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	int x;
	ModInt(): x(0) { }
	ModInt(signed sig) { if((x = sig % MOD + MOD) >= MOD) x -= MOD; }
	ModInt(signed long long sig) { if((x = sig % MOD + MOD) >= MOD) x -= MOD; }
	int get() const { return x; }
	
	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }
	
	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
	
	ModInt inverse() const {
		long long a = x, b = MOD, u = 1, v = 0;
		while(b) {
			long long t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		return ModInt(u);
	}
	
	bool operator==(ModInt that) const { return x == that.x; }
	bool operator!=(ModInt that) const { return x != that.x; }
	ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }
};
typedef ModInt<100711433> mint;

mint powR[100001], powinvR[100001];
mint up[100001], down[100001];
mint sum[100001];
int main() {
	int N, R, invR, U, Q;
	scanf("%d%d", &N, &R);
	invR = mint(R).inverse().get();
	powR[0] = powinvR[0] = 1;
	reu(i, 1, N+1) powR[i] = powR[i-1] * R;
	reu(i, 1, N+1) powinvR[i] = powinvR[i-1] * invR;
	vector<vi> g(N);
	rep(i, N-1) {
		int a, b;
		scanf("%d%d", &a, &b); a --, b --;
		g[a].pb(b); g[b].pb(a);
	}
	vector<pii> edges;
	direct_tree(g, 0, -1, edges);
	CentroidPathDecomposition cpd; cpd.build(g, 0);
	SchieberVishkinLCA lca; lca.build(Graph(N, edges), 0);

	mset(up, 0); mset(down, 0);
	scanf("%d%d", &U, &Q);
	rep(ii, U) {
		int a, b, X;
		scanf("%d%d%d", &a, &b, &X); a --, b --;
		int l = lca.query(a, b);
		int c, p, lc, lp;
		cpd.get(l, lc, lp);
		mint x = X;
		cpd.get(a, c, p);
		while(1) {
			int k = cpd.offsets[c], kp = k + p, k0 = k + (c == lc ? lp : 0);
			up[k + p] += x;
			x *= powR[kp - k0 + 1];
			if(k0) up[k0 - 1] -= x;
			if(c == lc) break;
			cpd.go_up(c, p);
		}
		int len = cpd.depths[a] + cpd.depths[b] - cpd.depths[l] * 2;
		x = powR[len] * X;
		cpd.get(b, c, p);
		while(1) {
			int k = cpd.offsets[c], kp = k + p, k0 = k + (c == lc ? lp + 1 : 0);
			int h = kp - k0 + 1;
			mint nx = x * powinvR[h];
			down[k0] += nx * R;
			down[kp + 1] -= x * R;
			if(c == lc) break;
			x = nx;
			cpd.go_up(c, p);
		}
	}

	for(int i = N-1; i > 0; i --) up[i-1] += up[i] * R;
	for(int i = 0;   i < N; i ++) down[i+1] += down[i] * R;
	sum[0] = 0;
	rep(i, N) sum[i+1] = sum[i] + up[i] + down[i];
	rep(ii, Q) {
		int a, b;
		scanf("%d%d", &a, &b); a --, b --;
		int l = lca.query(a, b);
		int c, p, lc, lp;
		cpd.get(l, lc, lp);
		cpd.get(a, c, p);
		mint ans = 0;
		while(1) {
			int k = cpd.offsets[c], kp = k + p, k0 = k + (c == lc ? lp : 0);
			ans += sum[kp+1] - sum[k0];
			if(c == lc) break;
			cpd.go_up(c, p);
		}
		cpd.get(b, c, p);
		while(1) {
			int k = cpd.offsets[c], kp = k + p, k0 = k + (c == lc ? lp + 1 : 0);
			ans += sum[kp+1] - sum[k0];
			if(c == lc) break;
			cpd.go_up(c, p);
		}
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.96
advanced
----------
PROBLEM STATEMENT:
You are given a sequence [expression]. The task is to perform the following queries on it:

Type 1. Given two integers [expression]. Reorder the elements of the sequence in such a way (changed part of the sequence is in brackets):
[expression]
That is swap the first two elements of segment [expression], the second two elements, and so on.

Type 2. Given two integers [expression].

Input Format  

The first line contains two integers [expression], denoting initial sequence.

Each of the next [expression] will be even.  

Constraints 
[expression] 
[expression] 
[expression] 
[expression] 
[expression]

Output Format

For each query of the second type print the required sum.

Sample Input

6 4
1 2 3 4 5 6
1 2 5
2 2 3
2 3 4
2 4 5


Example Output

5
7
9


Explanation

After the first query the sequence becomes [1, 3, 2, 5, 4, 6]. 
----------
TOP SOLUTION:
----------
#include <cstdio>

#define MX 210000
typedef long long LL;
struct Data {
	int f, l, r, sz, v;
	LL val;
	void set(int _f, int _l, int _r, int _sz, int _v, LL _val) {
		f = _f, l = _l, r = _r, sz = _sz, v = _v, val = _val; 
	}
	void clear() {
		f = l = r = 0;
		val = sz = 0;	
	}
} t[MX];
int S, T;

inline void upd(int x) {
	t[x].sz = 1, t[x].val = t[x].v;
	if (t[x].l) t[x].sz += t[t[x].l].sz, t[x].val += t[t[x].l].val;
	if (t[x].r) t[x].sz += t[t[x].r].sz, t[x].val += t[t[x].r].val;
}
inline void r_rotate(int x) {
	int f = t[x].f, l = t[x].l;
	(t[f].l == x ? (t[f].l) : (t[f].r)) = l; t[l].f = f;
	t[x].l = t[l].r, t[t[x].l].f = x;
	t[l].r = x, t[x].f = l;
	upd(x);
}

inline void l_rotate(int x) {
	int f = t[x].f, r = t[x].r;
	(t[f].l == x ? (t[f].l) : (t[f].r)) = r; t[r].f = f;
	t[x].r = t[r].l, t[t[x].r].f = x;
	t[r].l = x, t[x].f = r;
	upd(x);
}

inline void splay(int x, int rootf) {
	for (; t[x].f != rootf; ) {
		int f = t[x].f, g = t[f].f;
		if (g == rootf) {
			if (t[f].l == x) r_rotate(f);
			else l_rotate(f);
		} else {
			if (t[g].l == f)
				if (t[f].l == x) r_rotate(g), r_rotate(f);
				else l_rotate(f), r_rotate(g);
			else
			if (t[f].r == x) l_rotate(g), l_rotate(f);
			else r_rotate(f), l_rotate(g);
		}
	}
	upd(x);
}

inline int get_sz(int x) {
	return (x == 0)?x:t[x].sz;
}
int get_pos(int sz) {
	int x, root = S, pr, cnt, v;
	splay(root, 0);
	
	x = root;
	cnt = 0;
	while (1) {
		v = cnt + get_sz(t[x].l) + 1;
		if (v == sz) {
			return x;
		} else if (v > sz) {
			x = t[x].l;	
		} else {
			cnt = v;
			x = t[x].r;
		}
	}
}

void Swap(int l, int r, int ll, int rr) {
	l++, r++, ll++, rr++;
	int u = get_pos(ll - 1);
	int v = get_pos(rr + 1);
	splay(u, 0);
	splay(v, u);
	int x = t[v].l;
	t[x].f = 0, t[v].l = 0;
	splay(v, 0);
	
	u = get_pos(l - 1);
	v = get_pos(l);
	splay(u, 0);
	splay(v, u);
	t[x].f = v, t[v].l = x;
	splay(v, 0);
	
	u = get_pos(l + rr - ll);
	v = get_pos(r + rr - ll + 2);
	splay(u, 0);
	splay(v, u);
	x = t[v].l;
	t[x].f = 0, t[v].l = 0;
	splay(v, 0);
	
	u = get_pos(ll - 1);
	v = get_pos(ll);
	splay(u, 0);
	splay(v, u);
	t[x].f = v, t[v].l = x;
	splay(v, 0);
}

LL Get(int l, int r) {
	l++, r++;
	int u = get_pos(l - 1);
	int v = get_pos(r + 1);
	splay(u, 0);
	splay(v, u);
	return t[t[v].l].val;
}

int n, N, Q;
int a[MX];
LL b[MX], sum;

int main() {
//	freopen("in.txt", "r", stdin);
//	freopen("out.txt", "w", stdout);
	
	scanf("%d%d", &n, &Q);
	N = n - n / 2;
	
	int i, j, type, l, r;
	for (i = 1; i <= n; i++) {
		scanf("%d", a + i);
		b[i] = a[i];
		sum += a[i];
	}
	for (i = 1; i <= n; i++) {
		if (i % 2) a[i / 2 + 1] = b[i];
		else a[i / 2 + N] = b[i];
	}
	for (i = 1; i <= n; i++) b[i] = b[i - 1] + a[i];
	
	S = n + 2, T = n + 1;
	t[S].set(0, 0, 1, n + 2, 0, sum);
	for (i = 1; i <= n; i++) {
		t[i].set(i - 1, 0, i + 1, n + 2 - i, a[i], sum - b[i - 1]);
		if (i == 1) t[i].f = S;
	}
	t[T].set(n, 0, 0, 1, 0, 0);
	
	while (Q--) {
		scanf("%d%d%d", &type, &l, &r);
		if (type == 1) {
			Swap(l / 2 + 1, r / 2 + (r % 2), N + l / 2 + (l % 2), N + r / 2);
		} else {
			LL rlt = 0;
			rlt += Get(l / 2 + 1, r / 2 + (r % 2));
			rlt += Get(N + l / 2 + (l % 2), N + r / 2);
			printf("%lld\n", rlt);
		}
	}
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.97
advanced
----------
PROBLEM STATEMENT:
Let [expression] denote the sequence obtained by multiplying these APs.

Multiplication of two sequences is defined as follows. Let the terms of the first sequence be [expression]. The sequence obtained by multiplying these two sequences is 
[expression] 

If [expression], and so on.

We say that the [expression] difference are equal.  

Let [expression] 
Similarly, [expression]. 

Task: 
Can you find the smallest [expression] is a constant? You are also required to find this constant value.  

You will be given many operations. Each operation is of one of the two forms:  

1) 0 i j = 0 indicates a query [expression] is a constant. You should also output this constant value.  

2) 1 i j v = 1 indicates an update [expression].  

Input Format 
The first line of input contains a single integer [expression], denoting the number of APs. 
Each of the next [expression]. 
The next line consists of a single integer [expression] lines consist of one of the two operations mentioned above.  &nbsp;

Output Format 
For each query, output a single line containing two space-separated integers [expression] modulo 1000003.  

Note: [expression].

Constraints 
[expression] 
[expression] 
[expression] 
For updates of the form 1 i j v, [expression] 
&nbsp;

Sample Input  

2  
1 2 1  
5 3 1  
3  
0 1 2  
1 1 1 1  
0 1 1  


Sample Output  

2 12  
2 8  


Explanation

The first sequence given in the input is = [expression] 
The second sequence given in the input is = [expression]  

For the first query operation, we have to consider the product of these two sequences: 
= [expression] 
= [expression] 
First difference is = [expression] 
Second difference is = [expression] This is a constant and hence the output is 2 12.  

After the update operation 1 1 1 1, the first sequence becomes = [expression] 
i.e = [expression] 
For the second query, we consider only the first sequence = [expression] 
First difference is = [expression] 
Second difference is = [expression] This is a constant and hence the output is 2 8
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;

const int N=100005;
const int M=1000003;
typedef long long i64;

struct node {
int ans;
int mul;
i64 sump;
i64 c;
};

node tree[N<<2];
int f[M];

int mul(i64 x,i64 y) {
	return x*y%M;
}

int gao(int x,int y) {
	if (x==0) {
		return 0;
	}
	if (y==0) {
		return 1;
	}
	if (y&1) {
		y=gao(x,y-1);
		return mul(y,x);
	}
	y=gao(x,y>>1);
	return mul(y,y);
}

void build(int ind,int left,int right) {
int mid;
	tree[ind].ans=1;  //d1^p1*d2^p2*....
	tree[ind].mul=1;  //d1*d2*...
	tree[ind].sump=0; //p1+p2+...+pn
	tree[ind].c=0;
	if (left==right) {
		return;
	}
	mid=(left+right)>>1;
	build(ind<<1,left,mid);
	build((ind<<1)|1,mid+1,right);
}

void update(int ind,int left,int right,int ll,int rr,int x) {  //[left,right] all p+x
int mid,lson,rson;
	if ((left==ll) && (right==rr)) {
		tree[ind].sump+=(rr-ll+1)*x;
		tree[ind].ans=mul(tree[ind].ans,gao(tree[ind].mul,x));
        tree[ind].c+=x; 
		return;
	}
	mid=(left+right)>>1;
	lson=ind<<1;
	rson=lson|1;
	if (tree[ind].c) {   
        tree[lson].sump+=(mid-left+1)*tree[ind].c;
        tree[rson].sump+=(right-mid)*tree[ind].c;
		tree[lson].ans=mul(tree[lson].ans,gao(tree[lson].mul,tree[ind].c));
		tree[rson].ans=mul(tree[rson].ans,gao(tree[rson].mul,tree[ind].c));
        tree[lson].c+=tree[ind].c;
        tree[rson].c+=tree[ind].c;
        tree[ind].c=0;
    }  
	if (rr<=mid) {
		update(lson,left,mid,ll,rr,x);
	}
	else if (ll>mid) {
		update(rson,mid+1,right,ll,rr,x);
	}
	else {
		update(lson,left,mid,ll,mid,x);
		update(rson,mid+1,right,mid+1,rr,x);
	}
	tree[ind].ans=mul(tree[lson].ans,tree[rson].ans);
	tree[ind].sump=tree[lson].sump+tree[rson].sump;
}

void insert(int ind,int left,int right,int x,int p,int d,int dp) { //p[x] d[x] d[x]^p[x]
int mid;
	tree[ind].sump+=p;
	tree[ind].mul=mul(tree[ind].mul,d);
	tree[ind].ans=mul(tree[ind].ans,dp);
	if (left==right) {
		return;
	}
	mid=(left+right)>>1;
	if (x<=mid) {
		insert(ind<<1,left,mid,x,p,d,dp);
	}
	else {
		insert((ind<<1)|1,mid+1,right,x,p,d,dp);
	}
}

pair<i64,int> query(int ind,int left,int right,int ll,int rr) {
int mid,lson,rson;
pair<i64,int> templ,tempr;
	if ((left==ll) && (right==rr)) {
		return make_pair(tree[ind].sump,tree[ind].ans);
	}
	mid=(left+right)>>1;
	lson=ind<<1;
	rson=lson|1;
	if (tree[ind].c) {   
        tree[lson].sump+=(mid-left+1)*tree[ind].c;
        tree[rson].sump+=(right-mid)*tree[ind].c;
		tree[lson].ans=mul(tree[lson].ans,gao(tree[lson].mul,tree[ind].c));
		tree[rson].ans=mul(tree[rson].ans,gao(tree[rson].mul,tree[ind].c));
        tree[lson].c+=tree[ind].c;
        tree[rson].c+=tree[ind].c;
        tree[ind].c=0;
    }  
	if (rr<=mid) {
		return query(lson,left,mid,ll,rr);
	}
	else if (ll>mid) {
		return query(rson,mid+1,right,ll,rr);
	}
	else {
		templ=query(lson,left,mid,ll,mid);
		tempr=query(rson,mid+1,right,mid+1,rr);
		return make_pair(templ.first+tempr.first,mul(templ.second,tempr.second));
	}


}

int main() {
pair<i64,int> ans;
int i,j,x,y,n;
	for (i=f[0]=1;i<M;++i) {
		f[i]=mul(f[i-1],i);
	}
	scanf("%d",&n);
	build(1,1,n);
	for (i=1;i<=n;++i) {
		scanf("%d",&x);
		scanf("%d%d",&x,&y);
		insert(1,1,n,i,y,x,gao(x,y));
	}
	for (scanf("%d",&i);i;--i) {
		scanf("%d%d%d",&j,&x,&y);
		if (j==0) {
			ans=query(1,1,n,x,y);
			printf("%Ld %d\n",ans.first,(ans.first>=M)?0:mul(f[ans.first],ans.second));
		}
		else {
			scanf("%d",&j);
			update(1,1,n,x,y,j);
		}
	}
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.98
advanced
----------
PROBLEM STATEMENT:
Coolguy gives you a simple problem. Given a [expression].

//f(a, b) is a function that returns the minimum element in interval [a, b]

ans = 0

for a - [1, n]
    for b - [a, n]
        for c - [b + 1, n]
            for d - [c, n]
                ans = ans + min(f(a, b), f(c, d))

----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 512

const int N = 1000500;


const double INF = 1e18;

using namespace std;

int n;
int ar[N];

int brute()
{
	int ans = 0;

	for (int i = 0; i < n; i++)
	{
		for (int j = i; j < n; j++)
		{
			for (int q = j + 1; q < n; q++)
			{
				for (int w = q; w < n; w++)
				{
					int mn = 1e9;
					for (int a = i; a <= j; a++)
					{
						mn = min(mn, ar[a]);
					}
					for (int a = q; a <= w; a++)
					{
						mn = min(mn, ar[a]);
					}
					ans += mn;
					ans %= bs;
				}
			}
		}
	}
	return ans;
}

vector<pair<int, pair<int, int> > > events;
int block[N];

set<int> ban;
long long ttl;

int get_prev(int x)
{
	set<int>::iterator it;
	it = ban.lower_bound(x);
	--it;
	return *it;
}

int get_next(int x)
{
	set<int>::iterator it;
	it = ban.lower_bound(x);
	return *it;
}

long long TTL;

long long C(long long x)
{
	return x*(x + 1) / 2 % bs;
}

void remove_segment(int l, int r)
{
	TTL -= C(r - l - 1);
}

void add_segment(int l, int r)
{
	TTL += C(r - l - 1);
}

int smart()
{
	long long ans = 0;

	events.clear();

	for (int i = 0; i < n; i++)
	{
		events.push_back(make_pair(ar[i], make_pair(1, i)));
	}
	
	sort(events.begin(), events.end());

	ban.clear();
	ban.insert(-1);
	ban.insert(n);

	TTL = C(n);
	TTL %= bs;

	for (int i = 0; i < events.size(); i++)
	{
		int ps = events[i].second.second;
		int l, r;
		l = get_prev(ps);
		r = get_next(ps);
		int span = r - l - 1;
		long long val1 = TTL - C(span) + bs;
		val1 %= bs;
		ans += 1ll * val1*(ps - l) % bs*(r - ps) % bs*ar[ps]%bs;
		ans %= bs;
		//cout << ps << " " << l << " " << r << " "<<ar[ps]<<" "<<ans<<endl;

		for (int Q = l + 1; Q <= ps; Q++)
		{
			ans += C(Q - l - 1)*(r - ps)%bs*ar[ps]%bs;
			ans %= bs;
		}
		for (int Q = ps; Q < r; Q++)
		{
			ans += C(r - Q - 1)*(ps - l)%bs*ar[ps]%bs;
			ans %= bs;
		}
		
		remove_segment(l, r);
		add_segment(l, ps);
		add_segment(ps, r);
		ban.insert(ps);

	}

	return ans;
}

int main(){
	//freopen("route.in","r",stdin);
	//freopen("route.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);

//	srand(10);

	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> ar[i];
	//	ar[i] = rand() % 5;
	}

//	cout << brute() << endl;
	cout << smart() << endl;

	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
DATA-STRUCTURES.99
hard
----------
PROBLEM STATEMENT:
White Falcon has a tree with [expression].  

Let's denote the path from node [expression] are connected.  

White Falcon also has [expression] queries. They are in the following format:  


[expression].
[expression]

----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <vector>
#include <cstring>
#include <map>
using namespace std;

#define MAXN 100010
#define mod  1000000007
typedef long long LL;
typedef pair<LL,LL> PLL;

struct Mat
{
    int a[3][3];///last row is always 0 0 1
    void zero() {memset(a,0,sizeof(a));}
    void one()  {zero();for(int i=0;i<3;i++) a[i][i]=1;}
};
Mat operator*(const Mat &A,const Mat &B)
{
    Mat C;C.zero();
    for(int k=0;k<3;k++)
    {
        for(int i=0;i<2;i++)
        for(int j=0;j<3;j++)
        C.a[i][j] = ((LL)C.a[i][j]+(LL)A.a[i][k]*(LL)B.a[k][j])%mod;
    }
    C.a[2][2]=1;
    return C;
}
Mat Pow(Mat Mul,int pw)
{
    Mat ret;ret.one();
    while(pw)
    {
        if(pw&1) ret=ret*Mul;
        Mul=Mul*Mul;
        pw>>=1;
    }
    return ret;
}


struct segtree
{
    int l,r;
    LL lazy[2];
    LL SUMLToR[2],SUMRToL[2];
    ///ADD SUMLRA,SUMLRB: Left->Right
    ///ADD SUMRLA,SUMRLB: Right->Left
}t[MAXN*4+200];


int siz[MAXN],top[MAXN],fa[MAXN],son[MAXN],id[MAXN],dep[MAXN],pnum;//son ???????id???,pnum ????
vector<int> link1[MAXN];

int initvalue[MAXN][2],M,N,value[MAXN][2];

int STACK[MAXN],TOP,F[MAXN];

void dfs1(int x,int f)
{
    memset(F,-1,sizeof(int)*N);
    TOP=0;
    STACK[++TOP]=0;

    while(TOP)
    {
        x=STACK[TOP];
        f=F[x];
        if(f>=-1)
        {
            fa[x]=f;

            dep[x]=(f==-1?0:dep[f]+1);


            int len=link1[x].size(),v;
            for(int i=0;i<len;i++)
            {
                v=link1[x][i];
                if(f==v) continue;
                STACK[++TOP]=v;
                F[v]=x;
            }
            F[x]=-100;//visit 1
        }
        else
        {
             siz[x]=1;
             son[x]=-1;
             f=fa[x];
             int bestsiz=0;
             int len=link1[x].size(),v;
             for(int i=0;i<len;i++)
             {
                 v=link1[x][i];
                 if(f==v) continue;
                 siz[x]+=siz[v];
                 if(siz[v]>bestsiz)
                 {
                    son[x]=v;
                    bestsiz=siz[v];
                    swap(link1[x][0],link1[x][i]);//??dfs2???????
                 }
             }
             --TOP;
        }
    }
}
void dfs2(int x,int f)
{
    memset(F,-1,sizeof(int)*N);
    TOP=0;
    STACK[++TOP]=0;

    while(TOP)
    {
        x=STACK[TOP];
        f=F[x];
        if(f>=-1)
        {
            if(f==-1||son[fa[x]]!=x) top[x]=x;//??
            else top[x]=top[fa[x]];//????
            id[x]=pnum++;//????????
            value[id[x]][0]=initvalue[x][0];//??????
            value[id[x]][1]=initvalue[x][1];
            int len=link1[x].size(),v;
            for(int i=len-1;i>=0;i--)
            {
                v=link1[x][i];
                if(f==v) continue;
                STACK[++TOP]=v;
                F[v]=x;
            }

            F[x]=-100;
        }
        else TOP--;
    }
}

void build(int l,int r,int p)
{
    t[p].l=l;
    t[p].r=r;
    t[p].lazy[0]=-1;
    t[p].lazy[1]=-1;
    if(l==r)
    {
        t[p].SUMRToL[0] = t[p].SUMLToR[0] = value[l][0];
        t[p].SUMRToL[1] = t[p].SUMLToR[1] = value[l][1];
        return;
    }
    int mid=(l+r)>>1;
    build(l,mid,p<<1);
    build(mid+1,r,(p<<1)+1);
    ///L->R:fR(fL)
    t[p].SUMLToR[0] =  t[p<<1].SUMLToR[0]*t[1+(p<<1)].SUMLToR[0]%mod;
    t[p].SUMLToR[1] = (t[p<<1].SUMLToR[1]*t[1+(p<<1)].SUMLToR[0] + t[1+(p<<1)].SUMLToR[1])%mod;
    ///R->L:fL(fR)
    t[p].SUMRToL[0] =  t[p<<1].SUMRToL[0]*t[1+(p<<1)].SUMRToL[0]%mod;
    t[p].SUMRToL[1] = (t[p<<1].SUMRToL[0]*t[1+(p<<1)].SUMRToL[1] + t[p<<1].SUMRToL[1])%mod;
}
void dealcal(int p)
{
    Mat Mul,Ret;
    Mul.zero();
    Mul.a[1][1] = Mul.a[0][0] = t[p].lazy[0];
    Mul.a[1][2] = t[p].lazy[1];
    Mul.a[2][2] = 1;
    Ret = Pow(Mul,t[p].r-t[p].l+1);
    t[p].lazy[0] = t[p].lazy[1] = -1;
    t[p].SUMRToL[0] = t[p].SUMLToR[0] = (Ret.a[0][0] + Ret.a[0][2])%mod;
    t[p].SUMRToL[1] = t[p].SUMLToR[1] = (Ret.a[1][0] + Ret.a[1][2])%mod;
}
void deal(int p)
{
    if(t[p].l!=t[p].r)
    {
        t[p<<1].lazy[0]     = t[p].lazy[0];
        t[p<<1].lazy[1]     = t[p].lazy[1];
        t[1+(p<<1)].lazy[0] = t[p].lazy[0];
        t[1+(p<<1)].lazy[1] = t[p].lazy[1];
    }
    dealcal(p);
}
PLL query(int l,int r,int p,int LabLR)///LabLR=0:L->R;LabLR=1:R->L
{
    ///cout<<l<<" "<<r<<" "<<p<<" "<<LabLR<<endl;
    if(t[p].lazy[0]!=-1)
    {
        ///cout<<"QJ: "<< t[p].lazy[0]<<" "<<t[p].lazy[1]<<endl;
        deal(p);
    }
    if(t[p].l==l&&t[p].r==r)
    {
        if(LabLR==0) return PLL(t[p].SUMLToR[0],t[p].SUMLToR[1]);
        else         return PLL(t[p].SUMRToL[0],t[p].SUMRToL[1]);
    }
    int mid = (t[p].l+t[p].r)>>1;
    if(r<=mid) return query(l,r,p<<1,LabLR);
    if(l>mid ) return query(l,r,1+(p<<1),LabLR);
    PLL LAB = query(l,mid,p<<1,LabLR);
    PLL RAB = query(mid+1,r,1+(p<<1),LabLR);
    if(LabLR==0)
    {
        ///L->R:fR(fL)
        return PLL(LAB.first*RAB.first%mod , (LAB.second*RAB.first+RAB.second)%mod);
    }
    else
    {
        ///R->L:fL(fR)
        return PLL(RAB.first*LAB.first%mod , (RAB.second*LAB.first+LAB.second)%mod);
    }
}

void changeFunc(int l,int r,int p,int A,int B)
{
    ///cout<<"change: "<<l<<" "<<r<<" "<<p<<" "<<A<<" "<<B<<endl;
    if(t[p].l==l&&t[p].r==r)
    {
        t[p].lazy[0] = A;
        t[p].lazy[1] = B;
        deal(p);
        ///cout<<"end: "<<l<<" "<<r<<" "<<p<<" "<<A<<" "<<B<<" => ";
        ///cout<<t[p].SUMLToR[0]<<" "<<t[p].SUMLToR[1]<<" : "<<t[p].SUMRToL[0]<<" "<<t[p].SUMRToL[1]<<endl;
        return;
    }
    if(t[p].lazy[0]!=-1) deal(p);
    int mid = (t[p].l+t[p].r)>>1;
    if(r<=mid) changeFunc(l,r,p<<1,A,B);
    else if(l>mid) changeFunc(l,r,1+(p<<1),A,B);
    else
    {
        changeFunc(l,mid,p<<1,A,B);
        changeFunc(mid+1,r,1+(p<<1),A,B);
    }
    if(t[p<<1].lazy[0]!=-1) deal(p<<1);
    if(t[1+(p<<1)].lazy[0]!=-1) deal(1+(p<<1));
    ///L->R:
    t[p].SUMLToR[0] =  t[p<<1].SUMLToR[0]*t[1+(p<<1)].SUMLToR[0]%mod;
    t[p].SUMLToR[1] = (t[p<<1].SUMLToR[1]*t[1+(p<<1)].SUMLToR[0] + t[1+(p<<1)].SUMLToR[1])%mod;
    ///R->L:
    t[p].SUMRToL[0] =  t[p<<1].SUMRToL[0]*t[1+(p<<1)].SUMRToL[0]%mod;
    t[p].SUMRToL[1] = (t[p<<1].SUMRToL[0]*t[1+(p<<1)].SUMRToL[1] + t[p<<1].SUMRToL[1])%mod;
    ///cout<<"end: "<<l<<" "<<r<<" , "<<t[p].l<<" "<<t[p].r<<" , "<<A<<" "<<B<<" => ";
    ///cout<<t[p].SUMLToR[0]<<" "<<t[p].SUMLToR[1]<<" : "<<t[p].SUMRToL[0]<<" "<<t[p].SUMRToL[1]<<endl;
}

void updata(int u,int v,int A,int B)
{
    ///cout<<"-********-------"<<endl;
    int fu=top[u],fv=top[v];
    while(fu!=fv)
    {
        ///cout<<"up : " <<fu<<" "<<fv<<endl;
        if(dep[fu]>=dep[fv])
        {
            changeFunc(id[fu],id[u],1,A,B);
            u=fa[fu];fu=top[u];
        }
        else
        {
            changeFunc(id[fv],id[v],1,A,B);
            v=fa[fv];fv=top[v];
        }
    }
    u=id[u];v=id[v];
    if(u>v) swap(u,v);
    changeFunc(u,v,1,A,B);
}

LL QueryFunctions(int u,int v,int X)///u->v:fv(...fu(X)...)
{
    ///to u: always u->fu (Lab:R->L)
    ///to v: always fv->v (Lab:L->R)
    PLL Lu=PLL(1,0);
    PLL Lv=PLL(1,0);
    PLL tmp;
    int fu=top[u],fv=top[v];
    while(fu!=fv)
    {
        ///cout<<fu<<" "<<fv<<endl;
        if(dep[fu]>=dep[fv])
        {
            tmp = query(id[fu],id[u],1,1);
            Lu = PLL(Lu.first*tmp.first%mod , (Lu.second*tmp.first+tmp.second)%mod );
            u=fa[fu];fu=top[u];
        }
        else
        {
            tmp = query(id[fv],id[v],1,0);
            Lv = PLL(Lv.first*tmp.first%mod , (tmp.second*Lv.first+Lv.second)%mod );
            v=fa[fv];fv=top[v];
        }
    }
    u=id[u];v=id[v];
    if(v<=u)
    {
        tmp = query(v,u,1,1);
        Lu = PLL(Lu.first*tmp.first%mod , (Lu.second*tmp.first+tmp.second)%mod );
    }
    else
    {
        tmp = query(u,v,1,0);
        ///cout<<"u<v : "<<tmp.first<<" "<<tmp.second<<endl;
        Lv  = PLL(Lv.first*tmp.first%mod , (tmp.second*Lv.first+Lv.second)%mod );
    }
    PLL AB = PLL(Lv.first*Lu.first%mod , (Lu.second*Lv.first+Lv.second)%mod );
    return (AB.first*X+AB.second)%mod;
}

void init()
{
    dfs1(0,-1);
    pnum=0;
    dfs2(0,-1);
    ///cout<<"pnum: "<<pnum<<endl;
    ///for(int i=0;i<N;i++) cout<<id[i]<<" is id of "<<i<<endl;
    ///for(int i=0;i<N;i++) cout<<i<<" son:"<<son[i]<<" top:"<<top[i]<<" dep:"<<dep[i]<<" fa:"<<fa[i]<<endl;
    build(0,N-1,1);
}

int main()
{
    ///freopen("in.txt","r",stdin);
    int u,v,a,b,type,X;
    while(scanf("%d",&N)!=EOF)
    {
        for(int i=0;i<N;i++)
        {
            scanf("%d%d",&initvalue[i][0],&initvalue[i][1]);
            link1[i].clear();
        }
        M=N-1;
        for(int i=0;i<M;i++)
        {
            scanf("%d%d",&u,&v);
            u--;v--;
            link1[u].push_back(v);
            link1[v].push_back(u);
        }
        init();

        scanf("%d",&M);
        while(M--)
        {
            scanf("%d",&type);
            if(type==1)
            {

                scanf("%d%d%d%d",&u,&v,&a,&b);
                u--;v--;
                updata(u,v,a,b);
            }
            else
            {
                scanf("%d%d%d",&u,&v,&X);
                u--;v--;
                int ans = QueryFunctions(u,v,X);
                ans = (ans+mod)%mod;
                printf("%d\n",ans);
            }
        }
        ///cout<<"========="<<endl;
    }
    return 0;
}
----------
====================
----------
DATA-STRUCTURES.100
advanced
----------
PROBLEM STATEMENT:
Given a rooted tree of [expression] nodes, where each node is uniquely numbered in between [1..N]. The node 1 is the root of the tree. Each node has an integer value which is initially 0.

You need to perform the following two kinds of queries on the tree:


add t value: Add value to all nodes in subtree rooted at t
max a b: Report maximum value on the path from a to b

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

#define time something_awesome1

typedef pair < int ,int > pii;

typedef long long ll;

const int inf = 1e9;
const int mod = 1e9+7;
const int logN = 18;
const int N = 1e5+5;

int start[N], e[N], head[N], time, i, j, k, n, m, depth[N], lca[N][logN+1], sum[N], x, y, t; 

char s[5];

vector< int > v[N];

class node{
	
	public:

		int max, L;
	
		node(){ max = L = 0; }

} ST[4 * N];

node merge(int l,node x,node y){
	
	node temp;

	temp.max = max(x.max,y.max);

	temp.max += l;

	temp.L = l;

	return temp;
	
}

node update(int k,int bas,int son,int x,int y,int t){
	
	if(bas > y || son < x) return ST[k];

	if(x <= bas && son <= y){
		
		ST[k].L += t;

		ST[k].max += t;

		return ST[k];

	}

	int orta = bas + son >> 1;

	return ST[k] = merge(ST[k].L,update(2 * k,bas,orta,x,y,t),update(2 * k + 1,orta+1,son,x,y,t));
	
}

int query(int k,int bas,int son,int x,int y){
	
	if(bas > y || son < x) return -inf;

	if(x <= bas && son <= y) return ST[k].max;

	int orta = bas + son >> 1;

	return max(query(k+k,bas,orta,x,y),query(k+k+1,orta+1,son,x,y)) + ST[k].L;
	
}

int dfs(int node,int last){

	lca[node][0] = last;

	foreach(it,v[node])

		if(*it != last){
		
			depth[*it] = depth[node] + 1;

			sum[node] += dfs(*it,node);
		
		}
	
	return ++sum[node];
}

void dfs2(int node,int last,int s){
	
	int temp = 0;

	start[node] = ++time;

	head[node] = s;

	foreach(it,v[node]) if(*it != last && sum[*it] > sum[temp]) temp = *it;

	if(temp) dfs2(temp,node,s);
	
	foreach(it,v[node]) if(*it != last && *it != temp) dfs2(*it,node,*it);

	e[node] = time;
	
}

int LCA(int x,int y){
	
	if(depth[x] < depth[y]) swap(x,y);

	int diff = depth[x] - depth[y];

	FOR(i,0,logN) if(diff & (1<<i)) x = lca[x][i];

	if(x == y) return x;

	ROF(i,logN,0) if(lca[x][i] != lca[y][i]) x = lca[x][i], y = lca[y][i];

	return lca[x][0];
	
}

int que(int x,int y){
	
	int mx = -inf;

	while(depth[x] >= depth[y]){
	
		mx = max(mx, query(1, 1, n, max(start[ head[x] ], start[y]), start[x]));

		x = lca[head[x]][0]; 

	}

	return mx;

}

int solve(int x,int y){
	
	int l = LCA(x,y);

	return max(que(x,l), que(y,l));

}

int main(){
	
	scanf("%d",&n);

	FOR(i,2,n){
		
		scanf("%d %d",&x,&y);

		v[x].pb(y);
		
		v[y].pb(x);
		
	}

	depth[1] = 1;

	dfs(1,0);
	
	dfs2(1,0,1);

	FOR(j,1,logN)
		
		FOR(i,1,n)
			
			lca[i][j] = lca[lca[i][j-1]][j-1];

	scanf("%d",&m);

	FOR(i,1,m){
		
		scanf("%s",s);

		if(strcmp(s,"add") == 0){
			
			scanf("%d %d",&x,&y);

			update(1,1,n,start[x],e[x],y);
			
		}
		
		else {
			
			scanf("%d %d",&x,&y);

			printf("%d\n",solve(x,y));
			
		}
		
	}

    return 0;
}

----------
====================
----------
DATA-STRUCTURES.101
advanced
----------
PROBLEM STATEMENT:
There is an integer array [expression]) are present?&nbsp;

Input format 
The first line contains an integer, [expression] space-separated integers. Please note that there are no leading spaces before the first number, and there are no trailing spaces after the last number.

Output format: 
A single integer that denotes the number of distinct ascending triplets present in the array.

Constraints: 
[expression] 
Every element of the array is present at most twice. 
Every element of the array is a 32-bit non-negative integer.

Sample input:  

6  
1 1 2 2 3 4  


Sample output:  

4


Explanation 
The distinct triplets are 
(1,2,3) 
(1,2,4) 
(1,3,4) 
(2,3,4)

The elements of the array might not be sorted. Make no assumptions of the same.
----------
TOP SOLUTION:
----------
/**
 * Jerry Ma
 * triplets.cpp
 */

#include <assert.h>
#include <ctype.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <algorithm>
#include <bitset>
#include <deque>
#include <fstream>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <utility>
#include <vector>

using namespace std;

typedef long long int lli;
typedef pair<int, int> pii;

int gInt () {
    int i;
    scanf("%d", &i);
    return i;
}

lli gLong () {
    lli i;
    scanf("%lld", &i);
    return i;
}

double gDouble () {
    double i;
    scanf("%lf", &i);
    return i;
}

void quit () {
    fflush(stdout);
    exit(0);
}

int n;
int nums[100005];
lli bitree[100005], bidtree[100005], finals[100005];
map <int, int> numtoind;
set <int> sorted;

lli getfreq (lli * tree, int ind) {
    int curBit = 0, sum = 0;
    while (ind) {
        if (ind & (1 << curBit)) {
            sum += tree[ind];
            ind -= (1 << curBit);
        }
        curBit ++;
    }
    return sum;
}

void chgfreq (lli * tree, int ind, lli chg) {
    int curBit = 0;
    while (ind <= n) {
        if (ind & (1 << curBit)) {
            tree[ind] += chg;
            ind += (1 << curBit);
        }
        curBit ++;
    }
}

lli getpos (lli * tree, int ind) {
    return getfreq(tree, ind) - getfreq(tree, ind - 1);
}

int main (int argc, char ** argv) {
    n = gInt();
    for (int i = 0; i < n; i ++)
        sorted.insert(nums[i] = gInt());
    set <int> :: iterator it = sorted.begin();
    for (int i = 0; it != sorted.end(); i ++, it ++)
        numtoind[*it] = i + 1;
    for (int i = 0; i < n; i ++) {
        int curind = numtoind[nums[i]];
        if (!getpos(bitree, curind))
            chgfreq(bitree, curind, 1LL);
        lli newfreq = getfreq(bitree, curind - 1);
        chgfreq(bidtree, curind, newfreq - getpos(bidtree, curind));
        finals[curind] = getfreq(bidtree, curind - 1);
    }
    lli ans = 0LL;
    for (int i = 0; i <= sorted.size(); i ++)
        ans += finals[i];
    printf("%lld\n", ans);
    quit();
}
----------
====================
----------
DATA-STRUCTURES.102
expert
----------
PROBLEM STATEMENT:
You are given an array, [expression] integers.

A segment, [expression].

You must answer [expression].
----------
TOP SOLUTION:
----------
#include "iostream"
#include "algorithm"
#include "vector"
#include "set"
#include "map"
#include "cstring"
#include "string"
#include "vector"
#include "cassert"
#include "queue"
#include "cstdio"
#include "cstdlib"

using namespace std;

typedef long long ll;
typedef pair < int, int > ii;

const int N = 40000 + 5;
const int LOG = 16;
const int Q = 1e5 + 5;
const int K = 200 + 5;
const int T = N / K + 5;
const int MAX = 200000;

int n, q;
int a[N], ql[LOG][N], qr[LOG][N];
int fen[MAX];
int L[Q], R[Q], X[Q], ans[Q];
vector < int > qu[T];

int fl(int x, int y, int k) {
    if(a[x] <= k)
        return y - x + 1;
    int res = a[x];
    x++;
    for(int i = LOG - 1; i >= 0; i--) {
        if((res & qr[i][x]) > k) {
            res &= qr[i][x];
            x += 1 << i;
        }
    }
    return max(0, y - x + 1);
}

void up(int x, int y, int k) {
    x += 5;
    y += 5;
    for(; x < MAX; x += x & -x)
        fen[x] += k;
    for(y++; y < MAX; y += y & -y)
        fen[y] -= k;
}

int get(int x) {
    x += 5;
    int res = 0;
    for(; x; x -= x & -x)
        res += fen[x];
    return res;
}

void f(int to, int x) {
    int last = 150000, cur = a[x];
    while(x >= to) {
        int lx = x + 1;
        cur &= a[x];
        x--;
        if(cur == 0)
            x = 0;
        else
        for(int i = LOG - 1; i >= 0; i--) {
            if((cur & ql[i][x]) == cur) {
                x -= 1 << i;
            }
        }
        x++;
        x = max(x, to);
        int len = lx - x;
        up(cur, last - 1, len);
        //doSmth();
        x--;
    }
}

int main() {
    
    scanf("%d %d", &n, &q);
    
    for(int i = 1; i <= n; i++) {
        scanf("%d", a + i);
        ql[0][i] = qr[0][i] = a[i];
    }
    
    for(int i = 1; i < LOG; i++) {
        for(int j = 1; j + (1 << i) - 1 <= n; j++) {
            qr[i][j] = qr[i - 1][j] & qr[i - 1][j + (1 << i - 1)];
        }
        for(int j = n; j - (1 << i) + 1 >= 1; j--) {
            ql[i][j] = ql[i - 1][j] & ql[i - 1][j - (1 << i - 1)];
        }
    }
    
    for(int i = 1; i <= q; i++) {
        scanf("%d %d %d", L + i, R + i, X + i);
        qu[(L[i] - 1) / K].push_back(i);
    }
    
    for(int it = 0; it < T; it++) {
        if(qu[it].empty())
            continue;
        sort(qu[it].begin(), qu[it].end(), [&](int x, int y) {
            return R[x] < R[y];
        });
        memset(fen, 0, sizeof(fen));
        int last = min(n, (it + 1) * K);
        int Rb = last, res = 0;
        for(auto id : qu[it]) {
            int x = L[id];
            int y = R[id];
            int k = X[id];
            for(int i = Rb + 1; i <= y; i++) {
                f(last + 1, i);
                Rb = i;
            }
            ans[id] = get(k);
            for(int i = x; i <= last and i <= y; i++) {
                ans[id] += fl(i, y, k);
            }
        }
    }
    
    for(int i = 1; i <= q; i++) {
        printf("%d\n", ans[i]);
    }
    
    return 0;
    
}
----------
====================
----------
DATA-STRUCTURES.103
expert
----------
PROBLEM STATEMENT:
Two positive integers [expression] are given. 
[expression]. 
Lets define [expression].

For example, if [expression]: 
[expression]

For each query you will be given two integers [expression]. 
Your task is to calculate divisibility of given substring. 
Divisibility of given substring is equal to number of [expression] pairs such that: 
[expression] and 
[expression] is divisible by any other integer.

Timelimits  

Timelimits for this challenge is given here
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

#define fi first
#define se second

using namespace std;

typedef long long int Lint;
typedef pair <int,int> ii;
int N,Q,K,srt[110000],sizeLeft[110000],sizeRight[110000],A,B,C,D=1,R[110000][35],L[110000][35],OK[110000];
Lint num[110000],ans[110000],G[110000],P,POW[35]; //G[x]=f( x , N )
ii query[110000];
string s;

int compare( const int &a , const int &b ){
    if( query[a].fi/K != query[b].fi/K ) return query[a].fi < query[b].fi;
    return query[a].se < query[b].se;
}

int compare2( const int &a , const int &b ){ return G[a] < G[b]; }

int main(){

    cin >> P >> Q;
    cin >> s;
    while( (P%2) == 0 ){ P/=2; A++; D*=2; }
    while( (P%5) == 0 ){ P/=5; B++; D*=5; }
    C=max( A , B );
    N=s.size();
    for( int i=0 ; i<N ; i++ ) num[i+1]=s[i]-'0';
    K=sqrt( N );

    Lint power=1;
    for( int i=N ; i ; i-- ){
        srt[i+1]=i+1;
        G[i]=(G[i+1]+(power*num[i])%P)%P;
        power=(power*10LL)%P;
    }
    POW[0]=1;
    for( int i=1 ; i<=32 ; i++ ) POW[i]=(POW[i-1]*10)%D;
    srt[1]=1;

    sort( srt+1 , srt+2+N , compare2 );

    for( int i=1,prev=-1,count=0 ; i<=N+1 ; i++ ){
        if( G[srt[i]] !=prev  ) count++,prev=G[srt[i]];
        G[srt[i]]=count;
    }

    for( int i=1 ; i<=N ; i++ ){
        Lint md=0;
        int j;
        for( j=0 ; i-j && j<C ; j++ ){
            md=(md+(POW[j]*num[i-j])%D)%D;
            R[i+1][j+1]=R[i+1][j];
            if( !md && G[i-j] == G[i+1] ) R[i+1][j+1]++,L[i-j][j+1]++;
        }
        if( j == C && !md ) OK[i+1]=1;
    }

    for( int i=1 ; i<=N+1 ; i++ )
        for( int j=0 ; i+j<=N && j<C ; j++ ) L[i][j+1]+=L[i][j];

    for( int i=1,begin,end ; i<=Q ; i++ ){
        scanf(" %d %d",&begin,&end);
        query[i]=ii( begin , end );
        srt[i]=i;
    }
    sort( srt+1 , srt+1+Q , compare ); // query[srt[i]] < query[srt[i+1]]

    Lint sum=0;
    int left=N,right=N+5,r,l;

    for( int i=1,b,e ; i<=Q ; i++ ){
        b=query[srt[i]].fi,e=query[srt[i]].se+1;
        //~ cout << b << ' ' << e << ' ' << srt[i] << endl;
        if( e < right ){
            r=b-C-1,l=b+C;
            memset( sizeRight , 0 , sizeof sizeRight );
            memset( sizeLeft , 0 , sizeof sizeLeft );
            left=b,right=b-1;
            sum=0;
        }
        for( int j=right+1 ; j<=e ; j++ , r++ ){
            if( r >= left ) sizeRight[G[r]]++;
            if( j-left > C && OK[j] ) sum+=sizeRight[G[j]],sizeLeft[G[j]]++;
            sum+=R[j][min(j-left,C)];
        }
        for( int j=left-1 ; j>=b ; j-- , l-- ){
            if( OK[l] && l <= e ) sizeLeft[G[l]]++;
            sum+=sizeLeft[G[j]]+L[j][min(C,e-j)];
            if( e-C > j ) sizeRight[G[j]]++;
        }
        for( int j=left ; j<b ; j++  ){
            if( l < e ){
                l++;
                sum-=sizeLeft[G[j]]+L[j][min(C,e-j)];
                if( OK[l] ) sizeLeft[G[l]]--;
            }else sum-=L[j][e-j];
            if( l >= e ) l=j+C+1;
            if( e-C > j ) sizeRight[G[j]]--;
        }
        left=b; right=e;
        ans[srt[i]]=sum;
    }

    for( int i=1 ; i<=Q ; i++ ) printf("%lld\n",ans[i]);

    return 0;

}

----------
====================
----------
DATA-STRUCTURES.104
advanced
----------
PROBLEM STATEMENT:
Consider a binary search tree T which is initially empty. Also, consider the first N positive integers {1, 2, 3, 4, 5, ....., N} and its permutation P {a1, a2, ..., aN}. 

If we start adding these numbers to the binary search tree T, starting from a1, continuing with a2, ... (and so on) ..., ending with aN. After every addition we ask you to output the sum of distances between every pair of T's nodes.

Input Format 
The first line of the input consists of the single integer N, the size of the list. 
The second line of the input contains N single space separated numbers the permutation a1, a2, ..., aN itself.

Constraints 
1 ≤ N ≤ 250000  

Output Format 
Output N lines. 
On the ith line output the sum of distances between every pair of nodes after adding the first i numbers from the permutation to the binary search tree T  

Sample Input #00

8
4 7 3 1 8 2 6 5


Sample Output #00

0
1
4
10
20
35
52
76


Explanation #00  

After adding the first element, the distance is 0 as there is only 1 element 

4


After adding the second element, the distance between 2 nodes is 1.  

4
 \
  7


After adding the third element, the distance between every pair of elements is 2+1+1=4

  4
 / \
3   7    


After adding the fourth element, the distance between every pair of elements is 3 + 2 + 1 + 2 + 1 + 1 = 10

    4
   / \
  3   7    
 /
1


After adding the fifth element, the distance between every pair of elements is 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 20

    4
   / \
  3   7    
 /     \
1       8


After adding the sixth element, the distance between every pair of elements is 5 + 4 + 3 + 2 + 1 + 4 + 3 + 2 + 1 + 3 + 2 + 1 + 2 + 1 + 1 = 35

    4
   / \
  3   7    
 /     \
1       8
 \
  2


After adding the seventh element, the distance between every pair of elements is 5+5+4+3+2+1+4+4+3+2+1+3+3+2+1+2+2+1+1+1+2=52

    4
   / \
  3   7    
 /   / \
1   6   8
 \
  2


After adding the final element, the distance between every pair of elements is 6+5+5+4+3+2+1+5+4+4+3+2+1+4+3+3+2+1+3+2+2+1+2+1+1+2+1+3=76

        4
      /   \
    3      7   
  /      /   \
 1      6     8
  \    /
   2  5

----------
TOP SOLUTION:
----------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vector>
#include <set>

using namespace std;

#define LOCAL 0
#define DEBUG 0
#define NMAX 250100

char used[NMAX];
int p[NMAX];
int N;

void ReadInput() {
	int i;
	if (LOCAL) {
		srand(10000);
		N = 250000;
		memset(used, 0, sizeof(used));
		for (i = 1; i <= N; i++) {
			do {
				p[i] = N - i + 1;//1 + (rand() % N);
			} while (used[p[i]]);
			used[p[i]] = 1;
		}
	} else {
		//freopen("x.txt", "r", stdin);
		scanf("%d", &N);
		for (i = 1; i <= N; i++)
			scanf("%d", &p[i]);
	}
}

vector<int> child[NMAX];
set<int> numbers;
int lson[NMAX], rson[NMAX], level[NMAX];
int root;

void BuildBST() {
	int i, x, y;
	set<int>::iterator it;
	
	root = p[1];
	numbers.insert(root);
	level[root] = 1;

	memset(lson, 0, sizeof(lson));
	memset(rson, 0, sizeof(rson));

	for (i = 2; i <= N; i++) {
		x = y = 0;
		it = numbers.lower_bound(p[i]);
		if (it != numbers.end())
			y = *it;
		if (it != numbers.begin()) {
			it--;
			x = *it;
		}

		if (x > 0 && rson[x] == 0) {
			rson[x] = p[i];
			child[x].push_back(p[i]);
			if (DEBUG) fprintf(stderr, "%d -rson-> %d\n", x, p[i]);
			level[p[i]] = level[x] + 1;
		} else if (y > 0 && lson[y] == 0) {
			lson[y] = p[i];
			child[y].push_back(p[i]);
			if (DEBUG) fprintf(stderr, "%d -lson-> %d\n", y, p[i]);
			level[p[i]] = level[y] + 1;
		} else
			exit(1);
	
		numbers.insert(p[i]);
	}
}

long long cnt[NMAX];
int qbfs[NMAX];

void BFS() {
	int li, ls, i, j, k;
	qbfs[li = ls = 1] = root;
	while (li <= ls) {
		i = qbfs[li];
		li++;
		for (k = 0; k < child[i].size(); k++) {
			j = child[i][k];
			ls++;
			qbfs[ls] = j;
		}
	}

	if (ls != N) exit(2);

	for (li = N; li >= 1; li--) {
		i = qbfs[li];
		cnt[i] = 1;
		for (j = 0; j < child[i].size(); j++)
			cnt[i] += cnt[child[i][j]];
		if (DEBUG) fprintf(stderr, "i=%d: cnt=%lld\n", i, cnt[i]);
	}
}

int qhpd[NMAX][3], lihpd, lshpd;
vector<int> path[NMAX];
int pathp[NMAX], pathpnode[NMAX], nodepath[NMAX], nodepozinpath[NMAX];
int np;

void BuildPath(int rnode, int pathparent, int pathparentnode) {
	np++;
	pathp[np] = pathparent;
	pathpnode[np] = pathparentnode;

	int i = rnode, j, k, nexti;
	path[np].push_back(i);
	nodepath[i] = np;
	nodepozinpath[i] = path[np].size() - 1;

	while (1) {
		nexti = 0;
		for (k = 0; k < child[i].size(); k++) {
			j = child[i][k];
			if (!nexti || cnt[j] > cnt[nexti])
				nexti = j;
		}

		if (!nexti)
			break;

		for (k = 0; k < child[i].size(); k++) {
			j = child[i][k];
			if (j != nexti) {
				lshpd++;
				qhpd[lshpd][0] = j;
				qhpd[lshpd][1] = np;
				qhpd[lshpd][2] = i;
			}
		}
	
		i = nexti;
		path[np].push_back(i);
		nodepath[i] = np;
		nodepozinpath[i] = path[np].size() - 1;
	}

	if (DEBUG) {
		fprintf(stderr, "path %d (pathp=%d pathpnode=%d):", np, pathp[np], pathpnode[np]);
		for (i = 0; i < path[np].size(); i++)
			fprintf(stderr, " %d", path[np][i]);
		fprintf(stderr, "\n");
	}
}

void BuildHPD() {
	int i, j, k;
	
	np = 0;
	lihpd = lshpd = 0;
	qhpd[0][0] = root;
	qhpd[0][1] = qhpd[0][2] = 0;

	while (lihpd <= lshpd) {
		BuildPath(qhpd[lihpd][0], qhpd[lihpd][1], qhpd[lihpd][2]);
		lihpd++;
	}
}

#define MAXNODES 2000000

long long sum[MAXNODES], *psum[NMAX];
int upd[MAXNODES], *pupd[NMAX];
int nl[NMAX], nnodes;

void BuildHPDSegTrees() {
	int i, j, nextnnodes, l, r;

	for (i = 1, nnodes = 0; i <= np; i++) {
		nl[i] = 1;
		while (nl[i] < path[i].size())
			nl[i] <<= 1;
		psum[i] = sum + nnodes;
		pupd[i] = upd + nnodes;
		nextnnodes = nnodes + (2 * nl[i]);
		for (j = nl[i]; j < 2 * nl[i]; j++) psum[i][j] = 0;
		for (j = nl[i]; j < nl[i] + path[i].size(); j++)
			psum[i][j] = cnt[path[i][j - nl[i]]];
		for (j = nl[i] - 1; j >= 1; j--) {
			l = j << 1;
			r = l + 1;
			psum[i][j] = psum[i][l] + psum[i][r];
		}
		for (j = 1; j < 2 * nl[i]; j++) pupd[i][j] = 0;
		nnodes = nextnnodes;
	}
}

int QP, QMIN, QMAX, QOP, QUPD;
long long QANS;

void IntervalOpSegTree(int node, int li, int ls) {
	if (QMIN <= li && ls <= QMAX) {
		if (QOP == 1) {
			pupd[QP][node]--;
			psum[QP][node] -= (ls - li + 1);
		} else {
			QANS += psum[QP][node] + (long long) QUPD * (long long) (ls - li + 1);
		}
		return;
	}

	QUPD += pupd[QP][node];

	int lson = node << 1;
	int rson = lson + 1;
	int mid = (li + ls) >> 1;

	if (QMIN <= mid)
		IntervalOpSegTree(lson, li, mid);
	if (QMAX > mid)
		IntervalOpSegTree(rson, mid + 1, ls);

	if (QOP == 1)
		psum[QP][node] = psum[QP][lson] + psum[QP][rson] + (long long) (pupd[QP][node]) * (long long) (ls - li + 1);
	
	QUPD -= pupd[QP][node];
}

long long ans[NMAX], scnt, scnt2, scnttmp;

void ComputeAnswers() {
	int i, x;
	
	for (scnt = scnt2 = 0, i = 1; i <= N; i++) {
		scnt += cnt[i];
		scnt2 += (cnt[i] * cnt[i]);
	}

	QUPD = 0;
	for (i = N; i >= 1; i--) {
		if (DEBUG) fprintf(stderr, "i=%d scnt=%lld scnt2=%lld\n", i, scnt, scnt2);

		ans[i] = scnt * i - scnt2;
		scnt -= level[p[i]];
		scnttmp = 0;

		QP = nodepath[x = p[i]];
		QMIN = 1; QMAX = nodepozinpath[x] + 1;
		
		if (QMIN <= QMAX) {
			QANS = 0; QOP = 2;
			IntervalOpSegTree(1, 1, nl[QP]);
			scnttmp += QANS;
			QOP = 1;
			IntervalOpSegTree(1, 1, nl[QP]);
		}

		x = path[QP][0];

		while (x != root) {
			x = pathpnode[nodepath[x]];

			QP = nodepath[x];
			QMIN = 1; QMAX = nodepozinpath[x] + 1;
			
			QANS = 0; QOP = 2;
			IntervalOpSegTree(1, 1, nl[QP]);
			scnttmp += QANS;
			QOP = 1;
			IntervalOpSegTree(1, 1, nl[QP]);

			x = path[QP][0];
		}
	
		if (DEBUG)
			fprintf(stderr, "i=%d: p[i]=%d scnttmp=%lld\n", i, p[i], scnttmp);
		scnt2 = scnt2 - scnttmp * 2 + level[p[i]];
	}
}

void WriteAnswers() {
	int i;
	for (i = 1; i <= N; i++)
		printf("%lld\n", ans[i]);
}

int main() {
	ReadInput();
	BuildBST();
	BFS();
	BuildHPD();
	BuildHPDSegTrees();
	ComputeAnswers();
	WriteAnswers();
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.105
medium
----------
PROBLEM STATEMENT:
You are given a list of [expression] as: 
[expression] = 0. 
[expression] = 0.   

We define [expression] among all i.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

typedef long long     LL;
typedef pair<int,int> pii;

double PI  = acos(-1);
double EPS = 1e-7;
int INF    = 1000000000;
LL INFLL   = 1000000000000000000LL;

#define fi            first
#define se            second
#define mp            make_pair
#define pb            push_back

#define input(in)     freopen(in,"r",stdin)
#define output(out)   freopen(out,"w",stdout)

#define MIN(a, b)     (a) = min((a), (b))
#define MAX(a, b)     (a) = max((a), (b))

#define RESET(a, b)   memset(a,b,sizeof(a))
#define ALL(a)        (a).begin(), (a).end()
#define SIZE(a)       (int)a.size()
#define SORT(a)       sort(ALL(a))
#define UNIQUE(a)     (a).erase( unique( ALL(a) ), (a).end() )
#define FOR(a, b, c)  for (int (a)=(b); (a)<=(c); (a)++)
#define FORD(a, b, c) for (int (a)=(b); (a)>=(c); (a)--)
#define FORIT(a, b)   for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); a++)

int mx[8] = {-1,1,0,0,-1,-1,1,1};
int my[8] = {0,0,-1,1,-1,1,-1,1};

// ----- //

int x[100005];
int fl[100005];
int fr[100005];

int main()
{
	int n;
	scanf("%d",&n);
	FOR(a,1,n)
	{
		scanf("%d",&x[a]);
	}
	x[0] = INF+1;
	vector<int> stk;
	stk.pb(0);
	FOR(a,1,n) {
		while(x[stk.back()] <= x[a]) {
			stk.pop_back();
		}
		fl[a] = stk.back();
		stk.pb(a);
	}
	stk.clear();
	stk.pb(0);
	FORD(a,n,1) {
		while(x[stk.back()] <= x[a]) {
			stk.pop_back();
		}
		fr[a] = stk.back();
		stk.pb(a);
	}
	long long ans = 0;
	FOR(a,1,n) {
		MAX(ans,(LL)fl[a]*fr[a]);
	}
	cout << ans << endl;
}

----------
====================
----------
DATA-STRUCTURES.106
advanced
----------
PROBLEM STATEMENT:
Burger Town is a city that consists of [expression] is defined by the Taxicab geometry. 

Tim has recently afforded a taxicab to work as a taxicab driver. His vehicle was very cheap, but has a very big flaw. It can only drive [expression] units vertically before refueling. 

If a customer wants to be brought from a junction [expression] respectively. 

Also, there is a unique path between any two junctions.  



Now he has thoughts about returning the vehicle back to the seller. But he first wants to know, if it's even worth it. That's why he wants to know the number of unordered pairs [expression]. 

Input Format

On the first line you will be given [expression] separated by a single space. 
Each of the next [expression].
Each of the next [expression].  

Output Format

Output the number of unordered pairs [expression]. 

Constraints

[expression]

[expression]

[expression]

Sample Input

3 2 1
0 0
1 1
2 0
1 2
2 3


Sample Output

1


Explanation

The car is only capable of driving [expression].
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

#define FO(i,a,b) for (int i = (a); i < (b); i++)
#define sz(v) int(v.size())

using namespace std;

typedef long long ll;

typedef pair<ll,ll> E;
#define dx first
#define dy second
struct edge {
    int o;
    ll dx, dy;

    edge(int o=0, ll dx=0, ll dy=0) : o(o), dx(dx), dy(dy) {}
};

vector<edge> u[100005];
int n; ll DX, DY;
ll Y[100005], X[100005];
int sc[100005];

void delete_from(int x, int y) {
    FO(i,0,sz(u[x])) if (u[x][i].o == y) {
        swap(u[x][i],u[x].back());
        u[x].pop_back();
        return;
    }
}

void delete_node(int x) {
    FO(i,0,sz(u[x])) {
        delete_from(u[x][i].o,x);
    }
}

void resetsc(int x, int p) {
    sc[x] = 1;
    FO(i,0,sz(u[x])) if (u[x][i].o != p) {
        resetsc(u[x][i].o,x);
        sc[x] += sc[u[x][i].o];
    }
}

int find_centre(int x, int p, int tsz) {
    int lsz = tsz-sc[x];
    FO(i,0,sz(u[x])) if (u[x][i].o != p) {
        lsz = max(lsz, sc[u[x][i].o]);
        int y = find_centre(u[x][i].o,x,tsz);
        if (y != -1) return y;
    }
    if (2*lsz <= tsz+5) return x;
    return -1;
}

void getl(int x, int p, vector<E> &v, ll dx, ll dy) {
    if (dx != 0 || dy != 0) v.push_back(E(dx,dy));
    FO(i,0,sz(u[x])) if (u[x][i].o != p) {
        getl(u[x][i].o, x, v, dx+u[x][i].dx, dy+u[x][i].dy);
    }
}

bool cmp(E a, E b) {
    if (a.dx != b.dx) return a.dx < b.dx;
    else return a.dy < b.dy;
}

ll res;
vector<ll> bit;

void ub(int y, int dv) {
    for (;y<sz(bit);y+=y&-y) bit[y] += dv;
}

ll qb(int y) {
    ll r = 0;
    for (;y>0;y-=y&-y) r += bit[y];
    return r;
}

ll doitbf(vector<E> p) {
    ll RES = 0;
    FO(i,0,sz(p)) FO(j,0,i) if (p[i].dx+p[j].dx <= DX && p[i].dy+p[j].dy <= DY) RES++;
    return RES;
}

ll doit(vector<E> p) {
    //printf("DOIT\n");
    //FO(i,0,sz(p)) printf("%lld,%lld\n", p[i].dx, p[i].dy);
    ll RES = 0;
    vector<E> q;
    vector<ll> y;
    FO(i,0,sz(p)) {
        if (p[i].dx+p[i].dx <= DX && p[i].dy+p[i].dy <= DY) RES--;
        ll qdx = DX-p[i].dx;
        ll qdy = DY-p[i].dy;
        if (qdx >= 0 && qdy >= 0) q.push_back(E(qdx, qdy));
    }
    FO(i,0,sz(p)) y.push_back(p[i].dy);
    FO(i,0,sz(q)) y.push_back(q[i].dy);
    sort(y.begin(),y.end());
    y.resize(unique(y.begin(),y.end())-y.begin());
    bit.resize(sz(y)+5);
    FO(i,0,sz(bit)) bit[i] = 0;

    sort(p.begin(),p.end(),cmp);
    sort(q.begin(),q.end(),cmp);

    int pi = 0, qi = 0;
    while (qi < sz(q)) {
        if (pi < sz(p) && !cmp(q[qi],p[pi])) {
            int yv = lower_bound(y.begin(),y.end(),p[pi].dy)-y.begin()+1;
            ub(yv,1);
            pi++;
        } else {
            int yv = lower_bound(y.begin(),y.end(),q[qi].dy)-y.begin()+1;
            RES += qb(yv);
            qi++;
        }
    }
    RES /= 2;

    return RES;
}

void testdoit() {
    vector<E> v;
    DX = DY = 100;
    FO(i,0,1000) v.push_back(E(rand()%DX,rand()%DY));
    printf("%lld %lld\n", doit(v), doitbf(v));
}

void solve(int x) {
    if (sz(u[x]) == 0) return;
    resetsc(x,-1);
    x = find_centre(x,-1,sc[x]);
    vector<E> cv;
    cv.push_back(E(0,0));
    FO(i,0,sz(u[x])) {
        vector<E> v;
        getl(u[x][i].o,x,v,u[x][i].dx,u[x][i].dy);
        res -= doit(v);
        FO(j,0,sz(v)) cv.push_back(v[j]);
    }
    res += doit(cv);
    delete_node(x);
    FO(i,0,sz(u[x])) solve(u[x][i].o);
}

int main() {
    //testdoit();
    //return 0;

    scanf("%d %lld %lld", &n, &DX, &DY);
    FO(i,0,n) {
        scanf("%lld %lld", &X[i], &Y[i]);
    }
    FO(i,0,n-1) {
        int a,b; scanf("%d %d", &a, &b); a--; b--;
        u[a].push_back(edge(b,abs(X[a]-X[b]),abs(Y[a]-Y[b])));
        u[b].push_back(edge(a,abs(X[a]-X[b]),abs(Y[a]-Y[b])));
    }
    solve(0);
    ll T = (n * 1ll * (n-1)) / 2;
    printf("%lld\n", T - res);
}


----------
====================
----------
DATA-STRUCTURES.107
advanced
----------
PROBLEM STATEMENT:
Jaggu is a little kid and he likes playing with water balloons. He took 1 million ( 106 ) empty buckets and he filled the bucket with water balloons under the instruction of his sister Ishika. 
His sister gives him two types of commands:

R pos1 pos2 which implies that jaggu needs to tell her what is the total number of water balloons in the bucket from pos1 to pos2 (both included).

U pos M plus which implies that he has to work like the function 

Update(pos,M,plus)

void Update(int pos,int M,int plus)
{
    int N=1000000;  //1 million
    for (int i=1;i<=50;i++)
    {
        int back = pos
        for(int j=1;j<=1000;j++)
        {
            add M water ballons at bucket pos
            int s,in=__builtin_popcount(pos);
            for(int k=0;;k++)
            {
                s=pos+pow(2,k)
                if( __builtin_popcount(s) <= in )
                {
                    in = __builtin_popcount(s)
                    pos = s;
                    if(posN)       break;
                    add M water ballons at bucket pos
                }
            }
            pos = pos - N
        }
        pos = back+plus;
        if(posN) pos-=N;
    }
}


Jaggu is too lazy to put the water ballons in the bucket. Afraid that he might be caught for not doing what his sister told him to do so, he asks your help to provide correct answers  for each of his sister's query. .

Input Format

First line contains Q, number of queries to follow.

Next Q line follows , which can be either an Update Query or Report Query.Each Update Query is followed by atleast 1 report query.

Output Format

For each report query , output the answer in a separate line.

Constraints

1 ≤ Q ≤ 2 * 105

1 ≤ pos1,pos2,pos ≤ 106

pos1 ≤ pos2

1 ≤ M ≤ 10

1 ≤ plus ≤ 999999

Sample Input

2
U 692778 7 291188
R 636916 747794


Sample Output

378 


Explanation

Follow the code above to get the answer.

Note 


Input is randomly generated.
__builtin_popcount(x) gives the number of set bits in binary representation of x.
pow(2,k) denotes 2 raised to k , i.e. exponentiation of 2.


Timelimit is 3 times the timelimit mentioned here
----------
TOP SOLUTION:
----------
//jagia-playing-with-numbers.cpp
//Jaggu Playing with Balloons
//Weekly Challenges - Week 5
//Author: derekhh

#include<iostream>
#include<string>
using namespace std;

long long tree[1000001];
int bitcount[2000001];

void init()
{
	for (int i = 0; i <= 2000000; i++)
		for (int j = 0; j < 32; j++)
			if (i&(1 << j))
				bitcount[i]++;
}

void update(int idx, int val)
{
	while (idx <= 1000000)
	{
		tree[idx] += val;
		idx += (idx & -idx);
	}
}

long long read(int idx)
{
	long long sum = 0;
	while (idx > 0)
	{
		sum += tree[idx];
		idx -= (idx & -idx);
	}
	return sum;
}

void update(int pos, int M, int plus)
{
	int N = 1000000;
	for (int i = 1; i <= 50; i++)
	{
		int back = pos, j;
		for (j = 1; j <= 1000; j++)
		{
			int s, in = bitcount[pos];
			if (pos == 48576) break;
			update(pos, M);
			for (int k = 0;; k++)
			{
				s = pos + (k == 0 ? 1 : (1 << (k - 1)));
				if (bitcount[s] <= in)
				{
					in = bitcount[s];
					pos = s;
					if (pos > N) break;
					update(pos, M);
				}
			}
			pos -= N;
		}

		update(48576, (1000 - j + 1) * M);
		update(48640, (1000 - j + 1) * M);
		update(49152, (1000 - j + 1) * M);
		update(65536, (1000 - j + 1) * M);
		update(131072, (1000 - j + 1) * M);
		update(262144, (1000 - j + 1) * M);
		update(524288, (1000 - j + 1) * M);

		pos = back + plus;
		if (pos > N) pos -= N;
	}
}

int main()
{
	int q;
	cin >> q;
	init();
	while (q--)
	{
		char ch;
		cin >> ch;
		if (ch == 'U')
		{
			int pos, M, plus;
			cin >> pos >> M >> plus;
			update(pos, M, plus);
		}
		else
		{
			int pos1, pos2;
			cin >> pos1 >> pos2;
			long long sum1 = read(pos1 - 1);
			long long sum2 = read(pos2);
			cout << sum2 - sum1 << endl;
		}
	}
	return 0;
}
----------
====================
----------
DATA-STRUCTURES.108
hard
----------
PROBLEM STATEMENT:
Given a tree of N nodes, where each node is uniquely numbered in between [1, N]. Each node also has a value which is initially 0. You need to perform following two operations in the tree.  


Update Operation
Report Operation


Update Operation

U r t a b


Adds ab + (a+1)b + (b+1)a to all nodes in the subtree rooted at t, considering that tree is rooted at r (see explanation for more details).  

Report Operation

R r t m


Output the sum of all nodes in the subtree rooted at t, considering that tree is rooted at r. Output the sum modulo m (see explanation for more details).

Input Format

First line contains N, number of nodes in the tree. 
Next N-1 lines contain two space separated integers x and y which denote that there is an edge between node x and node y. 
Next line contains Q, number of queries to follow. 
Next Q lines follow, each line will be either a report operation or an update operation.  

Output Format

For each report query output the answer in a separate line.

Constraints

1 ≤ N ≤ 100000 
1 ≤ Q ≤ 100000 
1 ≤ m ≤ 101 
1 ≤ r, t, x, y ≤ N 
x ≠ y 
1 ≤ a, b ≤ 1018  

Notes


There will be at most one edge between a pair of nodes.
There will be no loop.
Tree will be completely connected. 


Sample Input

4
1 2
2 3
3 4
4
U 3 2 2 2
U 2 3 2 2
R 1 2 8
R 4 3 9


Sample Output

2
3


Explanation

Initially Values in each node : [0,0,0,0] 
The first query is U 3 2 2 2. Here, tree is rooted at 3. It looks like 

    3(0)
   / \
  /   \
 2(0)  4(0)
 |
 |
 1(0)


For the sub tree rooted at 2 ( nodes 2 and 1 ), we add ab  + (a+1)b + (b+1)a = 22 + 32 + 32 = 22. After first update operation, nodes 1, 2, 3, and 4 will have values 22, 22, 0 and 0 respectively.  

    3(0)
   / \
  /   \
 2(22) 4(0)
 |
 |
 1(22)


The second query is U 2 3 2 2. Here, tree is rooted at 2. It looks like

    2(22)
   / \
  /   \
 1(22) 3(0)
       |
       |
       4(0)


For the sub tree rooted at 3 (nodes 3 and 4), we add ab + (a+1)b + (b+1)a = 22 + 32 + 32 = 22. After second update operation, nodes 1, 2, 3, and 4 each have values 22,22,22,22 respectively.  

    2(22)
   / \
  /   \
 1(22) 3(22)
       |
       |
       4(22)


The first report query is R 1 2 8 asks for the sum modulo 8 of the subtree rooted at 2, when the tree is rooted at 1. The tree looks like 

1(22)
 \
  \
   2*(22)
   |
   |
   3*(22)
   |
   |
   4*(22)


The sum of the values of nodes 2, 3 and 4 are 

(22 + 22 + 22) % 8 = 2


The second report query is R 4 3 9 asks for the sum modulo 9 of the subtree rooted at 3 when the tree is rooted at 4. The tree looks like 

4(22)
 \
  \
   3*(22)
   |
   |
   2*(22)
   |
   |
   1*(22)


The sum of the values of nodes 3, 2 and 1 are 

(22 + 22 + 22) % 9 = 3


Time Limits: 
C, C++: 4s | Java and other JVM based languages: 10s | Python, Python3 = 45s | Other interpreted Language: 30s | C#, Haskell: 10s | Rest: 3 times of default. 

----------
TOP SOLUTION:
----------
//dynamic-summation.cpp
//Dynamic Summation
//Weekly Challenges - Week 6
//Author: derekhh

#include<cstdio>
#include<vector>
using namespace std;

const int MAXN = 100000;

vector<int> v[MAXN + 1];
vector<int> child[MAXN + 1];
bool visited[MAXN + 1];
int startTime[MAXN + 1], endTime[MAXN + 1];

int dfs(int now, int start)
{
	startTime[now] = start;
	visited[now] = true;
	int sz = (int)v[now].size();
	for (int i = 0; i < sz; i++)
	{
		if (!visited[v[now][i]])
		{
			child[now].push_back(v[now][i]);
			start = dfs(v[now][i], start + 1);
		}
	}
	endTime[now] = start;
	return start;
}

const int NMOD = 6;
int MOD[NMOD] = { 11 * 13 * 17 * 19 * 23 * 25 * 29, 31 * 37 * 41 * 43 * 47, 49 * 53 * 59 * 61 * 64, 67 * 71 * 73 * 79, 81 * 83 * 89 * 97, 101 };
int p[26] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101 };

int modidx[102];

int gcd(int a, int b)
{
	return b ? gcd(b, a%b) : a;
}

void init()
{
	for (int i = 1; i <= 101; i++)
	{
		for (int j = 0; j < NMOD; j++)
		{
			if (gcd(i, MOD[j]) != 1)
			{
				modidx[i] = j;
				break;
			}
		}
	}
}

long long tree[NMOD][4 * MAXN], lazy[NMOD][4 * MAXN];

long long ext_euclid(long long a, long long b, long long& x, long long& y)
{
	long long t, d;
	if (b == 0) { x = 1; y = 0; return a; }
	d = ext_euclid(b, a%b, x, y);
	t = x, x = y, y = t - a / b*y;
	return d;
}

long long linear_modular_equation_system(long long B[], long long W[], long long k)
{
	long long d, x, y, m, n = 1;
	long long a = 0;
	for (long long i = 0; i < k; i++)
		n *= W[i];
	for (long long i = 0; i < k; i++)
	{
		m = n / W[i];
		d = ext_euclid(W[i], m, x, y);
		while (y < 0) y += W[i];
		a += y * (m * B[i] % n);
	}
	while (a < 0) a += n;
	return a % n;
}

/*
long long linear_modular_equation_system(long long B[], long long W[], long long k)
{
	long long d, x, y, m, n = 1;
	long long a = 0;
	for (long long i = 0; i < k; i++)
		n *= W[i];
	for (long long i = 0; i < k; i++)
	{
		m = n / W[i];
		d = ext_euclid(W[i], m, x, y);
		a = (a + y*m*B[i]) % n;
	}
	if (a>0) return a;
	else return a + n;
}
*/

void updateTree(long long node, long long a, long long b, long long i, long long j, long long value, long long modidx)
{
	if (lazy[modidx][node] != 0)
	{
		tree[modidx][node] = (tree[modidx][node] + (long long)(b - a + 1) * lazy[modidx][node]) % MOD[modidx];

		if (a != b)
		{
			lazy[modidx][node * 2] = (lazy[modidx][node * 2] + lazy[modidx][node]) % MOD[modidx];
			lazy[modidx][node * 2 + 1] = (lazy[modidx][node * 2 + 1] + lazy[modidx][node]) % MOD[modidx];
		}

		lazy[modidx][node] = 0;
	}

	if (a > b || a > j || b < i) return;

	if (a >= i && b <= j)
	{
		tree[modidx][node] = (tree[modidx][node] + (long long)(b - a + 1) * value) % MOD[modidx];

		if (a != b)
		{
			lazy[modidx][node * 2] = (lazy[modidx][node * 2] + value) % MOD[modidx];
			lazy[modidx][node * 2 + 1] = (lazy[modidx][node * 2 + 1] + value) % MOD[modidx];
		}

		return;
	}

	updateTree(node * 2, a, (a + b) / 2, i, j, value, modidx);
	updateTree(node * 2 + 1, (a + b) / 2 + 1, b, i, j, value, modidx);

	tree[modidx][node] = (tree[modidx][node * 2] + tree[modidx][node * 2 + 1]) % MOD[modidx];
}

long long queryTree(long long node, long long a, long long b, long long i, long long j, long long modidx)
{
	if (a > b || a > j || b < i) return 0;

	if (lazy[modidx][node] != 0)
	{
		tree[modidx][node] = (tree[modidx][node] + (long long)(b - a + 1) * lazy[modidx][node]) % MOD[modidx];
		if (a != b)
		{
			lazy[modidx][node * 2] = (lazy[modidx][node * 2] + lazy[modidx][node]) % MOD[modidx];
			lazy[modidx][node * 2 + 1] = (lazy[modidx][node * 2 + 1] + lazy[modidx][node]) % MOD[modidx];
		}
		lazy[modidx][node] = 0;
	}

	if (a >= i && b <= j) return tree[modidx][node];

	long long q1 = queryTree(node * 2, a, (a + b) / 2, i, j, modidx);
	long long q2 = queryTree(node * 2 + 1, (a + b) / 2 + 1, b, i, j, modidx);
	long long tmp = q1 + q2;
	return tmp % MOD[modidx];
}

long long ModExp(long long a, long long b, long long mod)
{
	a %= mod;
	long long c = 1, d = a;
	while (b)
	{
		if (b & 1) c = (c*d) % mod;
		d = (d*d) % mod;
		b >>= 1;
	}
	return c;
}

long long calc(long long a, long long b, long long mod)
{
	long long sum1 = ModExp(a, b, mod);
	long long sum2 = ModExp(a + 1, b, mod);
	long long sum3 = ModExp(b + 1, a, mod);
	return (sum1 + sum2 + sum3) % mod;
}

int binarySearchChild(int root, int st, int en)
{
	int lo = 0, hi = (int)child[root].size(), mid = 0;

	while (lo < hi - 1)
	{
		mid = (lo + hi) / 2;
		int st_mid = startTime[child[root][mid]];
		int en_mid = endTime[child[root][mid]];

		if (st >= st_mid && en <= en_mid) return mid;
		else if (en <= st_mid) hi = mid;
		else lo = mid + 1;
	}
	return lo;
}

int main()
{
	init();

	int n;
	scanf("%d", &n);
	for (int i = 0; i < n - 1; i++)
	{
		int x, y;
		scanf("%d%d", &x, &y);
		v[x].push_back(y);
		v[y].push_back(x);
	}
	dfs(1, 1);

	int q;
	scanf("%d", &q);
	getchar();
	while (q--)
	{
		char ch;
		int r, t, m;
		long long a, b;
		ch = getchar();
		if (ch == 'U')
		{
			scanf("%d%d%lld%lld", &r, &t, &a, &b);
			getchar();

			int sr = startTime[r], er = endTime[r];
			int st = startTime[t], et = endTime[t];

			long long val[NMOD];

			for (long long i = 0; i < NMOD; i++)
				val[i] = calc(a, b, MOD[i]);

			if (sr == st && er == et)
			{
				for (long long i = 0; i < NMOD; i++)
					updateTree(1, startTime[1], endTime[1], startTime[1], endTime[1], val[i], i);
			}
			else if (sr > st && er <= et)
			{
				for (long long i = 0; i < NMOD; i++)
					updateTree(1, startTime[1], endTime[1], startTime[1], endTime[1], val[i], i);
				int childIdx = binarySearchChild(t, sr, er);
				for (long long i = 0; i < NMOD; i++)
					updateTree(1, startTime[1], endTime[1], startTime[child[t][childIdx]], endTime[child[t][childIdx]], MOD[i] - val[i], i);
			}
			else
			{
				for (long long i = 0; i < NMOD; i++)
					updateTree(1, startTime[1], endTime[1], st, et, val[i], i);
			}
		}
		else
		{
			scanf("%d%d%d", &r, &t, &m);
			getchar();

			if (m == 1)
			{
				printf("0\n");
				continue;
			}

			int sr = startTime[r], er = endTime[r];
			int st = startTime[t], et = endTime[t];

			int _m = m;

			long long W[6], B[6], k = 0;
			for (int i = 0; i < 26; i++)
			{
				int tmp = 1;
				bool flag = false;
				while (m % p[i] == 0)
				{
					flag = true;
					m /= p[i];
					tmp *= p[i];
				}
				if (flag)
					W[k++] = tmp;
			}

			if (sr == st && er == et)
			{
				for (int i = 0; i < k; i++)
				{
					B[i] = queryTree(1, startTime[1], endTime[1], startTime[1], endTime[1], modidx[W[i]]) % W[i];
					//cerr << "Case 1: B[" << i << "] = " << B[i] << endl;
				}
				printf("%lld\n", linear_modular_equation_system(B, W, k) % _m);
			}
			else if (sr > st && er <= et)
			{
				int childIdx = binarySearchChild(t, sr, er);
				for (int i = 0; i < k; i++)
				{
					long long tmp1 = queryTree(1, startTime[1], endTime[1], startTime[1], endTime[1], modidx[W[i]]) % W[i];
					long long tmp2 = queryTree(1, startTime[1], endTime[1], startTime[child[t][childIdx]], endTime[child[t][childIdx]], modidx[W[i]]) % W[i];
					B[i] = (tmp1 + W[i] - tmp2) % W[i];
				}
				printf("%lld\n", linear_modular_equation_system(B, W, k) % _m);
			}
			else
			{
				for (int i = 0; i < k; i++)
					B[i] = queryTree(1, startTime[1], endTime[1], st, et, modidx[W[i]]) % W[i];
				printf("%lld\n", linear_modular_equation_system(B, W, k) % _m);
			}
		}
	}
	return 0;
}
----------
====================
----------
DATA-STRUCTURES.109
hard
----------
PROBLEM STATEMENT:
In this problem you operate on two arrays of [expression] respectively. 
Your goal is just to maintain them under the modification operations, such as:   


1 [expression] number, inclusively;  
2 [expression];  
3 [expression] array;  
4 [expression]-coordinates of them. For the obtained set of points we would like to place such a circle on a plane that would contain all the points in it and would have the minimal radius. Find this minimal radius.  


Input Format 
The first line of input contains two space separated integers [expression] denoting the number of integers in arrays and the number of queries respectively. 
The second line contains [expression] array. 
The third line contains [expression] array. 
Then there are [expression] lines containing queries in the format listed above.  

Output Format 
For each type-4 query output the sought minimal radius with exactly two symbols after the decimal point precision.  

Constraints 
[expression] 
All the numbers in arrays are non-negative and don't exceed [expression]. 
The sum of [expression]. 
In the query of the type 2, [expression]. 
In the queries of the types 1, 3, 4, [expression].

Sample Input

10 10
1 2 3 4 5 6 7 8 9 10
1 2 3 4 5 6 7 8 9 10
3 2 6
1 0 9 9
4 6 9
2 0 2 7 9 9
1 0 3 6
2 1 2 3 4 5
1 1 7 10
2 1 8 8 9 10
4 6 9
2 0 2 2 4 6


Example Output

2.12
2.50

----------
TOP SOLUTION:
----------
// {{{ by shik
#include <bits/stdc++.h>
#include <unistd.h>
#define SZ(x) ((int)(x).size())
#define REP(i,n) for ( int i=0; i<int(n); i++ )
#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )
#define FOR(it,c) for ( __typeof((c).begin()) it=(c).begin(); it!=(c).end(); it++ )
#define MP make_pair
#define PB push_back
using namespace std;
typedef long long LL;
typedef pair<int,int> PII;
typedef vector<int> VI;

void RI() {}

template<typename... T>
void RI( int& head, T&... tail ) {
    scanf("%d",&head);
    RI(tail...);
}
// }}}

const int INF=0x7FFFFFFF;
const int N=400010;
const double eps=1e-6;

struct P { double x,y; } p[N],q[3];
double dis2( P a, P b ) { return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y); }
P operator -( P a, P b ) { return (P){a.x-b.x,a.y-b.y}; }
P operator +( P a, P b ) { return (P){a.x+b.x,a.y+b.y}; }
P operator /( P a, double b ) { return (P){a.x/b,a.y/b}; }
double abs2( P a ) { return a.x*a.x+a.y*a.y; }
double dot( P a, P b ) { return a.x*b.x+a.y*b.y; }
double X( P a, P b ) { return a.x*b.y-a.y*b.x; }
double X( P a, P b, P c ) { return X(b-a,c-a); }
struct C {
    P o; double r2;
    C() { o.x=o.y=r2=0; }
    C( P a ) { o=a; r2=0; }
    C( P a, P b ) { o=(a+b)/2; r2=dis2(o,a); }
    C( P a, P b, P c ) {
        double i,j,k,A=2*X(a,b,c)*X(a,b,c);
        i=abs2(b-c)*dot(a-b,a-c);
        j=abs2(a-c)*dot(b-a,b-c);
        k=abs2(a-b)*dot(c-a,c-b);
        o.x=(i*a.x+j*b.x+k*c.x)/A;
        o.y=(i*a.y+j*b.y+k*c.y)/A;
        r2=dis2(o,a);
    }
    bool cover( P a ) { return dis2(o,a)<=r2+eps; }
};
C MEC( int n, int m ) {
    C mec;
    if ( m==1 ) mec=C(q[0]);
    else if ( m==2 ) mec=C(q[0],q[1]);
    else if ( m==3 ) return C(q[0],q[1],q[2]);
    for ( int i=0; i<n; i++ )
        if ( !mec.cover(p[i]) ) {
            q[m]=p[i];
            mec=MEC(i,m+1);
        }
    return mec;
}

int my_rand() {
    static int seed;
    return seed=seed*1103515245+12345;
}
struct Treap {
    static Treap mem[N],*pmem;
    Treap *l,*r;
    int rnd,size,val;
    bool rev;
    Treap() {}
    Treap( int _val ):l(NULL),r(NULL),rnd(rand()),size(1),val(_val),rev(false) {}
} Treap::mem[N],*Treap::pmem=Treap::mem;
inline int size( Treap *t ) { return t?t->size:0; }
inline void push( Treap *t ) {
    if ( !t ) return;
    if ( t->rev ) {
        if ( t->l ) t->l->rev^=1;
        if ( t->r ) t->r->rev^=1;
        swap(t->l,t->r);
        t->rev=false;
    }
}
inline void pull( Treap *t ) {
    if ( !t ) return;
    t->size=size(t->l)+size(t->r)+1;
}
Treap* merge( Treap *a, Treap *b ) {
    if ( !a || !b ) return a?a:b;
    if ( a->rnd < b->rnd ) {
        push(a);
        a->r=merge(a->r,b);
        pull(a);
        return a;
    } else {
        push(b);
        b->l=merge(a,b->l);
        pull(b);
        return b;
    }
}
void split( Treap *t, int k, Treap *&a, Treap *&b ) {
    push(t);
    if ( !t ) a=b=NULL;
    else if ( k<=size(t->l) ) {
        b=t;
        split(t->l,k,a,b->l);
        pull(b);
    } else {
        a=t;
        split(t->r,k-size(t->l)-1,a->r,b);
        pull(a);
    }
}

void go( Treap *t, vector<int> &v ) {
    if ( !t ) return;
    push(t);
    go(t->l,v);
    v.PB(t->val);
    go(t->r,v);
}

Treap* input( int n ) {
    Treap *t=NULL;
    REP1(i,1,n) {
        int x;
        RI(x);
        t=merge(t,new (Treap::pmem++) Treap(x));
    }
    return t;
}

Treap *t[2];

int main() {
    srand(time(0)^getpid()^514514514);
    int n,m;
    RI(n,m);
    REP(i,2) t[i]=input(n);
    while ( m-- ) {
        int op;
        RI(op);
        if ( op==1 ) {
            int id,l,r;
            RI(id,l,r);
            Treap *tl,*tr;
            split(t[id],l-1,tl,t[id]);
            split(t[id],r-l+1,t[id],tr);
            t[id]->rev^=1;
            t[id]=merge(merge(tl,t[id]),tr);
        } else if ( op==2 ) {
            int id,l1,r1,l2,r2;
            RI(id,l1,r1,l2,r2);
            Treap *t1,*t2,*t3,*t4,*t5;
            split(t[id],l1-1,t1,t[id]);
            split(t[id],r1-l1+1,t2,t[id]);
            split(t[id],l2-r1-1,t3,t[id]);
            split(t[id],r2-l2+1,t4,t5);
            t[id]=merge(merge(merge(merge(t1,t4),t3),t2),t5);
        } else if ( op==3 ) {
            int l,r;
            RI(l,r);
            Treap *tl[2],*tm[2],*tr[2];
            REP(i,2) {
                split(t[i],l-1,tl[i],t[i]);
                split(t[i],r-l+1,tm[i],tr[i]);
            }
            t[0]=merge(merge(tl[0],tm[1]),tr[0]);
            t[1]=merge(merge(tl[1],tm[0]),tr[1]);
        } else if ( op==4 ) {
            int l,r;
            RI(l,r);
            vector<int> v[2];
            REP(i,2) {
                Treap *tl,*tr;
                split(t[i],l-1,tl,t[i]);
                split(t[i],r-l+1,t[i],tr);
                go(t[i],v[i]);
                t[i]=merge(merge(tl,t[i]),tr);
            }
            assert(v[0].size() == v[1].size());
            int vn=SZ(v[0]);
            REP(i,vn) {
                p[i].x=v[0][i];
                p[i].y=v[1][i];
            }
            random_shuffle(p,p+vn);
            C c=MEC(vn,0);
            double ans=sqrt(c.r2);
            printf("%.2f\n",ans);
        }
    }
    return 0;
}

----------
====================
----------
DATA-STRUCTURES.110
hard
----------
PROBLEM STATEMENT:
You are given a rooted tree with N nodes and the root of the tree, R, is also given. Each node of the tree contains a value, that is initially empty. You have to mantain the tree under two operations:


Update Operation
Report Operation


Update Operation 
Each Update Operation begins with the character U. Character U is followed by 3 integers T, V and K. For every node which is the descendent of the node T, update it's value by adding V + d*K, where V and K are the parameters of the query and d is the distance of the node from T. Note that V is added to node T.  

Report Operation 
Each Report Operation begins with the character Q. Character Q is followed by 2 integers, A and B. Output the sum of values of nodes in the path from A to B modulo (109 + 7)  

Input Format 
The first Line consists of 3 space separated integers, N E R, where N is the number of nodes present, E is the total number of queries (update + report), and R is root of the tree.  

Each of the next N-1 lines contains 2 space separated integers, X and Y (X and Y are connected by an edge).

Thereafter, E lines follows: each line can represent either the Update Operation or the Report Operation.


Update Operation is of the form : U T V K.
Report Operation is of the form : Q A B.


Output Format 
Output the answer for every given report operation.

Constraints  

1 ≤ N, E ≤ 105 
1 ≤ E ≤ 105 
1 ≤ R, X, Y, T, A, B ≤ N 
1 ≤ V, K ≤ 109 
X ≠ Y

Sample Input

7 7 1
1 2
2 3
2 4
2 5
5 6
6 7
U 5 10 2
U 4 5 3
Q 1 7
U 6 7 4
Q 2 7
Q 1 4
Q 2 4


Sample Output

36
54
5
5


Explanation  


Values of Nodes after U 5 10 2: [0 0 0 0 10 12 14].
Values of Nodes after U 4 5 3: [0 0 0 5 10 12 14]. 
Sum of the Nodes from 1 to 7: 0 + 0 + 10 + 12 + 14 = 36.
Values of Nodes after U 6 7 4: [0 0 0 5 10 19 25].  
Sum of the Nodes from 2 to 7: 0 + 10 + 19 + 25 = 54. 
Sum of the Nodes from 1 to 4: 0 + 0 + 5 = 5.
Sum of the Nodes from 2 to 4: 0 + 5 = 5.

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cmath>
#include <iostream>
#include <set>
#include <algorithm>
#include <vector>
#include <map>
#include <cassert>
#include <string>
#include <cstring>

using namespace std;

#define rep(i,a,b) for(int i = a; i < b; i++)
#define S(x) scanf("%d",&x)
#define P(x) printf("%d\n",x)

typedef long long int LL;
const int mod = 1000000007;
const int MAXN = 100005;
vector<int > g[MAXN];
int dep[MAXN];
int P[MAXN];
int _tm;
int tin[2*MAXN];
int tout[2*MAXN];
int n;
int L[MAXN][25];

LL bit1[2*MAXN], bit2[2*MAXN], bit3[2*MAXN];

LL _pow(LL a, LL b) {
	if(!b) return 1;
	if(b == 1) return a;
	if(b == 2) return (a*a) % mod;
	if(b&1) return (a*_pow(a,b-1)) % mod;
	return _pow(_pow(a,b/2),2);
}

void dfs(int c, int p, int d) {
	P[c] = p;
	dep[c] = d;
	_tm++;
	tin[c] = _tm;
	rep(i,0,g[c].size()) {
		int u = g[c][i];
		if(u != p) dfs(u, c, d+1);
	}
	_tm++;
	tout[c] = _tm;
}

void processLca() {

	int i, j;
   
  //we initialize every element in P with -1
	int N = n;
      for (i = 0; i < n; i++)
          for (j = 0; 1 << j < N; j++)
              L[i][j] = -1;
   
  //the first ancestor of every node i is T[i]
      for (i = 0; i < N; i++)
          L[i][0] = P[i];
   
  //bottom up dynamic programing
      for (j = 1; 1 << j < N; j++)
         for (i = 0; i < N; i++)
             if (L[i][j - 1] != -1)
                 L[i][j] = L[L[i][j - 1]][j - 1];

}

int lca(int p, int q)
  {
      int tmp, log, i;
   
  //if p is situated on a higher level than q then we swap them
      if (dep[p] < dep[q])
          tmp = p, p = q, q = tmp;
  
  //we compute the value of [log(L[p)]
      for (log = 1; 1 << log <= dep[p]; log++);
      log--;
   
  //we find the ancestor of node p situated on the same level
  //with q using the values in P
      for (i = log; i >= 0; i--)
          if (dep[p] - (1 << i) >= dep[q])
              p = L[p][i];
   
      if (p == q)
          return p;
   
  //we compute LCA(p, q) using the values in P
      for (i = log; i >= 0; i--)
          if (L[p][i] != -1 && L[p][i] != L[q][i])
              p = L[p][i], q = L[q][i];
   
      return P[p];
  }


void update(LL *bit, int idx, LL val) {
	for(int i = idx; i <= _tm; i += i & -i) bit[i] += val;
}

LL query(LL *bit, int idx) {
	LL res = 0;
	for(int i = idx; i; i -= i & -i) {
		res += bit[i];
	}
	return res % mod;
}

LL QQQ(int x) {
	LL res;
	LL c = dep[x];
	res = (query(bit1, tin[x]) * c) % mod;
	res += (query(bit2, tin[x]) * (((LL)c*c)%mod));
	res %= mod;
	res += query(bit3, tin[x]);
	return res % mod;
}

int main() {
	int e,r;
	scanf("%d%d%d",&n,&e,&r);
	r--;

	rep(i,0,n-1) {
		int x,y;
		scanf("%d%d",&x,&y);
		x--;y--;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	dfs(r,-1,0);
	processLca();

	while(e--) {
		char s[5];
		scanf("%s",s);
		if(s[0] == 'U') {
			int T,V,K;
			scanf("%d%d%d",&T,&V,&K);
			T--;
			LL k = ((LL)K * _pow(2,mod-2)) % mod;
			LL p = dep[T];
			LL val;
			// printf("%d %d %lld %lld\n",tin[T],tout[T],k,p);

			val = (V-2*p*k+k) % mod;
			val = (val + mod) % mod;
			// printf("%lld\n",val);
			update(bit1, tin[T], val);
			update(bit1, tout[T]+1, -val);

			val = k;
			// printf("%lld\n",val);
			update(bit2, tin[T], val);
			update(bit2, tout[T]+1, -val);

			val = (p*p) % mod;
			val = (val*k) % mod;
			val -= p*(V+k);
			val %= mod;
			val += mod+V;
			val %= mod;
			// printf("%lld\n",val);
			update(bit3, tin[T], val);
			update(bit3, tout[T]+1, -val);

		} else {
			int A,B;
			scanf("%d%d",&A,&B);
			A--;B--;
			LL ans = 0;
			int l = lca(A,B);

			ans = QQQ(A)+QQQ(B)-QQQ(l);
			if(P[l] != -1) ans -= QQQ(P[l]);
			// printf("%lld %lld %lld %d\n",QQQ(A),QQQ(B),QQQ(l),l);
			ans %= mod;
			ans += mod;
			ans %= mod;
			printf("%lld\n",ans);
		}
	}
	return 0;
}
----------
====================
----------
DATA-STRUCTURES.111
advanced
----------
PROBLEM STATEMENT:
Natural numbers from 1 to N have been placed in an increasing order over some helix ( a circular structure ). When the helix starts rotating, it is easy to find out 


The position of a given number
The number located at a given position. 


The helix has numbers arranged in the following fashion:  

[1, 2, 3, ..., N]


Due to some malfunction, the helix has started rotating in a weird manner. Right now, every possible contiguous interval can be rotated, and hence, locating a particular number or identifying the number at a given position is almost impossible. For example, if at some particular instant, the integer list is like this:

[1, 2, 3, 4, 5, ..., N]


rotating the interval [5...N] will leave the list like this:

[1, 2, 3, 4, N, N - 1, N - 2, ..., 5]


We need a software to handle this. Can you help us?

Input Format 
The first line of the input consists of two space separated integers, N, Q. N signifies that initially our list contains numbers from 1 to N, placed in an increasing order. Q lines follow and contain input in one of the following formats:  

1 A B


indicating that the helix rotated circularly in the interval [A..B] ( both inclusive);

2 A


indicating that we are interested in knowing the current position of the number A  

3 A


indicating that we are interested in knowing the number at position A.  

Output Format 
For each line in the input of the form 2 A  

output a line saying 

element A is at position x


where A is the number we are interested in and x is its current position.

For each line of the form 3 A

output a line saying 

element at position A is x


where A is the position we are interested in and x is the integer located at this position. 

Constraints  

1 ≤ N, Q ≤ 105 
positions are 1-indexed.   

Sample Input

5 10
1 1 3
2 3
3 3
1 3 5
1 2 4
3 1
3 5
2 4
1 5 5
2 2


Sample Output

element 3 is at position 1
element at position 3 is 1
element at position 1 is 3
element at position 5 is 1
element 4 is at position 2
element 2 is at position 4


Explanation

Initially elements are placed like this:

[1, 2, 3, 4, 5]


after the first rotation, they are placed like this:

[3, 2, 1, 4, 5]


and that's how we get the first 2 results (first 2 lines in the output). After second rotation, they are placed like this:

[3, 2, 5, 4, 1]


and third one does this:

[3, 4, 5, 2, 1]


In the last rotation (1 5 5), it's easy to see that output matches the initial positions of the elements. Last rotation doesn't change the positions of the elements.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <string>
#include <string.h>
#include <queue>
#include <math.h>
#include <cmath>
#include <map>
#include <set>
#include <vector>
#include <algorithm>
#include <bitset>
#include <ctype.h>
#include <cassert>
#include <stack>
#include <fstream>
#include <unordered_set>

using namespace std;

#define snd second
#define fst first
#define mp make_pair
#define ll long long
#define ull unsigned long long
#define ld long double
#define pb push_back
#define left _left
#define y1 _y1

template < typename T > T abs(T x)
{
	return x > 0 ? x : -x;
}

struct node
{
	node *l, *r, *p;
	int key, pr;
	int size;
	
	bool rev;
	
	node()
	{
		l = r = p = NULL;
		pr = rand();
		size = 1;
		rev = false;
	}
	
	void push()
	{
		if (rev)
		{
			if (l)
				l->rev ^= 1;
			if (r)
				r->rev ^= 1;
			swap(l, r);
			rev = false;
		}
	}
	
	void update()
	{
		size = 1 + (l ? l->size : 0) + (r ? r->size : 0);
	}
};

int getSize(node *v)
{
	return v ? v->size : 0;
}

typedef node* pnode;

pnode merge(pnode l, pnode r)
{
	if (!l || !r)
		return l ? l : r;
		
	l->push();
	r->push();
		
	if (l->pr > r->pr)
	{
		l->r = merge(l->r, r);
		l->r->p = l;
		l->update();
		return l;
	}
	else
	{
		r->l = merge(l, r->l);
		r->l->p = r;
		r->update();
		return r;
	}
}

void split(pnode v, pnode &l, pnode &r, int key)
{
	if (!v)
	{
		l = r = NULL;
		return;
	}
	
	v->push();
	v->p = NULL;
	
	if (1 + getSize(v->l) <= key)
	{
		l = v;
		split(l->r, l->r, r, key - 1 - getSize(v->l));
		if (l->r)
			l->r->p = l;
	}
	else
	{
		r = v;
		split(r->l, l, r->l, key);
		if (r->l)
			r->l->p = r;
	}
	
	if (l)
		l->update();
	if (r)
		r->update();
}

const int maxn = 100005;

node *a[maxn];

int main(int argc, char *argv[])
{
	//freopen("a.in", "r", stdin);
	
	int n, q;
	scanf("%d %d", &n, &q);
	
	a[0] = new node();
	a[0]->key = 0;
	
	node *root = a[0];
	
	for (int i = 1; i < n; i++)
	{
		node *v = new node();
		v->key = i;
		a[i] = v;
		root = merge(root, v);
	}
	
	for (int i = 0; i < q; i++)
	{
		int type;
		scanf("%d", &type);
		
		if (type == 1)
		{
			int u, v;
			scanf("%d %d", &u, &v);
			
			pnode left, center, right;
			split(root, left, right, u - 1);
			split(right, center, right, v - u + 1);
			
			center->rev ^= 1;
			
			root = merge(merge(left, center), right);
		}
		else if (type == 3)
		{
			int u;
			scanf("%d", &u);
			
			pnode left, center, right;
			split(root, center, right, u);
			split(center, left, center, u - 1);
			
			printf("element at position %d is %d\n", u, center->key + 1);
			
			root = merge(merge(left, center), right);
		}
		else
		{
			int u;
			scanf("%d", &u);
			
			node *v = a[u - 1];
			
			vector < pnode > b;
			
			while (v != NULL)
			{
				b.pb(v);
				v = v->p;
			}
			
			for (int j = b.size() - 1; j >= 0; j--)
			{
				b[j]->push();
			}
			
			v = a[u - 1];
			
			int ans = getSize(v->l) + 1;
			
			while (v->p != NULL)
			{
				if (v->p->r == v)
				{
					ans += getSize(v->p->l) + 1;
				}
				
				v = v->p;
			}
			
			printf("element %d is at position %d\n", u, ans);
		}
	}
	
	return 0;
}






----------
====================
----------
DATA-STRUCTURES.112
hard
----------
PROBLEM STATEMENT:
Time Limits C:5, Cpp:5, C#:6, Java:8, Php:18, Ruby:20, Python:20, Perl:18, Haskell:10, Scala:14, Javascript:20, Pascal:5

Like every IT company, the Uplink Corporation has its own network. But, unlike the rest of the companies around the world, Uplink's network is subject to very specific restrictions:


Any pair of servers within the network should be directly connected by at most 1 link.
Each link is controlled by some specific network administrator.
No server has more than 2 links connected to it, that are controlled by the same administrator.
For easier management, links controlled by some administrator cannot be redundant (this is, removing any link will disconnect some two previously connected servers)


Notice that 2 connected servers might not have any direct link between them. Furthermore, in order to keep the network in a secured status, Uplink directives periodically try to perform some modifications over the network to mislead hackers. The problem is, having such a huge network, they need a software to efficiently simulate the network status after any of such modifications. You have been assigned to write the core section of that software. 

Operations performed by the directives are:


Change the administrator assigned to some particular link.
Place some number of security devices along a particular link.


Also, given a network administrator, they would like to know how many devices are in the path created by links controlled by that administrator (if any) between 2 servers.

Input Format 
Input begins with a line containing 4 integers [expression] lines in the input follow one the next formats:


[expression]


meaning that link between server [expression]


[expression]


meaning that the number of security devices along the link between server [expression], removing any existing devices on this link before the operation. The involved link will always exist.  


[expression]


meaning that directives want to know the number of security devices placed along the path between server [expression].

Output Format 
For each network transformation in the form [expression] you should output:


"Wrong link" if there is no direct link between server [expression].
"Already controlled link" if the requested link does exist, but it is already controlled by administrator [expression].
"Server overload" if administrator [expression] already controls 2 links connected to one of the involved servers.
"Network redundancy" if the requested assignment creates no new connection considering just the links controlled by [expression].
"Assignment done" if none of the above conditions holds. In this case, link directly connecting [expression].


For each network transformation in the form [expression] you should output:


"No connection" if there is no path between the requested servers considering just the links controlled by [expression].
"[expression]. 


Constraints  

[expression] 
[expression] 
[expression] 
[expression] 
[expression]

Sample Input:

4 5 3 15
1 2 1
2 3 1
3 4 2
1 4 2
1 3 3
2 3 4 49
1 1 2 3
2 1 4 64
3 1 4 2
1 1 2 3
3 4 2 3
3 1 3 3
1 1 4 3
3 3 4 2
3 2 4 1
2 1 4 13
2 1 3 21
2 2 3 24
1 2 3 3
1 2 4 3


Sample Output:

Assignment done
64 security devices placed
Already controlled link
No connection
0 security devices placed
Server overload
49 security devices placed
No connection
Network redundancy
Wrong link

----------
TOP SOLUTION:
----------

 #define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#include <bitset>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }


unsigned xor128() {
	static unsigned x = 123456789, y = 362436069, z = 521288629, w = 88675123;
	unsigned t = x ^ (x << 11);
	x = y; y = z; z = w;
	return w = w ^ (w >> 19) ^ (t ^ (t >> 8));
}

template<typename Derived>
struct PNodeBase {
	Derived *left, *right, *parent;
	int size;
	PNodeBase(): left(NULL), right(NULL), parent(NULL), size(1) { }
	inline Derived *update() {
		size = (!left ? 0 : left->size) + 1 + (!right ? 0 : right->size);
		return derived();
	}
	inline void propagate() { }
	inline Derived *linkl(Derived *c) {
		if(left = c) c->parent = derived();
		return derived()->update();
	}
	inline Derived *linkr(Derived *c) {
		if(right = c) c->parent = derived();
		return derived()->update();
	}
	inline Derived *linklr(Derived *l, Derived *r) {
		if(left = l) l->parent = derived();
		if(right = r) r->parent = derived();
		return derived()->update();
	}
	static inline Derived *cut(Derived *t) {
		if(t) t->parent = NULL;
		return t;
	}
private:
	inline Derived *derived() { return static_cast<Derived*>(this); }
};
struct Node : PNodeBase<Node> {
	typedef PNodeBase<Node> Base;
	int weight, sum;
	bool reversed;
	Node(): weight(0), sum(0), reversed(false) { }
	Node *update() {
		sum = (!left ? 0 : left->sum) + weight + (!right ? 0 : right->sum);
		return static_cast<Base*>(this)->update();
	}
	inline void propagate() {
		if(reversed) {
			swap(left, right);
			if(left != 0) left->reversed ^= true;
			if(right != 0) right->reversed ^= true;
			reversed = false;
		}
		return static_cast<Base*>(this)->propagate();
	}
};

struct PRBSTBase {
	typedef Node *Ref;
	static int size(Ref t) { return !t ? 0 : t->size; }
	static Ref join(Ref l, Ref r) {
		if(!l) return r;
		if(!r) return l;
		if((int)(xor128() % (l->size + r->size)) < l->size) {
			l->propagate();
			return l->linkr(join(Node::cut(l->right), r));
		}else {
			r->propagate();
			return r->linkl(join(l, Node::cut(r->left)));
		}
	}
	typedef pair<Ref,Ref> RefPair;
	static RefPair split(Ref t, int k) {
		if(!t) return RefPair((Ref)NULL, (Ref)NULL);
		t->propagate();
		int s = size(t->left);
		if(k <= s) {
			RefPair p = split(Node::cut(t->left), k);
			return RefPair(p.first, t->linkl(p.second));
		}else {
			RefPair p = split(Node::cut(t->right), k - s - 1);
			return RefPair(t->linkr(p.first), p.second);
		}
	}
	static Ref insert(Ref t, int k, Ref n) {
		if(!t) return n;
		if(xor128() % (t->size + 1) == 0) {
			RefPair p = split(t, k);
			return n->linklr(p.first, p.second);
		}
		t->propagate();
		int s = size(t->left);
		if(k <= s)
			return t->linkl(insert(Node::cut(t->left), k, n));
		else
			return t->linkr(insert(Node::cut(t->right), k - s - 1, n));
	}
	static RefPair remove(Ref t, int k) {
		if(!t) return RefPair((Ref)NULL, (Ref)NULL);
		t->propagate();
		int s = size(t->left);
		if(k < s) {
			RefPair p = remove(Node::cut(t->left), k);
			return RefPair(t->linkl(p.first), p.second);
		}else if(k > s) {
			RefPair p = remove(Node::cut(t->right), k - s - 1);
			return RefPair(t->linkr(p.first), p.second);
		}else {
			Ref a = join(Node::cut(t->left), Node::cut(t->right));
			return RefPair(a, t->linklr(NULL, NULL));
		}
	}
	static Ref index(Ref t, int k) {
		if(!t) return NULL;
		t->propagate();
		int s = size(t->left);
		if(k < s)
			return index(t->left, k);
		else if(k > s)
			return index(t->right, k - s - 1);
		else
			return t;
	}
	static void topDown(Ref t) {
		Ref nodes[128]; int k = 0;
		for(Ref u = t; u != 0; u = u->parent)
			nodes[k ++] = u;
		while(k > 0)
			nodes[-- k]->propagate();
	}
	static pair<Ref,int> findRoot(Ref t) {
		if(!t) return make_pair((Ref)NULL, 0);
		topDown(t);
		int k = size(t->left);
		while(true) {
			Ref p = t->parent;
			if(!p) return make_pair(t, k);
			if(p->right == t)
				k += size(p->left) + 1;
			t = p;
		}
	}
};
typedef PRBSTBase BST;

struct Vector2 {
	int a[2], s;
	Vector2(): s(0) { }
	int operator[](int i) const { assert(i < s); return a[i]; }
	void push_back(int x) { a[s ++] = x; }
	void erase(int x) { s = remove(a, a + s, x) - a; }
	int size() const { return s; }
	bool empty() const { return s == 0; }
};

void link(int i, int a, int x, int y, const vector<vector<Vector2> > &g, vector<Node> &nodes) {
	Node *t = &nodes[i];
	assert(BST::size(t) == 1);
	if(!g[a][x].empty()) {
		Node *l = &nodes[g[a][x][0]];
		pair<Node*,int> pl = BST::findRoot(l);
		if(pl.second != BST::size(pl.first) - 1) {
			assert(pl.second == 0);
			pl.first->reversed ^= true;
		}
		t = BST::join(pl.first, t);
	}
	if(!g[a][y].empty()) {
		Node *r = &nodes[g[a][y][0]];
		pair<Node*,int> pr = BST::findRoot(r);
		if(pr.second != 0) {
			assert(pr.second == BST::size(pr.first) - 1);
			pr.first->reversed ^= true;
		}
		t = BST::join(t, pr.first);
	}
}

int main() {
	int S, L, AA, T;
	scanf("%d%d%d%d", &S, &L, &AA, &T);
	vector<vector<Vector2> > g(AA, vector<Vector2>(S));
	map<pii,int> links;
	vector<pii> edges(L);
	vector<Node> nodes(L);
	vector<int> admin(L, -1);
	rep(i, L) {
		int x, y, a;
		scanf("%d%d%d", &x, &y, &a), -- x, -- y, -- a;
		if(x > y) swap(x, y);

		link(i, a, x, y, g, nodes);

		g[a][x].push_back(i);
		g[a][y].push_back(i);

		edges[i] = mp(x, y);
		links[mp(x, y)] = i;
		admin[i] = a;
	}
	const char *msgs[9] = {
		"?????\n",
		"Wrong link\n",
		"Already controlled link\n",
		"Server overload\n",
		"Network redundancy\n",
		"Assignment done\n",
		"",
		"No connection\n",
		"%d security devices placed\n",
	};
	rep(ii, T) {
		int ty, A, B, x, a;
		scanf("%d%d%d%d", &ty, &A, &B, &x), -- A, -- B;
		a = x - 1;
		if(A > B) swap(A, B);

		int result; int ans = -1;
		if(ty == 1) {
			auto it = links.find(mp(A, B));
			if(it == links.end()) {
				result = 1;
			}else if(admin[it->second] == a) {
				result = 2;
			}else if(g[a][A].size() >= 2 || g[a][B].size() >= 2) {
				result = 3;
			}else {
				int i = it->second, pa = admin[i];
				Node *tt = &nodes[i];
				pair<Node*,int> p = BST::findRoot(tt);
				Node *t = p.first;

				{
					Node *l = g[a][A].empty() ? 0 : BST::findRoot(&nodes[g[a][A][0]]).first;
					Node *r = g[a][B].empty() ? 0 : BST::findRoot(&nodes[g[a][B][0]]).first;
					if(l != 0 && r != 0 && l == r) {
						result = 4;
						goto next;
					}
				}

				//??admin?????????
				if(p.second != 0) {
					int j = BST::index(p.first, p.second - 1) - &nodes[0];
					if(admin[j] == pa) {
						p.first = BST::split(p.first, p.second).second;
						p.second = 0;
					}
				}
				if(p.second != BST::size(p.first) - 1) {
					int j = BST::index(p.first, p.second + 1) - &nodes[0];
					if(admin[j] == pa) {
						p.first = BST::split(p.first, p.second + 1).first;
					}
				}
				g[pa][A].erase(i);
				g[pa][B].erase(i);

				link(i, a, A, B, g, nodes);

				g[a][A].push_back(i);
				g[a][B].push_back(i);

				admin[i] = a;

				result = 5;
			}
		}else if(ty == 2) {
			if(!links.count(mp(A, B))) abort();
			int i = links[mp(A, B)];
			Node *tt = &nodes[i];
			pair<Node*,int> p = BST::findRoot(tt);
			Node *u = BST::remove(p.first, p.second).first;
			tt->weight = x;
			tt->update();
			BST::insert(u, p.second, tt);
			result = 6;
		}else if(ty == 3) {
			if(A == B) {
				result = 8, ans = 0;
				goto next;
			}
			if(g[a][A].empty() || g[a][B].empty()) {
				result = 7;
				goto next;
			}
			Node *l = &nodes[g[a][A][0]];
			Node *r = &nodes[g[a][B][0]];
			pair<Node*,int> pl = BST::findRoot(l);
			pair<Node*,int> pr = BST::findRoot(r);
			if(pl.first != pr.first) {
				result = 7;
				goto next;
			}
			if(g[a][A].size() == 2) {
				Node *l1 = &nodes[g[a][A][1]];
				pair<Node*,int> pl1 = BST::findRoot(l1);
				if(pl1.first != pl.first) abort();
				if(abs(pl.second - pr.second) > abs(pl1.second - pr.second))
					l = l1, pl = pl1;
			}
			if(g[a][B].size() == 2) {
				Node *r1 = &nodes[g[a][B][1]];
				pair<Node*,int> pr1 = BST::findRoot(r1);
				if(pr1.first != pr.first) abort();
				if(abs(pl.second - pr.second) > abs(pl.second - pr1.second))
					r = r1, pr = pr1;
			}
			Node *t = pl.first;
			int L = pl.second, R = pr.second;
			if(L > R) swap(L, R);
			pair<Node*,Node*> p = BST::split(t, R + 1);
			pair<Node*,Node*> q = BST::split(p.first, L);

			Node *u = q.second;
			result = 8;
			ans = u->sum;

			t = BST::join(BST::join(q.first, q.second), p.second);
		}
	next:;
		printf(msgs[result], ans);
	}
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.113
expert
----------
PROBLEM STATEMENT:
You are given a tree with N nodes and each has a value associated with it. You are given Q queries, each of which is either an update or a retrieval operation. 

Initially all node values are zero.  

The update query is of the format

a1 d1 a2 d2 A B


This means you'd have to add [expression] is the distance between the node and A.

The retrieval query is of the format

i j


You need to return the sum of the node values lying in the path from node i to node j modulo 1000000007. 

Note:   


First all update queries are given and then all retrieval queries.  
Distance between 2 nodes is the shortest path length between them taking each edge weight as 1.  


Input Format  

The first line contains two integers (N and R respectively) separated by a space.  

In the next N-1 lines, the ith line describes the ith edge: a line with two integers x y separated by a single space denotes an edge between nodes x and y.  

The next line contains 2 space separated integers (U and Q respectively) representing the number of Update and Query operations to follow.  

U lines follow. Each of the next U lines contains 6 space separated integers (a1,d1,a2,d2,A and B respectively).

Each of the next Q lines contains 2 space separated integers, i and j respectively. 

Output Format  

It contains exactly Q lines and each line containing the answer of the ith query.

Constraints

2 5 
2 9 
1 5 
1 5 
1 8 
1 

Note 
For the update operation, x can be equal to y and for the query operation, i can be equal to j.  

Sample Input  

7 2
1 2
1 3
2 4
2 6
4 5
6 7
1 4
1 1 1 1 4 6
4 5
2 7
4 7
5 3


Sample Output

1
44
45
9


Explanation

The node values after updation becomes :  

0 8 0 1 0 36 0


Answer to Query #1: 1+0 = 1   

Answer to Query #2: 8+36+0 = 44

Answer to Query #3: 1+8+36+0 = 45

Answer to Query #4: 0+1+8+0+0 = 9
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt(): x(0) { }
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }
	
	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }
	
	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
	
	ModInt inverse() const {
		long long a = x, b = MOD, u = 1, v = 0;
		while(b) {
			long long t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		return ModInt(u);
	}
	ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }
};
typedef ModInt<1000000007> mint;

struct To {
	typedef int Vertex;
	Vertex to;
	To() { }
	To(Vertex to_): to(to_) { }
};
template<typename To_>
struct StaticGraph {
	typedef To_ To;
	typedef typename To::Vertex Vertex;
	typedef std::pair<Vertex,To> Edge;
	typedef const To *const_iterator;
 
	void init(int n_, const std::vector<Edge> &edges) {
		n = n_; int m = edges.size();
		tos.resize(m+1); offsets.resize(n+1);
		for(int e = 0; e < m; e ++) offsets[edges[e].first] ++;
		for(int v = 1; v <= n_; v ++) offsets[v] += offsets[v-1];
		for(int e = 0; e < m; e ++)
			tos[-- offsets[edges[e].first]] = edges[e].second;
	}
	int numVertices() const { return n; }
	int numEdges() const { return tos.size() - 1; }
 
	inline const_iterator edgesBegin(int v) const { return &tos[offsets[v]]; }
	inline const_iterator edgesEnd(int v) const { return &tos[offsets[v+1]]; }
private:
	int n;
	std::vector<To> tos;
	std::vector<int> offsets;
};

class SchieberVishkinLCA {
public:
	typedef StaticGraph<To> Graph;
	typedef unsigned Word;
	typedef Graph::Vertex Vertex;
private:

	static inline Word lowestOneBit(Word v) {
		return v & (~v+1);
	}
	static inline Word highestOneBitMask(Word v) {
		v |= v >> 1;
		v |= v >> 2;
		v |= v >> 4;
		v |= v >> 8;
		v |= v >> 16;
		return v >> 1;
	}

	std::vector<Word> indices;			//Vertex -> index
	std::vector<Word> maxHIndices;		//Vertex -> index
	std::vector<Word> ancestorHeights;	//Vertex -> Word
	std::vector<Vertex> pathParents;	//index-1 -> Vertex
public:
	//g
	void build(const Graph &g, Vertex root) {
		return build(g, std::vector<Vertex>(1, root));
	}
	void build(const Graph &g, const std::vector<Vertex> &roots) {
		int N = g.numVertices();

		ancestorHeights.resize(N);
		std::vector<Vertex> parents(N);
		maxHIndices.resize(N);
		std::vector<Vertex> vertices; vertices.reserve(N);
		indices.resize(N);

		//inorder traversal
		Word currentIndex = 1;
		for(int ri = 0; ri < (int)roots.size(); ri ++) {
			Vertex root = roots[ri];
			parents[root] = root;	//
			vertices.push_back(root);
		}
		while(!vertices.empty()) {
			Vertex v = vertices.back(); vertices.pop_back();
			indices[v] = currentIndex ++;
			for(const Graph::To *it = g.edgesBegin(v); it != g.edgesEnd(v); ++ it) {
				parents[it->to] = v;
				vertices.push_back(it->to);
			}
		}

		//BFS ()
		int head = 0, tail = roots.size();
		vertices.resize(N);
		for(int ri = 0; ri < (int)roots.size(); ri ++)
			vertices[ri] = roots[ri];
		while(head != tail) {
			Vertex v = vertices[head ++];
			for(const Graph::To *it = g.edgesBegin(v); it != g.edgesEnd(v); ++ it)
				vertices[tail ++] = it->to;
		}

		//
		for(std::vector<Vertex>::const_iterator it = vertices.begin(); it != vertices.end(); ++ it)
			maxHIndices[*it] = indices[*it];
		for(std::vector<Vertex>::const_reverse_iterator it = vertices.rbegin(); it != vertices.rend(); ++ it) {
			Vertex v = *it, parent = parents[v];
			if(lowestOneBit(maxHIndices[parent]) < lowestOneBit(maxHIndices[v]))
				maxHIndices[parent] = maxHIndices[v];
		}

		//A
		for(int ri = 0; ri < (int)roots.size(); ri ++) {
			Vertex root = roots[ri];
			ancestorHeights[root] = 0;
		}
		for(std::vector<Vertex>::const_iterator it = vertices.begin(); it != vertices.end(); ++ it) {
			Vertex v = *it;
			ancestorHeights[v] = ancestorHeights[parents[v]] | lowestOneBit(maxHIndices[v]);
		}

		pathParents.swap(parents);	//
		for(int ri = 0; ri < (int)roots.size(); ri ++) {
			Vertex root = roots[ri];
			pathParents[indices[root]-1] = root;
		}
		for(std::vector<Vertex>::const_iterator it = vertices.begin(); it != vertices.end(); ++ it) {
			Vertex v = *it;
			for(const Graph::To *jt = g.edgesBegin(v); jt != g.edgesEnd(v); ++ jt) {
				if(maxHIndices[v] != maxHIndices[jt->to])
					pathParents[indices[jt->to]-1] = v;
				else
					pathParents[indices[jt->to]-1] = pathParents[indices[v]-1];
			}
		}
	}

	Vertex query(Vertex v, Vertex u) const {
		//binary treeLCA
		Word Iv = maxHIndices[v], Iu = maxHIndices[u];
		Word hIv = lowestOneBit(Iv), hIu = lowestOneBit(Iu);
		Word hbMask = highestOneBitMask((Iv ^ Iu) | hIv | hIu);
		Word j = lowestOneBit(ancestorHeights[v] & ancestorHeights[u] & ~hbMask);
		//j = hI(lca(v,u))  (hI(x) = 2^(complete binary treeI(x)), I(x) = maxHIndices[x])
		//(hI(lca(v,u)) = j)hI(v)hI(u)
		Vertex x, y;
		if(j == hIv) x = v;
		else {			//lcav
			Word kMask = highestOneBitMask(ancestorHeights[v] & (j-1));	//vj
			x = pathParents[(indices[v] & ~kMask | (kMask+1))-1];	//indices[v]k
		}
		if(j == hIu) y = u;
		else {			//lcau
			Word kMask = highestOneBitMask(ancestorHeights[u] & (j-1));	//uj
			y = pathParents[(indices[u] & ~kMask | (kMask+1))-1];	//indices[u]k
		}
		return indices[x] < indices[y] ? x : y;	//in-order
	}
};
vector<int> t_parent;
vi t_ord;

void tree_getorder(const vector<vi> &g, int root) {
	int n = g.size();
	t_parent.assign(n, -1);
	t_ord.clear();

	vector<int> stk; stk.push_back(root);
	while(!stk.empty()) {
		int i = stk.back(); stk.pop_back();
		t_ord.push_back(i);
		for(int j = (int)g[i].size()-1; j >= 0; j --) {
			int c = g[i][j];
			if(t_parent[c] == -1 && c != root)
				stk.push_back(c);
			else
				t_parent[i] = c;
		}
	}
}

void querysub(vector<mint> &adds, int A, int B, mint x) {
	adds[A] += x;
	adds[B] -= x;
}

int main() {
	typedef StaticGraph<To> Graph;
	int N, R;
	scanf("%d%d", &N, &R);
	vector<vi> g(N);
	rep(i, N-1) {
		int x, y;
		scanf("%d%d", &x, &y), -- x, -- y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	tree_getorder(g, 0);
	vector<int> depth(N, 0);
	reu(ix, 1, N) {
		int i = t_ord[ix];
		depth[i] = depth[t_parent[i]] + 1;
	}
	vector<Graph::Edge> edges;
	reu(i, 1, N)
		edges.push_back(Graph::Edge(t_parent[i], i));
	Graph gg; gg.init(N, edges);
	SchieberVishkinLCA lca; lca.build(gg, 0);
	vector<mint> powRs(N*2+1);
	powRs[N] = 1;
	rer(i, 1, N) powRs[N+i] = powRs[N+i-1] * R;
	mint invR = mint(R).inverse();
	rer(i, 1, N) powRs[N-i] = powRs[N-i+1] * invR;
	const int T = 6;
	vector<mint> adds[T], coefs[T];
	rep(t, T) coefs[t].assign(N+1, mint());
	rep(i, N) {
		int d = depth[i];
		coefs[0][i] = powRs[N-d];
		coefs[1][i] = powRs[N+d];
		coefs[2][i] = powRs[N-d] * -d;
		coefs[3][i] = powRs[N+d] * +d;
		coefs[4][i] = powRs[N-d] * -d * -d;
		coefs[5][i] = powRs[N+d] * +d * +d;
	}
	rep(t, T) adds[t].assign(N+1, mint());
	vector<mint> values(N, mint());
	int U, Q;
	scanf("%d%d", &U, &Q);
	rep(ii, U) {
		int a1, d1, a2, d2, A, B;
		scanf("%d%d%d%d%d%d", &a1, &d1, &a2, &d2, &A, &B), -- A, -- B;
		//(a1 + z d1) (a2 + z d2) R^z
		//= a1 a2 R^z + (a1 d2 + d1 a2) z R^z + d1 d2 z^2 R^z
		int C = lca.query(A, B), Cp = C == 0 ? N : t_parent[C];
		int dA = depth[A], dB = depth[B], dC = depth[C];
		int uC = dA - dC, uB = dA + dB - dC * 2;
		mint p = powRs[N+dA], q = powRs[N-dB+uB];
		int e = -dB+uB;
		//a1 a2 R^z
		if(1) {
			mint t = mint(a1) * a2;
			querysub(adds[0], A, Cp, t * p);
			querysub(adds[1], B, C,  t * q);
		}
		//(a1 d2 + d1 a2) z R^z
		if(1) {
			mint t = mint(a1) * d2 + mint(d1) * a2;
			querysub(adds[2], A, Cp, t * p);
			querysub(adds[0], A, Cp, t * p * dA);
			querysub(adds[3], B, C,  t * q);
			querysub(adds[1], B, C,  t * q * e);
		}
		//d1 d2 z^2 R^z
		if(1) {
			mint t = mint(d1) * d2;
			querysub(adds[4], A, Cp, t * p);
			querysub(adds[2], A, Cp, t * p * dA * 2);
			querysub(adds[0], A, Cp, t * p * dA * dA);
			querysub(adds[5], B, C,  t * q);
			querysub(adds[3], B, C,  t * q * e * 2);
			querysub(adds[1], B, C,  t * q * e * e);
		}
	}
	rep(t, T) {
		for(int ix = N-1; ix > 0; -- ix) {
			int i = t_ord[ix];
			adds[t][t_parent[i]] += adds[t][i];
		}
		rep(i, N)
			adds[t][i] *= coefs[t][i];
//		cerr << t << ": "; rep(i, N) cerr << adds[t][i].get() << ", "; cerr << endl;
		rep(i, N)
			values[i] += adds[t][i];
		adds[t].assign(N+1, mint());
	}
//	cerr << "values: "; rep(i, N) cerr << values[i].get() << ", "; cerr << endl;
//	}
	vector<mint> sums = values;
	for(int ix = 1; ix < N; ++ ix) {
		int i = t_ord[ix];
		sums[i] += sums[t_parent[i]];
	}
	rep(ii, Q) {
		int A, B;
		scanf("%d%d", &A, &B), -- A, -- B;
		int C = lca.query(A, B);
		mint ans = 0;
		ans += sums[A];
		ans += sums[B];
		ans -= values[C];
		if(C != 0)
			ans -= sums[t_parent[C]] * 2;
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
DATA-STRUCTURES.114
expert
----------
PROBLEM STATEMENT:
Consider a permutation, [expression]: 
[expression]

Generate a lexicographically sorted list of all permutations of length [expression] permutation.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
// iostream is too mainstream
#include <cstdio>
// bitch please
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <list>
#include <cmath>
#include <iomanip>
#include <time.h>
#define dibs reserve
#define OVER9000 1234567890
#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)
#define tisic 47
#define soclose 1e-8
#define chocolate win
// so much chocolate
#define patkan 9
#define ff first
#define ss second
#define abs(x) ((x < 0)?-(x):x)
#define uint unsigned int
#define dbl long double
#define pi 3.14159265358979323846
using namespace std;
// mylittledoge

#ifdef DONLINE_JUDGE
	// palindromic tree is better than splay tree!
	#define lld I64d
#endif

int main() {
	cin.sync_with_stdio(0);
	cin.tie(0);
	cout << fixed << setprecision(10);
	int T;
	cin >> T;
	vector<long long> poc(300,0);
	vector< vector<long long> > sum(1000+tisic);
	sum[3].push_back(2);
	sum[3].push_back(2);
	poc[3] =6;
	for(int i =5; i < 1000; i +=2) {
		sum[i] =sum[i-2];
		sum[i].back() /=2;
		for(int j =0; j < (int)sum[i].size()-1; j++) sum[i][sum[i].size()-1] +=sum[i][j];
		sum[i].push_back(sum[i-2].back()*2);
		if(i < 200) {
			for(int j =0; j < (int)sum[i].size()-1; j++) poc[i] +=sum[i][j];
			poc[i] *=2;
			poc[i] +=sum[i].back();
			}
		}

	for(int t =0; t < T; t++) {
		int N;
		long long K;
		cin >> N >> K;
		if(N == 1) {
			if(K > 1) cout << "-1\n";
			else cout << "1\n";
			continue;}
		if(N%2 == 0) {
			if(K > 2) cout << "-1\n";
			vector<int> v(N);
			for(int i =0; i < N/2; i++) v[2*i] =N/2-i, v[2*i+1] =N-i;
			if(K == 2) for(int i =0; i < N; i++) cout << v[N-1-i] << ((i == N-1)?"\n":" ");
			if(K == 1) for(int i =0; i < N; i++) cout << v[i] << ((i == N-1)?"\n":" ");
			continue;}
		bool rev =false;
		if(N < 111 && poc[N] < K) {cout << "-1\n"; continue;}
		if(N < 113 && poc[N]/2 < K) {
			rev =true;
			K =poc[N]-K+1;}

		vector<int> v;
		set<int> nused;
		for(int i =0; i < N; i++) nused.insert(i);
		int x =0, p =min(499,N);
		while(sum[p][x] < K) {
			K -=sum[p][x];
			x++;}
		bool p2 =false, p0 =false;
		if(x == N/2) p2 =true;
		if(x == 0) p0 =true;
		v.push_back(x+1);
		nused.erase(x);
		while(!p2 && !p0) {
			auto it =nused.lower_bound(N/2+x);
			auto jt =nused.begin();
			int y =0;
			p =min(N,499);
			while(sum[p][y] < K) {
				K -=sum[p][y];
				y++;
				jt++;}
			if(y == 0) p0 =true;
			while(*it < *jt+N/2) {
				p2 =true;
				it++;}
			v.push_back(*it+1);
			v.push_back(*jt+1);
			x =*jt;
			nused.erase(it);
			nused.erase(jt);}

		if(!p2) {
			if(K == 1) {
				auto it =nused.end(); it--;
				auto jt =nused.lower_bound(N/2);
				while((int)v.size() < N) {
					v.push_back(*jt+1);
					v.push_back(*it+1);
					it--, jt--;}
				}
			else {
				auto it =nused.begin();
				auto jt =nused.lower_bound(N/2+1);
				while((int)v.size() < N) {
					v.push_back(*jt+1);
					v.push_back(*it+1);
					it++, jt++;}
				}
			}
		else {
			while(v.back() != N/2+1) {
				auto it =nused.lower_bound(v.back()-1+N/2);
				v.push_back(*it+1); nused.erase(it);
				it =nused.upper_bound(v.back()-1-N/2); it--;
				v.push_back(*it+1); nused.erase(it);}
			if(nused.find(0) != nused.end()) {
				v.push_back(1);
				nused.erase(0);}
			else if(nused.find(N-1) != nused.end()) {
				v.push_back(N);
				nused.erase(N-1);}
			int ex =(N-(int)v.size())/2-1;
			vector<int> end;
			while((int)(v.size()+end.size()) < N-1) {
				auto it =nused.begin();
				auto jt =nused.lower_bound(*it+N/2);
				if(ex <= 60 && (1LL<<ex) < K) {
					K -=(1LL<<ex);
					end.push_back(*jt+1); nused.erase(jt);
					end.push_back(*it+1); nused.erase(it);}
				else {
					v.push_back(*jt+1); nused.erase(jt);
					v.push_back(*it+1); nused.erase(it);}
				ex--;}
			while(!nused.empty()) {
				auto it =nused.begin();
				v.push_back(*it+1); nused.erase(it);}
			while(!end.empty()) {
				v.push_back(end.back());
				end.pop_back();}
			}

		if(rev) for(int i =0; i < N; i++) v[i] =N+1-v[i];
		for(int i =0; i < N; i++) cout << v[i] << ((i == N-1)?"\n":" ");
		}
	return 0;}

// look at my code
// my code is amazing

----------
====================
----------
DATA-STRUCTURES.115
advanced
----------
PROBLEM STATEMENT:
The LRT Company has [expression] (the director).

The director decides to have a retreat lasting [expression] days. Each day, the employees will be assigned to different groups for team building exercises. Groups are constructed in the following way:


An employee can invite their immediate supervisor (the director has no supervisor and, thus, doesn't invite anyone). If employee [expression] are considered to be in the same group.
Once an employee is invited to be in a group, they are in that group. This means that if two employees have the same immediate supervisor, only one of them can invite that supervisor to be in their group.  
Every employee must be in a group, even if they are the only employee in it.


The venue where LRT is hosting the retreat has different pricing for each of the [expression] (i.e., the maximum number of people that can be in any group on that day).

Help the director find optimal groupings for each day so the cost of the [expression].
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"

using namespace std;

typedef long long ll;
typedef pair < int, int > ii;

const int N = 1 << 17;
const int LOG = 17;

int n, m, tick, cnt;
int dep[N], st[N], nd[N], a[N], leaf[N];
vector < int > v[N], q[N];

int t[N << 1], sparse[LOG][N];

void up(int x, int k) {
    t[x += N] = k;
    while(x > 1) {
        x >>= 1;
        t[x] = min(t[x + x], t[x + x + 1]);
    }
}

int get(int l, int r) {
    int res = 1e9;
    for(l += N, r += N; l <= r; l = (l + 1) >> 1, r = (r - 1) >> 1) {
        if(l & 1) res = min(res, t[l]);
        if(~r & 1) res = min(res, t[r]);
    }
    return res;
}

void dfs(int p, int x) {
    st[x] = ++tick;
    dep[x] = dep[p] + 1;
    sparse[0][x] = p;
    for(int i = 1; i < LOG; i++)
        sparse[i][x] = sparse[i - 1][sparse[i - 1][x]];
    leaf[x] = 1e9;
    for(auto u : v[x]) {
        dfs(x, u);
        leaf[x] = min(leaf[x], leaf[u] + 1);
    }
    if(leaf[x] > 5e8) {
        leaf[x] = 0;
        cnt++;
    }
    q[leaf[x]].push_back(x);
    nd[x] = tick;
}

int calc(int group) {
    int res = cnt;
    priority_queue < ii > Q;
    for(auto x : q[group])
        Q.push({dep[x], x});
    vector < int > vv;
    while(!Q.empty()) {
        int x = Q.top().second;
        Q.pop();
        if(leaf[x] < group or get(st[x], nd[x]) - dep[x] < group)
            continue;
        vv.push_back(x);
        up(st[x], dep[x]);
        res++;
        if(dep[x] > group) {
            int k = group;
            for(int i = LOG - 1; i >= 0; i--) {
                if(k >= (1 << i)) {
                    k -= 1 << i;
                    x = sparse[i][x];
                }
            }
            Q.push({dep[x], x});
        }
    }
    for(auto x : vv)
        up(st[x], 1e9);
    return res;
}

int main () {

    for(int i = 1; i < N + N; i++)
        t[i] = 1e9;

    scanf("%d %d", &n, &m);

    for(int i = 2; i <= n; i++) {
        int x;
        scanf("%d", &x);
        v[x].push_back(i);
    }

    dfs(0, 1);

    for(int i = 1; i <= n; i++)
        a[i] = calc(i);

    ll ans = 0;

    for(int i = 1; i <= m; i++) {
        int x, y;
        scanf("%d %d", &x, &y);
        ans += (ll) x * a[min(n, y)];
        ans %= (int) 1e9 + 7;
    }

    printf("%lld\n", ans);

    return 0;

}
----------
====================
----------
DATA-STRUCTURES.116
expert
----------
PROBLEM STATEMENT:
Alice purchased an array of [expression].

Alice wants you to perform [expression] operations on the array of boxes. Each operation is in one of the following forms:

(Note: For each type of operations, [expression])


1 l r c: Add [expression] can be negative.
2 l r d: Replace each [expression]. 
3 l r: Print the minimum value of any [expression].
4 l r: Print the sum of all [expression].


Recall that [expression]).

Given [expression] operations, can you perform all the operations efficiently? 
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#include <limits.h>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#define each(it,o) for(auto it= (o).begin(); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF INT_MAX
#define INFL 0x3f3f3f3f3f3f3f3fLL
#define inrep int t;cin>>t; while(t--)
using namespace std;

typedef vector<int> vi;
typedef pair<int,int> pii;
typedef vector<pii > vpii;
typedef long long ll;
typedef vector<ll> vll;
typedef pair<ll,ll> pll;
typedef vector<pll > vpll;
typedef vector<string> vs;
typedef long double ld;

template<typename T> ostream& operator<< ( ostream &o,vector<T> v ) {
    if ( v.size() >0 )
        o<<v[0];
    for ( unsigned   i=1; i<v.size(); i++ )
        o<<" "<<v[i];
    return o<<endl;
}
template<typename U,typename V> ostream& operator<< ( ostream &o,pair<U,V> p ) {
    return o<<"("<<p.first<<", "<<p.second<<") ";
}
template<typename T> istream& operator>> ( istream &in,vector<T> &v ) {

    for ( unsigned   i=0; i<v.size(); i++ )
        in>>v[i];
    return in;
}
constexpr int BXSIZE=117;

typedef  int realt;
struct Box {
    bool isSpecial=1;
    int mx=BXSIZE;
    array<int,BXSIZE> vals= {};
    array<int,3> spVals= {};
    array<int,3> cnt= {};
    ll su=0;
    int mi=INF,ma=-INF;


    void add ( int b, int e, int c ) {
        doAdd();
        if ( !isSpecial ) makeSpecial();
        reu ( i,b,e ) vals[i]+=c;
        su+= ( ll ) ( e-b ) *c;
        mi=INF, ma=-INF;

        rep ( i,mx ) {
            mi=min ( mi,vals[i] );
            ma=max ( ma, vals[i] );
        }
    }
    void dfloor ( int &x, realt d ) {
        if ( x>0 ) {
             x=x/d;
        } else {
            int y=x/d;
            if (y*d!=x ) y--;
            x=y;
        }
    }
    void divide ( int b, int e, realt d ) {
        doAdd();
        if ( !isSpecial ) makeSpecial();
        reu ( i,b,e ) dfloor ( vals[i],d ); //vals[i]/=d;
        mi=INF, ma=-INF;
        su=0;
        rep ( i,mx ) {
            su+=vals[i];
            mi=min ( mi,vals[i] );
            ma=max ( ma, vals[i] );
        }
    }
    void divide ( realt d ) {
        doAdd();
        dfloor ( mi,d );
        dfloor ( ma,d );
        if ( isSpecial ) {
            su=0;
            rep ( i,mx ){
                if(vals[i] &&vals[i]!=-1)dfloor ( vals[i],d );
                su+=vals[i];
            }
            if ( ma-mi<3 ) {
                makeUnspecial();
            }
        } else {
            dfloor ( spVals[0],d );
            dfloor ( spVals[1],d );
            dfloor ( spVals[2],d );

            su= ( ll ) cnt[0]*spVals[0]+ ( ll ) cnt[1]*spVals[1]+ ( ll ) cnt[2]*spVals[2];
        }
    }
    
    int addC=0;
    
    void add ( int c ) {
        addC+=c;
         su+= ( ll ) mx*c;
        mi+=c;
        ma+=c;
       
    }
    void doAdd(){
     if(!addC)return;
        if ( isSpecial ) {
            rep ( i,mx ) vals[i]+=addC;
        } else {
            spVals[0]+=addC;
            spVals[1]+=addC;
            spVals[2]+=addC;
        }
        addC=0;
       
    }


    ll findSum ( int b, int e ) {
        doAdd();
        ll su=0;
        if ( isSpecial ) {
            reu ( i,b,e ) {
                su+=vals[i];
            }
        } else {
            reu ( i,b,e ) {
                su+=spVals[vals[i]];
            }
        }
        return su;

    }
    int findMin ( int b, int e ) {
        doAdd();
        int mi=INF;
        reu ( i,b,e ) mi=min ( mi,vals[i] );
        if ( isSpecial ) return mi;
        return spVals[mi];
    }
    void makeUnspecial() {
        isSpecial=0;
        spVals[0]=mi, spVals[1]=mi+1, spVals[2]=mi+2;
        cnt[0]=cnt[1]=cnt[2]=0;
        rep ( i,mx ) {
            int d=vals[i]-mi;
            vals[i]=d;
            cnt[d]++;
        }
    }
    void makeSpecial() {
        isSpecial=1;
        rep ( i,mx ) {
            vals[i]=spVals[vals[i]];
        }
    }

};
#define gc getchar_unlocked

ostream &operator<< ( ostream &os, const Box &b ) {
    if ( b.isSpecial ) os<<"special"<<endl;
    os<<vi ( b.vals.begin(), b.vals.begin() +b.mx );
    os<<"mi "<<b.mi<<" ma "<<b.ma<<"  "<<"su "<<b.su<<endl;
    return os;

}

void scan ( int &x ) {
    int c = gc();
    x = 0;
    bool inv=0;
    while ( ( c<48 || c>57 ) && c!='-' )  c = gc();
    if ( c=='-' ) {
        inv=1;
        c = gc();
    }
    while ( c>47 && c<58 ) {
        x = ( x << 1 ) + ( x << 3 ) + c - 48;
        c = gc();
    }
    if ( inv ) x=-x;
}
void dump ( vector<Box> &b ) {
    rep ( i,b.size() ) {
        cout<<"Box "<<i<<endl;
        cout<<b[i];
    }

}
int main() {

    int n;
    scan ( n );
    int q;
    scan ( q );
    int nBoxes= ( n-1 ) /BXSIZE+1;
    vector<Box> boxes ( nBoxes );
    int j=0;
    int k=0;
    rep ( i,n ) {
        int x;
        scan ( x );
        boxes[k].vals[j]=x;
        boxes[k].mi=min ( boxes[k].mi,x );
        boxes[k].ma=max ( boxes[k].ma,x );
        boxes[k].su+=x;
        if ( ++j==BXSIZE ) {
            k++;
            j=0;
        }
    }
    if ( j ) boxes.back().mx=j;
    vll res;
    rep ( i,q ) {
        int t, l,r,x;
        scan ( t );
        scan ( l );
        scan ( r );
        r++;
        int bmi=l/BXSIZE;
        int bma= ( r-1 ) /BXSIZE;
        int bi=l-bmi*BXSIZE;
        int be=r-bma*BXSIZE;
        if ( t<3 ) scan ( x );
        if ( t==1 ) {
            if ( bmi==bma ) {
                boxes[bmi].add ( bi,be, x );
            } else {
                boxes[bmi].add ( bi, boxes[bmi].mx,x );
                reu ( i,bmi+1, bma ) {
                    boxes[i].add ( x );
                }
                boxes[bma].add ( 0,be,x );
            }

        } else if ( t==2 ) {
            realt y=x; //1.0/x;
            if ( bmi==bma ) {
                boxes[bmi].divide ( bi,be, y );
            } else {
                boxes[bmi].divide ( bi, boxes[bmi].mx,y );
                reu ( i,bmi+1, bma ) {
                    boxes[i].divide ( y );
                }
                boxes[bma].divide ( 0,be,y );
            }

        } else if ( t==3 ) {
            int mi=INF;
            if ( bmi==bma ) {
                mi= boxes[bmi].findMin ( bi,be );
            } else {
                mi= boxes[bmi].findMin ( bi, boxes[bmi].mx );
                reu ( i,bmi+1, bma ) {
                    mi=min ( mi,   boxes[i].mi );
                }
                mi=min ( mi,  boxes[bma].findMin ( 0,be ) );
            }
            res.push_back ( mi );

        } else if ( t==4 ) {
            ll su=0;
            if ( bmi==bma ) {
                su= boxes[bmi].findSum ( bi,be );
            } else {
                su= boxes[bmi].findSum ( bi, boxes[bmi].mx );
                reu ( i,bmi+1, bma ) {
                    su+=boxes[i].su;

                }
                su+=  boxes[bma].findSum ( 0,be );
            }
            res.push_back ( su );

        }
    }
    for ( ll r: res ) printf ( "%lld\n", r );



}
// kate: indent-mode cstyle; indent-width 4; replace-tabs on; 


----------
====================
----------
DATA-STRUCTURES.117
expert
----------
PROBLEM STATEMENT:
Transforming data into some other data is typical of a programming job. This problem is about a particular kind of transformation which we'll call the max transform.

Let [expression], inclusive.

Let's define the max transform of [expression] as the array obtained by the following procedure:


Let [expression] be a list, initially empty.
For [expression]:
For [expression]:
Let [expression].  
Append [expression].  
Return [expression].  


The returned array is defined as the max transform of [expression]. 

Complete the function solve that takes an integer array [expression] as input.

Given an array [expression].  
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <iostream>
#include <sstream>
#include <deque>
#include <queue>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <vector>
#include <map>
#include <set>
#include <string>
#include <cstdlib>
#include <ctime>
using namespace std; 

#define P 1000000007
#define N 1100000

int used[N], fa[N], sum[N], f[N], now, ans, T, cc;
vector <int> V[N];
int n;
int a[N];

int gf(int x) {
	if (fa[x] != x)
		fa[x] = gf(fa[x]);
	return fa[x];
}

void merge(int x, int y) {
	x = gf(x);
	y = gf(y);
	sum[x] += sum[y];
	fa[y] = x;
}

void add(int x) {
	used[x] = 1;
	sum[x] = 1;
	if (used[x - 1]) {
		now = (now - f[sum[gf(x - 1)]] + P) % P;
		merge(x, x - 1);
	}
	if (used[x + 1]) {
		now = (now - f[sum[gf(x + 1)]] + P) % P;
		merge(x, x + 1);
	}
	now = (now + f[sum[gf(x)]]) % P;
	int L = sum[gf(1)], R = sum[gf(n)];
	// printf("?? %d %d %d\n", x, L, R);
	x = min(R, L - 1);
	if (x <= 0) {
		cc = now;
		return ;
	}
	cc = now;
	// printf("?? %d %d\n", cc, x);
	cc = (cc + 1LL * x * L * (R + 1)) % P;
	cc = (cc - 1LL * x * (x + 1) / 2 % P * (L + R + 1)) % P;
	cc = (cc + 1LL * x * (x + 1) * (2 * x + 1) / 6) % P;
	cc = (cc + P) % P;
	// printf("! %d\n", cc);
	return ;
}

int main() {
	scanf("%d", &n);
	int ma = 0;
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]), V[a[i]].push_back(i), ma = max(ma, a[i]);
	T = 1LL * n * (n + 1) / 2 % P;
	T = 1LL * T * (T + 1) / 2 % P;
	for (int i = 1; i <= n; i++)
		f[i] = (1LL * i * (i + 1) * (2 * i + 1) / 6 + 1LL * i * (i + 1) / 2) / 2 % P;
	for (int i = 1; i <= n; i++)
		fa[i] = i;
	now = 0;

	for (int i = 0; i < ma; i++) {
		for (int j = 0; j < (int) V[i].size(); j++)
			add(V[i][j]);
		ans = (ans + T - cc) % P;
	}
	ans = (ans + P) % P;
	printf("%d\n", ans);

}

----------
====================
----------
DATA-STRUCTURES.118
hard
----------
PROBLEM STATEMENT:
Given an array, you are asked to perform a number of queries and divide the array into what are called, beautiful subsequences. 

The array [expression] beautiful subsequences. Note that each element of an array should belong to exactly one subsequence, and subsequence does not necessarily need to be consecutive.   

A subsequence [expression] is called beautiful if and only if:  


[expression] or  
Let [expression]  


For instance, if [expression].  

You have to answer [expression] queries. Each query is of the type:  


[expression].  


After each query, for the value of [expression] query.  

You need to find [expression].
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================