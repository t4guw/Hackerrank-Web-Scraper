
----------
MATHEMATICS.1
easy
----------
PROBLEM STATEMENT:
Consider two points, [expression].

Given [expression] on a new line.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() 
{
	int T;
	cin >> T;
	if((1<=T) && (T <=15))
	{
		
		int x1,y1,x2,y2;
		for(int i = 0; i < T; i++)
		{
			cin >> x1 >> y1 >> x2 >> y2;
			if((x1 == x2)&&(y1 == y2))
			{ 
				cout << x1 << " " << y1 << endl;
				continue;
			}
			int x3 = x2 + (x2 - x1);
			cout << x3 << " " << ((y2 - y1)*x3 + (x2 * y1)-(y2 * x1))/(x2 - x1) << endl;
		}
	}
    return 0;
}

----------
====================
----------
MATHEMATICS.2
easy
----------
PROBLEM STATEMENT:
Jim is off to a party and is searching for a matching pair of socks. His drawer is filled with socks, each pair of a different color. In its worst case scenario, how many socks (x) should Jim remove from his drawer until he finds a matching pair?  

Input Format 
The first line contains the number of test cases T. 
Next T lines contains an integer N which indicates the total pairs of socks present in the drawer.

Output Format 
Print the number of Draws (x) Jim makes in the worst case scenario.

Constraints 
[expression] 
[expression]  

Sample Input

2
1
2


Sample Output

2
3


Explanation 
Case 1 : A pair of socks are present, hence exactly 2 draws for the socks to match. 
Case 2 : 2 pair of socks are present in the drawer. The first and the second draw might result in 2 socks of different color. The 3rd sock picked will definitely match one of previously picked socks. Hence, 3. 
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int pigeonhole(int num) {
    return num+1;
}
int main() {
    int testC;
    cin >> testC; 
    int ar [testC];
    for(int i = 0; i < testC; i++){
        cin >> ar[i];
    }
    for(int c = 0 ; c < testC; c++){
        cout << pigeonhole(ar[c]) << endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.3
easy
----------
PROBLEM STATEMENT:
At the annual meeting of Board of Directors of Acme Inc, every one starts shaking hands with everyone else in the room. Given the fact that any two persons shake hand exactly once, Can you tell the total count of handshakes?

Input Format 
The first line contains the number of test cases T, T lines follow. 
Each line then contains an integer N, the total number of Board of Directors of Acme. 

Output Format  

Print the number of handshakes for each test-case in a new line. 

Constraints  

1 
0 6  

Sample Input

2
1
2


Sample Output  

0
1


Explanation

Case 1 : The lonely board member shakes no hands, hence 0. 
Case 2 : There are 2 board members, 1 handshake takes place. 
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int T;
    cin>>T;
    long long int N[1000];
    for (int i=0; i<T; i++) {
        cin>>N[i];
    }
    
    for (int i=0; i<T; i++) {
        long long int x = N[i] - 1;
        long long int ans = (x*(x+1))/2;
        cout<<ans<<endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.4
easy
----------
PROBLEM STATEMENT:
Given integers [expression].


----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

int lowestTriangle(int b, int a){
    return 2 * a / b + ((2 * a) % b > 0);
}

int main() {
    int base;
    int area;
    cin >> base >> area;
    int height = lowestTriangle(base, area);
    cout << height << endl;
    return 0;
}


----------
====================
----------
MATHEMATICS.5
easy
----------
PROBLEM STATEMENT:
Luke is daydreaming in Math class. He has a sheet of graph paper with [expression] bases. He wants to drop supplies at strategic points on the sheet, marking each drop point with a red dot. If a base contains at least one package inside or on top of its border fence, then it's considered to be supplied. For example:



Given [expression], what's the minimum number of packages that Luke must drop to supply all of his bases?
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;

typedef int _loop_int;
#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)
#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)
#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)

#define DEBUG(x) cout<<#x<<": "<<x<<endl
#define DEBUG_VEC(v) cout<<#v<<":";REP(i,v.size())cout<<" "<<v[i];cout<<endl
#define ALL(a) (a).begin(),(a).end()

#define CHMIN(a,b) a=min((a),(b))
#define CHMAX(a,b) a=max((a),(b))

// mod
const ll MOD = 1000000007ll;
#define FIX(a) ((a)%MOD+MOD)%MOD

// floating
typedef double Real;
const Real EPS = 1e-11;
#define EQ0(x) (abs(x)<EPS)
#define EQ(a,b) (abs(a-b)<EPS)
typedef complex<Real> P;

int main(){
  int n,m;
  cin>>n>>m;
  int ans = (n+1)/2;
  ans *= (m+1)/2;
  cout<<ans<<endl;
  return 0;
}

----------
====================
----------
MATHEMATICS.6
easy
----------
PROBLEM STATEMENT:
Leonardo loves primes and created [expression] and then print this value on a new line.

Note: Recall that a prime number is only divisible by [expression] is not a prime number.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
    int a[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
    int i,t;
    unsigned long long int n;
    cin>>t;
    while(t>0)
        {
    cin>>n;
        if(n<2)
            cout<<0<<endl;
        else
   {unsigned long long int s=a[0];
            for(i=1;i<25;i++)
       { s=s*a[i];
        if(n<s)
        break; 
       }
    
    cout<<i<<endl;}
       
        t--;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.7
easy
----------
PROBLEM STATEMENT:
Gandalf is travelling from Rohan to Rivendell to meet Frodo but there is no direct route from Rohan (T1) to Rivendell (Tn). 

But there are towns T2,T3,T4...Tn-1 such that there are N1 routes from Town T1 to T2, and in general, Ni routes from Ti to Ti+1 for i=1 to n-1 and 0 routes for any other Ti to Tj  for  j ≠ i+1 

Find the total number of routes Gandalf can take to reach Rivendell from Rohan. 

Note 
Gandalf has to pass all the towns Ti for i=1 to n-1 in numerical order to reach Tn. 
For each Ti , Ti+1 there are only Ni distinct routes Gandalf can take.

Input Format 
The first line contains an integer T, T test-cases follow. 
Each test-case has 2 lines. The first line contains an integer N (the number of towns). 
The second line contains N - 1 space separated integers where the ith integer denotes the number of routes, Ni, from the town Ti to Ti+1  

Output Format 
Total number of routes from T1 to Tn modulo 1234567 
http://en.wikipedia.org/wiki/Modular_arithmetic

Constraints 
1 
2
1 i 

Sample Input  

2
3
1 3
4
2 2 2


Sample Output  

3
8


Explanation 
Case 1: 1 route from T1 to T2, 3 routes from T2 to T3, hence only 3 routes. 
Case 2: There are 2 routes from each city to the next, at each city, Gandalf has 2 choices to make, hence 2 * 2 * 2 = 8. 
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int t,n;
    cin>>t;
    while(t)
    {
        cin>>n;
        int product =1;
        while(n-1)
        {
            int temp;
            cin>>temp;
            product=(temp*product)%1234567;
            --n;
        }
        cout<<product<<endl;
        --t;
    }
    
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
MATHEMATICS.8
easy
----------
PROBLEM STATEMENT:
Mary has an [expression] pieces according to the following rules:


She can only cut one piece of paper at a time, meaning she cannot fold the paper or layer already-cut pieces on top of one another. 
Each cut is a straight line from one side of the paper to the other side of the paper. For example, the diagram below depicts the three possible ways to cut a [expression] piece of paper: 



Given [expression] unit in size. 
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
#define sz(x) ((int) (x).size())
#define forn(i,n) for (int i = 0; i < int(n); ++i)
typedef long long ll;
typedef long long i64;
typedef long double ld;
const int inf = int(1e9) + int(1e5);
const ll infl = ll(2e18) + ll(1e10);

int main() {
    #ifdef LOCAL
    assert(freopen("a.in", "r", stdin));
    #else
    #endif
    ll n, m;
    cin >> n >> m;
    cout << n * m - 1 << '\n';
}

----------
====================
----------
MATHEMATICS.9
medium
----------
PROBLEM STATEMENT:
You are given a sequence whose [expression] term is
[expression]
You have to evaluate the series
[expression]
Find [expression].
----------
TOP SOLUTION:
----------
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#include<cassert>
#include<set>
#include<queue>
#include<map>

using namespace std;

#define vi vector < int >
#define pb push_back
#define ll long long
#define llu unsigned long long
#define MOD 1000000007
#define INF 2000000000
#define dbg(x) { cout<< #x << ": " << (x) << endl; }
#define all(x) x.begin(),x.end()

int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
              ll n;
              scanf("%lld",&n);
              n%=MOD;
              ll ans = (n*n)%MOD;
              printf("%lld\n",ans);
    }
    //system("pause");
    return 0;
}

----------
====================
----------
MATHEMATICS.10
easy
----------
PROBLEM STATEMENT:
Sherlock is given [expression] plane; so that the bottom left corner of each square coincides with the the origin and their sides are parallel to the axes.  

At [expression].     

For each query of form [expression].  



Note: Assume all distances in meter, time in seconds and velocities in meter per second unless otherwise specified.  

Input Format 
First line contains integers [expression] in one line.

Constraints 
[expression] 
[expression] 
[expression] 
[expression]  

Output Format 
For each query, print the required answer in one line. Your answer will be considered correct if it is at most [expression] away from the true answer. See the explanation for more details.

Sample Input  

10 1 2
2
50
100


Sample Output  

4.1421
0.0000


Explanation  

For the first case, note that the answer is around 4.1421356237..., so any of the following will be accepted:  

4.1421356237
4.14214
4.14215000
4.1421
4.1422

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int,int> ii;
#define sz(a) int((a).size())
#define pb push_back
#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin() i = (c).begin(); i != (c).end(); i++)
#define present(c,x) ((c).find(x) != (c).end())
#define cpresent(c,x) (find(all(c),x) != (c).end())

#define S(x) scanf("%d",&x)
#define S1(x) scanf("%lld",&x)
#define P(x) printf("%d\n",x)
#define Sd(x) scanf("%lf",&x)
#define Pd(x) printf("%0.10lf\n",x)
#define P1(x) printf("%lld\n",x)
#define Ps(x) printf("%d ",x)
#define P1s(x) printf("%lld ",x)
#define St(x) scanf("%s",x)
#define Pt(x) printf("%s",x)
#define Sa(a,n) for(i=0;i<n;i++){scanf("%lld",&a[i]);}
#define Pa(a,n) for(i=0;i<n;i++){printf("%lld ",a[i]);}putchar('\n')
#define Y printf("Yes\n")
#define N printf("No\n")
#define mod 1000000007
#define ll long long

ll power(ll b, ll e) {
    ll p = 1;
    while (e > 0) {
        if(e&1) {
            p = (p*b)%mod;
        }
        e = e>>1;
        b = (b * b)%mod;
    }
    return p;
}

ll inp()
{
	ll n=0,s=1;
	char c;
	for(c=getchar_unlocked();c<48||c>58;c=getchar_unlocked())
	if(c=='-')s=-1;
	for(;c>47&&c<59;c=getchar_unlocked())
	n=n*10+c-48;
	return n*s;
}

int main()
{
	ll n,i,t,j,k,l,s1,s2,v,qi;
	double vi;
	S1(l);
	S1(s1);
	S1(s2);
	vi=sqrt(2)/abs(s1-s2);
	for(S1(t);t--;)
        Pd((l-sqrt(inp()))*vi);
	return 0;
}

----------
====================
----------
MATHEMATICS.11
easy
----------
PROBLEM STATEMENT:
Kristen loves playing with and comparing numbers. She thinks that if she takes two different positive numbers, the one whose digits sum to a larger number is better than the other. If the sum of digits is equal for both numbers, then she thinks the smaller number is better. For example, Kristen thinks that [expression].

Given an integer, [expression] that Kristin will consider to be the best?
----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;


int main(){
    int n;
    cin >> n;
    int res = -1 , www = -1 << 30;
    for (int i = 1 ; i <= n ; ++ i) {
        if (n % i == 0) {
            int sum = 0 , x = i;
            while (x) {
                sum += x % 10;
                x /= 10;
            }
            if (sum > www || sum == www && i < res) {
                res = i;
                www = sum;
            }
        }    
        
    }
    cout << res << endl;
    return 0;
}

----------
====================
----------
MATHEMATICS.12
easy
----------
PROBLEM STATEMENT:
Martha is interviewing at Subway. One of the rounds of the interview requires her to cut a bread of size [expression] into smaller identical pieces such that each piece is a square having maximum possible side length with no left over piece of bread.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int gcd(int a, int b) {
    return a==0?b:gcd(b%a,a);
}

int main() {
    int test;
    cin >> test;
    while(test--) {
        int a,b;
        cin >> a >> b;
        cout << (a/gcd(a,b))*(b/gcd(a,b)) << endl;
    }
    
    return 0;
}

----------
====================
----------
MATHEMATICS.13
easy
----------
PROBLEM STATEMENT:
Akash and Akhil are playing a game. They have [expression]. Akash will win the game, if he can answer. Help Akash.

Input Format 
The first line contains an integer [expression], i.e., the number of the test cases. 
The next [expression]. 

Output Format 
Print the final index of ball [expression] in the array.  

Constraints 
[expression] 
[expression] 
[expression]

Sample Input  

2
3 1
5 2


Sample Output  

2
4


Explanation 
For first test case, The rotation will be like this: 
0 1 2 - 2 1 0 - 2 0 1 - 2 0 1
So, Index of 1 will be 2.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

int main(){
    int t,n,k;
    scanf("%d",&t);
    while(t--){
        scanf("%d %d",&n,&k);
        if(k<n/2){
            printf("%d\n",2*k+1);
        }
        else{
            printf("%d\n",(n-1-k)*2);
        }
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.14
easy
----------
PROBLEM STATEMENT:
A strange grid has been recovered from an old book. It has [expression] columns and infinite number of rows. The bottom row is considered as the first row. First few rows of the grid are like this:

..............

..............

20 22 24 26 28

11 13 15 17 19

10 12 14 16 18

 1  3  5  7  9

 0  2  4  6  8


The grid grows upwards forever!

Your task is to find the integer in [expression]th row of the grid.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

typedef long long     LL;
typedef pair<int,int> pii;

double PI  = acos(-1);
double EPS = 1e-7;
int INF    = 1000000000;
LL INFLL   = 1000000000000000000LL;

#define fi            first
#define se            second
#define mp            make_pair
#define pb            push_back

#define input(in)     freopen(in,"r",stdin)
#define output(out)   freopen(out,"w",stdout)

#define MIN(a, b)     (a) = min((a), (b))
#define MAX(a, b)     (a) = max((a), (b))

#define RESET(a, b)   memset(a,b,sizeof(a))
#define ALL(a)        (a).begin(), (a).end()
#define SIZE(a)       (int)a.size()
#define SORT(a)       sort(ALL(a))
#define UNIQUE(a)     (a).erase( unique( ALL(a) ), (a).end() )
#define FOR(a, b, c)  for (int (a)=(b); (a)<=(c); (a)++)
#define FORD(a, b, c) for (int (a)=(b); (a)>=(c); (a)--)
#define FORIT(a, b)   for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); a++)

int mx[8] = {-1,1,0,0,-1,-1,1,1};
int my[8] = {0,0,-1,1,-1,1,-1,1};

// ----- //

int main()
{
	int r,c;
	scanf("%d%d",&r,&c);
	r--;
	c--;
	int u = r/2;
	long long ans = 2LL*c+10LL*u;
	if (r%2==1) ans += 1;
	cout << ans << endl;
}

----------
====================
----------
MATHEMATICS.15
medium
----------
PROBLEM STATEMENT:
On the eve of Diwali, Hari is decorating his house with a serial light bulb set. The serial light bulb set has N bulbs placed sequentially on a string which is programmed to change patterns every second. If at least one bulb in the set is on at any given instant of time, how many different patterns of light can the serial light bulb set produce? 

Note: Lighting two bulbs *-* is different from **- 

Input Format 
The first line contains the number of test cases T, T lines follow. 
Each line contains an integer N, the number of bulbs in the serial light bulb set. 

Output Format 
Print the total number of patterns modulo 105

Constraints 
1 
04

Sample Input

2
1
2


Sample Output

1
3


Explanation

Case 1: 1 bulb can be lit in only 1 way. 
Case 2: 2 bulbs can be lit in -*, *-, ** i.e. 3 ways. 
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int c=100000;
long long power2(int n)
{
    if(n==0)
        return 1;
    else if(n==1)
        return 2;
    long long temp=power2(n/2);
    if(n%2==0)
    {
        temp=temp*temp;
        if(temp>=c)
            temp%=c;
    }
    else
    {
        temp=temp*temp*2;
        if(temp>=c)
            temp%=c;
    }
    return temp;
}

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int t;
    scanf("%d",&t);
    while(t--)
    {
        int n;
        scanf("%d",&n);
        long long val;
        val=power2(n);
        val-=1;
        printf("%lld\n",val);
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.16
easy
----------
PROBLEM STATEMENT:
Watson gives an integer [expression] that are divisible by 2?.    

Input Format 
First line contains [expression].   

Output Format 
For each testcase, print the required answer in one line.      

Constraints 
[expression] 
[expression]  

Sample Input  

2
9
8


Sample Output   

0
3


Explanation 
9 has three divisors 1, 3 and 9 none of which is divisible by 2. 
8 has four divisors 1,2,4 and 8, out of which three are divisible by 2.  
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>

using namespace std;

int main()
{
	int t;
	scanf("%d",&t);
	while( t-- ) {
		long long n,i,j,k,l;
		scanf("%lld",&n);
		long long ans =0;
		for(i=1;i*i<=n;i++){
			if(n%i==0){
			if(n/i!=i){
				k = n/i;
				if(!(k&1))
				ans++;
			}
			if(!(i&1))
				ans++;
				
				}
			}
			printf("%lld\n",ans);
	}
	return 0;
}
----------
====================
----------
MATHEMATICS.17
hard
----------
PROBLEM STATEMENT:
Watson asks Sherlock: 
Given a string S of N 0's and M 1's, how many unique permutations of this string start with 1?   

Help Sherlock by printing the answer modulo (109+7).   

Input Format 
First line contains T, the number of test cases. 
Each test case consists of N and M separated by a space.

Output Format 
For each test case, print the answer modulo (109+7).

Constraints 
1 ≤ T ≤ 200 
1 ≤ N,M ≤ 1000  

Sample Input   

2
1 1
2 3


Sample Output      

1
6


Explanation 
Test1: Out of all unique permutations ie. 01 and 10, only second permutation satisfies. Hence, output is 1. 
Test2: Out of all unique permutations ie. 00111 01011 01101 01110 10011 10101 10110 11001 11010 11100, only 10011 10101 10110 11001 11010 11100 satisfy. Hence, output is 6.
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <climits>
#include <cstring>
#include <map>
#include <queue>
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <iostream>
#include <stack>
#include <deque>
#include <list>
#include <unordered_map>
#include <unordered_set>
#include <cassert>
using namespace std;
#define FOR(i,c) for(auto &i: c)
#define SZ size()
#define ALL(x) (x).begin(),(x).end()
#define REP(i,n) for(int i=0;i<(n);i++)
#define REP1(i,a,b) for(int i=(a);i<=(b);i++)
#define REPL(i,x) for(int i=0;x[i];i++)
#define PER(i,n) for(int i=(n)-1;i>=0;i--)
#define PER1(i,a,b) for(int i=(a);i>=(b);i--)
#define RI(x) scanf("%d",&x)
#define RL(x) scanf("%lld",&x)
#define DRI(x) int x;RI(x)
#define DRL(x) LL x;RL(x)
#define RII(x,y) scanf("%d%d",&x,&y)
#define DRII(x,y) int x,y;RII(x,y)
#define RIII(x,y,z) scanf("%d%d%d",&x,&y,&z)
#define DRIII(x,y,z) int x,y,z;RIII(x,y,z)
#define RS(x) scanf("%s",x)
#define PI(x) printf("%d\n",x)
#define PL(x) printf("%lld\n",x)
#define PIS(x) printf("%d ",x)
#define MP make_pair
#define PB push_back
#define PQ priority_queue
#define E emplace
#define EB emplace_back
#define MS0(x) memset(x,0,sizeof(x))
#define MS1(x) memset(x,-1,sizeof(x))
#define SEP(x) ((x)?'\n':' ')
#define F first
#define S second
#define V(x) vector<x >

typedef pair<int,int> PII;
typedef vector<int> VI;
typedef long long LL;
typedef unsigned long long ULL;
const int INF = 2000000000;

const int MOD = 1000000007;
struct Z {
  int i;
  Z():i(0) {}
  Z(int i): i(i) {}
  void operator +=(const Z& z) { i += z.i; if(i >= MOD) i -= MOD; }
  void operator -=(const Z& z) { i -= z.i; if(i < 0) i += MOD; }
  void operator *=(const Z& z) { i = (LL) i * z.i % MOD; }
  void operator /=(const Z& z) { (*this) *= z.inverse(); }
  Z operator +(const Z& z) const { Z ret(i); ret += z; return ret; }
  Z operator -(const Z& z) const { Z ret(i); ret -= z; return ret; }
  Z operator *(const Z& z) const { Z ret(i); ret *= z; return ret; }
  Z operator /(const Z& z) const { return (*this) * z.inverse(); }
  // Z operator -() const { return Z(-i); }
  Z inverse() const {
    int a = i, d = MOD, x = 0, s = 1;
    while(a) {
      int q = d / a, r = d % a, t = x - q * s;
      d = a, a = r, x = s, s = t;
    }
    if (d != 1) return -1;
    return x < 0 ? x + MOD : x;
  }
  Z pow(int b) {
    Z x=1,y=*this; // ll is taken to avoid overflow of intermediate results
    while(b > 0){
      if(b%2 == 1)
        x *= y;
      y *= y; // squaring the base
      b /= 2;
    }
    return x;
  }
};

vector<Z> factorial(1, 1), inv_factorial(1, 1);

Z inv_fact(int n) {
  while(inv_factorial.size() <= n)
    inv_factorial.push_back(inv_factorial.back() / inv_factorial.size());
  return inv_factorial.at(n);
}

Z fact(int n) {
  while(factorial.size() <= n)
    factorial.push_back(factorial.back() * factorial.size());
  return factorial.at(n);
}

Z choose(int n, int k) {
  if(n < k) return 0;
  return fact(n) * (inv_fact(k) * inv_fact(n-k));
}

int main() {
  DRI(T);
  while(T--) {
    DRII(N, M);
    PI(choose(N+M-1, N).i);
  }
  return 0;
}
----------
====================
----------
MATHEMATICS.18
hard
----------
PROBLEM STATEMENT:
You are given an array A of size N. You are also given an integer Q. Can you figure out the answer to each of the Q queries?

Each query contains 2 integers x and y, and you need to find whether the value find(x,y) is Odd or Even:

find(int x,int y)
{
    if(xy) return 1;
    ans = pow(A[x],find(x+1,y))
    return ans
}


Note : pow(a,b) = ab.

Input Format 
The first line of the input contains an integer N. 
The next line contains N space separated non-negative integers(whole numbers less than or equal to 9). 
The line after that contains a positive integer, Q , the denotes the number of queries to follow.
Q lines follow, each line contains two positive integer x and y separated by a single space.   

Output Format 
For each query, display 'Even' if the value returned is Even, otherwise display 'Odd'.

Constraints 
2 ≤ N ≤ 105 
2 ≤ Q ≤ 105 
1 ≤ x,y ≤ N 
x ≤ y

Array is 1-indexed.  

No 2 consecutive entries in the array will be zero.

Sample Input 

3
3 2 7
2
1 2
2 3


Sample Output 

Odd
Even


Explanation

find(1,2) = 9, which is Odd 
find(2,3) = 128, which is even  
----------
TOP SOLUTION:
----------
#include<iostream>
#include<vector>

using namespace std;

int main(){
    vector<int> a;
    int n, q, x, y, t;
    cin>>n;
    
    for( int i = 0; i < n; i++ ){
        cin>>t;
        a.push_back(t);
    }
    
    cin>>q;
    
    for( int i = 0; i < q; i++ ){
        cin>>x>>y;
        
        if( x > y || a[x-1] % 2 || ( x < y && a[x] == 0 ) ) cout<<"Odd";
        else    cout<<"Even";
        
        cout<<endl;
    }    
    
    return 0;  
}
----------
====================
----------
MATHEMATICS.19
medium
----------
PROBLEM STATEMENT:
You are given an integer N. Can you find the least positive integer X made up of only 9's and 0's, such that, X is a multiple of N?

Update  

X is made up of one or more occurences of 9 and zero or more occurences of 0. 

Input Format 
The first line contains an integer T which denotes the number of test cases. T lines follow. 
Each line contains the integer N for which the solution has to be found.

Output Format 
Print the answer X to STDOUT corresponding to each test case. The output should not contain any leading zeroes. 

Constraints 
1 4 
1 

Sample Input  

3
5
7
1


Sample Output  

90
9009
9


Explanation 
90 is the smallest number made up of 9's and 0's divisible by 5. 
Similarly, you can derive for other cases. 

Timelimits
Timelimits for this challenge is given here
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 5555;

bool was[N];
int x[N], pr[N], pd[N];

int main() {
    int tt;
    cin >> tt;
    while (tt--) {
        int n;
        cin >> n;
        for (int i = 0; i < n; i++) was[i] = false;
        int b = 1, e = 1;
        x[1] = 9 % n;
        was[x[1]] = true;
        pr[x[1]] = -1;
        pd[x[1]] = -1;
        while (b <= e) {
            int nx = (x[b] * 10 + 0) % n;
            if (!was[nx]) {
                e++;
                x[e] = nx;
                was[nx] = true;
                pr[nx] = x[b];
                pd[nx] = 0;
            }
            nx = (x[b] * 10 + 9) % n;
            if (!was[nx]) {
                e++;
                x[e] = nx;
                was[nx] = true;
                pr[nx] = x[b];
                pd[nx] = 9;
            }
            b++;
        }
        int p = 0;
        string res = "";
        while (pr[p] != -1) {
            res += (char)(pd[p] + 48);
            p = pr[p];
        }
        res += "9";
        reverse(res.begin(), res.end());
        cout << res << endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.20
hard
----------
PROBLEM STATEMENT:
A word from the English dictionary is taken and arranged as a matrix. e.g. "MATHEMATICS"

MATHE  
ATHEM  
THEMA  
HEMAT  
EMATI  
MATIC  
ATICS  


There are many ways to trace this matrix in a way that helps you construct this word. You start tracing the matrix from the top-left position and at each iteration, you either move RIGHT or DOWN, and ultimately reach the bottom-right of the matrix. It is assured that any such tracing generates the same word. How many such tracings can be possible for a given
word of length m+n-1 written as a matrix of size m * n?

Input Format 
The first line of input contains an integer T. T test cases follow. 
Each test case contains 2 space separated integers m & n (in a new line) indicating that the matrix has m rows and each row has n characters.  

Constraints 
1 3 
1 ≤ m,n ≤ 106

Output Format 
Print the number of ways (S) the word can be traced as explained in the problem statement.
If the number is larger than 109+7, 
print  S mod (10^9 + 7) for each testcase (in a new line). 

Sample Input

1
2 3


Sample Output

3


Explanation 
Let's consider a word AWAY written as the matrix

AWA
WAY


Here, the word AWAY can be traced in 3 different ways, traversing either RIGHT or DOWN.

AWA
  Y

AW
 AY

A
WAY


Hence the answer is 3.

Timelimit
Time limit for this challenge is given here
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

const int md = 1000000007;
const int co = 2000010;

long long fact[co + 10], inv[co + 10];

int main() {
    fact[0] = 1;
    for (int i = 1; i <= co; i++) fact[i] = fact[i - 1] * i % md;
    for (int i = 0; i <= co; i++) {
        int x = 1, step = 1 << 30;
        while (step > 0) {
          x = (long long)x * x % md;
          if (step & (md - 2)) x = (long long)x * fact[i] % md;
          step >>= 1;
        }
        inv[i] = x;
    }
    int tt;
    cin >> tt;
    while (tt--) {
        int n, m;
        cin >> n >> m;
        long long ans = fact[n + m - 2];
        ans = ans * inv[n - 1] % md;
        ans = ans * inv[m - 1] % md;
        cout << ans << endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.21
medium
----------
PROBLEM STATEMENT:
Simon: On the fountain, there should be 2 jugs - a 5 gallon and a 3 gallon. Do you see them? Fill one of the jugs with exactly 4 gallons of water and place it on the scale and the timer will stop. You must be precise; one ounce more or less will result in detonation. If you’re still alive in 5 minutes, we’ll speak. 

Bruce: Wait, wait a second. I don’t get it. Do you get it?   

Samuel: No. 

Bruce: Get the jugs. Obviously, we can’t ﬁll the 3 gallon jug with 4 gallons of water. 

Samuel: Obviously. 

Bruce: All right. I know, here we go. We ﬁll the 3 gallon jug exactly to the top, right? 

Samuel: Uh huh. 

Bruce: Okay, now we pour this 3 gallons into the 5 gallon jug, giving us exactly 3 gallons in the 5 gallon jug, right? 

Samuel: Right, then what? 

Bruce: We take the 3 gallon jug and ﬁll it a third of the way... 

Samuel: No! He said, “Be precise.” Exactly 4 gallons. 

Bruce: Damn! Every cop within 50 miles is running his ass off and I’m out here playing a kids' games in the park. 

Samuel: Hey, you want to focus on the problem at hand? 

Given 2 jugs of capacity a and b gallons, and an infinite supply of water, can you fill one of the jugs with exactly c gallons of water ? 

Input Format

First line contains the number of testcases T. T lines follow. 
Each line contains 3 space separated integers a, b and c . a and b indicate the capacity of the two jugs respectively, and c denotes the exact capacity with which one of the jugs should be filled.  

Output Format

For each test case, print "YES" (in a new line) if one of the jugs can be filled with exactly c gallons of water and "NO" (in a new line) if they cannot be filled. ( quotes are for clarity )

Constraints

1 ≤ a, b, c ≤ 103 
1 ≤ T ≤ 100

Sample Input

2
5 3 4
3 6 4


Sample Output

YES
NO


Explanation

Bruce can do the following, fill jug a with 5 gallons. 

a = 5, b = 0


Now, he can fill jug b with 3 gallons from jug a.  

a = 2, b = 3


He can empty jug b and empty 2 gallons from jug a to jug b.  

a = 0, b = 2


Now, he can fill jug a with 5 gallons and fill jug b with 1 gallon from jug a.  This results in jug a containing exactly 4 gallons of water.  

a = 5, b = 2
a = 4, b = 3


In the second testcase, it is impossible to generate 4 gallons of water, hence NO.  
----------
TOP SOLUTION:
----------
#include <iostream>
#include <stdio.h>
using namespace std;

int hcf(int a,int b)
{
	if(b==0)
	return a;
	else
	return hcf(b,a%b);
}

int main() 
{
	int t,a,b,c;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d %d %d",&a,&b,&c);
		int ast=hcf(a,b);
		int number=a>b?a:b;
		if(c%ast==0 && c<=number)
		cout<<"YES"<<endl;
		else
		cout<<"NO"<<endl;
	}
	return 0;
}
----------
====================
----------
MATHEMATICS.22
easy
----------
PROBLEM STATEMENT:
Alex is attending a Halloween party with his girlfriend, Silvia. At the party, Silvia spots the corner of an infinite chocolate bar (two dimensional, infinitely long in width and length).  

If the chocolate can be served only as 1 x 1 sized pieces and Alex can cut the chocolate bar exactly [expression] times, what is the maximum number of chocolate pieces Alex can cut and give Silvia?

Input Format 
The first line contains an integer [expression] lines follow.
Each line contains an integer [expression].  

Output Format
[expression] lines; each line should contain an integer that denotes the maximum number of pieces that can be obtained for each test case.

Constraints
[expression]
[expression]

Note: Chocolate must be served in 1 x 1 sized pieces. Alex can't relocate any of the pieces, nor can he place any piece on top of another.

Sample Input #00  

4
5
6
7
8


Sample Output #00  

6
9
12
16


Explanation
The explanation below is for the first two test cases. The rest of them follow a similar logic.

For the first test-case where [expression] vertical cuts. 

For the second test case, where [expression] vertical cuts.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int t,k;
    for(cin>>t;t--;) {
        cin>>k;
        int l=k/2;
        long long r=k-l;
        cout<<l*r<<'\n';
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.23
easy
----------
PROBLEM STATEMENT:
Animesh has [expression] (both inclusive).
Can you tell the average number of candies after [expression] operations?
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int N, M;
    long long tot = 0;
    cin >> N >> M;
    for(int i=0;i<M;i++){
        int a, b;
        long long k;
        cin >> a >> b >> k;
        tot+= (b-a+1)*k;
    }
    
    cout << tot/N << endl;
    return 0;
}

----------
====================
----------
MATHEMATICS.24
medium
----------
PROBLEM STATEMENT:
You are given an integer, [expression] is an element of the Fibonacci sequence.  

The first few elements of the Fibonacci sequence are [expression]. 

Formally: 
[expression]

Input Format 
The first line contains [expression], number of test cases. 
[expression].

Output Format 
Display IsFibo if [expression] is a Fibonacci number and IsNotFibo  if it is not. The output for each test case should be displayed in a new line.

Constraints 
[expression] 
[expression]

Sample Input  

3
5
7
8


Sample Output  

IsFibo
IsNotFibo
IsFibo


Explanation 
[expression] 
[expression] is not a Fibonacci number 
[expression]  

Time Limit 
Time limit for this challenge is given here. 

----------
TOP SOLUTION:
----------
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <set>

using namespace std;

set<long long> fib;

int main() {
    long long a = 1, b = 1;
    fib.insert(0); fib.insert(1);
    
    while (b <= 10000000000LL) {
        long long c = a + b;
        fib.insert(c);
        a = b; b = c;
    }
    
    int n; scanf("%d", &n);
    for (int i = 0; i < n; ++ i) {
        long long q;
        scanf("%lld", &q);
        if (fib.count(q)) printf("IsFibo\n");
        else printf("IsNotFibo\n");
    }
    
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    
    return 0;
}

----------
====================
----------
MATHEMATICS.25
medium
----------
PROBLEM STATEMENT:
Jim enters a candy shop which has N different types of candies, each candy is of the same price. Jim has enough money to buy K candies. In how many different ways can he purchase K candies if there are infinite candies of each kind? 

Input Format 
The first line contains an integer T, the number of tests. 
This is followed by 2T lines which contain T tests: 
The first line (of each testcase) is an integer N and the second line (of each testcase) is an integer K.   

Output Format 
For each testcase, print the number of ways Jim can buy candies from the shop in a newline. If the answer has more than 9 digits, print the last 9 digits.  

Note 
This problem may expect you to have solved nCr Table

Constraints 
1 
1 
1 

Sample Input  

2
4
1
2
3


Sample Output  

4
4


Explanation 
There are 2 testcases, for the first testcase we have N = 4 and K = 1, as Jim can buy only 1 candy, he can choose to buy any of the 4 types of candies available. Hence, his answer is 4.
For the 2nd testcase, we have N = 2 and K = 3, If we name two chocolates as a and b, he can buy 

aaa bbb aab abb 


chocolates, hence 4. 
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int C[2002][2002];

int Comb(int n, int r){
    //cout<<n<<" "<<r<<endl;
    if(C[n][r] != -1){
        return C[n][r];
    }
    else if(n == 1){
        C[1][1] = 1;
        C[1][0] = 1;
        return C[1][1];
    }
    else if(r==0 || r == n){
        C[n][0] = 1;
        C[n][n] = 1;
        return C[n][0];
    }
    else{
        long long a = ((long long)Comb(n-1,r) + (long long)Comb(n-1,r-1))%1000000000;
        C[n][r] = (int)a;
        C[n][n-r] = (int)a;
        return C[n][r];
    }
}


int main() {
    int t, n, r,i,j,k;
    cin>>t;
    for(i=0;i<=2001;i++){
        for(j=0;j<=2001;j++){
            C[i][j] = -1;
        }
    }
    while(t-- > 0){
        cin>>n;
        cin>>k;
        cout<<Comb(n+k-1,k)<<endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.26
easy
----------
PROBLEM STATEMENT:
Famous wizard Sumar moonji kumaru is stuck in a huge room and has to save Hermione Granger from a monster. Kumaru is at location P1 given by integral coordinates (x1,y1) and Hermione is at location P2 given by integral coordinates (x2,y2). 
Sadly P1 and P2 are the only points at which floating rocks are present. Rest of the room is without floor and underneath is hot lava. 

Kumaru has to go from P1 to P2 but there are no floating rocks to walk on. Kumaru knows a spell that can make the rocks appear but only on the integral coordinates on the straight line joining P1 and P2.

How many rocks can appear at locations (x,y) on the line segment between P1 and P2 (excluding P1 and P2) which satisfy the condition that both x and y are integers?

Input Format 
The first line contains a single integer T, the number of test cases. T lines follow. 
 Each of the following T lines contains one test case each. Each test case contains 4 integers x1, y1, x2 and y2 separated by a single space. 

Output Format 
A single line containing the number of rocks.

Constraints 
1 5 
-109 1, y1, x2, y2 9

Sample input  

3
0 2 4 0
2 2 5 5
1 9 8 16


Sample Output

1
2
6


Explanation   



Case 1: As shown in the figure, between (0,2) and (4,0) there's only 1 integral point (2,1) hence 1 rock. 
Case 2: Between (2,2) and (5,5) lies (3,3) and (4,4), hence 2 rocks. 
Case 3: Between (1,9) and (8,16) there lies 6 rocks at positions (2,10) (3,11) (4,12) (5,13) (6,14) (7,15).  
----------
TOP SOLUTION:
----------
    #include<math.h>
    #include<algorithm>
    #include<cstdlib>
    #include<iostream>
    #include<stdio.h>
    #include<map>
    #include<ext/hash_map>
    #include<ext/hash_set>
    #include<set>
    #include<string>
    #include<assert.h>
    #include<vector>
    #include<time.h>
    #include<queue>
    #include<deque>
    #include<sstream>
    #include<stack>
    #include<sstream>
    #define INF 2000000000
    #define MA(a,b) ((a)>(b)?(a):(b))
    #define MI(a,b) ((a)<(b)?(a):(b))
    #define AB(a) (-(a)<(a)?(a):-(a))
    #define Pr 1000000007ll
    #define X first
    #define Y second
    #define mp make_pair
    #define pb push_back
    #define pob pop_back
    #define ep 0.0000000001
    #define pi 3.1415926535897932384626433832795

    using namespace std;
    using namespace __gnu_cxx;
    const int N=10000;
    int x,y,xx,yy,t,s,n,m,i,l,r;
    int main()
    {
        cin>>t;
        while (t--)
        {
            scanf("%d%d%d%d",&x,&y,&xx,&yy);
            printf("%d\n",__gcd(abs(x-xx),abs(y-yy))-1);

        }

        return 0;
    }

----------
====================
----------
MATHEMATICS.27
easy
----------
PROBLEM STATEMENT:
We all know how to calculate [expression] can be large, which makes exponentiation very slow.

There is a well known method called Russian Peasant Multiplication that you can read about here. Now let's use this to raise some complex numbers to powers!

You're given [expression] as two space-separated integers on a new line. 
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

typedef pair<long, long> num;

long mod;

num operator* (num a, num b){
    long r = a.first * b.first - a.second * b.second;
    r %= mod;
    if (r < 0) r += mod;
    
    long i = a.second * b.first + a.first * b.second;
    i %= mod;
    if (i < 0) i += mod;
    
    return {r, i};
}

num raise(num z, long n){
    if (n == 1) return z;
    auto tmp = raise(z, n/2);
    if (n%2) return tmp * tmp * z;
    return tmp*tmp;
}

int main() {
    long q;
    cin >> q;
    while (q--){
        long a, b, k, m;
        cin >> a >> b >> k >> m;
        num z(a, b);
        mod = m;
        num r = raise(z, k);
        cout << r.first << ' ' << r.second << endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.28
medium
----------
PROBLEM STATEMENT:
There are [expression] people. 

They live near a bus stop, and only a single bus operates on this route. An empty bus arrives at the bus stop and all the groups want to travel by the bus. 

However,  group of friends do not want to get separated. So they enter the bus only if the bus can carry the entire group. 

Moreover, the groups do not want to change their relative positioning while travelling.  In other words, group 3 cannot travel by bus, unless group 1 and group 2 have either (a) already traveled by the bus in the previous trip or (b) they are also sitting inside the bus at present.

You are given that a bus of size [expression] people simultaneously. 

Find the size [expression] of the bus so that 
(1) the bus can transport all the groups and 
(2) every time when the bus starts from the bus station, there is no empty space in the bus (i.e. the total number of people present inside the bus is equal to [expression])?

Input Format 
The first line contains an integer [expression].

Output Format

Print all possible sizes of the bus in an increasing order.

Sample Input

8
1 2 1 1 1 2 1 3


Sample Output

3 4 6 12


Sample Explanation

In the above example, 
[expression] = 3.

If x = 1 : 
In the first trip, [expression] go by the bus.
There will be no second trip because the bus cannot accommodate group 2. Hence "x = 1" is not the required answer.

If x = 2 :
No bus trip is possible. That's because [expression] cannot go together, because the bus is cannot accommodate both the groups simultaneously.

If x = 3 : 
In the first trip, [expression] go by the bus. 
In the second trip, [expression] go by the bus. 
In the third trip, [expression] go by the bus. 
In the fourth trip, [expression] go by the bus. 

If x = 4 : 
In the first trip, [expression] go by the bus. 
In the second trip,  [expression]go by the bus. 
In the third trip, [expression] go by the bus. 

Similarly you can figure out the output for x= 5, 6 & 7.
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void writer(int x, char c){int i,sz=0,m=0;char buf[10];if(x<0)m=1,x=-x;while(x)buf[sz++]=x%10,x/=10;if(!sz)buf[sz++]=0;if(m)mypc('-');while(sz--)mypc(buf[sz]+'0');mypc(c);}

int N, A[110000];

int res[100000], ress;
int sum;

int check(int k){
  int i, j;
  int now;

  now = 0;
  rep(i,N){
    now += A[i];
    if(now > k) return 0;
    if(now==k) now = 0;
  }

  return 1;
}

int main(){
  int i, j, k;

  reader(&N);
  rep(i,N) reader(A+i);

  sum = 0;
  rep(i,N) sum += A[i];

  ress = 0;
  for(i=1;i*i<=sum;i++) if(sum%i==0){
    if(check(i)) res[ress++] = i;
    if(i!=sum/i && check(sum/i)) res[ress++] = sum/i;
  }

  sort(res,res+ress);
  rep(i,ress) writer(res[i], i==ress-1?'\n':' ');

  return 0;
}

----------
====================
----------
MATHEMATICS.29
easy
----------
PROBLEM STATEMENT:
Keko has [expression] coordinate to zero.   

Help Keko calculate the distance!
----------
TOP SOLUTION:
----------
// Author : Bony Roopchandani

#include <bits/stdc++.h>
using namespace std;

double pointDistance(long long x1, long long y1, long long x2, long long y2) {
	//cout<<x1<<' '<<x2<<' '<<y1<<' '<<y2<<endl;
	return hypot(x2-x1, y2-y1);
}

double calcMaxDistance(long long* quadX, long long* quadY) {
	double dist=0;
	for(int i=0; i<4; i++) {
		for(int j=i+1; j<4; j++) {
			dist = max(dist, pointDistance(quadX[i], quadY[i], quadX[j], quadY[j]));
		}
	}
	return dist;
}

int main(void) {
	ios_base::sync_with_stdio(false);
	int N;
	cin>>N;
	long long x, y, 
	quadX[4]{}, quadY[4]{};
	while(N--) {
		cin>>x>>y;
		if(x == 0) {
			if(y < 0) {
				if(-y > -quadY[0]) {
					quadY[0]=y;
					quadX[0]=x;
				}
			}
			else {
				if(y > quadY[1]) {
					quadY[1]=y;
					quadX[1]=x;
				}
			}
		}
		else {
			if(x < 0) {
				if(-x > -quadX[2]) {
					quadX[2]=x;
					quadY[2]=y;
				}
			}
			else {
				if(x > quadX[3]) {
					quadX[3]=x;
					quadY[3]=y;
				}
			}
		}
	}
	cout<<setprecision(6)<<fixed<<calcMaxDistance(quadX, quadY)<<endl;
	return (0);
}
----------
====================
----------
MATHEMATICS.30
medium
----------
PROBLEM STATEMENT:
Jim runs a big burger restaurant and, to entertain his customers, he always tell them jokes. He is running out of jokes and he needs you to help him find new ones.

An often heard programmer joke goes like this:

"Why do programmers always mix up Christmas and Halloween? Because Dec 25 is Oct 31".

Got it? :-) It is because [expression] (31 in Octal).

If we are talking about dates, then let [expression]). Let's describe some slightly different jokes:

"Why do programmers always mix up event [expression]". 

Here [expression].  

Jim knows that his customers love this kind of jokes. That's why he gives you a calendar with [expression] events in it and asks you to count the number of such jokes he can create using the given events.

Two jokes ([expression]) differ if they don't contain the same events.

Note: 


The given numbers are all represented with digits from 0-9, that's why for months like [expression], we can't use additional characters to represent 10 or 11. 
It might happen, that a special event cannot be used for a joke because the base conversion is invalid. For example [expression].  
Unary base is invalid.  
Two events can have the same date.


Input Format

On the first line you will get [expression] of the special events, each separated by a single space. 

Output Format

Print the number of jokes Jim can make.

Constraints 


[expression]
([expression]) will be a valid date in the Gregorian Calendar without leap day. 


Sample Input #1

2
10 25
8 31


Sample Output #1

1


Sample Input #2

2
2 25
2 25


Sample Output #2

0


Sample Input #3

2
11 10
10 11


Sample Output #3

1


Explanation

There are two special events happening on [expression]. He can make one joke, namely the one described in the description.

In the second test case there are no valid dates we can use for our jokes since 25 is not defined for base 2.

In the third test case [expression].
----------
TOP SOLUTION:
----------
#define _USE_MATH_DEFINES
#define _CRT_SECURE_NO_DEPRECATE

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <climits>
#include <cfloat>
#include <ctime>
#include <cassert>
#include <map>
#include <utility>
#include <set>
#include <iostream>
#include <memory>
#include <string>
#include <vector>
#include <algorithm>
#include <functional>
#include <sstream>
#include <complex>
#include <stack>
#include <queue>
#include <numeric>
#include <list>
#include <iomanip>
#include <fstream>
#include <iterator>
#include <bitset>

using namespace std;

typedef long long ll;
typedef pair<int, int> Pii;
typedef pair<ll, ll> Pll;

#define FOR(i,n) for(int i = 0; i < (n); i++)
#define sz(c) ((int)(c).size())
#define ten(x) ((int)1e##x)
#define tenll(x) ((ll)1e##x)
template<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }


int main(){
	int n; cin >> n;
	map<int, int> mp;
	FOR(i, n){
		int x, y; cin >> x >> y;
		int val = 0;
		int cur = 1;
		while (y) {
			int a = y % 10;
			if (a >= x) {
				val = -1;
				break;
			}
			val += a * cur;
			cur *= x;
			y /= 10;
		}
		if (val >= 0) {
			mp[val]++;
		}
	}

	ll ans = 0;
	for (auto kv : mp) {
		ll x = kv.second * ll(kv.second - 1) / 2;
		ans += x;
	}
	cout << ans << endl;

	return 0;
}
----------
====================
----------
MATHEMATICS.31
easy
----------
PROBLEM STATEMENT:
Adam is standing at point [expression]) co-ordinates.  

Tell Adam whether he can reach [expression] or not.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
	int t;
	scanf("%d", &t);
	for (int i = 0; i < t; i++) {
        long long a, b, c, d;
        cin >> a >> b >> c >> d;
        puts(__gcd(a,b) == __gcd(c,d) ? "YES" : "NO");
	}

	return 0;
}

----------
====================
----------
MATHEMATICS.32
medium
----------
PROBLEM STATEMENT:
Since you know how to compute large Fibonacci numbers quickly using matrix exponentiation, let's take things to the next level.  

Let [expression] be positive integers. We define two bi-infinite sequences
[expression]
and
[expression]
as follows:  

[expression]

and  

[expression]

Given [expression].  

This link may help you get started: http://fusharblog.com/solving-linear-recurrence-for-programming-contest/
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

const i64 P = 1000000000;

vvi64 mul(const vvi64 &a, const vvi64 &b) {
    int n = a.size();
    vvi64 c(n, vi64(n));
    forn(i, n) forn(j, n) forn(k, n) {
        c[i][k] += a[i][j] * b[j][k];
        c[i][k] %= P;
    }
    return c;
}

vvi64 deg(vvi64 a, i64 d) {
    int n = a.size();
    vvi64 c(n, vi64(n));
    forn(i, n) c[i][i] = 1;
    while (d) {
        if (d & 1) c = mul(c, a);
        a = mul(a, a);
        d /= 2;
    }
    return c;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int T;
    cin >> T;
    forn(t, T) {
        int a, b, c, d, e, f, g, h;
        i64 n;
        cin >> a >> b >> c >> d >> e >> f >> g >> h >> n;
        vvi64 m(24, vi64(24));
        forn(i, 9) m[i + 1][i] = m[i + 11][i + 10] = 1;
//        m[0][a - 1] = m[0][10 + b - 1] = m[0][10 + c - 1] = m[0][20] = 1;
        ++m[0][a - 1];
        ++m[0][10 + b - 1];
        ++m[0][10 + c - 1];
        ++m[0][20];
//        m[10][f - 1] = m[10][g - 1] = m[10][10 + e - 1] = m[10][22] = 1;
        ++m[10][f - 1];
        ++m[10][g - 1];
        ++m[10][10 + e - 1];
        ++m[10][22];
        m[20][20] = m[20][21] = d;
        m[21][21] = d;
        m[22][22] = m[22][23] = h;
        m[23][23] = h;
        vvi64 mm = deg(m, n + 1);
        vi64 v0(24, 1);
        v0[20] = v0[22] = 0;
        i64 x = 0, y = 0;
        forn(i, 24) {
            x += mm[0][i] * v0[i]; x %= P;
            y += mm[10][i] * v0[i]; y %= P;
        }
        cout << x << ' ' << y << '\n';
    }

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
MATHEMATICS.33
easy
----------
PROBLEM STATEMENT:
Manipulating numbers is at the core of a programmer's job. To test how well you know their properties, you are asked to solve the following problem.

You are given [expression]. You can reorder the digits as you want. The resulting number can contain leading zeros.

For example, consider the numbers [expression] from which you have to construct a new integer as described above. Numerous arrangements of digits are possible; but we have illustrated one below. 



Complete the function canConstruct which takes an integer array as input and return "Yes" or "No" based on whether or not the required integer can be formed.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

int main() {
#ifdef AZINO777
    freopen("in", "r", stdin);
#endif
    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);
    int t;
    cin >> t;
    for (int tt = 0; tt < t; tt++) {
        int n;
        cin >> n;
        int sm = 0;
        for (int i = 0; i < n; i++) {
            int x;
            cin >> x;
            while (x) {
                sm += x % 10;
                x /= 10;
            }
        }
        if (sm % 3 == 0) {
            cout << "Yes" << endl;
        } else {
            cout << "No" << endl;
        }
    }
}
----------
====================
----------
MATHEMATICS.34
medium
----------
PROBLEM STATEMENT:
You are given 3 numbers a, b and x. You need to output the multiple of x which is closest to ab. If more than one answer exists , display the smallest one. 
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cmath>
using namespace std;

int main() {
	int x, a , b, t, ab, rem;
	cin>>t;
	
	while( t-- ){
		cin>>a>>b>>x;
		ab = pow(a,b);
		rem = ab % x;
		
		if( rem <= x/2 )	cout<<ab-rem;
		else	cout<<ab+(x-rem);
		
		cout<<endl;
	}
	return 0;
}
----------
====================
----------
MATHEMATICS.35
easy
----------
PROBLEM STATEMENT:
Sherlock is stuck while solving a problem: Given an array [expression] of this array which follows these statements:


[expression] is a non-empty subset.
There exists no integer [expression].
There are no elements of [expression] which are equal to another.

----------
TOP SOLUTION:
----------
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <math.h>
#include <set>
#include <map>

using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    int t;
    cin >> t;
    while(t-->0)
    {
        int n;
        cin >> n;
        int g, x;
        cin >> g;
        for(int i = 0 ; i < n-1 ; ++i)
        {
            cin >> x;
            g = __gcd(g, x);
        }
        if(g == 1)
            cout << "YES\n";
        else
            cout << "NO\n";
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.36
easy
----------
PROBLEM STATEMENT:
We define a primitive root of prime number [expression] are different. 

For example: if [expression]) are as follows:


[expression]  
[expression]  
[expression]  
[expression]  
[expression]  
[expression]


Note that each of these evaluates to one of the six distinct integers in the range [expression].

Given prime [expression], find and print the following values as two space-separated integers on a new line:


The smallest primitive root of prime [expression].
The total number of primitive roots of prime [expression].  


Need Help? Check out a breakdown of this process at Math Stack Exchange.
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.37
easy
----------
PROBLEM STATEMENT:
A Smith number is a composite number, the sum of whose digits is the sum of the digits of its prime factors obtained as a result of prime factorization (excluding [expression].

Example: 
[expression] 
So, its prime factors are [expression]. 
The sum of its digits is [expression]. 
The sum of the digits of its factors is [expression].  

Similarly, [expression] is a Smith number. 
[expression].

Task: 
Write a program to check whether a given integer is a Smith number.
----------
TOP SOLUTION:
----------
#include <functional>
#include <algorithm>
#include <iostream>
#include <climits>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <numeric>
#include <cstring>
#include <cassert>
#include <cstdio>
#include <string>
#include <vector>
#include <bitset>
#include <queue>
#include <stack>
#include <cmath>
#include <ctime>
#include <list>
#include <set>
#include <map>

using namespace std;

typedef long long        LL;
typedef pair<int, int>   pii;
typedef pair<int, pii>   piii;
typedef vector<int>      vi;
typedef vector<pii>      vii;
typedef vector<piii>     viii;

#ifdef _WIN32
#define getchar_unlocked getchar
#endif
inline void inpint( int &n ) {
  n=0; register int ch = getchar_unlocked(); bool sign = 0;
  while(ch < 48 || ch > 57) { if(ch == '-') sign = 1; ch = getchar_unlocked(); }
  while(ch >= 48 && ch <= 57) { n = (n << 3) + (n << 1) + ch - 48, ch = getchar_unlocked(); }
  if(sign) n = -n;
}

inline int sqr(int x){return x * x;}
inline int cube(int x){return x * x * x;}
inline LL sqrLL(LL x){return x * x;}
inline LL cubeLL(LL x){return x * x * x;}

const LL LLINF      = 9223372036854775807LL;
const LL LLINF17    = 100000000000000000LL;
const int INF       = 2147483647;
const int INF9      = 1000000000;
const int MOD       = 1000000007;
const double eps    = 1e-7;
const double PI     = acos(-1.0);

#define FOR(a,b,c)   for (int (a)=(b); (a)<(c); (a)++)
#define FORN(a,b,c)  for (int (a)=(b); (a)<=(c); (a)++)
#define FORD(a,b,c)  for (int (a)=(b); (a)>=(c); (a)--)
#define REP(i,n)     FOR(i,0,n)
#define REPN(i,n)    FORN(i,1,n)
#define REPD(i,n)    FORD(i,n,1)

#define RESET(a,b)   memset(a,b,sizeof(a)) 
#define SYNC         ios_base::sync_with_stdio(0);
#define SIZE(a)      (int)(a.size())
#define MIN(a,b)     (a) = min((a),(b))
#define MAX(a,b)     (a) = max((a),(b))
#define ALL(a)       a.begin(),a.end()
#define RALL(a)      a.rbegin(),a.rend()
#define SIZE(a)      (int)(a.size())
#define LEN(a)       (int)(a.length())

#define fi           first
#define se           second
#define pb           push_back
#define mp           make_pair

int dr[] = {1,0,-1,0,-1,1,1,-1};
int dc[] = {0,-1,0,1,1,1,-1,-1};
const int N = 50000;
bool isprime[N];
LL x; vi primes;
inline int get(int x){
	int ret = 0;
	while (x){
		ret += (x % 10);
		x /= 10;
	}
	return ret;
}
int main(){
	RESET(isprime,1);
	for (int i = 2; i * i < N; i++) {
		if (isprime[i]) {
			for (int j = i + i; j < N; j+=i) {
				isprime[j] = 0;
			}
		}
	}
	primes.pb(2);
	for (int i = 3; i < N; i += 2)
		if (isprime[i]) primes.pb(i);

	cin >> x;
	LL tmp = x;

	LL sum = 0;
	for (int i = 0; i < SIZE(primes); i++) {
		while (x % primes[i] == 0) {
			x /= primes[i];
			sum += get(primes[i]);
		}
	}

	if (x > 1) sum += get(x);

	if (sum == get(tmp)) puts("1");
	else puts("0");

	return 0;
}
----------
====================
----------
MATHEMATICS.38
easy
----------
PROBLEM STATEMENT:
Your friend gives you an equation [expression].  

However, you know your friend's mischievous nature and suspect that there is no solution to such an equation. Thus, you first want to find out whether there is a solution to it.  

You may find this link helpful: http://mathworld.wolfram.com/EulersCriterion.html
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

long long modpow(long long a , long long b , long long m){
    if(a == 0)return 1LL ;
    long long y = a; long long x = 1LL ;
    
    while(b){
        if(b&1)
            x = (x*y)%m ;
        b /= 2;
        y = (y*y)%m ;
        
    }
    return x%m ;
}
int main() {
   int t;
    cin>>t;
    long long a, m ;
    while(t--){
        cin>>a>>m;
        if(modpow(a,(m-1)/2 , m) == 1)
            cout<<"YES"<<endl;
        else
            cout<<"NO"<<endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.39
medium
----------
PROBLEM STATEMENT:
Lia is fascinated by anything she considers to be a twin. She calls a pairs of positive integers, [expression], twins if:


They are both prime. A prime number is an integer greater than [expression] and itself.
Their absolute difference is exactly equal to [expression]).


Given an inclusive interval of integers from [expression] are considered to be the same pair.
----------
TOP SOLUTION:
----------


#include <cstdio>
#include <iostream>
#include <algorithm>
#include <utility>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <stack>
#include <list>
#include <queue>
#include <deque>
#include <cmath>
#include <numeric>
using namespace std;

namespace stanczyk {
	typedef int INT;
	typedef long long LL;
	typedef long double DOUBLE;

	const INT INF = 1000000001;
	constexpr const INT EPS_PRECISION = -9;
	const DOUBLE EPS = pow((DOUBLE)10.0, (DOUBLE)EPS_PRECISION);

	typedef vector<INT> VI;
}
using namespace stanczyk;



#define FOR(x, b, e) for (int x = b; x <= (e); ++x)
#define FORD(x, b, e) for (int x = b; x >= (e); --x)
#define REP(x, n) for (int x = 0; x<(n); ++x)
#ifdef _MSC_VER 
#define VAR(v, n) decltype(n) v = (n)
#else
#define VAR(v, n) __typeof(n) v = (n)
#endif
#define ALL(c) c.begin(), c.end()
#define SIZE(x) (int)x.size()
#define FOREACH(i, c) for (VAR(i, (c).begin()); i != (c).end(); ++i)
#define PB push_back
#define ST first
#define ND second
#define PF push_front
#define MP make_pair

namespace stanczyk {

	
	bool PWit(LL x, LL n) {
		if (x >= n) return 0;
		LL d = 1, y;
		LL t = 0, l = n - 1;
		while (!(l & 1)) {
			++t;
			l >>= 1;
		}
		for (; l > 0 || t--; l >>= 1) {
			if (l & 1) d = (d * x) % n;
			if (!l) {
				x = d;
				l = -1;
			}
			y = (x * x) % n;
			
			if (y == 1 && x != 1 && x != n - 1) return 1;
			x = y;
		}
		
		
		return x != 1;
	}

	
	
	bool IsPrime(int x) {
		return !(x < 2 || PWit(2, x) || PWit(7, x) || PWit(61, x));
	}
}

int main()
{
	int n, m;
	scanf("%d %d", &n, &m);

	int twins = 0;

	for (int i = n; i <= m - 2; ++i) {
		if (IsPrime(i) && IsPrime(i + 2)) {
			twins++;
		}
	}

	printf("%d", twins);
	
    return 0;
}


----------
====================
----------
MATHEMATICS.40
easy
----------
PROBLEM STATEMENT:
You're given three numbers: [expression] where 
[expression]  

As the number can be very large, output it modulo [expression].  

Consider the following link: http://en.wikipedia.org/wiki/Fibonacci_number#Matrix_form
----------
TOP SOLUTION:
----------
#include<cstdio>
#include<cmath>
#define MOD 1000000007
#define ll long long
#define rl(x) scanf("%lld",&x)
ll expo(ll a,ll b,ll n)
{
    ll A[2][2]={{a+b,b},{b,a}};
    ll M[2][2]={{1,1},{1,0}};
    ll u,v,x,y;
    while(n)
    {
        if(n&1)
        {
            u=(M[0][0]*A[0][0]+M[0][1]*A[1][0])%MOD;
            v=(M[0][0]*A[0][1]+M[0][1]*A[1][1])%MOD;
            x=(M[1][0]*A[0][0]+M[1][1]*A[1][0])%MOD;
            y=(M[1][0]*A[0][1]+M[1][1]*A[1][1])%MOD;
            A[0][0]=u,A[0][1]=v,A[1][0]=x,A[1][1]=y;
        }
            u=(M[0][0]*M[0][0]+M[0][1]*M[1][0])%MOD;
            v=(M[0][0]*M[0][1]+M[0][1]*M[1][1])%MOD;
            x=(M[1][0]*M[0][0]+M[1][1]*M[1][0])%MOD;
            y=(M[1][0]*M[0][1]+M[1][1]*M[1][1])%MOD;
            M[0][0]=u,M[0][1]=v,M[1][0]=x,M[1][1]=y;
            n>>=1;
    }
    //printf("%lld %lld %lld %lld \n",A[0][0],A[0][1],A[1][0],A[1][1]);
    return A[0][0];
}
int main()
{
    ll a,b,n,m,t,i=1;
    rl(t);
    while(i<=t)
    {
        rl(a),rl(b),rl(n);
       // printf("Case %lld: ",i);
       // m=(ll)pow(10,m);
        if(n==0)
        printf("%lld\n",a);
        else if(n==1)
        printf("%lld\n",b);
        else if(n==2)
        printf("%lld\n",b+a);
        else
        printf("%lld\n",expo(a,b,n-2));
        i++;
       
    }
}
----------
====================
----------
MATHEMATICS.41
hard
----------
PROBLEM STATEMENT:
Little Panda has a thing for powers and modulus and he likes challenges. His friend Lucy, however, is impractical and challenges Panda to find both positive and negative powers of a number modulo a particular number. We all know that [expression] (see Wikipedia).  

Since Lucy is impractical, she says that [expression].  

Now she wants Panda to compute [expression].   

She also thinks that this problem can be very difficult if the constraints aren't given properly. Little Panda is very confused and leaves the problem to the worthy programmers of the world. Help him in finding the solution.

Input Format 
The first line contains [expression], the number of test cases. 
Then [expression].  

Output Format 
Output the value of [expression].  

Constraints 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] are coprime to each other (see Wikipedia)  

Sample Input  

3  
1 2 3  
3 4 2  
4 -1 5


Sample Output  

1  
1  
4  


Explanation 
Case 1: [expression] 
Case 2: [expression] 
Case 3: [expression]  
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
#define ll long long int
#define MOD 1000000007
using namespace std;
ll modmulinverse(ll a,ll m)
{
    ll x = 0,y = 1,u = 1,v = 0;
    ll e = m,f = a;
    ll c,d,q,r;
    while(f != 1)
    {
        q = e/f;
        r = e%f;
        c = x-q*u;
        d = y-q*v;
        x = u;
        y = v;
        u = c;
        v = d;
        e = f;
        f = r;
    }
    u = (u+m)%m;
    return u;
}
ll mod(ll a,ll b,ll n){
    ll res=1;

      while (b)
{
    if (b % 2) { res = (res * a) % n; }

    a = (a * a) % n;
    b /= 2;
}

return res;
}

int main()
{
    ll t;
    cin>>t;
    while(t--){
            ll a,b,x,ans;
    cin>>a>>b>>x;
    a=a%x;
    if (b<0) a=modmulinverse(a,x);
    ans=mod(a,b,x);
    cout<<ans<<endl;

    }
    return 0;
}


----------
====================
----------
MATHEMATICS.42
hard
----------
PROBLEM STATEMENT:
Mehta is a very lazy boy. He always sleeps in Maths class. One day his teacher catches him sleeping and tells him that she would mark him absent for the whole semester. While she pretends to be strict, she is actually very kind-hearted. So she wants to give Mehta a chance to prove himself. She gives him a problem. If Mehta can answer it correctly, she will forgive him. Can you help Mehta find the answer to this problem?  

The problem: The teacher gives Mehta a number [expression] would be an even perfect square.  

Note: Even perfect square means the number should be even and a perfect square.  

Input Format 
The first line of input contains an integer [expression], the number of test cases. 
[expression], the number that the teacher provides.  

Output Format 
For each test case, print in a newline the output in [expression] are positive coprime integers. 
if [expression] is 0, you should simply output 0.  

Constraints 
[expression] 
[expression]  

Sample Input

4
2
8
36
900


Sample Output

0
1/3
1/8
3/26


Explaination 
For the first case [expression]. 
For the second case [expression]. 
For the third case [expression]. 
For the fourth case [expression] are even perfect squares.   
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

long num[1003];

long divisors(long n)
{
    long gog = 0;
    for(long i = 1 ; i <= sqrt(n) ; i++){
        if(i == sqrt(n) && sqrt(n) == n/sqrt(n)){
            gog++;
        }
        else if(n%i == 0){
            gog++;
            gog++;
        }
    }
    return gog;
}

long gcd(long a , long b){
    if(b == 0){
        return a;
    }
    else{
        return gcd(b,a%b);
    }
}

int main() {
    long t;
    cin >> t;
    for(long i = 2 ; i <= 1000 ; i=i+2){
        num[i/2-1] = i*i;
    }
    while(t--){
        long long n;
        cin >> n;
        long answer = divisors(n);
        long counter = 0;
        for(long i = 0 ; ; i++){
            if(num[i] >= n){
                break;
            }
            if(n%num[i] == 0){
                counter++;
            }
        }
        if(counter == 0){
            cout << "0\n";
        }
        else{
            long common = gcd(counter,answer-1);
            cout << counter/common << "/" << (answer-1)/common << "\n";
        }
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.43
hard
----------
PROBLEM STATEMENT:
Given two long integers, [expression], choose the one with the smallest denominator.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#define each(it,o) for(auto it= (o).begin(); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
#define inrep int t;cin>>t; while(t--)
#define sz(x) int(x.size())
using namespace std;

typedef vector<int> vi;
typedef pair<int,int> pii;
typedef vector<pii > vpii;
typedef long long ll;
typedef vector<ll> vll;
typedef pair<ll,ll> pll;
typedef vector<pll > vpll;
typedef vector<string> vs;
typedef long double ld;

template<typename T> ostream& operator<< ( ostream &o,vector<T> v ) {
    if ( v.size() >0 )
        o<<v[0];
    for ( unsigned   i=1; i<v.size(); i++ )
        o<<" "<<v[i];
    return o<<endl;
}
template<typename U,typename V> ostream& operator<< ( ostream &o,pair<U,V> p ) {
    return o<<"("<<p.first<<", "<<p.second<<") ";
}
template<typename T> istream& operator>> ( istream &in,vector<T> &v ) {

    for ( unsigned   i=0; i<v.size(); i++ )
        in>>v[i];
    return in;
}
typedef __int128 li;
struct frac {
    ll n, d;
    frac ( ll nn, ll dd ) :n ( nn ), d ( dd ) {}
    bool operator< ( const frac &o ) const {
        return ( li ) n*o.d< ( li ) o.n*d;
    }

    double quot() const {
        return ( double ) n/d;
    }
    frac normalize() const{
     ll g=__gcd(n,d);
     return frac(n/g, d/g);
    }
};
frac med ( const frac &f1, const frac&f2 ) {
    return frac ( f1.n+f2.n, f1.d+f2.d );
}
ostream &operator<< ( ostream &os, const frac &f ) {
    return os<<f.n<<"/"<<f.d;
}
const frac PI ( 2646693125139304345LL, 842468587426513207LL );
const frac PI2 ( PI.n-3*PI.d,PI.d );

frac findBetter ( const frac &l, const frac &u ) {
    frac d1 ( ( li ) PI2.n*l.d- ( li ) PI2.d*l.n,l.d );
    frac d2 ( ( li ) PI2.d*u.n- ( li ) PI2.n*u.d,u.d );
    if ( d2<d1 ) return u;
    else return l;
}
frac solve1 ( ll mi, ll ma ) {
    frac bb ( 1,1 ), bs ( 0,1 );
    for ( ll x=mi; x<ma; x++ ) {
        frac bs2 ( ( li ) PI2.n*x/PI2.d, x );
        frac bb2 ( bs2.n+1, x );
        assert ( bs2<PI2 &&PI2<bb2 );
        if ( bb2<bb ) bb=bb2;
        if ( bs<bs2 ) bs=bs2;
    }
    frac sol=findBetter ( bs,bb );
    sol.n+=3*sol.d;
    return sol;
}
pair<frac,frac> farey ( ll bnd ) {
    frac l ( 0,1 ),u ( 1,1 );
    while ( 1 ) {
        frac s=med ( l,u );
        
        if ( s<PI2 ) l=s;
        else u=s;
    if ( s.d>=bnd ) return mp ( l,u );
        
    }
    assert ( 0 );
    return mp ( frac ( 0,1 ),frac ( 0,1 ) );

}

frac up ( const frac &f1, const frac&f2,ll n ) {
    ll k= ( n+f2.d ) /f1.d;
    return frac ( k*f1.n-f2.n, k*f1.d-f2.d );
}
frac down ( const frac &f1, const frac &f2 , ll n ) {
    return up ( f1,f2,n );
}
frac solve2 ( ll mi, ll ma ) {

    frac l ( 0,1 ), u ( 0,1 );
    tie ( l,u ) =farey ( ma );
//      cout<<l<<" "<<u<<" "<<l.quot()-PI2.quot()<<" "<<u.quot()-PI2.quot()<<endl;
    ll n=max ( l.d, u.d );
    frac u2=l;
    frac l2=u;
    while ( ( ( mi-1 ) /u.d+1 ) *u.d>=ma ) {
        frac s=up ( u,u2,n ).normalize();
        u2=u;
        u=s;
//         cout<<"up "<<u<<endl;
    }
    while ( ( ( mi-1 ) /l.d+1 ) *l.d>=ma ) {
        frac s=down ( l,l2,n ).normalize();
        l2=l;
        l=s;
//           cout<<"down "<<l<<" "<<l.quot()-PI2.quot()<<endl;
         assert(l.n>=0);
    }

// cout<<"to "<<l<<" "<<u<<" "<<l.quot()-PI2.quot()<<" "<<u.quot()-PI2.quot()<<endl;
    frac sol=findBetter ( l,u );
    ll k= ( mi-1 ) /sol.d+1;
    sol=frac ( sol.n*k, sol.d*k );
    sol.n+=3*sol.d;
    return sol;
}
int test() {
    rep ( xx,10000 ) {
        int mi=rand() %1000000+1;
        int ma=mi+rand() %10000+1;

        cout<<mi<<" "<<ma<<endl;

        frac s1=solve1 ( mi,ma );
        cout<<"s1: "<<s1<<" "<<s1.normalize()<<" "<<s1.quot()-M_PI<<endl;
        frac s2=solve2 ( mi,ma );
        cout<<"s2: "<<s2<<" "<<s2.normalize()<<" "<<s2.quot()-M_PI<<endl;
assert(!(s1<s2) &&!(s2<s1));
    }
    return 0;
}
int main() {
//     return test();
    ios_base::sync_with_stdio ( false );
    ll mi,  ma;
    cin>>mi>>ma;
    ma++;

//     if(ma-mi<1.e7)
    
    frac sol=solve2 ( mi,ma );
    cout<<sol<<endl;



}
// kate: indent-mode cstyle; indent-width 4; replace-tabs on; 

----------
====================
----------
MATHEMATICS.44
hard
----------
PROBLEM STATEMENT:
Harvey Specter has agreed to take Mike Ross to a meeting filled with brilliant scientists at NSA Headquarters. But, as always, it's not going to be easy for Mike. He has to solve a puzzle given by Harvey. 

Harvey gives two numbers N and K and defines a set A.

A = { x : x is a natural number ≤ N } 
(i.e), A = {1,2,3,4,5,6,...., N}   

Mike has to find the total number of pairs of elements A[i] and A[j] belonging to the given set, such that, i 

Input Format 
An integer T followed by T lines, each containing a pair of space separated integers N and K. 

Output Format 
T integers on separate lines. Each integer denotes the answer corresponding to that test case.

Constraints 
1
K9 
1

Sample Input  

2
10 4
7 3


Sample Output

10
7


Explanation  

For the 1st test case, there are 10 pairs whose sum is divisible by 4. 
(1,3), (1,7), (2,6), (2,10), (3,5), (3,9), (4,8), (5,7), (6,10) and (7,9)

For the 2nd test case, there are 7 pairs whose sum is divisible by 3. 
(1,2), (1,5), (2,4), (2,7), (3,6), (4,5) and (5,7)
----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <memory.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash

#define  INF 100000000
#define eps 1e-8
//#define M_PI 3.141592653589793
//#define mx 1000000000000ll
#define bs 1000000007

//#define free asdfasdfsdadsg
//#define szz 400
//#define pb push_back
#define MAXN 10000
#define free afdshjioey
//#define SIZE 60
//#define bsize 250
#define clone agsdahfaassdg

using namespace std;

long long n,k,ans,p,d[11000],tests;

int main(){
//freopen("line3.in","r",stdin);
//freopen("line3.out","w",stdout);
//freopen("C:/input.txt","r",stdin);
//freopen("C:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);

cin>>tests;
for (;tests;--tests)
{
    cin>>n>>k;
    for (int i=0;i<=k;i++)
    d[i]=0;
    
    for (int i=0;i<k;i++)
    {
        d[i]=n/k;if (n%k>=i&&i>0)++d[i];
    }
    /*
    for (int i=0;i<k;i++)
    cout<<d[i]<<" ";
    cout<<endl;
    */
    
    ans=0;
    for (int i=0;i<k;i++)
    {
        p=k-i;
        if (p==k)p=0;
        if (p>i)ans+=d[i]*d[p];
        else if (p==i)ans+=d[i]*(d[p]-1)/2;
//cout<<ans<<endl;
    }
//    cout<<ans/2<<endl;
cout<<ans<<endl;
}

cin.get();cin.get();
return 0;}

----------
====================
----------
MATHEMATICS.45
hard
----------
PROBLEM STATEMENT:
Bob is a dance teacher and he started dance classes recently. He observes a strange attendance pattern among his students. Initially, there are no students. On day i, a new student starts attending the class. The student stops attending the class, if and only if he has attended the class for i consecutive days. 
Also, the student resumes attending the class, if and only if he has not attended the class for i consecutive days. 

We denote the student who starts coming on day i as student i. 
To mark attendance, o denotes present and x denotes absent.  

For example, the schedule for student 1 from day 1 is as follows: 
oxoxoxoxoxoxoxoxoxox...  

The schedule for the student 3 from day 1 is as follows:  

xxoooxxxoooxxxoooxxx... 
(Student 3 starts attending the class from day 3, and stops attending from day 6, and then starts attending from day 9, and so on. )  

The schedule for the student 5 from day 1 is as follows.
xxxxoooooxxxxxoooooxxxxx...

Bob wants his students to dance in pairs. However, if the number of students coming on day i is odd, then there will be someone who can't find a partner. So Bob wants to know if the number of students coming on day i is even or odd. We denote the number of students coming on day i as N(i).  Please find out whether N(i) is even or odd.

Input format  

The first line contains an integer, T, which denotes the number of test cases. 
For each test case, there is an integer i

Output Format 
For each test case, if N(i) is even, then print even. 
If N(i) is odd, then print one line odd.

Constraints 
1 ≤ T ≤ 100 
1 ≤ i ≤ 1018  

Sample Input

4
1
2
3
4


Sample Output  

odd
odd
odd
even


Explanation 
The number of students coming on day 1 is 1: only student #1 attends the class. So N(1)=1 and it is odd. 
The number of students coming on day 2 is 1:  student #2, so n(2)=1 and it is odd. 
The number of students coming on day 3 is 3: student #1, student #2, and student #3. So N(3)=3 and it is odd. 
The number of students coming on day 4 is 2: student #3 and student #4. So N(4)=2 and it is even. 
----------
TOP SOLUTION:
----------
#include <iostream>

/** HEADER FOR CODING CONTESTS **/
#include <vector>
#include <cstdio>
#include <map>
#include <set>
#include <algorithm>
#include <tuple>
#include <cassert>
#include <cstring>
#include <string>
#include <queue>

typedef long long LL;
typedef unsigned long long ULL;

template <typename T> using V = std::vector<T>;
#define RI(x, ...) read_these(x, ##__VA_ARGS__)
#define RV(v) read_these(v)
#define RNP(n, p) read_these(n,p)
inline void read_this(int&v){scanf("%d",&v);}
inline void read_this(unsigned int&v){scanf("%u",&v);}
inline void read_this(long long&v){scanf("%lld",&v);}
inline void read_this(unsigned long long&v){scanf("%llu",&v);}
inline void read_these(){}
template <typename T, typename...Ts>
inline void read_these(T&v,Ts&... vs){read_this(v);read_these(vs...);}
template <typename T>
inline void read_these(std::vector<T>&vs){for(auto&v:vs)read_this(v);}
template<typename T>
inline void read_these(size_t n,T*vs){for(size_t i=0;i<n;++i)read_this(vs[i]);}
/** END OF HEADER **/

using namespace std;

LL msqrt(LL v) {
  LL l = 0;
  LL r = LL(1e9) + 1;

  while (r - l > 1) {
    auto m = (l + r) / 2;
    if (m * m > v) {
      r = m;
    } else {
      l = m;
    }
  }
  return l;
}

int main(int argc, char* argv[]) {
  int t;RI(t);
  while (t --) {
    LL n; RI(n);

    cout << ((msqrt(n) & 1) ? "odd" : "even") << endl;

  }
  return 0;
}


----------
====================
----------
MATHEMATICS.46
medium
----------
PROBLEM STATEMENT:
You are given a sequence of [expression] except for exactly one element.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define endl '\n'

using namespace std;
const int MAXN = (1 << 20);

int n;
int64_t a[MAXN];

void read()
{
	cin >> n;
	for(int i = 0; i < n; i++)
		cin >> a[i];
}

int64_t pref[MAXN], suff[MAXN];

void solve()
{
	if(n == 1)
	{
		cout << a[0] + 1 << endl;
		return;
	}

	pref[0] = a[0]; for(int i = 1; i < n; i++) pref[i] = __gcd(pref[i - 1], a[i]);
	suff[n - 1] = a[n - 1]; for(int i = n - 2; i >= 0; i--) suff[i] = __gcd(suff[i + 1], a[i]);

	if(a[n - 1] % pref[n - 2] != 0) { cout << pref[n - 2] << endl; return; }
	if(a[0] % suff[1] != 0) { cout << suff[1] << endl; return; }

    for(int i = 1; i < n - 1; i++)
	{
		int64_t g = __gcd(pref[i - 1], suff[i + 1]);
        if(a[i] % g != 0)
		{
			cout << g << endl;
			return;
		}
	}
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	read();
	solve();
	return 0;
}

----------
====================
----------
MATHEMATICS.47
medium
----------
PROBLEM STATEMENT:
The city of Hackerland has formed a new football club and wants to participate in the upcoming Football League of their country. The coach is worried that they will not be able to qualify because they don't have a famous footballer in their team. The assistant coach suggests that the team should buy Cristiano Ronaldo as he can single-handedly get their team qualified.  

On day 1, today, the club has to pay 'A' HackerCoins in order to buy Ronaldo. After each passing day, the price of buying Ronaldo becomes A times the price on the previous day. Any normal person would buy him on the 1st day itself as the price will be the lowest but since the coach always failed in high school Mathematics, he wants 'B' days to think before making him an offer.  

As the coach doesn't know how to calculate the price of Ronaldo on the Bth day, he has asked for your help.  

Your task is to tell the price of Ronaldo on the Bth day. Since, the price can be a very large number, please tell him the price modulo 109 + 7.

Input Format 
The first line contains an integer T, the number of testcases. It's followed by T lines. 
Each testcase will contain two integers A & B separated by a space.  

Output Format 
Output T lines, each corresponding to the answer of the testcase.  

Constraints 
1 
1 100000 
A % (109 + 7) != 0

Note 
Both integers will have a maximum of 100000 digits.  

Sample Input #00:  

5
3 2
4 5
7 4
34534985349875439875439875349875 93475349759384754395743975349573495
34543987529435983745230948023948 3498573497543987543985743989120393097595572309482304


Sample Output #00:  

9
1024
2401
735851262
985546465


Explanation #00:  

As value of 32 = 9, So output for first case will be 9. 
Similarly 45 modulo (109 + 7) = 1024 
Similarly 74 modulo (109 + 7) = 2401 
Similarly we can do for others.  
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

#define ull unsigned long long int
#define ll long long int
#define uint unsigned int

#define read(n) scanf("%d",&n)
#define readll(n) scanf("%lld",&n)
#define read2(n,m) scanf("%d%d",&n,&m)
#define read3(n,m,l) scanf("%d%d%d",&n,&m,&l)

#define init(mem,v) memset(mem,v,sizeof(mem))
#define DB(x)              cout<<__LINE__<<" :: "<<#x<< ": "<<x<<endl;
#define DB2(x, y)          cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<endl;
#define DB3(x, y, z)       cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<" | "<<#z<<": "<<z<<endl;
#define DB4(a, b, c, d)    cout<<__LINE__<<" :: "<<#a<< ": "<<a<<" | "<<#b<< ": "<<b<<" | "<<#c<<": "<<c<<" | "<<#d<<": "<<d<<endl;
#define mod 1000000007

ll ppow(ll b,ll p){
    if(p==0) return 1;
    if(b==1) return 1;
    if(p%2==0){
        ll res=ppow(b,p/2);
        return (res*res)%mod;
    }
    return (b*ppow(b,p-1))%mod;
}

char A[100001],B[100001];
void solve(){
    scanf("%s %s",A,B);
    ll a=0;
    for(int i=0;A[i]!='\0';i++){
        a=(10*a+A[i]-'0')%mod;
    }
    ll res=1;
    for(int i=0;B[i]!='\0';i++){
        res=(ppow(res,10)*ppow(a,B[i]-'0'))%mod;
    }
    printf("%lld\n",res);
}

int main(){
    int t;
    read(t);
    while(t--) solve();
}

----------
====================
----------
MATHEMATICS.48
medium
----------
PROBLEM STATEMENT:
Manager of HackerX company is having big trouble. Workers are very unhappy with the way salary is given to them. They want every worker to have the same salary, otherwise they will go on a strike.

Their current salaries are denoted by a sequence of N integers: A1, A2, A3 ... AN .
Manager has decided to take action and make their salaries equal. He uses the following process until all salaries are equal. This method is called normalization:

a) Select any two different values from A.  

b) Replace larger value with the difference of the two. Difference of two positive integers B and C is defined as |B-C|.    

He knows that the final value will always be unique. 
Now, Q queries are given. In each query you are given an integer K. K is the amount to be added to everyone's salary as bonus, before the normalization.

Input Format 
First line contains, N and Q, the number of employees and the number of queries. Next line contains N space seperated positive integers denoting the array A. Next Q lines contain queries. Each query consists of one integer per line denoting K.

Output Format 
For each query, print the normalized salary (which is same for everyone in the end) in one line.

Constraints 
1 ≤ N ≤ 105 
1 ≤ Q ≤ 105 
1 ≤ A[i] ≤ 1014 
0 ≤ K ≤ 109  

Sample Input  

4 2
9 12 3 6
0
3


Sample Output  

3
3


Explanation 
for sample input: 
If 0 is added to every element of array A, it will remain same. 
One way to normalise A is this: 
1. Picking 12 and 3 gives:  9 9 3 6 
2. Picking 3 and 6 gives:  9 9 3 3 
3. Picking 9 and 3 gives:  6 9 3 3 
4. Picking 9 and 3 gives:  6 6 3 3 
5. Picking 6 and 3 gives:  3 6 3 3 
6. Picking 6 and 3 gives:  3 3 3 3  
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long ll;

ll gcd(ll a, ll b) {
    while (a > 0 && b > 0) {
        if (a > 0) b %= a;
        if (b > 0) a %= b;
    }
    return a + b;
}

int main() {
    int N, Q;
    scanf("%d%d", &N, &Q);
    ll a0, other = 0, tmp;
    for (int i = 0; i < N; ++i) {
        scanf("%lld", &tmp);
        if (i == 0) a0 = tmp;
        else { tmp -= a0; if (tmp < 0) tmp = -tmp; other = gcd(other, tmp); }
    }
    for (int i = 0; i < Q; ++i) {
        scanf("%lld", &tmp);
        printf("%lld\n", gcd(a0 + tmp, other));
    }
}
----------
====================
----------
MATHEMATICS.49
hard
----------
PROBLEM STATEMENT:
After dating for a long time, Akhil is finally going to propose to his girlfriend. She is very strong in mathematics, and will accept his proposal, if and only if Akhil solves a problem given by her. The problem is given below. Help Akhil solve it.

Akhil is given two numbers N and M, and he has to tell her the remainder when [expression].  

Input Format 
The first line contains an integer [expression] i.e. the number of test cases. 
Each of the next [expression].  

Output Format 
[expression] lines each containing ouptut for the corresponding test case. 

Constraints 
[expression] 
[expression] 
[expression]  

Sample Input 00  

3
3 3
4 7
5 18


Sample Output 00  

0
5   
5


Explanation 

111 % 3  = 0 
  1111 % 7 = 5 
  11111%18 = 5  
----------
TOP SOLUTION:
----------
#include<iostream>
#include<cmath>
#include<math.h>

using namespace std;

long long num,t,n,m,p,rem,count,counter,num1,first;

int main(){
    cin >> t;
    while(t--){
        cin >> n >> m;
        num = 1%m;
        num1 = 1%m;
        p = 10%m;
        rem = 1%m;
        count = 0;
        first = 0;
        counter = 1;
        while(count+counter <= n){
            num = ((((num%m)*(p%m))%m + num1%m)%m);
            num1 = ((((num1%m)*(p%m))%m + num1%m)%m);
            p = (p*p)%m;
            rem = num;
            counter = counter*2;
            if(count+2*counter >= n)
            {
                break;
            }
        }
        count = count + counter;
        if(count == n){
            cout << rem%m << "\n";
        }
        else{
            while(1){
                num1 = 1%m;
                p = 10%m;
                counter = 0;
                while(count+counter <= n){
                    num = ((((num%m)*(p%m))%m + num1%m)%m);
                    num1 = ((((num1%m)*(p%m))%m + num1%m)%m);
                    p = (p*p)%m;
                    rem = num;
                    counter = counter*2;
                    if(counter == 0)
                        counter = 1;
                    count = count + counter;
                    if(count+2*counter >= n)
                    {
                        break;
                    }
                }
                if(count == n){
                    cout << rem%m << "\n";
                    break;
                }
                first++;
            }
        }
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.50
hard
----------
PROBLEM STATEMENT:
Little Ashish is doing internship at multiple places. Instead of giving parties to his friends he decided to donate candies to children. He likes solving puzzles and playing games. Hence he plays a small game. Suppose there are [expression] children. The rules of the game are:  


The [expression]).  
The [expression].  


One of his jealous friends, Pipi, asks him "Given [expression] (the number of candies) how many children will you be able to serve?". Little Ashish fears calculations and cannot solve this problem so he leaves this problem to the worthy programmers of the world. Help little Ashish in finding the solution.  

Input Format 
The first line contains [expression] i.e. number of test cases. 
[expression].  

Output Format 
For each testcase, print the output that little Ashish wants in one line.   

Constraints 
[expression] 
[expression]  

Note: If the [expression] number of candies then it's not counted as a successful donation  

Sample Input  

3
1
5
13


Sample Output  

1  
2  
2  


Explanation  


For [expression] candy) and no other child.  
For [expression] candies) children can get the candies.  
For [expression] children can get 1 and 4 candies respectively.  

----------
TOP SOLUTION:
----------
#include<iostream>
using namespace std;

long long ans(long long x)
{
	x*=6;
	long long low = 1,high = 1000000,mid,f1,f2;
	while(low<high)
	{
		mid = (low+high)/2;
		f1 = mid*(mid+1)*(2*mid+1);
		f2 = (mid+1)*(mid+2)*(2*mid+3);
		if(f1 == x)
			return mid;
		if(f2 == x)
			return mid+1;
		if(f1<x&&f2<x)
			low = mid+1;
		if(f1>x && f2>x)
			high = mid-1;
		else if(f1<x && f2>x)
			return mid;
	}
	return low;
}

int main()
{
	long long t,x;
	cin>>t;
	while(t--)
	{
		cin>>x;
		cout<<ans(x)<<'\n';
	}
	return 0;
}
----------
====================
----------
MATHEMATICS.51
hard
----------
PROBLEM STATEMENT:
Manasa was sulking her way through a boring class when suddenly her teacher singled her out and asked her a question. He gave her a number n and Manasa has to come up with the smallest number m which contains atleast n number of zeros at the end of m!. Help Manasa come out of the sticky situation. 

Input Format 
The first line contains an integer T i.e. the number of Test cases. 
Next T lines will contain an integer n.  

Output Format 
Print smallest such number m. 

Constraints 
1 ≤ T ≤ 100 
1 ≤ n ≤ 1016  

Sample Input  

3
1
2
3


Sample Output  

5
10
15


Explanation


As 4! = 24 and 5! = 120, so minimum value of m will be 5.
As 9! = 362880 and 10! = 3628800, so minimum value of m will be 10.
As 14! = 87178291200 and 15! = 1307674368000, so minimum value of m will be 15.

----------
TOP SOLUTION:
----------
#include <iostream>
using namespace std;
const long long MAXV = 1000000000;

long long f( long long x )
{
    long long res = 0;
    long long exp = 5;
    long long delta = 0;
    do
    {
        delta = (x / exp);
        exp *= 5;
        res += delta;
    }
    while( delta != 0 );
    return res;

}

int main()
{

    int T;
    cin >> T;

    for ( int t = 1 ; t <= T ; t++ )
    {
        long long N ;
        cin >> N;
        long long l = 1 ,  r = MAXV * MAXV;
        while ( r - l > 1 )
        {
            long long mid = ( l + r ) / 2;
            if ( f( mid ) < N ) l = mid ;
            else r = mid ;
        }
        cout << r << endl;
    }

    return 0;
}

----------
====================
----------
MATHEMATICS.52
medium
----------
PROBLEM STATEMENT:
You are given an integer [expression] denotes xor operation) are there? 
Print your answer modulo [expression]. 
Note that the  xorsum of an empty set is zero!  

Input Format 
The first line contains one integer [expression], the number of testcases. 
The next [expression] each.

Output Format 
Output [expression].

Constraints 
[expression] 
[expression]

Sample Input  

2
1
2


Sample Output  

2
4


Explanation 
For [expression]. 
For [expression].
----------
TOP SOLUTION:
----------
#include <iostream>

using namespace std;

typedef long long ll;

ll mod=1000000007ll;

ll pow(ll a, ll p, ll m){
    if (p==2ll) return (a*a)%m;
    if (p==0ll) return 1ll;
    if (p%2ll==0ll) return pow(pow(a, p/2ll, m), 2ll, m);
    return (a*pow(a, p-1ll, m))%m;
}

int main(){
    int t;
    cin>>t;
    for (int tc=0;tc<t;tc++){
        ll n;
        cin>>n;
        cout<<(pow(2ll, pow(2ll, n, mod-1ll), mod)*pow(pow(2, n, mod), mod-2ll, mod))%mod<<endl;
    }
}

----------
====================
----------
MATHEMATICS.53
medium
----------
PROBLEM STATEMENT:
You recently received a bag of chocolate sticks for Halloween. To prevent you from compulsively eating all the chocolate sticks in one go, your dietician devises the following fun game.

In each move, you choose one of the sticks from your bag. Then, you either eat it, or  break it into some number of equally-sized parts and save the pieces for later. The lengths of all sticks must always be integers, so breaking a stick into [expression].

Note that this means that a stick of length [expression] cannot be broken anymore, and can only be eaten.

For example, a chocolate stick of length [expression] will be dealt with as shown below. 



Given the chocolate sticks you received, determine the length of the longest sequence of moves you can perform.

Complete the function longestSequence which takes an integer array [expression], denoting the lengths of the chocolate sticks, as input. Return the maximum number of moves you can perform to consume the chocolate sticks according the game. 
----------
TOP SOLUTION:
----------
/**
 *    author:  tourist
 *    created: 14.12.2017 19:11:30       
**/
#include <bits/stdc++.h>

using namespace std;

int main() {
  int tt;
  cin >> tt;
  long long ans = 0;
  while (tt--) {
    long long x;
    cin >> x;
    ans += (x > 1 ? x : 0);
    while (x > 1) {
      bool found = false;
      for (long long i = 2; i * i <= x; i++) {
        if (x % i == 0) {
          found = true;
          x /= i;
          ans += x;
          break;
        }
      }
      if (!found) {
        break;
      }
    }
    ans += 1;
  }
  cout << ans << endl;
  return 0;
}

----------
====================
----------
MATHEMATICS.54
easy
----------
PROBLEM STATEMENT:
Waiter: Good day, sir! What would you like to order? 
Lucas: One Cheese & Random Toppings (CRT) pizza for me, please. 
Waiter: Very good, sir. There are [expression] toppings. 
Lucas: Hmm, let's see...  

...Then Lucas started writing down all the ways to choose R toppings from N toppings in a piece of napkin. Soon he realized that it's impossible to write them all, because there are a lot. So he asked himself: How many ways are there to choose exactly [expression] toppings?

Since Lucas doesn't have all the time in the world, he only wished to calculate the answer modulo [expression], where M is a squarefree number whose prime factors are each less than 50.

Fortunately, Lucas has a Wi-Fi-enabled laptop with him, so he checked the internet and discovered the following useful links: 
Lucas' theorem 
Chinese remainder theorem (CRT)  

Input Format 
The first line of input contains [expression], the number of test cases. The following lines describe the test cases.

Each test case consists of one line containing three space-separated integers: [expression].  

Constraints 
[expression] 
[expression] 
[expression] 
[expression]

Output Format 
For each test case, output one line containing a single integer: the number of ways to choose [expression].  

Sample Input  

6
5 2 1001
5 2 6
10 5 15
20 6 210
13 11 21
10 9 5    


Sample Output  

10
4
12
120
15
0


Explanation  

Case 1 and 2: Lucas wants to choose 2 toppings from 5 toppings. There are ten ways, namely (assuming the toppings are A, B, C, D and E):  

AB, AC, AD, AE, BC, BD, BE, CD, CE, DE  

Thus, 
Case 1: [expression] 
Case 2: [expression]  

Case 6: We can choose 9 toppings from 10 by removing only one from our choice. Thus, we have ten ways and [expression]
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }


struct GModInt {
	static int Mod;
	int x;
	GModInt(): x(0) { }
	GModInt(signed sig) { if((x = sig % Mod + Mod) >= Mod) x -= Mod; }
	GModInt(signed long long sig) { if((x = sig % Mod + Mod) >= Mod) x -= Mod; }
	int get() const { return x; }
	
	GModInt &operator+=(GModInt that) { if((x += that.x) >= Mod) x -= Mod; return *this; }
	GModInt &operator-=(GModInt that) { if((x += Mod - that.x) >= Mod) x -= Mod; return *this; }
	GModInt &operator*=(GModInt that) { x = (unsigned long long)x * that.x % Mod; return *this; }
	GModInt &operator/=(GModInt that) { return *this *= that.inverse(); }
	
	GModInt operator+(GModInt that) const { return GModInt(*this) += that; }
	GModInt operator-(GModInt that) const { return GModInt(*this) -= that; }
	GModInt operator*(GModInt that) const { return GModInt(*this) *= that; }
	GModInt operator/(GModInt that) const { return GModInt(*this) /= that; }
	
	//Mod
	GModInt inverse() const {
		signed a = x, b = Mod, u = 1, v = 0;
		while(b) {
			signed t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		if(u < 0) u += Mod;
		GModInt res; res.x = (unsigned)u;
		return res;
	}
	
	bool operator==(GModInt that) const { return x == that.x; }
	bool operator!=(GModInt that) const { return x != that.x; }
	GModInt operator-() const { GModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }
};
int GModInt::Mod = 0;
typedef GModInt mint;


void exGCD(ll a, ll b, ll &out_a, ll &out_p, ll &out_r) {
	if(a == 0 || b == 0) return;
	int as = a > 0 ? 1 : a < 0 ? -1 : 0;
	int bs = b > 0 ? 1 : b < 0 ? -1 : 0;
	a = abs(a); b = abs(b);
	ll p = 1, q = 0, r = 0, s = 1;
	while(b > 0) {
		ll c = a / b;
		ll d;
		d = a; a = b; b = d % b;
		d = p; p = q; q = d - c * q;
		d = r; r = s; s = d - c * s;
	}
	out_a = a, out_p = p * as, out_r = r * bs;
}

ll crt(const vector<ll> &divs, const vector<ll> &mods) {
	if(divs.empty()) return 0;
	ll div = divs[0], mod = mods[0];
	reu(i, 1, divs.size()) {
		ll apr[3];
		exGCD(div, divs[i], apr[0], apr[1], apr[2]);
		if((mods[i] - mod) % apr[0] != 0) return -1;
		ll ndiv = div * divs[i] / apr[0];
		ll nmod = (apr[1] * (mods[i] - mod) / apr[0] * div + mod) % ndiv;
		if(nmod < 0) nmod += ndiv;
		div = ndiv;
		mod = nmod;
	}
	return mod;
}


mint Cprime_small(int n, int r) {
	if(n < r) return 0;
	if(r >= n / 2) r = n - r;
	mint res = 1;
	rep(i, r) res *= n - i;
	mint inv = 1;
	rep(i, r) inv *= i + 1;
	res /= inv;
	return res;
}
mint Cprime(ll nn, ll rr) {
	const int MOD = mint::Mod;
	if(nn == 0) return rr == 0 ? 1 : 0;
	else return Cprime(nn / MOD, rr / MOD) * Cprime_small(nn % MOD, rr % MOD);
}

int main() {
	int T;
	scanf("%d", &T);
	rep(ii, T) {
		int N, R, M;
		scanf("%d%d%d", &N, &R, &M);
		vector<ll> mods, divs;
		for(int p = 2; p <= 50; ++ p) if(M % p == 0) {
			divs.push_back(p);
			mint::Mod = p;
			mods.push_back(Cprime(N, R).get());
			M /= p;
		}
		ll ans = crt(divs, mods);
		printf("%lld\n", ans);
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.55
medium
----------
PROBLEM STATEMENT:
We call a sequence of [expression].

Given an awesome sequence, [expression], satisfying the following conditions:


[expression]
[expression] is also awesome.

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define ll long long
#define mod 1000000007
#define upperlimit 1000100
#define INF 1000000000
#define INFL 1000000000000000000
#define eps 1e-8
#define endl '\n'
#define sd(n) scanf("%d",&n)
#define slld(n) scanf("%lld",&n)
#define pd(n) printf("%d",n)
#define plld(n) printf("%lld",n)
#define pds(n) printf("%d ",n)
#define pllds(n) printf("%lld ",n)
#define pdn(n) printf("%d\n",n)
#define plldn(n) printf("%lld\n",n)
#define REP(i,a,b) for(i=a;i<=b;i++)
#define mp make_pair
#define pb push_back
#define pcc pair<char,char>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++)
#define F first
#define S second

using namespace std;

ll gcd(ll n1,ll n2){
	if(n1%n2==0)return n2;
	return gcd(n2,n1%n2);
}
ll powmod(ll base,ll exponent)
{
	ll ans=1;
	while(exponent){
		if(exponent&1)ans=(ans*base)%mod;
		base=(base*base)%mod;
		exponent/=2;
	}
	return ans;
}
int arr[upperlimit+1];
int f(int n){
	int i;
	for(i=2;i*i<=n;i++)if(n%i==0)return i;
	return n;
}
int main()
{
	int n,i,j,k;
	sd(n);
	sd(k);
	for(i=1;i<=n;i++)sd(arr[i]);
	int g=arr[1];
	for(i=2;i<=n;i++)g=gcd(g,arr[i]);
	int q=f(g);
	pd(k-(k%q));
	return 0;
}

----------
====================
----------
MATHEMATICS.56
hard
----------
PROBLEM STATEMENT:
Given a positive integer, [expression] are positive integers) has at least one solution.
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
#define MAXN 300009
#define INF 1000000007
#define mp(x,y) make_pair(x,y)
#define all(v) v.begin(),v.end()
#define pb(x) push_back(x)
#define wr cout<<"----------------"<<endl;
#define ppb() pop_back()
#define tr(ii,c) for(typeof((c).begin()) ii=(c).begin();ii!=(c).end();ii++)
#define ff first
#define ss second

using namespace std;

typedef long long ll;
typedef pair<int,int> PII;
template<class T>bool umin(T& a,T b){if(a>b){a=b;return 1;}return 0;}
template<class T>bool umax(T& a,T b){if(a<b){a=b;return 1;}return 0;}
int vis[MAXN];
vector<int>dv[MAXN];
int main(){
	for(int i=1;i<MAXN;i++)
		for(int j=i;j<MAXN;j+=i)
			dv[j].pb(i);
	int n,ans=0;
	scanf("%d",&n);
	for(int a=1;a<n;a++){
		stack<int>s;
		for(int x=1;x<n;x++){
			if(x*a>=n)
				break;
			int rem=n-a*x;
			int p=upper_bound(all(dv[rem]),a)-dv[rem].begin();
			for(int i=p;i<int(dv[rem].size());i++){
				int to=dv[rem][i];
				if(!vis[to]){
					ans++;vis[to]=1;
					s.push(to);
				}
			}
		}
		while(!s.empty()){
			vis[s.top()]=0;
			s.pop();
		}
	}
	printf("%d\n",ans);
	return 0;
}

----------
====================
----------
MATHEMATICS.57
medium
----------
PROBLEM STATEMENT:
You are given an integer N. Is there a permutation of digits of integer that's divisible by 8? A permutation of digits of integer N is defined as an integer formed by rearranging the digits of N. For example, if the number N = 123, then {123, 132, 213, 231, 312, 321} are the possible permutations.

Input Format 
The first line contains an integer T i.e. number of test cases. 
T lines follow, each containing the integer N. 

Output Format 
For each test case print YES if there exists one such re-arrangement of N such that it is divisible by 8 or NO if there isn't. 

Constraints 
1 
0 110  

Note 
Re-arrangements of 10 are {10, 01} which boils down to {10, 1}.

Sample Input  

2
61
75


Sample Output  

YES
NO


Explanation 
Test case #00: 16 is permutation of 61 which is divisible by 8. 
Test case #01: None of permutation of 75, {57, 75}, are divisible by 8.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;
typedef unsigned long long ULL;
typedef pair <int, int> pnt;

#define tup(name, pos) get<(pos)>(name)
#define FI(i,a) for (auto i=0; i<(a); ++i)
#define FOR(i,s,e) for (auto i=(s); i<(e); ++i)
#define MEMS(a,b) memset(a,b,sizeof(a))
#define pb push_back
#define mp make_pair
#define ALL(a) a.begin(),a.end()
#define V(t) vector < t >
#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)<(b)?(a):(b))
#define ABS(a) ((a)>(0)?(a):(-(a)))
#define ALL(a) a.begin(),a.end()

#define lbl cerr << "debug_label" << endl;
#define dval(x) cerr<<#x<<"="<<(x)<<"\n"

void dout(){cerr << endl;}

template <typename Head, typename... Tail>
void dout(Head H, Tail... T) {
  cerr << H << ' ';
  dout(T...);
}


constexpr double pi  {3.14159265358979323846264338327950288419716939937511};
constexpr double eps {1e-9};

//*
char ch_ch_ch[1<<20];
inline string gs() {scanf("%s",ch_ch_ch); return string(ch_ch_ch);}
inline string gl() {gets(ch_ch_ch); return string(ch_ch_ch);}
inline int gi() {int x; scanf("%d",&x); return x;}
//*/

constexpr int inf = 1000000000;

// code starts here

int sti(string s) {
    int r = 0;
    FI(i,s.size()) r = r*10 + (s[i] - '0');
    return r;
}

int a[55][55][55];

void solution() {
    int tn = gi();
    FI(i,10) FI(j,10) FI(k,10) {
        string s = "";
        s+= (i + '0');
        s+= (j + '0');
        s+= (k + '0');
        sort(ALL(s));
        bool found = false;
        do {
            if (sti(s) % 8 == 0) {found = true; break;}
        } while (next_permutation(ALL(s)));
        a[i][j][k] = found;
    }

    FI(it,tn) {
        string s = gs();
        if (s.size() < 4) {
            sort(ALL(s));
            bool found = false;
            do {
                if (sti(s) % 8 == 0) found = true;
            } while (next_permutation(ALL(s)));
            if (found) printf("YES\n");
            else printf("NO\n");
        } else {
            bool found = false;
            FI(i,s.size()) FOR(j,i+1,s.size()) FOR(k,j+1,s.size()) if (a[s[i]-'0'][s[j]-'0'][s[k]-'0']) {found = true; break;}
            if (found) printf("YES\n");
            else printf("NO\n");
        }
    }



}


// code ends here

int main(int argc, char** argv) {

#ifdef IGEL_ACM
  freopen("in.txt","r",stdin);
  //freopen("out.txt", "w", stdout);
  clock_t beg_time = clock();
#else
  //freopen(argv[1],"r",stdin);
  //freopen("painting.in", "r", stdin);
  //freopen("painting.out", "w", stdout);
#endif

  solution();

#ifdef IGEL_ACM
  fprintf(stderr,"*** Time: %.3lf ***\n",1.0*(clock()-beg_time)/CLOCKS_PER_SEC);
#endif

  return 0;
}

----------
====================
----------
MATHEMATICS.58
hard
----------
PROBLEM STATEMENT:
Given a matrix you need to find the submatrix with the largest number of elements, where the GCD (Greatest Common Divisor) of its elements is greater than one. A submatrix of the matrix is a sub-section composed of contiguous rows and columns of the original matrix.


Input
Two numbers n,m in the first line. Followed by n lines with m numbers in each line.

Constraints  

1
1

Output
Just a largest area where GCD is greater than 1.

Sample Input  

3 3
2 6 8
4 8 3
6 9 4


Sample Output  

4


If you observe the following submatrix:  

2 6  
4 8  


The GCD is 2.
There is no matrix larger than this with a GCD  1.
----------
TOP SOLUTION:
----------
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#define fo(i,a,b) dfo(int,i,a,b)
#define fr(i,n) dfr(int,i,n)
#define fe(i,a,b) dfe(int,i,a,b)
#define fq(i,n) dfq(int,i,n)
#define nfo(i,a,b) dfo(,i,a,b)
#define nfr(i,n) dfr(,i,n)
#define nfe(i,a,b) dfe(,i,a,b)
#define nfq(i,n) dfq(,i,n)
#define dfo(d,i,a,b) for (d i = (a); i < (b); i++)
#define dfr(d,i,n) dfo(d,i,0,n)
#define dfe(d,i,a,b) for (d i = (a); i <= (b); i++)
#define dfq(d,i,n) dfe(d,i,1,n)
#define ffo(i,a,b) dffo(int,i,a,b)
#define ffr(i,n) dffr(int,i,n)
#define ffe(i,a,b) dffe(int,i,a,b)
#define ffq(i,n) dffq(int,i,n)
#define nffo(i,a,b) dffo(,i,a,b)
#define nffr(i,n) dffr(,i,n)
#define nffe(i,a,b) dffe(,i,a,b)
#define nffq(i,n) dffq(,i,n)
#define dffo(d,i,a,b) for (d i = (b)-1; i >= (a); i--)
#define dffr(d,i,n) dffo(d,i,0,n)
#define dffe(d,i,a,b) for (d i = (b); i >= (a); i--)
#define dffq(d,i,n) dffe(d,i,1,n)
#define ll long long
#define alok(n,t) ((t*)malloc((n)*sizeof(t)))
#define pf printf
#define sf scanf
#define pln pf("\n")

int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}
int main() {
	int r, c;
	sf("%d%d", &r, &c);
	int **g = alok(r, int*);
	int ***gr = alok(r+1, int**);
	fr(i,r) {
		int *gi = g[i] = alok(c, int);
		int **gri = gr[i] = alok(c, int*);
		fr(j,c) {
			sf("%d", &gi[j]);
			gri[j] = alok(c, int);
			gri[j][j] = gi[j];
			ffr(k,j) {
				gri[k][j] = gcd(gri[k + 1][j], gi[k]);
			}
		}
	}
	int **grr = gr[r] = alok(c, int*);
	fr(j,c) {
		grr[j] = alok(c, int);
		fe(k,0,j) grr[k][j] = 1;
	}
	r++;
	int area = 0;
	int ht = 1;
	for (int sz = r, nsz = sz + 1 >> 1; sz > 1; ht++, sz = nsz, nsz = sz + 1 >> 1);
	int **t = alok(ht, int*);
	int *v = t[0] = alok(r, int);
	for (int h = 1, sz = r, nsz = sz + 1 >> 1; sz > 1; h++, sz = nsz, nsz = sz + 1 >> 1) {
		t[h] = alok(nsz, int);
	}
	fr(j,c) fo(k,j,c) {
		fr(i,r) v[i] = gr[i][j][k];
		for (int h = 1, sz = r, nsz = sz + 1 >> 1; sz > 1; h++, sz = nsz, nsz = sz + 1 >> 1) {
			fr(i,nsz) t[h][i] = 0;
			fr(i,sz) {
				int p = i >> 1;
				t[h][p] = gcd(t[h][p], t[h - 1][i]);
			}
		}
		int w = 0;
		int mlen = 0;
		fr(i,r) {
			int g = 0;
			for (int L = i, R = w, h = 0; L < R; h++, L >>= 1, R >>= 1) {
				if (L & 1) g = gcd(g, t[h][L++]);
				if (R & 1) g = gcd(g, t[h][--R]);
			}
			while (g != 1) g = gcd(g, v[w++]);
			if (mlen < w - i) mlen = w - i;
		}
		int narea = (k - j + 1) * (mlen - 1);
		if (area < narea) area = narea;
	}
	pf("%d\n", area);
}

----------
====================
----------
MATHEMATICS.59
easy
----------
PROBLEM STATEMENT:
John is new to Mathematics and does not know how to calculate GCD of numbers. So he wants you to help him in a few GCD calculations. John has a list A of numbers, indexed 1 to N. He wants to create another list B having N+1 numbers, indexed from 1 to N+1, and having the following property:

GCD(B[i], B[i+1]) = A[i],  ∀ 1  ≤ i  ≤ N

As there can be many such lists, John wants to know the list B in which sum of all elements is minimum. It is guaranteed that such a list will always exist.

Input Format 
The first line contains an integer T, i.e., the number of the test cases. T testcases follow. 
The first line of each test case contains an integer N, i.e., the number of elements in the array. 
The second line of each test case contains N space separated integers that  denote the elements of the list A.  

Output Format 
For each test case, print in a new line the list B such that each element is separated by a single space. 

Constraints 
1 ≤ T ≤ 10 
2 ≤ N ≤ 103 
1 ≤ A[i] ≤ 104 
1 ≤ B[i]  

Sample Input  

2
3
1 2 3
3
5 10 5


Sample Output  

1 2 6 3
5 10 10 5


Explanation  

For the first testcase, 

 GCD(1,2) = 1
 GCD(2,6) = 2
 GCD(6,3) = 3
 sum = 1+2+6+3 = 12 which is minimum among all possible list B


For the second testcase, 

GCD(5, 10) = 5
GCD(10, 10) = 10
GCD(10, 5) = 5
sum = 5 + 10 + 10 + 5 = 30 which is the minimum among all possible list B

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
#include <set>
#include <string>
#include <iostream>
using namespace std;
#define X first
#define Y second
#define Maxn 100010
int nCase,n;
int a[Maxn],b[Maxn];
int main(){
    scanf("%d",&nCase);
    while(nCase--) {      
        scanf("%d",&n);
        for (int i=1;i<=n;i++) scanf("%d",&a[i]);
        a[++n]=a[0]=1;
        for (int i=1;i<=n;i++) b[i] = a[i-1] * a[i] / __gcd(a[i-1],a[i]);
        for (int i=1;i<=n;i++) printf("%d ",b[i]);
        puts("");
    }
}
----------
====================
----------
MATHEMATICS.60
hard
----------
PROBLEM STATEMENT:
You are given [expression], such that:
[expression]

For each query, find the following value: 

[expression]  

where [expression] on a new line.
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.61
hard
----------
PROBLEM STATEMENT:
Let [expression] in its decimal representation. 
John is looking for new methods of determining which numbers are strange all day long. 
All non-negative numbers of length 1 are strange. Further, a number [expression] can also be considered strange if and only if  


[expression]  
the number [expression] is recursively strange


Your task is to calculate how many strange numbers belong to an interval [expression].  

Input Format 
The first line contains single integer [expression].  

Output Format 
In [expression].

Constraints 
[expression] 
[expression]  

Sample Input

5
7 25
45 50
1 100
99 103
0 1000000


Sample Output

10
1
26
0
96


Explanation 
First testcase: There are [expression]. 
Second testcase: Only [expression] satisfies the given constraints.  
----------
TOP SOLUTION:
----------
#include <iostream>
#include <stdio.h>
#include <math.h>
#include <map>
#include <vector>
#include <string.h>
#include <queue>
#include <algorithm>
#define ll unsigned long long
#define X first
#define Y second
using namespace std;
const int Maxn = 510;
int N,M,cs,K;
map<ll , bool > vis;
int Getlen(ll x){
	int ans = 0;
	while(x) x/=10,ans++;
	return ans;
}
std::vector<ll> ans;
int main()
{
	int cs = 0;
	int T = 1;
	queue<ll> Q;
	ans.push_back(0);
	for (int i=1;i<10;i++) Q.push(i);
	while(Q.size()){
		ll x = Q.front();
		Q.pop();
		ans.push_back(x);
		// cout << x <<endl;		
		for (int i=Getlen(x);i<=18;i++)
			if (i-1 && Getlen(x * i) == i)
				Q.push(x * i);
	}
	sort(ans.begin(),ans.end());
	// for(int i=0;i<ans.size();i++) cout <<i+1<<" "<<ans[i]<<endl;
	cin >> T;
	while(T--){
		ll L,R;
		cin >> L >> R;
		int x = lower_bound(ans.begin(),ans.end(),L) - ans.begin() - 1;
		int y = upper_bound(ans.begin(),ans.end(),R) - ans.begin() - 1;
		cout << y - x <<endl;
	}
}
----------
====================
----------
MATHEMATICS.62
medium
----------
PROBLEM STATEMENT:
Charlie and Johnny play a game. For every integer X Charlie gives, Johnny has to find the smallest positive integer Y, such that X * Y contains only 4's and 0's and starts with one or more 4's followed by zero or more 0's. (i.e.), 404 is an invalid number but 400 is a valid number. 

If a is the number of 4's and b is the number of 0's, can you print the value of 2 * a + b.

Input Format
The first line contains an integer T. T lines follow, each line containing the integer X as stated above.

Output Format
For every X, print the output 2 * a + b in a newline as stated in the problem statement. 

Constraints
13 
15

Sample Input #00

3
4
5
80


Sample Output #00

2
3
4


Explanation 
For the 1st test-case, the smallest such multiple of 4 is 4 itself. Hence value of a will be 1 and and value of b will be 0. The required value of 2 * a+b is 2.     

For the 2nd test-case, Y = 8 and 40 is the minimum such multiple of 5. Hence value of a,b and 2 * a+b will be 1, 1 and 3 respectively.
----------
TOP SOLUTION:
----------

/*===============*\
|  ID: TMANDZU    |
|    LANG: C++    |
\*===============*/
//Tornike Mandzulashvili
//#pragma comment(linker,"/STACK:256000000")
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <stack>
#include <math.h>
#include <vector>
#include <string>
#include <map>
#include <queue>
#include <iostream>
#include <set>
#include <cstring>

#define EPS 0.000000001
#define Pi 3.1415926535897932384626433832795028841971
#define hash1 1000003
#define hash2 1000033
#define md 1000000007
#define INF 1000000500ll
#define mp make_pair
#define pb push_back
#define S size()
#define MX(aa,bb) (aa>bb?aa:bb)
#define MN(aa,bb) (aa<bb?aa:bb)
#define fi first
#define se second
#define PI pair < int,int >
#define REP(i,a,n) for(i=a;i<n;i++)
#define sc scanf
#define pt printf
#define big long long
#define VI vector <int>
#define DID (long long)
#define ll long long
#define AL(a) (a).begin(),(a).end()
#define INFF DID INF*INF


using namespace std;

int x,t,now,n4,n0,raod;
int fix[1000000],id[1000000];

main()
{
    //#ifndef ONLINE_JUDGE
   //         freopen("text.in","r",stdin); freopen("text.out","w",stdout);
   // #endif

    cin>>t;
    while (t--){
        cin>>x;

        now=0;
        raod++;
        n4=0;
        n0=0;

        fix[0]=raod;
        id[0]=0;

        while (now || n4==0){
            n4++;
            now=(now*10+4)%x;
            if (fix[now]==raod){
                n0=id[now];
                n4-=n0;
                break;
            }else fix[now]=raod , id[now]=n4;
        }
        cout<<2*n4+n0<<endl;
    }

}

----------
====================
----------
MATHEMATICS.63
medium
----------
PROBLEM STATEMENT:
Find the number of positive integral solutions for the equations 
[expression]

Input Format 
An integer N&nbsp;  

Output Format 
The number of positive integral solutions for the above equation modulo 1000007  

Constraints 
[expression]  

Sample Input00  

1  


Sample Output00  

1


Sample Input01

32327


Sample Output01

656502  


Sample Input02

40921


Sample Output02

686720

----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
typedef long long int64;
/*
 * 1/x + 1/y = 1/n
 * xy - nx - ny = 0
 * n^2 + xy - nx - ny = n^2
 * n(n-x) + y(x-n) = n^2
 * (n-y)*(n-x) = n^2
 * Number of factors of n^2 ;)
 * = product (1 + 2*e) where e is an exponent of a prime number
 */
int main() {   
    int n;
    cin>>n;
    bool *prime = new bool[n+1];
    for (int i=1; i <= n; i++) 
        prime[i] = 1;
    int64 answer = 1;
    for (int p=2; p <= n; p ++)
        if (prime[p]) {
            for (int j=2*p; j <= n; j += p)
                prime[j] = 0;
           int64 e = 0;
           for (int64 j=p; j <= n; j *= p)
               e += n/j;
            answer = ( answer * ( 1 + 2*e ) ) % 1000007;
        }
    cout << answer << endl;
    
}

----------
====================
----------
MATHEMATICS.64
medium
----------
PROBLEM STATEMENT:
In mathematics, binomial coefficients are a family of positive integers that occur as coefficients in the binomial theorem. &nbsp;
[expression]
denotes the number of ways of choosing k objects from n different objects.

However when n and k are too large, we often save them after&nbsp;modulo operation by a prime number P. Please calculate how many&nbsp;binomial coefficients&nbsp;of n become to 0 after modulo by P.

Input Format 
The first of input is an integer [expression], the number of test cases. 
Each of the following [expression].  

Constraints 
[expression] 
[expression] 
[expression]

Output Format

For each test case, output a line contains the number of &nbsp; [expression]s&nbsp;(0

Sample Input

3
2 2
3 2
4 3


Sample Output

1
0
1

----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

/*
??n
?c(n,m)=n!/m!/(n-m)! ????p???m??? ?n??p??? (a1a2...ak)
???n+1-(a1+1)*(a2+1)*...*(ak+1)
*/

typedef long long ll;
int a[1000],b[1000],c[1000],g[1000],t[1000];
char s[1001];

void make(int x,int *a) {
	a[0]=0;
	while (x) {
		a[++a[0]]=x%10;
		x/=10;
	}
}

void mul(int *a,int *b) {  // a*=b
int i,j;
	if (a[0]*b[0]==0) {
		a[0]=0;
		return;
	}
	c[0]=a[0]+b[0]-1;
	for (i=1;i<=c[0];++i)
		c[i]=0;
	c[c[0]+1]=0;
	for (i=1;i<=a[0];++i)
		for (j=1;j<=b[0];++j)
			c[i+j-1]+=a[i]*b[j];
	for (i=1;i<=c[0];++i) {
		c[i+1]+=c[i]/10;
		c[i]%=10;
	}
	if (c[c[0]+1])
		++c[0];
	for (i=0;i<=c[0];++i)
		a[i]=c[i];
}

void dec(int *a,int *b) {  //a-=b a>=b
int i;
	for (i=1;i<=a[0];++i) {
			a[i]-=(i>b[0])?0:b[i];
			if (a[i]<0) {
				a[i]+=10;
				--a[i+1];
			}
	}
	while (a[0] && !a[a[0]])
		--a[0];
}


void divp(int *b,int p) {
int ca,i;
ll temp;

	while (b[0]) {
		ca=0;
		for (i=b[0];i>0;--i) {
			temp=((ll) ca*(ll) 10)+b[i];
			ca=temp%p;
			b[i]=temp/p;
		}
		while (b[0] && (b[b[0]]==0)) {
			--b[0];
		}
		make(ca+1,t);
		mul(g,t);

	}
}

void print(int *a) {
int i;
	if (a[0]==0) {
		printf("0\n");
		return;
	}
	for (i=a[0];i>0;--i)
		printf("%d",a[i]);
	printf("\n");
}

int main() {
int i,z,p;
	for (scanf("%d",&z);z;--z) {
		g[0]=g[1]=1;
		scanf("%s%d",s,&p);
		b[0]=a[0]=strlen(s);
		for (i=1;i<=a[0];++i)
			b[i]=a[i]=s[a[0]-i]-'0';
		divp(b,p);
		++a[1];
		a[a[0]+1]=0;
		for (i=1;i<=a[0];++i) {
			if (a[i]>=10) {
				a[i]-=10;
				++a[i+1];
			}
			else {
				break;
			}
		}
		if (a[a[0]+1]) {
			++a[0];
		}
		dec(a,g);
		print(a);
	}
	return 0;
}



----------
====================
----------
MATHEMATICS.65
medium
----------
PROBLEM STATEMENT:
Little Lucy loves to arrange her flowers in patterns similar to those of a binary search tree. Her father, a computer scientist himself, takes note of this and finds out that she has N flowers. Every day she takes some of these N flowers and arranges them into all possible different patterns. The more the number of arrangements, the more time she spends outside.

Now, her father knows that she takes a non-empty subset of these N flowers any given day. He wants to find out the total number of arrangements that she can ever make. As this may be too large to handle, you only need to report final answer modulo 109+9 if the answer is no less than 109+9. 

Note: All flowers are distinct and are labelled by distinct numbers.

Input Format 
The first line contains an integer, T, the number of test cases. 
The next T lines contain an integer each, N ,that denotes the number of flowers the girl has.

Output Format 
Output T lines each containing an answer to corresponding query.

Constraints

1 ≤ T ≤ 5000 
1 ≤ N ≤ 5000

Sample Input

4
1
2
3
4


Sample Output

1
4
14
50    


Explanation

For the first case, only one BST is possible. 
For the second case, only 4 BSTs are possible (shown below). 

1    2    1      2
           \    / 
            2   1


Similarly, 14 BSTs are possible for N = 3, and 50 are possible for N = 4. 
----------
TOP SOLUTION:
----------
#include<iostream>
using namespace std;
int main()
{
	long long int arr[]={0,1,4,14,50,187,730,2949,12234,51821,223190,974426,4302644,19181099,86211884,390248054,777495625,140539877,463689441,164231407,539467117,930490070,709550495,506039991,170374877,788103207,2630865,927411523,986039480,58705900,724965387,330867037,227124320,752283562,13879020,27739771,473175206,239615414,374760792,685439374,562346731,50588752,78281607,623101219,587154951,397288232,675470470,994904954,363413376,826790368,85240219,100296851,233127698,659095763,335454446,501307199,55905810,666240709,959086916,473146463,7472042,625417516,462309624,30452951,230853801,967065611,761139748,137121291,154919282,760078651,862897493,275569562,426935666,985660918,704408075,958951040,807931728,580092308,535054443,303871212,529678214,327021583,719528916,223898708,962266514,102254980,742480403,774092792,957234082,384974466,671946140,416306403,228312138,972772391,784557224,129432080,985869444,935478320,788319346,823006767,345940295,151417222,899656874,759286996,409078302,547848467,631493635,90705907,823366280,89578368,911783315,19250123,689007502,868324555,129635706,295210115,156711862,665054559,897916613,124453638,670225885,545666843,876830374,358793376,607792065,445845793,419666836,703624580,538666555,981006544,425825649,198432259,690569071,274087210,796959358,987534762,232888522,995977938,698914634,30515709,856925523,830169999,597986051,350384455,527388797,722579913,239305879,939904332,891714177,772532269,75542487,821652712,4375059,542542203,483077337,913706881,809027309,99963943,455845648,768709624,571593336,308939986,997172723,371946238,367002673,455438108,316935768,862631787,373764536,927288317,550575842,299968577,151591278,155606833,165804940,604463824,960596300,203954544,370323043,297037536,689322329,867536370,588950457,315389163,90103737,933746849,977796931,57170166,344621612,538798456,625577058,967716776,339109834,572179737,454522371,366672374,138650029,516505608,185956626,621598750,635066944,589217081,540445269,108197034,652023573,632640621,793982437,389030673,880193306,530524352,244538544,424746005,274362725,812411562,861931699,976331744,183394920,238417983,325983549,35521879,872696176,848539017,749899633,892801795,684452961,587188420,480368019,34112243,604277852,679048914,362905894,876532373,477354870,998332697,742740475,854785323,265596566,825632143,245269866,469684186,806258788,151308519,546730539,610476855,327508391,471546985,165435120,825972544,132862724,296100951,673884989,61098528,693806816,302468424,677220880,283822660,501662815,989409802,88767679,813187713,724108444,470845725,415461109,734692460,992272114,533586713,399912639,724589166,519727967,825377791,444380611,321375363,86835585,959826746,750927026,697699635,998088581,618710588,664584802,775635969,61997701,711041782,963087753,763478566,546215266,338447947,713390351,385593173,127400230,853113912,710029680,271495172,406223115,329744343,419975153,492540153,256912051,511221571,403101426,348792053,775719207,497381998,118165058,294542546,349627717,11159461,212652079,396772233,721749512,747260816,946326689,499034229,340754034,836819026,811470910,494465844,998270130,388230203,102534855,408626953,913406228,681957919,464897184,278051547,969745098,302515131,386173675,170124200,912067550,641192451,519418586,230599191,72836739,438884663,702608717,446133666,743749576,215590469,736189570,951733254,11117432,78296824,57006608,108482609,582390747,646803382,385723844,980849858,813243337,973218032,7697443,679158754,415059340,499847912,715767700,23659707,624655911,314663018,348902620,82198985,618019980,523306781,911982517,959584278,716615410,217243534,105747134,252956603,986385570,860661402,989395190,543525014,184270000,965431023,983554108,695940480,128609794,894947207,605596030,95957795,217814670,217719617,254937276,243467491,301966964,402803548,629976753,871482516,995021366,265932666,770931025,781871467,28569442,301628285,970397603,938620683,523300339,605492116,360784495,700168017,292363665,424144837,615384385,718409774,851824532,682369993,982663120,236487546,764618836,674172639,709174766,440176485,292691957,796960703,425656778,868570714,992751891,553235977,948739082,959450892,95698256,973212191,500666657,340124829,754558448,163263563,399387471,520281618,714103449,402956752,893435305,315462499,431165824,18219994,802148107,822167112,511379168,711162381,216740147,838669238,659103887,881444249,305876258,739674694,531456437,582618739,338773901,501505072,794839538,254081482,173164271,890603670,225277036,632352755,929696056,764846667,768123115,521412518,291149152,724364797,571823854,403640913,270046109,838873911,543205301,515598523,52740786,261388147,459073351,730353183,173265931,383417419,50803430,694543098,951034442,513611221,843060033,466018786,235723735,594195156,325437224,254133994,784204395,265687993,144686500,374039923,57674675,843223460,752216754,975580170,148848406,239915263,100055145,148930091,966656565,607216412,375023376,127857355,61821599,453210827,781399526,510551992,823768769,287700591,528025238,778369421,696862113,128319267,216728967,983384060,433685351,662465969,61802037,576245528,243624231,568528348,72909679,994627187,400463388,304149351,514654871,373550764,706573532,852761632,157499533,231127511,557001699,61098494,245252113,669131464,911126073,289148549,77568783,522049995,751183678,671499527,61048678,146762130,641074084,716965367,304693527,133983985,13355367,611008238,45594557,734543264,642869216,498737079,485615190,589282927,224031565,115348279,364549450,231921876,399036481,236636344,622296844,366706831,769059668,790671319,459095392,840777964,248062436,717859437,523017426,469292282,608913190,831351559,390710911,484328443,136360897,270216186,252235870,24153583,745184130,882073054,886093503,691199176,183621054,396494302,5893672,217697747,491670696,9212842,25715054,869124428,606280551,16280560,308950517,320929444,957003559,72430290,109919117,805519738,909833793,811901591,199297741,772607343,608791584,61139026,942841000,961099439,355442398,821805329,694082741,713333489,35673152,533634577,28511716,288320800,885203449,356220552,791244545,382052189,465937628,710191154,615377487,672342962,470538719,546935449,443137941,525314797,647641869,855546477,672080781,900405376,806809145,683652166,841474391,637100946,428732835,812432082,345127145,379837976,276876487,761413969,896310861,129484419,412609262,350099042,818086639,851102948,715052364,203728965,15361126,618281079,412181221,423171695,131030747,38300590,351921552,545130082,950924909,597397343,902629868,926891465,265263624,274976737,532120183,100402255,511431373,712970559,54619037,146434881,369987349,539558164,627867117,713682305,447047047,546050541,933917587,280974765,371522762,387819962,523546952,33083998,368023016,159807552,352017091,331861746,329271919,285068300,283687356,105117699,988905827,972190349,651511844,188395214,128266303,304227291,784392350,475343537,645887619,731441357,816199030,419275924,232089080,30160664,336798432,932283291,154942528,869497006,885503289,300209334,694950026,585710823,329845523,778228564,994858316,717194978,663914901,975970463,171355384,510169190,343583938,237407713,845350277,527975706,373967533,298771142,493315553,4875804,875117129,357605231,66446216,342117386,556687150,729766287,705900978,887465470,960758902,216827942,632061263,298298404,15789190,897885356,441303468,648161565,332286601,168889257,127842830,810300932,700109608,182085962,339007231,226976573,987538502,290842034,912231091,218657104,221323890,998508864,762554770,566716206,537313882,463541219,485252292,610632715,249349658,879923250,329051506,70974725,5653370,533319535,900787565,90773768,713823059,18128273,670984945,983077893,573173259,758423934,913221081,126843069,540911069,354731902,887891750,834467553,746041277,378751366,745157659,651135721,550428960,809787924,175405639,286820750,493781296,494215942,964049614,398318913,943184964,486249672,753328408,31840293,531668386,161543820,979709387,772013077,886999609,87712424,604595262,156640799,851853350,993029982,104595480,137725164,505287035,238312900,377047142,311911866,367585892,525486109,647671038,315197017,137434452,707019305,127426024,158617084,998339574,908658637,659662147,852403906,832853142,390270695,767911654,452435332,401123426,274171827,967300285,465476655,555575363,314013805,208299234,623939510,60334251,184600711,450050734,228667901,956880289,282027472,97195738,567387091,357765969,80764327,315793463,351791728,757690494,234656463,171547171,920676235,909976118,102868664,807398039,7526728,295905611,312225273,36135428,976004603,495552198,179099062,597440519,91713287,723263365,838341304,350755155,244899918,455587237,910872100,210620779,947782321,50953881,58864694,973606191,628320265,806701509,766906340,298753485,474252371,124435659,788701028,659329486,285274924,118638704,452769424,826885421,345222282,629699256,521019505,81252738,312261816,692126989,182916512,451486703,181605285,530591534,732633614,638546174,687282661,917491459,890238655,543156659,429206930,17816992,82714150,701693265,751570706,600742215,499363829,201506567,228024211,296057954,443147477,734362229,18178395,611246361,523411287,556346252,750196832,170550793,450731020,144899957,706143913,576068811,629646650,13993691,914329922,686588486,79832379,505930482,940454186,841897252,345538938,43441558,559836750,38022010,17937854,732070675,908622610,461298914,155952616,951607298,755726390,899832212,97436103,467697749,185002555,535198150,393315813,65574790,148352385,943385399,462601312,362702979,298981118,785853685,344382793,257303665,622936632,89880949,836592480,139563279,424946849,76159655,605709381,356997800,969755762,393226958,461566169,899484867,690542029,851255772,803070749,176830103,877881596,817749540,771430266,478427604,579760813,131519995,356382711,772708658,831305949,642173009,549329125,876000166,185303920,744262007,630043249,514361267,14926653,265507593,875292535,811077978,570753988,561641333,936976063,542958223,626001401,339937576,757158981,196255097,501517690,349815096,663231076,968810768,919056952,780849593,590749085,393549330,966717991,769457163,786622916,315098851,85038149,316479167,633446600,352105989,964575465,796112665,262893622,291076568,195494548,48324245,171426206,414362186,247365041,856551385,859313077,418982572,150574016,487469402,245207928,333913184,579935375,530529071,34033380,425260856,495982272,975946187,532642903,215740639,573264369,403616742,101838104,930955904,886841935,623497327,501316703,928759102,136050208,31877028,799134225,887011531,858556738,479317521,104665983,773466828,326222366,85396570,357285576,431146882,828818460,236443421,549377125,76458225,787738148,356755044,556730314,958958116,784952843,241079570,303355853,953026133,336767954,796719991,679188258,322294399,176242120,557021520,108424285,646846850,902646777,944570957,900935305,709704720,972089297,471059390,886822030,177001,936554477,503418286,115519580,552156013,19376497,822480362,697136440,384589770,371851558,307133278,19234105,314449845,541596358,818590681,486956518,88776895,441603349,728188128,990164836,803529483,808617062,651846457,426331026,255724065,140766033,45286292,683519649,376015593,47642973,232749516,410616540,713013709,560473742,181252403,422294053,837666004,33106206,798339034,209560182,426256658,931584651,908100711,654683696,672544385,127955833,646160060,603475430,462729323,312894153,61632390,221670853,769315363,915648385,683505933,753290569,880212642,949806601,339802258,445511972,559642720,723320785,678817845,259951290,340560918,928942704,759140842,143017607,723980780,376325398,578712185,39899172,835470597,241654038,725212266,375490359,973875008,770226958,660793001,965617,124070135,219094511,197621976,377469175,20061055,978858813,854013295,977197686,518117551,994896049,174566294,588639958,228895253,442062810,892306718,82109148,728392390,93867547,580496089,380890212,767013774,376348195,13834212,197617342,461509854,60942327,694194724,812844529,44722774,362520266,239703762,648710895,274268895,708459047,367418942,556026772,76016926,875762196,708584674,721280635,30679045,6569782,654193773,813792370,522775946,178036271,477221428,872787492,469179758,496276112,792317021,102541403,182822099,233622333,127819119,603144292,785854249,671463249,446278290,932034622,716395189,437864035,610326914,420284177,430931000,948310495,651582702,219942487,574883138,766064860,654677506,820662701,831073337,343318171,452059812,529382726,373254750,31064143,599569055,643627315,51145727,330359502,213133864,67579579,423280392,357517736,789957580,986595888,659530303,96213291,302523887,567840306,493536200,220058550,676245054,639765073,959060295,289126565,834704667,354561732,977890073,743132139,372516232,673879477,400125479,574163816,603891136,328476407,444285391,148315030,488835668,828604834,112352686,778663924,296419780,283497587,570401191,523015439,756576107,47964481,336700059,592615182,59352732,931315537,492322870,68128154,769068270,511831112,584624543,144617357,121401544,482610915,737814657,734972827,638260502,58259953,598040017,162023218,687129924,195020607,670540614,488282520,248082175,627033336,314222141,868702377,281554175,137936739,28590679,488803212,758308225,909485981,159172775,405958882,560028528,352717656,91090506,294869138,178533917,671797897,88765592,573610003,313608725,64073238,964650512,201362568,48619963,937320625,543866251,84084885,247288595,444547841,166053980,880229289,309347573,492385086,406200445,200889610,411495719,562980952,188169234,983832487,965117652,168967571,963013540,535891475,453670839,182486206,66118556,19844312,934538173,942361950,337694265,934562969,257791591,679860906,300199421,408039169,513980905,181093484,113216701,573033670,129265024,889063378,138295561,553149577,393207098,400461163,623171854,183038239,132310294,458940067,689953932,913814688,489075809,84475028,745380864,121253229,524395751,244011342,981968270,849151701,368409238,977300573,897468410,534601181,848363890,181188232,836028756,973696049,889745673,320435931,421306212,464768818,63047567,132890980,152262738,633268621,993135600,265757121,462651346,80424842,66516375,678469880,150294984,255942692,247400597,463574462,484292338,891662684,640078609,842577964,521971393,476076392,536419452,960655405,414943182,766527262,980661533,638041545,80786460,153066392,989367058,114736074,913232130,330985384,138556165,984349783,508732419,643701003,652760537,71124122,151809952,531311752,447024203,801027548,786312092,817658588,814972858,762633160,932300211,507647820,84773075,925219138,202085319,458242606,403877766,705783931,241665120,443104365,325469748,237178370,600894157,666781305,296063034,218632425,587937797,926608451,762065665,342055798,123479734,821369988,980205210,333057977,152405063,891007088,958522939,653312139,959593113,743268858,468036894,47071943,143667730,191640843,999883723,422443997,75729757,713368943,660173012,121244635,476053263,911441371,625919784,42887631,725795282,29639065,865928815,125832708,316235726,27081540,300420502,229693600,653651806,51117726,608082,505045449,675714467,75968401,675213815,864649065,518806712,260122137,315545793,881074694,167481137,16601162,623615162,677931237,478063158,495162039,70991749,426708536,180503662,194435319,693016493,551014348,238067266,661277880,824541443,958932843,312756379,870820026,974763974,478106478,835603621,135537968,407373732,899427798,202169352,246031200,625868995,524702991,586725712,862178632,35275894,982588402,265100441,570096040,715688267,884202016,174209912,129699966,26882345,592099624,215051429,358253577,588916715,754360418,136398627,873580987,975384569,279872169,358693845,254677490,408651715,818725881,448353373,564945788,429314345,975784018,622400597,359164165,12014918,227601730,52706367,649547460,35232692,270901022,231224347,849608543,649898952,5336376,394450346,527692595,713627754,481414589,136301428,817875452,516117316,348667842,98816217,559429899,279539595,640991346,396566131,414865026,446576893,135572336,188177111,562496548,76608908,774053295,122345563,826829266,828729235,947729367,995506008,757124729,904918447,840610848,473904610,992308144,339633408,478993018,956054172,38473603,637724212,858781033,911193758,412625893,9848928,65129225,987784544,330252840,636085309,970798041,522881355,971812666,323079098,406888864,430588200,256216278,407812319,563647705,928598631,121901394,182183304,936992337,512702641,427437514,408499025,47347055,472364930,540630018,756209023,333712689,291074435,491618607,549577950,737748185,592846648,505087277,943872361,477688734,23127067,222260635,496147916,497379854,728031061,399471371,179267593,783405690,921811640,691133538,990953533,721413893,302927848,746386431,652376498,663288979,383050574,498965440,746905286,822139441,373977834,971419270,17115026,975651896,507970030,916695861,610560929,94340130,357585291,355192011,53703515,70680462,265934095,127480620,962563286,199335754,830818588,96721959,504023836,325955795,392161725,6616554,131320620,590345430,199311791,700155962,856755766,483370960,271179802,230590808,335260093,68479649,492820708,786121667,807775385,144029339,782540525,838944362,316237561,165238358,919781451,180416439,689279162,250078724,970728955,627958512,257145065,302044373,487700178,172726487,930124559,3823849,826970003,598217813,905808328,42566270,671825980,336651120,579913204,438675809,140619089,247372300,931816865,511308773,182071552,810716604,55342049,346092546,812357762,551813591,151392841,968272484,553397162,83405187,32166987,373559926,970938099,52667840,111966523,283820066,972436955,557516066,166253084,575681439,456094156,504408066,801989940,540256204,724317719,196048675,574938756,420274050,873232228,14136840,866152435,953839054,397942469,780241974,304804124,76240168,508963617,627874357,82183901,548338222,52117755,318521879,760139457,705926261,575766506,23987446,622672527,704247286,537663231,990712266,735784466,551761162,373368380,495108761,906028874,631222530,504826353,418148491,238632763,556127866,744570149,734392633,503722150,269988715,985762041,467410982,151373030,911240456,983831739,122669511,343619320,743986578,679755575,509982783,336832630,830025126,167872920,361498508,573035114,259039004,959646278,875726191,120001868,591818339,349289178,255811259,134250741,979016205,619561499,955274664,85703311,719721383,347493101,960896669,634570818,225939609,99061918,802441687,900033191,488657452,175432051,328283907,922411619,912562949,659041277,631309855,804937031,13568342,804118340,199827518,712451709,612314340,743983370,868367043,770400419,713893689,523099303,891109123,844959888,873993571,133032549,552918367,2485668,311348705,227793949,476664179,606396224,606942426,955629698,406688967,495570118,160587391,997536273,605609831,913818627,9748028,950719269,939722564,608466723,680614768,80587669,52849137,893604641,457690446,789163897,93855038,147390859,458466686,179260221,633254734,497676967,241584286,575755144,652857992,639924152,875154102,77398926,149939001,849617995,832560637,127261029,29270669,762087940,734698474,592881755,530803387,57343963,444694600,601403613,778251777,71400827,941344917,361878968,445972505,893154481,355693253,870732149,942578161,797978815,64043646,296541774,477941739,239627267,203712417,309284746,430051094,496000582,521347035,446930846,400726344,926457083,299195607,307455910,189447739,226832564,502824918,376447164,47565983,106717687,394016454,486635752,695886563,136828208,709507721,638692081,915914371,699380210,169983125,843118006,815655118,239668840,495383885,692088201,205567272,927384154,934335642,254192490,832652721,545864693,651781218,310257242,113380866,870803762,260044416,593615224,923982770,608191491,623112043,791402854,316427547,959539147,989877587,830079876,364724896,474471073,226980592,146613279,803083157,473301612,869052012,106671261,966070455,774101326,100855630,747718639,738353941,228883122,795214778,215753185,232959910,402684453,855486301,563026415,480651948,159078483,142342644,744289167,785851802,142615384,251442139,670595751,455627882,467862551,506442585,82964481,612127786,282373951,85631878,186778722,775943695,429621165,142392227,871582088,269994671,608430497,140486597,579684366,771088978,709565196,685693495,917653835,838365189,450079273,534779918,365122600,623872033,572913427,63997575,431624343,296010377,316484293,456540377,788911735,741534081,298814615,148713772,869827099,795220899,966335606,998835226,698727860,473165786,915832111,615146557,113794812,384333422,640141137,579024223,236651984,637154946,980299580,317374854,603172924,738674660,35453114,245029200,261440696,77850056,340428062,678636700,874772335,900051176,204953054,388375529,906139296,227564620,903639835,776770979,962195341,659922245,95989079,716280393,472753679,338878947,783467878,325486373,461160533,164394188,806488483,874952239,991495989,590007586,569191322,209026608,411095752,685995500,513025668,512262768,932444509,525042104,445444619,223552437,845382125,546622624,567450116,193063014,361323412,591851778,914841295,484273493,403096030,371669141,972065721,107353427,82155551,551987437,470526615,872041743,419156046,763164037,469481263,670837707,889250129,360266905,642878223,947250922,495073119,339913510,116943566,601556803,717280965,519828737,42248668,650980566,475976492,759628137,412310623,101475324,685327697,528170029,842817955,951085371,799054430,351161896,927363845,621737871,335661334,128114690,841824903,464938923,223793426,122303108,48820437,39740014,510531404,564914640,663515838,663210732,390043928,978316056,526138664,570453797,132512358,962639813,755594113,861435161,471302009,882216556,357510979,652332878,172041079,542197957,439477386,21201458,225622469,922256,874300010,595631817,719601695,700577351,109651011,106185650,896257204,138730968,725053178,738426119,925098981,348796060,896458783,448336841,958015577,769411640,844026137,45971046,329915021,430579151,60722751,304764950,843131137,239583543,396292169,384234514,479217618,277424732,254116531,115103498,315898048,821522503,668363114,430283988,756156628,230949102,112284834,905968603,188733203,705894033,575057296,896580735,332124408,430200375,587041304,48603579,539973871,992375650,273136546,35774087,21779323,969955244,445578888,489822999,677907426,566695183,161262862,458595354,315336082,176025895,960242024,853480152,820243641,672916815,243341108,383066920,651175059,300514514,807681390,815981560,512900661,955444532,37732293,108944211,590397530,718113730,972219097,486229570,600606971,400887118,527922715,564965886,645397553,615893586,616805807,736680298,755472319,952242658,639309260,349246168,268482040,367476225,991824096,751746120,292563279,677418343,78677388,542558823,375652974,944492603,965535879,658084693,898926210,396774308,346453756,618306077,746857265,787061747,770634608,182207333,731161481,20335348,66270180,358190910,838346670,203513123,557101173,274856458,852397548,214217508,899274520,142837992,977219963,771881581,737142958,485574699,976307833,842657010,791610156,630657601,746030395,879275500,494270558,730760933,759576149,282777985,597496862,785894628,74118911,769482760,197489692,75421473,887801226,354579310,347785479,217959958,538401082,592499498,526186735,794845893,132479365,60443048,276434794,230483735,405959552,792103,423447014,345609629,153953767,722902923,543437016,712751868,42221751,321037125,762752113,501012750,433028449,179607331,363764485,489904432,721855089,930076319,986076653,95449952,281639196,212885401,371516306,601917289,131495801,252047310,979558838,15019168,129495888,755210360,62416378,544380393,11360561,128964796,486905955,553565136,142466873,754943261,914728624,48218923,508950705,678771845,282714046,831461517,856933472,183894911,824668361,158502413,425972352,585882157,537341891,722664250,427491359,210617089,945136509,170239926,465200557,958529733,39905590,566846391,85801224,9836156,957786920,821253329,478781867,763226539,955773852,656759598,489698261,674781363,204092433,542907051,339825527,955677531,527096798,871375430,480900608,202238522,996481806,473562347,316694035,169634412,67854379,471934851,744691658,116286589,291996032,386361417,342940549,707349136,357713868,341353067,129970943,853298415,353582906,835811491,311956187,912175332,444046247,204215983,343834528,367523394,220774732,44018632,63937272,925681052,992234798,882478331,612814564,402138883,324826014,591236461,269735107,612744603,793359899,541740878,682165996,492738612,284361350,993153420,775890259,382652562,284318822,885909138,384952827,881718993,148929154,966005268,749447660,408141422,398884193,860314695,387600428,90764762,935900972,335897003,956208146,784621739,111327224,659738886,900305664,658629754,316347820,314716830,968750323,63205795,931009739,406873563,966336772,611316228,898545443,536038665,991101857,599790899,365256639,847551315,222984294,311423122,77147946,86909818,939948576,526913716,443257859,424866914,611442479,85560069,613792004,952192103,612611245,488569009,508171892,418413120,829697377,104410425,138939845,266616072,172649214,571012593,825418006,957664124,475760089,547333035,530799577,727023063,626369916,948147862,110644648,23207018,813132967,984521260,637735215,61198673,442321398,334020031,427619157,233162252,44168977,182726188,39321333,892850606,340969875,195625317,94088994,864662764,431146644,937316050,982952173,404282362,888198788,578935776,342177713,472094663,482155888,409483237,655185848,984351875,685719712,985123144,465957332,234530333,582237027,826557484,630755231,430176860,503973774,423811990,937926099,561458375,82611946,952697854,991468359,827234237,363182818,67775498,534717600,618017437,193311380,720773164,505309819,134239287,393074829,700621488,375254249,621075954,299143440,374031085,945503719,520564317,634187219,773670449,796428435,114799852,893128709,148198232,189685788,442988458,66032283,723559755,140079350,20082227,633616272,555100236,447861416,150414648,187502905,888824955,760423337,45197314,711714299,92542908,14226297,10128415,826279119,954712546,606769711,369637713,771370948,10386138,718229227,11049421,7724122,45003979,529101308,412748403,727557906,908948614,635342785,149804717,179371593,239739769,268805732,311469500,942264887,142822850,897539198,505825309,394530580,570230625,778131785,45266488,120114353,121355871,106651012,443951282,649153458,359850171,995534568,800341517,532777264,165916098,248245399,552461613,426552467,872334578,27237826,638572287,365264995,298448973,941319558,798864385,686141912,140156351,590501469,689453385,543315340,892317786,931803936,257626791,930694609,412107251,324274408,205928503,981354640,396677152,20494612,974349213,110908316,73604482,639070346,58878356,770985686,173667106,454588534,508857302,628557032,236094034,750458307,814155503,800180444,941010369,635963780,971421404,113523389,939691048,709847052,321749135,824777895,419435232,910812518,703613667,257637802,117741705,842163601,583093982,966506396,587557591,719636023,947881565,264756673,27598646,992320915,209658928,183387309,431445385,356753334,861993097,100658124,136527713,886530342,861422175,589041860,261203262,415193242,53769238,721185256,951961917,129003235,947822145,356411091,791309633,990639279,369853219,317214038,522343163,131534845,246877917,362974152,30988475,234920819,443989939,177520028,276009242,747332519,268206758,698130228,442566449,153157688,592751346,745137807,383800260,218249678,413990914,419032948,95813681,154716929,213406081,11001094,813916209,381909909,918181022,250056707,858003961,105712645,701823381,149521334,622811297,555251875,82537161,980855140,567484514,680561755,590282143,346626304,493121598,752141608,861527288,637525495,840506763,250204813,975909693,424054937,258822753,56500174,632617810,790099866,135803174,476630486,79299946,433743797,629434856,8432948,78360895,700105162,379650570,626877391,111489650,218062277,242407166,286380751,322579015,605580842,159676045,1680830,784936177,689611768,504266673,779791293,408421682,964690539,561672517,560272244,308340657,418039492,538483158,315861828,147188545,772845097,779899885,116958882,577240785,745847872,295747350,758746908,364775923,289840423,717207554,234050586,554107308,366835696,472033735,641733256,57035147,543285128,840806925,288112226,201062358,856205002,966019467,59260125,230430117,239545657,425786217,166137345,908647884,867351623,503587420,151165574,282054431,426146577,85535596,879324428,50468248,947682444,823478903,387515595,542845497,633131567,957661211,683543991,741768997,119218054,392109580,509668750,950226481,679764454,18539529,413663382,917016842,744083063,241050680,159858729,396852504,821352354,893815693,22902983,902825782,808225374,844880821,201651291,185376078,248743978,450070464,5106825,803526367,319085364,232129350,888629003,301438777,546107145,513568140,826754712,914487295,781505607,555235787,855225317,273944033,2539621,969358613,83547618,27589068,828649565,635080120,337676060,651228482,604331408,899227595,752081562,703929636,64864761,900212764,888330277,986776391,888833571,394537151,529326966,413411150,94801993,839481072,526687198,952421338,827604790,542688159,182587436,364141143,516278077,720626142,923695351,77408011,378714102,776416043,692540388,467874576,968190222,731944793,728260202,871064366,783957162,139237539,495991316,392731530,835232081,333973831,236959934,820878150,59812769,623318990,333293302,900116605,451543176,185227252,836576797,424321640,117901178,712522439,295140427,102078986,449125960,415931292,804357892,126506008,777093928,444277304,627835140,933862441,597901497,982867500,197917020,881264301,146533455,841392630,365479509,574614772,484671503,367114068,407896808,868723778,794642954,470389848,86749815,722680221,807670761,591232460,534842535,301417770,387903238,450955474,837519857,400506864,50238254,61404715,427992380,389364013,938952064,854024288,779623488,18757861,947576816,451996684,6317822,512624284,545319549,840012694,26044056,769016941,341348053,472943065,742259032,998621484,702354540,606943268,271891596,759248483,508727751,696767135,308482980,547710556,373886227,255761922,796256523,731769412,528155483,166887862,203146123,657118667,767625990,501518420,251787810,574706306,971967736,479888743,64681880,668262427,111655565,194996490,380733522,29506352,82388535,62007130,446776006,166059976,608730847,52300801,397897834,98512062,14754642,750456991,12211796,384281782,207622723,371975103,294530000,164029557,748778282,75706716,612982418,263032803,236339660,171674081,721489523,156978042,866511242,915374607,616862245,215161908,261394647,239455270,516777220,854852248,990655602,306777835,370307421,491139509,552096913,207210032,311311628,872966924,532907110,746971650,498588380,664224729,826613889,594749783,169168436,697665042,377753522,347743494,393578301,816723881,357052734,219594219,881116059,88056061,707997791,843281847,813526192,298186914,260947028,399696948,159271546,679096046,55651064,922943978,730072021,336293041,483467740,456036617,476904482,363586584,304893485,245775600,5606561,258262967,443199232,508669234,285505696,898278787,485153854,677157379,680610950,858514041,217818955,290277250,491502564,332780979,891076574,819304748,299103795,426127475,100402716,36317909,164787822,635658903,645389844,565810937,564550096,559898111,416871502,262516885,203125373,113164017,648960692,270836905,779167306,603022822,357342859,718043470,137245857,388213796,928578844,784099998,677955530,499029023,697329487,997270029,873528181,485656898,788831632,205326188,734129368,506391488,435693861,689464611,601784810,919462362,144164061,176024377,593052159,329913639,605092663,286918599,325459027,650392907,437987488,804849304,953960362,414749400,223046534,465661930,626601078,558560375,247434316,355390524,490496416,258946733,605416424,192839539,304950849,60036086,30270882,544223830,714225024,994069511,395876243,516825920,326816857,838484583,892745123,44086529,346801398,888608245,190453009,88400100,941204875,405025676,409502809,454130534,396861360,126648158,589068955,993625506,667472465,894485343,799546223,955116611,37686345,749172179,582637484,246780113,25036975,398883096,908732802,4172348,826182239,268554235,922186626,979639011,117161542,489187191,302906094,871334878,27497593,512330340,518350187,855918740,263579657,360555051,326836111,354567132,322594498,746986593,12325983,788796515,815235157,890709759,975945751,195763047,397608904,952364475,217105763,816629600,58326229,145898531,231457800,752631026,482388659,98276833,196597298,212445132,132879482,986924363,717585366,280750970,713414409,372750160,560867421,772656854,670157021,884034346,906773595,921143331,935307560,474641315,526667435,661423595,442548369,720581184,615098407,779228789,45323743,556213077,46491323,179647525,889622378,434183569,408269138,207904733,806885497,507556433,997743720,147116627,763219193,788458254,703679108,860901166,558704990,809991660,338073976,705240414,502214209,526471072,295546160,280305485,886844726,882866604,750451005,733962613,479919314,572522646,71831234,82418803,59621619,909244958,692272606,241925827,593044377,279887079,165874470,568328700,578812917,310558266,474684983,71336781,823670108,349616707,54005815,873669159,432340275,152232788,373815047,457688767,372695899,413751914,779931641,285119701,878265815,322204406,940993384,990186918,984114899,166067508,611107232,33042360,255356393,558579434,387577770,398459034,348949646,698031169,701455384,118266372,716318465,584419081,125128781,452954530,828987392,889192996,807435633,163625554,366393886,625051218,243379376,952247115,373439866,159204529,507201985,293728574,212219198,977889892,73896256,476578368,395553993,79918783,626949139,874275104,612329950,599097065,266702552,332177036,413352616,78472151,591292291,50584858,680929308,15109385,242299126,344402700,177747733,622719653,655839477,469382884,217469195,404739859,675891859,514927888,504720765,174655347,660008669,286676405,731513380,512870821,610718791,61546245,17256436,436185329,82939527,691547421,229206137,783067658,473801386,193872951,84808594,565832822,368511160,946714144,959849769,655182473,716389785,870045880,899652867,18095106,651475545,190646438,140101860,570551226,492817621,191087566,196512966,358287080,907568465,860176869,67655124,129712083,848808514,123031584,455889518,865660771,170489355,278490741,184083893,327187901,530628140,321681534,346481368,247803625,707493663,57030351,74248934,625288206,841722553,519200493,98379997,21233476,26522727,637808682,247768813,989409800,698069814,326492066,836396291,714955154,542327396,179133617,148273841,983685768,113263013,408717773,689611338,179610588,58767739,569854132,793121540,453934660,95286366,118791885,532466260,136448828,468911087,572337944,106870312,30362154,883813798,444661655,847421011,803896168,747220536,428042606,507881491,533582083,885406880,971782023,827678446,426392511,980604440,465905868,859304074,509412775,857427574,946446490,684491482,740075641,840235235,336628042,802124535,209764814,713448322,64832537,474241679,736228358,362331778,163090898,750574092,281346200,812608592,11130433,329731382,338965624,589427013,316454677,769722522,766326820,518169186,266379857,778810951,198233053,129734404,487111084,69141611,801873603,721532510,993599577,353440605,231068940,590337969,782007312,311600759,186027942,811971948,979075134,365170601,943221742,522162641,745819663,403819187,222290583,190892918,990376993,71244929,374941580,955754732,575675079,970698481,775178046,643001087,823081674,151364900,44485447,604103976,664112845,479780421,718413245,84902341,975715555,739485821,713094582,234538582,921728863,133286088,202401538,314611691,846194639,306865640,247764925,513288838,3266510,80050629,727876705,933507900,620586402,260021226,553406190,286896348,860260278,602884025,699648708,12293132,553869623,116001832,885307876,537750416,129338079,502847708,17612928,484935152,432833827,529478334,784283317,173903098,484747307,901586818,231207944,766695830,398349462,260020868,115836933,516021293,426220070,689675712,645554578,723340074,578711728,972270233,945639372,747329755,85998318,336786253,610816591,368522213,194100969,140390421,794200839,52146498,95494848,752569335,709312405,120312171,928262347,312664038,901371003,572760354,793942186,940432448,551602141,665636135,987105530,100062983,360052547,392112232,574675081,511921882,832462136,665868262,257718596,639351314,450128801,595093982,198368396,15006558,771448937,909516930,224908828,57808766,339118449,328159312,994235785,189208503,143265050,680612467,489525572,895546383,773761223,769940013,287276535,517103216,507647583,46502304,940859534,660226796,302652243,530467027,402065013,106391154,57618780,148260328,110342065,569778383,116835412,801412426,735725230,368747067,879153668,80531527,58483538,855140963,366226875,65775983,366671747,307875747,212914229,662083576,99646727,238873379,575978686,225195828,959553555,727658017,817574203,819492724,982493006,868061750,563827245,517544589,206060051,818663737,569592814,821285182,946972880,201704344,131674426,662111994,554131564,781299686,925082510,168640785,145213142,830709641,803372618,758179547,285318762,335439553,513037466,204719229,5878900,789995779,25104138,770410666,453206845,365453606,34033103,212661312,183146936,368097702,354579325,103068415,455950873,706858185,748815166,481917616,514051529,341129372,29374211,16247142,750548266,542289959,665828317,584271585,552088173,6649490,211106930,637522350,917482120,484985640,752571646,448192539,294645589,568756134,720229643,507579961,820105976,38027851,24290590,240642006,655817424,957733514,245093705,262920243,696346783,442709605,889112884,946847335,218252189,883449024,561384855,823388223,532612180,321859938,391966340,991654459,128610317,610962929,983428420,526948881,899585455,640946759,348782086,207719225,23889791,845079090,504021896,688090157,490411138,100358924,64668264,95418002,356828056,479073106,851097849,624018245,719017383,457188707,898980900,415958796,659837749,944297572,301793493,686741691,416221953,876876687,565231519,809977139,682720678,401241124,478958805,752788893,216073162,807566893,675821437,217639663,949139122,453957403,650298498,910997168,962045801,108685009,565236612,630832007,347711057,167848267,692859862,96402855,482524938,784583678,662668482,518186885,592230663,785447196,551015351,170213686,129380114,601664972,495185802,111088398,623305211,648155800,184201359,483902600,161365040,510630725,282986487,626815615,582713811,114649640,131933284,852222241,998967662,60423930,168202778,473665922,219524323,739163271,241498217,199214055,152155224,760251256,157356264,375201995,108514955,572083128,185581743,96309211,587826264,891593075,182970124,781568103,656006582,924217585,544910779,170536869,956188052,204821581,590604229,206404506,278732712,628669721,852903449,551244692,465042861,694865217,416205635,664723783,587305268,820086,104554103,259867185,556062204,307290493,22394317,631709931,621284944,501120478,34509678,396512480,50047099,932972795,240651922,251195105,308134863,537476164,48441547,383445380,572467839,734007889,800929484,415797839,527333183,310129226,761311998,343712039,138830757,113994696,925254941,16644114,741193771,189086130,786983660,606667383,607960557,107688782,168117352,718847131,848310236,513133300,717079250,954868522,191265464,955203312,599092675,776055299,490654429,396685932,55988764,625293077,888240740,494417418,638292426,943956122,728988323,485810731,681595413,71322718,309374803,518794432,805949442,284671878,381536530,507883299,597845089,390978740,230274512,919273739,218169368,506512770,949278423,792573765,825078958,946327355,715096012,734628505,562329997,183435090,884033011,330463696,49495720,893050054,392682582,475453962,954625436,207330118,108154424,369850693,726896928,131001807,825659877,670181500,805641933,656197481,674448938,887877908,360078613,749833275,227502710,548967711,674408450,878103552,782150653,532938623,473071333,262973448,344498861,880144479,329097850,764000178,284710632,491269288,905197475,439463133,60951227,761890847,488103568,192370214,920261937,44185424,948870393,971631094,739999923,227746432,812164884,861675136,505628055,952319260,344293209,332376353,877790558,253599097,829096,632637533,639992331,51287034,253112632,577967949,114852449,920278436,44660397,85838264,69722584,944591862,399481700,524229960,33322764,523986242,734808925,269968229,188967443,354550217,265810664,539202937,313510007,581983960,898130860,979644177,855453220,353682150,537906535,554147233,558166079,439852008,612682167,510430043,766656634,637373479,243823806,789680404,464510864,922392006,472012041,853482154,759321633,148885153,80481745,113704510,113208146,692201839,72742028,112350900,570106031,673140531,178519324,294434593,646933905,424169997,531029950,24411160,806525473,403421687,156582054,513563800,101391592,23627913,6567615,605690175,106275928,265513223,355932399,190384546,956265995,783770408,761000854,376283869,34584019,336756239,498660455,876829625,418477800,93480270,621786006,127063865,996226671,63887537,47992880,108606483,454653225,861287422,35763722,124659509,304923371,20421895,259421338,587604191,829371736,504202382,789063661,498634750,129921527,530792362,494427708,835977401,824139419,387120273,719847283,646847098,852723844,46862045,888573625,559618715,892072598,387341168,44574601,692160901,212763359,762366077,646441037,431025734,128358212,198483445,991268768,264599535,323586225,889452810,854605360,109230574,922267545,816314530,772666746,948223376,783425616,801657794,625495592,881634172,663827272,286886061,369864546,700132833,368414217,455183321,754739631,997151432,109154934,707332826,211116291,441585968,130976905,94538318,937551145,321919882,355281704,116014430,343720631,875078594,686523313,722389179,508332105,385642903,797208489,717378011,156262413,862321965,276008455,308508948,655519583,872167206,823762934,300515646,743740247,515165517,372127866,681196305,255366792,115380287,205967804,135433782,378303957,979135053,963651913,919038830,101304560,706338096,891563699,979042620,518034563,413387643,868144749,647349105,817368665,457615545,259449664,272080196,331038642,263577707,543631589,260536675,572267083,402548183,678418268,322259779,101992611,281639086,917321914,475578471,515046003,272106707,70005007,863433064,975486001,815111678,538473789,80443062,453333419,980775404,2106590,918202881,679584540,499237770,835247398,72136094,511976623,946579761,718730230,831605711,671204335,414746909,107706846,387099832,513482979,962084249,599283993,666593666,905944509,783402322,325342363,237694603,963136613,700488675,805377232,743257584,100609273,134391492,912904422,720161630,515488146,383069547,594761375,871038404,664612637,572326946,521737909,45680364,786947685,155913271,350675921,829249149,852019583,507209859,31743335,97899385,595706453,439638118,210784003,495486021,246891019,94884303,685462511,563937105,277383913,169382617,738841903,926757155,589173844,693804504,34070873,938833277,354326739,740317277,660363621,198459389,801325162,357951121,225889352,598448225,823397409,802145023,77548233,233057684,197850972,837100182,553458487,814798695,28073853,497646374,569845141,229888493,431376067,525583274,941735431,655136797,268696255,144306116,469248157,118287667,558593550,692460723,305606669,959792367,373566163,14635072,848661446,510873317,441227591,126984334,720208588,482044354,681711086,805911487,721579956,628305373,958272594,187746926,563735179,689655514,850274786,623103936,297124385,137033448,293573914,754497942,52859338,16179188,948752400,703834380,301546283,293018382,14371337,390058243,628341363,528646984,809450266,582001761,986315788,308583456,707535663,701243872,75092184,674587217,851766640,32888329,13957629,830638824,411630803,115582982,829002979,351217464,641233965,559845789,197864426,897252321,235659792,767662154,508420224,512143948,122647773,228349106,879485109,189263465,810334939,109880866,880201913,115714037,84646216,956400642,977540190,625807911,556079104,382625714,107067263,507299623,815541836,197553763,970364457,388881182,370742341,586758030,752794825,391240750,959130839,982504558,502501000,912504879,132771282,328130850,810323011,676528099,200158410,480162164,314050926,628138805,934968052,798312555,754508765,356281786,884832389,862769071,161881929,825890240,278193942,595061391,302305977,559801234,260365594,320521441,109302367,254414436,800413572,880452433,706848751,28047300,534231055,85734880,34718618,433171024,267856592,462344070,512725377,71051973,859197816,918878664,50520128,115359089,917347745,314571563,915182545,785841543,454480335,631846629,590217079,445731580,325632090,954329035,622267058,100954517,200830863,724375225,157709536,980549794,848288073,905797005,949125147,772250906,122226793,718893753,331207220,650134683,326484502,72355097,818012712,167107980,824881051,541020983,456082072,869559506,688650138,185264868,387416998,528858928,829095275,3952493,58609836,669085247,63419652,101978245,81051577,953261010,213589726,90132577,796074811,329700374,963302132,815218633,634620704,161940057,378164563,887736159,433516483,606681381,622123001,78945671,405283918,900379103,784325576,110073784,312682828,704281830,396149723,966868709,43724287,472749698,610022345,995529616,189200106,748367986,529532638,805222152,885146308,474243684,327241121,739516963,642438565,958255995,332280700,756785891,410828997,136256329,896036551,246231460,645942318,444517561,737593629,744125123,667853564,880592264,311578808,585696814,583867524,39529116,931689238,560284412,436336372,939331153,631456117,745366119,711111896,451806550,547144177,542047188,935939740,978311263,648215769,292959052,740836316,222574119,867977021,4624481,304369252,881300992,316969618,590119822,739266158,177370287,515512599,358134883,92170780,388002087,749471538,630964979,336467947,503951634,762276438,835075914,678017208,157226556,770521870,265784408,351290933,710473988,986649564,2067047,176714674,125998951,253601257,795227739,352108304,751841297,887636130,832377674,699863757,941361633,905940029,262812816,663710371,736345291,132841510,675475466,371184384,614234174,760781713,404841274,382082251,129971246,716711763,635514695,811175638,957786275,398073884,10952732,712557330,542043446,358341255,212174081,971100506,69306983,591433364,399885353,442734810,182585949,316947269,204047913,199103652,281397670,636870330,198261144,39628456,138266884,166400560,148318985,477243607,160980196,109421725,81608690,963409242,989134613,952476219,781567284,835209436,100639551,293292965,254110264,570270208,42665448,961498627,221914132,419080098,4018114,433056503,523595794,763731186,771505809,631815402,789355733,180246369,796007268,68488388,446052725,290205959,965273601,243189199,701321156,417963998,227080068,755111635,899939533,258017902,32928625,233151657,735976942,86179702,297522001,627298215,151089550,762123529,355447780,687587421,121501850,358348746,939700904,516998485,345071548,40128391,590370811,823534583,331599401,439228296,423105850,61699656,179136837,466447558,55610633,296772095,587001941,851536830,972002792,27522030,468725492,885695713,556337641,32500844,198410373,285258166,444225766,57754884,630829906,396829383,847941514,77348982,581180192,33525667,755679461,476722826,391606332,773687497,7445746,467835097,500351816,880673521,541142899,975281990,628799502,425202877,618827993,906839264,181806180,568014140,139408945,340438307,997200671,951938018,487726150,871670557,18654566,888383524,518434047,553262539,819628966,423779239,145991600,867685797,21201874,608762692,86905351,780956035,724613481,949029286,940940170,266196183,693886422,773475393,739209031,117628500,33655647,784374910,923183412,654843595,852869094,296794612,341396808,533707866,626689618,238613857,133082045,157047881,914805625,522747028,688209284,762308151,960169234,124746118,256645858,944966889,923015349,344980775,842477536,476206065,207622098,475508212,178956421,68958265,555503015,891422880,15671867,948481991,881874463,326471891,905523348,570466645,82223438,641226534,1358623,966119816,987851826,82241349,298119717,16817033,650187991,490876154,129991690,581598803,749771565,288300878,870363313,614965965,406784556,653924119,342976759,964177307,35724382,964813700,847109327,185435641,873107157,155877340,251486367,102043337,194099478,559804160,18546513,33441678,426261846,523610969,312803830,721514133,662500893,867624796,499409202,454568992,944579603,767191591,950247030,316161128,798495223,557484971,947400566,513478446,103321992,959358689,558033607,81882386,787257035,197467876,451232279,984202636,129633471,937632739,258662185,919083858,743465078,849092377,387487576,370660084,756035042,471356388,301068539,371244706,633176258,239294390,480823260,500461485,166564452,785671493,876337628,468342247,771455542,863147216,224758898,740567218,986753753,909228541,638826954,225909906,16000879,836495064,571182287,578869132,59663243,271959221,902870165,423796387,552896267,448049622,172624563,827744668,674883083,341202651,907265990,139583042,91809303,266770328,606790437,471606822,417752889,176622111,957403740,45199432,131099621,492938510,172066942,158043169,244286818,947003253,543363320,653766112,415100217,955570688,982643435,982323868,575573455,112507123,169058660,833810757,71266390,637118233,739193193,552271420,149767302,248197521,28205160,323161121,445668916,557936249,759670630,707166222,310497911,244247883,245480146,772487405,755352617,182017439,226928765,514900994,154345557,878572508,116305817,758639193,453167756,450772227,560963347,616793134,903179904,278104099,440862797,464561823,46201512,669899780,617591257,702839218,660890483,41616887,113759964,968302497,355241222,790307419,144928274,213894967,768180026,214897145,83405469,271840736,658684540,69559887,517196674,229645131,457612205,927006623,952113923,351591731,991851170,961518870,155537211,77719857,880516511,305973554,239093446,620073047,666648850,662489510,771019683,338319641,38575463,256368591,956747385,525195967,20036098,992646851,932335584,280792868,859140607,736402538,638418200,314009901,916596433,290791069,208691757,17544793,237325843,274914766,660006754,412144520,750364515,186979205,801230368,944493358,842554016,210451318,525361669,50254002,121554109,301490038,72504664,82064777,579989027};
	int t,n;
	cin>>t;
	while(t--)
	{
		cin>>n;
		cout<<arr[n]<<endl;
	}
	return 0;
}
----------
====================
----------
MATHEMATICS.66
hard
----------
PROBLEM STATEMENT:
You are given [expression], such that:
[expression]  

Using this value of [expression] as follows :-  


The value [expression] is the root of the tree.  
A node is expanded such that all it's divisors are it's children.  
Continue expanding till the tree has depth [expression].  


For example, if [expression], then the tree will look like the following:



Once the tree is built, we create another tree [expression] as follows :- 


Every leaf node [expression] is the totient function.   
Every non-leaf node is equal to the sum of the values of it's children.  


From our previous example tree, after constructing a new tree, we get the following tree.  



Print the value at the root of tree [expression].  
----------
TOP SOLUTION:
----------
#pragma comment(linker, "/STACK:512000000")
#define _CRT_SECURE_NO_WARNINGS
//#include "testlib.h"
#include <bits/stdc++.h>
using namespace std;

#define all(a) a.begin(), a.end()
typedef long long li;
typedef long double ld;
void solve(bool);
void precalc();
clock_t start;
int main() {
#ifdef AIM
  freopen("/home/alexandero/ClionProjects/ACM/input.txt", "r", stdin);
  //freopen("/home/alexandero/ClionProjects/ACM/output.txt", "w", stdout);
  //freopen("out.txt", "w", stdout);
#else
  //freopen("input.txt", "r", stdin);
  //freopen("output.txt", "w", stdout);
#endif
  start = clock();
  int t = 1;
  cout.sync_with_stdio(0);
  cin.tie(0);
  precalc();
  cout.precision(10);
  cout << fixed;
  cin >> t;
  int testNum = 1;
  while (t--) {
    //cout << "Case #" << testNum++ << ": ";
    //cerr << testNum << endl;
    solve(true);
    //cerr << testNum - 1 << endl;
  }
  cout.flush();
#ifdef AIM1
  while (true) {
      solve(false);
  }
#endif

#ifdef AIM
  cerr << "\n\n time: " << (clock() - start) / 1.0 / CLOCKS_PER_SEC << "\n\n";
#endif

  return 0;
}

//BE CAREFUL: IS INT REALLY INT?

template<typename T>
T binpow(T q, T w, T mod) {
  if (!w)
    return 1 % mod;
  if (w & 1)
    return q * 1LL * binpow(q, w - 1, mod) % mod;
  return binpow(q * 1LL * q % mod, w / 2, mod);
}

template<typename T>
T gcd(T q, T w) {
  while (w) {
    q %= w;
    swap(q, w);
  }
  return q;
}
template<typename T>
T lcm(T q, T w) {
  return q / gcd(q, w) * w;
}

void precalc() {

}

template<typename T>
void relax_min(T& cur, T val) {
  cur = min(cur, val);
}

template<typename T>
void relax_max(T& cur, T val) {
  cur = max(cur, val);
}

#define int li
const int mod = 1000000007;

const int C = 3100;
int c[C][C];

void solve(bool read) {
  for (int i = 0; i < C; ++i) {
    c[i][i] = c[i][0] = 1;
    for (int j = 1; j < i; ++j) {
      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;
    }
  }
  int m, a, d;
  cin >> m >> a >> d;
  vector<int> primes;
  for (int i = 2; primes.size() < m; ++i) {
    bool f = true;
    for (int j = 2; j * j <= i; ++j) {
      if (i % j == 0) {
        f = false;
        break;
      }
    }
    if (f) {
      primes.push_back(i);
    }
  }

  int res = 1;
  for (int i = 0; i < m; ++i) {
    int sum = 0;
    int init = i + a + 1;
    int step = 1;
    for (int rest = 0; rest <= init; ++rest) {
      int add = c[init - rest + d - 1][d - 1];
      if (rest) {
        add = add * step % mod * (primes[i] - 1) % mod;
        step = step * primes[i] % mod;
      }
      sum = (sum + add) % mod;
    }
    res = res * sum % mod;
  }

  cout << res << endl;

}

----------
====================
----------
MATHEMATICS.67
advanced
----------
PROBLEM STATEMENT:
You will be given two integers [expression].

Constraints

[expression]
----------
TOP SOLUTION:
----------
//#pragma comment (linker, "/STACK:128000000")
//#include "testlib.h"
#include <cstdio>
#include <cassert>
#include <algorithm>
#include <iostream>
#include <memory.h>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <cmath>
//#include <unordered_map>
//#include <unordered_set>
#include <ctime>
#include <stack>
#include <queue>
using namespace std;
//#define FILENAME ""
#define mp make_pair
#define all(a) a.begin(), a.end()
typedef long long li;
typedef long double ld;
void solve();
void precalc();
clock_t start;
//int timer = 1;

bool doing = true;

int main() {
#ifdef room111
	freopen("in.txt", "r", stdin);
	//freopen("out.txt", "w", stdout);
#else
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	//freopen(FILENAME".in", "r", stdin);
	//freopen(FILENAME ".out", "w", stdout);
#endif
	int t = 1;
	cout.sync_with_stdio(0);
	cin.tie(0);
	precalc();
	cout.precision(10);
	cout << fixed;
	//cin >> t;
	start = clock();
	int testNum = 1;
	while (t--) {
		//cout << "Case #" << testNum++ << ": ";
		solve();
		//++timer;
	}

#ifdef room111
	cerr << "\n\n" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << "\n\n";
#endif

	return 0;
}

//BE CAREFUL: IS INT REALLY INT?

#define int li

void precalc() {

}

int binpow(int q, int w, int mod) {
	if (!w)
		return 1;
	if (w & 1)
		return q * binpow(q, w - 1, mod) % mod;
	return binpow(q * q % mod, w / 2, mod);
}

int mod = 1000000007;

int gcd(int q, int w) {
	while (w) {
		q %= w;
		swap(q, w);
	}
	return q;
}

//ld eps = 1e-9;


void solve() {
	int a, b;
	cin >> a >> b;

	int cur = 2;
	for (int i = 0; i < a; ++i) {
		cur = cur * cur % b;
	}
	
	cout << cur << "\n";

}




----------
====================
----------
MATHEMATICS.68
hard
----------
PROBLEM STATEMENT:
Sherlock Holmes is bored to death as there aren't any interesting cases to solve. Dr Watson finding it impossible to be around Sherlock goes out to get some fresh air. Just as he lays his feet out of the door, he is thrown right back into his house by the explosion in front of his apartment. The metropolitan police arrive at the scene a few minutes later. They search the place thoroughly for any evidence that could throw some light on the event that unfolded. Unable to get any clues, they call Sherlock for help. After repeated persuasion by Mycroft Holmes and Dr Watson, Sherlock agrees to look at the crime scene. 

Sherlock walks into the apartment, the walls are all black and dripping wet as the fire was recently extinguished. With his skills, he observes, deduces and eliminates the impossible. What's left after it is a simple puzzle left by an evil computer genius and the future Arch Nemesis of Sherlock, Jim Moriarty. 

Given a binary string (S) which contains '0's and '1's and an integer K, 
find the length (L) of the longest contiguous subsequence of (S * K) such that twice the number of zeroes is 

S * K is defined as follows:
S * 1 = S 
S * K = S + S * (K - 1)  

Input Format 
The first (and only) line contains an integer K and the binary string S separated by a single space. 

Constraints 
1 
1 

Output Format 
A single integer L - the answer to the test case

Sample Input

2 00010


Sample Output

2


Explanation

S * K = 0001000010


"1" and "10" meet the requirement that 2 * #0 
The longest one is "10", length = 2.
----------
TOP SOLUTION:
----------
#include<iostream>
#include<stdio.h>
#include<cassert>
#include<cstring>
#include<time.h>
#include<cstdlib>
#include<cmath>
#include<string>
#include<sstream>
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<vector>
#include<algorithm>
#pragma comment(linker, "/STACK:16777216")
#define pb push_back
#define ppb pop_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
#define LL long long
#define bit __builtin_popcountll
#define sqr(x) (x) * (x)
#define forit(it,S) for(__typeof((S).begin()) it = (S).begin(); it != (S).end(); it++)
using namespace std;
typedef pair<int, int> pii;
const double eps = 1e-9;
const double pi = acos(-1.0);
const int maxn = (int)1e6 + 10;
const int INF = (int)1e9;
char s[maxn];
int cnt[maxn],f[maxn],m;
LL x[maxn];
void update(int p, int val) {
    while(p < m) {
        f[p] = min(f[p],val);
        p = p | (p + 1);
    }
}
int get(int p) {
    int res = INF;
    while(p >= 0) {
        res = min(res,f[p]);
        p = (p & (p + 1)) - 1;
    }
    return res;
}
int main() {
    int k; cin >> k;
    scanf("%s",s);
    int n = strlen(s);
    for (int i = 1; i <= n; i++) {
        cnt[i] = cnt[i - 1] + 5 * (s[i - 1] == '1');
    }
    for (int i = 0; i <= n; i++) {
        x[i] = cnt[i] - 2 * i;
    }
    sort(x,x + n + 1);    
    m = unique(x,x + n + 1) - x;
    for (int i = 0; i < m; i++) {
        f[i] = INF;
    }
    LL res = 0;
    int p = lower_bound(x,x + m,cnt[0]) - x;
    update(p,0);
    for (int i = 1; i <= n; i++) {
        p = lower_bound(x,x + m,cnt[i] - 2 * i) - x;
        int w = get(p);
        if (w != INF) {
            res = max(res,(LL)(i - w));
        }
        update(p,i);
    }
    if (k == 1) {
        cout << res << endl;
        return 0;
    }
    for (int i = 1; i <= n; i++) if (x[0] <= cnt[i] + cnt[n] - 2 * (i + n)) {
        int l = 0;
        int r = k - 1;
        while(l < r - 1) {
            int e = (l + r) >> 1;
            if (cnt[i] + (e + 1) * 1LL * cnt[n] - 2 * (i + (e + 1) * 1LL * n) >= x[0]) {
                l = e;
            } else {
                r = e;
            }
        }
        p = upper_bound(x,x + m,cnt[i] + (l + 1) * 1LL * cnt[n] - 2 * (i + (l + 1) * 1LL * n)) - x - 1;
        res = max(res,i + (l + 1) * 1LL * n - get(p));
    }
    cout << res << endl;
	return 0;
}

----------
====================
----------
MATHEMATICS.69
medium
----------
PROBLEM STATEMENT:
You are given an array [expression] queries. 

Each query is of the form : 

[expression] 

You need to print Yes if [expression] function, otherwise print No.

find(int i,int j)
{
    if(ij) return 1;
    ans = pow(A[i],find(i+1,j))
    return ans
}


Input Format

First line of the input contains [expression].

Output Format

For each query display Yes or No as explained above.

Constraints 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression]

No 2 consecutive entries in the array will be zero.

Sample Input

4
2 3 4 5
2
1 2 4
1 3 7


Sample Output

Yes
No

----------
TOP SOLUTION:
----------
#include <iostream>
#include <stdio.h>
using namespace std;

#define THRESHOLD 70
#define INFI 1000

long long A[200001];



long long gcd(long long x, long long y){
	
	if(y>x) return gcd(y,x);
	if(y==0) return x;
	return gcd(y, x%y);
}


long long greaterHelper(int L, int R){
	
	if(L>R) return 1;
	
	long long ret = greaterHelper(L+1, R);
	long long a = A[L];

	if(ret == 0){
		return 1;
	}
	
	if(ret > 7 ||  a > THRESHOLD)
		return INFI;
	
	for(int i=1;i<ret;i++){
		a = a * A[L];
		if(a > THRESHOLD)
			return INFI;
	}
	return a;
}



bool mygreater(int L, int R, int K){  //K<60
	
	int nsteps = 20;
	int Rprime = min(L+nsteps, R);
	for(int i=Rprime; i>=L; i--){
		if(A[i]==0 || A[i]==1) Rprime = i;
	}
	long long ans = greaterHelper(L, Rprime);	
	if(ans > K)
		return true;
	else 
		return false;
}








void funct(long long x, int L, int R, int K, long long a){
	
	//cout<<x<<" : "<<L<<" : "<<R<<" : "<<K<<" : "<<a<<endl;
	
	if(L==R || A[L+1]==1){
		if(a%x == 0)
			printf("Yes\n");
		else	
			printf("No\n");
		return;	
	}
	
	
	if(A[L+1] == 0){
		if(x==1)
			printf("Yes\n");
		else
			printf("No\n");
		return;
	}
	
	
	if(a%x == 0){
		printf("Yes\n");
		return;
	}
	
	
	long long g = gcd(a, x);
	if(g == 1) {
		printf("No\n");
		return;
	}
	
	if(!mygreater(L+1, R, K+1)){
		printf("No\n");
		return;
	}
	funct(x/g, L, R, K+1, g);
}




int main(){
	
	int N,Q,L,R;
	long long x;
	scanf("%d", &N); 
	for(int i=0;i<N;i++)
		scanf("%lld", &A[i]);
	scanf("%d", &Q);
	for(int i=0;i<Q;i++){
		scanf("%d", &L);
		scanf("%d", &R);
		scanf("%lld", &x);
		funct(x, L-1, R-1, 0, A[L-1]);
	}
}

----------
====================
----------
MATHEMATICS.70
hard
----------
PROBLEM STATEMENT:
It is holi festival, festival of colors. Devu is having fun playing holi and is throwing balloons with his girlfriend Glynis. Police saw this mischief and tried arresting his girlfriend, Devu being a mathematician asked police not to arrest his girlfriend and instead torture him with brain teaser. Devu was a young engineering fellow and he did not knew that policeman was equally good in mathematics, policeman gave Devu a problem which is as follows:

Let [expression]

Your aim is to answer [expression]

Can you help devu and his girlfriend rescue from modern police.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <cassert>
using namespace std;

int multi(long long x,long long y,int m) {
	return x * y % m;
}

int f(int n,int k,int m) {  // n > 0, k > 0,	
int r = (m == 1)?0:1;
	for (;k;k >>= 1) {
      		if (k & 1) {
        		r = multi(r, n, m);
      		}
      		n = multi(n, n, m);
    	}
    	return r;
}

int crt(int n1,int n2,int k2,int n) {
vector<int> a,m,b;
int M = n;
	for (int i = 2; i * i <= n; ++i) {
		if (n % i == 0) { 
			int j = 1;
			for (;n % i == 0; n /= i, j *= i)
			;
			m.push_back(j);
			b.push_back(j - j / i);
			a.push_back((n1 % i)?f(n1,f(n2,k2,j - j / i), j):0);
				
		}
	}
	if (n > 1) {
		m.push_back(n);
		b.push_back(n - 1);
		a.push_back((n1 % n)?f(n1,f(n2, k2, n - 1), n):0);
	}
	int r = 0;
	for (int i = 0; i < a.size(); ++i) {
		int temp = M / m[i];
		if ((r +=multi(multi(a[i], f(temp , b[i] - 1, m[i]), M), temp, M)) >= M) {
			r -= M;
		}
	}
	return r;
	
	
}

  

bool check(int &n1,int k1,int n2,int k2,int n) {
	if (n == 1) {
        	puts("0");
        	return true;
    	}
    	if (k1 == 0) {
        	puts("1");
        	return true;
    	}
   	 if ((n2 == 0) && (k2 > 0)) {  
        	puts("1");
        	return true;
    	}
    	if ((n1 %= n) == 0) {
        	puts("0");
        	return true;
    	}
    
    	// f(n2,k2) > 0
  	n1 = f(n1, k1, n);
  	if (n1 == 0) {
		puts("0");
      		return true;
    	}
    	if ((n2 == 1) || (k2 == 0)) { 
		printf("%d\n",n1);
      		return true;
    	}
    	return false;
}



int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
int c,n1,n2,k1,k2,n;
        for (scanf("%d",&c);c;--c) {
            scanf("%d%d%d%d%d",&n1,&k1,&n2,&k2,&n);
        	if (check(n1,k1,n2,k2,n)) {
            		continue;
        	}
       		// f(n2,k2) > 0, n1 > 0, k1 > 0
		long long r = 1LL;
		for (int i = 0; (i < k2) && (r < 30); r *= n2, ++i)
		;
		printf("%d\n",(r < 30)?f(n1, (int) r, n):crt(n1, n2, k2, n));
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.71
medium
----------
PROBLEM STATEMENT:
Ma5termind is going through the Euler's book of knowledge when he finds the following function: 

def function(L,R):
    sum=0
    for i in range(L,R+1):              #[L,R]
        for j in range(1,i+1):          #[1,i]
            cnt=0
            if (j)*(j+1) == 2*i :
                for k in range(1,i+1):  #[1,i]
                    if __gcd(k,i)==1:   #__gcd Greatest Common Divisor 
                        cnt+=1
            sum=sum+cnt
    return sum


The function seems weird as well as interesting. Don't you think ?? 

Fascinated by the function, Ma5termind codes it and successfully compiles it in the first go itself. After all, he is a good coder. Ma5termind checks the output computed by the function for all the values of [expression] and finds that the results are correct.

But as we all know, Ma5termind loves large numbers - very large numbers. When he inputs [expression], the code does not produce any output #TimeLimitExceeded. He still wants to know the answer for such large ranges. Can you help him by writing a code that can also produce an answer for such large ranges?   

Input Format 
First line of input contains a single integer [expression] denoting inputs to the above function.  

Output Format 
Output consists of [expression] lines each containing result computed by the function when corresponding range is inputted to the function.

Constraints 
[expression] 
[expression]

Sample Input  

2
1 10
2 5


Sample Output  

9
2


Explanation 
Pass Parameters to the function and check the result.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

typedef long long LL;
vector<LL> V;
vector<LL> ans;
int T;
LL L,R;
int euler[2000001];

int main(){
    for(int i=1;i<=2000000;++i){
        euler[i] += i;
        for(int j=2*i;j<=2000000;j+=i){
            euler[j] -= euler[i];
        }
    }
    for(int i=0;i<2000000;i+=2){
        V.push_back((LL)i*(i+1)/2);
        V.push_back((LL)(i+2)*(i+1)/2);
        ans.push_back((LL)euler[i/2]*euler[i+1]);
        ans.push_back((LL)euler[i/2+1]*euler[i+1]);
    }
    for(int i=1;i<2000000;++i) ans[i]+=ans[i-1];
    scanf("%d",&T);
    while(T--){
        scanf("%lld%lld",&L,&R);
        --L;
        printf("%lld\n",ans[upper_bound(V.begin(),V.end(),R)-V.begin()-1]-ans[upper_bound(V.begin(),V.end(),L)-V.begin()-1]);
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.72
medium
----------
PROBLEM STATEMENT:
Arthur defines a function, [expression] pairs such that:


[expression]
[expression] are coprime.
[expression]


Given an integer, [expression], help Arthur find and print the result of: 
[expression]
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define PII pair<int,int>
#define VI vector<int>
#define VPII vector<pair<int,int> >
#define PLL pair<long long,long long>
#define VPLL vector<pair<long long,long long> >
#define F first
#define S second
typedef long long LL;
using namespace std;
const int MOD = 1e9+7;
const int SIZE = 4e4+10;
VI fac[SIZE];
LL an;
void dfs(int it,int x,int mul,int L,int R){
    if(it==SZ(fac[L])){
        an+=mul*(R/x-L/x);
        return;
    }
    dfs(it+1,x,mul,L,R);
    dfs(it+1,x*fac[L][it],-mul,L,R);
}
int main(){
    REPP(i,2,SIZE){
        if(!SZ(fac[i])){
            for(int j=i;j<SIZE;j+=i)fac[j].PB(i);
        }
    }
    DRI(n);
    for(int i=2;i*i<n;i++){
        dfs(0,1,1,i,n/i);
    }
    cout<<an<<endl;
    return 0;
}

----------
====================
----------
MATHEMATICS.73
hard
----------
PROBLEM STATEMENT:
Consider an inifite array, [expression] in the following way:  

[expression] 

To get infinite array [expression], and so on, infinitely many times. 

Given the values of [expression]. See the Explanation section below for more detail. 

Note: This challenge uses [expression]-based array indexing.
----------
TOP SOLUTION:
----------
#define _USE_MATH_DEFINES
#include <algorithm>
#include <cstdio>
#include <functional>
#include <iostream>
#include <cfloat>
#include <climits>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <time.h>
#include <vector>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> i_i;
typedef pair<ll, int> ll_i;
typedef pair<double, int> d_i;
typedef pair<ll, ll> ll_ll;
typedef pair<double, double> d_d;
typedef pair<int, ll> i_ll;
struct edge { int u, v; ll w; };

ll INF = INT_MAX / 2;
ll MOD = 1000000007;
ll _MOD = 1000000009;
double EPS = 1e-10;

int main() {
	int N; ll M; cin >> N >> M;
	M--;
	vector<int> p(N);
	for (int i = 0; i < N; i++) {
		scanf("%d", &p[i]);
		p[i]--;
	}
	vector<int> pi(N);
	for (int i = 0; i < N; i++)
		pi[p[i]] = i;
	for (int i = M; i >= 0 && M < i + N; i--)
		M = i + p[M - i];
	cout << M + 1 << endl;
}

----------
====================
----------
MATHEMATICS.74
medium
----------
PROBLEM STATEMENT:
A prime number is an integer greater than [expression] and itself.

We call a number megaprime if it is prime and all of its individual digits are prime. For example, [expression] is not prime).

Given two long integers, [expression].
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

long long mulmod(long long a, long long b, long long c){
	long long x = 0, y = a%c;
	while(b){
		if(b&1){
			x += y;
			if(x >= c) x -= c;
		}
		y = y * 2;
		if(y >= c) y -= c;
		b >>= 1;
	}
	return x;
}

long long BigMod(long long a, long long b, long long mod){
	if(b == 0) return 1;
	long long x = BigMod(a, b >> 1, mod);
	x = mulmod(x,x,mod);
	if(b&1)
		x = mulmod(x,a,mod);
	return x;
}

int miller_rabin(long long n, int itr = 3){
	if(n < 2) return 0;
	else if(n == 2) return 1;
	if(n%2 == 0) return 0;
	long long d = n - 1;
	while(d%2 == 0)
		d /= 2;
	while(itr--){
		long long rnd = rand() % (n - 2) + 2;
		long long temp = d;
		long long x = BigMod(rnd, temp, n);
		while(temp != (n - 1) && x!=1 && x!=(n-1) )
		{
			temp *= 2;
			x = mulmod(x,x,n);
		}
		if(x != (n - 1) && temp%2 == 0)
			return false;
	}
	return true;
}

int ans = 0;
vector<int> A, B;

int v[] = {2,3,5,7};

void solve(long long num, int idx, int equalA, int equalB){
	if(idx == A.size()){
		//cout << num << "\n";
		ans += miller_rabin(num);
		return;
	}
	int lo = 0, hi = 9;
	if(equalA) lo = max(lo, A[idx]);
	if(equalB) hi = min(hi, B[idx]);

	if(lo <= 0 && hi >= 0 && num == 0)
		solve(0, idx + 1, equalA && (A[idx] == 0), equalB && (B[idx] == 0));

	for(int i = 0; i < 4; i++){
		if(v[i] >= lo && v[i] <= hi)
			solve(num * 10 + v[i], idx + 1, equalA && (A[idx] == v[i]), equalB && (B[idx] == v[i]));
	}
}

int main(){
	long long a,b;
	cin >> a >> b;
	assert(a <= b);
	while(a){
		A.push_back(a%10);
		a /= 10;
	}
	while(b){
		B.push_back(b%10);
		b /= 10;
	}
	while((int)(A.size()) < (int)(B.size()))
		A.push_back(0);
	reverse(A.begin(), A.end());
	reverse(B.begin(), B.end());
	assert(A.size() == B.size());
	solve(0, 0, 1, 1);
	cout << ans << "\n";
	return 0;
}

----------
====================
----------
MATHEMATICS.75
hard
----------
PROBLEM STATEMENT:
You are given [expression], such that:
[expression]

For each dataset, find and print the following on a new line: 

[expression]  

where [expression].  
----------
TOP SOLUTION:
----------
#include <cstdio>

using namespace std;

const int mo = int(1e9) + 7;

int sum[200005];

int pow(int a,int b)
{
	int tmp = 1;
	for(;b;b >>= 1,a = a * 1ll * a % mo)
		if (b & 1) tmp = tmp * 1ll * a % mo;
	return tmp;
}

int main()
{
	sum[0] = 1;
	for(int i = 1;i <= 200000;i ++)
		sum[i] = sum[i - 1] * 1ll * ((1ll * (i + 1) * (i + 2) / 2) % mo) % mo;
	int t;
	scanf("%d", &t);
	for(;t;t --)
	{
		int m,a;
		scanf("%d%d", &m, &a);
		printf("%d\n", sum[m + a] * 1ll * pow(sum[a],mo - 2) % mo);
	}
}

----------
====================
----------
MATHEMATICS.76
medium
----------
PROBLEM STATEMENT:
N ants are in a circular race. The length of the race is 1000 meters and ant number i is initially Vi meters far from starting point (point 0) of the race in clockwise order. All the ants walk with a speed of 0.1 meters per second, some of them walk in clockwise order, some in counter clockwise order. When two ants meet at a point, they say "Hi" to each other and both of them change their direction of walking to the opposite direction. This process is timeless, meaning they say "Hi" and change their direction in 0 seconds.

You are given the initial position of ants, you don't know their initial directions but you want to know how many times do they say "Hi" to each other after 1000000006 ( 10^9+6 seconds ). You need to find the initial walking direction of ants such that, c1+c2+c3+...+cn is maximized, where ci is the number of times ant number i say "Hi". Print this maximum value.

Input: 
The first line of the input contains an integer N, the number of ants. N is not greater than 100. 
Next line contains n numbers V1 , V2 , ... , VN. All Vi are non negative integers less than 1000. All Vi are distinct.

Output: 
On the only line of the output print an integer being the answer to the test.

Sample Input 
2 
0 500

Sample Output 
400000

Explanation 
In the example there are two ants, In case their direction is the same, they will never say hi to each other, in the other case they will say "Hi" to each other in times 2500, 7500,12500, ... , 999999750. so the result for an Ant would be (999997500 - 2500)/5000+1 = 200000. Hence the answer is 200000*2 = 400000.
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.77
medium
----------
PROBLEM STATEMENT:
Ichigo is receiving special training from Kisuke Urahara to beat Aizen. This time, Kisuke took (P * Q * R) identical cubes and made them into a big box of dimensions P x Q x R. Moreover, it happened quite by chance that P, Q, R were all pairwise coprime, that is, gcd(P, Q) = gcd(Q, R) = gcd(R, P) = 1 where gcd(X, Y) is the greatest integer dividing both X and Y. He then asked Ichigo to cut the box into two pieces with a single slice. Ichigo used a Getsuga Tenshou in his hollow form on the box and sliced it into two parts completely. 

His slice was such that for a corner vertex X of the box, if A, B, C are the vertices of the box adjacent to X, then Ichigo's slice was a plane passing through A, B, C as given in the picture below. Now Kisuke is wondering what is the number of cubes that were cut into two parts. Since the answer can be huge, output it modulo (109 + 7).

  

Input Format:

Line 1: T 
T - Number of test cases. 
Lines 2 to T+1: P Q R 
P, Q, R - the dimensions of the box  

Output Format:

For each test case, print a single integer in a new line that is the number of cubes that were cut by Ichigo modulo (109 + 7).

Constraints:

1 
1 12 
P, Q, R are pairwise coprime

Sample Input:

3
1 1 1
2 1 3
5 3 2


Sample Output:

1
5
15


Explanation:

In the first test case, we have a single cube. And when Ichigo slices it, that single cube is sliced. So, the answer is 1.

In the second test case, we have a (2 x 1 x 3) cuboid. Then, when Ichigo takes an arbitrary vertex X and slice the cuboid as explained, then the cube which contains the vertex diagonally(body diagonal) opposite X in the cuboid is not cut, every other cube is cut. So, 5 cubes are cut.
----------
TOP SOLUTION:
----------
#include <cstring>
#include <string>
#include <cstdio>
#include <cmath>
#include <vector>
#include <algorithm>
#include <map>
#include <iostream>
#include <set>
using namespace std;
long long i,j,k,s;
long long a,b,c,d,t,e,l,m,n;
string p,q,r;

main() {
    cin >>t;
    a = 1000000007;
    while (t --){
        s = 0;
        cin >> l>>m>>n;
        l = l%a;
        m %= a;
        n %= a;
        s = (((n-1) * (l-1)) % a +a)*500000004%a+
        (((n-1) * (m-1)) % a +a)*500000004%a+
        (((m-1) * (l-1)) % a +a)*500000004%a;
        s %= a;
        s = s + m+l+n - 2;
        
        cout <<s%a <<endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.78
hard
----------
PROBLEM STATEMENT:
Integer sequence [expression] is defined as follows:


[expression]
[expression]
[expression]


Write a function generator, [expression].

Let [expression].
Determine the number of different residues in [expression].
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>

using namespace std;
#define MAXN 300000

long long A[MAXN+1], B[MAXN+1];
long long N, M, C, temp;
map<long long, bool> S;

int main(){
    cin >> C >> M >> N;
    A[0] = C % M; B[0] = (2*C) % M;
    for (int i=1; i<N; i++) {
        A[i] = (A[i-1] + B[i-1]) % M;
        B[i] = (B[i-1] + A[i]) % M;
    }

    long long ans = 0;

    for (int i=1; i<N-1; i++) {
        temp = (A[0] * A[i] + B[0] * B[i]) % M;
        if (S.find(temp) == S.end()) {
            ans++;
            S[temp] = true;
        }
    }
    for (int i=0; i<N-1; i++) {
        temp = (A[i] * A[N-1] + B[i] * B[N-1]) % M;
        if (S.find(temp) == S.end()) {
            ans++;
            S[temp] = true;
        }
    }
    ans = ans % M;
    cout << ans << endl;
}

----------
====================
----------
MATHEMATICS.79
medium
----------
PROBLEM STATEMENT:
The problem is quite simple. You're  given a number N and a positive integer K. Tell if N can be represented as a sum of K prime numbers (not necessarily distinct).

Input Format 
The first line contains a single integer T, denoting the number of test cases. 
Each of the next T lines contains two positive integers, N & K, separated by a single space.  

Output Format 
For every test case, output "Yes" or "No" (without quotes).

Constraints 
1 
1 12 
1 12    

Sample Input

2
10 2
1 6


Sample Output

Yes
No


Explanation  

In the first case, 10 can be written as 5 + 5, and 5 is a prime number.
In the second case, 1 cannot be represented as a sum of prime numbers, because there are no prime numbers less than 1.
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

#define ll long long
#define ull unsigned ll

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}

/* 64?2????leading zero??? */
int ullNumberOfLeadingZerosTable[256]={8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
int ullNumberOfLeadingZeros(ull x){
  int res=56; unsigned xl=x, xh=x>>32;
  if(xh)             res -= 32, xl = xh;
  if(xl&0xffff0000U) res -= 16, xl >>= 16;
  if(xl&0x0000ff00U) res -= 8,  xl >>= 8;
  return res + ullNumberOfLeadingZerosTable[xl];
}

/* (x*y)%m ???? (?? x,y < m) */
ull ullMultipleMod(ull x, ull y, ull m){
  int k,loop=2;
  ull xlo,xhi,ylo,yhi,rlo,rhi,d1,d2,a,q,r,mask=0xffffffffULL;
  
  if(m<=mask) return (x*y)%m;
  
  xlo=(x&mask); xhi=(x>>32);
  ylo=(y&mask); yhi=(y>>32);
  rhi=xhi*yhi; rlo=xlo*ylo;
  a=(rlo>>32)+xhi*ylo;
  rhi+=(a>>32); a&=mask; a+=xlo*yhi; rhi+=(a>>32);
  rlo = (rlo&mask) | ((a&mask)<<32);
  
  k = ullNumberOfLeadingZeros(m);
  rhi = (rhi<<k)|(rlo>>(64-k));
  rlo<<=k; m<<=k;
  
  d1=(m>>32); d2=(m&mask);
  while(loop--){
    r = rhi/d1*d2;
    rhi = ( (rhi%d1 << 32) | (rlo>>32) );
    rlo = ( (rlo&mask) << 32 );
    if(rhi<r) rhi+=m-r; else rhi-=r;
    if(rhi>m) rhi+=m;
  }
  return rhi>>k;
}

/* (x^k)%m */
ull ullPowMod(ull x, ull k, ull m){
  ull res;
  if(k==0) return 1;
  res = ullPowMod(x,k/2,m);
  res = ullMultipleMod(res,res,m);
  if(k%2) res = ullMultipleMod(res,x,m);
  return res;
}

ull unsignedMillerRabinSuspectPow(int a, unsigned k, unsigned n){
  ull p=1; unsigned bit;
  for (bit=0x80000000U;bit;bit>>=1) {
    if(p>1)   p=(p*p)%n;
    if(k&bit) p=(p*a)%n;
  }
  return p;
}

int unsignedMillerRabinSuspect(int b, unsigned n){
  unsigned i,t=0,u=n-1; ull now, next;

  while(!(u&1)) t++, u>>=1;
  now = unsignedMillerRabinSuspectPow(b, u, n);

  for(i=1;i<=t;i++){
    next=(now*now)%n;
    if(next==1 && now!=1 && now!=n-1) return 0;
    now=next;
  }
  return next==1;
}

int unsignedMillerRabin(unsigned n){
  if(n<=1)return 0; if(n<=3)return 1; if(!(n&1))return 0;
  if(!unsignedMillerRabinSuspect(2,n)) return 0;
  if(n<=1000000){
    if(!unsignedMillerRabinSuspect(3,n)) return 0;
  } else {
    if(!unsignedMillerRabinSuspect(7,n)) return 0;
    if(!unsignedMillerRabinSuspect(61,n)) return 0;
  }
  return 1;
}

ull ullMillerRabinSuspectPow(ull a, ull k, ull n){
  ull p=1, bit;
  for (bit=0x8000000000000000ULL;bit;bit>>=1) {
    if(p>1)   p=ullMultipleMod(p,p,n);
    if(k&bit) p=ullMultipleMod(p,a,n);
  }
  return p;
}

int ullMillerRabinSuspect(ull b, ull n){
  ull i, t=0, u=n-1, now, next;

  while(!(u&1)) t++, u>>=1;
  now = ullMillerRabinSuspectPow(b, u, n);

  for(i=1;i<=t;i++){
    next=ullMultipleMod(now,now,n);
    if(next==1 && now!=1 && now!=n-1) return 0;
    now=next;
  }
  return now==1;
}

int ullMillerRabin(ull n){
  int i,lim;

  if(n<(1ULL<<32)) return unsignedMillerRabin(n);
  if(!(n&1)) return 0;
  
  if(n < 341550071728321ULL) lim=17; else lim=29;
  if(!ullMillerRabinSuspect(2,n)) return 0;
  for(i=3;i<=lim;i+=2) if(!ullMillerRabinSuspect(i,n)) return 0;

  return 1;
}


int solve(ll N, ll K, int r=0){
  if(N==0 && K==0) return 1;
  if(K==0) return 0;
  if(K==1){
    if(ullMillerRabin(N)) return 1;
    return 0;
  }
  if(N < 2*K) return 0;
  if(N%2==0 && N>=2*K) return 1;

  if(r==0){
    if(solve(N-2, K-1, 1)) return 1;
    if(solve(N-3, K-1, 1)) return 1;
  }
  return 0;
}

int main(){
  int i, j;
  int T;
  ll N, K;

  reader(&T);
  while(T--){
    reader(&N); reader(&K);
    if(solve(N,K)) writer("Yes\n"); else writer("No\n");
  }

  return 0;
}

----------
====================
----------
MATHEMATICS.80
hard
----------
PROBLEM STATEMENT:
An array of integers is called [expression]-coprime if the following conditions are both satisfied:


All the integers in the array are positive divisors of [expression].
Each pair of adjacent elements in the array is coprime (i.e., element [expression]).


Two arrays, [expression].

You are given [expression], and print it on a new line.      
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.81
medium
----------
PROBLEM STATEMENT:
Let there be a K-dimensional Hyperrectangle, where each dimension has a length of n1,n2,...nk. 
Each of the Hyperrectangle's unit cells is addressed at (i,j,k,...) and has a value which is equivalent to GCD(i,j,k,...) where 1 1 , 1 2 ....  

The goal is to sum all the GCD(i,j,k,...) cell values and print the result modulo 10^9 + 7. Note that indexing is from 1 to N and not 0 to N-1. 

Input Format 
The first line contains an integer T. T testcases follow. 
Each testcase contains 2 lines, the first line being K (K-dimension) and the second line contains K space separated integers indicating the size of each dimension - 
n1 n2 n3 ... nk

Output Format 
Print the sum of all the hyperrectangle cell's GCD values modulo 10^9 + 7 in each line corresponding to each test case. 

Constraints 
1 
2 
1 k 

Sample Input #00  

2
2
4 4
2
3 3


Sample Output #00 

24
12


Sample Input #01  

1
3
3 3 3


Sample Output #01

30


Explanation #00 
For the first test case, it's a 4X4 2-dimension Rectangle. The (i,j) address and GCD values of each element at (i,j) will look like  

1,1 1,2 1,3 1,4              1 1 1 1  
2,1 2,2 2,3 2,4  = GCD(i,j) 1 2 1 2  
3,1 3,2 3,3 3,4              1 1 3 1  
4,1 4,2 4,3 4,4              1 2 1 4  


Sum of these values is 24  

Explanation #00 
Similarly for 3X3 GCD (i,j) would look like 

1,1 1,2 1,3               1 1 1  
2,1 2,2 2,3  = GCD(i,j)  1 2 1  
3,1 3,2 3,3               1 1 3  


Sum is 12 

Explanation #01 
Here we have a 3-dimensional 3X3X3 Hyperrectangle or a cube. We can write it's GCD (i,j,k) values in 3 layers. 

1,1,1 1,1,2 1,1,3  |  2,1,1 2,1,2 2,1,3  |  3,1,1 3,1,2 3,1,3  
1,2,1 1,2,2 1,2,3  |  2,2,1 2,2,2 2,2,3  |  3,2,1 3,2,2 3,2,3  
1,3,1 1,3,2 1,3,3  |  2,3,1 2,3,2 2,3,3  |  3,3,1 3,3,2 3,3,3  
GCD (i,j,k)
1 1 1              |  1 1 1              |  1 1 1  
1 1 1              |  1 2 1              |  1 1 1  
1 1 1              |  1 1 1              |  1 1 3  


Total Sum = 30

Timelimits
Timelimits for this challenge is given here
----------
TOP SOLUTION:
----------
/******************************************************************************\
*                         Author:  Dumbear                                     *
*                         Email:   dumbear[#at]163.com                         *
*                         Website: http://dumbear.com                          *
\******************************************************************************/
#include <algorithm>
#include <bitset>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <typeinfo>
#include <utility>
#include <vector>

using namespace std;

typedef long long LL;
typedef vector<int> VI;
typedef vector<long long> VL;
typedef vector<double> VD;
typedef vector<string> VS;

const int mod = 1000000007;

int n, len[512], m;
LL f[100000 + 10];

void solve() {
    scanf("%d", &n);
    for (int i = 0; i < n; ++i)
        scanf("%d", &len[i]);
    for (int k = 1; ; ++k) {
        LL cnt = 1;
        for (int i = 0; i < n; ++i)
            cnt = (cnt * (len[i] / k)) % mod;
        if (cnt == 0)
            break;
        f[k] = cnt;
        m = k;
    }
    LL ans = 0;
    for (int k = m; k > 0; --k) {
        // cout << k << ' ' << f[k] << endl;
        for (int i = k + k; i <= m; i += k) {
            f[k] = (f[k] - f[i] + mod) % mod;
        }
        // cout << k << ' ' << f[k] << endl;
        ans = (ans + k * f[k]) % mod;
    }
    cout << ans << endl;
}

int main() {
    int t;
    scanf("%d", &t);
    for (int i = 0; i < t; ++i)
        solve();
    return 0;
}

----------
====================
----------
MATHEMATICS.82
expert
----------
PROBLEM STATEMENT:
Given two integers [expression] items?
----------
TOP SOLUTION:
----------
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstdlib>

#include <algorithm>
#include <deque>
#include <fstream>
#include <functional>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <set>
#include <unordered_map>
#include <unordered_set>
#include <vector>
using namespace std;
typedef vector<int> vi;
typedef set<int> si;
typedef pair<int,int> pii;
typedef vector<pii> vii;
typedef map<int,int> mii;
typedef long long ll;

#define all(s) (s).begin(), (s).end()
#define FOR(i,a,b) for(int i=(a);i<(b); i++)
#define REP(i,b) FOR(i,0,b)
#define FE(it,set) for(auto it = (set).begin(); it != (set).end(); ++it)
#define pb push_back

int partBalance(int n, int prime) {
	return n == 0 ? 0 : n/prime + partBalance(n/prime, prime);
}
int calcBalance(int n, int r, int prime) {
	return partBalance(n,prime) - partBalance(r, prime) - partBalance(n-r, prime);


}
int gcd(int a, int b) {
	return b ? gcd(b, a%b) : a;
}

ll mulMod(ll a, ll b, ll mod) {
	return a * b % mod;
}
ll expMod(ll n, ll p, ll mod) {
	assert(p >= 0);
	if(p <= 0) return 1;
	ll part = expMod(n * n % mod, p/2, mod);
	if(p % 2) part = (part * n) % mod;
	return part;
}

int calcInvPow(int mod, int p){
	static mii memo;
	int& prod = memo[mod];
	if(prod) return prod;
	prod = p - 1;
	assert(mod % p == 0);
	mod /= p;

	while(mod > 1) {
		assert(mod % p == 0);
		mod /= p;
		prod *= p;
	}
	prod--;
	return prod;
}

void addRange(vi & v, const int start, const int end, const int delta, const int P) {
	const int N = v.size();
	if(start > end) return;
	if(end == 0) return;
	REP(i,N) {
		const int x = start + i;
		if(x > end)break;

		const int inRange = (end - x) / N + 1;
		v[x % N] += delta * inRange;
	}
	addRange(v, (start + P - 1) / P , end / P, delta, P);

}

int multiplierWithoutPrime(int n, int i, int modulo, int prime) {
	const int P = calcInvPow(modulo, prime);
	int mul = n - i;
	while(mul % prime == 0) {
		mul /= prime;
	}
	int div = i + 1;
	//cout << mul << " / " <<  div << endl;
	while(div % prime == 0) {
		div /= prime;
	}
	//cout << "P=" << P << endl;
	ll invDiv = expMod(div, P, modulo);
	mul = mulMod(mul, invDiv, modulo);
	return mul;
}

int primeNCRMod(int n, int r, int prime) {
	r = min(r, n-r);
	if(r == 0) return 1;
	const int balance = calcBalance(n, r, prime);
	if(balance > 0) {
		return 0;
	}
	vi factorCount(prime);
	addRange(factorCount, 1, r, -1, prime);
	addRange(factorCount, n - r + 1, n, +1, prime);
	//for(int i: factorCount) cout << i << ' ';
	//cout << endl;

	int prod = 1;
	FOR(i,1,prime) {
		int p = factorCount[i];
		if(p == 0) continue;

		int base = i;
		if(p < 0) {
			base = expMod(base, prime - 2, prime);
			p = -p;
		}
		const int part = expMod(base, p, prime);
		//cout << base << " "  << p << " gives " << part << endl;
		prod = mulMod(prod, part, prime);
	}

	return prod;
}
int ncrModNew(int n, int r, int modulo, int prime) {
	//cout << "n="<<n<<" r="<<r<< " mod=" << modulo << endl;
	const int P = calcInvPow(modulo, prime);
	r = min(r, n-r);
	if(r == 0) return 1;
	const int balance = calcBalance(n, r, prime);
	const int factor = expMod(prime, balance, modulo);
	if(factor == 0) {
		return 0;
	}
	vi factorCount(modulo);
	addRange(factorCount, 1, r, -1, prime);
	addRange(factorCount, n - r + 1, n, +1, prime);
	//for(int i: factorCount) cout << i << ' ';
	//cout << endl;

	int prod = factor;
	FOR(i,0,modulo) {
		int p = factorCount[i];
		if(p == 0) continue;
		if(i % prime == 0)continue;

		int base = i;
		if(p < 0) {
			base = expMod(base, P, modulo);

			p = -p;
		}
		//cout << "P=" << P << endl;
		const int part = expMod(base, p, modulo);
		//cout << base << " "  << p << " gives " << part << endl;
		prod = mulMod(prod, part, modulo);
		//cout << "prod = " << prod << endl;
	}

	return prod;

}

int ncrMod(int n, int r, int modulo, int prime) {
	r = min(r, n - r);

	const int balance = calcBalance(n, r, prime);
	//cout << "balance = " << balance << endl;
	const int factor = expMod(prime, balance, modulo);
	if(factor == 0) {
		return 0;
	}
	ll prod = 1;

	for(int i=0;i<r; i++) {
		int mul = multiplierWithoutPrime(n, i, modulo, prime);
		//cout << n <<"," << i << " " << mul << endl;

		prod = mulMod(prod, mul, modulo);
	}
	//cout << "prod was / " << prod << endl;
	//cout << "factor is " << factor << endl;
	prod = mulMod(prod, factor, modulo);

	assert(prod == ncrModNew(n, r, modulo, prime));
	return prod;

}

int crt(int a, int b, int c, int d) {
	//cout << b << " to " << d << endl;
	assert(gcd(b,d) == 1);
	while(a % d != c) {
		a += b;
	}
	return a;
}

int solution(int n, int r) {
	static const vii parts = {pii(27, 3), pii(11,11), pii(13,13), pii(37,37)};
	//142857: 3 3 3 11 13 37
	int sol = 0, mod = 1;
	for(pii part: parts) {
		const int factor = part.first, prime = part.second;
		int partial;
		//cout << "mod " << factor << endl;
		if(factor != prime){
			partial = ncrModNew(n, r, factor, prime);
		} else {
			partial = primeNCRMod(n, r, prime);
		}
		//cout << "done" << endl;

		sol = crt(sol, mod, partial, factor);
		mod *= factor;
		assert(sol < mod);
	}
	return sol;
}
int main() {
	assert(primeNCRMod(10269,886, 11) == 7);
	/*while(true) {
		int a = rand() % 10000, b = rand() % 100;
		a += b;
		cout << a << " b=" << b << endl;
		cout << solution(a, b) << endl;
	}*/
	assert(solution(10269, 886) >= 0);
	assert(solution(5,2) == 10);
	assert(ncrMod(1,1,3,3) == 1);
	assert(ncrMod(2,1,3,3) == 2);
	assert(ncrMod(5,2,3,3) == 1);
	assert(ncrMod(20000,10000,37,37) == 18);
	assert(solution(200000,100000) == 0);
	assert(solution(2,1) == 2);
	assert(solution(9999,0) == 1);
	assert(solution(10,3) == 120);

	int t;
	cin >> t;
	REP(i,t) {
		int n,r;
		cin >> n >> r;
		//cout << n << " " << r << endl;
		cout << solution(n,r) << '\n';

	}

	return 0;
}

----------
====================
----------
MATHEMATICS.83
hard
----------
PROBLEM STATEMENT:
Chandrima likes the XOR operation very much and keeps finding and solving related problems. One day she comes across a problem and gets stuck on it, which makes her sad. You being her friend decide to help her out by writing a code for the same. 

Consider a list of all natural numbers. Now you remove all numbers whose binary representation has at least two consecutive [expression] numbers from this newly generated list. You have to find the XOR of these numbers.

Input Format 
The first line has an integer [expression]. 
The next line contains [expression].

Output Format 
Just print one line containing the final answer.  

Constraints 
[expression] 
[expression]

Sample Input 1  

3
1 2 3


Sample Output 1  

7


Sample Input 2  

3
1 3 4


Sample Output 2  

0


Explanation  

Sample 1: 
The values to be considered are [expression].

Sample 2: 
The values to be considered are [expression].
----------
TOP SOLUTION:
----------
#include<stdio.h>
#include<iostream>
#include<cmath>
#include<vector>
using namespace std;
#define ll long long int
ll Fibo[86]={2,3,5,8,13,21 ,34 ,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817
,39088169
,63245986
,102334155
,165580141
,267914296
,433494437
,701408733
,1134903170
,1836311903
,2971215073
,4807526976
,7778742049
,12586269025
,20365011074
,32951280099
,53316291173
,86267571272
,139583862445
,225851433717
,365435296162
,591286729879
,956722026041
,1548008755920
,2504730781961
,4052739537881
,6557470319842
,10610209857723
,17167680177565
,27777890035288
,44945570212853
,72723460248141
,117669030460994
,190392490709135
,308061521170129
,498454011879264
,806515533049393
,1304969544928657
,2111485077978050
,3416454622906707
,5527939700884757
,8944394323791464
,14472334024676221
,23416728348467685
,37889062373143906
,61305790721611591
,99194853094755497
,160500643816367088
,259695496911122585
,420196140727489673
,679891637638612258
,1100087778366101931};

#define MOD 1000000007
typedef struct
{
    ll a;
    ll b;
}Struct;
Struct Bsearch(ll x)
{
   ll a=0,b=85,mid;
   Struct s;
   while(a<=b)
   {
       mid=(a+b)/2;
       if(Fibo[mid]==x)
        {
            s.a=mid+1;
            s.b=Fibo[mid];
            return s;
        }
       else if((b-a)==1 && Fibo[a]<=x && Fibo[b]>=x)
        {
            if(Fibo[a]==x)
                {
                    s.a=a+1;
                    s.b=Fibo[a];
                    return s;
                }
            else if(Fibo[b]==x)
                {
                    s.a=b+1;
                    s.b=Fibo[b];
                    return s;
                }
            else {
                    s.a=a+1;
                    s.b=Fibo[a];
            return s;
            }
        }
       else if(Fibo[mid]>x)
        b=mid-1;
       else a=mid+1;
   }
   if(Fibo[a]>x)
    {
      s.a=a;
      s.b=Fibo[a-1];
      return s;
    }
   else {s.a=a+1;
   s.b=Fibo[a];
   return s;
   }
}
void update(ll A[],ll x)
{
    A[100-x]=(A[100-x]+1)%2;
}
ll pow(ll a,ll b,ll n)
{
    ll res=1;
    while (b)
{
    if (b % 2) { res = (res * a) % n; }

    a = (a * a) % n;
    b /= 2;
}

return res;
}
int main()
{
    ll i,a,b,T,n,x,ans=0;
    Struct s;
        ans=0;
        ll A[101]={};
        cin>>n;
        while(n--)
        {
            cin>>x;
            while(x>1)
            {
                s=Bsearch(x);
                x=x-s.b;
                update(A,s.a);
            }
            if(x==1)
                update(A,0);
        }
        for(i=100;i>=0;i--)
            if(A[i]!=0)
            ans=(ans+(ll)pow(2,100-i,MOD))%MOD;
        cout<<ans<<endl;
    return 0;
}
----------
====================
----------
MATHEMATICS.84
hard
----------
PROBLEM STATEMENT:
You are given a square grid of size N, with rows numbered from 0 to N - 1 starting from the top and columns numbered from 0 to N - 1 starting from the left.   

A cell (u, v) refers to the cell that is on the uth row and the vth column. Each cell contains an integer - 0 or 1. You can pick any cell and flip the number in all the cells (including the picked cell) within the Manhattan distance D from the picked cell. A flip here means changing the number from 0 to 1 and vice-versa. The manhattan distance from the cell (u, v) to the cell (x, y) is equal to [expression] is the absolute value of i.   

Your mission is to change all values in the grid to zero without using more than N×N flips.

Input Format 
The first line of the input contains two integers N and D  separated by a single space. 
Each line in the next N lines contains N integers separated by a single space which are either 0 or 1. the ith number on the jth line is the number on the cell (i - 1, j - 1) of the grid.

Constraints 
1 ≤  N ≤  20 
 0 ≤ D ≤ 40

Output Format 
If there is no solution, your output should contain exactly a single string "Impossible" (without quotes). If a solution exists, print out the string "Possible" (without quotes) in the first line of your output. In the second line, print out an integer M which represent the number of operations that you need. Each line in the next M lines should contain a pair of integers separated by a single space representing the cell that you picked for the corresponding operation. Note that if there is more than one solution you can pick any one of them.

Sample Input:#00

3 1
0 1 0
1 1 1
0 1 0


Sample Output:#00

Possible
1
1 1


Sample Input:#01

3 2
1 0 1 
1 1 0 
0 0 0 


Sample Output:#01

Impossible


Explanation

In the first testcase, we can perform the first operation in the center cell, this will flip all the elements to 0 within 1 manhattan distance. 
In the second testcase, we cannot make it an all 0 matrix under 9 moves. Hence, Impossible. 
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <bitset>
#include <cassert>
using namespace std;

typedef bitset<400> B;

int dot(const B& x, const B& y) {
    return ((x&y).count())%2;
}

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int R, C, D;
    cin >> R >> D;
    C=R;
    B final;
    for(int r=0; r<R; r++) for(int c=0; c<C; c++) {
        int x;
        cin >> x;
        if(x) final[r*C+c]=x;
    }
    //cout << final << endl;
    int N=R*C;
    vector<B> els(N);
    for(int r=0; r<R; r++) for(int c=0; c<C; c++) {
    for(int r2=0; r2<R; r2++) for(int c2=0; c2<C; c2++) if(abs(r-r2)+abs(c-c2)<=D) {
        els[r*C+c][r2*C+c2]=1;
    }
    }
    
    vector<bitset<400+1> > system(N);
    for(int i=0; i<N; i++) for(int j=0; j<N; j++) system[i][j]=els[j][i];
    for(int i=0; i<N; i++) system[i][N]=final[i];
    
    vector<int> pivots;
    int jj=0;
    for(int i=0; i<N; i++) {
        for(int j=jj; j<N; j++) if(system[j][i]) {
            if(jj!=j) swap(system[j],system[jj]);
            break;
        }
        if(!system[jj][i]) continue;
        pivots.push_back(i);
        for(int j=0; j<N; j++) if(jj!=j) if(system[j][i]) system[j]^=system[jj];
        jj++;
    }
    bool good=true;
    for(int j=jj; j<N; j++) if(system[j][N]) good=false;
    if(!good) cout << "Impossible\n";
    else {
        int cnt=0;
        for(int i=0; i<N; i++) if(system[i][N]) cnt++;
        cout << "Possible" << endl << cnt << endl;
        for(int i=0; i<N; i++) if(system[i][N]) cout << (pivots[i]/C) << " " << (pivots[i]%C) << endl;
    }

    return 0;
}

----------
====================
----------
MATHEMATICS.85
hard
----------
PROBLEM STATEMENT:
Fibonacci numbers have the following form: 
[expression]  

We have an array [expression] elements.   

We want to find [expression].  

Input Format 
The first line contains [expression] denotes size of the array. 
Each of the next [expression].

Output Format 
Print a single integer — the remainder of the division of the resulting number by [expression].  

Constraints 
[expression] 
[expression]  

Sample Input 1

3
2
3
5


Sample Output 1

1


Explanation 1 
[expression] 
[expression] 
[expression] 
[expression]  

Sample Input 2

2
3
6


Sample Output 2

2


Explanation 2 
[expression] 
[expression] 
[expression]  
----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
//#pragma comment(linker, "/STACK:100000000")
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cmath>
#include <string>
#include <cstring>
#include <set>
#include <stdio.h>
#include <vector>
#include <map>


#define ll long long
#define ld long double
#define f(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)
#define fn(i, b) for(int i=0; i<(int) (b); i++)
#define fz(i, a, b) for (int i=(int)(a); i>=(int)(b); --i)
#define mp make_pair
#define pii pair<int, int>
#define pb push_back
#define bg begin()
#define ed end()
#define pi 3.141592653589793238462643383279
#define sqr(A) A*A*1.0
ll gcd(ll a, ll b) {
	while (a && b) {
		if (a > b) a %= b; else b %= a;
	}
	return a + b;
}

ll lcm(ll a, ll b) { return (((a*b) / gcd(a, b))); }

int phi(int n){
	int result = n;
	for (int i = 2; i*i <= n; i++) {
		if (n % i == 0) {
			while (n % i == 0) n /= i;
			result -= result / i;
		}
	}
	if (n > 1) result -= result / n;
	return result;
}

int catalan(unsigned int n){
	int c[100];
	c[0] = c[1] = 1;
	f(i, 2, n) {
		f(k, 0, i)
			c[i] += c[k] * c[i - 1 - k];
	}
	return c[n];
}

#define MAX 1000100
#define INF 1000000007
#define eps 1e-9
#define ls (v << 1)
#define rs ((v << 1)+1)
using namespace std;
/*

int n;
int last = 0;
int a[10000];
int p = 0;
ll dp[1000][1000];

ll cnt(int pos, int last) {
	if (pos == 0) {
		//for (int j = 0; j < all; j++) cout << a[j];
		//cout << endl;
		p++;
		return 1;
		
	}
	if (dp[pos][last]) return dp[pos][last];
	ll x = 0;
	for (int i = last; i <= 9; i++) {
		a[pos] = i;
		x += cnt(pos - 1, i);
	}
	return dp[pos][last]=x;
}
int R[100];
int kk = 0;

void get(int pos, int last, int len, int numb){
	if (pos == len) {
		//kk++;
		if (kk == numb) {
			for (int j = 0; j < len; j++) cout << R[j];
			cout << endl;
//			system("pause");
			exit(0);
		}
		return;
	}

	//if (cnt(len - pos, last) < numb && pos>len/2) return;
	for (int i = last; i <= 9; ++i) {
		R[pos] = i;
		//kk++;
		int s = cnt(len - pos-1, i);
		get(pos + 1, i, len, numb);
	}
}
*/
#define vll vector<ll>
#define vpii vector<pii>
#define vvll vector<vll > 

vvll a;

vvll mul(vvll a, vvll b)
{
	vvll c;
	c.resize(2);
	for (int i = 0; i < 2; ++i) c[i].assign(2, 0);

	for (int p = 0; p < 2; ++p)
	for (int i = 0; i < 2; ++i)
	for (int j = 0; j < 2; ++j)
		c[i][j] = (c[i][j] + a[i][p] * b[p][j]) % INF;
	return c;
}

vvll power(vvll a, ll y)
{
	if (y == 1) return a;
	if (y % 2) return mul(a, power(a, y - 1));
	vvll x = power(a, y / 2);
	return mul(x, x);
}
ll b[MAX];
int n;

int main()
{
	//freopen("input.txt", "r", stdin); freopen("output.txt", "w", stdout);
	
	cin >> n;
	fn(i, n) scanf("%lld", b + i);
	ll g = b[0];
	for (int i = 1; i < n; i++) g = gcd(g, b[i]);
	a.resize(3);
	a[0].resize(2);

	a[1].resize(2);
	a[0][0] = a[0][1] = a[1][0] = 1;
	a[1][1] = 0;
	if (g>1) a = power(a, g - 1);
	ll ans = a[0][0];
	ans = (ans % INF);
	cout << ans << endl;

	

	return 0;
}
----------
====================
----------
MATHEMATICS.86
medium
----------
PROBLEM STATEMENT:
Ichigo is on his way to save Rukia. Unfortunately, when Ichigo was busy fighting Renji, Kenpachi Zaraki had gone to the Dangai(the same place where Ichigo got his final Getsuga Tenshou) to train. Now, he has a Bankai called Tensa Quantum Computer and he used it against Ichigo!

Tensa Quantum Computer consists of 2N rooms arranged in a circle. Kenpachi imprisoned Rukia in one of these rooms. The rooms have the numbers 1, 2, ..., N-1, N, -N, -(N-1), ..., -1 written on them in that order clockwise. Each room has a one-way door to another unique room. Kenpachi knows that if a room has number X, then it leads to another room which is at distance abs(X) from this room. More precisely, if X is positive, it means that this room leads to the X-th room in the clockwise direction from the current room. And if X is negative, then that means that this room leads to the (-X)-th room in the anticlockwise direction from the current room.

Kenpachi knows that Ichigo starts at the room with the number A. Being a determined guy, Ichigo doesn't sit still until he finds Rukia. Instead he keeps running to the next room for as long as he can. But Kenpachi's funny and crafty lieutenant Yachiru Kusajishi suggested that if Kenpachi keeps Rukia in one of the rooms that Ichigo will never visit, then Ichigo will keep running forever and die from exhaustion.

Now, Kenpachi wants to know the number of rooms that he can keep Rukia in, so that poor Ichigo never finds her and hence, keeps running.

Note: abs(X) is the absolute value of X.

Input Format

Line 1: T 
T - Number of test cases. 
Lines 2 to T+1: N A 
N - Half the total number of rooms. 
A - The number of the room where Ichigo starts his pursuit of Rukia.  

Output Format

For each test case, print a single integer in a new line that is the number of rooms where Kenpachi can imprison Rukia so that Ichigo never finds her.

Constraints

1 
1 9 
1 

Sample Input

4
1 1
4 1
4 -3
1729 -786


Sample Output

0
2
6
3170


Explanation

In the first test case, the rooms that Ichigo visits have numbers 1, -1, 1, -1, ... in that order. So, there are no unvisited rooms. 

In the second test case, the rooms that Ichigo visits have numbers 1, 2, 4, -1, -2, -4, 1, 2, ... in that order. So, there are two unvisited rooms namely the ones numbered 3 and -3. 

In the third test case, the rooms that Ichigo visits have numbers -3, 3, -3, 3, ... in that order. So, there are six unvisited rooms namely the ones numbered 1, 2, 4, -4, -2, -1.
----------
TOP SOLUTION:
----------
#include <cassert>
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;

typedef long long ll;

vector<int> PrimeFactors(int n) {
	vector<int> r;
	for (int p = 2; n / p >= p; p = p == 2 ? 3 : p + 2) {
		if (n % p == 0) {
			r.push_back(p);
			while (n % p == 0) n /= p;
		}
	}
	if (n > 1) r.push_back(n);
	return r;
}

bool Okay(int N, int A, int pow) {
	ll r = 1, u = 2;
	for (int i = 0; pow >> i; ++i) {
		if (pow >> i & 1) r = r * u % N;
		u = u * u % N;
	}
	return A * r % N == A;
}

int Solve(int N, int A) {
	N = N * 2 + 1;
	if (A < 0) A += N;
	// Find k s.t. A * 2**k == A (mod N).
	auto pf = PrimeFactors(N);
	vector<int> all_pf = pf, tmp;
	int phi = N;
	for (int p : pf) {
		phi = phi / p * (p - 1);
		tmp = PrimeFactors(p - 1);
		all_pf.insert(all_pf.end(), tmp.begin(), tmp.end());
	}
	if (!Okay(N, A, phi)) {
		cerr << "Weird: " << N << ' ' << A << ' ' << phi << endl;
	}
	sort(all_pf.begin(), all_pf.end());
	all_pf.erase(unique(all_pf.begin(), all_pf.end()), all_pf.end());
	int ans = phi;
	for (int p : all_pf) {
		while (ans % p == 0 && Okay(N, A, ans / p)) ans /= p;
	}
	return N - 1 - ans;
}

int main() {
	cin.sync_with_stdio(false);
	cout.sync_with_stdio(false);
	int T;
	for (cin >> T; T--;) {
		int N, A;
		cin >> N >> A;
		cout << Solve(N, A) << endl;
	}
}

----------
====================
----------
MATHEMATICS.87
hard
----------
PROBLEM STATEMENT:
Charlie and Johnny play a game. For every integer [expression]) contains only 4s and 0s and starts with one or more 4s followed by zero or more 0s. For example, 404 is an invalid number but 4400, 440, and 444 are valid numbers. 

If [expression]?  

Input Format  

The first line of input contains a single integer [expression], the number of test cases.  

[expression] as stated above.

Output Format  

For every [expression] in a newline as stated in the problem statement.  

Constraints  

[expression] 
[expression]  

Sample Input  

3
4
5
80


Sample Output  

2
3
4


Explanation  

For the 1st test case, the smallest such multiple of [expression].  

For the 2nd test case, [expression] respectively.
----------
TOP SOLUTION:
----------
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
long long mul(long long x,long long y,long long mod){
    if(x<((long long)1e18/y))return x*y%mod;
    long long res=0;
    while(y){
        if(y&1){
            res=res+x;
            if(res>=mod)res-=mod;
        }
        x=x+x;
        if(x>mod)x-=mod;
        y>>=1;
    }
    return res;
}
long long mypow(long long x,long long y,long long mod){
    long long res=1;
    x%=mod;
    while(y){
        if(y&1){
            res=mul(res,x,mod);
            if(res%mod!=res){
                res%=mod;
            }
        }
        x=mul(x,x,mod);
        if(x%mod!=x){
            x%=mod;
        }
        y>>=1;
    }
    return res;
}
long long shyuewen(long long fac,long long mod){
    long long mi=fac;
    for(long long i=1;i*i<=fac;i++){
        if(fac%i)continue;
        if(mypow(10,i,mod)==1)return i;
        else if(mypow(10,fac/i,mod)==1)mi=fac/i;
    }
    return mi;
}
int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        long long X;
        scanf("%lld",&X);
        int two=0;
        int five=0;
        while(!(X&1)){
            X>>=1;
            two++;
        }
        while(X%5==0){
            X/=5;
            five++;
        }
        long long gg=1;
        while(X%3==0){
            gg*=3;
            X/=3;
        }
        for(long long i=7;i*i<=X;i++){
            if(X%i==0){
                long long tmp=i-1;
                long long pp=i;
                X/=i;
                while(X%i==0){
                    X/=i;
                    tmp*=i;
                    pp*=i;
                }
                tmp=shyuewen(tmp,pp);
                long long ggg=__gcd(gg,tmp);
                gg=gg/ggg*tmp;
            }
        }
        if(X!=1){
            long long tmp=shyuewen(X-1,X);
            long long ggg=__gcd(gg,tmp);
            gg=gg/ggg*tmp;
        }
        printf("%lld\n",gg*2+max(five,two-2));
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.88
hard
----------
PROBLEM STATEMENT:
After Derek (of district 5) discovered how to compute the greatest common divisor (gcd) of Fibonacci numbers, he now tried to answer the next obvious question: how does one compute the least common multiple (lcm) of Fibonacci numbers? Unfortunately, Derek found out that this wasn't as easy as the original problem, so he asked you to answer it for him.

The Fibonacci numbers are defined as:

[expression]
[expression]

Given [expression].

Input Format 
The first line of input contains [expression]. 
Each of the next [expression].

Constraints 
[expression] 
[expression]  

Output Format 
Print a single integer, which is the least common multiple of the [expression].

Sample Input  

5
1
3
3
6
9


Sample Output  

136


Explanation 
[expression]  
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <map>
using namespace std;

map<int,int> M;
vector<pair<int,int> > rec;

const int mod = 1000000007;
const int mod2 = 1000000006;

long long ans;

struct matrix{
    long long M[3][3];
    inline long long* operator [](const int dn){
        return M[dn];
    }
}A,B,C,D,E;

inline void mul(matrix &X,matrix &Y){
    for(int i=0;i<2;++i) for(int j=0;j<2;++j) for(int k=0;k<2;++k){
        C[i][j]+=X[i][k]*Y[k][j];
        if(C[i][j]>=mod) C[i][j]%=mod;
    }
    for(int i=0;i<2;++i) for(int j=0;j<2;++j) X[i][j]=C[i][j],C[i][j]=0;
}

long long Pow(long long a,long long b){
    long long ret=1;
    while(b){
        if(b&1){
            if(mod<=(ret*=a)){
                ret%=mod;
            }
        }
        if(mod<=(a*=a)){
            a%=mod;
        }
        b>>=1;
    }
    return ret;
}

long long getFib(int n){
    --n;
    A=E,B=D;
    while(n){
        if(n&1) mul(A,B);
        n>>=1;
        mul(B,B);
    }
    return (A[0][0]+A[0][1])%mod;
}

int n,a;

int Gcd(int x,int y){
    int z;
    if(!y) return x;
    while(z=x%y) x=y,y=z;
    return y;
}

void Add(int &x,const int &y){
    if(mod2<=(x+=y)) x-=mod2;
}

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    E[0][0]=E[1][1]=1;
    D[1][1]=D[0][1]=D[1][0]=1;
    scanf("%d",&n);
    while(n--){
        rec.clear();
        scanf("%d",&a);
        rec.push_back(make_pair(a,1));
        for(map<int,int>::iterator iter=M.begin();iter!=M.end();++iter) if(iter->second){
            rec.push_back(make_pair(Gcd(iter->first,a),mod2-iter->second));
        }
        for(int i=0;i<int(rec.size());++i){
            int x=rec[i].first,y=rec[i].second;
            Add(M[x],y);
        }
    }
    ans=1;
    for(map<int,int>::iterator iter=M.begin();iter!=M.end();++iter) if(iter->second){
        ans*=Pow(getFib(iter->first),iter->second);
        if(ans>=mod) ans%=mod;
    }
    printf("%d\n",(int)ans);
    return 0;
}

----------
====================
----------
MATHEMATICS.89
hard
----------
PROBLEM STATEMENT:
Given [expression] unfriendly numbers, determine how many numbers are divisors of the friendly number but not the unfriendly numbers.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <algorithm>
using namespace std;

typedef unsigned long long ULL;

void factor(int N, map<int, int>& res)
{
    unsigned i = 2;
    for (; i * i <= N; ++i)
    {
        if (N % i == 0)
        {
            res[i]++;
            return factor(N / i, res);
        }
    }
    if (i * i > N) res[N]++;
}

// recursively visit all multiples of curr, use a set to avoid duplication
int check(int curr, int K, map<int, int>& fac, vector<ULL>& unf, set<int>& visited)
{
    int result = 0;
    if (curr > K) return 0;
    if (visited.count(curr)) return result;
    visited.insert(curr);

    if (K % curr == 0)
    {
        result++;
        for (unsigned i = 0; i < unf.size(); ++i)
            if (unf[i] % curr == 0)
        {
            result--;
            break;
        }
        for (map<int,int>::iterator i = fac.begin(); i != fac.end(); ++i)
        {
            result += check(curr * i->first, K, fac, unf, visited);
        }
    }
    return result;
}

// factor to get tuple. 
// exclude some ranges
int main()
{
    int N, K;
    cin >> N >> K;
    vector<ULL> unf;

    ULL u;
    for (unsigned i = 0; i < N; ++i)
    {
        // read
        cin >> u;
        unf.push_back(u);
    }
    // enumerate all factors of K, and check against all unf?
    map<int, int> fac;
    set<int> vis;
    factor(K, fac);
    cout << check(1, K, fac, unf, vis);
    return 0;
}

----------
====================
----------
MATHEMATICS.90
expert
----------
PROBLEM STATEMENT:
A Hackerrank number is a magic number that can be used to get sudo permissions on the site. We are going to generate a hackerrank number from two integers A & B. Each number has two parts to it - the left (L) & the right side (R).  

For eg: for the number 100101, 


L could be 100 & R could be 101 (or) 
L could be 1 and R could be 00101 and so on.. 


How to generate a hackerrank number?

Let x & y be integers such that,

(1 <= x <= A & 1 <= y <= B) 


Generate the left part of any hackerrank number (L) by multiplying x and y (i.e) x*y 
and the right part of any hackerrank number (R) by bitwise xor-ing x and y (i.e) x^y

Add leading zeros to R to make length(R) = length(B) + 1. Concatenate both L & R to form the hackerrank number.

Can you find the sum of all possible hackerrank numbers generated by this rule?

Input format

Each input contains 2 integers A and B separated by a space. 

Constraints

1 
1 8

Output format

Print the sum of all possible numbers that satisfy the above mentioned property. 

Sample Input

2 4


Sample Output

14502


The left value can be one of  {1 * 1, 1 * 2, 1 * 3, 1 * 4, 2 * 1, 2 * 2, 2 * 3, 2 * 4} 
which is {1,2,3,4,2,4,6,8} 
and the distinct values are {1, 2, 3, 4, 6, 8}

The right value can be one of {1^1,1^2,1^3,1^4,2^1,2^2,2^3,2^4} 
which is {0, 3, 2, 5, 3, 0, 1, 6} 
and the distinct values are {0, 1, 2, 3, 5, 6} 

All the possible value are

{
    100, 101, 102, 103, 105, 106,
    200, 201, 202, 203, 205, 206,
    300, 301, 302, 303, 305, 306,
    400, 401, 402, 403, 405, 406,
    600, 601, 602, 603, 605, 606,
    800, 801, 802, 803, 805, 806 
}


S = all the sum of the above = 14502.

Note: Any number can only be added once. 
----------
TOP SOLUTION:
----------
// https://www.hackerrank.com/challenges/hackerrank-number




#include <cassert>
#include <cstddef>
#include <cstdint>
#include <vector>
#include <utility>

using TFactorization = std::vector<std::pair<uint64_t, unsigned>>;
#include <algorithm>

class PrimesList
{
protected:
    uint64_t table_size, squared_table_size;
    std::vector<uint64_t> primes, squared_primes;
    std::vector<unsigned> table;

public:
    PrimesList(uint64_t size)
    {
        table_size = size;
        squared_table_size = table_size * table_size;
        table.resize(table_size + 1, 0);
        table[0] = table[1] = 1;
        primes.push_back(2);
        for (uint64_t i = 2; i <= table_size; i += 2)
            table[i] = 2;
        for (uint64_t i = 3; i <= table_size; i += 2)
        {
            if (!table[i])
            {
                primes.push_back(i);
                table[i] = unsigned(i);
                for (uint64_t j = i * i; j <= table_size; j += 2 * i)
                {
                    if (table[j] == 0)
                        table[j] = unsigned(i);
                }
            }
        }
        squared_primes.reserve(primes.size());
        for (uint64_t p : primes)
            squared_primes.push_back(p * p);
    }

    const std::vector<uint64_t>& GetPrimes() const { return primes; }
    const std::vector<uint64_t>& GetSquaredPrimes() const { return squared_primes; }
    uint64_t GetTableSize() const { return table_size; }
    uint64_t GetSquaredTableSize() const { return squared_table_size; }
    const std::vector<unsigned>& GetTable() const { return table; }

    bool IsPrime(uint64_t n)
    {
        assert(n <= squared_table_size);
        if (n <= table_size) return (n > 1) && (table[n] == n);
        for (size_t i = 0; squared_primes[i] <= n; ++i)
        {
            if ((n % primes[i]) == 0) return false;
        }
        return true;
    }

    TFactorization FactorizeTable(uint64_t n) const
    {
        assert(n <= table_size);
        TFactorization output;
        for (; n > 1; )
        {
            unsigned p = table[n], cnt = 1;
            for (n /= p; table[n] == p; ++cnt) n /= p;
            output.push_back(std::make_pair(uint64_t(p), cnt));
        }
        return output;
    }

    TFactorization Factorize(uint64_t n, bool skip_assert = false) const
    {
        if (n <= table_size) return FactorizeTable(n);
        TFactorization output;
        for (uint64_t p : primes)
        {
            if (n < p * p) break;
            if ((n % p) == 0)
            {
                n /= p;
                unsigned cnt = 1;
                for (; (n % p) == 0; ++cnt) n /= p;
                output.push_back(std::make_pair(p, cnt));
            }
        }
        if (!skip_assert)
            assert(squared_table_size > n);
        if (n != 1)
            output.push_back(std::make_pair(n, 1));
        return output;
    }
};


// Return count of coprime to k numbers in the interval [1..n].
inline uint64_t CoprimeCount(const TFactorization& k_factorization, uint64_t n)
{
    if (n <= 1) return n;
    if (k_factorization.size() == 0) return n;
    unsigned fs = unsigned(k_factorization.size()), p2 = 1u << fs;
    uint64_t total = 0;
    for (unsigned i = 0; i < p2; ++i)
    {
        uint64_t t = n;
        unsigned bits = 0;
        for (unsigned j = 0; j < fs; ++j)
        {
            if ((1u << j) & i)
            {
                ++bits;
                t /= k_factorization[j].first;
            }
        }
        total = ((bits & 1) ? total - t : total + t);
    }
    return total;
}


// Return sum of coprime to k numbers in the interval [1..n].
inline uint64_t CoprimeSum(const TFactorization& k_factorization, uint64_t n)
{
    if (n <= 1) return n;
    if (k_factorization.size() == 0) return (n*(n+1)) / 2;
    unsigned fs = unsigned(k_factorization.size()), p2 = 1u << fs;
    uint64_t total = 0;
    for (unsigned i = 0; i < p2; ++i)
    {
        uint64_t tn = n, tm = 1;
        unsigned bits = 0;
        for (unsigned j = 0; j < fs; ++j)
        {
            if ((1u << j) & i)
            {
                ++bits;
                tn /= k_factorization[j].first;
                tm *= k_factorization[j].first;
            }
        }
        uint64_t t = tm * ((tn * (tn + 1)) / 2);
        total = ((bits & 1) ? total - t : total + t);
    }
    return total;
}


inline unsigned GetDivisorsCount(const TFactorization& factorization)
{
    unsigned k = 1;
    for (auto p : factorization)
        k *= (p.second + 1);
    return k;
}

inline void GetDivisorsI(const TFactorization& factorization, unsigned fpi, uint64_t current, std::vector<uint64_t>& output)
{
    if (fpi < factorization.size())
    {
        for (unsigned i = 0; i <= factorization[fpi].second; ++i)
        {
            GetDivisorsI(factorization, fpi + 1, current, output);
            current *= factorization[fpi].first;
        }
    }
    else
        output.push_back(current);
}

inline std::vector<uint64_t> GetDivisors(const TFactorization& factorization)
{
    std::vector<uint64_t> v;
    GetDivisorsI(factorization, 0, 1, v);
    return v;
}

#include <iostream>
#include <string>

class LongUnsigned
{
protected:
    std::vector<unsigned> data;

public:
    using iterator = unsigned*;
    using const_iterator = const unsigned*;

    LongUnsigned() {}
    LongUnsigned(unsigned u) { if (u) data.push_back(u); }
    LongUnsigned(uint64_t u)
    {
        data.push_back(unsigned(u));
        data.push_back(unsigned(u >> 32));
        Normalize();
    }

    void Normalize() { for (; (data.size() > 0) && (data.back() == 0);) data.pop_back(); }
    bool Empty() const { return data.empty(); }
    size_t Size() const { return data.size(); }

    iterator begin() { return &data.front(); }
    const_iterator begin() const { return &data.front(); }
    iterator end() { return begin() + data.size(); }
    const_iterator end() const { return begin() + data.size(); }
    void swap(LongUnsigned& lu) { data.swap(lu.data); }

    bool operator==(const LongUnsigned& lu) const { return data == lu.data; }
    bool operator!=(const LongUnsigned& lu) const { return data != lu.data; }

    bool operator<(const LongUnsigned& lu) const
    {
        if (Size() < lu.Size()) return true;
        if (lu.Size() < Size()) return false;
        for (size_t i = Size(); i; )
        {
            --i;
            if (data[i] < lu.data[i]) return true;
            if (data[i] > lu.data[i]) return false;
        }
        return false;
    }

    bool operator<=(const LongUnsigned& lu) const
    {
        if (Size() < lu.Size()) return true;
        if (lu.Size() < Size()) return false;
        for (size_t i = Size(); i; )
        {
            --i;
            if (data[i] < lu.data[i]) return true;
            if (data[i] > lu.data[i]) return false;
        }
        return true;
    }

    bool operator>(const LongUnsigned& lu) const { return !(lu <= (*this)); }
    bool operator>=(const LongUnsigned& lu) const { return !(lu < (*this)); }

    LongUnsigned operator+(unsigned u) const
    {
        if (u == 0) return (*this);
        LongUnsigned lu;
        lu.data.reserve(data.size());
        uint64_t t64 = u;
        for (unsigned ud : data)
        {
            t64 += ud;
            lu.data.push_back(unsigned(t64));
            t64 >>= 32;
        }
        if (t64)
            lu.data.push_back(unsigned(t64));
        return lu;
    }

    LongUnsigned operator*(unsigned u) const
    {
        if (u == 0) return LongUnsigned();
        LongUnsigned lu;
        lu.data.reserve(data.size() + 1);
        uint64_t u64 = u, t64 = 0;
        for (unsigned ud : data)
        {
            t64 += u64 * ud;
            lu.data.push_back(unsigned(t64));
            t64 >>= 32;
        }
        if (t64)
            lu.data.push_back(unsigned(t64));
        return lu;
    }

    LongUnsigned operator/(unsigned u) const
    {
        assert(u);
        if (data.empty()) return LongUnsigned();
        LongUnsigned lu;
        lu.data.reserve(data.size());
        uint64_t u64 = u, t64 = data.back();
        if (t64 >= u64)
        {
            lu.data.push_back(unsigned(t64 / u64));
            t64 %= u64;
        }
        for (auto p = end() - 2, pb = begin(); p >= pb;)
        {
            t64 = ((t64 << 32) + *p--);
            lu.data.push_back(unsigned(t64 / u64));
            t64 %= u64;
        }
        if (lu.Size() > 1) std::reverse(lu.begin(), lu.end());
        return lu;
    }

    unsigned operator%(unsigned u) const
    {
        assert(u);
        if (data.empty()) return 0;
        if ((u & (u - 1)) == 0) return (data[0] % u);
        uint64_t u64 = u, t64 = data.back() % u64;
        for (auto p = end() - 2, pb = begin(); p >= pb;)
            t64 = ((t64 << 32) + *p--) % u64;
        return unsigned(t64);
    }

    LongUnsigned operator+(const LongUnsigned& r) const
    {
        if (Empty()) return r;
        if (r.Empty()) return *this;
        LongUnsigned lu;
        size_t l = std::max(data.size(), r.data.size());
        lu.data.reserve(l);
        uint64_t t64 = 0;
        for (unsigned i = 0; i < l; ++i)
        {
            t64 += (i < data.size()) ? data[i] : 0;
            t64 += (i < r.data.size()) ? r.data[i] : 0;
            lu.data.push_back(unsigned(t64));
            t64 >>= 32;
        }
        if (t64)
            lu.data.push_back(unsigned(t64));
        return lu;
    }

    LongUnsigned operator-(const LongUnsigned& r) const
    {
        if (r.Empty()) return *this;
        assert(r <= *this);
        LongUnsigned lu;
        size_t l = data.size();
        lu.data.reserve(l);
        int64_t i64 = 0;
        for (unsigned i = 0; i < l; ++i)
        {
            i64 += int64_t(data[i]);
            i64 -= (i < r.data.size()) ? int64_t(r.data[i]) : 0;
            lu.data.push_back(unsigned(i64));
            i64 >>= 32;
        }
        assert(!i64);
        lu.Normalize();
        return lu;
    }

    LongUnsigned& operator+=(unsigned u) { LongUnsigned t = (*this + u); swap(t); return *this; }
    LongUnsigned& operator*=(unsigned u) { LongUnsigned t = (*this * u); swap(t); return *this; }
    LongUnsigned& operator/=(unsigned u) { LongUnsigned t = (*this / u); swap(t); return *this; }
    LongUnsigned& operator+=(const LongUnsigned& r) { LongUnsigned t = (*this + r); swap(t); return *this; }
    LongUnsigned& operator-=(const LongUnsigned& r) { LongUnsigned t = (*this - r); swap(t); return *this; }

    static LongUnsigned Parse(const std::string& s, unsigned base = 10)
    {
        assert(base == 10);
        LongUnsigned lu;
        for (char c : s)
        {
            lu *= base;
            assert((c >= '0') && (c <= '9'));
            lu += unsigned(c - '0');
        }
        return lu;
    }

    static LongUnsigned Read(unsigned base = 10)
    {
        std::string s;
        std::cin >> s;
        return Parse(s, base);
    }

    std::vector<unsigned> ToVector(unsigned base) const
    {
        LongUnsigned t(*this);
        std::vector<unsigned> v;
        for (; !t.Empty(); t /= base)
            v.push_back(t % base);
        return v;
    }

    std::string ToString(unsigned base = 10) const
    {
        if (Empty()) return "0";
        assert(base == 10);
        std::vector<unsigned> v = ToVector(base);
        std::reverse(v.begin(), v.end());
        std::string s; s.reserve(v.size());
        for (unsigned u : v)
            s.push_back('0' + char(u));
        return s;
    }

    void Write(bool add_eod = true, unsigned base = 10) const
    {
        std::string s = ToString(base);
        std::cout << s;
        if (add_eod) std::cout << std::endl;
    }
};

template<class T>
inline T GCD(T x, T y)
{
    for (; y; )
    {
        T z = x % y;
        x = y;
        y = z;
    }
    return x;
}


using namespace std;

int main()
{
    uint64_t a, b;
    cin >> a >> b;
    uint64_t raw_b = b;
    if (a > b) swap(a, b);
    PrimesList primes_list(a);
    // L
    uint64_t cL = 0, sL = 0;
    TFactorization f;
    for (uint64_t p : primes_list.GetPrimes())
    {
        uint64_t t = a / p, c = 0;
        for (; t ; t /= p) c += 1;
        f.push_back({p, unsigned(c)});
    }
    vector<uint64_t> vd = GetDivisors(f);
    sort(vd.begin(), vd.end());
    uint64_t fd = vd.back();
    for (uint64_t c : vd)
    {
        uint64_t la = 1;
        for (uint64_t ia = 2; ia <= a; ++ia)
        {
            if ((c % ia) == 0)
                la = ia;
        }
        uint64_t cb = b / (c / la), fdc = fd / c;
        TFactorization ff = primes_list.Factorize(fdc);
        cL += CoprimeCount(ff, cb);
        sL += c * CoprimeSum(ff, cb);
    }
    // cout << cL << "\t" << sL << endl;
    // R
    uint64_t maxaxb = 0;
    for (unsigned i = 30; i--; )
    {
        uint64_t bit = (1ull << i);
        if ((a | b) & bit)
        {
            maxaxb |= bit;
            if (a & b & bit)
            {
                maxaxb += (bit - 1);
                break;
            }
        }
    }
    uint64_t cR = maxaxb + 1, sR = (maxaxb * (maxaxb + 1)) / 2;
    if (a == 1)
    {
        cR -= 1; sR -= a; // a is not possible
        if ((b & 1) == 0)
        {
            cR -= 1; sR -= b; // b is not possible
        }
    }
    else
    {
        if ((b ^ (b - 1)) / 2 >= a)
        {
            cR -= 1; sR -= b; // b is not possible
        }
    }
    // cout << cR << "\t" << sR << endl;
    // Final
    uint64_t lb = 1, pb = 10;
    for (; raw_b >= pb; pb *= 10) ++lb;
    LongUnsigned r1 = LongUnsigned(sL) * cR * pb * 10;
    LongUnsigned r2 = LongUnsigned(sR) * cL;
    (r1 + r2).Write();
    return 0;
}

----------
====================
----------
MATHEMATICS.91
medium
----------
PROBLEM STATEMENT:
You are currently studying the language [expression] ( which means strange in English ) from a renowned professor. The language has infinite number of letters in its alphabet ( now you know, why it is called ajob ).  

The professor taught you [expression] letters.  

All the letters within a word are distinct to each other.

Now, you are handed an assignment. You have to choose any one of the [expression], then you must not choose that word. Two subsequences are different to each other if, the lengths of them are different or they contain different characters in the same position.

Find the number of ways you can complete the assignment [expression] ).  

1. 
The first line contains [expression].  

Output Format 
For each testcase, print one integer in a single line, the number possible ways you can complete the assignment, [expression].

Constraints 
[expression] 
[expression] 
[expression] 
[expression] 
[expression]  

Sample Input #00  

3
2 1 2
2 1 5
5 3 13


Sample Output #00  

1
3
2


Sample Input #01  

5
5 2 3
6 5 11
7 6 3
6 5 7
6 5 5


Sample Output #01  

2
7
2
0
2

----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>

using namespace std;

#define long long long
#define M 100100

long bin(long x, long a, long mod) {
    long y = 1;
    while (a) {
        if (a & 1)
            y *= x, y %= mod;
        x *= x, x %= mod;
        a >>= 1;
    }
    return y;
}

long f[M];

void pre(long p) {
    f[0] = 1;
    for (int i = 1; i < p; ++i)
        f[i] = (f[i - 1] * i) % p;
}

void fact(long n, long p, long &rem, long &pow) {
    pow = 0;
    rem = 1;

    while (n) {
        rem = (rem * f[n % p]) % p;
        if ((n / p) % 2 == 1)
            rem = -rem;

        pow += (n / p);
        n /= p;
    }

    if (rem < 0)
        rem += p;
}

long cnk(long n, long k, long p) {
    long rn, pn, rk, pk, r2, p2;
    fact(n, p, rn, pn);
    fact(k, p, rk, pk);
    fact(n - k, p, r2, p2);
    if (pn > p2 + pk)
        return 0;
    rn = (rn * bin(rk, p - 2, p)) % p;
    rn = (rn * bin(r2, p - 2, p)) % p;
    return rn;
}

int main(){
#ifdef TROLL
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#else
    ios_base::sync_with_stdio(0);
#endif

    long n, k, p, t;

    cin >> t;

    while (t--) {
        cin >> n >> k >> p;
        pre(p);
        cout << cnk(n + 1, k + 1, p) << "\n";
    }

    return 0;
}
----------
====================
----------
MATHEMATICS.92
hard
----------
PROBLEM STATEMENT:
This time your assignment is really simple.

Calculate GCD(1, 1) * GCD(1, 2) * ... * GCD(1, M) * GCD(2, 1) * GCD(2, 2) * ... * GCD(2, M) * ... * GCD(N, 1) * GCD(N, 2) * ... * GCD(N, M).

where GCD is defined as the Greatest Common Divisor. 

Input Format

The first and only line contains two space separated integers N and M.

Output Format

Output the required product modulo 109+7.

Constraints

1 N, M 7

Sample input:

4 4

Sample output:

96

Explanation

For the above testcase, N = 4, M = 4. So, 

GCD(1, 1) * GCD(1, 2) * ...... * GCD(4, 4) = 1 * 1 * 1 * 1 * 1 * 2 * 1 * 2 * 1 * 1 * 3 * 1 * 1 * 2 * 1 * 4 = 96. 
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
 
using namespace std;

vector <long long> primes;

const int N = 15000000;

int lp[N+1];

void genPrimes() {
    primes.reserve(N / 10);
    for (int i=2; i<=N; ++i) {
        if (lp[i] == 0) {
            lp[i] = i;
            primes.push_back (i);
        }
        for (int p : primes) {
            int q = i * p;
            if (q > N || p > lp[i]) {
                break;
            }
            lp[q] = p;
        }
    }
}

long long mod = 1000000007;

long long pw(long long a, long long n) {
    n %= mod - 1;
    long long res = 1;
    while (n) {
        if (n & 1ll) {
            res = res * a;
            if (res >= mod) {
                res %= mod;
            }
        }
        a = a * a;
        if (a >= mod) {
            a %= mod;
        }
        n >>= 1;
    }
    return res;
}

long long solve(int n, int m) {
    if (n > m) {
        swap(n, m);
    }
    long long res = 1;
    for (int p : primes) {
        if (p > n) break;
        long long pa = 0;
        long long n1 = n, m1 = m;
        while (n1 && m1) {
            n1 /= p, m1 /= p;
            pa += n1 * m1;
        }
        
        res = res * pw(p, pa);
        if (res >= mod) {
            res %= mod;
        }
    }
    return res;
}

int main() {
 
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
#endif
    ios_base::sync_with_stdio(false);
    
    genPrimes();
    int n, m;
    cin >> n >> m;
    cout << solve(n, m) << endl;
    //cout << solve2(1000, 1000) << endl;
    //cout << solve1(10000000, 10000000) << endl;

    return 0;
}
----------
====================
----------
MATHEMATICS.93
hard
----------
PROBLEM STATEMENT:
Sergey and Chen are locked in a rectangular box of Dimension L*W*H. Evil Larry has put a machine which is located at a point inside the box (p,q,r) which starts shooting balls in every direction (dx,dy,dz) where 

-N ≤ dx, dy, dz ≤ N except (0, 0, 0) 

such that the ball goes through (p, q, r) - (p + dx, q + dy, r + dz) - (p + 2dx, q + 2dy, r + 2dz) and so on. 

so, a total of (2N + 1)3 - 1 balls are fired. Sergey is standing at (a,b,c) and Chen is standing at (d,e,f). Provided all the balls follow reflection property and have constant velocity and gravity is not taken into account, can you tell how many balls are caught by Sergey and Chen? Sergey and Chen can catch the ball if it passes through the point at which they are standing. 

Input Format 
The first line contains the number of test cases, T lines follow, each containing a testcase. 
Each testcase contains 13 integers in the following order 

L W H a b c d e f p q r N


Output Format 
For each test case please output two integers indicating the number of balls that are caught by Sergey and C, respectively.

Constraints 
T = 1 
1 ≤ L, W, H, a, b, c, d, e, f, p, q, r, N ≤ 50  

Sample Input

1
3 3 3 1 1 1 1 1 2 2 2 2 1


Sample Output

8 4


Explanation

Here, L, W, H  = (3, 3, 3), Sergey is at (1, 1, 1) and Chen is at (1, 1, 2) and the machine Larry put is at (2, 2, 2). 
Balls are thrown at -1 ≤ x, y, z ≤ 1 from (2, 2, 2).  


(-1, -1, -1): (2, 2, 2)-(1, 1, 1) Sergey
(-1, -1, 0): (2, 2, 2)-(1, 1, 2) Chen
(-1, -1, 1): (2, 2, 2)-(1, 1, 3)-(0, 0, 2)-(1, 1, 1) Sergey
(-1, 0, -1): (2, 2, 2)-(1, 2, 1)-(0, 2, 0)-(1, 2, 1)-(2, 2, 2)-(3, 2, 3)-...
(-1, 0, 0): (2, 2, 2)-(1, 2, 2)-(0, 2, 2)-(1, 2, 2)-(2, 2, 2)-(3, 2, 2)-...
(-1, 0, 1): (2, 2, 2)-(1, 2, 3)-(0, 2, 2)-(1, 2, 1)-(2, 2, 0)-(3, 2, 1)-...
(-1, 1, -1): (2, 2, 2)-(1, 3, 1)-(0, 2, 0)-(1, 1, 1) Sergey
(-1, 1, 0): (2, 2, 2)-(1, 3, 2)-(0, 2, 2)-(1, 1, 2) Chen
(-1, 1, 1): (2, 2, 2)-(1, 3, 3)-(0, 2, 2)-(1, 1, 1) Sergey
(0, *, *): x-coordinate never changed
(1, -1, -1): (2, 2, 2)-(3, 1, 1)-(2, 0, 0)-(1, 1, 1) Sergey
(1, -1, 0): (2, 2, 2)-(3, 1, 2)-(2, 0, 2)-(1, 1, 2) Chen
(1, -1, 1): (2, 2, 2)-(3, 1, 3)-(2, 0, 2)-(1, 1, 1) Sergey
(1, 0, -1): (2, 2, 2)-(3, 2, 1)-(2, 2, 0)-(1, 2, 1)-(0, 2, 2)-...
(1, 0, 0): (2, 2, 2)-(3, 2, 2)-(2, 2, 2)-(1, 2, 2)-(0, 2, 2)-...
(1, 0, 1): (2, 2, 2)-(3, 2, 3)-(2, 2, 2)-(1, 2, 1)-(0, 2, 0)-...
(1, 1, -1): (2, 2, 2)-(3, 3, 1)-(2, 2, 0)-(1, 1, 1) Sergey
(1, 1, 0): (2, 2, 2)-(3, 3, 2)-(2, 2, 2)-(1, 1, 2) Chen
(1, 1, 1): (2, 2, 2)-(3, 3, 3)-(2, 2, 2)-(1, 1, 1) Sergey

----------
TOP SOLUTION:
----------
#include <iostream>
#include <algorithm>
#include <tuple>
using namespace std;

const int debug = 0;

template<typename T>
void gcd(T a, T b, T& d, T& u, T& v) {
	if (b == 0) {
		d = a;
		u = 1;
		v = 0;
	} else {
		gcd(b, a % b, d, v, u);
		v -= u * (a / b);
	}
}

std::pair<int, int> mem_inverse[101][101];

std::pair<int, int> Inverse(int a, int n) {
  a %= n; if (a < 0) a += n;
  auto& r = mem_inverse[a][n];
  if (r.first == 0) {
  	int g, u, v;
  	gcd(a, n, g, u, v);
    r = make_pair(g, u);
  }
  return r;
}

int gcd(int a, int b) {
  while (b != 0) {
    int t = a % b;
    a = b;
    b = t;
  }
  return a;
}

struct P {
  int p[3];
};

#define LOOP3(i) for (int i = 0; i < 3; ++i)

istream& operator>>(istream& a, P& b) {
  LOOP3(i) a >> b.p[i];
  return a;
}

ostream& operator<<(ostream& a, const P& b) {
  LOOP3(i) {
    a << (i == 0 ? "(" : ",");
    a << b.p[i];
  }
  a << ")";
  return a;
}

typedef long long ll;

P dim;

ll Solve(P t, P d) {
  if (debug > 1) {
  	cerr << "  Try target" << t << " direction" << d << endl;
  }
  ll z = 0, n = 1;  // All sol'ns in the form z + xn.
  LOOP3(i) {
    int m = dim.p[i] * 2;
    int a = n * d.p[i] % m, b = (t.p[i] - d.p[i] * z) % m;
    if (a == 0) {
      if (b != 0) return -1;
      continue;
    }
    int g, inv_a;
    tie(g, inv_a) = Inverse(a, m);
    if (b % g != 0) return -1;
    int z1 = (b / g * inv_a) % (m / g);
    // x = z1 (mod m / g).
    z += n * z1;
    n *= m / g;
  }
  z %= n;
  if (z < 0) z += n;
  return z;
}

ll Solve(P s, P t, P d) {
  if (debug > 0) {
    cerr << "Try source" << s << " target" << t << " direction" << d << endl;
  }
  int ag = gcd(gcd(d.p[0], d.p[1]), d.p[2]);
  if (ag == 0) {
    if (debug > 0) cerr << "  Zero direction." << endl;
    return -1;
  }
  if (ag < 0) ag = -ag;
  LOOP3(i) { d.p[i] /= ag; }
  
  ll ans = -1;
  for (int k = 0; k < 8; ++k) {
    P nt;
    LOOP3(i) {
      nt.p[i] = (k >> i & 1) ? 2 * dim.p[i] - t.p[i] : t.p[i];
      nt.p[i] -= s.p[i];
    }
    ll tmp = Solve(nt, d);
    if (debug > 1) cerr << "  Result: " << tmp << endl;
    if (tmp != -1 && (ans == -1 || tmp < ans)) ans = tmp;
  }
  if (debug > 0) cerr << "Answer: " << ans << endl;
  return ans;
}

int main() {
	
	cin.sync_with_stdio(false);
	int T, N;
	P pS, pC, pL;
	cin >> T >> dim >> pS >> pC >> pL >> N;
	int ansS = 0, ansC = 0;
	P d;
#define LOOP(x) for (x = -N; x <= N; ++x)
    LOOP(d.p[0]) LOOP(d.p[1]) LOOP(d.p[2]) {
		ll tS = Solve(pL, pS, d);
		ll tC = Solve(pL, pC, d);
		if (tS == -1 && tC == -1) continue;
		if (tS == -1) {
			++ansC;
		} else if (tC == -1) {
			++ansS;
		} else if (tS < tC) {
			++ansS;
		} else {
			++ansC;
		}
	}
	cout << ansS << ' ' << ansC << endl;
	return 0;
}

----------
====================
----------
MATHEMATICS.94
medium
----------
PROBLEM STATEMENT:
Eugene must do his homework, but he is struggling. 
He has three integer numbers: A, N, M. He writes number A on the board N times in a row. Let's call the resulting big number X.
Help Eugene find X modulo M. 
----------
TOP SOLUTION:
----------
#define _USE_MATH_DEFINES
#include <algorithm>
#include <cstdio>
#include <functional>
#include <iostream>
#include <cfloat>
#include <climits>
#include <cstring>
#include <cmath>
#include <fstream>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <time.h>
#include <vector>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> i_i;
typedef pair<ll, int> ll_i;
typedef pair<double, int> d_i;
typedef pair<ll, ll> ll_ll;
typedef pair<double, double> d_d;
struct edge { ll B, T, F, P; };

unsigned MOD = 1000000007;
ll _MOD = 1000000009;
double EPS = 1e-10;
int UNKO = INT_MAX;

ll M;

vector< vector<ll> > matmul(vector< vector<ll> >& A, vector< vector<ll> >& B) {
	int n = A.size();
	vector< vector<ll> > C(n, vector<ll>(n));
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			for (int k = 0; k < n; k++)
				C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % M;
	return C;
}

vector< vector<ll> > matpow(vector< vector<ll> > A, ll x) {
	int n = A.size();
	vector< vector<ll> > B(n, vector<ll>(n));
	for (int i = 0; i < n; i++) B[i][i] = 1;
	while (x > 0) {
		if (x % 2) B = matmul(B, A);
		x /= 2;
		A = matmul(A, A);
	}
	return B;
}

int main() {
	int T; cin >> T;
	while (T--) {
		ll A, N;
		cin >> A >> N >> M;
		int k;
		if (A <= 9) k = 10;
		else if (A <= 99) k = 100;
		else if (A <= 999) k = 1000;
		else if (A <= 9999) k = 10000;
		vector<vector<ll> > a(2, vector<ll>(2));
		a[0][0] = k; a[0][1] = 1;
		a[1][0] = 0; a[1][1] = 1;
		a = matpow(a, N);
		cout << a[0][1] * A % M << endl;
	}
}
----------
====================
----------
MATHEMATICS.95
medium
----------
PROBLEM STATEMENT:
Sevenkplus has a rooted tree with [expression]. 
He forms a [expression] is defined by 
[expression] 
where [expression]. 
He wants to calculate the determinant of [expression].  

Input Format 
First line contains the number of vertices, [expression]. 
Second line contains [expression] separated by a space. 
This is followed by [expression].  

Output Format 
Output one line, the determinant of [expression].

Constraints 
[expression] 
[expression]. 

Sample Input

3
1 2 3
1 2
1 3


Sample Output

2


Explanation

[expression]

Then, [expression]. 

Hence [expression]

Timelimits 
Timelimits for this challenge is given here
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>

using namespace std;

#define N 100001
#define PB push_back
#define MOD 1000000007LL
#define LL long long int
vector<int> adj[N];
bool vis[N] = {false};
int val[N];

inline LL go(int u, int k){
    LL ret = val[u] - k + MOD;
    if(ret >= MOD){
        ret -= MOD;
    }
    vis[u] = true;
    for(int i = adj[u].size() - 1, v; i >= 0; i--){
        v = adj[u][i];
        if(vis[v] == false){
            ret *= go(v, val[u]);
            ret %= MOD;
        }
    }
    return ret;
}

int main(){
    int n, i, u, v;
    cin>>n;
    for(i = 1; i <= n; i++){
        cin>>val[i];
    }
    for(i = 1; i < n; i++){
        cin>>u>>v;
        adj[u].PB(v);
        adj[v].PB(u);
    }
    cout<<go(1, 0)<<endl;
    return 0;
}
----------
====================
----------
MATHEMATICS.96
hard
----------
PROBLEM STATEMENT:
You are given 2 integers a and b. Let a number be defined as 
. As we know  will be an irrational number when b is non-zero. In this problem, we call it the AC number. We define 

 (where x an integer) and the operation  on AC number as:



This problem is to find the smallest positive integer n, such that:



We call the integer n as period. You are given a, b and m. Can you figure out the period?

Input Format 
The first line of the input contains a single integer T denoting the number of test-cases. 
T lines follow, each containing 3 integers - a, b and m separated by a single space. 

Output Format 
Output the Period if it exists, otherwise output "-1" (quotes only for reference)

Constraints 
1 ≤ T ≤ 300 
5 ≤ m ≤ 107 
0 ≤ a, b 

Sample Input #00

4
0 0 13
1 0 7
3 0 10007
1 1 19


Sample Output #00

-1
1
5003
18


Explanation #00   

For the 1st test-case, no amount of operation ⊗ on a = 0, b = 0 gives 1 on the RHS. Hence the answer is -1. 
When a = 1, b = 0, we have 1 for n = 1. 
On repeated operations, the third and the fourth testcases sum to 1 for n = 5003 and n = 18 respectively. 
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <map>
#include <cstdlib>
using namespace std;

struct num {
    long long a, b, m;
    num(long long x, long long y, int z) { a=x, b=y, m=z; }
    num operator* (num x) {
        return num((a*x.a + 5*b*x.b)%m, (a*x.b+b*x.a)%m, m);
    }
    bool operator< (const num &x) {
        if (a < x.a) return true;
        if (a > x.a) return false;
        return b < x.b;
    }
};
num power(num a, long long p) {
    if (p==1) return a;
    num tmp = power(a, p/2);
    if (p%2==1)
        return tmp*tmp*a;
    else
        return tmp*tmp;
}
struct cmp {
    bool operator() (const num &x, const num &y) {
        if (x.a < y.a) return true;
        if (x.a > y.a) return false;
        return x.b < y.b;
    }
};
long long gcd(long long a, long long b) {
    if (b==0) return a;
    return gcd(b, a%b);
}

int main() {
    ios_base::sync_with_stdio(0);
    int T, a, b, m;
    cin >> T;
    //map<num, int, cmp> used;
    while (T--) {
        //used.clear();
        cin >> a >> b >> m;
        if (a==1 && b==0) {
            cout << "1\n";
            continue;
        }
        num beg = num(a,b,m);
        num act = power(beg, (long long)(m)*m-1);
        if (act.a!=1 || act.b!=0) {
            cout << "-1\n";
            continue;
        }
        //used[beg] = 1;
        long long res = (long long)(m)*m-1;
        /*for (int i=0; i<m; i++) {
            long long n = rand()%(m)+1;
            act = power(beg, n);
            if (used[act]!=0 && used[act]!=n) {
                res = gcd(m-1, abs(n-used[act]));
                break;
            }
            used[act] = n;
        }*/
        bool ok = false;
        long long mini = (long long)(m)*m-1;
        for (long long i=1; i*i<=res; i++) {
            if (res%i!=0) continue;
            act = power(beg, i);
            if (act.a==1 && act.b==0) {
                cout << i << "\n";
                ok = true;
                break;
            }
            act = power(beg, res/i);
            if (act.a==1 && act.b==0)
                mini = min(mini, res/i);
        }
        if (!ok)
            cout << mini << "\n";
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.97
medium
----------
PROBLEM STATEMENT:
Given a sequence of [expression] in which every pair is a nice pair?

The pair [expression] is a nice pair iff at least one of the following condition holds.  


The parity of the number of distinct prime divisors of [expression].  
The parity of the sum of all positive divisors of [expression].

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

long long mul(long long x, long long y, long long mod) {
	if (x == 0) return 0; else {
		long long v = mul(x / 2, y, mod);
		return ((v+v)%mod+((x%2==0)?0:y))%mod;
	}
}
long long power_mod(long long x, long long e, long long mod) {
	return (e == 0) ? 1 : mul(power_mod(mul(x, x, mod), e / 2, mod), (e % 2 == 0) ? 1 : x, mod);
}

// Miller Rabin
bool isPrime(long long n) {
	int r = 0;
	long long R = n - 1;
	while (R % 2 == 0) {
		r++; R /= 2;
	}
	for (int it = 1; it <= 10; it++) {
		long long a = 1 + rand() % (n - 1);
		long long a_R (power_mod(a, R, n));
		vector<long long> b (r + 1);
		b[0] = a_R;
		for (int i = 1; i <= r; i++) {
			b[i] = mul(b[i - 1], b[i - 1], n);
		}
		if (b[r] != 1) {
			return false;
		}
		if (b[0] == 1) {
			continue;
		}
		int j = -1;
		for (int i = 0; i <= r; i++) {
			if (b[i] != 1) {
				j = i;
			}
		}
		if (b[j] == n - 1) {
			continue;
		}
		else {
			return false;
		}
	}
	return true;
}

bool isSquare(long long n) {
    long long l = 0, r = 1;
    while (r * r < n) r *= 2;
    while (l != r) {
        long long m = (l + r) / 2;
        (m * m < n) ? (l = m + 1) : (r = m);
    }
    return l * l == n;
}

int calc(long long n) {
    bool divisibleBy2 = n % 2 == 0;
    while (n % 2 == 0) n /= 2;
    // n odd
    int nFactors = int (divisibleBy2);
    int divSumParity = 1;
    for (int i = 2; (long long) i * i * i <= n; i ++) {
        if (n % i == 0) {
            int e = 0;
            while (n % i == 0) n /= i, e ++;
            if (e % 2 == 1) divSumParity = 0;
            nFactors ++;
        }
    }
    if (n > 1) {
        if (isSquare(n)) {
            nFactors += 1;
        } else if (isPrime(n)) {
            nFactors += 1;
            divSumParity = 0;
        } else {
            nFactors += 2;
            divSumParity = 0;
        }
    }
    return 2*(nFactors%2) + divSumParity;
}

inline int TWO(int n) { return 1 << n; }
inline int All1(int n) { return TWO(n) - 1; }

int main() {
    srand(0);
    vector<int> freq (4);
    int n;
    cin >> n;
    for (; n > 0; n --) {
        long long x;
        cin >> x;
        freq[calc(x)] ++;
    }
    cout << max(freq[0], freq[3]) + max(freq[1], freq[2]) << endl;
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
MATHEMATICS.98
hard
----------
PROBLEM STATEMENT:
For a given prime [expression].

For a given [expression].

Your job is to calculate [expression].

Input Format 
The first line contains the number of test cases [expression]. 
Each of the next [expression] separated by a space.

Output Format 
For each test case, output one line containing [expression].

Constraints 
[expression] 
[expression] 
[expression] 
[expression] is prime

Sample input  

2
2 6
3 6


Sample Output  

2
2


Explanation 
Here are the first 6 factorials: 1, 2, 6, 24, 120, 720.  

The multiplicities of 2 in these numbers are: 0, 1, 1, 3, 3, 4. 
Exactly two of these are divisible by 2 (0 and 4), so [expression].

The multiplicities of 3 in these numbers are: 0, 0, 1, 1, 1, 2. 
Exactly two of these are divisible by 3 (0 and 0), so [expression].
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define ll long long

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void writer(ll x, char c){int i,sz=0,m=0;char buf[20];if(x<0)m=1,x=-x;while(x)buf[sz++]=x%10,x/=10;if(!sz)buf[sz++]=0;if(m)mypc('-');while(sz--)mypc(buf[sz]+'0');mypc(c);}

int T;
ll P, L;

int main(){
  ll i, j, k, st, res, g, rest;
  P = 3;
  k = 0;

  reader(&T);
  while(T--){
    reader(&P);
    reader(&L); L++;

    res = 0;
    st = 0;
    if(P <= 1000000000){
      st += L/(P*P) * (P*P);
      res += L/(P*P) * P;
    }

    g = 0;
    k = st;
    while(k) k /= P, g = (g+k) % P;

    rest = L - st;
//    printf("%lld %lld\n",g,rest);
    if(g==0){
      res += min(max(0LL, rest), (ll)P);
    } else {
      rest -= (P-g) * P;
      res += min(max(0LL, rest), (ll)P);
    }

    res--;
    writer(res,'\n');
  }

  return 0;
}

----------
====================
----------
MATHEMATICS.99
advanced
----------
PROBLEM STATEMENT:
A number is algebraic if it is a root of some nonzero polynomial with integer coefficients. A number is transcendental if it is not algebraic.

For example, [expression] is transcendental.

The degree of an algebraic number is the minimal degree of a polynomial with integer coefficients in which it is a root. For example, the degrees of [expression], respectively.

Given [expression], calculate the degree of the following algebraic number:
[expression]  

Input Format 
The first line of input contains [expression], the number of test cases. The descriptions of the test cases follow.

Each test case has two lines of input. The first line contains a single integer, [expression] separated by single spaces.

Output Format 
For each test case, output one line containing exactly one integer, which is the answer for that test case.

Constraints 
[expression] 
[expression] 
[expression] 
The sum of the [expression]  

Sample Input  

3
1
4
3
2 4 4
4
1 2 3 5


Sample Output 

1
2
8


Explanation 
Case 1: A minimal polynomial of [expression].  

Case 2: A minimal polynomial of [expression].  

Case 3: A minimal polynomial of [expression] is:
[expression]
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define MP make_pair
#define PB push_back
#define int long long
#define st first
#define nd second
#define rd third
#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)
#define RE(i, n) FOR(i, 1, n)
#define FORD(i, a, b) for(int i = (a); i >= (b); --i)
#define REP(i, n) for(int i = 0;i <(n); ++i)
#define VAR(v, i) __typeof(i) v=(i)
#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)
#define ALL(x) (x).begin(), (x).end()
#define SZ(x) ((int)(x).size())
#ifdef LOCAL
#define debug(x) {cerr <<#x<<" = " <<x<<"\n"; }
#define debug2(x, y) {cerr <<#x<<" = " <<x<<", "<<#y <<" = " <<y <<"\n";}
#define debug3(x, y, z) {cerr <<#x<<" = " <<x<<", "<<#y <<" = " <<y <<", "<<#z<<" = "<<z<<"\n";}
#define debug4(x, y, z, t) {cerr <<#x<<" = " <<x<<", "<<#y <<" = " <<y <<", "<<#z<<" = "<<z<<", "<<#t <<" = " <<t<<"\n";}
#define debugv(x) {{cerr <<#x <<" = "; FORE(itt, (x)) cerr <<*itt <<", "; cerr <<"\n"; }}
#else
#define debug(x)
#define debug2(x, y)
#define debug3(x, y, z)
#define debug4(x,y,z,t)
#define debugv(x)
#define cerr if(0)cout
#endif
#define make(type, x) type x; cin>>x;
#define make2(type, x, y) type x, y; cin>>x>>y;
#define make3(type, x, y, z) type x, y, z; cin>>x>>y>>z;
#define make4(type, x, y, z, t) type x, y, z, t; cin>>x>>y>>z>>t;
#define next ____next
#define prev ____prev
#define left ____left
#define hash ____hash
using namespace std;
typedef long long ll;
typedef long double LD;
typedef pair<int, int> PII;
typedef pair<ll, ll> PLL;
typedef vector<int> VI;
typedef vector<ll> VLL;
typedef vector<pair<int, int> > VPII;
typedef vector<pair<ll, ll> > VPLL;

template<class C> void mini(C&a4, C b4){a4=min(a4, b4); }
template<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }
template<class T1, class T2>
ostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << "(" << pair.first << ", " << pair.second << ")";}
template<class A, class B, class C> struct Triple { A first; B second; C third; };
template<class T> void ResizeVec(T&, vector<int>) {}
template<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {
  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }
  for (T& v : vec) { ResizeVec(v, sz); }
}

const int R = 1e7 + 5;
vector<int> lp[R];
int sieve[R];

int Vp2(int n, int p) {
  int ex = 0;
  while (n % p == 0) {
    ex ^= 1;
    n /= p;
  }
  return ex;
}

struct Rep {
  vector<int> is;
  int sz;
  Rep(int sz_) {
    sz = sz_;
    is.resize(sz);
  }

  int& operator[](int a) {
    return is[a];
  }
  Rep& operator=(Rep a) {
    REP (i, sz) {
      is[i] = a.is[i];
    }
    return *this;
  }
  bool IsZero() {
    int nonzero = false;
    REP (i, sz) {
      nonzero |= is[i];
    }
    return nonzero;
  }

};
void Print(Rep& a) {
  REP (i, a.sz) {
    cerr<<a[i]<<" ";
  }
  cerr<<endl;
}
Rep Xor(Rep a, Rep b) {
  Rep x(a.sz);
  REP (i, a.sz) {
    x[i] = (a[i] ^ b[i]);
  }
  return x;
  
}


#undef int
int main() {
#define int long long

  ios_base::sync_with_stdio(0);
  cout << fixed << setprecision(10);
  double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;
  
  FOR (i, 2, R - 2) {
    if (sieve[i] == 0) {
      for (int j = 1; j * i < R; j++) {
        if (sieve[i * j] == 0) {
          sieve[i * j] = i;
        }
//         int tmp = j * i;
//         int ex = 0;
//         while (tmp % i == 0) {
//           tmp /= i;
//           ex++;
//         }
//         if (ex % 2) {
//           lp[i * j].PB(i);
//         }
      }
    }
  }
  make(int, t);
  RE (tt, t) {
    make(int, n);
    set<int> prims_all;
    vector<int> as;
    vector<set<int>> prims_loc;
    RE (i, n) {
      make(int, a);
      as.PB(a);
      prims_loc.PB(set<int>());
      debug(a);
      while (a > 1) {
        int p = sieve[a];
        if (Vp2(a, p)) {
          prims_loc.back().insert(p);
          prims_all.insert(p);
        }
        while (a % p == 0) {
          a /= p;
        }
      }
      debugv(prims_loc.back());
    }
    debugv(prims_all);

    int P = SZ(prims_all);
    vector<Rep> row;
    REP (i, n) {
      row.PB(Rep(P));
      int cnt = 0;
      for (auto x : prims_all) {
        if (prims_loc[i].count(x)) {
          row.back()[cnt] = true;
        }
        cnt++;
      }
      Print(row.back());
    }
    int fixed = 0;
    for (int bit = 0; bit < P; bit++) {
      if (fixed == n) {
        continue;
      }
      int got = 1;
      if (row[fixed][bit] == 0) {
        got = 0;
        for (int j = fixed + 1; j < n; j++) {
          if (row[j][bit]) {
            swap(row[fixed], row[j]);
            got = 1;
            break;
          }
        }
      }
      if (got == 0) { continue; }
      for (int j = fixed + 1; j < n; j++) {
        if (row[j][bit]) {
          row[j] = Xor(row[j], row[fixed]);
        }
      }
      fixed++;
    }
    cout<<(1ll << fixed)<<"\n";
      
        
    
    
  }
  
    
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  return 0;
}

----------
====================
----------
MATHEMATICS.100
advanced
----------
PROBLEM STATEMENT:
Suppose we have an n-dimensional supercomputer with an infinite number of processors. Every processor has a vector of [expression], are not neighbors.

Some processors of this computer are infected by a virus. At time [expression].
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

#define long long long
#define mod 1000000007ll
#define M 5000500

long f[M], r[M], two[M], qf[M];

void pre() {
    two[0] = 1;
    for (int i = 1; i < M; ++i)
        two[i] = (2 * two[i - 1]) % mod;

    f[0] = 1;
    for (int i = 1; i < M; ++i)
        f[i] = (f[i - 1] * i) % mod;

    r[0] = r[1] = 1;
    for (int i = 2; i < M; ++i)
        r[i] = (-(mod / i) * r[mod % i]) % mod;
    for (int i = 2; i < M; ++i)
        r[i] = (r[i] * r[i - 1]) % mod;
}

long cnk(long n, long k) {
    if (k < 0 || n < k)
        return 0;
    long ans = (f[n] * r[k]) % mod;
    ans = (ans * r[n - k]) % mod;
    return ans;
}

void preq(long q, long n) {
    q %= mod;
    qf[0] = 1;
    for (int i = 1; i <= n; ++i)
        qf[i] = (qf[i - 1] * (q - i + 1)) % mod;
}

long qcnk(long k) {
    return (qf[k] * r[k]) % mod;
}

long binpow(long x, long a) {
    long y = 1;
    while (a) {
        if (a & 1)
            y = (y * x) % mod;
        x = (x * x) % mod;
        a >>= 1;
    }
    return y;
}

void kill() {
    long n, q, ans = 0;
    cin >> n >> q;
    preq(q, n);
    for (int k = 0; k <= n; ++k) {
        long bon = (qcnk(k) * cnk(n, k)) % mod;
        bon = (bon * two[k]) % mod;
        ans = (ans + bon) % mod;
    }
    if (ans < 0)
        ans += mod;
    cout << ans << "\n";
}

int main() {
    pre();

    int t;
    cin >> t;
    while (t--)
        kill();

    return 0;
}
----------
====================
----------
MATHEMATICS.101
hard
----------
PROBLEM STATEMENT:
How many non decreasing sequences are there of length [expression].

Input Format 
The first line contains an integer [expression] i.e. the number of test cases.
[expression] separated by a single space.  

Output Format 
For each testcase, print in a newline the answer [expression]. 

Constraints  

[expression] 
[expression] 
[expression]  

Sample Input

4
2 4 
3 4
5 2
1 10


Sample Output

4
13
10
1


Explanation

For the first testcase, the sequences are 

(1,1,1,1), (1,1,1,2), (1,1,2,2), (1,2,2,2) = 4


For the second testcase, the sequences are 

(1,1,1,1), (1,1,1,2), (1,1,1,3), (1,1,2,2), (1,1,2,3), (1,1,3,3)
(1,3,3,3), (1,2,2,2), (1,2,2,3), (1,2,3,3), (2,2,2,3), (2,2,3,3), (2,3,3,3)


which are 13 in number.  

For the third testcase, the sequences are  

(1,1), (1,2), (1,3), (1,4), (1,5), (2,3), (2,5), (3, 4), (3, 5), (4, 5) = 10


for the fourth testcase, the only sequence is 

(1,1,1,1,1,1,1,1,1,1)

----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt(): x(0) { }
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }
	
	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }
	
	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
	
	ModInt inverse() const {
		long long a = x, b = MOD, u = 1, v = 0;
		while(b) {
			long long t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		return ModInt(u);
	}
};
template<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {
	ModInt<MOD> r = 1;
	while(k) {
		if(k & 1) r *= a;
		a *= a;
		k >>= 1;
	}
	return r;
}
typedef ModInt<1000000007> mint;


vector<bool> isprime;
vector<int> primes;
void sieve(int n){
	if((int)isprime.size() >= n+1) return;
	isprime.assign(n+1, true);
	isprime[0] = isprime[1] = false;
	int sqrtn = (int)(sqrt(n * 1.) + .5);
	for(int i = 2; i <= sqrtn; i ++) if(isprime[i]) {
		for(int j = i * i; j <= n; j += i)
			isprime[j] = false;
	}
	primes.clear();
	for(int i = 2; i <= n; i ++) if(isprime[i])
		primes.push_back(i);
}

vector<int> mobiusMu;
void calcMobiusMu() {
	int n = (int)isprime.size() - 1;
	mobiusMu.assign(n+1, 1);
	for(int i = 2; i <= n; i ++) if(isprime[i]) {
		if((ll)i * i <= n) {
			for(int j = i * i; j <= n; j += i * i)
				mobiusMu[j] = 0;
		}
		for(int j = i; j <= n; j += i)
			mobiusMu[j] *= -1;
	}
}

vector<mint> fact, factinv;
void nCr_computeFactinv(int N) {
	N = min(N, mint::Mod - 1);
	fact.resize(N+1); factinv.resize(N+1);
	fact[0] = 1;
	rer(i, 1, N) fact[i] = fact[i-1] * i;
	factinv[N] = fact[N].inverse();
	for(int i = N; i >= 1; i --) factinv[i-1] = factinv[i] * i;
}
mint nCr(int n, int r) {
	if(n >= mint::Mod)
		return nCr(n % mint::Mod, r % mint::Mod) * nCr(n / mint::Mod, r / mint::Mod);
	return r > n ? 0 : fact[n] * factinv[n-r] * factinv[r];
}

mint nHr(int n, int r) { return r == 0 ? 1 : nCr(n+r-1, r); }


int main() {
	sieve(100000);
	calcMobiusMu();
	nCr_computeFactinv(200000);
	int T;
	scanf("%d", &T);
	rep(ii, T) {
		int N, K;
		scanf("%d%d", &N, &K);
		mint ans = 0;
		rer(g, 1, N) {
			mint x = nHr(N / g, K);
			ans += x * mobiusMu[g];
		}
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.102
advanced
----------
PROBLEM STATEMENT:
Given two integers, [expression], Alice loves to calculate their power sum using the following formula:
[expression]

Bob has a set, [expression].

Alice and Bob are now confused about the final value of the power sum and decide to turn to Eve for help. Can you write a program that helps Eve solve this problem? Given [expression] on a new line for each query.
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }


template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
};
template<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {
	ModInt<MOD> r = 1;
	while(k) {
		if(k & 1) r *= a;
		a *= a;
		k >>= 1;
	}
	return r;
}
typedef ModInt<1000000007> mint;

int main() {
	const vector<mint> polynomials[11] = {
		{ 0, 1, },
		{ 0, 500000004, 500000004, },
		{ 0, 166666668, 500000004, 333333336, },
		{ 0, 0, 250000002, 500000004, 250000002, },
		{ 0, 766666672, 0, 333333336, 500000004, 400000003, },
		{ 0, 0, 916666673, 0, 416666670, 500000004, 166666668, },
		{ 0, 23809524, 0, 833333339, 0, 500000004, 500000004, 142857144, },
		{ 0, 0, 83333334, 0, 708333338, 0, 583333338, 500000004, 125000001, },
		{ 0, 766666672, 0, 222222224, 0, 733333338, 0, 666666672, 500000004, 111111112, },
		{ 0, 0, 450000003, 0, 500000004, 0, 100000000, 0, 750000006, 500000004, 700000005, },
		{ 0, 348484851, 0, 500000003, 0, 1, 0, 1000000006, 0, 833333340, 500000004, 818181824, },
	};

	int T;
	scanf("%d", &T);
	for(int ii = 0; ii < T; ++ ii) {
		int n; int k;
		scanf("%d%d", &n, &k);
		long long m;
		scanf("%lld", &m);
		vector<ll> a(n);
		for(int i = 0; i < n; ++ i)
			scanf("%lld", &a[i]);
		if(count(a.begin(), a.end(), 1) != 0) {
			puts("0");
			continue;
		}
		sort(a.begin(), a.end());
		reverse(a.begin(), a.end());
		vector<mint> powa(n);
		rep(i, n)
			powa[i] = mint(a[i]) ^ k;

		//A^k \sum_{i=0}^{m/A} i^k

		auto calc = [k, &polynomials](mint m) -> mint {
			mint r;
			for(int i = k + 1; i >= 0; -- i)
				r = r * m + polynomials[k][i];
			return r;
		};

		mint undef; undef.x = -1;
		const int M = (int)min(m, 10000000LL / n);
		vector<vector<mint>> memo(n + 1, vector<mint>(M + 1, undef));
		auto rec = [&](auto rec, int i, ll m) -> mint {
			mint *memop = nullptr;
			if(m <= M) {
				memop = &memo[i][(int)m];
				if(memop->x != -1)
					return *memop;
			}
			mint r;
			if(i == n) {
				r = calc(m);
			} else {
				r += rec(rec, i + 1, m);
				r -= rec(rec, i + 1, m / a[i]) * powa[i];
			}
			if(memop) *memop = r;
			return r;
		};

		mint ans = rec(rec, 0, m);
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.103
expert
----------
PROBLEM STATEMENT:
When you look at photographs of watches and clocks, you'll find that they almost always show the time 10:10. There are lots of theories and even urban legends about this. For example, when showing 10:10, the hands look like a smile, and so you are more inclined to buy the watch or clock :D (a form of subliminal advertising).

Now, you are given [expression] such that:


[expression],
If [expression], and
[expression] are squarefree.


Since the number can be very large, only give the number modulo [expression].

Input Format 
The first line of input contains a single integer [expression], which is the number of test cases. The following lines contain the test cases.

Each test case consists of one line containing two integers, [expression].

Constraints 
[expression] 
[expression]  

Output Format 
For each test case, output a single line containing the answer.

Sample Input  

2
2 3
3 3


Sample Output  

3
62


Explanation 
For the first test case, the possible sequences are: 
[expression], 
[expression], 
[expression]  
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <iostream>
#include <set>
#include <vector>
#include <cstring>
#include <string>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <complex>
#include <map>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vi> vvi;
typedef vector<double> vd;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef vector<pii> vii;
typedef vector<string> vs;
const int mod = 2000003;

ll mpow (ll x, ll n) {
    ll res = 1;
    while (n) {
        if (n & 1) 
            res = res * x % mod;
        n /= 2;
        x = x * x % mod;
    }
    return res;
}

ll inv(ll x) {
    return mpow(x, mod-2);
}

ll p3(ll x) {
    return x*x%mod*x%mod;
}

ll p2(ll x) {
    return x*x%mod;
}

ll getp(ll x) {
    ll sum = 0;
    while(x) {
        x /= mod;
        sum += x;
    }
    return sum;
}

vl fact(mod,1);
ll fac(ll x) {
    ll res = 1;
    while(x) {
        res = res * fact[x%mod] % mod;
        x /= mod;
    }
    return res;
}

ll c(ll a, ll b) {
    ll cnt = getp(b) - getp(a) - getp(b-a);
    if (cnt) return 0;
    return fac(b) * inv(fac(a)*fac(b-a)%mod) % mod;
}

ll f3(ll n) {
    if (n == 0) return 1;
    if (n == 1) return 9;
    return ((n+2) % mod * mpow(2, 3*n-1) - 3*n%mod*mpow(2, n-2)*c(n, 2*n)) % mod;
}

ll f2(ll n) {
    if (n == 0) return 1;
    //(n+2)*2^(2*n-1)-(n/2)*binomial(2*n,n)
    ll x = ((n+2)%mod * mpow(2, 2*n-1) - n % mod * (mod+1)/2 % mod * c(n, 2*n)) % mod;
    if (x < 0) x += mod;
    return x;
}

ll f1(ll n) { //(n+2)*2^(n-1)
    if (n == 0) return 1;
    return (n+2) % mod * mpow(2, n-1) % mod;
}

int main() {
    for (int i = 2; i < fact.size(); ++i)
        fact[i] = fact[i-1] * i % mod;
    int T;
    scanf("%d", &T);
    for (int test = 1; test <= T; ++test) {
        ll n,m;
        scanf("%lld%lld", &n, &m);
        ll res = 0, res1 = 1, s = 0;
        res = (f3(n-1) - n + 3*f1(n-1) - 3*f2(n-1))%mod;
        //cerr << f3(n-1) << endl;
        /*ll c = 1;
        for (int i = 1; i <= n-1; ++i) {
            c = (n - i) % mod * c % mod * inv(i) % mod;
            s = (s + c) % mod;
            res1 = (res1 + s+1) % mod;
        }
        cerr << res1 << ' ' << f1(n-1) << endl;*/
        s = mpow(2, n-1) - 1;
        res = (res + (m - n + 1) % mod * p3(s)) % mod;
        printf("%lld\n", (res + mod) % mod);
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.104
advanced
----------
PROBLEM STATEMENT:
The Rebel Alliance and the Galactic Empire are engaged in an epic battle in the skies above Endor. The grand setup has d-dimensional board with each dimension of length 'N', (i.e) N x N... (d times). Each cell (i1, i2, ...id) has the gcd (i1, i2, ...id) written on it. 

Now, the game begins. A random integer L is chosen and the first person to sum up the Lth power of each number modulo 30000001 wins the game. 

Rebel Alliance needs some help and pings you. If they win, you get a million dollars for it. Can you help?

Input Format

There are several test cases. The first line contains the number of test cases T. Then T test cases follow. Each test case is given in the following format.
N and d are given in the first Line.
Q is given in the second line.
Each of the next Q lines contain an integer L.

Constraints

0
17 
1
0
0

Output Format

For each test case, output Q lines, indicating the answer.

Sample Input

3
3 2
4
0
1
2
3
5 1
3
0
1
2
6 3
2
2
3


Sample Output

9
12
20
42
5
15
55
421
975


Explanation

Test case1: 
the board is as follows:  

1(gcd 1,1)  1(gcd 1,2)  1(gcd 1,3) 
1(gcd 2,1)  2(gcd 2,2)  1(gcd 2,3) 
1(gcd 3,1)  1(gcd 3,2)  3(gcd 3,3)  

Therefore,
sum of 0th power is 1^0+1^0+1^0 + 1^0+2^0+1^0 + 1^0+1^0+3^0 = 9 
sum of 1st power is 1^1+1^1+1^1 + 1^1+2^1+1^1 + 1^1+1^1+3^1 = 12 
so on ...

Test case2: 
the board is as follows:  

1(gcd 1)  2(gcd 2)  3(gcd 3)  4(gcd 4)  5(gcd 5)

Therefore, 
sum of 0th power is 1^0+2^0+3^0+4^0+5^0 = 5 
sum of 1st power is 1^1+2^1+3^1+4^1+5^1 = 15 
so on ...  
----------
TOP SOLUTION:
----------
#include <stdio.h>
#include <math.h>
#define ll long long
#define mod 30000001
#define L 110
#define N 10000010

ll ipow(ll b, ll e) {
    if (e == 0) return 1;
    if (e == 1) return b;
    if (e & 1) return ipow(b, e - 1) * b % mod;
    return ipow(b * b % mod, e >> 1);
}

ll inv[L+2];
ll A[L+1];
ll B[L+1];
ll C[L+1][L+1];
ll P[L+1];
ll G[N+1];

int main() {
    inv[0] = inv[1] = 1;
    for (int i = 2; i <= L+1; i++) {
        inv[i] = (mod - mod/i) * inv[mod%i] % mod;
    }
    for (int i = 0; i <= L; i++) {
        for (int m = 0; m <= i; m++) {
            A[m] = inv[m+1];
            for (int j = m; j; j--) {
                A[j-1] = j * (A[j-1] - A[j]) % mod;
            }
        }
        B[i] = A[0];
    }
    G[0] = 0;
    for (int n = 0; n <= L; n++) {
        for (int r = 0; r <= L; r++) {
            if (r > n) {
                C[n][r] = 0;
            } else if (r == 0 or r == n) {
                C[n][r] = 1;
            } else {
                C[n][r] = (C[n-1][r-1] + C[n-1][r]) % mod;
            }
        }
    }

    int z;
    scanf("%d", &z);
    while (z--) {
        int n, d;
        scanf("%d%d", &n, &d);
        int c = int(fmin(n,pow(n, 2./3) * pow(log(n+1), 1./3) * 2))+1;

        for (int i = 1; i < c; i++) {
            G[i] = ipow(i, d) - ipow(i-1, d);
        }

        for (int i = 1; i < c; i++) {
            G[i] %= mod;
            for (int j = i << 1; j < c; j += i) {
                G[j] -= G[i];
            }
            G[i] += G[i-1];
            G[i] %= mod;
        }

        for (int k = n/c; k; k--) {
            int i = n/k;
            int u = int(sqrt(i))+1;
            ll t = ipow(i, d);
            for (int g = i/u; g > 1; g--) {
                t -= G[i/g];
            }
            t %= mod;
            for (int v = 1; v < u; v++) {
                t -= (i/v) * (G[v] - G[v-1]);
                t %= mod;
            }
            t += (i/u) * G[u-1];
            G[i] = t % mod;
        }

        int q;
        scanf("%d", &q);
        while (q--) {
            int l;
            scanf("%d", &l);
            ll t;

            if (l == 0) {
                t = ipow(n, d);
            } else {

                for (int k = 0; k <= l; k++) {
                    P[k] = C[l+1][k] * B[k] % mod;
                }

                ll res;
                #define set_F(_w) do {\
                    ll w = (_w);\
                    res = 0;\
                    for (int k = 0; k <= l; k++) {\
                        res += P[k];\
                        res *= w;\
                        res %= mod;\
                    }\
                } while (0)

                int u = int(sqrt(n/l))+1;
                t = 0;
                for (int v = 1; v < u; v++) {
                    set_F(n/v);
                    t += res * (G[v] - G[v-1]);
                    t %= mod;
                }
                set_F(n/u);
                t -= res * G[u-1];
                t %= mod;
                t *= inv[l+1];
                t %= mod;
                for (int g = n/u; g; g--) {
                    t += ipow(g, l) * G[n/g];
                    t %= mod;
                }
            }

            if (t < 0) t += mod;
            printf("%lld\n", t);
        }
    }
}

----------
====================
----------
MATHEMATICS.105
expert
----------
PROBLEM STATEMENT:
You are standing at position [expression].

You have a single laser beam which you can use to shoot enemies. You can aim it in any direction, and all enemies in that direction will be eliminated. You win if the number of enemies you eliminate is at least [expression].

How many directions can you aim the laser so that you win? As the answer can get very large, output the answer modulo [expression]).

Input Format 
The first line contains a single integer, [expression], which is the number of test cases.
The next [expression].

Output Format 
For each test case, output a single line containing the number of directions you can aim the laser, modulo [expression].

Constraints 
[expression] 
[expression] 
[expression] 
[expression]  

Sample Input  

2
3 2 1
100 3 2


Sample Output  

26
70946


Explanation 
For the first test case, here are the 26 directions you can point the laser beam to: 
[expression] 
[expression] 
[expression] 
[expression] 
[expression]
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
typedef long long LL;
using namespace std;
const int MOD = 1e9+7;
const int SIZE = 600000;
LL dp3[SIZE],mul[SIZE],record[SIZE];
void pre(){
    REPP(i,1,SIZE){
        dp3[i]+=(LL)(i+i+1)*(i+i+1)*(i+i+1)-(LL)(i+i-1)*(i+i-1)*(i+i-1);
        for(int j=i+i;j<SIZE;j+=i){
            dp3[j]-=dp3[i];
        }
        dp3[i]+=dp3[i-1];
        dp3[i]%=MOD;
    }
}
int main(){
    pre();
    CASET{
        MS0(record);
        MS0(mul);
        LL N,an=0;
        int M,D;
        scanf("%lld%d%d",&N,&M,&D);
        LL now=1;
        while(now<=N){
            LL v=N/now;
            LL nxt=N/v;
            if(v>=M){
                if(v%D==0){
                    if(nxt<SIZE)
                        an+=dp3[nxt];
                    else
                        mul[v]++;
                    if(now-1<SIZE)
                        an-=dp3[now-1];
                    else
                        mul[v+1]--;
                }
            }
            now=nxt+1;
        }
        int ker=1;
        while(N/ker>=SIZE)ker++;
        int bb=ker;
        for(ker--;ker>0;ker--){
            LL n=N/ker;
            LL me=(n+n+1)%MOD;
            record[ker]=(me*me%MOD*me%MOD-1);
            for(now=2;ker*now<bb;now++)
                record[ker]-=record[ker*now];
            while(now<=n){
                LL v=n/now;
                LL nxt=n/v;
                if(v<SIZE){
                    record[ker]-=dp3[v]*(nxt-now+1);
                    record[ker]%=MOD;
                }
                now=nxt+1;
            }
            record[ker]%=MOD;
            if(record[ker]<0)record[ker]+=MOD;
            if(mul[ker])an+=mul[ker]*record[ker];
        }
        an%=MOD;
        if(an<0)an+=MOD;
        cout<<an<<endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.106
medium
----------
PROBLEM STATEMENT:
Alice is feeling bored while sitting on the riverbank with her sister, when she notices a 2D White Rabbit with a 2D pocket watch run past. She follows it down a rabbit hole when suddenly she falls a long way to a curious 2D plane.

In this 2D plane she discovered she can only move using a sequence of movements. Those movements are limited to:


Scaling, denoted as [expression].
Translation, denoted as [expression].
Rotation, denoted as [expression].
Flip X-axis, denoted as [expression].
Flip Y-axis, denoted as [expression].
Inversion, denoted as [expression].


Also, Alice discovered that when she is at [expression].

Now, Alice has a sequence of [expression] times. Your task is to determine her final location after her adventure.

If Alice's final location is [expression].

Input Format 
The first input contains a single integer, [expression] test cases.

The first line of each test case contains four values [expression] are rational numbers).

The next [expression] lines each contains the description of a movement in the sequence, which is one of the following:


S c, which denotes scaling ([expression] is a nonzero rational number),
T a b, which denotes translation ([expression] are rational numbers),
R a b, which denotes rotation ([expression]),
F X, which denotes flip X-axis,
F Y, which denotes flip Y-axis, and
I, which denotes inversion.


Output Format 
If Alice's final location is Wonderland, output WONDERLAND.

If Alice's final location is [expression] is not invertible, also output WONDERLAND.  

Constraints 
[expression] 
[expression] 
The sum of the [expression] 
[expression] 
Each rational number is expressed in irreducible form [expression] with the following constraints: 
[expression] 
[expression]  

Sample Input  

2
3 2 0/1 0/1
T -2/1 3/1
R 3/5 4/5
I
5 1 2/1 -2/1
F X
S 3/2
T -3/1 -3/1
I
F Y


Sample Output  

881896558 492241383
WONDERLAND


Explanation 
In the first test case, [expression].

[expression]  

Therefore, the final location is [expression]. So we print: 
[expression] and: 
[expression].  

In the second test case, [expression].

[expression]  

Therefore, the final location is Wonderland.  
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <iostream>
#include <set>
#include <vector>
#include <cstring>
#include <string>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <complex>
#include <map>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vi> vvi;
typedef vector<double> vd;
typedef pair<ll, ll> pii;
typedef pair<double, double> pdd;
typedef vector<pii> vii;
typedef vector<vii> vvll;
typedef vector<string> vs;
const int mod = 1000000007;

ll mpow (ll x, ll n) {
    ll res = 1;
    while (n) {
        if (n & 1) 
            res = res * x % mod;
        n /= 2;
        x = x * x % mod;
    }
    return res;
}

ll inv(ll x) {
    return mpow(x, mod-2);
}

vvl id(int k) {
    vvl v(k, vl(k));
    for (int i = 0; i < k; ++i)
        v[i][i] = 1;
    return v;
}

int w[] = {0,1,4,5};
int u[] = {2,3,6,7};

vvl mul(const vvl &x, const vvl &y) {
    int n = x.size();
    vvl res(n, vl(n));
    for (int i = 0; i < 4; ++i) for (int j = 0; j < 4; j += 1) {
        for (int l = 0; l < 4; ++l) {
            res[w[i]][w[j]] += x[w[i]][w[l]]*y[w[l]][w[j]];
            res[u[i]][u[j]] += x[u[i]][u[l]]*y[u[l]][u[j]];
        }
        res[w[i]][w[j]] %= mod;
        res[u[i]][u[j]] %= mod;
    }
    return res;
}

vvl mulfast(const vvl &x, const vvl &y) {
    int n = x.size();
    vvl res(n, vl(n));
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; j += 2) {
            for (int l = 0; l < 4; ++l) {
                res[w[i]][w[j]] += x[w[i]][w[l]]*y[w[l]][w[j]];
            }
            res[w[i]][w[j]] %= mod;
        }
    }
    for (int i = 0; i < 4; ++i) for (int j = 0; j < 4; j += 2) {
        res[u[i]][u[j]] = res[w[i]][w[j]];
    }
    /*for (int i = 0; i < 4; ++i) for (int j = 0; j < 4; j += 2) {
        for (int l = 0; l < 4; ++l) {
            res[u[i]][u[j]] += x[u[i]][u[l]]*y[u[l]][u[j]];
        }
        res[u[i]][u[j]] %= mod;
    }*/
    for (int i = 1; i < 4; i += 2) for (int j = 1; j < 4; j += 2) {
        res[w[i]][w[j]] = res[w[i-1]][w[j-1]];
        res[u[i]][u[j]] = res[u[i-1]][u[j-1]];
    }    
    for (int i = 0; i < 4; i += 2) for (int j = 1; j < 4; j += 2) {
        res[w[i]][w[j]] = -res[w[i+1]][w[j-1]];
        res[u[i]][u[j]] = -res[u[i+1]][u[j-1]];
    }
    return res;
}
/*
vvl mpow(vvl x, ll n) {
//    n %= 2*(mod-1);
    vvl res = id(x.size());
    while(n) {
        if (n & 1) res = mulfast(res, x);
        x = mulfast(x, x);
        n /= 2;
    }
    return res;
}
*/
ll in() {
    ll x, y;
    scanf("%lld/%lld", &x, &y);
    return x*inv(y)%mod;
}

void out(const vl & v) {
    for (int i = 0; i < v.size(); ++i)
        cerr << v[i] << ' ';
    cerr << endl;
}

void out(const vvl & v) {
    cerr << endl;
    for (int i = 0; i < v.size(); ++i)
        out(v[i]);
}

void eval(ll x, ll y, const vvl & a) {
        vl t(8);
        for (int i = 0; i < 8; ++i)
            t[i] = (a[i][0]+a[i][6]) % mod;
//        out(t);
        ll xz = (t[6] + t[4]*x - t[5]*y) % mod;
        ll yz = (t[7] + t[4]*y + t[5]*x) % mod;
        if (xz == 0 && yz == 0) {
            printf("WONDERLAND\n");
        } else {
            ll xn = (t[2] + t[0]*x - t[1]*y) % mod;
            ll yn = (t[3] + t[0]*y + t[1]*x) % mod;
            ll d = (xz*xz+yz*yz) % mod;
            assert(d);
            ll di = inv(d);
            ll xf = ((xz*xn+yz*yn) % mod * di % mod + mod) % mod;
            ll yf = ((-yz*xn+xz*yn) % mod * di % mod + mod) % mod;
            printf("%lld %lld\n", xf, yf);
//            cerr << xf*65%mod << ' ' << yf*65%mod << endl;
        }
}

pii mul(pii x, pii y) {
    return pii((x.first*y.first - x.second*y.second) % mod, (y.first*x.second + y.second*x.first) % mod);
}

void mul(pii & z, pii x, pii y) {
    z.first = (z.first + x.first*y.first - x.second*y.second) % mod;
    z.second = (z.second + y.first*x.second + y.second*x.first) % mod;
}

pii mpow(pii x, ll n) {
    pii res(1, 0);
    while (n) {
        if (n & 1) res = mul(res, x);
        x = mul(x, x);
        n /= 2;
    }
    return res;
}

vvll mul(vvll x, vvll y) {
    int n = x.size();
    vvll res(n, vii(n));
    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j)
        for (int l = 0; l < n; ++l)
            mul(res[i][j], x[i][l], y[l][j]);
    return res;
}

vvl mpow(vvl x, ll n) {
    vvll res(2, vii(2));
    res[0][0] = res[1][1] = pii(1, 0);
    vvll y(2, vii(2));
    for (int i = 0; i < 2; ++i) for (int j = 0; j < 2; ++j)
        y[i][j] = pii(x[i*4][j*4], x[i*4][j*4+1]);
    while(n) {
        if (n & 1) res = mul(res, y);
        y = mul(y, y);
        n /= 2;
    }
    vvl resout(8, vl(8));
    for (int i = 0; i < 2; ++i) for (int j = 0; j < 2; ++j) {
        resout[i*4][j*4] = res[i][j].first;
        resout[i*4+1][j*4+1] = res[i][j].first;
        resout[i*4][j*4+1] = res[i][j].second;
        resout[i*4+1][j*4] = -res[i][j].second;
    }
    for (int i = 0; i < 4; ++i) for (int j = 0; j < 4; j++) {
        resout[u[i]][u[j]] = resout[w[i]][w[j]];
    }
    return resout;
}

int main() {
    int T;
    cin >> T;
    for (int test = 1; test <= T; ++test) {
        ll n,k,x,y;
        scanf("%lld%lld", &n, &k);
        //cerr << n << ' ' << k << endl;
        x = in();
        y = in();
        int cntc = 0;
        vvl a = id(8);
        char type;
        ll a1,b,c;
        for (int i = 0; i < n; ++i) {
            scanf("\n%c", &type);
            //cerr << type << endl;
            if (type == 'I') {
                cntc = 1 - cntc;
                vvl x(8, vl(8));
                for (int i = 0; i < 4; i+=2)
                    x[i][i+4] = x[i+4][i] = 1;
                for (int i = 1; i < 4; i+=2)
                    x[i][i+4] = x[i+4][i] = -1;
                a = mul(x, a);
            } else if (type == 'F') {
                cntc = 1 - cntc;
                char ax;
                scanf(" %c", &ax);
                vvl x = id(8);
                for (int i = 0; i < 4; ++i)
                    x[2*i][2*i] = -1;
                if (ax == 'Y') {
                    for (int i = 0; i < 4; ++i)
                        x[i][i] *= -1;
                }
                a = mul(x, a);
            } else if (type == 'S') {
                c = in();
                vvl x = id(8);
                for (int i = 0; i < 4; ++i)
                    x[i][i] = c;
                a = mul(x, a);
            } else if (type == 'R') {
                a1 = in();
                b = in();
                vvl x = id(8);
                for (int i = 0; i < 4; i += 2) {
                    x[i][i] = a1; x[i][i+1] = b;
                    x[i+1][i] = -b; x[i+1][i+1] = a1;
                }
                a = mul(x, a);
            } else if (type == 'T') {
                a1 = in();
                b = in();
                vvl x = id(8);
                for (int i = 0; i < 4; i += 2) {
                    x[i][i+4] = a1; x[i][i+5] = -b;
                    x[i+1][i+4] = b; x[i+1][i+5] = a1;
                }
                a = mul(x, a);
            } else {
                cerr << i << ' ' << type << endl;
                assert(0);
            }
        }
        if (n == 1) {
            if (type == 'F' || type == 'I') {
                k %= 2;
            } else if (type == 'S') {
                a = id(8);
                for (int i = 0; i < 4; ++i)
                    a[i][i] = mpow(c, k);
                k = 1;
            } else if (type == 'T') {
                x = (x + k%mod*a1) % mod;
                y = (y + k%mod*b) % mod;
                k = 0;
            } else if (type == 'R') {
                pii t(a1, -b);
                t = mpow(t, k);
                a1 = t.first; b = -t.second;
                a = id(8);
                for (int i = 0; i < 4; i += 2) {
                    a[i][i] = a1; a[i][i+1] = b;
                    a[i+1][i] = -b; a[i+1][i+1] = a1;
                }
                k = 1;
            }
        }
        vvl a0 = a;
        a = mul(a, a);
        //out(a);
        a = mpow(a, k/2);
        if (k % 2) a = mul(a, a0);
        if (k % 2 && cntc) {
            y *= -1;
        }
        eval(x, y, a);
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.107
expert
----------
PROBLEM STATEMENT:
Gru wanted to upgrade the quality of his minions' despicableness through his new base, The Volcano. Dave, desperately wanting the Minion of the Year award, rushed to The Volcano only to find out that he needs to solve a series of questions before he can unlock the gate and enter.

Dave is given a prime [expression] questions.

In each question/query, Dave is given four integers [expression].

Unfortunately, the gate has a strict time limit, and if Dave is unable to answer all questions quickly and correctly, then a hidden freeze ray will zap him and he won't be able to move. Please help Dave answer all the questions so he can enter The Volcano and win the Minion of the Year award!

Input Format 
The first line of input consists of an integer, [expression], which is the number of test cases.

The first line of each test case consists of two integers separated by a space, [expression].

Output Format 
For each query, output a single line containing the minimum value of [expression] exist.

Constraints 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] is prime  

Sample Input  

2
7 2
1 1 1 5
7 8 8 7
11 5
1 1 1 1
0 1 2 3
3 2 1 0
9 8 7 6
0 0 1 1


Sample Output  

7
wala
2
1
wala
33
0


Explanation 
For the first query, [expression]).

For the second query, no matter what [expression], so the answer is wala.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
typedef long long LL;
using namespace std;
int MOD;
const int SIZE = 1e6+10;
int root;
LL mypow(LL x,LL y){
    LL res=1;
    while(y){
        if(y&1)res=res*x%MOD;
        y>>=1;
        x=x*x%MOD;
    }
    return res;
}
int find_root(int P){
    if(P==2)return 1;
    vector<int>fac;
    for(int i=2;i*i<=P-1;i++){
        if((P-1)%i==0)fac.PB(i),fac.PB(P/i);
    }
    int now=2;
    while(1){
        bool err=0;
        REP(i,SZ(fac)){
            if(mypow(now,fac[i])==1){
                err=1;
                break;
            }
        }
        if(!err)break;
        now++;
    }
    return now;
}
vector<pair<int,int> >pp;
int half,hv;
void pre(int P){
    root=find_root(P);
    int now=1;
    pp.clear();
    pp.PB(MP(1,0));
    for(int i=1;i<P-1&&i<=1000000;i++){
        now=(LL)now*root%P;
        pp.PB(MP(now,i));
        half=i;
        hv=now;
    }
    hv=mypow(hv,MOD-2);
    sort(ALL(pp));
}
int get_id(int x){
    int ans=0;
    int it;
    while(1){
        it=lower_bound(ALL(pp),MP(x,0))-pp.begin();
        if(it!=SZ(pp)&&pp[it].F==x)break;
        ans+=half;
        x=(LL)x*hv%MOD;
    }
    return pp[it].S+ans;
}
// a*x+b*y=z
struct gcd_t {long long x,y,z;};
gcd_t gcd(long long a,long long b) {
    if(b==0)return (gcd_t){1,0,a};
    gcd_t t=gcd(b,a%b);
    return (gcd_t){t.y,t.x-t.y*(a/b),t.z};
}
int main(){
    CASET{
        DRII(P,N);
        MOD=P;
        pre(P);
        while(N--){
            DRII(A,B);
            DRII(C,D);
            if(A<B){swap(A,B);swap(C,D);}
            if(C%P==0&&D%P==0){
                printf("%d\n",A+B);
            }
            else if(C%P==0||D%P==0)puts("wala");
            else{
                C%=P;
                D%=P;
                if(P==2){
                    printf("%d\n",A+B);
                    continue;
                }
                C=get_id(C);
                D=get_id(D);
                if(C==0&&D==0){
                    printf("%d\n",A+B);
                    continue;
                }
                else if(C==0){
                    int gg=__gcd(D,P-1);
                    printf("%lld\n",A+(LL)B*(P-1)/gg);
                    continue;
                }
                else if(D==0){
                    int gg=__gcd(C,P-1);
                    printf("%lld\n",B+(LL)A*(P-1)/gg);
                    continue;
                }
                int M=P-1;
                {
                    int ha=__gcd(C,__gcd(D,M));
                    C/=ha;
                    D/=ha;
                    M/=ha;
                }
                int gg1=__gcd(D,M);
                int M2=M/gg1;
                LL now1=gg1/__gcd(gg1,C);
                gcd_t ker=gcd(D,M);
                while(ker.x<0)ker.x+=M2;
                LL now2=C*now1/ker.z%M2*ker.x%M2;
                D=now1;
                C=now2;
                if(now2==0)now2=M2;
                LL mi=A*now1+B*now2;
                while((LL)A*(now1+D)<mi){
                    now1+=D;
                    now2+=C;
                    if(now2>M2)now2-=M2;
                    mi=min(mi,A*now1+B*now2);
                }
                cout<<mi<<endl;
            }
        }
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.108
advanced
----------
PROBLEM STATEMENT:
Limak is a little bear who loves school. Today was his first lesson in cryptography, and the teacher assigned some difficult homework—to find any number with exactly [expression] divisors. Limak wants to go the extra mile and find the biggest possible number; however, his teacher explained that there are arbitrarily large numbers with this property. 

To give this little bear a more achievable challenge, the teacher advised him to consider only numbers not greater than [expression]. 

Given [expression], what is the largest number Limak can find?
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

const int MAX = 1000010;

bool prime[MAX];
int np, p[MAX];
long long ans;
long long n;
bool used[MAX];
int cnt, power[42];
long long smallest[42];

inline long long max_prime_power(long long up, int pw) {
  if (pw == 1) {
    while (up >= 2) {
      if (up < MAX) {
        if (prime[up] && !used[up]) {
          return up;
        }
      } else {
        bool pr = true;
        for (int i = 0; i < np && p[i] * 1LL * p[i] <= up; i++) {
          if (up % p[i] == 0) {
            pr = false;
            break;
          }
        }
        if (pr) {
          return up;
        }
      }
      up--;
    }
    return -1;
  }
  int low = -1, high = np - 1;
  while (low < high) {
    int mid = (low + high + 1) >> 1;
    long long z = 1;
    for (int j = 0; j < pw; j++) {
      z *= p[mid];
      if (z > up) {
        break;
      }
    }
    if (z > up) {
      high = mid - 1;
    } else {
      low = mid;
    }
  }
  while (low >= 0 && used[p[low]]) {
    low--;
  }
  if (low == -1) {
    return -1;
  }
  long long z = 1;
  for (int j = 0; j < pw; j++) {
    z *= p[low];
  }
  return z;
}

inline long long max_diff_primes(long long up, int cc) {
  while (up >= 2) {
    bool good = true;
    int diff = 0;
    long long tmp = up;
    for (int i = 0; i < np; i++) {
      if (p[i] * 1LL * p[i] > tmp) {
        break;
      }
      if (tmp % p[i] == 0) {
        if (used[p[i]]) {
          good = false;
          break;
        }
        diff++;
        tmp /= p[i];
        if (tmp % p[i] == 0) {
          good = false;
          break;
        }
      }
    }
    if (tmp > 1) {
      diff++;
    }
    if (good && diff == cc) {
      return up;
    }
    up--;
  }
  return -1;
}

int id[42];

void go(int v, long long num) {
  if (v == cnt - 1) {
    long long up = n / num;
    long long z = max_prime_power(up, power[v]);
    if (z == -1) {
      return;
    }
    ans = max(ans, num * z);
    return;
  }
  if (power[v] == 1) {
    long long up = n / num;
    long long z = max_diff_primes(up, cnt - v);
    if (z == -1) {
      return;
    }
    ans = max(ans, num * z);
    return;
  }
  int start = 0;
  if (v > 0 && power[v - 1] == power[v]) {
    start = id[v - 1] + 1;
  }
  for (int i = start; i < np; i++) {
    if (used[p[i]]) {
      continue;
    }
    long long bound = n / smallest[v + 1];
    long long new_num = num;
    for (int j = 0; j < power[v]; j++) {
      new_num *= p[i];
      if (new_num > bound) {
        break;
      }
    }
    if (new_num > bound) {
      break;
    }
    {
      long long test = new_num;
      bool bad = false;
      for (int w = v + 1; w < cnt; w++) {
        if (power[w] != power[v]) {
          break;
        }
        long long new_bound = n / smallest[w + 1];
        for (int j = 0; j < power[w]; j++) {
          test *= p[i];
          if (test > new_bound) {
            bad = true;
            break;
          }
        }
      }
      if (bad) {
        break;
      }
    }
    used[p[i]] = true;
    id[v] = i;
    go(v + 1, new_num);
    used[p[i]] = false;
  }
}

void factor(int k, int cur, vector <int> powers) {
  if (cur == 1) {
    if (k > 1) {
      return;
    }
    cnt = powers.size();
    for (int i = 0; i < cnt; i++) {
      power[i] = powers[i];
    }
    for (int i = 0; i <= cnt; i++) {
      smallest[i] = 1;
      for (int j = i; j < cnt; j++) {
        for (int u = 0; u < power[j]; u++) {
          smallest[i] *= p[j - i];
        }
      }
    }
    go(0, 1);
    return;
  }
  factor(k, cur - 1, powers);
  if (k % cur == 0) {
    powers.push_back(cur - 1);
    factor(k / cur, cur, powers);
  }
}

int main() {
  for (int i = 2; i < MAX; i++) {
    prime[i] = true;
  }
  np = 0;
  for (int i = 2; i < MAX; i++) {
    if (prime[i]) {
      p[np++] = i;
      if (i * 1LL * i >= MAX) {
        continue;
      }
      for (int j = i * i; j < MAX; j += i) {
        prime[j] = false;
      }
    }
  }
  for (int i = 0; i < np; i++) {
    used[i] = false;
  }
  int tt;
  cin >> tt;
  while (tt--) {
    int k;
    cin >> n >> k;
    ans = -1;
    if (k == 1) {
      ans = 1;
    } else {
      factor(k, k, vector <int> ());
    }
    cout << ans << endl;
  }
  return 0;
}

----------
====================
----------
MATHEMATICS.109
medium
----------
PROBLEM STATEMENT:
Jim is doing his discrete maths homework which requires him to repeatedly calculate nCr(n choose r) for different values of n. Knowing that this is time consuming, he goes to his sister June for help. June,  being a computer science student knows how to convert this into a computer program and generate the answers quickly. She tells him, by storing the lower values of nCr(n choose r), one can calculate the higher values using a very simple formula. 

If you are June, how will you calculate nCr values for different values of n?

Since [expression].  

Input Format 
The first line contains the number of test cases T. 
T lines follow each containing an integer n. 

Output Format 
For each n output the list of nC0 to nCn each separated by a single space in a new line. If the number is large, print only the last 9 digits. i.e. modulo 109

Constraints 
1
1

Sample Input

3
2
4
5


Sample Output

1 2 1
1 4 6 4 1
1 5 10 10 5 1


Explanation 
For 2 we can check 2C0  2C1 and 2C2 are 1, 2 and 1 respectively. The other inputs' answer follow similar pattern. 
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
#define llu unsigned long long
#define MOD 1000000000

llu arr[1001][1001];
void pascalTriangle(int n)
{
  for (int line = 0; line < n; line++)
  {
    for (int i = 0; i <= line; i++)
    {
      if (line == i || i == 0)
           arr[line][i] = 1;
      else 
           arr[line][i] = (arr[line-1][i-1] + arr[line-1][i])%MOD;
    }
  }
}
int main()
{
    pascalTriangle(1000);
    llu t, n;
    cin>>t;
    while(t--)
    {
        cin>>n;
        for(int i=0;i<=n;i++)
        {
            cout<<arr[n][i]<<" ";
        }
        cout<<"\n";
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.110
medium
----------
PROBLEM STATEMENT:
The Indian bank issues coins in 4 denominations, ₹1, ₹2, ₹5 and ₹10. 

Given a limited supply of each of the above denominations, in how many ways can you sum them up to a total of ₹N?

Input Format 
The first line contains an integer T (number of testcases). 
Each testcase contains 2 lines. The first line contains integer N (sum to be achieved) 
A, B, C and D in the next line, each representing the number of ₹1, ₹2, ₹5 and ₹10 coins respectively. 

Output Format 
Output the number of ways in which we can achieve the sum N.   

Constraints 
1 
1 
1 
1 

Sample Input  

2
15
2 3 1 1
12
2 2 1 1


Sample Output

2
2


Explanation 
In the first case we need to find the different ways to total to 15. 
We can use one ₹10 coin and one ₹5 coin  or one ₹10 coin two ₹2 coin and one ₹1 coin. Proceed similarly for the second case.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int n,a,b,c,t,d;
long long sol=0;

int main() {
    
    cin >> t;
    
    while (t>0)
    {
    sol=0;
    
        cin >> n;
    cin >> a >> b >> c >> d;
        
    for(int i=0;i<=c;i++)
        for(int j=0;j<=d;j++)
    {
        int z=(n-5*i-10*j);
        if (z>=0)
        {
            int l=max(0,z-a);
            int r=z;
            
            if (l%2==1) l++;
            if (r%2==1) r--;
            
            if (l<=r)
            {
            l/=2;
            r/=2;
            
                if (b>=r) sol+=r-l+1;
                else
                    if (b>=l)
                    sol+=b-l+1;
            
            }
        }
    }
    
    cout << sol << endl;
    t--;
    }
    
    
    
    return 0;
}

----------
====================
----------
MATHEMATICS.111
medium
----------
PROBLEM STATEMENT:
Chan has decided to make a list of all possible combinations of letters of a given string S. If there are two strings with the same set of characters, print the lexicographically smallest arrangement of the two strings. 

abc acb cab bac bca


all the above strings' lexicographically smallest string is abc. 

Each character in the string S is unique. Your task is to print the entire list of Chan's in lexicographic order. 

for string abc, the list in lexicographic order is given below

a ab abc ac b bc c


Input Format 
The first line contains the number of test cases T. T testcases follow. 
Each testcase has 2 lines. The first line is an integer N ( the length of the string). 
The second line contains the string S.  

Output Format 
For each testcase, print the entire list of combinations of string S, with each combination of letters in a newline.

Constraints 
0
1
string S contains only small alphabets(a-z) 

Sample Input

2
2
ab
3
xyz


Sample Output

a
ab
b
x
xy
xyz
xz
y
yz
z


Explanation 
In the first case we have ab, the possibilities are a, ab and b. Similarly, all combination of characters of xyz. 
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int t;
    scanf("%d",&t);
    for(int i=0; i<t; i++)
    {
        int len;
        scanf("%d",&len);
        string s;
        cin>>s;
        vector<int> count(26);
        for(int j=0; j<26; j++)
            count[j]=0;
        for(int j=0; j<len; j++)
            count[s[j]-'a']++;

        vector<vector<string> > val;
        vector<string> temp_vec, temp_vec2;
        
        char ch='z';
        for(int j=25; j>=0; j--)
        {
            string s=(string)""+ch;
            if(count[j]!=0)
            {
                temp_vec.clear();
                temp_vec.push_back(s);
                temp_vec2.clear();
                for(int k=1; k<count[j]; k++)
                    temp_vec.push_back(temp_vec[k-1]+ch);
                for(int k=0; k<count[j]; k++)
                    temp_vec2.push_back(temp_vec[k]);
                
                for(int k=count[j]-1; k>=0; k--)
                {
                    int len1=val.size();
                    for(int a=len1-1; a>=0; a--)
                    {
                        int len2=val[a].size();
                        for(int b=0; b<len2; b++)
                        {
                            temp_vec2.push_back(temp_vec[k]+val[a][b]);
                        }
                    }
                }
                
                val.push_back(temp_vec2);
             }
            ch--;
        }
        
        int len1=val.size();
        for(int a=len1-1; a>=0; a--)
        {
            int len2=val[a].size();
            for(int b=0; b<len2; b++)
            {
                cout<<val[a][b]<<"\n";
            }
        }
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.112
medium
----------
PROBLEM STATEMENT:
Shashank is very excited after learning about the linked list. He learned about how to merge two linked lists. When we merge two linked lists, the order of the elements of each list doesn't change. For example, if we merge [expression]. 

Shashank wants you to solve a problem for him: You are given two lists having sizes [expression]. 
----------
TOP SOLUTION:
----------
#include <iostream>
using namespace std;

long modulus_of_power(long a, long x, long p) {
    
    long res = 1;
    while(x > 0) {
        if( x % 2 != 0) {
            res = (res * a) % p;
        }
        a = (a * a) % p;
        x /= 2;
    }
    return res;
}

long modulus_of_ncr(long n, long k, long p) {

    long num = 1;
    for (int i=0; i<k; i++) {
        num = (num * (n-i) ) % p;
    }

    long den = 1; 
    for (int i=1; i<=k; i++) {
        den = (den * i) % p;
    }

    return ( num*modulus_of_power(den, p-2, p)) % p;
}
int main()
{
     int t;
     long x=1000000007,n,m;
    cin>>t;
    while(t-->0)
    {
        cin>>n>>m;
        cout<<modulus_of_ncr(m+n,m,x)<<endl;
    }
        
     
    return 0;
}

----------
====================
----------
MATHEMATICS.113
easy
----------
PROBLEM STATEMENT:
Welcome to the exciting class of Professor Manasa. In each lecture she used to play some game while teaching a new concept. Today's topic is Set Theory. For today's game, she had given a set A = {a1, a2, ...aN} of N integers to her students and asked them to play the game as follows.  

At each step of the game she calls a random student and asks him/her to select a non-empty subset from set A such that this subset had not been selected earlier and the sum of subset should be even. This game ends when all possible subsets had been selected. Manasa needs your help in counting the total number of times students can be called assuming each student gives the right answer. While it is given that if two numbers are same in the given set, they have different colors. It means that if a1 = a2, then choosing a1 and choosing a2 will be considered as different sets. 

Note  


Two subsets are different if there exists an element (ak) that is present in one subset but not in other. Let's say set A = {a1, a2, a3} = {2, 2, 3}, then all possible subsets are {}, {a1}, {a2}, {a3}, {a1, a2}, {a1, a3}, {a2, a3}, {a1, a2, a3} which is equivalent to {}, {2}, {2}, {3}, {2, 2}, {2, 3}, {2, 3}, {2, 2, 3}.  
Students can be called multiple times.  


Input Format 
The first line contains an integer N i.e. size of set A. 
Next line will contain N integers, each representing an element of A.  

Output Format 
Print number of time students are called. As this number can be very large you have to print the answer modulo (109 + 7). 

Constraints 
1 ≤ N ≤ 105 
0 ≤ ai ≤ 104 , where i ∈ [1 .. N]

Sample Input 00  

4
2 4 6 1


Sample Output 00  

7


Sample Input 01  

3
1 2 2


Sample Output 01  

3


Explanation 
There are 7 different ways in which a non-empty subset, with even sum, can be selected, i.e., {2}, {4}, {6}, {2, 4}, {2, 6}, {4, 6}, {2, 4, 6}.

For second sample test case, there are 3 different ways in which a non-empty subset, with even sum, can be selected, i.e., {a2}, {a3}, {a2, a3} which is equivalent to {2}, {2}, {2,2}.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define M 1000000007

using namespace std;

int n;
int a[100005];
long long dp[100005][2];

long long f(int idx, int flag)
{
    if ( idx == n ) {
         if ( !flag ) return 1;
         return 0;
    }
    long long &ans = dp[idx][flag];
    if ( ans != -1 ) return ans;
    ans = 0;
    ans += f(idx+1,flag)%M;
    ans %= M;
    ans += f(idx+1, (flag+a[idx])%2)%M;
    ans %= M;
    return ans;
}

int main()
{
    cin >> n;
    for ( int i = 0; i < n; i++ ) cin >> a[i];
    memset(dp, -1, sizeof(dp));
    long long ans = f(0,0);
    ans = (ans-1)%M;
    cout << ans << endl;
    return 0;
}

----------
====================
----------
MATHEMATICS.114
hard
----------
PROBLEM STATEMENT:
Mehta is a very rich guy. He has [expression] types of coins, and each type of coin is available in an unlimited supply.  

So Mehta goes to a supermarket to buy monthly groceries. There he sees that every item has a unique price, that is, no two items have the same price.  

Now, the supermarket owner tells Mehta that they are selling items in the price range [expression] only on that particular day. He also tells Mehta that for every price, there is an item in the shop.  

The supermarket has recently adopted a weird new tradition: Mehta may only use a single type of coin for each item he purchases. For example, he could pay for an item of price 4 with two 2-coins, but not with a 3-coin and a 1-coin.  

As you know Mehta is very weak at calculations, so he wants you to do these calculations for him and tell how many different types of items he can buy.  

Input Format 
The first line of input contains [expression], the number of types of coins Mehta has. 
Then the next [expression], the value of Mehta's ith type of coin.  

Then the next line contains a number [expression], the number of days Mehta goes shopping. 
Then each of the next [expression] on that particular day.  

Output format 
There will be [expression] lines, each containing the number of distinct items that can be bought at that particular day.  

Constraints 
[expression] 
[expression] 
[expression] 
[expression]  

Sample Input  

4
2
3
4
5
3
1 10
2 20
3 7


Sample output

8
14
4


Explanation 
For [expression]. 
For [expression]. 
For [expression].  
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
#define ll long long int
#define MOD 1000000007
using namespace std;
ll gcd(ll a,ll b)
{
    if(b==0)
        return a;
    else return (ll)gcd(b,a%b);
}
ll lcm(ll a,ll b)
{
    return ((ll)(a*b)/(gcd(a,b)));
}
void func(ll Lcm,ll cnt,ll A[],ll x,ll n,ll& ans,ll l,ll r)
{
    if(cnt%2==0)
    {
        ans+=((r/Lcm)-l/Lcm);
            if(l%Lcm==0)
                ans++;
    }
    else{
        ans-=((r/Lcm)-l/Lcm);
            if(l%Lcm==0)
                ans--;
    }
    for(ll i=x+1;i<n;i++)
        {
            ll L=lcm(Lcm,A[i]);
            func(L,cnt+1,A,i,n,ans,l,r);
        }
}
int main()
{
    ll n,d,l,i,k,r,ans=0,j,p;
    cin>>n;
    ll A[n],B[n];
    for(i=0;i<n;i++)
        cin>>A[i];
   cin>>d;
   while(d--)
   {
       ans=0;
    cin>>l>>r;
    for(i=0;i<n;i++)
        func(A[i],0,A,i,n,ans,l,r);
    cout<<(ll)ans<<endl;
   }
    return 0;
}

----------
====================
----------
MATHEMATICS.115
medium
----------
PROBLEM STATEMENT:
Animesh and Mohit are playing a game. They have [expression].  

Input Format 
The first line contains two integers [expression]. 
The next line will contain a list having [expression] numbers.  

Output Format 
Print the value of [expression].  

Constraints 
[expression] 
[expression] 
[expression]  

Sample Input  

4 2
10 20 30 40


Sample Output  

100


Explanation

There are 6 possible selections. 
1. 10 20 
2. 20 30 
3. 30 40 
4. 10 30 
5. 20 40 
6. 10 40 
Summation = 10+10+10+20+20+30 = 100
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cmath>
#include <cstdlib>
#define ull unsigned long long
#define MODNUM 1000000007
using namespace std;

int cmp(const void* a,const void* b)
{
    return *(int*)a - *(int*)b;
}
ull powMod(ull a,int power)
{
    if(power==0)
        return 1L;
    ull temp=powMod(a,power/2);
    if(power%2==1)
        return ((((temp%MODNUM)*a)%MODNUM)*temp)%MODNUM;
    return (temp*temp)%MODNUM;
}

void findCombinations(ull comb[],int sizeC,int K)
{
    comb[0]=1;
    for(int i=1;i<sizeC;i++){
      //  cout<<(comb[i-1]*(K+i-1))<<" : "<<powMod((ull)i,MODNUM-2)<<endl;
        comb[i]=((ull)((comb[i-1]*(K+i-1))%MODNUM)*powMod(i,MODNUM-2))%MODNUM;
    }
}

int main()
{
    //cout<<powMod(2,5)<<endl;


    int N,K;
    cin>>N>>K;
    int A[N];
    for(int i=0;i<N;i++){
        cin>>A[i];
    }
    ull comb[N-K+1];
    findCombinations(comb,N-K+1,K);
    qsort(A,N,sizeof(int),cmp);
    ull res=0;
    for(int i=K-1;i<N;i++){
        res=(res+(A[i]*comb[i-K+1])%MODNUM)%MODNUM;
    }
    for(int i=0;i<N-K+1;i++){
        res=(MODNUM+ res- (A[i]*comb[N-K-i])%MODNUM)%MODNUM;
    }
    cout<<res<<endl;
}

----------
====================
----------
MATHEMATICS.116
medium
----------
PROBLEM STATEMENT:
Sherlock is given an array of [expression].     

That is, Sherlock has to count the total number of pairs of indices [expression].

Input Format 
The first line contains [expression] test cases follow. 
Each test case consists of two lines; the first line contains an integer [expression] space separated integers.

Output Format 
For each test case, print the required answer on a different line. 

Constraints 
[expression] 
[expression] 
[expression]  

Sample input

2
3
1 2 3
3
1 1 2


Sample output   

0
2


Explanation 
In the first test case, no two pair of indices exist which satisfy the given condition. 
In the second test case as A[0] = A[1] = 1, the pairs of indices (0,1) and (1,0) satisfy the given condition.
----------
TOP SOLUTION:
----------
#include<math.h>
#include<algorithm>
#include<cstdlib>
#include<iostream>
#include<stdio.h>
#include<map>
#include<ext/hash_map>
#include<ext/hash_set>
#include<set>
#include<string>
#include<assert.h>
#include<vector>
#include<time.h>
#include<queue>
#include<deque>
#include<sstream>
#include<stack>
#include<sstream>
#define MA(a,b) ((a)>(b)?(a):(b))
#define MI(a,b) ((a)<(b)?(a):(b))
#define AB(a) (-(a)<(a)?(a):-(a))
#define X first
#define Y second
#define mp make_pair
#define pb push_back
#define pob pop_back
#define ep 0.0000000001
#define pi 3.1415926535897932384626433832795

using namespace std;
using namespace __gnu_cxx;
const int N=1001000;
const int Pint=1000000007;
const long long P=1000000007ll;
const long long INF=1001001001ll;

long long A,n,m;
int k,i,j,de;
int a[N];
int main()
{
   cin>>m;
   while (m--)
   {
       cin>>n;
       for (i=0;i<N;i++)a[i]=0;
       for (i=1;i<=n;i++) {cin>>k;a[k]++;}
       A=0;
       for (i=0;i<N;i++)A+=(long long)a[i]*(a[i]-1);
       cout<<A<<endl;

   }
    return 0;
}

----------
====================
----------
MATHEMATICS.117
medium
----------
PROBLEM STATEMENT:
Jigar got a sequence of n positive integers as his birthday present! He likes consecutive subsequences whose sum is divisible by k. He asks you to write a program to count them for him.

Input Format 
The first line contains T, the number of testcases. 
T testcases follow. Each testcase consists of 2 lines. 
The first line contains n and k separated by a single space. 
And the second line contains n space separated integers.

Output Format 
For each test case, output the number of consecutive subsequenences whose sum is divisible by k in a newline.

Constraints 
1 ≤ T ≤ 20 
1 ≤ n ≤ 106 
1 ≤ k ≤ 100 
1 ≤ a[i] ≤ 104 

Sample Input

2
5 3
1 2 3 4 1
6 2
1 2 1 2 1 2


Sample Output

4
9


Explanation

For 

1 2 3 4 1


there exists, 4 subsequences whose sum is divisible by 3, they are   

3
1 2
1 2 3
2 3 4


For 

1 2 1 2 1 2


there exists, 9 subsequences whose sum is divisible by 2, they are  

2
2
2
1 2 1
1 2 1
1 2 1 2
2 1 2 1
1 2 1 2
2 1 2 1 2

----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
using namespace std;
const int MAXD = 1000005;
int h[MAXD];
int main(){
  int C;
  scanf("%d", &C);
  while(C--){
    int d, n;
    scanf("%d %d", &n, &d);

    for (int i = 0; i < d; ++i) h[i] = 0;
    h[0] = 1;

    long long ans = 0, sum = 0;
    for (int i = 0; i < n; i++){
      int x; scanf("%d", &x);
      sum += (long long)x;
      ans += h[sum % d];
      h[sum % d]++;
    }
    printf("%lld\n", ans);
  }
   return 0;
}
----------
====================
----------
MATHEMATICS.118
medium
----------
PROBLEM STATEMENT:
You are given two integers, [expression] as a consecutive substring.
----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt(): x(0) { }
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }
	
	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	
	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }

};
template<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {
	ModInt<MOD> r = 1;
	while(k) {
		if(k & 1) r *= a;
		a *= a;
		k >>= 1;
	}
	return r;
}
typedef ModInt<1000000007> mint;

int main() {
	int T;
	scanf("%d", &T);
	rep(ii, T) {
		int N, M;
		scanf("%d%d", &N, &M);
		mint ans = mint(M) * (N == 1 ? 1 : mint(M-1) * (N == 2 ? 1 : mint(M-2) ^ (N-2)));
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.119
medium
----------
PROBLEM STATEMENT:
Krishnakant is standing at [expression] is one of the possible ways.   

Given the value of [expression].   

Input Format 
The first line contains an integer [expression] , i.e., number of test cases. 
Next [expression].  

Output Format 
For each test case, print lexicographically [expression] smallest path.  

Constraints 
[expression] 
[expression] 
[expression] 
[expression] 

Sample Input  

2
2 2 2
2 2 3


Sample Output  

HVVH
VHHV


Explanation

All the paths of going to [expression] in lexicographically increasing order:

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
----------
TOP SOLUTION:
----------
/* Author : Pranav
BITS PILANI Hyderabad Campus */
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <cstring>
//#include <sstream>
using namespace std;

#define sz(a) int((a).size())
#define pb push_back
#define pop pop_back
#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define present(c,x) ((c).find(x) != (c).end())
#define cpresent(c,x) (find(all(c),x) != (c).end())
#define fr(i,n) for(i=0; i<n; i++)
#define N 10005
#define INF 1000000
#define mod 1000000007
#define f first
#define s second
#define mp(x,y) make_pair(x,y)
#define sc(x) scanf("%lld",&x);
#define pr(x) printf("%lld\n",x);
typedef long long ll;
ll fact[30]={0};
ll compute(ll x,ll y){

if(x>=y)
      return fact[x]/(fact[x-y]*fact[y]);
      else{
          return 0;
      }
}
void findKthPermutation(ll k,ll n,ll m){
    ll partition;

    if(n==1&&m==0){
        cout<<"H";return;
    }
    if(n==0&&m==1){
        cout<<"V";return;
    }
    

    partition=compute(n+m-1,m);
   // cout<<partition<<endl;
    
    if(k<=partition){
        cout<<"H";
        findKthPermutation(k,n-1,m);
    }
    else{
        cout<<"V";
        findKthPermutation(k-partition,n,m-1);
    }
    return ;
}

int main(){
    ll t,n,m,k;
    ios::sync_with_stdio(0);
    cin>>t;
   //t=1;
    fact[0]=1;
    for(ll i=1;i<30;i++){
        fact[i]=fact[i-1]*i;
    }
    while(t--){
        cin>>n>>m>>k;
        k++;

        findKthPermutation(k,n,m);
        cout<<endl;


    }
    return 0;
 }
----------
====================
----------
MATHEMATICS.120
medium
----------
PROBLEM STATEMENT:
Sam is playing with an array, [expression]'s contiguous subarrays, and then replaces each subarray with its respective maximum element.

For example, consider the following [expression]: 
[expression] 
Subarrays of [expression] 
Updated (Maximum) Subarrays: [expression]

Help Sam determine how many numbers in [expression].
----------
TOP SOLUTION:
----------
/*
*/
 
//#pragma comment(linker, "/STACK:16777216")
#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <ctime> 
 
#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
 
#define eps 1e-9
//#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 256
#define right adsgasgadsg
#define free adsgasdg
#define MAGIC 47

using namespace std;

long tests,n,k,r,ar[1<<20];
long long ans;

int main(){
//freopen("k.in","r",stdin);
//freopen("k.out","w",stdout);
//freopen("C:/input.txt","r",stdin);
//freopen("C:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);
//cin.tie(0);

cin>>tests;
for (;tests;--tests)
{
 cin>>n>>k;
 r=n+1;
 for (int i=1;i<=n;i++)
  cin>>ar[i];
 ans=0;
 for (int i=n;i;--i)
 {
  if (ar[i]>k)r=i;
  ans+=(n-r+1);
 }
 cout<<ans<<endl;
}
cin.get();cin.get();
return 0;}



----------
====================
----------
MATHEMATICS.121
hard
----------
PROBLEM STATEMENT:
This follows from Game of Thrones - I.

Now that the king knows how to find out whether a given word has an anagram which is a palindrome or not, he encounters another challenge. He realizes that there can be more than one palindrome anagrams for a given word. Can you help him find out how many palindrome anagrams are possible for a given word ?

The king has many words. For each given word, he needs to find out the number of palindrome anagrams of the string. As the number of anagrams can be large, the king needs the number of anagrams % (109+ 7).

Input format :
A single line which contains the input string

Output format : 
A single line which contains the number of anagram strings which are palindrome % (109 + 7).

Constraints : 
1
Each character of the string is a lowercase alphabet. 
Each test case has at least 1 anagram which is a palindrome. 

Sample Input 01 :

aaabbbb


Sample Output 01 :

3 


Explanation : 
Three palindrome permutations of the given string are abbabba , bbaaabb and bababab.

Sample Input 02 :

cdcdcdcdeeeef


Sample Output 02 :

90

----------
TOP SOLUTION:
----------
/*
AUTHOR : VUAcoder
LANGUAGE : C++
PROBLEM :
*/

#include<iostream>
#include<stdio.h>
#include<math.h>
#include<string.h>
#include<algorithm>
#include<string>
#include<vector>
#include<map>
#include<queue>
#include<stack>
#include<sstream>
#include<set>
#include<fstream>
#include<cfloat>
using namespace std;
#define PI (2.*acos(0.))
#define EPS 1e-9
#define ZERO(x)     (fabs(x) < EPS)
#define EQ(a,b)     (ZERO((a)-(b)))
#define LESSER(a,b) (!EQ(a,b) && (a)<(b))
#define GREATER(a,b)(!EQ(a,b) && (a)>(b))
#define GETBIT(x,i) (x&(1<<i))
#define SETBIT(x,i) (x|(1<<i))
#define FORab(i,a,b) for(int i=(a);i<=(b);i++)
#define FOR(i,n) FORab(i,0,(n)-1)
#define FOR1(i,n) FORab(i,1,n)
#define FORit(it,a) for( typeof((a).begin()) it=(a).begin();it!=(a).end();it++)
#define all(a) (a).begin(),(a).end()
#define ms(a,b) memset((a),(b),sizeof(a))
#define pb push_back
#define sz(a) (int)a.size()
#define in(a,b,c) ((a) <= (b) && (b) <= (c))
#define px first
#define py second


typedef long long  LL;
typedef vector<int>   vi;
typedef pair<int,int>  pii;
LL fac[100100];
#define MOD 1000000007
LL bm(LL a,LL p,LL M)
{
    if(p==0)return 1;
    if(p%2==1)
    {
        LL x=bm(a,p-1,M);
        x*=a;
        x%=M;
        return x;
    }
    else
    {
        LL x=bm(a,p/2,M);
        x*=x;
        x%=M;
        return x;
    }
}
LL invmod(LL a){
    return bm(a,MOD-2,MOD);
}

int main()
{
    int t;
    //cin>>t;
	//while(t--)
	fac[0]=1;
	FOR1(i,100000)fac[i]=(fac[i-1]*i)%MOD;
	{
	    string s;
        cin>>s;

            int c1[100]={0};
        FOR(i,sz(s)){
                c1[s[i]-'a']++;
            }
            LL ans=0;
            FOR(i,26){
                //cout<<c1[i]<<endl;
                ans+=abs(c1[i])%2;
            }
            if(ans<=1){
                ans=fac[sz(s)/2];
                FOR(i,26){
                    //cout<<c1[i]<<endl;
                    ans*=invmod(fac[c1[i]/2]);
                    ans%=MOD;
                }
                cout<<ans<<endl;
            }
                else cout<<"0"<<endl;

        }


	return 0;
}

----------
====================
----------
MATHEMATICS.122
medium
----------
PROBLEM STATEMENT:
Elon Musk has succesfully built an automated staircase from Earth to Mars. Many people want to go to Mars, but that's not possible due to limited capacity of the staircase and logistics involved. Hence, Elon asks interested candidates to solve a tough challenge. If they solve it, they get a chance to visit Mars, otherwise not. Sam is highly interested in going to Mars. Can you help him solve the challenge? 
The staircase has N steps. One can either go step by step, or at each step, can take a jump of at most N steps. 

Elon is interested to know the number of ways in which you can go to Mars. Since the number of steps in stairs can be insanely large, Elon is only interested in the first and the last K digits of number of ways from which he can compute the actual answer with his algorithm.

Input Format
   First line is an integer T that denotes the number of test cases.
   Next T lines contain 2 integers each, N and K.

Output Format
  T lines. Each line corresponds to one of the test cases and contains the sum of numbers which are formed by first K digit and last K digits of number of ways.

Constraints

1<=T<=1000
1<=N<=10^9
1<=K<=9


If S is the number of ways in which one can climb the staircase, then 
the number of digits in S is greater or equal to the K.

Sample Input

2
10 2 
12 1


Sample Output

63
10


If there are 10 steps, let's call the number of ways in which one can go is 
S

let S be of the form wxyz. 

So, summing wx + yz gives 63.
----------
TOP SOLUTION:
----------
#include<iostream>
#include<stdio.h>
#include<cmath>
using namespace std;
typedef long long lint;
typedef long double double64;
lint powm(lint a,int b,lint MOD)
{
	lint ans=1;
	while(b)
	{
		if(b&1)
			ans=(ans*a)%MOD;
		a=(a*a)%MOD;
		b>>=1;	
	}
	return ans;
}
int main()
{
	int t,n,k,a,b,i,m;
	scanf("%d",&t);
	int A[]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};
	while(t--)
	{
		scanf("%d%d",&m,&k);
                m-=1;
                n=2;
		double64 logval = m * log10(1.0L*n);
		double64 mantissa = logval - floor(logval);
		logval = k-1 + mantissa;
		a=(int)(exp(logval*log(10)));
		b=powm((lint)(n),m,(lint)(A[k]));
		printf("%lld\n",((lint)a+(lint)b));		
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.123
medium
----------
PROBLEM STATEMENT:
Sherry likes matrices a lot, but her favorite ones are humble matrices. An [expression]) is humble if:


It contains all the elements in range [expression] exactly once.
For any [expression]:
If [expression] should hold. 


Given [expression].
----------
TOP SOLUTION:
----------
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include<cstdio>
#include<numeric>
#include<cstring>
#include<ctime>
#include<cstdlib>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<list>
#include<cmath>
#include<bitset>
#include<cassert>
#include<queue>
#include<stack>
#include<deque>
#include<cassert>
using namespace std;
typedef long long ll;
typedef long double ld;
const long long MOD = 1000 * 1000 * 1000 + 7;
long long facts[2 * 1000 * 1000 + 7];
int main()
{
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	int n, m;
	scanf("%d %d", &n, &m);
	facts[0] = 1;
	for (int i = 1; i <= n + m; i++)
	{
		facts[i] = (facts[i - 1] * i) % MOD;
	}
	long long ans = 1;
	if (n < m) swap(n, m);
	for (int i = 1; i < m; i++)
	{
		ans = (ans*facts[i]) % MOD;
		ans = (ans*facts[i]) % MOD;
	}
	for (int i = 1; i <= n + m - 1 - 2 * (m - 1); i++)
	{
		ans = (ans*facts[m]) % MOD;
	}
	printf("%lld\n", ans);
}

----------
====================
----------
MATHEMATICS.124
medium
----------
PROBLEM STATEMENT:
Tatyana is a big sports fan and she likes volleyball a lot! She writes down the final scores of the game after it has ended in her notebook. 

If you are not familiar with the rules of volleyball, here's a brief:


2 teams play in total
During the course of the game, each team gets points, and thus increases its score by 1. 
The initial score is 0 for both teams. 


The game ends when 


One of the teams gets 25 points and another team has 
If the score ties at 24:24, the teams continue to play until the absolute difference between the scores is 2.  


Given the final score of a game in the format A:B i.e., the first team has scored A points and the second has scored B points, can you print the number of different sequences of getting points by teams that leads to this final score? 

Input Format 
The first line contains A and the second line contains B.  

Constraints  

0 ≤ A , B ≤ 109

Output Format 
Output the number of different sequences of getting points by the teams that leads to the final score A : B. Final means that the game should be over after this score is reached. If the number is larger than 109+7, output number modulo 109 + 7. Print 0 if no such volleyball game ends with the given score. 

Example input #00

3
25


Example output #00

2925

Example input #01

24
17


Example output #01

0

Explanation #01

There's no game of volleyball that ends with a score of 24 : 17.
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <climits>
#include <cstring>
#include <map>
#include <queue>
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <iostream>
#include <stack>
#include <deque>
#include <list>
#include <unordered_map>
#include <unordered_set>
#include <cassert>
using namespace std;
#define FOR(i,c) for(auto &i: c)
#define SZ size()
#define ALL(x) (x).begin(),(x).end()
#define REP(i,n) for(int i=0;i<(n);i++)
#define REP1(i,a,b) for(int i=(a);i<=(b);i++)
#define REPL(i,x) for(int i=0;x[i];i++)
#define PER(i,n) for(int i=(n)-1;i>=0;i--)
#define PER1(i,a,b) for(int i=(a);i>=(b);i--)
#define RI(x) scanf("%d",&x)
#define RL(x) scanf("%lld",&x)
#define DRI(x) int x;RI(x)
#define DRL(x) LL x;RL(x)
#define RII(x,y) scanf("%d%d",&x,&y)
#define DRII(x,y) int x,y;RII(x,y)
#define RIII(x,y,z) scanf("%d%d%d",&x,&y,&z)
#define DRIII(x,y,z) int x,y,z;RIII(x,y,z)
#define RS(x) scanf("%s",x)
#define PI(x) printf("%d\n",x)
#define PL(x) printf("%lld\n",x)
#define PIS(x) printf("%d ",x)
#define MP make_pair
#define PB push_back
#define PQ priority_queue
#define E emplace
#define EB emplace_back
#define MS0(x) memset(x,0,sizeof(x))
#define MS1(x) memset(x,-1,sizeof(x))
#define SEP(x) ((x)?'\n':' ')
#define F first
#define S second
#define V(x) vector<x >

typedef pair<int,int> PII;
typedef vector<int> VI;
typedef long long LL;
typedef unsigned long long ULL;
const int INF = 2000000000;
const int MOD = 1000000007;
struct Z {
  int i;
  Z():i(0) {}
  Z(int i): i(i) {}
  void operator +=(const Z& z) { i += z.i; if(i >= MOD) i -= MOD; }
  void operator -=(const Z& z) { i -= z.i; if(i < 0) i += MOD; }
  void operator *=(const Z& z) { i = (LL) i * z.i % MOD; }
  void operator /=(const Z& z) { (*this) *= z.inverse(); }
  Z operator +(const Z& z) const { Z ret(i); ret += z; return ret; }
  Z operator -(const Z& z) const { Z ret(i); ret -= z; return ret; }
  Z operator *(const Z& z) const { Z ret(i); ret *= z; return ret; }
  Z operator /(const Z& z) const { return (*this) * z.inverse(); }
  // Z operator -() const { return Z(-i); }
  Z inverse() const {
    int a = i, d = MOD, x = 0, s = 1;
    while(a) {
      int q = d / a, r = d % a, t = x - q * s;
      d = a, a = r, x = s, s = t;
    }
    if (d != 1) return -1;
    return x < 0 ? x + MOD : x;
  }
  Z pow(int n) const {
    if(n == 0) return Z(1);
    Z tmp = pow(n / 2);
    if(n % 2) tmp *= (*this);
    return tmp;
  }
};

vector<Z> factorial(1, 1), inv_factorial(1, 1);

Z inv_fact(int n) {
  while(inv_factorial.size() <= n)
    inv_factorial.push_back(inv_factorial.back() / inv_factorial.size());
  return inv_factorial.at(n);
}

Z fact(int n) {
  while(factorial.size() <= n)
    factorial.push_back(factorial.back() * factorial.size());
  return factorial.at(n);
}

Z choose(int n, int k) {
  if(n < k) return 0;
  return fact(n) * (inv_fact(k) * inv_fact(n-k));
}
inline int mul(int a, int b, int mod=MOD) { return (LL)a * b % mod; }

template<class T>
T pow(T a, T b, T c=MOD){
  T x=1,y=a; // ll is taken to avoid overflow of intermediate results
  while(b > 0){
    if(b%2 == 1){
      x=mul(x, y, c);
    }
    y = mul(y, y, c); // squaring the base
    b /= 2;
  }
  return x%c;
}

int main() {
  DRII(A, B);
  if(A > B) swap(A, B);
  if(B < 25) {
    PI(0);
  } else if(B == 25) {
    if(A >= 24) {
      PI(0);
    } else
      PI(choose(A+B-1, A).i);
  } else {
    if(B - A == 2)
      PI((choose(48, 24) * pow(2, A-24)).i);
    else
      PI(0);
  }
  // PI(Z(2).pow(10).i);
  return 0;
}
----------
====================
----------
MATHEMATICS.125
easy
----------
PROBLEM STATEMENT:
There are N cards on the table and each has a number between 0 and N. Let us denote the number on the ith card by ci. You want to pick up all the cards. The ith card can be picked up only if at least ci cards have been picked up before it. (As an example, if a card has a value of 3 on it, you can't pick that card up unless you've already picked up 3 cards previously) In how many ways can all the cards be picked up?

Input Format 
The first line contains the number of test cases T. T test cases follow. Each case contains an integer N on the first line, followed by integers c1,..ci,...,cN on the second line.

Output Format 
Output T lines one corresponding to each test case containing the required answer for the corresponding test case. As the answers can be very big, output them modulo 1000000007.

Constraints: 
1 
1 
0 i 

Sample Input:  

3  
3  
0 0 0  
3  
0 0 1  
3  
0 3 3


Sample Output:  

6  
4  
0


Sample Explanations:

For the first case, the cards can be picked in any order, so there are 3! = 6 ways. 
For the second case, the cards can be picked in 4 ways: {1,2,3}, {2,1,3}, {1,3,2}, {2,3,1}.&nbsp; 
For the third case,&nbsp;no cards can be picked up after the first one, so there are 0 ways to pick up all cards.
----------
TOP SOLUTION:
----------

#include <map>
#include <utility>

#include <iostream>
#include <istream>
#include <ostream>

using namespace std;

#define M 1000000007LL

typedef long long mint;

mint cc(mint n, map<mint, mint> &freqs)
{
    mint res = 1;
    mint opts = 0;
    mint cur = 0;

    for (map<mint, mint>::iterator i = freqs.begin(); i != freqs.end(); ++i)
    {
        mint num = i->first;

        for (; cur != num; ++cur)
        {
            res = (res * opts) % M;

            --opts;

            if (opts < 0)
            {
                return 0;
            }
        }

        opts = (opts + i->second) % M;
    }

    for (; cur != n - 1; ++cur)
    {
        res = (res * opts) % M;

        --opts;

        if (opts < 0)
        {
            return 0;
        }
    }

    return res;
}

int main()
{
    mint t;

    cin >> t;

    for (; t; --t)
    {
        mint n;

        cin >> n;

        map<mint, mint> freqs;

        for (mint i = 0; i != n; ++i)
        {
            mint c;

            cin >> c;

            freqs[c] = (freqs[c] + 1) % M;
        }

        /*
        for (map<mint, mint>::iterator j = freqs.begin(); j != freqs.end(); ++j)
        {
            cout << "(" << j->first << ", " << j->second << ") ";
        }
        */

        cout << cc(n, freqs) << endl;
    }

    return 0;
}

----------
====================
----------
MATHEMATICS.126
medium
----------
PROBLEM STATEMENT:
You need to count the number of quadruples of integers (X1, X2, X3, X4),
such that Li ≤ Xi ≤ Ri for i = 1, 2, 3, 4
and X1 ≠ X2, X2 ≠ X3,
X3 ≠ X4, X4 ≠ X1.

The answer could be quite large. 
Hence you should output it modulo (109 + 7). 
That is, you need to find the remainder of the answer by (109 + 7).

Input Format 
The first line of the input contains an integer T denoting the number of test cases.
The description of T test cases follows.
The only line of each test case contains 8 space-separated integers
L1, R1, L2, R2, L3, R3, L4, R4, in order.

Output Format 
For each test case, output a single line containing the number of required quadruples modulo (109 + 7).

Constraints 
1 ≤ T ≤ 1000 
1 ≤ Li ≤ Ri ≤ 109

Sample Input

5
1 4 1 3 1 2 4 4
1 3 1 2 1 3 3 4
1 3 3 4 2 4 1 4
1 1 2 4 2 3 3 4
3 3 1 2 2 3 1 2


Sample Output  

8
10
23
6
5


Explanation 
Example case 1. All quadruples in this case are

1 2 1 4
1 3 1 4
1 3 2 4
2 1 2 4
2 3 1 4
2 3 2 4
3 1 2 4
3 2 1 4


Example case 2. All quadruples in this case are

1 2 1 3
1 2 1 4
1 2 3 4
2 1 2 3
2 1 2 4
2 1 3 4
3 1 2 4
3 1 3 4
3 2 1 4
3 2 3 4


Example case 3. All quadruples in this case are

1 3 2 3
1 3 2 4
1 3 4 2
1 3 4 3
1 4 2 3
1 4 2 4
1 4 3 2
1 4 3 4
2 3 2 1
2 3 2 3
2 3 2 4
2 3 4 1
2 3 4 3
2 4 2 1
2 4 2 3
2 4 2 4
2 4 3 1
2 4 3 4
3 4 2 1
3 4 2 4
3 4 3 1
3 4 3 2
3 4 3 4


Example case 4. All quadruples in this case are

1 2 3 4
1 3 2 3
1 3 2 4
1 4 2 3
1 4 2 4
1 4 3 4


Example case 5. All quadruples in this case are

3 1 2 1
3 1 3 1
3 1 3 2
3 2 3 1
3 2 3 2

----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt(): x(0) { }
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }
	
	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }
	
	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
	
	ModInt inverse() const {
		long long a = x, b = MOD, u = 1, v = 0;
		while(b) {
			long long t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		return ModInt(u);
	}
	
	bool operator==(ModInt that) const { return x == that.x; }
	bool operator!=(ModInt that) const { return x != that.x; }
	ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }
};
template<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {
	ModInt<MOD> r = 1;
	while(k) {
		if(k & 1) r *= a;
		a *= a;
		k >>= 1;
	}
	return r;
}
typedef ModInt<1000000007> mint;

struct UnionFind {
	static const int MAXN = 4;
	typedef char Index;	//???????????????????????????
	Index data[MAXN];
	void init(int size_) { memset(data, -1, size_ * sizeof(*data)); }
	bool unionSet(int x, int y) {
		x = root(x); y = root(y);
		if (x != y) {
			if (data[y] < data[x]) swap(x, y);
			data[x] += data[y]; data[y] = x;
		}
		return x != y;
	}
	inline bool findSet(int x, int y) { return root(x) == root(y); }
	inline int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }
	inline int size(int x) { return -data[root(x)]; }
};


int L[4], R[4];
int main() {
	int T;
	scanf("%d", &T);
	rep(ii, T) {
		rep(i, 4)
			scanf("%d%d", &L[i], &R[i]);
		UnionFind uf;
		mint ans = 0;
		rep(eqs, 1<<4) {
			uf.init(4);
			rep(i, 4) if(eqs >> i & 1)
				uf.unionSet(i, (i + 1) % 4);
			mint x = 1;
			rep(i, 4) if(uf.root(i) == i) {
				int LL = 0, RR = INF;
				rep(j, 4) if(uf.findSet(i, j)) {
					amax(LL, L[j]);
					amin(RR, R[j]);
				}
//				cerr << eqs << ", " << i << ": " << LL << ", "<< RR << endl;
				if(LL > RR) x = 0;
				else x *= RR + 1 - LL;
			}
			bool parity = 0;
			rep(i, 4) parity ^= eqs >> i & 1;
			if(parity) ans -= x; else ans += x;
		}
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.127
hard
----------
PROBLEM STATEMENT:
How many n-digit numbers (without leading zeros) are there such that no digit occurs more than k times?  

As the count of such n-digit numbers can be very large, print the answer mod (109+7)  

Input Format  

The first line contains an integer, T , the number of test cases. This is followed by T lines each containing 2 space separated integers, n and k  

Constraints  

T ≤ 100000 
1 ≤ n ≤ 1000 
1 ≤ k ≤ 109

Sample Input

2
2 3
2 1


Sample Output

90
81


Explanation 
Case 1: A number can appear three times. So we have 9 (all except 0) numbers for first digit and 10 numbers for the second digit. 
Case 2: A number can appear only once. So we have 9 choices for the first digit and 9(all except the first one) for the second digit. 
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
typedef long long LL;
using namespace std;
const int MOD = 1e9+7;
int C[1001][1001],dp[10][1001],ha[1001][1001][10],dp2[1001][1001];
int main(){
    REP(i,1001){
        C[i][0]=1;
        REPP(j,1,i+1){
            C[i][j]=C[i-1][j-1]+C[i-1][j];
            if(C[i][j]>=MOD)C[i][j]-=MOD;
        }
    }
    for(int i=1;i<=1000;i++){
        for(int j=1;j<=i;j++){
            ha[i][j][0]=1;
            for(int k=1;k*j<=i&&k<10;k++){
                ha[i][j][k]=(LL)ha[i][j][k-1]*C[i-(k-1)*j][j]%MOD;
            }
        }
    }
    int kerker=0;
    REP(i,9)dp[i][0]=1;
    REPP(i,1,1001){
        for(int j=9;j>=1;j--)
            for(int k=min(j*i,1000);k>=i;k--){
                for(int r=1;r*i<=k&&r<=j;r++){
                    dp[j][k]=(dp[j][k]+(LL)dp[j-r][k-r*i]*ha[k][i][r]%MOD*C[j][r])%MOD;
                }
            }
        for(int j=0;j<=min(i*9,1000);j++)dp2[i][j]=dp[9][j];
    }
    CASET{
        DRII(n,k);
        k=min(n,k);
        int an=0;
        for(int i=0;i<n&&i<=k;i++)an=(an+(LL)C[n-1][i]*dp2[k][n-i])%MOD;
        printf("%d\n",an);
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.128
medium
----------
PROBLEM STATEMENT:
We define the following:


A subsequence of an array is an ordered subset of the array's elements having the same sequential ordering as the original array. For example, the subsequences of array [expression].
The longest increasing subsequence of an array of numbers is the longest possible subsequence that can be created from its elements such that all elements are in increasing order.


Victoria has two integers, [expression]. She builds unique arrays satisfying the following criteria:


Each array contains [expression] integers.
Each integer is [expression].
The longest increasing subsequence she can create from the array has length [expression].


Given [expression].
----------
TOP SOLUTION:
----------
#include <stdexcept>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <cassert>
#include <cstring>
#include <cstdarg>
#include <cstdio>
#include <memory>
#include <random>
#include <cmath>
#include <ctime>
#include <functional>
#include <algorithm>
#include <complex>
#include <numeric>
#include <limits>
#include <bitset>
#include <vector>
#include <string>
#include <queue>
#include <deque>
#include <array>
#include <list>
#include <map>
#include <set>

using namespace std;

#define all(a) (a).begin(), (a).end()
#define sz(a) static_cast<int>((a).size())
#define FOR(i, a, b) for (int i(a), b_(b); i < b_; ++i)
#define REP(i, n) FOR (i, 0, n)
#define FORD(i, a, b) for (int i(a), b_(b); i >= b_; --i)
#define UNIQUE(a) sort(all(a)), (a).erase(unique(all(a)), (a).end())
#define CL(a, v) memset(a, v, sizeof a)
#define eb emplace_back
#define pb push_back
#define X first
#define Y second

typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using min_queue = priority_queue<T, vector<T>, greater<T>>;

const int INF = static_cast<int>(1e9);
const long long INF_LL = static_cast<long long>(4e18);
const double pi = acos(-1.0);

template <class T> inline T& smin(T& x, const T& y) { return x > y ? x = y : x; }
template <class T> inline T& smax(T& x, const T& y) { return x < y ? x = y : x; }
template <class T> inline T sqr(const T& x) { return x * x; }

template <class T> T gcd(T a, T b) {
  for (a = abs(a), b = abs(b); a && b; a >= b ? a %= b : b %= a);
  return a + b;
}

using uint = unsigned int;
// Buffer size should be 2^12 or 2^13 for optimal performance with files.
const uint BUFFER_SIZE = 1 << 12;
// Maximum possible length of a string representing primitive type
// assuming we won't encounter huge double values.
const uint MAX_LENGTH = 1 << 7;

namespace Detail {
  struct Width { uint value; };
  struct Fill { char value; };
  struct Base { uint value; };
  struct Precision { uint value; };
  struct Delimiter { const char* value; };
}  // namespace Detail

Detail::Width setWidth(uint value = 0) { return {value}; }
Detail::Fill setFill(char value = ' ') { return {value}; }
Detail::Base setBase(uint value = 10) { assert(2 <= value && value <= 36); return {value}; }
Detail::Precision setPrecision(uint value = 9) { assert(value < MAX_LENGTH); return {value}; }
Detail::Delimiter setDelimiter(const char* value = " ") { return {value}; }

/*************************************************** input classes ****************************************************/
class InputDevice {
protected:
  const char* head;
  const char* tail;

  InputDevice(const char* head, const char* tail) : head(head), tail(tail), base(setBase().value) {}
  InputDevice(InputDevice const&) = delete;
  InputDevice& operator = (InputDevice const&) = delete;

  virtual void fillInput() = 0;

  inline char nextChar() {
    if (__builtin_expect(head >= tail, false)) fillInput();
    return *head++;
  }

  template <class I> int readUnsignedIntGeneral(I& arg, char c) {
    I value = 0;
    int length = 0;
    for (;; ++length, c = nextChar()) {
      if (isDigit(c)) c -= '0';
      else if (isUpper(c)) c -= 'A' - 10;
      else if (isLower(c)) c -= 'a' - 10;
      else c = base;
      if (c >= base) break;
      value = base * value + c;
    }
    arg = value;
    return --head, length;
  }

  template <class I> inline int readUnsignedInt(I& arg, char c) {
    if (__builtin_expect(base > 10, false)) return readUnsignedIntGeneral(arg, c);
    I value = 0;
    int length = 0;
    for (; static_cast<unsigned char>(c - '0') < base; ++length, c = nextChar())
      value = base * value + c - '0';
    arg = value;
    return --head, length;
  }

  template <class I> inline bool readSignedInt(I& arg, char c) {
    bool negative = c == '-';
    if (negative) c = nextChar();
    typename make_unsigned<I>::type unsignedArg;
    if (readUnsignedInt(unsignedArg, c) == 0) return false;
    arg = negative ? ~static_cast<I>(unsignedArg - 1) : static_cast<I>(unsignedArg);
    return true;
  }

  template <class F> bool readFloatingPoint(F& arg, char c) {
    bool negative = c == '-';
    if (negative) c = nextChar();
    unsigned long long integerPart;
    if (readUnsignedInt(integerPart, c) == 0) return false;
    if (nextChar() == '.') {
      unsigned long long fractionalPart = 0;
      int fractionalLength = readUnsignedInt(fractionalPart, nextChar());
      if (fractionalLength > 0) {
        unsigned long long basePower = 1;
        for (; fractionalLength; --fractionalLength) basePower *= base;
        arg = static_cast<F>(fractionalPart) / basePower;
      }
    } else --head;
    arg += integerPart;
    if (negative) arg = -arg;
    return true;
  }

public:
  static inline bool isSpace(char c) { return static_cast<unsigned char>(c - '\t') < 5 || c == ' '; }
  static inline bool isDigit(char c) { return static_cast<unsigned char>(c - '0') < 10; }
  static inline bool isUpper(char c) { return static_cast<unsigned char>(c - 'A') < 26; }
  static inline bool isLower(char c) { return static_cast<unsigned char>(c - 'a') < 26; }
  static inline bool isOneOf(char c, const char* str) { return strchr(str, c) != nullptr; }

  uint base;
  void putBack() { --head; }  // can be called only once directly after successfully reading a character

  inline bool readChar(char& arg) {
    if (__builtin_expect(head >= tail, false)) {
      fillInput();
      if (__builtin_expect(head >= tail, false)) return arg = '\0', false;
    }
    return arg = *head++, true;
  }

  template <class UnaryPredicate>
  inline char skipCharacters(UnaryPredicate isSkipped) {
    char c;
    do { c = nextChar(); } while (isSkipped(c));
    return c;
  }
  inline char skipCharacters() { return skipCharacters(isSpace); }

  template <class UnaryPredicate>
  inline bool readString(char* arg, int limit, UnaryPredicate isTerminator) {
    skipCharacters(isTerminator);
    // put back first non-skipped character, reserve space for null character
    for (--head, --limit; head < tail; fillInput()) {
      ptrdiff_t chunkSize = find_if(head, min(tail, head + limit), isTerminator) - head;
      arg = copy_n(head, chunkSize, arg);
      head += chunkSize;
      limit -= chunkSize;
      if (chunkSize == 0 || head < tail) break;
    }
    return *arg = '\0', true;
  }

  template <class I> inline bool readUnsignedInt(I& arg) { return readUnsignedInt(arg, skipCharacters()) > 0; }
  template <class I> inline bool readSignedInt(I& arg) { return readSignedInt(arg, skipCharacters()); }
  template <class F> inline bool readFloatingPoint(F& arg) { return readFloatingPoint(arg, skipCharacters()); }
};

class InputFile : public InputDevice {
  FILE* file;
  bool lineBuffered;
  bool owner;
  char buffer[BUFFER_SIZE];

  void fillInput() override {
    head = buffer;
    *buffer = '\0';
    if (__builtin_expect(!lineBuffered, true)) {
      tail = head + fread(buffer, 1, BUFFER_SIZE, file);
    } else {
      tail = head;
      if (fgets(buffer, BUFFER_SIZE, file)) while (*tail) ++tail;
    }
  }

public:
  InputFile(FILE* file = stdin, bool lineBuffered = true, bool takeOwnership = false)
  : InputDevice(buffer, buffer) , file(file), lineBuffered(lineBuffered), owner(takeOwnership) {}
  InputFile(const char* fileName) : InputFile(fopen(fileName, "r"), false, true) {}
  ~InputFile() { if (owner) fclose(file); }
};

// Picks up data appended to the string but doesn't handle reallocation.
class InputString : public InputDevice {
  void fillInput() override { while (*tail) ++tail; }

public:
  InputString(const string& s) : InputDevice(s.data(), s.data() + s.size()) {}
  InputString(const char* s) : InputDevice(s, s + strlen(s)) {}
};

/*************************************************** output classes ***************************************************/
class OutputDevice {
protected:
  char buffer[BUFFER_SIZE + MAX_LENGTH];
  char* output;
  char* end;
  bool separate;

  OutputDevice() : output(buffer), end(buffer + BUFFER_SIZE + MAX_LENGTH), separate(false), width(setWidth().value)
  , fill(setFill().value), base(setBase().value), precision(setPrecision().value), delimiter(setDelimiter().value) {}
  OutputDevice(OutputDevice const&) = delete;
  OutputDevice& operator = (OutputDevice const&) = delete;

  virtual void writeToDevice(uint count) = 0;

  inline void flushMaybe() {
    if (__builtin_expect(output >= buffer + BUFFER_SIZE, false)) {
      writeToDevice(BUFFER_SIZE);
      output = copy(buffer + BUFFER_SIZE, output, buffer);
    }
  }

  template <class I> inline char* writeUnsignedInt(I arg, char* last) {
    if (__builtin_expect(arg == 0, false)) *--last = '0';
    if (__builtin_expect(base == 10, true)) {
      for (; arg; arg /= 10) *--last = '0' + arg % 10;
    } else for (; arg; arg /= base) {
      I digit = arg % base;
      *--last = digit < 10 ? '0' + digit : 'A' - 10 + digit;
    }
    return last;
  }

  template <class I> inline char* writeSignedInt(I arg, char* last) {
    auto unsignedArg = static_cast<typename make_unsigned<I>::type>(arg);
    if (arg < 0) {
      last = writeUnsignedInt(~unsignedArg + 1, last);
      *--last = '-';
      return last;
    }
    return writeUnsignedInt(unsignedArg, last);
  }

  template <class F> char* writeFloatingPoint(F arg, char* last) {
    bool negative = signbit(arg);
    if (negative) arg = -arg;
    if (isnan(arg)) for (int i = 0; i < 3; ++i) *--last = i["NaN"];
    else if (isinf(arg)) for (int i = 0; i < 3; ++i) *--last = i["fnI"];
    else {
      auto integerPart = static_cast<unsigned long long>(arg);
      arg -= integerPart;
      for (int i = 0; i < precision; ++i) arg *= base;
      auto fractionalPart = static_cast<unsigned long long>(arg);
      if ((arg - fractionalPart) * 2 >= static_cast<F>(1)) {
        if (precision == 0) ++integerPart;
        else ++fractionalPart;
      }
      if (precision > 0) {
        char* point = last - precision;
        last = writeUnsignedInt(fractionalPart, last);
        ::fill(point, last, '0');
        last = point;
        *--last = '.';
      }
      last = writeUnsignedInt(integerPart, last);
    }
    if (negative) *--last = '-';
    return last;
  }

  inline int writeT(char* first) {
    int delimiterLenght = separate ? writeDelimiter() : 0;
    separate = true;
    int charsWritten = static_cast<int>(end - first);
    if (__builtin_expect(charsWritten < width, false))
      charsWritten += writeFill(width - charsWritten);
    output = copy(first, end, output);
    flushMaybe();
    return delimiterLenght + charsWritten;
  }

  inline int writeFill(int count) {
    int result = count;
    if (__builtin_expect(output + count + MAX_LENGTH < end, true)) {
      if (count == 1) *output++ = fill;
      else output = fill_n(output, count, fill);
    } else for (uint chunkSize = static_cast<uint>(buffer + BUFFER_SIZE - output);; chunkSize = BUFFER_SIZE) {
      if (chunkSize > count) chunkSize = count;
      output = fill_n(output, chunkSize, fill);
      flushMaybe();
      if ((count -= chunkSize) == 0) break;
    }
    return result;
  }

public:
  int width;
  char fill;
  uint base;
  uint precision;
  string delimiter;

  inline int writeChar(char arg) { separate = false; *output++ = arg; flushMaybe(); return 1; }

  inline int writeString(const char* arg, int count, bool checkWidth = true) {
    separate = false;
    int result = count + (checkWidth && count < width ? writeFill(width - count) : 0);
    if (__builtin_expect(output + count + MAX_LENGTH < end, true)) {
      if (count == 1) *output++ = *arg;
      else output = copy_n(arg, count, output);
    } else for (int chunkSize = static_cast<int>(buffer + BUFFER_SIZE - output);; chunkSize = BUFFER_SIZE) {
      if (chunkSize > count) chunkSize = count;
      output = copy_n(arg, chunkSize, output);
      flushMaybe();
      if ((count -= chunkSize) == 0) break;
      arg += chunkSize;
    }
    return result;
  }

  inline int writeDelimiter() { return writeString(delimiter.c_str(), static_cast<int>(delimiter.size()), false); }

  template <class I> inline int writeUnsignedInt(I arg) { return writeT(writeUnsignedInt(arg, end)); }
  template <class I> inline int writeSignedInt(I arg) { return writeT(writeSignedInt(arg, end)); }
  template <class F> inline int writeFloatingPoint(F arg) { return writeT(writeFloatingPoint(arg, end)); }

  inline void flush() {
    writeToDevice(static_cast<uint>(output - buffer));
    output = buffer;
  }
  virtual ~OutputDevice() {};
};

class OutputFile : public OutputDevice {
  FILE* file;
  bool owner;

  void writeToDevice(uint count) override {
    fwrite(buffer, 1, count, file);
    fflush(file);
  }

public:
  OutputFile(FILE* file = stdout, bool takeOwnership = false) : file(file), owner(takeOwnership) {}
  OutputFile(const char* fileName) : OutputFile(fopen(fileName, "w"), true) {}
  ~OutputFile() override { flush(); if (owner) fclose(file); }
};

class OutputString : public OutputDevice {
  string& str;

  void writeToDevice(uint count) override { str.append(buffer, count); }

public:
  OutputString(string& str) : OutputDevice(), str(str) {}
  ~OutputString() override { flush(); }
};

/**************************************************** read & write ****************************************************/
//unique_ptr<InputDevice> input;
unique_ptr<InputFile> input;
//unique_ptr<OutputDevice> output;
unique_ptr<OutputFile> output;

// property setters
inline int read(Detail::Base base) { input->base = base.value; return 0; }
// primitive types
inline int read() { return 0; }
inline int read(char& arg) { return input->readChar(arg); }
template <class I> inline typename enable_if<is_integral<I>::value && is_unsigned<I>::value,
int>::type read(I& arg) { return input->readUnsignedInt(arg); }
template <class I> inline typename enable_if<is_integral<I>::value && is_signed<I>::value,
int>::type read(I& arg) { return input->readSignedInt(arg); }
template <class F> inline typename enable_if<is_floating_point<F>::value,
int>::type read(F& arg) { return input->readFloatingPoint(arg); }
// characters skip
inline int read(const char& arg) { input->skipCharacters([arg](char c) { return arg != c; }); return 0; }
inline int read(const char* arg) {
  if (*arg) input->skipCharacters([arg](char c) { return InputDevice::isOneOf(c, arg); });
  else input->skipCharacters();
  input->putBack(); return 0;
}
inline int read(bool (*isSkipped)(char)) { input->skipCharacters(isSkipped); input->putBack(); return 0; }
// forward declarations so everything compiles
template <class... Ts> int read(char* arg, int limit, bool (*isTerminator)(char), Ts&&... args);
template <class... Ts> int read(char* arg, int limit, const char* terminators, Ts&&... args);
template <class Iterator, class... Ts, typename = decltype(*std::declval<Iterator>())>
int read(Iterator first, Iterator last, Ts&&... args);
template <class Iterator, class... Ts, typename = decltype(*std::declval<Iterator>())>
int read(Iterator first, int count, Ts&&... args);
template <class T, class... Ts, typename = typename enable_if<!is_convertible<T, char*>::value, void>::type>
int read(T&& arg1, Ts&&... args);
// C strings
inline int read(char* arg, int limit, const char* terminators = "") {
  if (!*terminators) return input->readString(arg, limit, InputDevice::isSpace);
  else return input->readString(arg, limit, [terminators](char c) { return InputDevice::isOneOf(c, terminators); });
}
template <class... Ts>
inline int read(char* first, char* last, Ts&&... args) {
  return read(first, static_cast<int>(last - first), forward<Ts>(args)...);
}
template <int N, class... Ts>
inline int read(char (&arg)[N], Ts&&... args) { return read(static_cast<char*>(arg), N, forward<Ts>(args)...); }
template <class... Ts>
inline int read(char* arg, int limit, bool (*isTerminator)(char), Ts&&... args) {
  int argsRead = input->readString(arg, limit, isTerminator);
  return argsRead + read(forward<Ts>(args)...);
}
template <class... Ts>
inline int read(char* arg, int limit, const char* terminators, Ts&&... args) {
  int argsRead = read(arg, limit, terminators);
  return argsRead + read(forward<Ts>(args)...);
}
// complex types and ranges
template <class T1, class T2>
inline int read(pair<T1, T2>& arg) { return read(arg.first) == 1 && read(arg.second) == 1 ? 1 : 0; }
template <class T>
inline int read(vector<T>& arg) {
  uint n;
  if (read(n) == 0) return 0;
  arg.resize(n);
  return read(arg.begin(), arg.end());
}
template <class Iterator, class... Ts, typename>
int read(Iterator first, Iterator last, Ts&&... args) {
  int success = 1;
  for (; first != last; ++first) success &= read(*first);
  return success + read(forward<Ts>(args)...);
}
template <class Iterator, class... Ts, typename>
int read(Iterator first, int count, Ts&&... args) { return read(first, first + count, forward<Ts>(args)...); }
template <class T, class... Ts, typename>
inline int read(T&& arg1, Ts&&... args) {
  int argsRead = read(forward<T>(arg1));
  return argsRead + read(forward<Ts>(args)...);
}

// property setters
inline int write(Detail::Width width) { output->width = static_cast<int>(width.value); return 0; }
inline int write(Detail::Fill fill) { output->fill = fill.value; return 0; }
inline int write(Detail::Base base) { output->base = base.value; return 0; }
inline int write(Detail::Precision precision) { output->precision = precision.value; return 0; }
inline int write(Detail::Delimiter delimiter) { output->delimiter = delimiter.value; return 0; }
// primitive types
inline int write() { return 0; }
inline int write(char arg) { return output->writeChar(arg); }
template <class I> inline typename enable_if<is_integral<I>::value && is_unsigned<I>::value,
int>::type write(I arg) { return output->writeUnsignedInt(arg); }
template <class I> inline typename enable_if<is_integral<I>::value && is_signed<I>::value,
int>::type write(I arg) { return output->writeSignedInt(arg); }
template <class F> inline typename enable_if<is_floating_point<F>::value,
int>::type write(F arg) { return output->writeFloatingPoint(arg); }
// complex types
inline int write(const char* arg) { return output->writeString(arg, static_cast<int>(strlen(arg))); }
template <int N>
inline int write(char (&arg)[N]) { return output->writeString(arg, static_cast<int>(strlen(arg))); }
inline int write(const string& arg) { return output->writeString(arg.c_str(), static_cast<int>(arg.size())); }
template <class T1, class T2>
inline int write(const pair<T1, T2>& arg) {
  int charsWritten = write(arg.first);
  charsWritten += output->writeDelimiter();
  return charsWritten + write(arg.second);
}
// forward declarations so everything compiles
template <class Iterator, class... Ts,
typename = typename enable_if<!is_convertible<Iterator, const char*>::value, decltype(*std::declval<Iterator>())>::type>
int write(Iterator first, Iterator last, Ts&&... args);
template <class Iterator, class... Ts,
typename = typename enable_if<!is_convertible<Iterator, const char*>::value, decltype(*std::declval<Iterator>())>::type>
int write(Iterator first, int count, Ts&&... args);
template <class T, class T2, class... Ts> int write(T&& arg, T2&& arg2, Ts&&... args);
// ranges
template <class Iterator, class... Ts, typename>
int write(Iterator first, Iterator last, Ts&&... args) {
  int charsWritten = 0;
  for (; first != last; charsWritten += ++first == last ? 0 : output->writeDelimiter()) charsWritten += write(*first);
  return charsWritten + write(forward<Ts>(args)...);
}
template <class Iterator, class... Ts, typename>
int write(Iterator first, int count, Ts&&... args) { return write(first, first + count, forward<Ts>(args)...); }
template <class T, class T2, class... Ts>
inline int write(T&& arg, T2&& arg2, Ts&&... args) {
  int charsWritten = write(forward<T>(arg));
  return charsWritten + write(forward<T2>(arg2), forward<Ts>(args)...);
}
template <class... Ts>
inline int writeln(Ts&&... args) { return write(forward<Ts>(args)..., '\n'); }

void flush() { output->flush(); }

const int module = static_cast<int>(1e9+7);
template <class T> inline
T& inc(T& x, T y, T mod = module) { return (x += y) >= mod ? x -= mod : x; }
template <class T> inline
T add(T x, T y, T mod = module) { return inc(x, y, mod); }
template <class T> inline
T& dec(T& x, T y, T mod = module) { return (x -= y) < 0 ? x += mod : x; }
template <class T> inline
T sub(T x, T y, T mod = module) { return dec(x, y, mod); }

inline int mul(int x, int y, int mod = module) {
  return static_cast<int>(static_cast<long long>(x) * y % mod);
}
int inv(int x, int mod = module) {  // x < mod
  return x < 2 ? x : mod - static_cast<long long>(inv(mod % x, x)) * mod / x;
}

template <class T, class P, class M = int>
T qpow(T x, P power, M mod = module) {
  T res = 1;
  for (; power; power >>= 1, x = mul(x, x, mod))
    if (power & 1) res = mul(res, x, mod);
  return res;
}

template <int N>
class Combinatorics {
  int mod, fact[N+1], invFact[N+1];

public:
  Combinatorics(int mod = module) : mod(mod) {  // initialization: O(N)
    fact[0] = invFact[0] = invFact[1] = 1;
    for (int i = 2; i <= N; ++i) {
      invFact[i] = -static_cast<ll>(mod / i) * invFact[mod % i] % mod;
      if (invFact[i] < 0) invFact[i] += mod;
    }
    for (int i = 1; i <= N; ++i) {
      fact[i] = mul(fact[i-1], i, mod);
      invFact[i] = mul(invFact[i-1], invFact[i], mod);
    }
  }

  int factorial(int n) { return fact[n]; }
  int inverseFactorial(int n) { return invFact[n]; }
  int Anm(int n, int m) { return mul(fact[n], invFact[n-m], mod); }
  int Cnm(int n, int m) {
    return mul(fact[n], mul(invFact[m], invFact[n-m], mod), mod); }
  int Cnm(const vector<int>& a) {  // C({n = sum a_i}, a_0, a_1, ...)
    int n = 0, product = 1;
    for (int ai : a) n += ai, product = mul(product, invFact[ai], mod);
    return mul(fact[n], product, mod);
  }
  int Catalan(int n) {
    return mul(fact[2*n], mul(invFact[n], invFact[n+1], mod), mod); }
};

const int M = 5e5+5;
Combinatorics<M> C;
int p, m, n;

int main() {
#ifdef LocalHost
  input.reset(new InputFile("input.txt"));
  //input.reset(new InputFile());
  output.reset(new OutputFile());
  //output.reset(new OutputFile("output2.txt"));
#else
  input.reset(new InputFile(stdin, false));
  //input.reset(new InputFile());
  output.reset(new OutputFile());
#endif

  read(p);
  REP(i, p) {
    read(m, n);
    int ans = 0;
    int c = qpow(n, m-n);
    int invn = inv(n);
    FOR(k, n, m+1) {
      inc(ans, mul(C.Cnm(k-1, n-1), c));
      c = mul(c, n-1);
      c = mul(c, invn);
    }
    writeln(ans);
  }

#ifdef LocalHost
  flush();
  cerr << endl << endl << static_cast<double>(clock()) / CLOCKS_PER_SEC << endl;
#endif
  return 0;
}

----------
====================
----------
MATHEMATICS.129
medium
----------
PROBLEM STATEMENT:
Let [expression] without leading zeros. For instance:

[expression] 
[expression] 
[expression]  

You are given three positive integers [expression].
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

typedef pair<int, int> pii;
typedef long long ll;
typedef vector<int> vi;

#define pb push_back
#define eb emplace_back
#define mp make_pair
#define fi first
#define se second
#define rep(i,n) rep2(i,0,n)
#define rep2(i,m,n) for(int i=m;i<(n);i++)
#define ALL(c) (c).begin(),(c).end()

const ll MOD = 1000000007;

ll comb[110][110];
ll dp[110][120][120];

ll calc(int len, ll k)
{
    if (len == 0) return (k == 1);

    int c5 = 0, c7 = 0, c2 = 0, c3 = 0;
    while (k % 5 == 0) {
	++c5;
	k /= 5;
	--len;
    }

    while (k % 7 == 0) {
	++c7;
	k /= 7;
	--len;
    }

    while (k % 2 == 0) {
	++c2;
	k /= 2;
    }
    
    while (k % 3 == 0) {
	++c3;
	k /= 3;
    }
  
    if (len < 0 || k != 1) return 0;
    ll res = dp[len][c2][c3];
    len += c5 + c7;
    res = res * comb[len][c5] % MOD * comb[len-c5][c7] % MOD;
    return res;
}

void add(ll &x, ll y) {
    x += y;
    if (x >= MOD) x -= MOD;
}

ll acc(string s, ll k) // count x < s
{
    int len = s.size();
    ll res = 0;
    ll cur = 1;

    for (int i = 1; i < len; ++i) add(res, calc(i, k));

    rep(i, len) {
	int x = s[i] - '0';

	for (int j = 1; j < x; ++j) {
	    ll nc = cur * j;
	    if (k % nc == 0) add(res, calc(len-i-1, k / nc));
	}

	//cout<<i<< " "<< res<<endl;
	cur *= x;
	if (x == 0 || k % cur != 0) break;
    }
    //cout<<res<<endl;
    return res;
}

int same(string s, ll k) {
    ll t = 1;

    rep(i, s.size()) {
	int x = s[i] - '0';
	if (t * x > k) return false;
	t *= x;
    }

    return t == k;
}

int TC;
ll x, k;
string a, b;

int main() {
    comb[0][0] = 1;
    for (int i = 1; i < 110; ++i) {
	comb[i][0] = comb[i][i] = 1;
	for (int j = 1; j < i; ++j)
	    comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;
    }

    dp[0][0][0] = 1;

    rep(i, 105) {
	rep(j, 110) {
	    rep(k, 110) {
		add(dp[i+1][j][k], dp[i][j][k]);
		add(dp[i+1][j+1][k], dp[i][j][k]);
		add(dp[i+1][j][k+1], dp[i][j][k]);
		add(dp[i+1][j+2][k], dp[i][j][k]);
		add(dp[i+1][j+1][k+1], dp[i][j][k]);
		add(dp[i+1][j+3][k], dp[i][j][k]);
		add(dp[i+1][j][k+2], dp[i][j][k]);		
	    }
	}
    }

    ios::sync_with_stdio(false);
    cin >> TC;

    rep(tc, TC) {
	cout << "Case " << tc + 1 << ": ";
	cin >> a >> b >> k;
	cout << (acc(b, k) - acc(a, k) + same(b, k) + MOD) % MOD << '\n';
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.130
hard
----------
PROBLEM STATEMENT:
One day John had to take care of his little nephew Jim. He was very busy, so he gave Jim a big bag full of building bricks. The bricks are of various heights: at most 15 different heights. For each height, the bag contains infinitely many bricks. 

Now, Jim’s task is to build every possible tower of height [expression] from the given bricks. Bricks are stacked vertically only and stand in an upright position. Two towers are different if their brick height sequences are different.

Jim is good at building towers and can build one tower in exactly 2 minutes, regardless of its height. John wants to know the time Jim requires to build all possible towers.  

Input Format 
There are [expression] distinct integers representing the available heights.  

Output Format 
In one line print the number of minutes Jim requires to build all possible towers. As this number can be very large, print the number modulo [expression].  

Constraints 
[expression] 
[expression] 
All heights will be unique. 
Height of each brick will lie in range [1, 15].  

Sample Input#00

10
1
1


Sample Output#00  

2


Explanation#00:  There is exactly one type of brick, so there is exactly one tower of height 10. Building any tower takes 2 minutes, so the answer is 2.

Sample Input#01  

5
2
2 3


Sample Output#01  

4


Explanation #01: There are two types of bricks. There are two different towers of height 5 which can be build from these types of bricks: [expression].

Sample Input#03  

19
2
4 5


Sample Output#03

8


Explanation #03: There are two types of bricks. Jim can build 4 different towers of height [expression].
----------
TOP SOLUTION:
----------
#define DEBUG 0
 
#include <algorithm>
#include <functional>
#include <numeric>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <complex>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <cassert>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <sstream>
using namespace std;
 
#define LL long long
#define LD long double
#define PR pair<int,int>
 
#define Fox(i,n) for (i=0; i<n; i++)
#define Fox1(i,n) for (i=1; i<=n; i++)
#define FoxI(i,a,b) for (i=a; i<=b; i++)
#define FoxR(i,n) for (i=(n)-1; i>=0; i--)
#define FoxR1(i,n) for (i=n; i>0; i--)
#define FoxRI(i,a,b) for (i=b; i>=a; i--)
#define Foxen(i,s) for (i=s.begin(); i!=s.end(); i++)
#define Min(a,b) a=min(a,b)
#define Max(a,b) a=max(a,b)
#define Sz(s) int((s).size())
#define All(s) (s).begin(),(s).end()
#define Fill(s,v) memset(s,v,sizeof(s))
#define pb push_back
#define mp make_pair
#define x first
#define y second
 
template<typename T> T Abs(T x) { return(x<0 ? -x : x); }
template<typename T> T Sqr(T x) { return(x*x); }
string plural(string s) { return(Sz(s) && s[Sz(s)-1]=='x' ? s+"en" : s+"s"); }
 
const int INF = (int)1e9;
const LD EPS = 1e-12;
const LD PI = acos(-1.0);
 
#if DEBUG
#define GETCHAR getchar
#else
#define GETCHAR getchar_unlocked
#endif
 
bool Read(int &x)
{
	char c,r=0,n=0;
	x=0;
		for(;;)
		{
			c=GETCHAR();
				if ((c<0) && (!r))
					return(0);
				if ((c=='-') && (!r))
					n=1;
				else
				if ((c>='0') && (c<='9'))
					x=x*10+c-'0',r=1;
				else
				if (r)
					break;
		}
		if (n)
			x=-x;
	return(1);
}

#define MOD 1000000007

int main()
{
		if (DEBUG)
			freopen("in.txt","r",stdin);
	LL N;
	int K;
	int i,j,k,a,b,c,x,y;
	int H[15];
	int mat[15][15],pw[15][15],tmp[15][15];
	scanf("%lld%d",&N,&K);
		Fox(i,K)
			Read(H[i]);
	Fill(mat,0);
		Fox(i,15)
			mat[i][i]=1;
	Fill(pw,0);
		Fox(i,14)
			pw[i+1][i]=1;
		Fox(i,K)
			pw[0][H[i]-1]=1;
		while (N)
		{
				if (N&1)
				{
					Fill(tmp,0);
						Fox(i,15)
							Fox(j,15)
								Fox(k,15)
									tmp[i][j]=(tmp[i][j]+(LL)mat[i][k]*pw[k][j])%MOD;
					memcpy(mat,tmp,sizeof(tmp));
				}
			Fill(tmp,0);
				Fox(i,15)
					Fox(j,15)
						Fox(k,15)
							tmp[i][j]=(tmp[i][j]+(LL)pw[i][k]*pw[k][j])%MOD;
			memcpy(pw,tmp,sizeof(tmp));
			N>>=1;
		}
	printf("%d\n",mat[0][0]*2%MOD);
	return(0);
}
----------
====================
----------
MATHEMATICS.131
advanced
----------
PROBLEM STATEMENT:
Welcome to Sevenkplus' perfect math class! In this class, you will learn about representation theory. And this class is in a different format than before: Learning by doing! You need to solve a problem, which can be solved elegantly using (really elementary) representation theory. (Of course you can solve this problem without representation theory. But learning more is helpful!)

Sevenkplus had an [expression] identity matrix.)
However, the dark side of the world destroyed [expression] remained.

Sevenkplus wants to recover his beloved [expression]. However, this is impossible. 
Nevertheless, doing something weaker is possible: Only recover the eigenvalues of [expression], they are unique up to permutation.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <complex>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

const double PI = atan2(0, -1);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int N, M;
    cin >> N >> M;
    vector<complex<double> > a(M);
    forn(i, M) {
        double x, y;
        cin >> x >> y;
        a[i] = complex<double>(x, y);
    }
    reverse(a.begin() + 1, a.end());
    forn(i, M) {
        complex<double> w0(cos(2 * PI * i / M), sin(2 * PI * i / M)), w(1.0, 0.0);
        complex<double> res;
        forn(j, M) {
            res += w * a[j];
            w *= w0;
        }
        int x = (int)(real(res) / M + 0.5);
        forn(j, x) {
            cout << cos(2 * PI * i / M) << ' ' << sin(2 * PI * i / M) << '\n';
        }
    }

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
MATHEMATICS.132
hard
----------
PROBLEM STATEMENT:
Nikita has a row of [expression]. This time, she's painting them green! 

Find the number of ways Nikita can paint certain tiles in green so that the indices of the green tiles form an Arithmetic Progression. As this value can be quite large, your answer must be modulo [expression].

Note: Nikita must paint at least [expression] tile.
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }


template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
};
typedef ModInt<1000000007> mint;

void integerDivisionValues(long long n, vector<long long> &res) {
	res.clear();
	res.push_back(1);
	for(long long L = 1, d = n; L <= n; ) {
		long long U = n / d;
		res.push_back(U + 1);
		L = U + 1, d = n / L;
	}
}

mint sum1(long long R) {
	long long x = R, y = R + 1;
	if(x % 2 == 0) x /= 2; else y /= 2;
	return mint(x) * y;
}

int main() {
	int T;
	scanf("%d", &T);
	for(int ii = 0; ii < T; ++ ii) {
		long long N;
		scanf("%lld", &N);
		vector<ll> xs;
		integerDivisionValues(N, xs);
		mint ans = N;
		rep(i, xs.size() - 1) {
			ll L = xs[i], R = xs[i + 1];
			long long f = N / L;
			ans += mint(N) * (R - L) * f;
			ans -= sum1(f) * (sum1(R - 1) - sum1(L - 1));
			//- \sum_{i=L}^{R-1} \sum_{j=1..f} i*j
			//- (f (f+1) / 2) \sum_{i=L}^{R-1} i
		}
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.133
hard
----------
PROBLEM STATEMENT:
Consider a set, [expression]:


[expression]
[expression]


For example, [expression]?

Perform [expression]. For each query:


Find the number of different beautiful sets having exactly [expression]. 
Print the number of beautiful sets, modulo [expression], on a new line.

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <iostream>
#include <utility>
#include <vector>
using namespace std;
int n;
const int mo=1000000007;
int qp(int a,int b){int x=1;do{if(b&1)x=1ll*x*a%mo;a=1ll*a*a%mo;}while(b>>=1);return x;}
int fac[1111111],ifac[1111111];
int c(int a,int b){
		if(b>a || b<0)return 0;
		return 1ll*fac[a]*ifac[a-b]%mo*ifac[b]%mo;
}
int notouch(int n,int m){
		return c(n-m+1,m);
}
int main() {
	fac[0]=1;
	for (int i=1;i<=1000005;i++)fac[i]=1ll*fac[i-1]*i%mo;
	ifac[1000005]=qp(fac[1000005],mo-2);
	for (int i=1000004;i>=0;i--)ifac[i]=1ll*(i+1)*ifac[i+1]%mo;
	int q;scanf("%d",&q);
	while(q--){
	    int n,k;
	    scanf("%d%d",&n,&k);
	    int ans=0;
	    for (int m=1;m*2<=k;m++){
	    		int ways=c(k-m-1,m-1);
	    		ans=(ans+1ll*ways*notouch(n-(k-m),m))%mo;
		}
		printf("%d\n",ans);
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.134
hard
----------
PROBLEM STATEMENT:
Meera bought a house on Mars, and plans to decorate it with chains of alien flowers. Each flower is either red ([expression]), and Meera knows how many occurrences of RR, RB, BB, and BR she wants to see in a chain.     

The diagram below shows a flower chain of length [expression]:



In this example, RR occurs [expression]).

Meera wants your help determining how many different chains with positive length can be made. Given [expression].
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }


template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }

	ModInt inverse() const {
		signed a = x, b = MOD, u = 1, v = 0;
		while(b) {
			signed t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		if(u < 0) u += Mod;
		ModInt res; res.x = (unsigned)u;
		return res;
	}
};
typedef ModInt<1000000007> mint;

vector<mint> fact, factinv;
void nCr_computeFactinv(int N) {
	N = min(N, mint::Mod - 1);
	fact.resize(N + 1); factinv.resize(N + 1);
	fact[0] = 1;
	rer(i, 1, N) fact[i] = fact[i - 1] * i;
	factinv[N] = fact[N].inverse();
	for(int i = N; i >= 1; i --) factinv[i - 1] = factinv[i] * i;
}
mint nCr(int n, int r) {
	if(n >= mint::Mod)
		return nCr(n % mint::Mod, r % mint::Mod) * nCr(n / mint::Mod, r / mint::Mod);
	return r > n ? 0 : fact[n] * factinv[n - r] * factinv[r];
}

int main() {
	nCr_computeFactinv(400001);
	int A; int B; int C; int D;
	while(~scanf("%d%d%d%d", &A, &B, &C, &D)) {
		if(B < D) swap(A, C), swap(B, D);
		int len = A + B + C + D + 1;
		mint ans;
		if(len == 1) {
			ans = 2;
		} else if(B == D) {
			if(B == 0) {
				if(A == 0 || C == 0)
					ans = 1;
				else
					ans = mint();
			} else {
				ans = mint();
				ans += nCr(A + B, B) * nCr(C + D - 1, D - 1);
				ans += nCr(C + D, D) * nCr(A + B - 1, B - 1);
			}
		} else if(B == D + 1) {
			//red run = blue run = B times
			//RRRRBBRRRBRRRBBB
			ans = nCr(A + B - 1, B - 1) * nCr(C + B - 1, B - 1);
		} else {
			ans = mint();
		}
		printf("%d\n", ans.get());
		/*
		int naiveans = 0;
		rep(mask, 1 << len) {
			int cnt[4] = {};
			rep(i, len - 1)
				++ cnt[mask >> i & 3];
			if(cnt[0] == A && cnt[1] == B && cnt[2] == D && cnt[3] == C)
				++ naiveans;
		}
		if(ans.get() != naiveans)
			cerr << A << ", " << B << ", " << C << ", " << D << ": " << naiveans << " != " << ans.get();
		*/
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.135
medium
----------
PROBLEM STATEMENT:
For a given integer [expression] on the result.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;
typedef long long int ll;
ll power(ll x,ll y, ll p)
{
if(y==0)
return 1;
else if(y==1)
return x;
else
{
    ll res = 1;      
 
    x = x % p; 
               
 
    while (y > 0)
    {
      
        if (y & 1)
            res = (res*x) % p;
        y = y>>1;
        x = (x*x) % p;  
    }
    return res%p;
}
}
ll towerColoring(ll n){
ll res=power(3,n,1000000006);
ll ans=power(3,res,1000000007);
return ans;
    
}

int main() {
    ll n;
    cin >> n;
    ll result = towerColoring(n);
    cout << result << endl;
    return 0;
}


----------
====================
----------
MATHEMATICS.136
medium
----------
PROBLEM STATEMENT:
A non-decreasing sequence is a called a Fox sequence, iff the most frequent element in the sequence is unique. 

e.g. The sequence 1, 1, 2, 3, 4  is a Fox sequence, because it follows the above definition. The most frequent element is 1. It occurs twice in the series, and is unique.

But the sequence 1, 1, 2, 2 is not a Fox sequence, because there are two most frequent elements - 1 and 2. It violates the uniqueness property.

Note: Sequence 2, 1, 1 is not a Fox sequence, because it is not a non-decreasing sequence.

You need to find the number of all possible Fox sequences of length n with elements having value between lo and hi inclusive.  

As the number can grow very large, return the number modulo (109 + 7).

Input Format 
The first line will contain T, i.e., the number of test cases. 
For each test case, there will be a single line containing three space separated integers n, lo, hi.

Output Format 
For each test case, display a single value corresponding to the number of all possible Fox sequences.

Constraints  

1  ≤ T ≤ 5 
1  ≤ lo, hi ≤ 109 
lo ≤ hi 
0  ≤ \|hi - lo\| 5 
1  ≤ n ≤ 105  

Sample Input

5
2 1 1
2 1 3
3 1 2
4 4 5
10 2 4


Sample Output

1
3
4
4
60


Explanation 
For the first test case, 1 1 is the only possible Fox sequence. 
For the second test case, 1 1, 2 2, and 3 3 are three possible Fox sequences. 
For the third test case, 1 1 1, 2 2 2, 1 1 2, and 1 2 2 are four possible Fox 
sequences. 
Rest of the test cases are up to you to figure out. 
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
using namespace std;
const int SIZE = 2e5+5;
const int MOD = 1e9+7;
long long inv[SIZE],fac[SIZE];
long long mypow(long long x,long long y){
    long long res=1;
    while(y){
        if(y&1){
            res=res*x%MOD;
        }
        y>>=1;
        x=x*x%MOD;
    }
    return res;
}
void build(){
    fac[0]=1;
    REPP(i,1,SIZE)fac[i]=fac[i-1]*i%MOD;
    inv[SIZE-1]=mypow(fac[SIZE-1],MOD-2);
    for(int i=SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%MOD;
}
long long C(long long x,long long y){
    if(y<0||y>x)return 0;
    return fac[x]*inv[y]%MOD*inv[x-y]%MOD;
}
long long d[100001];
void add(long long &x,long long v){
    x+=v;
    x%=MOD;
}
long long g(int num,int sum,int big){
    if(big==0){
        if(sum==0)return 1;
        return 0;
    }
    long long res=C(sum+num-1,sum);
    int ng=-1;
    for(int k=1;k<=num&&k*(big+1)<=sum;k++,ng*=-1){
        res=(res+ng*C(sum-k*(big+1)+num-1,num-1)*C(num,k))%MOD;
    }
    return res;
}
int main(){
    build();
    CASET{
        DRIII(n,lo,hi);
        int m=hi-lo+1;
        if(m==1)puts("1");
        else{
            long long an=0;
            REPP(i,1,n+1){
                add(an,m*g(m-1,n-i,i-1));
            }
            if(an<0)an+=MOD;
            cout<<an<<endl;
        }
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.137
medium
----------
PROBLEM STATEMENT:
Manasa has a string having N number of A's and 2*N number of B's. She wants to arrange these characters in such a way that in each prefix and in each suffix of the string the number of B's is greater than or equal to the number of A's. Given the value of N, she wants to find the number of ways to do so.

Input Format 
The first line contains an integer T i.e. number of test cases. 
Next T lines will contain an integer N.  

Output Format 
A single line containing number of ways MOD 99991.

Constraints 
1  
1 12  

Sample Input #00  

2
1
2


Sample Output #00  

1
4


Explanation  

In first case, "BAB" is only valid string.
In second case, "BBAABB", "BABABB" , "BBABAB" and "BABBAB" are valid strings.
----------
TOP SOLUTION:
----------
#include <cassert>
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;

typedef long long ll;

const int MOD = 99991;

void gcd(ll a, ll b, ll& d, ll& u, ll& v) {
	if (b == 0) {
		d = a;
		u = 1;
		v = 0;
	} else {
		gcd(b, a % b, d, v, u);
		// ua + vb = u'b + v'(a - a/b * b)
		//         = v'a + (u' - v' a/b)b
		v -= u * (a / b);
	}
}

ll Inverse(ll x) {
	x %= MOD;
	ll d, u, v;
	gcd(x, MOD, d, u, v);
	return (u % MOD + MOD) % MOD;
}

int fac[MOD + 1];

ll Power(ll u, ll i) {
	ll r = 1;
	for (; i > 0; i >>= 1) {
		if (i & 1) r = r * u % MOD;
		u = u * u % MOD;
	}
	return r;
}

pair<ll, ll> Factorial(ll n) {
	ll res = 1, index = 0;
	while (n > 0) {
		res = res * Power(fac[MOD - 1], n / MOD) * fac[n % MOD] % MOD;
		index += n / MOD;
		n /= MOD;
	}
	return make_pair(res, index);
}

int C(ll n, ll m) {
	if (m < 0 || m > n) return 0;
	auto a = Factorial(n), b = Factorial(m), c = Factorial(n - m);
	if (a.second > b.second + c.second) return 0;
	return a.first * Inverse(b.first * c.first % MOD) % MOD;
}

int Solve(ll N) {
	ll ans = C(N * 3, N) - 2 * C(N * 3, N - 1) + C(N * 3, N - 2);
	return (ans % MOD + MOD) % MOD;
}

int main() {
	{
		for (ll i = 1; i < 100; ++i)
			for (ll j = 1; j < 100; ++j) {
				ll d, u, v;
				gcd(i, j, d, u, v);
				assert(i * u + j * v == d);
			}
	}
	{
		ll x = 1;
		fac[0] = x;
		for (int i = 1; i <= MOD; ++i) {
			x = x * i % MOD;
			fac[i] = x;
		}
		cerr << fac[MOD - 1] << endl;
	}
	cin.sync_with_stdio(false);
	cout.sync_with_stdio(false);
	int T;
	for (cin >> T; T--;) {
		ll N;
		cin >> N;
		cout << Solve(N) << endl;
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.138
medium
----------
PROBLEM STATEMENT:
Calculate the number of ways to color an N * M grid using K colors. Adjacent squares in the grid should have different colors. Squares are considered adjacent if they share an edge.

Input Format 
The first line contains an integer T denoting the number of test-cases.
The next T lines contains integers N, M and K separated by a single space. 

Output Format 
Output T lines, one for each test case containing the number of ways modulo 109+7. 

Constraints 
1 5 
1 
1 9    

Sample Input

3
3 3 2
3 4 3
1 1 1


Sample Output 

2
1122
1


Explanation 
For the first case, there are two ways to color the grid. The colorings are in a chessboard pattern with either color at the top right square.

Timelimits
Timelimits for this challenge can be seen here
----------
TOP SOLUTION:
----------
#include <cmath>
#include <map>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

const int md = 1000000007;

vector <int> add(vector <int> a, vector <int> b) {
    int n = a.size();
    int m = b.size();
    int k = (n > m ? n : m);
    vector <int> c(k);
    for (int i = 0; i < k; i++)
        if (i >= n) c[i] = b[i]; else
        if (i >= m) c[i] = a[i];
        else c[i] = (a[i] + b[i]) % md;
    return c;
}

vector <int> mul(vector <int> a, int b) {
    int n = a.size();
    for (int i = 0; i < n; i++) {
        a[i] = ((long long)a[i] * b) % md;
        if (a[i] < 0) a[i] += md;
    }
    return a;
}

vector <int> mul_x(vector <int> a, int bb) {
    vector <int> b(1, 0);
    b.insert(b.end(), a.begin(), a.end());
    vector <int> c = mul(a, -bb);
    return add(b, c);
}

int eval(vector <int> a, int x) {
    int ans = 0, y = 1;
    for (int i = 0; i < (int)a.size(); i++) {
        ans = (ans + (long long)y * a[i]) % md;
        y = (long long)y * x % md;
    }
    return ans;
}

void normalize(vector <int> &a) {
  int n = a.size();
  vector <int> color(n + 3, 0);
  int last = 0;
  for (int i = 0; i < n; i++) {
    if (a[i] == 0) {
      continue;
    }
    if (color[a[i]] == 0) {
      color[a[i]] = ++last;
    }
    a[i] = color[a[i]];
  }
}

map < vector <int>, vector <int> > f[10][10];
map < vector <int>, vector <int> >::iterator it;
vector <int> result[10][10];

int main() {
    for (int rows = 1; rows <= 8; rows++) {
        for (int i = 0; i < rows; i++)
            for (int j = 0; j <= 8; j++) f[i][j].clear();
        vector <int> temp(rows, 0);
        f[0][0][temp] = vector <int>(1, 1);
        for (int col = 0; col < 8; col++) {
            for (int row = 0; row < rows; row++) {
                int n_col = col;
                int n_row = row;
                if (n_row + 1 < rows) {
                    n_row++;
                } else {
                    n_row = 0;
                    n_col++;
                }
                it = f[row][col].begin();
                while (it != f[row][col].end()) {
                    vector <int> state = (*it).first;
                    vector <int> poly = (*it).second;
                    int maxc = 0;
                    for (int i = 0; i < rows; i++)
                        if (state[i] > maxc) maxc = state[i];
                    for (int c = 1; c <= maxc; c++) {
                        if (c == state[row]) {
                            continue;
                        }
                        if (row > 0 && c == state[row - 1]) {
                            continue;
                        }
                        vector <int> new_state = state;
                        new_state[row] = c;
                        normalize(new_state);
                        f[n_row][n_col][new_state] = add(f[n_row][n_col][new_state], poly);
                    }
                    vector <int> new_state = state;
                    new_state[row] = maxc + 1;
                    normalize(new_state);
                    vector <int> new_poly = mul_x(poly, maxc);
                    f[n_row][n_col][new_state] = add(f[n_row][n_col][new_state], new_poly);
                    it++;
                }
            }
        }
        for (int cols = 1; cols <= 8; cols++) {
            result[rows][cols] = vector <int>();
            it = f[0][cols].begin();
            while (it != f[0][cols].end()) {
                vector <int> poly = (*it).second;
                result[rows][cols] = add(result[rows][cols], poly);
                it++;
            }
        }
    }
    int tt;
    scanf("%d", &tt);
    while (tt--) {
        int n, m, k;
        scanf("%d %d %d", &n, &m, &k);
        printf("%d\n", eval(result[n][m], k));
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.139
hard
----------
PROBLEM STATEMENT:
In an NxM grid with each cell's dimension being 1x1, there will be (N+1) x (M+1) cross points. 
You task is to count the number of ways (S) of choosing K different points from these cross points such that all of them lie on a straight line and at least one of the cross points lies on the border.

Input Format  

A single line containing 3 integers N, M & K separated by a single space. 

Output Format  

A single integer denoting the number of ways (S) modulo 1000000007

Constraints

0 
2 

Sample Input  

2 2 3


Sample Output  

8


Explanation  

If you imagine a grid of the first quadrant of the co-ordinate system. Then, we have, 8 such 3 points of which at least 1 point on the borders. 

(0,0), (0,1), (0,2) 
(1,0), (1,1), (1,2) 
(2,0), (2,1), (2,2) 
(0,0), (1,0), (2,0) 
(0,1), (1,1), (2,1) 
(0,2), (1,2), (2,2) 
(0,0), (1,1), (2,2) and 
(0,2), (1,1), (2,0)
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <map>
#include <list>
#include <iterator>
#include <set>
#include <queue>
#include <iostream>
#include <sstream>
#include <stack>
#include <deque>
#include <cmath>
#include <memory.h>
#include <cstdlib>
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <utility> 
using namespace std;
 
#define FOR(i, a, b) for(int i = (a); i < (b); ++i)
#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)
#define REP(i, N) FOR(i, 0, N)
#define RREP(i, N) RFOR(i, N, 0)
 
#define ALL(V) V.begin(), V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair
#define Pi 3.14159265358979

typedef long long Int;
typedef unsigned long long UInt;
typedef vector <int> VI;
typedef pair <int, int> PII;

const Int MOD = 1000000007;

int gcd(int x, int y)
{
	while (x && y)
	{
		if (x > y)
			x%=y;
		else
			y%=x;
	}
	return x+y;
}

int CNK[3333][3333];

Int solve(int n, int m, int k, int i, int j, int pi, int pj)
{	
	Int res = 0;
	int cnt = k-2;
	while (i <= n && j <= m)
	{
		res = (res + 1LL*((n-i) + (m-j+1))*CNK[cnt][k-2])%MOD;
		
		i += pi;
		j += pj;
		++cnt;
	}
	
	if (i != 0 && j != 0)
		res = (res * 2) % MOD;
	
	return res;
}

int main()
{
		
	FOR(i,0,3333)
	{
		CNK[i][0] = CNK[i][i] = 1;
		
		FOR(j,1,i)
		{
			CNK[i][j] = CNK[i-1][j-1] + CNK[i-1][j];
			
			if (CNK[i][j] >= MOD)
				CNK[i][j] -= MOD;
		}
	}
		
	int n, m, k;
	cin>>n>>m>>k;
	
	Int res = 0;
	
	FOR(i,0,n+1)
	{
		FOR(j,0,m+1)
		{
			int cnt = gcd(i,j);
			
			if (cnt != 1)
				continue;
			
			int I = i * (k-1);
			int J = j * (k-1);
			
			Int buf = solve(n,m,k,I,J,i,j) + solve(n-1,m-1,k,I,J,i,j);
			
			if (buf >= MOD)
				buf -= MOD;
			
			res = res + buf;
			
			if (res >= MOD)
				res -= MOD;
		}
	}

	cout << res << endl;
	
	return 0;
}

----------
====================
----------
MATHEMATICS.140
medium
----------
PROBLEM STATEMENT:
Maya is teaching Alex about HyperText Markup Language (HTML). Alex is confused about div and span tags, so Maya decides to reduce the concept to a simpler visual by representing div tags as square brackets and span tags as parentheses. In other words, she represents  as [,  as ], [expression] as ).

We use the following rules to determine the validity of a configuration:


The empty string (""), a single pair of square brackets [], and single pair of parentheses () are all considered to be valid configurations. We can express each of these as [expression].
A valid configuration, [expression]. For example, () is normal.
Two or more consecutive valid configurations (e.g., [expression]) also constitute a valid configuration. For example, [][], ()(), and []()[] are all valid.
The following configurations are also valid: [V], (N). 
For example, [[(())]()], ((())), and [(())[]] are all valid; however, ([]) is not valid (you cannot nest a div tag inside a span tag).


Given some number of distinguishable square brackets, [expression].
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <map>
#include <set>
#include <cassert>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
// head

const int N=201000;
ll fac[N],fnv[N],cat[N],dp[210][210];
int _,x,y;
int main() {
	fac[0]=1; fnv[0]=1;
	rep(i,1,200011) {
		fac[i]=fac[i-1]*i%mod,fnv[i]=powmod(fac[i],mod-2);
	}
	rep(i,1,100001) cat[i]=fac[2*i]*fnv[i]%mod*fnv[i+1]%mod;
	dp[0][0]=1;
	rep(i,1,201) rep(j,1,201) rep(k,1,j+1) {
		dp[i][j]=(dp[i][j]+dp[i-1][j-k]*cat[k])%mod;
	}
//	printf("%lld %lld\n",dp[1][2],dp[2][2]);
	for (scanf("%d",&_);_;_--) {
		scanf("%d%d",&x,&y);
		ll ret=0;
		rep(j,1,y+1) 
			ret=(ret+fac[2*x+1]*fnv[j]%mod*fnv[2*x+1-j]%mod*dp[j][y])%mod;
		ret=ret*cat[x]%mod*fac[x]%mod*fac[y]%mod;
		printf("%lld\n",ret);
	}
}

----------
====================
----------
MATHEMATICS.141
hard
----------
PROBLEM STATEMENT:
You are planning the next FIFA World Cup and you are counting the number of highways that need to be built to connect the cities with the venue. 
Your country has [expression]. 

The requirements for the highways are as follows:


All games will be held in the [expression] city.
New bidirectional roads, called "Super Highways", need to be built such that it is possible to visit the [expression] city from any other city directly.  


You also have the cost to fulfil the second condition. The engineering team knows that if the length of a Super Highway is [expression].  

For this problem, you need to find only a rough estimation of the cost, hence, find Total Cost Modulo [expression]. 
----------
TOP SOLUTION:
----------
#include <ios>
#include <iostream>
#include <vector>
#define MOD 1000000009

long long int fastexp(long long int x, long long int y)
{
    if (y == 0)
        return 1;
    else if (y == 1)
        return x%MOD;
    else if (y & 1)
        return ((x%MOD)*fastexp(x, y-1))%MOD;
    else
    {
        long long int t = fastexp(x, y/2);
        return (t*t)%MOD;
    }
}

long long int inv(long long int x)
{
    return fastexp(x, MOD-2);
}

std::vector<long long int> vec;

int main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    int tc = 1, k;
    long long int n;
    std::cin >> tc;
    while (tc--)
    {
        vec.clear();
        std::cin >> n >> k;
        if (n == 1)
            std::cout << 0 << '\n';
        else
        {
            n--;
            long long int s = 0;
            vec.push_back(s);
            for (int i = 0; i < k+1; i++)
            {
                s += fastexp(i+1, k);
                s %= MOD;
                vec.push_back(s);
            }
            if (n < vec.size())
                std::cout << ((vec[n] - 1)+MOD)%MOD << '\n';
            else
            {
                long long int ans = 0;
                long long int u = 1;
                for (int i = 1; i < vec.size(); i++)
                {
                    u *= ((n-i)%MOD+MOD)%MOD;
                    u %= MOD;
                    u *= inv(((-i)%MOD+MOD)%MOD);
                    u %= MOD;
                }
                for (int i = 0; i < vec.size(); i++)
                {
                    ans += (vec[i]*u)%MOD;
                    ans %= MOD;
                    if (i+1 >= vec.size())
                        break;
                    else
                    {
                        u *= ((((n-i)%MOD+MOD)%MOD)*inv((n-(i+1)%MOD+MOD)%MOD))%MOD;
                        u %= MOD;
                        u *= ((((i-((int)(vec.size())-1))%MOD+MOD)%MOD*inv((i+1)%MOD)))%MOD;
                        u %= MOD;
                    }
                }
                std::cout << ((ans-1)%MOD+MOD)%MOD << '\n';
            }
        }
    }
}

----------
====================
----------
MATHEMATICS.142
hard
----------
PROBLEM STATEMENT:
You are given an array [expression] queries.  

Each query contains a number [expression].  

For each distinct permutation of the array [expression], you need to print the sum of the values returned by the find function.

As the sum can be too large, output it modulo [expression], which is a prime and given in input.  

find(int permutation_A[], int M)
{
    x = Length(permutation_A)
    sum = 0
    for(i = 0; i < x; i++) {
        if (permutation_A[i] <= M)
            sum = sum + permutation_A[i]
        else
            break
    }
    return sum
}


Input Format 
The first line of input contains [expression]. 
The second line of input contains [expression] separated by single spaces. 
The next line contains [expression].  

Output Format 
For each query, output as asked above.  

Constraints 
[expression] 
[expression] 
[expression] 
[expression]

Sample Input

2000003
5
4 2 3 1 4
2
1
2


Sample Output

12
45


Explanation

Query 1: 
Consider all permutations. if the first number is greater than 1, then the loop will break in the beginning itself. There are a total of 60 distinct permutations out of which 48 will give 0. The remaining 12 will fetch 1 each from the function. Thus the answer is 12.  
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.143
advanced
----------
PROBLEM STATEMENT:
The farmer decided to build a barn on his farm. But on his farm there are trees and other buildings, which he does not want to remove.   

For simplicity, we represent the farm as a rectangular grid of height [expression]. Each of the trees and buildings are located in one or more cells of the grid. The barn is a rectangle and should be built on the free cells of the grid.   

Help the farmer to find out how many ways there are to place the barn, for all possible sizes of barns.  

Input Format 
The first line contains two integers [expression] - the dimensions of the farm. 
The next [expression] characters - 0 or 1 (1 means the cell is available/free for building the barn).  

Output Format 
Write [expression] in the farm.  

Constraints 
[expression]  

Sample input  

3 3
011
110
110


Sample Output  

6 3 0
3 1 0
1 0 0


Explanation

Barns with height 1 and width 1:

0*1    01*    011    011    011    011
110    110    *10    1*0    110    110
110    110    110    110    *10    1*0


Barns with height 1 and width 2:

0**    011    011
110    **0    110
110    110    **0


Barns with height 2 and width 1:

0*1    011    011
1*0    *10    1*0
110    *10    1*0


Barns with height 2 and width 2 (there is only one):

011
**0
**0


Barns with height 3 and width 1 (there is only one):

0*1
1*0
1*0


Time Limits: C/C++ 1 sec, Java/C# 2 sec, other languages follow standard TL given in Environment
----------
TOP SOLUTION:
----------
#include <stdio.h>
#include <algorithm>
#include <vector>
#include <stack>
#include <queue>
#include <string.h>
#include <set>
#include <map>
#define MP make_pair
#define FF first.first
#define FS first.second
#define SF second.first
#define SS second.second
#define ALL(container) (container).begin(), (container).end()
#define FORI(i,from,to) for(int i = (from); i <= (to); i++)
#define FORD(i,from,to) for(int i = (from); i >= (to); i--)
#define REP(i,num) for(int i = 0; i < (num); i++)


using namespace std;

typedef long long LL;
typedef long double LD;
typedef vector<int> VI;
typedef pair<int,int> PII;
const LD Eps = 1e-8;
inline bool is_zero(LD x){ return (x >= -Eps) && (x <= Eps); }


const int MaxDim = 1030;

int N, M;
char data[MaxDim][MaxDim];
LL resultPref[MaxDim][MaxDim];
LL increasePref[MaxDim][MaxDim];
LL result[MaxDim][MaxDim];
int availableHeight[MaxDim];

void input(){
	scanf("%d%d", &N, &M);
	REP(i, N){
		scanf("%s", data[i]);
		data[i][M] = '0';
	}
}



void add_rect(int x1, int y1, int x2, int y2){
	//printf("add((%d,%d)(%d,%d))\n",x1,y1,x2,y2);
	resultPref[y2][x2]++;
	resultPref[y2][x1-1]--;
	resultPref[y1-1][x2]--;
	resultPref[y1-1][x1-1]++;
}


int main(){
	input();
	
	// almost like 'Dzialka', IX/X POI
	REP(row, N){
		//int prevHeight = 0;
		stack<PII> heights;
		stack<int> locks;
		heights.push(PII(-100,-1));
		locks.push(-1);
		
		//printf("Y\n");
		REP(col, M+1){
			int lastPop = col;
			availableHeight[col] = (data[row][col]=='1'
							? availableHeight[col]+1
							: 0);
			
			int h = availableHeight[col];
			//printf("h=%d\n", h);
			while(h < heights.top().first){
				int prevH = heights.top().first,
				    prevX = heights.top().second;
				lastPop = prevX;
				heights.pop(); locks.pop();
				int lowH = max(1, heights.top().first+1);
				lowH = max(lowH, h+1);
				
				int prevWidth = col-prevX;
				
				//printf("(%d,%d)\n", prevH,prevWidth);
				add_rect(1, lowH, prevWidth, prevH);
				//resultPref[prevH][prevWidth]++;
				//heights.pop();
			}
			if(h != heights.top().first && h){
				heights.push(PII(h, lastPop));
				locks.push(col);
			}
		}
	}
	
	/*FORI(row, 1, N){
		FORI(col, 1, M){
			printf("%lld ", resultPref[row][col]);
		}
		printf("\n");
	}*/
	
	// recover result from prefix
	FORD(row, N, 0){
		//LL suf=0, sufWeight=0;
		FORD(col, M, 0){			
			increasePref[row][col] = resultPref[row][col]
			                       + increasePref[row+1][col]
			                       + increasePref[row][col+1]
			                       - increasePref[row+1][col+1];
			//result[row][col] = sufWeight;
		}
	}
	FORD(row, N, 0){
		FORD(col, M, 0){
			result[row][col] = result[row][col+1] + increasePref[row][col];
		}
	}
	
	
	
	/*FORI(row, 1, N){
		FORI(col, 1, M){
			printf("%lld ", increasePref[row][col]);
		}
		printf("\n");
	}
	printf("\n");*/
	
	FORI(row, 1, N){
		FORI(col, 1, M){
			printf("%lld ", result[row][col]);
		}
		printf("\n");
	}
}

----------
====================
----------
MATHEMATICS.144
hard
----------
PROBLEM STATEMENT:
A number, [expression] (respectively) requires a carry operation:


In [expression]'s place. 
In [expression]'s place.
In [expression]'s place.


You have two integers, [expression].

Given [expression].
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
};
typedef ModInt<1000000007> mint;

struct Matrix {
	typedef mint Num;
	static const int MaxN = 4;
	int hei, wid;
	Num v[MaxN][MaxN];
	Matrix() {}
	Matrix(int n, int m) : hei(n), wid(m) {
		memset(v, 0, sizeof(m));
	}
	inline int height() const { return hei; }
	inline int width() const { return wid; }
	inline Num& at(int i, int j) { return v[i][j]; }
	inline const Num& at(int i, int j) const { return v[i][j]; }
	static Matrix identity(int n) {
		Matrix A(n, n);
		rep(i, n) A.at(i, i) = 1;
		return A;
	}
	inline static Matrix identity(const Matrix& A) { return identity(A.height()); }
	Matrix& operator*=(const Matrix& B) {
		int n = height(), m = B.width(), p = B.height();
		assert(p == width());
		const unsigned(*b)[MaxN] = reinterpret_cast<const unsigned(*)[MaxN]>(B.v);
		Num w[MaxN][MaxN];
		unsigned long long pp = (1ULL << 32) % mint::Mod;
		rep(i, n) {
			const unsigned *ai = reinterpret_cast<const unsigned*>(v[i]);
			rep(j, m) {
				unsigned x0 = 0; unsigned long long x1 = 0;
				rep(k, p) {
					unsigned long long y = (unsigned long long)ai[k] * b[k][j];
					unsigned long long t = x0 + y;
					x1 += t >> 32;
					x0 = t & 0xffffffff;
				}
				w[i][j].x = (x0 + x1 % mint::Mod * pp) % mint::Mod;
			}
		}
		memcpy(v, w, sizeof(v));
		return *this;
	}
};
Matrix operator^(const Matrix& t, ll k) {
	Matrix A = t, B = Matrix::identity(t);
	while(k) {
		if(k & 1) B *= A;
		A *= A;
		k >>= 1;
	}
	return B;
}

mint geometricSum(mint a, long long k) {
	mint smul = 1, mul = a, ret;
	while(k > 0) {
		if(k & 1)
			ret = ret * mul + smul;
		smul *= mul + 1;
		mul *= mul;
		k >>= 1;
	}
	return ret;
}

int main() {
	char x[1000002];
	long long n;
	while(~scanf("%s%lld", x, &n)) {
		int len = (int)strlen(x);
		Matrix matrices[10];
		rep(e, 10) {
			Matrix A(4, 4);
			rep(le, 2) rep(inc, 2) {
				int s = le * 2 + inc * 1;
				rep(d, 10) {
					int nle = d == e ? le : d < e ? 1 : 0;
					int ninc = d + inc >= 10 ? 1 : 0;
					int sum = d + ((d + inc) % 10) + 0;
					int ncarry = sum >= 10 ? 1 : 0;
					if(ncarry == 0) {
						int ns = nle * 2 + ninc * 1;
						A.at(s, ns) += 1;
					}
				}
			}
			matrices[e] = A;
		}
		Matrix X = Matrix::identity(4);
		for(int i = len - 1; i >= 0; -- i)
			X *= matrices[x[i] - '0'];
		Matrix A = X ^ n;
		Matrix b(1, 4);
		b.at(0, 3) = 1;
		b *= A;
		mint xm, pow10 = 1;
		rep(i, len) {
			xm = xm * 10 + (x[i] - '0');
			pow10 *= 10;
		}
		mint ans = xm * geometricSum(pow10, n) + 1;
		rep(le, 2) rep(inc, 2) {
			int s = le * 2 + inc * 1;
			if(le == 1)
				ans -= b.at(0, s);
		}
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.145
advanced
----------
PROBLEM STATEMENT:
The Academy is a school where each common area is laid out on an [expression] meter. Danielle is their new head of security, and she wants to place a surveillance camera along every square meter of each common area. Because the school doesn't have enough money in their security budget to do this, she decides to further restrict camera placement according to the following rules:


Each cell can contain at most [expression] camera.
Every [expression] cameras.


Given the values of [expression].
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <ctype.h>
#include <deque>
#include <queue>
#include <cstring>
#include <set>
#include <list>
#include <map>
#include <random>
#include <unordered_map>
#include <stdio.h>

using namespace std;

typedef long long ll;
typedef std::vector<int> vi;
typedef std::vector<bool> vb;
typedef std::vector<string> vs;
typedef std::vector<double> vd;
typedef std::vector<long long> vll;
typedef std::vector<std::vector<int> > vvi;
typedef vector<vvi> vvvi;
typedef vector<vll> vvll;
typedef std::vector<std::pair<int, int> > vpi;
typedef vector<vpi> vvpi;
typedef std::pair<int, int> pi;
typedef std::pair<ll, ll> pll;
typedef std::vector<pll> vpll;

const long long mod = 1000000007;

#define all(c) (c).begin(),(c).end()
#define sz(c) (int)(c).size()
#define forn(i, a, b) for(int i = a; i < b; i++)

#define pb push_back
#define mp make_pair

int main()
{
    int t;
    vll d2(1,1);
    vll d3(1,1);
    forn(i,0,1000) {
        d2.pb((d2.back()*2ll)%mod);
        d3.pb((d3.back()*3ll)%mod);
    }
    scanf("%d", &t);
    forn(agag,0,t) {
        int m,n;
        ll ans = 36;
        scanf("%d %d", &m, &n);
        forn(i,0,3) {
            forn(j,0,3) {
                int l = (m+i)/3;
                int r = (n+j)/3;
                ans += ((d2[l] + mod - 2) % mod) * ((d3[r] + mod - 3) % mod);
                ans += ((d2[r] + mod - 2) % mod) * ((d3[l] + mod - 3) % mod);
                ans += mod*mod - ((d2[r] + mod - 2) % mod) * ((d2[l] + mod - 2) % mod);
                ans = ans%mod;
            }
        }
        forn(i,0,3) {
            int l = (m+i)/3;
            ans += 6*(d3[l] + mod - 3);
            ans += 3*(d2[l] + mod - 2);
            l = (n+i)/3;
            ans += 6*(d3[l] + mod - 3);
            ans += 3*(d2[l] + mod - 2);
        }
        ans = ans % mod;
        forn(i,0,3) {
            forn(j,i,3) {
                if(i != j) {
                    int l = (m+i)/3;
                    int r = (m+j)/3;
                    ans += ((d3[r] + mod - 3) % mod) * ((d3[l] + mod - 3) % mod);
                    ans = ans%mod;
                    l = (n+i)/3;
                    r = (n+j)/3;
                    ans += ((d3[r] + mod - 3) % mod) * ((d3[l] + mod - 3) % mod);
                    ans = ans%mod;
                }
                else {
                    int l = (m+i)/3;
                    ans += ((d3[l] + mod - 3) % mod) + 3*mod - 3*((d2[l] + mod - 2) % mod);
                    ans = ans%mod;
                    l = (n+i)/3;
                    ans += ((d3[l] + mod - 3) % mod) + 3*mod - 3*((d2[l] + mod - 2) % mod);
                    ans = ans%mod;
                }
                
            }
        }
        printf("%lld\n", ans);
        
    }
}



----------
====================
----------
MATHEMATICS.146
expert
----------
PROBLEM STATEMENT:
We need your help to divide candies at a very unusual party! 
There are [expression] different candies in total. There are three kinds of people at party:   


[expression] of them want to get odd number of candies,  
[expression] of them want to get even number of candies,
[expression] simply don't care about parity of candies they get.   


Find out the number of ways to divide all of [expression] people), such that everyone is satisfied.  Some people may not receive a candy.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ld double
#define vll vector<ll>
#define vi vector<int>
#define pb push_back
#define eb emplace_back
const int N = 1e5 + 10, mod = 7340033;
int fact[N], invfact[N];
inline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}
inline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}
inline int mul(int x, int y){ return (((ll) x) * y) % mod;}
inline int powr(int a, ll b){
	int x = 1 % mod;
	while(b){
		if(b & 1) x = mul(x, a);
		a = mul(a, a);
		b >>= 1;
	}
	return x;
}
inline int inv(int a){ return powr(a, mod - 2);}
void prefact(){
	fact[0] = invfact[0] = 1;
	for(int i = 1;i < N; i++) fact[i] = mul(i, fact[i - 1]);
	invfact[N - 1] = inv(fact[N - 1]);
	for(int i = N - 2; i >= 1; i--) invfact[i] = mul(invfact[i + 1], i + 1);
	assert(invfact[1] == 1);
}
inline int C(int n, int k){
	if(n < k || k < 0) return 0;
	return mul(fact[n], mul(invfact[k], invfact[n - k]));
}

struct base{
    ld x,y;
    base(){x=y=0;}
    base(ld _x, ld _y){x = _x,y = _y;}
    base(ld _x){x = _x, y = 0;}
    void operator = (ld _x){x = _x,y = 0;}
    ld real(){return x;}
    ld imag(){return y;}
    base operator + (const base& b){return base(x+b.x,y+b.y);}
    void operator += (const base& b){x+=b.x,y+=b.y;}
    base operator * (const base& b){return base(x*b.x - y*b.y,x*b.y+y*b.x);}
    void operator *= (const base& b){ld p = x*b.x - y*b.y, q = x*b.y+y*b.x; x = p, y = q;}
    void operator /= (ld k){x/=k,y/=k;}
    base operator - (const base& b){return base(x - b.x,y - b.y);}
    void operator -= (const base& b){x -= b.x, y -= b.y;}
};

double PI = 2.0*acos(0.0);
const int MAXN = 19;
const int maxn = (1<<MAXN);
base W[maxn],invW[maxn];
void precompute_powers(){
    for(int i = 0;i<maxn/2;i++){
        double ang = (2*PI*i)/maxn; 
        ld _cos = cos(ang), _sin = sin(ang);
        W[i] = base(_cos,_sin);
        invW[i] = base(_cos,-_sin);
    }
}
void fft (vector<base> & a, bool invert) {
    int n = (int) a.size();
 
    for (int i=1, j=0; i<n; ++i) {
        int bit = n >> 1;
        for (; j>=bit; bit>>=1)
            j -= bit;
        j += bit;
        if (i < j)
            swap (a[i], a[j]);
    }
    for (int len=2; len<=n; len<<=1) {
        for (int i=0; i<n; i+=len) {
            int ind = 0,add = maxn/len;
            for (int j=0; j<len/2; ++j) {
                base u = a[i+j],  v = (a[i+j+len/2] * (invert?invW[ind]:W[ind]));
                a[i+j] = (u + v);
                a[i+j+len/2] = (u - v);
                ind += add;
            }
        }
    }
    if (invert) for (int i=0; i<n; ++i) a[i] /= n;
}
void multiply (vll & a, vll b) {
    vector<base> fa (a.begin(), a.end()),  fb (b.begin(), b.end());
    int fsz = a.size()+b.size()-1;
    int n = 1;
    while (n < max (a.size(), b.size()))  n <<= 1;
    n <<= 1;
    fa.resize (n),  fb.resize (n);
 
    fft (fa, false),  fft (fb, false);
    for (size_t i=0; i<n; ++i) fa[i] *= fb[i];
    fft (fa, true);
 
    a.resize (fsz);
    for(int i = 0;i<fsz;i++)
        a[i] = ( (ll) (fa[i].real() + 0.5));
}
inline ll mul(ll a, ll b, ll mod){
    return (a*b)%mod;
}
void mul_big_mod(vll &a, vll b, ll mod){
    int n1 = a.size(),n2 = b.size();
    vll a1(n1),a2(n1),b1(n2),b2(n2),a3(n1),b3(n2);
    int base = (int)sqrt(mod)+10;
    for(int i = 0;i<n1;i++)
        a1[i] = a[i]/base,a2[i] = a[i]%base,a3[i] = (a1[i]+a2[i]);
    for(int i = 0;i<n2;i++)
         b1[i] = b[i]/base, b2[i] = b[i]%base, b3[i] = (b1[i]+b2[i]);
    multiply(a1,b1);
    multiply(a2,b2);
    multiply(a3,b3);
    int _sz = n1+n2-1;
    a.resize(_sz);
    for(int i = 0;i<_sz;i++){
        // a[i] = base * base * a1[i] + base * (a3[i] - a1[i] - a2[i]) + a2[i]
        a[i] = (mul(base*base,a1[i]%mod,mod)+mul(base,(a3[i]-a1[i] - a2[i])%mod,mod)+a2[i])%mod;
        if(a[i]<0) a[i]+=mod;
    }
}

vll v1(N);
vll v2(N);
int main(){
	precompute_powers();
	prefact();
	int n, a, b, c;
	cin >> n >> a >> b >> c;
	for(int i = 0; i <= a; i++){
		v1[2 * i] = C(a, i);
		if((a - i) % 2 == 1) v1[2 * i] = sub(0, v1[2 * i]);
	}
	for(int i = 0; i <= b; i++)v2[2 * i] = C(b, i);
	mul_big_mod(v1, v2, mod);
	int ans = 0;
	for(int i = 0; i < v1.size(); i++){
		ans = add(ans, mul(v1[i], powr((mod + i + c - a - b) % mod, n)));
	}
	ans = mul(ans, inv(powr(2, a + b)));
	cout << ans;
}
----------
====================
----------
MATHEMATICS.147
medium
----------
PROBLEM STATEMENT:
Grimmjow is not dead. He comes back to take revenge from Ichigo. This time, Grimmjow has a new release which gives a difficult mathematical question which is as follows. Given an odd prime number P, a non-negative integer K less than P, and positive integers U,V , find the number of ways of choosing a subset of (V * P) distinct numbers from the set {1, 2, 3, ..., (U * P)}, such that, the sum of these (V * P) numbers, when divided by P, leaves remainder K.  

Because his zanpakutou is useless here, Ichigo cannot do anything except to solve it. So, he asks you to solve it for him, so that, he can beat Grimmjow and rescue Orihime yet again. Since the answer can be large, output the number modulo (109+7).  

Input Format

Line 1: T  where T is the number of test cases. 
Lines 2 to T+1: U V K P 
U, V, K, P - As defined above.  

Output Format

A single integer on each line that denotes the number of ways to choose the subsets modulo (109+7).  

Constraints

1 ≤ T ≤ 5000 
1 ≤ V ≤ U 
( U * P ) ≤ 100000  

Sample Input

4
1 1 0 5
2 1 0 3
2 1 1 3
2 1 2 3


Sample Output

1
8
6
6


Explanation

In the first test case, we have to choose 5 numbers from {1, 2, 3, 4, 5} whose sum is divisible by 5. Only way to do this is to choose the set itself.

In the next three test cases, we have to choose 3 numbers from {1, 2, 3, 4, 5, 6}. There are 20 possible selections overall.  

The selections {1, 2, 3}, {1, 2, 6}, {1, 3, 5}, {1, 5, 6}, {2, 3, 4}, {2, 4, 6}, {3, 4, 5}, {4, 5, 6} are such that the sum of the chosen numbers leave remainder 0 when divided by 3.  

The selections {1, 2, 4}, {1, 3, 6}, {1, 4, 5}, {2, 3, 5}, {2, 5, 6}, {3, 4, 6} are such that the sum of the chosen numbers leave remainder 1 when divided by 3.  

The selections {1, 2, 5}, {1, 3, 4}, {1, 4, 6}, {2, 3, 6}, {2, 4, 5}, {3, 5, 6} are such that the sum of the chosen numbers leave remainder 2 when divided by 3.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <iostream>
#include <set>
#include <vector>
#include <cstring>
#include <string>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <complex>
#include <map>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vi> vvi;
typedef vector<double> vd;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef vector<pii> vii;
typedef vector<string> vs;
const int mod = 1000000007;

ll mpow (ll x, ll n, int mod) {
    ll res = 1;
    while (n) {
        if (n & 1) 
            res = res * x % mod;
        n /= 2;
        x = x * x % mod;
    }
    return res;
}

ll inv(ll x) {
    return mpow(x, mod-2, mod);    
}

vl fac(1000000, 1);
ll c(int k, int n) {
    return fac[n] * inv(fac[k]) % mod * inv(fac[n-k]) % mod;
}

int main() {
    for (int i = 1; i < fac.size(); ++i) {
        fac[i] = fac[i-1]*i % mod;
    }
    int T;
    cin >> T;
    for (int test = 1; test <= T; ++test) {
        ll u,v,k,p;
        cin >> u >> v >> k >> p;
        k %= p;
        ll c0 = c(v, u);
        ll c1 = c(v*p, u*p);
        ll ans = 0;
        if (k) {
            ans = (c1-c0)*inv(p)%mod;
        } else {
            ans = (c1+(p-1)*c0)%mod*inv(p)%mod;
        }
        cout << (ans+mod) % mod << endl;
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.148
expert
----------
PROBLEM STATEMENT:
Roy was given a string [expression]. The allowed modifications are:


He can add underscore ('_') character in anywhere inside the string.  
He can delete any existing character of the string.  
He can swap any two characters of the string.


Every character in the resulting string has a value equal to its ASCII value.

After doing the modifications the string needs to have the following properties:


The length of the string should be equal to [expression].  
There should be at least [expression] characters of higher value between two equal letters (Note that, underscore is not a letter).


Calculate how many different strings Roy can achieve modulo [expression].

Note: In the increasing order of ASCII value, we can arrange the alphabet in the following way, 
ABCDXYZ_

Input Format

The first line contains two space separated integers [expression].

Output Format

Print the number of different strings Roy can achieve modulo [expression].

Sample Input #1  

3 1
LBB


Sample Output #1 

15


Sample Input #2  

5 2
PPPP


Sample Output #2

9


Sample Input #3  

8 7
DQ


Sample Output #3

73


Sample Input #4  

1078 223
RMXQYQPKSSBJCAFWPXZ


Sample Output #4

451838


Explanation

In the first test case, the 15 valid strings are 
BLB 
BL_ 
B_B 
B_L 
B__ 
LB_ 
L_B 
L__ 
_BL 
_B_ 
_LB 
_L_ 
__B 
__L 
___
----------
TOP SOLUTION:
----------
#pragma comment(linker, "/STACK:64000000")
#include <iostream>
#include <cstdio>
#include <cassert>
#include <cmath>
#include <cstring>
#include <ctime>
#include <cstdlib>
#include <vector>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <map>
#include <set>
#include <sstream>
#include <bitset>
#include <algorithm>

#define forit(it,S) for(__typeof(S.begin()) it = (S).begin(); it != (S).end(); it++)
#define sz(x) (int)(x).size()
#define all(x) (x).begin(),(x).end()
#define ll long long
#define bit __builtin_popcountll
#define sqr(x) (x) * (x)
#define mp make_pair
#define pb push_back

using namespace std;

typedef pair<int, int> pii;

const double eps = 1e-9;
const double pi = acos(-1.0);

const int mod = (int)1e6 + 3;

int cnt[26];
int dp[27][2505];
int f[mod],ob[mod];

int binpow(int x, int y) {
	int res = 1;
	while(y > 0) {
		if (y & 1) res = res * 1LL * x % mod;
		x = x * 1LL * x % mod;
		y >>= 1;
	}
	return res;
}

void add(int &x, int y) {
	x += y;
	if (x >= mod) x -= mod;
}

int C(int n, int m) {
	int res = 1;
	while(n > 0 || m > 0) {
		int nn = n % mod; n /= mod;
		int mm = m % mod; m /= mod;
		if (nn < mm) {
			res = 0;
			break;
		}
		int cc = f[nn] * 1LL * ob[mm] % mod * 1LL * ob[nn - mm] % mod;
		res = res * 1LL * cc % mod;
	}
	return res;
}

int main() {

	f[0] = 1;
	for (int i = 1; i < mod; i++) {
		f[i] = f[i - 1] * 1LL * i % mod;
	}
	for (int i = 0; i < mod; i++) {
		ob[i] = binpow(f[i],mod - 2);
	}
	int n,kk; cin >> n >> kk;	
	string s; cin >> s;
	for (int i = 0; i < sz(s); i++) {
		cnt[s[i] - 'A']++;
	}
	dp[0][0] = 1;
	int sum = 0;
	for (int i = 0; i < 26; i++) {
		for (int j = 0; j <= sum && j <= n; j++) {
			add(dp[i + 1][j],dp[i][j]);
			for (int k = 1; k <= cnt[i] && j + k + (k - 1) * kk <= n; k++) {
				add(dp[i + 1][j + k],dp[i][j] * 1LL * C(n - j - k - (k - 1) * kk + k,k) % mod);
			}
		}
		sum += cnt[i];
	}
	int res = 0;
	for (int i = 0; i <= sum; i++) {
		add(res,dp[26][i]);
	}
	cout << res << endl;
	return 0;
}

----------
====================
----------
MATHEMATICS.149
medium
----------
PROBLEM STATEMENT:
The binomial coefficient C(N, K) is defined as
N! / K! / (N − K)! for 0 ≤ K ≤ N. 
Here N! = 1 * 2 * ... * N for N ≥ 1, and 0! = 1.

You are given a prime number P and a positive integer N. 

AL is defined as the number of elements in the sequence C(N, K), such that, PL divides C(N, K),
but PL+1 does not divide C(N, K). Here, 0 ≤ K ≤ N.

Let M be an integer, such that, AM  0,
but AL = 0 for all L  M.
Your task is to find numbers A0, A1, ..., AM.

Input Format 
The first line of the input contains an integer T, denoting the number of test cases.
The description of T test cases follows.
The only line of each test case contains two space-separated integers N and P.

Output Format 
For each test case, display M + 1 space separated integers
A0, A1, ..., AM
on the separate line.

Constraints

1 ≤ T ≤ 100 
1 ≤ N ≤ 1018 
2 ≤ P 18 
P is prime  

Sample Input

3
4 5
6 3
10 2


Sample Output

5
3 4
4 4 1 2


Explanation  

Example case 1. Values C(4, K) are {1, 4, 6, 4, 1}.
Each of them is not divisible by 5.
Therefore, A0 = 5, A1 = 0, A2 = 0, ..., hence the answer.

Example case 2. Values C(6, K) are {1, 6, 15, 20, 15, 6, 1}.
Among them 1, 20, 1 are not divisible by 3,
while remaining values 6, 15, 15, 6 are divisible by 3, but not divisible by 9.
Therefore, A0 = 3, A1 = 4,
A2 = 0, A3 = 0, ..., hence the answer.

Example case 3. Values C(10, K) are {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}.
Among them 1, 45, 45, 1 are not divisible by 2,
values 10, 210, 210, 10 are divisible by 2, but not divisible by 4,
value 252 is divisible by 4, but not divisible by 8,
finally, values 120, 120 are divisible by 8, but not divisible by 16.
Therefore, A0 = 4, A1 = 4,
A2 = 1, A3 = 2,
A4 = 0, A5 = 0, ..., hence the answer.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
using namespace std;
long long dp[64][64][2];
int main(){
    CASET{
        long long n,p,nn;
        cin>>n>>p;
        nn=n;
        vector<long long>d;
        while(n){
            d.PB(n%p);
            n/=p;
        }
        if(SZ(d)==1)cout<<nn+1<<endl;
        else{
            MS0(dp);
            dp[0][0][0]=1;
            REP(i,SZ(d)){
                REP(j,62){
                    dp[i+1][j+1][1]+=dp[i][j][0]*(p-d[i]-1);
                    dp[i+1][j][0]+=dp[i][j][0]*(d[i]+1);
                    dp[i+1][j+1][1]+=dp[i][j][1]*(p-d[i]);
                    dp[i+1][j][0]+=dp[i][j][1]*d[i];
                }
            }
            bool start=false;
            vector<long long>res;
            for(int i=63;i>=0;i--){
                if(dp[SZ(d)][i][0]){
                    if(!start){
                        start=true;
                    }
                }
                if(start){
                    res.PB(dp[SZ(d)][i][0]);
                }
            }
            for(int i=SZ(res)-1;i>=0;i--){
                if(i!=SZ(res)-1)putchar(' ');
                cout<<res[i];
            }
            puts("");
        }
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.150
medium
----------
PROBLEM STATEMENT:
You are given a set A containing n integers from 1 to n; A = {1,2,3,...n}. 
Let's call P(A) as a set that contains all permutations of A; 
For eg: if A = {1,2}. P(A) = {{1,2},{2,1}}

Can you find the number of elements a ∈ P(A) which satisfies following conditions:


For every 1 th integer in permutation a
There exists a set of k integers {i1, i2, i3, .... ik} such that 
a[ij] = ij+1 ∀ j k] = i1 (cyclic)


Input Format 
The first line contains an integer T indicating the number of test-cases.
T lines follow. Each line has two integers n and k separated by a single space.

Constraints 
1 
1 6

Output Format 
Output the remainder of the answer after divided by 1000000007 ie., (109+7)

Sample Input

4
3 2
4 2
5 3
6 2


Sample Output

0
3
20
105


Hint
109+7 is a prime number.

Explanation

note : Array's are 1 indexed. 

Lets take a look at N = 3 and K = 2

We will get 2 sets of A that satisfy the first property a[i] ≠ i, they are 


[3,1,2]
[2,3,1]


Now, as K = 2, we can have 6 such elements. 


[1,2], [1,3],[2,3], [2,1], [3,1], [3,2]


Lets consider the first element of P(A) - [3,1,2] 


[1,2], a[1] ≠ 2
[1,3], a[1] = 3 but a[3] ≠ 1
[2,3], a[2] ≠ 3
[2,1], a[2] = 1 but a[1] ≠ 2
[3,1], a[3] = 1 but a[1] ≠ 3
[3,2], a[3] ≠ 2


Lets consider the second element of P(A) - [2,3,1]


[1,2], a[1] = 2 but a[2] ≠ 1
[1,3], a[1] ≠ 3
[2,3], a[2] = 3 but a[3] ≠ 3
[2,1], a[2] ≠ 1
[3,1], a[3] = but a[1] ≠ 3
[3,2], a[3] ≠ 2


As none of the elements of a satisfy the properties above, hence 0. 

In the second case, n=4,k=2. Here follows all the permutations of 

A={1,2,3,4} we could find that satisfy the two condition above.

2 1 4 3 # (a[2] = 1, a[1] = 2) or (a[4] = 3, a[3] = 4) is ok.

4 3 2 1 # (a[4] = 1, a[1] = 4) or (a[3] = 2, a[2] = 3) is ok.

3 4 1 2 # (a[3] = 1, a[1] = 3) or (a[4] = 2, a[2] = 4) is ok.

Timelimits
Timelimits for this challenge is given here
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

const int md = 1000000007;
const int co = 1000010;

int fact[co + 10], inv[co + 10], invfact[co + 10];
int good[co + 10];

int C(int n, int m) {
    int res = fact[n];
    res = (long long)res * invfact[m] % md;
    res = (long long)res * invfact[n - m] % md;
    return res;
}

int main() {
    fact[0] = 1;
    for (int i = 1; i <= co; i++) fact[i] = (long long)fact[i - 1] * i % md;
    inv[0] = 0;
    invfact[0] = 1;
    for (int i = 1; i <= co; i++) {
        int x = 1, step = 1 << 30;
        while (step > 0) {
          x = (long long)x * x % md;
          if (step & (md - 2)) x = (long long)x * i % md;
          step >>= 1;
        }
        inv[i] = x;
        invfact[i] = (long long)invfact[i - 1] * inv[i] % md;
    }
    good[0] = 1;
    good[1] = 0;
    good[2] = 1;
    for (int i = 3; i <= co; i++) {
        good[i] = (long long)good[i - 1] * i % md;
        if (i & 1) {
            good[i]--;
            if (good[i] < 0) good[i] += md;
        } else {
            good[i]++;
            if (good[i] >= md) good[i] -= md;
        }
    }
    int tt;
    cin >> tt;
    while (tt--) {
        int n, k;
        cin >> n >> k;
        int ans = 0;
        int ways = 1;
        if (k > 1) {
            for (int cycles = 1; k * cycles <= n; cycles++) {
                ways = (long long)ways * C(n - k * (cycles - 1), k) % md;
                ways = (long long)ways * fact[k - 1] % md;
                ways = (long long)ways * inv[cycles] % md;
                int cur = (long long)ways * good[n - k * cycles] % md;
                if (cycles & 1) {
                    ans += cur;
                    if (ans >= md) ans -= md;
                } else {
                    ans -= cur;
                    if (ans < 0) ans += md;
                }
            }
        }
        cout << ans << endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.151
advanced
----------
PROBLEM STATEMENT:
Consider a rooted binary tree with [expression] vertices containing numbers. Each vertex of the tree either has two sons (left son and right son), or no sons. We will call such a tree heap, if and only if for all vertices (except the root), the number assigned the vertex is smaller or equal to the parent's number.

Consider a heap and the following function:

dfs(vertex){
    print number in the vertex
    if (vertex is not a leaf) {
        dfs(left son of the vertex)
        dfs(right son of the vertex)
    }
}


You are given a sequence [expression].

Constraints

[expression] 
[expression]
----------
TOP SOLUTION:
----------
#define _USE_MATH_DEFINES
#include <algorithm>
#include <cstdio>
#include <functional>
#include <iostream>
#include <cfloat>
#include <climits>
#include <cstring>
#include <cmath>
#include <fstream>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <time.h>
#include <vector>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> i_i;
typedef pair<ll, int> ll_i;
typedef pair<double, int> d_i;
typedef pair<ll, ll> ll_ll;
typedef pair<double, double> d_d;
struct edge { ll B, T, F, P; };

unsigned MOD = 1000000007;
ll _MOD = 1000000009;
double EPS = 1e-10;
int UNKO = INT_MAX;

struct segment_tree_max {
	int n; vector<int> v;
	segment_tree_max(int _n) {
		for (n = 1; n < _n; n *= 2);
		v = vector<int>(n * 2 - 1, INT_MIN);
	}
	void set(int i, int x) {
		int k = i + n - 1;
		v[k] = x;
		while (k > 0) {
			k = (k - 1) / 2;
			v[k] = max(v[k * 2 + 1], v[k * 2 + 2]);
		}
	}
	int _get(int i, int j, int k, int l, int r) {
		if (r <= i || j <= l) return INT_MIN;
		if (i <= l && r <= j) return v[k];
		int vl = _get(i, j, k * 2 + 1, l, (l + r) / 2);
		int vr = _get(i, j, k * 2 + 2, (l + r) / 2, r);
		return max(vl, vr);
	}
	int get(int i, int j) { return _get(i, j, 0, 0, n); }
};

ll f(vector<int>& a, segment_tree_max& st, int l, int r, map<i_i, ll>& memo) {
	if (memo.count(i_i(l, r))) return memo[i_i(l, r)];
	if (r - l == 1) return 1;
	ll sum = 0;
	int x;
	for (x = l + 1; x < r && a[x] <= a[l + 1]; x++);
	int maxi = st.get(x, r);
	for (int m = min(r - 1, x); m >= l + 1; m--) {
		maxi = max(maxi, a[m]);
		if (a[m] == maxi && (r - m) % 2)
			sum = (sum + f(a, st, l + 1, m, memo) * f(a, st, m, r, memo)) % MOD;
	}
	return memo[i_i(l, r)] = sum;
}

int main() {
	int n; cin >> n;
	vector<int> a(n);
	for (int i = 0; i < n; i++)
		scanf("%d", &a[i]);
	segment_tree_max st(n);
	for (int i = 0; i < n; i++)
		st.set(i, a[i]);
	map<i_i, ll> memo;
	cout << f(a, st, 0, n, memo) << endl;
}
----------
====================
----------
MATHEMATICS.152
advanced
----------
PROBLEM STATEMENT:
Little Sasha likes to swap elements in his array. Initially, he has an array of [expression] times. However, Sasha forgot his favorite swap sequence the next day. 

Given the resulting permutation, find the swap sequence used by Sasha or say that there is no such sequence.

 
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;
#define MP make_pair
#define PB push_back
#define LL long long
#define int LL
#define FI first
#define SE second
#define R(i,n) for(int i=0;i<n;i++)
#define F(i,a,b) for(int i=a;i<b;i++)
#define FD(i,n) for(int i=n-1;i>=0;i--)
#define ALL(x) (x).begin(), (x).end()
#define SZ(x) ((int)(x).size())
#define PII pair<int,int>
#define VI vector<int>
template<class C> void mini(C&a4, C b4){a4=min(a4,b4);}
template<class C> void maxi(C&a4, C b4){a4=max(a4,b4);}

template<class TH> void _dbg(const char *sdbg, TH h){cerr<<sdbg<<"="<<h<<"\n";}
template<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a){
  while(*sdbg!=',')cerr<<*sdbg++;cerr<<"="<<h<<","; _dbg(sdbg+1,a...);
}

#ifdef LOCAL
#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)
#define debugv(C) {for(auto&c:C)cerr<<c<<",";cerr<<endl;}
#else
#define debug(...) (__VA_ARGS__)
#define debugv(C) {}
#define cerr if(0) cout
#endif
#define MAX 100001
vector<vector<int>> cykle[MAX];
void nie(){
  cout << "no solution\n";
  exit(0);
}
int n,k,t;
int in[MAX];
int wyn[MAX];
bool cz[MAX];
#undef int
int main(){
#define int LL
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  cout<<fixed<<setprecision(11);
  cin >> n >> k >> t;
  R(i,n){
    cin >> in[i];
    in[i]--;
  }
  R(i,n)if(cz[i] == 0){
    vector<int> cykl;
    int ak = i;
    while(cz[ak] == 0){
      cz[ak] = 1;
      cykl.PB(ak);
      ak = in[ak];
    }
    cykle[SZ(cykl)].PB(cykl);
  }
  vector<PII> res,res2;
  bool czzl = 0;
  F(i,1,n+1)if(SZ(cykle[i])){
    int pom = __gcd(i,t);
    while(1){
      int pom2 = __gcd(pom*pom,t);
      if(pom2 == pom)break;
      pom = pom2;
    }
    debug(i,SZ(cykle[i]),pom);
    if(SZ(cykle[i]) % pom != 0)nie();
    R(j,SZ(cykle[i])/pom){
      R(k,pom){
        int ak = k;
        for(auto x:cykle[i][j*pom+k]){
          wyn[ak] = x;
          ak = (ak+t)%(i*pom);
        }
      }
      R(j,i*pom-1)res.PB({wyn[j],wyn[j+1]});
      R(j,i*pom-1)res2.PB({wyn[j],wyn[j+1]});
    }
    if(czzl == 0 && t%2 == 0 && pom%2 != 0 && SZ(cykle[i])%2 == 0){
      czzl = 1;
      res2.resize(SZ(res2)-2*i*pom+2);
      R(k,pom*2){
        int ak = k;
        for(auto x:cykle[i][SZ(cykle[i])-k-1]){
          wyn[ak] = x;
          ak = (ak+t)%(2*i*pom);
        }
      }
      R(j,2*i*pom-1)res2.PB({wyn[j],wyn[j+1]});
    }
  }
  debug(k,SZ(res),czzl,SZ(res2));
  if(k < SZ(res) || (czzl == 0 && (k+SZ(res))%2 != 0))nie();
  if((k+SZ(res))%2 != 0){
    debug("swap!!!!!!!!!!!!!!!!!!!!1");
    swap(res,res2);
  }
  while(k!=SZ(res)){
    res.PB({0,1});
    res.PB({0,1});
  }
  for(auto x:res){
    cout << x.FI+1  << " " << x.SE+1 << "\n";
  }
}

----------
====================
----------
MATHEMATICS.153
hard
----------
PROBLEM STATEMENT:
Your task is to calculate the sum (indicated by S) of all the k-balanced integers between [L, R]. An integer is called k-balanced when either of #1 or #2 below holds true.


The length of the integer 
Sum of the first k digits (with no leading zeros) is equal to the sum of the last k digits.    


Input format 
L R k

Output format 
S % 1000000007

Constraints 
0 
0 

Sample Input 
9 23 1

Sample Output 
42

Explanation 
9, 11 and 22 are the only 3 integers between 9 and 23 ( both included ) that are k-balanced. Hence, the answer is 9+11+22=42
----------
TOP SOLUTION:
----------
#include <algorithm>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <iterator>
#include <limits>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
using namespace std;


/* Prewritten code begins */
#define LL          long long
#define FILL(a,v)   memset(a,v,sizeof(a))
#define FOR(i,a,b)  for(int i=(a); i<=(b); ++i)
/* Prewritten code ends */

const int MOD = 1000000007, maxD = 18;
int D[maxD], pot[maxD+1] = {1,}, nD, K;
inline void inc_mod(int &a, int b) {
	if((a += b) >= MOD) a -= MOD;
}
int mem_g[maxD+1][maxD+1][2][maxD*2*9+1];
int mem_suma[maxD+1][maxD+1][2][maxD*2*9+1];
int g(int pos, int nzpos, int lo, int sum) {
	int &res = mem_g[pos][nzpos][lo][sum+maxD*9];
	if(res >= 0) return res;
	res = 0;
	if(pos == nD) return res = sum == 0;
	for(int d = lo ? 9 : D[pos]; d >= 0; d--) {
		int tsum = sum;
		int tnzpos = nzpos ? nzpos+1 : d > 0 ? 1 : 0;
		if( tnzpos <= K) tsum += d;
		if( nD-pos <= K) tsum -= d;
		inc_mod(res, g(pos+1, tnzpos, lo || d < D[pos], tsum)); 
	}
	return res;
}
int suma(int pos, int nzpos, int lo, int sum) {
	int &res = mem_suma[pos][nzpos][lo][sum+maxD*9];
	if(res >= 0) return res;
	res = 0;
	if(pos == nD) return res;
	for(int d = lo ? 9 : D[pos]; d >= 0; d--) {
		int tsum = sum;
		int tnzpos = nzpos ? nzpos+1 : d > 0 ? 1 : 0;
		if( tnzpos <= K) tsum += d;
		if( nD-pos <= K) tsum -= d;
		int cnt = g(pos+1, tnzpos, lo || d < D[pos], tsum);
		inc_mod(res, (LL)d*cnt*pot[nD-1-pos]%MOD);
		inc_mod(res, suma(pos+1, tnzpos, lo || d < D[pos], tsum));
	}
	return res;
}
int f(LL x) {
	FILL(mem_g, 0xFF);
	FILL(mem_suma, 0xFF);

	LL tx = x; nD = 0;
	do {
		D[nD++] = tx%10;
		tx /= 10;
	} while(tx);
	reverse(D,D+nD);

	return suma(0, 0, 0, 0);
}
int main() {
	FOR(i,1,maxD) pot[i] = 10LL*pot[i-1]%MOD;
	LL L, R;
	cin >> L >> R >> K;
	cout << (f(R)-f(L-1)+MOD)%MOD << endl;
	return 0;
}

----------
====================
----------
MATHEMATICS.154
advanced
----------
PROBLEM STATEMENT:
The longer the code, the stronger the code. The power number (P) of a code determines the strength of a code.

While computing the power number of a code we should ignore the keywords in the code. A few sample key words would be int, unsigned, string, etc. The power of a code can be determined by the number of characters in the code that do not belong to any of the keywords.

More formally, for each keyword K, consider all the occurrences of K in the code, ignore all these matching substrings while computing the power. See the example for clarity.

Example: 
If you take a code to be

[expression]



The above code has 37 characters in total.

If the key words are

[expression]
[expression]
[expression]
[expression]



Then the power of the above code would be 20, spaces need to be counted:

[expression]
[expression]
[expression]



The codes can be concatenated to be made more powerful. If we have two codes C1, C2 with power P1, P2, the power of code C1 [expression] denotes concatenation) will be P1 + P2.

While concatenating two codes, a % character gets inseted in between the two codes. For example if C1 was print 5; and C2 was print 6;, C1 $ C2 = print 5;%print 6;

You are given N codes, K keywords, you can use each code as many number of times as you want. You are to output the largest power X, that can't be attained by concatinating the codes.

Note:

All the following operations are possible.


Two same codes can be concatenated with each other.
Some codes need not be used in the concatenation.
Each code can be used any number of times.


Input Format 
First line contains N. In the following N lines, the ith line represents the code Ci. The following line contains K the number of keywords. The following K lines one keyword each.

Output Format 
Print a single line containing X as described above.

Constraints

[expression]
[expression]
[expression]
[expression]



Note:


Key words do not contain spaces. Both the code and the key words do not contain % character. They can contain any other ASCII character.
If the answer is infinite then print -1.


Sample Input: #1

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



Sample Output: #1

[expression]



Sample Input: #2

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



Sample Output: #2

[expression]



Explanation:

In sample 1, the powers of codes are 6, 7, 6, 6. And hence the maximum unattainable power by combination is 29. In sample 2, the powers are 4, 0, 3, and hence the result is 5.
----------
TOP SOLUTION:
----------
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#define fo(i,a,b) dfo(int,i,a,b)
#define fr(i,n) dfr(int,i,n)
#define fe(i,a,b) dfe(int,i,a,b)
#define fq(i,n) dfq(int,i,n)
#define nfo(i,a,b) dfo(,i,a,b)
#define nfr(i,n) dfr(,i,n)
#define nfe(i,a,b) dfe(,i,a,b)
#define nfq(i,n) dfq(,i,n)
#define dfo(d,i,a,b) for (d i = (a); i < (b); i++)
#define dfr(d,i,n) dfo(d,i,0,n)
#define dfe(d,i,a,b) for (d i = (a); i <= (b); i++)
#define dfq(d,i,n) dfe(d,i,1,n)
#define ffo(i,a,b) dffo(int,i,a,b)
#define ffr(i,n) dffr(int,i,n)
#define ffe(i,a,b) dffe(int,i,a,b)
#define ffq(i,n) dffq(int,i,n)
#define nffo(i,a,b) dffo(,i,a,b)
#define nffr(i,n) dffr(,i,n)
#define nffe(i,a,b) dffe(,i,a,b)
#define nffq(i,n) dffq(,i,n)
#define dffo(d,i,a,b) for (d i = (b)-1; i >= (a); i--)
#define dffr(d,i,n) dffo(d,i,0,n)
#define dffe(d,i,a,b) for (d i = (b); i >= (a); i--)
#define dffq(d,i,n) dffe(d,i,1,n)
#define ll long long
#define alok(n,t) ((t*)malloc((n)*sizeof(t)))
#define pf printf
#define sf scanf
#define pln pf("\n")

#define lim 1111111
#include<algorithm>
using namespace std;

char line[lim];
char word[lim];
char **C;
int *Cl;
int **gd;
int *bd;
ll *a;

int *onQ;
int *Q;
int *P;
ll *S;

ll frob(int n) {
	onQ = alok(a[0], int);
	Q = alok(31111111, int);
	P = alok(a[0], int);
	fr(i,a[0]) onQ[i] = 0;
	onQ[0] = 1;
	Q[0] = 0;
	P[0] = n-1;
	S = alok(a[0], ll);
	S[0] = 0;
	fo(i,1,a[0]) S[i] = a[0]*a[n-1];
	int ql = 1;
	fr(qi,ql) {
		int v = Q[qi];
		onQ[v] = 0;
		fq(j,P[v]) {
			int u = (v + a[j]) % a[0];
			ll w = S[v] + a[j];
			if (w < S[u]) {
				S[u] = w;
				P[u] = j;
				if (!onQ[u]) {
					onQ[u] = 1;
					Q[ql++] = u;
				}
			}
		}
	}
	ll mx = S[0];
	fo(i,1,a[0]) if (mx < S[i]) mx = S[i];
	return mx - a[0];
}

ll gcd(ll a, ll b) {
	return b ? gcd(b, a % b) : a;
}
int *machine[1111];
int main() {
	fr(i,1111) machine[i] = alok(128, int);
	//a = alok(111, ll);
	//a[0] = 3; a[1] = 5; pf("%lld\n", frob(2));
	//a[0] = 3; a[1] = 5; a[2] = 7; pf("%lld\n", frob(3));
	//a[0] = 3*5; a[1] = 3*7; a[2] = 5*7; pf("%lld\n", frob(3));

	fgets(line, lim, stdin);
	int n;
	sscanf(line, "%d", &n);
	Cl = alok(n, int);
	C = alok(n, char*);
	gd = alok(n, int*);
	bd = alok(lim, int);
	fr(i,n) {
		C[i] = alok(lim, char);
		fgets(C[i], lim, stdin);
		Cl[i] = strlen(C[i])-1;//
		C[i][Cl[i]] = 0;
		gd[i] = alok(Cl[i], int);
		fr(j,Cl[i]) gd[i][j] = 1;
	}
	int k;
	fgets(line, lim, stdin);
	sscanf(line, "%d", &k);
	fr(xi,k) {
		fgets(line, lim, stdin);
		sscanf(line, "%s", word);
		int lw = strlen(word);
		// make machine word
		fr(i,128) machine[0][i] = 0;
		int i, j;
		for (i = 0, j = -1; i < lw; i++) {
	        if (j >= 0) {
	            for (int k = 0; k < 128; k++) {
	                machine[i][k] = machine[j][k];
	            }
	        }
	        char d = word[i];
	        machine[i][d] = i + 1;
	        j = j < 0 ? 0 : machine[j][d];
	    }
		fr(jj,n) {
			// feed to machine
			fr(l,Cl[jj]) bd[l] = 0;
			int cst = 0;
			fr(l,Cl[jj]) {
				cst = machine[cst][C[jj][l]];
				if (cst == lw) {
					bd[l - lw + 1] = 1;
					cst = j;
				}
			}
			int mxbd = -1;
			fr(l,Cl[jj]) {
				if (bd[l]) mxbd = l;
				if (mxbd >= 0 && l - lw < mxbd) gd[jj][l] = 0;
			}
		}
	}
	a = alok(n, ll);
	ll g = 0;
	fr(i,n) {
		a[i] = 0;
		fr(j,Cl[i]) {
			if (gd[i][j]) a[i]++;
		}
		g = gcd(g, a[i]);
	}
	if (g == 1) {
		sort(a, a + n);
		while (!a[0]) a++ ,n--;
		ll f = frob(n);
		pf("%lld\n", f);
	} else {
		pf("-1\n");
	}
}

----------
====================
----------
MATHEMATICS.155
expert
----------
PROBLEM STATEMENT:
Imagine you have a rooted tree consisting of [expression] vertices. Consider the following function:

int order[n]; // initially consists of -1
int pointer = 0;
void dfs(int vertex, int depth) {
  order[pointer] = depth;
  pointer++;
  for each child of vertex
    dfs(child, depth + 1);
}


In the end this function produces an array [expression] vertices. 

You are given an array [expression].

Input Format  

The first line contains a single integer [expression].  

Constraints 
[expression] 
[expression]

Output Format

Print a single integer [expression].

Sample Input #0

3
? ? ?    


Sample Output #0

2


Sample Input #1

2
1 ?


Sample Output #1

0


Sample Input #2

4
0 ? 1 ?


Sample Output #2

2


Explanation

In sample#0 there are two possible arrays: [0, 1, 2] and [0, 1, 1];

In sample#1 there cannot be any suitable arrays, because each of them starts with 0.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <iostream>
#include <set>
#include <vector>
#include <cstring>
#include <string>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <complex>
#include <map>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vi> vvi;
typedef vector<vl> vvl;
typedef vector<double> vd;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef vector<pii> vii;
typedef vector<string> vs;
const int mod = 1000000007;

vl fac(200005, 1);
vl invfac(200005, 1);
ll mpow (ll x, ll n) {
    ll res = 1;
    while (n) {
        if (n & 1) {
            res = res * x % mod;
        }
        x = x * x % mod;
        n /= 2;
    }
    return res;
}

ll inv (ll x) {
    return mpow(x, mod - 2);    
}

ll c(int k, int n) {
    if (k < 0 || k > n) return 0;
    return fac[n] * invfac[k] % mod * invfac[n-k] % mod;
}

int main() {
    for (int i = 2; i < fac.size(); ++i) {
        fac[i] = fac[i-1] * i % mod;
        invfac[i] = inv(fac[i]);
    }
    int n;
    cin >> n;
    vi a(n);
    string in;
    for (int i = 0; i < n; ++i) {
        cin >> in;
        if (in == "?") {
            a[i] = -1;
        } else {
            a[i] = stoi(in);            
        }
    }
    if (a[0] > 0) {
        cout << 0 << endl;
        return 0;
    }
    a[0] = 0;
    for (int i = 1; i < n; ++i) if (a[i] == 0) {
        cout << 0 << endl;
        return 0;
    }
    int mi = 0;
    for (int i = 1; i < n; ++i) if (a[i] != -1) {
        mi = min(mi, a[i] - i);
        if (a[i] - i > mi) {
            cout << 0 << endl;
            return 0;
        }
    }
    ll res = 1;
    mi = 0;
    int prev = 0;
    for (int i = 1; i < n; ++i) if (a[i] != -1) {
        int t = a[i] - i;
        int k = mi - t;
        int box = i - prev;
        ll mul = c(k, k + box - 1);
        //if (t < -prev) { // ?
            int k1 = k + a[i];
            int box1 = box - a[i];
            mul -= c(k1, k1 + box1 - 1);
        //}
        res = res * mul % mod;
        mi = min(mi, t);
        prev = i;
    }
    //cerr << res << endl;
    if (prev != n-1) {
        int t = 1 - (n-1);
        int dy = mi - t + 1;
        int dx = n - prev - 1;
        //cerr << dx << ' ' << dy << endl;
        ll mul = c(dy, dx + dy);
        int dy1 = dy + 1;
        int dx1 = dx - 1;
        mul -= c(dy1, dy1 + dx1);
        res = res * mul % mod;
    }
    cout << (res + mod) % mod << endl;
    return 0;
}
----------
====================
----------
MATHEMATICS.156
advanced
----------
PROBLEM STATEMENT:
You are given two integers [expression].
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

#define ll long long
#define ull unsigned ll

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
int reader(char c[]){int i,s=0;for(;;){mygc(i);if(i!=' '&&i!='\n'&&i!='\r'&&i!='\t'&&i!=EOF) break;}c[s++]=i;for(;;){mygc(i);if(i==' '||i=='\n'||i=='\r'||i=='\t'||i==EOF) break;c[s++]=i;}c[s]='\0';return s;}
template <class T, class S> void reader(T *x, S *y){reader(x);reader(y);}
template <class T, class S, class U> void reader(T *x, S *y, U *z){reader(x);reader(y);reader(z);}
template <class T, class S, class U, class V> void reader(T *x, S *y, U *z, V *w){reader(x);reader(y);reader(z);reader(w);}

void writer(int x, char c){int s=0,m=0;char f[10];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(ll x, char c){int s=0,m=0;char f[20];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}
void writer(const char x[], char c){int i;for(i=0;x[i]!='\0';i++)mypc(x[i]);mypc(c);}
template<class T> void writerLn(T x){writer(x,'\n');}
template<class T, class S> void writerLn(T x, S y){writer(x,' ');writer(y,'\n');}
template<class T, class S, class U> void writerLn(T x, S y, U z){writer(x,' ');writer(y,' ');writer(z,'\n');}
template<class T> void writerArr(T x[], int n){int i;if(!n){mypc('\n');return;}rep(i,n-1)writer(x[i],' ');writer(x[n-1],'\n');}

#define MD 1000000007

void unionInit(int d[],int s){int i;rep(i,s)d[i]=i;}
int unionGet(int d[],int n){int t=n,k;while(d[t]!=t)t=d[t];while(d[n]!=n)k=d[n],d[n]=t,n=k;return n;}
int unionConnect(int d[],int a,int b){a=unionGet(d,a);b=unionGet(d,b);if(a==b)return 0;d[a]=b;return 1;}

int N, L;


/*
  // A055314
int res[1000];
int deg[1000];

void solve(int a, int b, int ind[]){
  int i, j, k;
  int send[10];

  if(a==N){
    REP(i,1,N) if(unionGet(ind,0) != unionGet(ind,i)) return;
    k = 0;
    rep(i,N) if(deg[i]==1) k++;
    res[k]++;
    return;
  }
  if(b==N){
    solve(a+1,a+2,ind);
    return;
  }
  if(unionGet(ind, a)==unionGet(ind, b)){ solve(a,b+1,ind); return; }

  rep(i,N) send[i] = ind[i];
  unionConnect(send,a,b);
  deg[a]++; deg[b]++;
  solve(a,b+1,send);

  deg[a]--; deg[b]--;
  solve(a,b+1,ind);
}

int main(){
  int i, j, k;
  int ind[1000];

  reader(&N,&L);

  rep(i,N) deg[i] = 0;
  unionInit(ind,N);
  solve(0, 1, ind);

  rep(i,N) printf("%d %d\n",i,res[i]);

  return 0;
}
*/

template<class T> void getInverseList(int n, T res[], int p){int i;res[1]=1;REP(i,2,n)res[i]=p-((ll)(p/i)*res[p%i]%p);}
ull pw(ull a, ull b, ull m){ull r=1;while(b){if(b&1)r=r*a%m;b>>=1;a=a*a%m;}return r;}

ll fact[1100000], fact_inv[1100000], inv[1100000];

ll comb(int a, int b){
  if(b < 0 || b > a) return 0;
  return fact[a] * fact_inv[b] % MD * fact_inv[a-b] % MD;
}

int main(){
  int i, j, k;
  ll res, add;
  
  reader(&N,&L); N--;
  getInverseList(1100000, inv, MD);
  fact[0] = fact_inv[0] = 1;
  REP(i,1,1100000) fact[i] = fact[i-1] * i % MD;
  REP(i,1,1100000) fact_inv[i] = fact_inv[i-1] * inv[i] % MD;

  res = 0;
  rep(i,N-L+2){
    add = comb(N+1-L, i);
    if( (N+1-L-i)%2 ) add = -add;
    (add *= pw(i,N-1,MD)) %= MD;
    res += add;
  }
  res %= MD;
  (res *= comb(N+1,L)) %= MD;
  if(res < 0) res += MD;
  writerLn((int)res);
  
  return 0;
}

----------
====================
----------
MATHEMATICS.157
hard
----------
PROBLEM STATEMENT:
Count the number of labeled strongly connected digraphs with the given number of vertices.  

Input Format 
The first line contains [expression], the number of queries. 
Following are [expression], denoting the number of vertices.  

Output Format 
Output [expression]. 

Constraints 
[expression] 
[expression]  

Sample Input

5
1
2
3
4
1000


Sample Output

1
1
18
1606
871606913


Explanation

You can refer to oeis.
----------
TOP SOLUTION:
----------
#include <vector> 
#include <list> 
#include <map> 
#include <set> 
#include <queue>
#include <stack> 
#include <bitset> 
#include <algorithm> 
#include <numeric> 
#include <utility> 
#include <sstream> 
#include <iostream> 
#include <iomanip> 
#include <cstdio> 
#include <cmath> 
#include <cstdlib> 
#include <ctime> 
#include <cstring> 

using namespace std; 

typedef long long ll; 
typedef pair<int, int> pii;

#define INF 1000000000
#define pb push_back 
#define itr iterator 
#define sz size() 
#define mp make_pair

const int mod = 1000000007;

long long pot[1100000];
long long ch[1100][1100];
long long s[1100];
long long nn[1100];

// a*x + b*y = gcd(a,b)
int extGcd(int  a, int b, int &x, int &y){
    if(b == 0){
        x = 1;
        y = 0;
        return a;
    }
    
    int g = extGcd(b,a % b,y,x);
    y -= a / b * x;
    return g;
}

// ASSUME: gcd(a, m) == 1
int modInv(int a){
    int x,y;
    extGcd(a, mod, x, y);
    return (x % mod + mod) % mod;
}

int main() {
	pot[0] = 1;
	for (int i = 1; i <= 1100000; i++) {
		pot[i] = (pot[i-1] * 2) % mod;
	}

	for (int i = 0; i <= 1000; i++) {
		for (int j = 0; j <= i; j++) {
			if (j == 0) ch[i][j] = 1;
			else ch[i][j] = (ch[i-1][j-1] + ch[i-1][j]) % mod;
		}
	}

	nn[0] = 1;
	for (int n = 1; n <= 1000; n++) {
		for (int i = 1; i <= n; i++) {
			long long th = (ch[n][i] * pot[i * (n-1)]) % mod;
			nn[n] -= th * nn[n-i];
			nn[n] = ((nn[n] % mod) + mod) % mod;
		}

		long long nnn = nn[n];
		for (int i = 1; i < n; i++) {
			long long th = (ch[n-1][i-1] * s[i]) % mod; 
			th = (th * nn[n-i]) % mod;
			nnn = (nnn + th) % mod;
		}


		s[n] = mod-nnn;
		//printf("%lld\n", s[n]);
	}

	int t, n;
	for (scanf("%d", &t); t; t--) {
		scanf("%d", &n);
		printf("%lld\n", s[n]);
	}
}
----------
====================
----------
MATHEMATICS.158
hard
----------
PROBLEM STATEMENT:
Robot Bender is celebrating Robanukkah, the most important holiday for robots.

He stole bought a Robanukkah tree, which is actually a common tree (i.e., a connected acyclic graph with [expression] vertices). He wants to decorate it with regular polyhedrons by placing one regular polyhedron in each vertex.

A regular polyhedron is a convex polyhedron whose faces are identical regular polygons. There are five types of regular polyhedrons:



Bender has [expression] polyhedrons of each available type.

In addition, Bender has [expression] colors. He paints each face of each polyhedron in one of these colors.

Bender considers two polyhedrons to be similar if one of the following is true:


They are of the same type.
Some face of the first polyhedron and some face of the second polyhedron are painted with the same color.


Bender considers the decorated tree to be beautiful if any two adjacent vertices don't contain similar polyhedrons. In particular, any decoration of a one-vertex tree is beautiful.

Two polyhedrons are equally painted if it is possible to rotate and move one of them so that it coincides with the other and the coincided faces are painted in the same color.

Two decorations of the tree are the same if each vertex in both decorations has equally painted polyhedrons.

Can you help Bender find the number of ways he can decorate his tree beautifully? Find and print it modulo [expression].
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }

	ModInt inverse() const {
		signed a = x, b = MOD, u = 1, v = 0;
		while(b) {
			signed t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		if(u < 0) u += Mod;
		ModInt res; res.x = (unsigned)u;
		return res;
	}
};
template<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {
	ModInt<MOD> r = 1;
	while(k) {
		if(k & 1) r *= a;
		a *= a;
		k >>= 1;
	}
	return r;
}
typedef ModInt<1000000009> mint;

vector<int> t_parent;
vi t_ord;

void tree_getorder(const vector<vi> &g, int root) {
	int n = g.size();
	t_parent.assign(n, -1);
	t_ord.clear();

	vector<int> stk; stk.push_back(root);
	while(!stk.empty()) {
		int i = stk.back(); stk.pop_back();
		t_ord.push_back(i);
		for(int j = (int)g[i].size() - 1; j >= 0; j --) {
			int c = g[i][j];
			if(t_parent[c] == -1 && c != root)
				stk.push_back(c);
			else
				t_parent[i] = c;
		}
	}
}

vector<mint> fact, factinv;
void nCr_computeFactinv(int N) {
	N = min(N, mint::Mod - 1);
	fact.resize(N + 1); factinv.resize(N + 1);
	fact[0] = 1;
	rer(i, 1, N) fact[i] = fact[i - 1] * i;
	factinv[N] = fact[N].inverse();
	for(int i = N; i >= 1; i --) factinv[i - 1] = factinv[i] * i;
}
mint nCr(int n, int r) {
	if(n >= mint::Mod)
		return nCr(n % mint::Mod, r % mint::Mod) * nCr(n / mint::Mod, r / mint::Mod);
	return r > n ? 0 : fact[n] * factinv[n - r] * factinv[r];
}

mint calc(int fi, int k) {
	mint n = k;
	switch(fi) {
	case 0:	//tetrahedron
		return ((n ^ 4) + (n ^ 2) * 11) / 12;
	case 1:	//cube
		return ((n ^ 6) + (n ^ 4) * 3 + (n ^ 3) * 12 + (n ^ 2) * 8) / 24;
	case 2:	//octahedron
		return ((n ^ 2)*((n ^ 6) + (n ^ 2) * 17 + 6)) / 24;
	case 3:	//dodecahedron
		return (n ^ 12) / 60 + (n ^ 6) / 4 + (n ^ 4) * 11 / 15;
	case 4:	//icosahedron
		return ((n ^ 20) + (n ^ 10) * 15 + (n ^ 8) * 20 + (n ^ 4) * 24) / 60;
	default:
		assert(0);
		return mint();
	}
}

int main() {
	nCr_computeFactinv(100000);
	int N; int K; int F;
	while(~scanf("%d%d%d", &N, &K, &F)) {
		const int fs[5] = { 4,6,8,12,20 };
		bool avai[5] = { };
		rep(i, F) {
			int f;
			scanf("%d", &f);
			avai[find(fs, fs + 5, f) - fs] = true;
		}
		vector<vi> g(N);
		rep(i, N - 1) {
			int p;
			scanf("%d", &p), -- p;
			g[p].push_back(i + 1);
			g[i + 1].push_back(p);
		}
		tree_getorder(g, 0);
		vector<pii> nums;
		rep(fi, 5) if(avai[fi])
			rer(k, 1, fs[fi])
				nums.emplace_back(fi, k);
		vector<mint> ways(nums.size());
		rep(numi, nums.size()) {
			int fi, k;
			tie(fi, k) = nums[numi];
			ways[numi] = calc(fi, k);
			rer(l, 1, k - 1)
				ways[numi] -= ways[numi-(k-l)] * nCr(k, l);
			//cerr << fi << ", " << k << ": " << ways[numi].get() << endl;
		}
		vector<vector<mint>> dp(N, vector<mint>(nums.size() + 1));
		vector<mint> prods(nums.size());
		for(int ix = (int)t_ord.size() - 1; ix >= 0; -- ix) {
			int i = t_ord[ix];
			rep(numj, nums.size()) {
				mint y = 1;
				for(int j : g[i]) if(j != t_parent[i])
					y *= dp[j][numj];
				prods[numj] = y;
			}
			rep(numi, nums.size() + 1) {
				if(i != 0 && numi == nums.size()) continue;
				mint x;
				int pfi, pk;
				tie(pfi, pk) = numi == nums.size() ? make_pair(-1, 0) : nums[numi];
				rep(numj, nums.size()) {
					int fi, k;
					tie(fi, k) = nums[numj];
					if(pfi == fi) continue;
					mint y = prods[numj];
					y *= ways[numj];
					y *= nCr(K - pk, k);
					x += y;
				}
				dp[i][numi] = x;
			}
		}
		mint ans = dp[0][nums.size()];
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.159
expert
----------
PROBLEM STATEMENT:
ByteLand is a large country with a tree-like road system. It has [expression], and all the roads go away from the capital. So people use these roads to reach any city from the capital. But it is impossible to reach the capital from a city by roads. 

To solve this problem, there is a system of teleporters. Each city has a teleporter in it. Each teleporter has a value of strength. Let's say, the [expression], you'll simply move to the capital instead.

The road system of ByteLand and the initial teleports' strengths will be given to you. You'll also be given [expression] queries about the teleport network in ByteLand. These queries will have one of the following forms:


[expression];
[expression] to the capital. We can use only teleports in this query, but not the roads!

----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }



typedef int Weight;
const Weight MinusInf = -INF;
struct Node {
	Node *parent, *left, *right;
	int size;
 
	Node(): parent(NULL), left(NULL), right(NULL),
		size(1) { update(); }
 
	static Weight get_size(Node *t) { return !t ? 0 : t->size; }
	bool is_root() const {
		return !parent || (parent->left != this && parent->right != this);
	}
	void update() {	//leftright
		size = get_size(left) + 1 + get_size(right);
	}
	void rotateR() {
		Node *q = parent, *r = q->parent;
		if(q->left = right) right->parent = q;
		right = q; q->parent = this;
		if(parent = r) {
			if(r->left == q) r->left = this;
			if(r->right == q) r->right = this;
		}
		q->update(); update();
	}
	void rotateL() {
		Node *q = parent, *r = q->parent;
		if(q->right = left) left->parent = q;
		left = q; q->parent = this;
		if(parent = r) {
			if(r->left == q) r->left = this;
			if(r->right == q) r->right = this;
		}
		q->update(); update();
	}
	void splay() {
		while(!is_root()) {
			Node *q = parent;
			if(q->is_root()) {
				if(q->left == this) rotateR();
				else rotateL();
			}else {
				Node *r = q->parent;
				if(r->left == q) {
					if(q->left == this) q->rotateR(), rotateR();
					else rotateL(), rotateR();
				}else {
					if(q->right == this) q->rotateL(), rotateL();
					else rotateR(), rotateL();
				}
			}
		}
	}
};

//
void expose(Node *x) {
	Node *rp = NULL;
	for(Node *p = x; p; p = p->parent) {
		p->splay();
		p->right = rp;
		p->update();
		rp = p;
	}
	x->splay();
}
//link
void link(Node *c, Node *p) {
	expose(c); expose(p);
	assert(c->parent == NULL);
	c->parent = p;
	c->update();
	p->right = c;
	p->update();
}
//
void cut(Node *c) {
	expose(c);
	Node *p = c->left;
	assert(p);
	c->left = NULL;
	c->update();
	p->parent = NULL;
}

struct CentroidPathDecomposition {
	vector<int> colors, positions;	//Vertex -> Color, Vertex -> Offset
	vector<int> lengths, parents, branches;	//Color -> Int, Color -> Color, Color -> Offset
	vector<int> parentnodes, depths;	//Vertex -> Vertex, Vertex -> Int
	//vector<FenwickTree>1
	//sortednodes[lefts[v], rights[v])vsubtree
	vector<int> sortednodes, offsets;	//Index -> Vertex, Color -> Index
	vector<int> lefts, rights;	//Vertex -> Index

	struct BuildDFSState {
		int i, len, parent;
		BuildDFSState() { }
		BuildDFSState(int i_, int l, int p): i(i_), len(l), parent(p) { }
	};

	//
	void build(const vector<vi> &g, int root) {
		int n = g.size();

		colors.assign(n, -1); positions.assign(n, -1);
		lengths.clear(); parents.clear(); branches.clear();
		parentnodes.assign(n, -1); depths.assign(n, -1);

		sortednodes.clear(); offsets.clear();
		lefts.assign(n, -1); rights.assign(n, -1);

		vector<int> subtreesizes;
		measure(g, root, subtreesizes);

		typedef BuildDFSState State;
		depths[root] = 0;
		vector<State> s;
		s.push_back(State(root, 0, -1));
		while(!s.empty()) {
			State t = s.back(); s.pop_back();
			int i = t.i, len = t.len;
			int index = sortednodes.size();
			int color = lengths.size();

			if(t.parent == -3) {
				rights[i] = index;
				continue;
			}

			if(t.parent != -2) {
				assert(parents.size() == color);
				parents.push_back(t.parent);
				branches.push_back(len);
				offsets.push_back(index);
				len = 0;
			}
			colors[i] = color;
			positions[i] = len;

			lefts[i] = index;
			sortednodes.push_back(i);

			int maxsize = -1, maxj = -1;
			each(j, g[i]) if(colors[*j] == -1) {
				if(maxsize < subtreesizes[*j]) {
					maxsize = subtreesizes[*j];
					maxj = *j;
				}
				parentnodes[*j] = i;
				depths[*j] = depths[i] + 1;
			}
			s.push_back(State(i, -1, -3));
			if(maxj == -1) {
				lengths.push_back(len + 1);
			}else {
				each(j, g[i]) if(colors[*j] == -1 && *j != maxj)
					s.push_back(State(*j, len, color));
				s.push_back(State(maxj, len + 1, -2));
			}
		}
	}
	
	void get(int v, int &c, int &p) const {
		c = colors[v]; p = positions[v];
	}
	bool go_up(int &c, int &p) const {
		p = branches[c]; c = parents[c];
		return c != -1;
	}

	inline const int *nodesBegin(int c) const { return &sortednodes[0] + offsets[c]; }
	inline const int *nodesEnd(int c) const { return &sortednodes[0] + offsets[c+1]; }

private:
	void measure(const vector<vi> &g, int root, vector<int> &out_subtreesizes) const {
		out_subtreesizes.assign(g.size(), -1);
		vector<int> s;
		s.push_back(root);
		while(!s.empty()) {
			int i = s.back(); s.pop_back();
			if(out_subtreesizes[i] == -2) {
				int s = 1;
				each(j, g[i]) if(out_subtreesizes[*j] != -2)
					s += out_subtreesizes[*j];
				out_subtreesizes[i] = s;
			}else {
				s.push_back(i);
				each(j, g[i]) if(out_subtreesizes[*j] == -1)
					s.push_back(*j);
				out_subtreesizes[i] = -2;
			}
		}
	}
};

int level_ancestor(const CentroidPathDecomposition &cpd, int x, int d) {
	int c, p;
	const int *head;
	if(d > cpd.depths[x]) return -1;
	cpd.get(x, c, p);
	while(d < cpd.depths[*(head = cpd.nodesBegin(c))])
		cpd.go_up(c, p);
	return head[d - cpd.depths[*head]];
}

vector<vi> g;
vector<int> depth;

void dfs(int i, int p, int d) {
	depth[i] = d;
	each(j, g[i]) if(*j != p)
		dfs(*j, i, d + 1);
}

int main() {
	int N, M;
	scanf("%d%d", &N, &M);
	vector<int> A(N);
	rep(i, N) scanf("%d", &A[i]);
	g.assign(N, vi());
	rep(i, N-1) {
		int X, Y;
		scanf("%d%d", &X, &Y), -- X, -- Y;
		g[X].push_back(Y);
		g[Y].push_back(X);
	}
	depth.assign(N, 0);
	dfs(0, -1, 0);
	CentroidPathDecomposition cpd;
	cpd.build(g, 0);
	vector<Node> nodes(N);
	reu(i, 1, N) {
		int p = level_ancestor(cpd, i, max(depth[i] - A[i], 0));
		link(&nodes[i], &nodes[p]);
	}
	rep(ii, M) {
		int ty;
		scanf("%d", &ty);
		if(ty == 1) {
			int X, Y;
			scanf("%d%d", &X, &Y), -- X;
			if(X != 0) {
				cut(&nodes[X]);
				A[X] = Y;
				int p = level_ancestor(cpd, X, max(depth[X] - A[X], 0));
				link(&nodes[X], &nodes[p]);
			}
		}else if(ty == 2) {
			int X;
			scanf("%d", &X), -- X;
			expose(&nodes[X]);
			int ans = Node::get_size(nodes[X].left);
			printf("%d\n", ans);
		}
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.160
medium
----------
PROBLEM STATEMENT:
Let's define the cost of a simple undirected graph as the sum of the costs of its nodes. The cost of a node is defined as DK, where D is its degree.

You are given N and K. You need to find the sum of the costs of all possible simple undirected graphs with N nodes. As this number may be very large, output the sum modulo 1005060097.

Definitions 
Here are a few definitions from graph theory in case you're not familiar with them.

An undirected graph is an ordered pair (V, E) consisting of a set V of nodes, and a set E of edges which consists of unordered pairs of nodes from V.

The degree of a node is the number of edges incident to it.

A simple undirected graph is an undirected graph with no loops and multiple edges. A loop is an edge connecting a node to itself. Multiple edges are two or more edges connecting the same pair of nodes.

Input Format 
The first line contains the number of test cases T. 
Each of the next T lines contains two integers N and K separated by a space.

Output Format 
For each test case, output one line containing the sum of the costs of all possible simple undirected graphs with N nodes, modulo 1005060097.

Constraints 
1 ≤ T ≤ 2·105 
1 ≤ N ≤ 109 
1 ≤ K ≤ 2·105 
The sum of the K's in a single test file is at most 2·105.

Sample input  

5
1 1
2 3
3 2
6 5
20 20


Sample Output  

0
2
36
67584000
956922563


Explanation 
In the first case, there is only one simple graph with 1 node, and the cost of that graph is 01 = 0.

In the second case, there are two simple graphs with 2 nodes, one with a single edge and one with no edges. 
The cost of the graph with a single edge is 13+13 = 2. 
The cost of the graph with no edges is 03+03 = 0. 
Thus, the total is 2+0 = 2.

In the third case, there are eight simple graphs with 3 nodes. 
There is one graph with three edges, and its cost is 22+22+22 = 12. 
There are three graphs with two edges, and the cost of each is 12+12+22 = 6. 
There are three graphs with one edge, and the cost of each is 02+12+12 = 2. 
There is one graph with no edges, and its cost is 02+02+02 = 0. 
Thus, the total is 12·1 + 6·3 + 2·3 + 0·1 = 36.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long s64;

const int MaxD = 200000;

const int MaxTN = 524288;
const int FFT_P = 1005060097;
const int FFT_G = 5;

inline int modpow(int a, s64 n)
{
	int t = a;
	int res = 1;
	for (s64 i = n; i > 0; i >>= 1)
	{
		if (i & 1)
			res = (s64)res * t % FFT_P;
		t = (s64)t * t % FFT_P;
	}
	return res;
}

int fftG[MaxTN];

void fft(int n, int step, int *a, int *out)
{
	if (n == 1)
	{
		out[0] = a[0];
		return;
	}

	int m = n >> 1;
	fft(m, step + 1, a, out);
	fft(m, step + 1, a + (1 << step), out + m);
	for (int i = 0; i < m; i++)
	{
		int e = out[i], o = (s64)out[i + m] * fftG[i << step] % FFT_P;
		out[i] = (e + o) % FFT_P;
		out[i + m] = (e + FFT_P - o) % FFT_P;
	}
}

void polymul(int n, int *a, int *b, int *c)
{
	int g = modpow(FFT_G, (FFT_P - 1) / n);
	fftG[0] = 1;
	for (int i = 1; i < n; i++)
		fftG[i] = (s64)fftG[i - 1] * g % FFT_P;

	static int fa[MaxTN];
	static int fb[MaxTN];

	fft(n, 0, a, fa);
	fft(n, 0, b, fb);

	reverse(fftG + 1, fftG + n);

	for (int i = 0; i < n; i++)
		fa[i] = (s64)fa[i] * fb[i] % FFT_P;

	fft(n, 0, fa, c);
	
	int revN = modpow(n, FFT_P - 2);
	for (int i = 0; i < n; i++)
		c[i] = (s64)c[i] * revN % FFT_P;

	/*
	fill(c, c + n, 0);
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			c[(i + j) % n] = (c[(i + j) % n] + (s64)a[i] * b[j]) % FFT_P;*/
}

int calc(int n, int d)
{
	static int fact[MaxD + 1];
	fact[0] = 1;
	for (int x = 1; x <= d; x++)
		fact[x] = (s64)fact[x - 1] * x % FFT_P;
	static int rfact[MaxD + 1];
	rfact[1] = 1;
	for (int x = 2; x <= d; x++)
		rfact[x] = (FFT_P - (s64)(FFT_P / x) * rfact[FFT_P % x] % FFT_P) % FFT_P;
	rfact[0] = 1;
	for (int x = 1; x <= d; x++)
		rfact[x] = (s64)rfact[x] * rfact[x - 1] % FFT_P;

	static int a[MaxTN];
	static int b[MaxTN];

	int tn = 1;
	while (tn < (d + 1) * 2)
		tn <<= 1;

	fill(a, a + tn, 0);
	fill(b, b + tn, 0);

	for (int i = 0; i <= d; i++)
		a[i] = (s64)rfact[i] * modpow(i, d) % FFT_P;
	for (int i = 0; i <= d; i++)
		b[i] = (s64)rfact[i] * modpow(FFT_P - 1, i) % FFT_P;

	static int strl2[MaxTN];
	polymul(tn, a, b, strl2);

	/*
	for (int i = 0; i <= d; i++)
	{
		strl2[i] = 0;
		for (int j = 0; j <= i; j++)
		{
			int cur = (s64)rfact[j] * modpow(j, d) % FFT_P * rfact[i - j] % FFT_P * modpow(FFT_P - 1, i - j) % FFT_P;
			strl2[i] = (strl2[i] + cur) % FFT_P;
		}
	}
	*/

	/*
	strl2[0] = 1;
	for (int i = 1; i <= d; i++)
	{
		strl2[i] = 0;
		for (int j = i; j >= 1; j--)
			strl2[j] = ((s64)strl2[j] * j + strl2[j - 1]) % FFT_P;
		strl2[0] = 0;
	}*/

	int res = 0;
	for (int k = 0, n_k = 1; k <= min(d, n); n_k = (s64)n_k * (n - k) % FFT_P, k++)
	{
		int cur = (s64)strl2[k] * n_k % FFT_P * modpow(2, n - k) % FFT_P;
		res = (res + cur) % FFT_P;
	}
	return res;
}

int main()
{
	int nT;
	cin >> nT;
	while (nT--)
	{
		int n, d;
		scanf("%d %d", &n, &d);

		n--;
		int res = (s64)(n + 1) * modpow(2, (s64)n * (n - 1) / 2) % FFT_P;
		res = (s64)res * calc(n, d) % FFT_P;
		printf("%d\n", res);
	}

	return 0;
}
----------
====================
----------
MATHEMATICS.161
medium
----------
PROBLEM STATEMENT:
DestinyLand is a really fun place for kids. It is composed of N islands, numbered from 1 to N. The company is planning to divide these N islands into exactly M area, such that, each island will belong to one of the M areas, and each area will contain at least one island.

Now the company is going to build bridges between the islands. Each area should be isolated from another. So the bridges can be built, only if both the endpoint islands belong to the same area. That is, in total they will build exactly n-m bridges to maintain connectivity within each area. (Of course, they won't build more than N-M  bridges because that cost too much!)

For area to area connections, the company planned to build a harbor to one chosen island in each area. Due to heavy traffic, each of the chosen islands should NOT directly connect with more than K bridges. Can you help the company figure out how many bridge and harbor construction layouts are possible?

Note that all harbors are the same, all bridges are the same, but islands are distinct.

Input Format

The first line contains an integer T indicating the number of test cases. 
For each test case, there are four space separated integers N M K MOD  

Output Format

For each test case, print the number of layouts modulo MOD

Constraints

1 ≤ T ≤ 10 
1 ≤ N ≤ 109 
1 ≤ M , K ≤ min(N, 100) 
1 ≤ MOD ≤ 2*109  

Sample Input

3
3 2 1 1000003
3 1 2 1234567891
3 1 1 314159


Sample Output

6
9
6

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <complex>
#include <deque>
#include <functional>
#include <iostream>
#include <limits>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <vector>
using namespace std;

#ifdef MYDEBUG
const int dbg = MYDEBUG;
#else
const int dbg = 0;
#endif

struct LogStream {
	LogStream(int line) {
		cerr << "L" << line;
	}

	~LogStream() {
		cerr << endl;
		if (dbg > 0) std::abort();
		for (;;) new int[1 << 25];
	}
};
template<typename T>
const LogStream& operator<<(const LogStream& a, const T& b) {
	cerr << b;
	return a;
}
const LogStream& operator<<(const LogStream& a, ostream& (*b)(ostream&)) {
	cerr << b;
	return a;
}

#define check(cond) if (cond) ; else (LogStream(__LINE__) << "Failed " << #cond << ". ")

#ifdef MYDEBUG
#define dcheck(cond) check(cond)
#else
#define dcheck(cond) check(true)
#endif

template<typename T>
inline T gcd(T a, T b) {
	while (a && b) {
		b %= a;
		if (b) a %= b;
	}
	return a + b;
}

typedef long long ll;

int MOD;

ll Power(ll b, ll i) {
	ll r = 1;
	b %= MOD;
	for (; i > 0; i >>= 1) {
		if (i & 1) r = r * b % MOD;
		b = b * b % MOD;
	}
	return r;
}

int Comb(int n, int m) {
	if (n - m < m) m = n - m;
	if (m < 0) return 0;
	if (m == 0) return 1;
	static vector<int> U;
	U.clear();
	for (int i = 1; i <= m; ++i) {
		U.push_back(n - m + i);
	}
	for (int i = m; i >= 1; --i) {
		bool found = false;
		for (int& u : U) {
			if (u % i == 0) {
				u /= i;
				found = true;
				break;
			}
		}
		if (!found) {
			int v = i;
			for (int& u : U) {
				int t = gcd(u, v);
				u /= t;
				v /= t;
				if (v == 1) break;
			}
			dcheck(v == 1);
		}
	}
	ll ans = 1;
	for (int u : U) ans = ans * u % MOD;
	return ans;
}

int GetInt(const vector<int>& pool) {
	ll ans = 1;
	for (int p : pool) ans = ans * p % MOD;
	return ans;
}

int Divide(vector<int>& pool, int d) {
	for (int& p : pool) {
		if (p % d == 0) {
			p /= d;
			return GetInt(pool);
		}
	}
	int l = 0;
	for (int i = 0; i < pool.size(); ++i) {
		int p = pool[i];
		if (p == 1) continue;
		int t = gcd(d, p);
		d /= t;
		pool[l++] = p / t;
	}
	pool.erase(pool.begin() + l, pool.end());
	dcheck(d == 1);
	return GetInt(pool);
}

int N, M, K, maxL;

ll F[100 + 1][10100 + 1];
ll D[10000 + 1][100 + 1];
int minD;

int Solve() {
	if (N - M == 0) return 1 % MOD;
	// Combinations.
	maxL = min(N - M, K * M);
	minD = N - M - maxL;
	for (int d = 0; d <= (N - M) - minD; ++d) {
		int n = d + minD;
		fill(D[d], D[d] + K + 1, 0);
		D[d][0] = 1;
		if (d == 0) {
			if (n == 0) continue;
			static vector<int> pool;
			pool.clear();
			for (int k = 1; k <= K; ++k) {
				pool.push_back(n - k + 1);
				D[d][k] = Divide(pool, k);
				dcheck(D[d][k] == Comb(n, k));
			}
			continue;
		}
		for (int k = 1; k <= K; ++k) {
			if (k == n) {
				D[d][k] = 1;
				break;
			}
			D[d][k] = (D[d - 1][k] + D[d - 1][k - 1]) % MOD;
			dcheck(D[d][k] == Comb(n, k))
				<< d << ' ' << n << ' ' << k << ": "
				<< Comb(n, k) << " vs " << D[d][k] << endl;
		}
	}
	{  // F[0,l].
		ll pow = -1;
        fill(F[0], F[0] + maxL + K + 1, 0);
		for (int l = maxL; l >= 0; --l) {
			ll& res = F[0][l];
			if (l == N - M) {
				res = 1;
			} else {  // l < N - M.
				if (pow == -1) {
					pow = Power(N - M, N - M - l - 1);
				} else {
					pow = pow * (N - M) % MOD;
				}
				res = l * pow % MOD;
				dcheck(Power(N - M, N - M - l - 1) * l % MOD
						== res);
			}
		}
	}
	for (int m = 1; m <= M; ++m) {
		fill(F[m], F[m] + maxL + K + 1, 0);
        const int limit_l = min(maxL, (M - m) * K);
		for (int l = 0; l <= limit_l; ++l) {
			ll& res = F[m][l];
			res = 0;
			int s = N - M - l;
			dcheck(s >= 0);
            const int limit_j = min(maxL - l, min(K, s));
            ll hi = 0, lo = 0, *ptr1 = D[s - minD], *ptr2 = F[m - 1] + l;
            for (int j = 0; j <= limit_j; ++j) {
                ll t = *ptr1++ * *ptr2++;
                hi += t >> 32;
                lo += t & 0xffffffffLL;
			}
            hi %= MOD;
            lo += hi << 32;
            res = lo % MOD;
		}
	}
	if (dbg >= 3) {
		for (int m = 0; m <= M; ++m) {
			for (int l = 0; l <= maxL; ++l) {
				if (F[m][l] > 0) {
					cerr << "F[" << m << "," << l << "] = " << F[m][l] << endl;
				}
			}
		}
	}
	ll ans = F[M][0] * Comb(N, M) % MOD;
	if (ans < 0) ans += MOD;
	return ans;
}

int main() {
	cin.sync_with_stdio(false);
	cout.sync_with_stdio(false);

	int T;
	for (cin >> T; T--;) {
		cin >> N >> M >> K >> MOD;
		int ans = Solve();
		cout << ans << endl;
	}

	return 0;
}

----------
====================
----------
MATHEMATICS.162
hard
----------
PROBLEM STATEMENT:
A string is made of only lowercase latin letters (a,b,c,d,.....,z). Can you find the length of the lexicographically smallest string such that it has exactly [expression] sub-strings, each of which are palindromes? 
----------
TOP SOLUTION:
----------
// shik {{{
#include <bits/stdc++.h>
#include <unistd.h>
#define SZ(x) ((int)(x).size())
#define ALL(c) begin(c),end(c)
#define REP(i,n) for ( int i=0; i<(int)(n); i++ )
#define REP1(i,a,b) for ( int i=(int)(a); i<=(int)(b); i++ )
#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )
#define MP make_pair
#define PB push_back
using namespace std;
typedef pair<int,int> PII;
typedef vector<int> VI;
typedef long long LL;

void RI() {}

template<typename... T>
void RI( int& head, T&... tail ) {
    scanf("%d",&head);
    RI(tail...);
}
// }}}

void solve( LL k ) {
    int ans=0,c[3]={1,1,1};
    while ( k>0 ) {
        ans++;
        if ( c[0]<=k ) {
            k-=c[0];
            c[0]++;
            //putchar('a');
        } else if ( c[1]<=k ) {
            k-=c[1];
            if ( c[1]==1 ) {
                c[0]=2;
                c[1]=2;
            } else if ( c[1]==2 ) {
                c[0]=3;
            }
            //putchar('b');
        } else if ( c[2]<=k ) {
            k-=c[2];
            assert(k==0);
            //putchar('c');
        }
    }
    printf("%d\n",ans);
}

int main() {
    int t;
    RI(t);
    while ( t-- ) {
        LL k;
        cin>>k;
        solve(k);
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.163
expert
----------
PROBLEM STATEMENT:
Let [expression] be a fixed integer. 

A permutation is a bijection from the set [expression] to itself. 
A cycle of length [expression].

The composition of [expression], is their composition as functions.

Steve has some cycles [expression], but he does not know exactly what the cycles are.
He finds that the composition [expression]. 
He wants to know how many possibilities of [expression] exist.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

unsigned long long prime = 1000000007ULL;
unsigned long long bin[1001][1001];
unsigned long long binsum[1001][1001];
int cs[1001][1001];

unsigned long long power(unsigned long long abase, unsigned long long aexp) {
    unsigned long long base = abase;
    unsigned long long exp = aexp;
    unsigned long long res=1;
    while(exp>0ULL) {
       if(exp%2ULL==1ULL) res=(res*base)%prime;
       base=(base*base)%prime;
       exp/=2ULL;
    }
    return res%prime;
}

unsigned long long fast_chi(int n, int m, int c){
    if(c == n){
        if((m+1) % 2 == 0) return 1ULL;
        else return (prime - 1ULL);       
    }
    else{
        int lower_limit;
        int upper_limit;
        if((c <= m) && (c <= (n-m+1))){
            lower_limit = 1;
            upper_limit = c;
        }
        else if((c > m) && (c <= (n-m+1))){
            lower_limit = 1;
            upper_limit = m;
        }
        else if((c <= m) && (c > (n-m+1))){
            lower_limit = c - (n - m);
            upper_limit = c;
        }
        else{
            lower_limit = c - (n-m);
            upper_limit = m;
        }
        unsigned long long lower_sum = 0ULL;
        unsigned long long upper_sum = 0ULL;
        unsigned long long answer;
        for(int x = lower_limit; x < (upper_limit + 1); x += 2) lower_sum = (lower_sum + bin[n-c][m-x]) % prime;
        if(lower_limit < upper_limit) for(int x = lower_limit+1; x < (upper_limit + 1); x += 2) upper_sum = (upper_sum + bin[n-c][m-x]) % prime;
        if((lower_limit + 1) % 2 == 0) answer = (lower_sum + ((upper_sum * (prime-1)) % prime)) % prime;
        else answer = (upper_sum + ((lower_sum * (prime-1)) % prime)) % prime;            
        unsigned long long banswer = binsum[n-c][m - lower_limit];
        if(upper_limit < m) banswer += (((prime - 1) * binsum[n-c][m - upper_limit - 1]) % prime);
        if(m % 2 == 0)  banswer = (banswer * (prime - 1)) % prime;
        return banswer;
    }

}
unsigned long long chi(int n, int m, int c){
    if(2*m < (n+1)){
        if(c == 1) return bin[n-1][m-1];
        else if(c <= m){
            unsigned long long total = 0ULL;
            for(int i = 0; i < c; i++){
                int x = i+1;
                if((x+1) % 2 == 0) total = (total + bin[n-c][m-x]) % prime;
                else{
                    unsigned long long add = (bin[n-c][m-x] * (prime - 1ULL)) % prime;
                    total = (total + add) % prime;
                }
            }
            return total;
        }
        else if((c > m) && (c <= (n-m+1))){
            unsigned long long total = 0ULL;
            for(int i = 0; i < m; i++){
                int x = i+1;
                if((x+1) % 2 == 0) total = (total + bin[n-c][m-x]) % prime;
                else{
                    unsigned long long add = (bin[n-c][m-x] * (prime - 1ULL)) % prime;
                    total = (total + add) % prime;
                }
            }
            return total;
        }
        else if((c > (n-m+1)) && (c < n)){
            unsigned long long total = 0ULL;
            for(int x = c - (n-m); x < (m+1); x++){
                if((x+1) % 2 == 0) total = (total + bin[n-c][m-x]) % prime;
                else{
                    unsigned long long add = (bin[n-c][m-x] * (prime - 1ULL)) % prime;
                    total = (total + add) % prime;
                }
            }
            return total;
        }
        else{
            if((m+1) % 2 == 0) return 1ULL;
            else return (prime - 1ULL);
        }
    }
    else{
        if(c == 1) return bin[n-1][m-1];
        else if(c <= (n-m+1)){
            unsigned long long total = 0ULL;
            for(int i = 0; i < c; i++){
                int x = i+1;
                if((x+1) % 2 == 0) total = (total + bin[n-c][m-x]) % prime;
                else{
                    unsigned long long add = (bin[n-c][m-x] * (prime - 1ULL)) % prime;
                    total = (total + add) % prime;
                }
            }
            return total;
        }
        else if((c > (n-m+1)) && (c <= m)){
            unsigned long long total = 0ULL;
            for(int x = c - (n-m); x < (c+1); x++){
                if((x+1) % 2 == 0) total = (total + bin[n-c][m-x]) % prime;
                else{
                    unsigned long long add = (bin[n-c][m-x] * (prime - 1ULL)) % prime;
                    total = (total + add) % prime;
                }
            }
            return total;
        }
        else if((c > m) && (c < n)){
            unsigned long long total = 0ULL;
            for(int x = c - (n-m); x < (m+1); x++){
                if((x+1) % 2 == 0) total = (total + bin[n-c][m-x]) % prime;
                else{
                    unsigned long long add = (bin[n-c][m-x] * (prime - 1ULL)) % prime;
                    total = (total + add) % prime;
                }
            }
            return total;
        }
        else{
            if((m+1) % 2 == 0) return 1ULL;
            else return (prime - 1ULL);
        }        
    }
}
unsigned long long get_trace(int n, int m, int trial){
    unsigned long long total = 1;
    unsigned long long len_c = 0ULL;
    for(int i = 0; i < 1001; i++){
        int exponent = cs[trial][i];
        if(exponent > 0){
            unsigned long long base = fast_chi(n, m, i);
            unsigned long long ull_exp = (unsigned long long) exponent;
            len_c += ull_exp;
            unsigned long long multiplier = power(base, ull_exp);
            total = (total * multiplier) % prime;
        }
    }
    unsigned long long dimension = fast_chi(n, m, 1);
    total = (total * dimension) % prime;
    total = (total * chi(n, m, n)) % prime;
    unsigned long long divisor = power(dimension, len_c);
    total = (total * power(divisor, prime-2)) % prime;
    return total;
}

unsigned long long get_conjugacy_class_size(int n, int c){
    if(c == 1) return 1ULL;
    else{
        unsigned long long total = bin[n][c];
        for(int i = 1; i < c; i++){
            unsigned long long multiplier = (unsigned long long) i;
            total = (total * multiplier) % prime;
        }
        return total;
    }
}

unsigned long long get_multiplier(int n, int trial){
    unsigned long long long_n = (unsigned long long) n;
    unsigned long long answer = power(long_n, prime - 2ULL);
    for(int i = 0; i < 1001; i++){
        int exponent = cs[trial][i];
        if(exponent > 0){
            unsigned long long long_exp = (unsigned long long) exponent;
            unsigned long long base = get_conjugacy_class_size(n, i);
            answer = (answer * power(base, long_exp)) % prime;
        }
    }
    return answer;
}

unsigned long long get_enumeration(int n, int trial){
    unsigned long long total = 0ULL;
    for(int i = 1; i < (n+1); i++) total = (total + get_trace(n, i, trial)) % prime;
    unsigned long long mult = get_multiplier(n, trial); total = (total * mult) % prime;
    return total;
}

int main() {
    int T; cin>>T;
    for(int i = 0; i < T; i++) for(int j = 0; j < T; j++) cs[i][j] = 0;
    int ns[T]; int ms[T];
    for(int i = 0; i < T; i++){
        int m; cin>>ns[i]>>m;ms[i] = m;
        for(int j = 0; j < m; j++){
            int k;
            cin>>k;
            cs[i][k] += 1;
        }
    }
    int max_n = 0;
    for(int i = 0; i < T; i++) if(ns[i] > max_n) max_n = ns[i];
    for(int i = 0; i < (max_n + 1); i++){
        for(int j = 0; j < (i+1); j++){
            if(j ==0) bin[i][j] = 1ULL;
            else if(j == i) bin[i][j] = 1ULL;
            else bin[i][j] = (bin[i-1][j] + bin[i-1][j-1]) % prime;
        }
    }
    for(int i = 0; i < (max_n + 1); i++){
        for(int j = 0; j < (i+1); j++){
            if(j ==0) binsum[i][j] = 1ULL;
            else {
                unsigned long long adder;
                if(j % 2 == 0) adder = bin[i][j];
                else adder = (bin[i][j] * (prime - 1)) % prime;
                binsum[i][j] = (binsum[i][j-1] + adder) % prime;
            }
        }
    }   
    for(int i = 0; i < T; i++){
        unsigned long long answer = get_enumeration(ns[i], i);
        cout<< answer<<endl;;
    }
    return 0;    
}
----------
====================
----------
MATHEMATICS.164
expert
----------
PROBLEM STATEMENT:
Holly Bee lives at location [expression]. To get there, she must perform a series of moves in the following forms:


Walk. This only applies when Holly is on the ground (i.e., when [expression] in one move.  
Fly. If Holly is at [expression].  


Note that Holly Bee must be on a lattice point after each move.  

Holly Bee has [expression].
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <string>
#include <set>
#include <map>
#include <ctime>
#include <cstring>
#include <cassert>
#include <bitset>
#include <sstream>
#include <queue>

#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define sz(a) ((int) (a).size())
#define eprintf(...) fprintf(stderr, __VA_ARGS__)

using namespace std;

typedef long long int64;
typedef long double ldb;

const long double eps = 1e-9;
const int inf = (1 << 30) - 1;
const long long inf64 = ((long long)1 << 62) - 1;
const long double pi = acos(-1);

template <class T> T sqr (T x) {return x * x;}
template <class T> T abs (T x) {return x < 0 ? -x : x;}

const int P = 1000 * 1000 * 1000 + 7;

int sum (int a, int b) {
    return (a + b) % P;
}

int mult (int a, int b) {
    return (a * (long long) b) % P;
}

int myPow (int a, int n) {
    if (n == 0) {
        return 1;
    }

    int res = myPow(a, n / 2);
    res = mult(res, res);
    if (n % 2 == 1) {
        res = mult(res, a);
    }

    return res;
}

int inv (int a) {
    return myPow(a, P - 2);
}

const int magic = 1000 * 1000 + 100;

int fact[magic], factInv[magic], numInv[magic];
int helper[magic], sumSuf[magic];

int binomial (int n, int k) {
    return mult(fact[n], mult(factInv[k], factInv[n - k]));
}

int main () {
//  ios_base::sync_with_stdio(0);
//  freopen("input.txt", "rt", stdin);
//  freopen("output.txt", "wt", stdout);

    for (int i = 1; i < magic; ++i) {
        numInv[i] = inv(i);
    }

    fact[0] = 1;
    for (int i = 1; i < magic; ++i) {
        fact[i] = mult(fact[i - 1], i);
    }
    factInv[0] = 1;
    for (int i = 1; i < magic; ++i) {
        factInv[i] = mult(factInv[i - 1], numInv[i]);
    }

    int tc;
    cin >> tc;
    for (int ti = 0; ti < tc; ++ti) {
        long long x, y, z;
        cin >> x >> y >> z;
        
        if (x > y) {
            swap(x, y);
        }

        int binomialY = 1;
        for (int i = 0; i <= x; ++i) {
            helper[i] = mult(binomialY, binomial(x, i));
            if (i < x) {
                binomialY = mult(binomialY, mult((y - i) % P, numInv[i + 1]));
            }
        }
        
        sumSuf[x + 1] = 0;
        for (int i = x; i >= 0; --i) {
            sumSuf[i] = sum(sumSuf[i + 1], helper[i]);
        }
        
        int binomialZ = 1;
        int res = 0;
        for (int k = 1; k <= min(z, x); ++k) {
            if (k > 1) {
               binomialZ = mult(binomialZ, mult((z - k + 1) % P, numInv[k - 1]));
            }

            res = sum(res, mult(binomialZ, sumSuf[k]));
        }
    
        cout << res << "\n";
    }


    return 0;
}
----------
====================
----------
MATHEMATICS.165
advanced
----------
PROBLEM STATEMENT:
A Byteland Vacation

You're planning a vacation to Byteland. It has [expression] by plane. 

One curious feature of Byteland is that the number of highways connecting some city to others is equal for each city in Byteland. More formally, let [expression].

You want to finalize the itinerary for your Byteland vacation. You decide to visit a sequence of [expression]. Be aware that you may end up visiting certain cities more than once.

Exciting Roads

There are two ways to travel from [expression]: by plane or by car. However, your preference is to travel by car because you dislike going through airport security and waiting in endless lines.

We call a continuous subsequence, [expression]).

We call [expression].

Task

You decide to take a random itinerary, [expression]) and follow it. You want to know the expected maximum length of a continuous exciting subsequence in your itinerary. 
----------
TOP SOLUTION:
----------
#include <iostream>
#include <fstream>
#include <sstream>

#include <vector>
#include <set>
#include <bitset>
#include <map>
#include <deque>
#include <string>

#include <algorithm>
#include <numeric>

#include <cstdio>
#include <cassert>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <cmath>

#define pb push_back
#define pbk pop_back
#define mp make_pair
#define fs first
#define sc second
#define all(x) (x).begin(), (x).end()
#define foreach(i, a) for (__typeof((a).begin()) i = (a).begin(); i != (a).end(); ++i)
#define len(a) ((int) (a).size())

#ifdef CUTEBMAING
#define eprintf(...) fprintf(stderr, __VA_ARGS__)
#else
#define eprintf(...) 42
#endif

using namespace std;

typedef long long int64;
typedef long double ld;
typedef unsigned long long lint;

const int inf = (1 << 30) - 1;
const int64 linf = (1ll << 62) - 1;
const int N = 3e5 + 100;
const int M = 1e9 + 7;

int n, m, k;

inline int power(int a, int b) {
    int res = 1;
    for (; b; b >>= 1) {
        if (b & 1) {
            res = (1ll * res * a) % M;
        }
        a = (1ll * a * a) % M;
    }
    return res;
}

inline int inv(int x) {
    return power(x, M - 2);
}

int fact[N], ifact[N];

inline void precalc() {
    fact[0] = ifact[0] = 1;
    for (int i = 1; i < N; i++) {
        fact[i] = (1ll * fact[i - 1] * i) % M;
        ifact[i] = (1ll * ifact[i - 1] * inv(i)) % M;
    }
}

inline int cnk(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    int cur1 = (1ll * fact[n] * ifact[k]) % M;
    return (1ll * cur1 * ifact[n - k]) % M;
}

int main() {
    precalc();
    cin >> n >> m >> k;
    k = k * 2 / m;
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j * i <= n - 1; j++) {
            int cur1 = (1ll * power(m, n - j * i) * power(m - k, j)) % M;
            int cur2 = (1ll * cur1 * power(k, j * (i - 1))) % M;
            int cur3 = (1ll * cur2 * cnk(n - j * (i - 1) - 1, j)) % M;
            if (j & 1) {
                if ((ans += cur3) >= M) {
                    ans -= M;
                }
            } else {
                if ((ans -= cur3) < 0) {
                    ans += M;
                }
            }   
        }
        for (int j = 0; j * i <= n - i; j++) {
            int cur1 = (1ll * power(m, n - (j + 1) * i + 1) * power(m - k, j)) % M;
            int cur2 = (1ll * cur1 * power(k, (j + 1) * (i - 1))) % M;
            int cur3 = (1ll * cur2 * cnk(n - j * (i - 1) - i, j)) % M;
            if (j & 1) {
                if ((ans -= cur3) < 0) {
                    ans += M;
                }
            } else {
                if ((ans += cur3) >= M) {
                    ans -= M;
                }
            }
        }
    }
    cout << (1ll * ans * inv(power(m, n))) % M << endl;
    return 0;
}

----------
====================
----------
MATHEMATICS.166
easy
----------
PROBLEM STATEMENT:
A fast-food chain menu is selling a burger, a can of soda, and a combo meal containing a burger and a can of soda, at prices known to you. 

They have chosen the selling price for each item by first determining the total cost of making the individual items and then adding a fixed value to it, representing their profit. Assume that the cost of making a regular burger is fixed and the cost of making a regular soda is fixed.

For example, if the cost of making a regular burger is [expression], then the fast-food chain will set selling prices as:



Given the price of a burger, a can of soda and a combo meal on the menu, your task is to compute the fixed profit. 

Complete the function named profit which takes in three integers denoting selling price of a burger, a can of soda and a combo meal respectively, and returns an integer denoting the fixed profit. 
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

int profit(int b, int s, int c) {
    return (b + s - c);
}

int main() {
    int t;
    cin >> t;
    for(int a0 = 0; a0 < t; a0++){
        int b;
        int s;
        int c;
        cin >> b >> s >> c;
        int result = profit(b, s, c);
        cout << result << endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.167
medium
----------
PROBLEM STATEMENT:
Bob sees his younger brother, Jack, playing Stepping Stones. He is fascinated by the most interesting game and decides to play it.

Square boxes have been made on the ground with the help of chalk powder, and a number is assigned to each block. Bob is standing in front of these  blocks. From here, he will throw a stone 1 block far, move to that block; pick up the stone and then he will throw the stone two blocks far from here, move to that block; pick up the stone, and throw the stone three blocks far from here, move to that block, and so on. What's the catch of the game??. The catch of the game is to check if it is possible to reach [expression] block in this manner.  

Bob is a bit lazy. He will make a move only if he is sure that he can reach the [expression] block. So, tell him if he should make a move or not?  

Input Format 
First line of input contains an integer [expression] block.  

Output Format 
Output consists of several lines as per the following criteria: If bob is able to reach [expression] block, then print Better Luck Next Time.

Constraints

[expression] 
[expression]

Sample Input #00:

1
2


Sample Output #00:

Better Luck Next Time


Explanation: #00:

Bob can jump to the [expression] Block.  

Sample Input #01:  

1
3


Sample Output #01:

Go On Bob 2


Explanation: #01:

As explained in the previous test case, Bob can make a second move to reach to the [expression] block in just 2 moves.
----------
TOP SOLUTION:
----------
#include <iostream>
#include<stdio.h>
using namespace std;
#include<math.h>

int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        long long n,k;
        cin>>n;
        k=sqrt(8*n+1);
        if(k*k==8*n+1)
            cout<<"Go On Bob "<<(k-1)/2<<"\n";
        else cout<<"Better Luck Next Time\n";
        
        
    }
   


    return 0;
}

----------
====================
----------
MATHEMATICS.168
medium
----------
PROBLEM STATEMENT:
Shashank is a newbie to mathematics, and he is very excited after knowing that a given l of cardinality N has (2N - 1) non-empty sublist. He writes down all the non-empty sublists for a given set A. For each sublist, he calculates sublist_sum, which is the sum of elements and denotes them by S1, S2, S3, ... , S(2N-1).

He then defines a special_sum, P.

P = 2S1  + 2S2  + 2S3  .... + 2S(2N-1) and reports P % (109 + 7).  

Input Format 
The first line contains an integer N, i.e., the size of list A. 
The next line will contain N integers, each representing an element of list A.  

Output Format 
Print special_sum, P modulo (109 + 7).  

Constraints 
1 ≤ N ≤ 105 
0 ≤ ai ≤ 1010 , where i ∈ [1 .. N]  

Sample Input  

3
1 1 2


Sample Output  

44


Explanation  

For given list, sublist and calculations are given below 
1. {1} and 21 = 2 
2. {1} and 21 = 2 
3. {2} and 22 = 4 
4. {1,1} and 22 = 4 
5. {1,2} and 23 = 8 
6. {1,2} and 23 = 8 
7. {1,1,2} and 24 = 16 
So total sum will be 44.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
const int SIZE = 1011;
const int MOD = 1e9+7;
using namespace std;
long long mypow(long long x,long long y){
    long long res=1;
    while(y){
        if(y&1){
            res=res*x%MOD;
        }
        y>>=1;
        x=x*x%MOD;
    }
    return res;
}
int main(){
    DRI(N);
    long long res=1;
    REP(i,N){
        long long x;
        cin>>x;
        res=res*(mypow(2,x)+1)%MOD;
    }
    res--;
    if(res<0)res+=MOD;
    cout<<res<<endl;
    return 0;
}

----------
====================
----------
MATHEMATICS.169
medium
----------
PROBLEM STATEMENT:
Given a triangle of numbers where each number is equal to the sum of the three numbers on top of it, find the first even number in a row.  

Explanatory Note:
The vertex of the triangle (at the top) is 1.
The structure of the triangle is shown below.
Each number is equal to the sum of the numbers at the following positions:
Position X: immediately above it.
Position Y: to the immediate left of X.
Position Z: to the immediate right of X.
If there are no numbers at positions X, Y, or Z, then assume those positions are occupied by a zero (0). This can occur for positions at the edge.


Here are four rows of the triangle:

         1
      1  1  1
   1  2  3  2  1
1  3  6  7  6  3  1


Input Format and Constraints 
First line contains a number T (number of test cases).
Each of the next T lines contain a number N (the row number, assuming that the top vertex of the triangle is Row 1).

Output Format 
For each test case, display an integer that denotes the position of the first even number. 
Note: Assume that the left most number in a row is Position 1.
If there is no even number in a row, print -1.

Constraints 
1
3

Sample Input  

2
3
4


Sample Output  

2
3

----------
TOP SOLUTION:
----------
#include <iostream>
using namespace std;

int main(){
	int T;
	cin>>T;
	
	for(int i=0; i<T; i++){
		int N;
		cin>>N;
		
		if(N%2 == 1){
			cout<<2<<endl;
		}
		else if(N%4 == 0 || N%4 == 1){
			cout<<3<<endl;
		}
		else{
			cout<<4<<endl;
		}
	}
}

----------
====================
----------
MATHEMATICS.170
medium
----------
PROBLEM STATEMENT:
Little Gaurav is very fond of numbers and sequences. One day his teacher tells him to find a strange sequence.    

[expression]

Since this sequence looks a bit difficult, the teacher tells him to find the last digit of [expression].  

Little Gaurav is confused because he cannot solve the problem and leaves this problem to the worthy programmers of the world. Help little Gaurav in finding the solution.   

Input Format 
The first line contains [expression], the number of test cases. 
[expression].   

Output Format 
For each testcase, print the last digit of [expression] in one line.    

Constraints 
[expression] 
[expression]  

Sample Input     

3
1
2
3


Sample Output   

0
6
0


Explanation 
For n=1, only i=0 is valid. So S is [expression]. Hence last digit of S is 0. 
For n=2, only i=0 and 1 are valid. So S is 
S1(for i=0) is [expression]. 
S2(for i=1) is [expression]. 
So last digit of S is 6. 
----------
TOP SOLUTION:
----------
#include<iostream>
#include<math.h>

using namespace std;

int main(){
    int t;
    cin >> t;
    while(t--){
        long long n;
        cin >> n;
        if(n%2 == 1){
            cout << "0\n";
        }
        else{
            long long sum = 0;
            for(long long i = 0 ; pow(2,i) <= n ; i++){
                if(i == 0){
                    sum = sum + 2;
                }
                else if(i == 1){
                    sum = sum + 4;
                }
                else{
                    sum = sum + 6;
                }
                sum = sum%10;
            }
            cout << sum%10 << "\n";
        }
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.171
hard
----------
PROBLEM STATEMENT:
Little Kevin had never heard the word 'Infinitum'. So he asked his mentor to explain the word to him. His mentor knew that 'Infinitum' is a very large number. To show him how big Infinitum can be, his mentor gave him a challenge: to sum the numbers from 1 up to N. The sum started to get really large and was out of long long int range. And so the lesson was clear.

Now his mentor introduced him to the concept of mod and asked him to retain only the remainder instead of the big number. And then, he gave him a formula to compute:

[expression]

Input Format 
The first line contains T, the number of test cases. 
T lines follow, each containing 2 space separated integers N m

Output Format 
Print the result on new line corresponding to each test case.  

Constraint 
1 ≤ T ≤ 1000 
1 ≤ N ≤ 109 
1 ≤ m ≤ 109

Sample Input  

3
10 5
10 3
5 5


Sample Output  

20
10
10


Explanation 
Case 1: N = 10 m = 5, 
1%5 + 2%5 + 3%5 + 4%5 + 5%5 + 6%5 + 7%5 + 8%5 + 9%5 + 10%5 = 20. 
Similar explanation follows for Case 2 and 3. 
----------
TOP SOLUTION:
----------
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

typedef long long int lli;

int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        lli n,m;
        cin>>n>>m;
        lli ans = 0;
        if(m>n)
            ans = n*(n+1)/2;
        else
        {
            ans = m*(m-1)/2;
            ans *= (n/m);
            lli temp = n%m;
            ans += temp*(temp+1)/2;
        }
        cout<<ans<<endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.172
easy
----------
PROBLEM STATEMENT:
Tim likes Math. He likes it so much that he always brings his tablets with him and reads math e-books everywhere, even during parties.

Tim found an interesting exercise in one of the e-books he is reading. But you want him to join the party, so you decide to answer the question for him.

The problem is: Given [expression] are there such that:

[expression]
[expression]
----------
TOP SOLUTION:
----------
//#pragma comment (linker, "/STACK:128000000")
//#include "testlib.h"
#include <cstdio>
#include <cassert>
#include <algorithm>
#include <iostream>
#include <memory.h>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <cmath>
//#include <unordered_map>
//#include <unordered_set>
#include <ctime>
#include <stack>
#include <queue>
using namespace std;
//#define FILENAME ""
#define mp make_pair
#define all(a) a.begin(), a.end()
typedef long long li;
typedef long double ld;
void solve();
void precalc();
clock_t start;
//int timer = 1;

bool doing = true;

int main() {
#ifdef room111
	freopen("in.txt", "r", stdin);
	//freopen("out.txt", "w", stdout);
#else
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	//freopen(FILENAME".in", "r", stdin);
	//freopen(FILENAME ".out", "w", stdout);
#endif
	int t = 1;
	cout.sync_with_stdio(0);
	cin.tie(0);
	precalc();
	cout.precision(10);
	cout << fixed;
	cin >> t;
	start = clock();
	int testNum = 1;
	while (t--) {
		//cout << "Case #" << testNum++ << ": ";
		solve();
		//++timer;
	}

#ifdef room111
	cerr << "\n\n" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << "\n\n";
#endif

	return 0;
}

//BE CAREFUL: IS INT REALLY INT?

#define int li

void precalc() {

}

int binpow(int q, int w, int mod) {
	if (!w)
		return 1;
	if (w & 1)
		return q * binpow(q, w - 1, mod) % mod;
	return binpow(q * q % mod, w / 2, mod);
}

void solve() {
	int d, p;
	cin >> d >> p;

	if (d < 0) {
		cout << "0\n";
		return;
	}

	int D = d * d + 4 * p;
	int cur = int(sqrt((ld)D) + 1e-9);

	if (cur * cur != D) {
		cout << "0\n";
		return;
	}

	if ((d + cur) & 1) {
		cout << "0\n";
		return;
	}

	if (cur == 0) {
		if (d != 0) {
			cout << "2\n";
		}
		else {
			cout << "1\n";
		}
		return;
	}
	else {
		if (d != 0) {
			cout << "4\n";
		}
		else {
			cout << "2\n";
		}
		return;
	}

}





----------
====================
----------
MATHEMATICS.173
easy
----------
PROBLEM STATEMENT:
A Pythagorean triple consists of three positive integers [expression]. This term comes from the Pythagorean theorem, which says that a Pythagorean Triple will be the lengths of the sides of a right-angled triangle.  

You have been given an integer [expression] which represents the length of one of cathetus of a right-angle triangle.  



You need to find the lengths of the remaining sides. There may be multiple possible answers; any one will be accepted.

Hints: 


Every odd number [expression].  
If [expression]. 

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
#define err(x) cerr << "err->" << x << endl
typedef long long LL;
template <typename T, typename U>
inline void chkmax(T& x, U y) {
	if (x < y) x = y;
}
template <typename T, typename U>
inline void chkmin(T& x, U y) {
	if (y < x) x = y;
}
LL modPow(LL a, LL n, LL p) {
	LL ret = 1;
	for (; n; n >>= 1, a = (LL)a * a % p) if (n & 1) ret = (LL)ret * a % p;
	return ret;
}

int main(){
	#ifndef ONLINE_JUDGE
//		freopen("in.txt", "r", stdin);
//		freopen("out.txt", "w", stdout);
	#endif
	LL n;
	cin>>n;
	if (n%2) printf("%lld %lld %lld\n", n, (n*n>>1), (n*n>>1) + 1);
	else printf("%lld %lld %lld\n", n, (n>>1)*(n>>1)-1, (n>>1)*(n>>1)+1);
	return 0;
}

----------
====================
----------
MATHEMATICS.174
hard
----------
PROBLEM STATEMENT:
You are given an array of numbers. Let us denote the array with [expression].

fun(A)
    sum = 0
    for i = 1 to A.length
        for j = i+1 to A.length
            sum = sum + Floor((A[i]+A[j])/(A[i]*A[j])) 
    return sum


In short, this function takes all distinct pairs of indexes from the array and adds the value [expression] to the sum. Your task is to find the sum.  

Note: [expression] is the integer division function.  

Input Format 
The first line contains [expression], the number of test cases to follow.  

Each test case contains two lines: the first line contains [expression] integers separated by spaces.  

Output Format 
The output should contain exactly [expression] test case.  

Constraints 
[expression] 
[expression] 
[expression] 
[expression]  

Sample Input  

2
3
4 2 3
3
1 4 1


Sample Output  

0
4


Explanation 
First Test Case: [expression] 
Second Test Case: [expression]  
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
#define ll long long int
using namespace std;
ll func(ll n)
{
    if(n<2)
        return 0;
    else return ((n*(n-1))/2);
}
int main(){
 ll t;
 cin>>t;
 while(t--){
    ll n,i,j,count=0,count2=0;
    cin>>n;
    ll a[n];
    for(i=0;i<n;i++){
        cin>>a[i];
        if (a[i]==1) count++;
        if (a[i]==2) count2++;}
    j=func(count)*2+count*(n-count)+func(count2);
    cout<<j<<endl;

 }
 return 0;
}
----------
====================
----------
MATHEMATICS.175
easy
----------
PROBLEM STATEMENT:
The positive odd numbers are sorted in ascending order as [expression] and so on.

Thus, the first group is [expression] elements of the sequence. 

Given [expression]:



Complete the function sumOfGroup with input integer [expression]th group.
----------
TOP SOLUTION:
----------
/*
*/

//#pragma GCC optimize("O3")
#define _CRT_SECURE_NO_WARNINGS
#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>

#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk

#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd
#define have adsgagshdshfhds
#define ends asdgahhfdsfshdshfd

#define eps 1e-8
#define M_PI 3.141592653589793
#define bsize 512

#define ldouble long double
using namespace std;

#define bs 1000000007

const int N = 510031;

long long x;

int main(){
//	freopen("apache.in","r",stdin);
//	freopen("apache.out","w",stdout);
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
//	cin.tie(0);

	cin>>x;

	cout<<x*x*x<<endl;

//	cin.get(); cin.get();
	return 0;
}

----------
====================
----------
MATHEMATICS.176
medium
----------
PROBLEM STATEMENT:
James is very naive in Mathematics, He always makes new things out of a given list of integers. Today he is given a list [expression] out of it.  

[expression] from a given list can be calculated as follows.

value_of_S(list L)
{
    while ((number of elements in L)  1)
    {
        a = L[0]
        b = L[1]
        delete L[1]
        L[0] = a+b+ab
    }
    return L[0] % 1000000007
}


James has an ample amount of time, so he calculates the values of [expression] and finds their average value. Then he asks you to report that value.

Input Format 
The first line contains an integer [expression], the number of integers in the list. 
The second line contains [expression], separated by single spaces.

Output Format 
Print the floor of the average value.

Constraints 
[expression] 
[expression]

Sample Input  

2
2 3


Sample Output  

11


Explanation 
The [expression].
----------
TOP SOLUTION:
----------
#include<iostream>
#include<utility>
#include <boost/multiprecision/cpp_int.hpp>
using namespace std;
using boost::multiprecision::cpp_int;
int main()
{
    cpp_int n,i,j,k,m;
    cin>>n;
    cin>>i;
    for(j=1;j<n;j++){
        cin>>k;
        i=i+k+i*k;
    }
    cout<<i%1000000007;
}

----------
====================
----------
MATHEMATICS.177
medium
----------
PROBLEM STATEMENT:
Mark is an undergraduate student and he is interested in rotation. A conveyor belt competition is going on in the town which Mark wants to win. In the competition, there's A conveyor belt which can be represented as a strip of 1xN blocks. Each block has a number written  on it. The belt keeps rotating in such a way that after each rotation, each block is shifted to left of it and the first block goes to last position.  

There is a switch near the conveyer belt which can stop the belt. Each participant would be given a single chance to stop the belt and his PMEAN would be calculated.  

PMEAN is calculated using the sequence which is there on the belt when it stops. The participant having highest PMEAN is the winner. There can be multiple winners.

Mark wants to be among the winners. What PMEAN he should try to get which guarantees him to be the winner.

[expression]

where [expression] represents the configuration of conveyor belt when it is stopped. Indexing starts from 1.  

Input Format 
First line contains N denoting the number of elements on the belt. 
Second line contains N space separated integers.  

Output Format 
Output the required PMEAN  

Constraints 
1 ≤ N ≤ 106 
-109 ≤ each number ≤ 109 
For any rotation, PMEAN will always lie within the range of 64-bit signed integer.  

Sample Input  

3
20 30 10 


Sample Output  

140


Explanation  

Number on top can be written in these manners. 
Initial numbers on belt, 20 30 10  PMEAN = 1x20 + 2x30 + 3x10 = 110 
After first rotation,     30 10 20  PMEAN = 1x30 + 2x10 + 3x20 = 110 
After second rotation,     10 20 30  PMEAN = 1x10 + 2x20 + 3x30 = 140 
So maximum possible value will be 140.
----------
TOP SOLUTION:
----------
// {{{ by shik
#include <bits/stdc++.h>
#include <unistd.h>
#define SZ(x) ((int)(x).size())
#define ALL(x) begin(x),end(x)
#define REP(i,n) for ( int i=0; i<int(n); i++ )
#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )
#define FOR(it,c) for ( __typeof((c).begin()) it=(c).begin(); it!=(c).end(); it++ )
#define MP make_pair
#define PB push_back
using namespace std;
typedef long long LL;
typedef pair<int,int> PII;
typedef vector<int> VI;

void RI() {}

template<typename... T>
void RI( int& head, T&... tail ) {
    scanf("%d",&head);
    RI(tail...);
}
// }}}

#define N 1000010
int n,a[N];
int main() {
    RI(n);
    REP(i,n) RI(a[i]);
    LL s=0;
    REP(i,n) s+=a[i];
    LL now=0;
    REP(i,n) now+=1LL*(i+1)*a[i];
    LL ans=now;
    REP(i,n) {
        now+=1LL*n*a[i]-s;
        ans=max(ans,now);
    }
    cout<<ans<<endl;
    return 0;
}


----------
====================
----------
MATHEMATICS.178
medium
----------
PROBLEM STATEMENT:
We define a [expression] series as follows:


[expression]   
[expression]  
[expression]  
[expression]  


We define a Hackonacci Matrix to be an [expression] is even, it's X; otherwise, it's Y.

Next, we want to perform [expression]: 



As you can see, there are two cells whose values change after the rotation. Note that we filled each initial cell using the Hackonacci formula given above:


[expression] 
Because this is an odd number, we mark this cell with a Y.
[expression] 
Because this is an even number, we mark this cell with an X.
[expression] 
Because this is an even number, we mark this cell with an X.
[expression] 
Because this is an even number, we mark this cell with an X.


Given the value of [expression] degrees in the clockwise direction. 
----------
TOP SOLUTION:
----------
#pragma GCC diagnostic ignored "-Wunused-result"

#include <cstdio>
#include <vector>
#include <cassert>

void research() {
	std::vector<int> h(1 + 1000);
	h[1] = 1 % 2;
	h[2] = 2 % 2;
	h[3] = 3 % 2;
	for (int i = 4; i <= 1000; i++) {
		h[i] = (1 * h[i - 1] + 2 * h[i - 2] + 3 * h[i - 3]) % 2;
	}
	std::vector<int> p{1, 1, 0, 1, 0, 0, 1};
	for (int i = 1; i <= 1000; i++) {
		printf("%d -> %d\n", i, h[i]);
		assert(h[i] == p[i % 7]);
   	}
}

void rotate(const std::vector<std::vector<int>> &src, std::vector<std::vector<int>> &dst) {
	int n = (int)src.size();
	// 1 2   3 1
	// 3 4   4 2
	for (int srcI = 0, dstJ = n - 1; srcI < n; srcI++, dstJ--) {
		for (int srcJ = 0, dstI = 0; srcJ < n; srcJ++, dstI++) {
			dst[dstI][dstJ] = src[srcI][srcJ];
		}
	}
}

int getDiff(const std::vector<std::vector<int>> &a, const std::vector<std::vector<int>> &b) {
	int count = 0;
	int n = (int)a.size();
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (a[i][j] != b[i][j]) {
				count++;
			}
		}
	}
	return count;
}

int main() {
	// research();
	int n, q;
	scanf("%d %d", &n, &q);
	std::vector<std::vector<int>> a(n, std::vector<int>(n));
	std::vector<int> hp{1, 1, 0, 1, 0, 0, 1};
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			a[i][j] = hp[1LL * (i + 1) * (j + 1) * (i + 1) * (j + 1) % 7];
		}
	}
	auto b = a;
	rotate(a, b);
	auto c = b;
	rotate(b, c);
	auto d = c;
	rotate(c, d);
	std::vector<int> diff{getDiff(a, a), getDiff(a, b), getDiff(a, c), getDiff(a, d)};
	for (int i = 0; i < q; i++) {
		int r;
		scanf("%d", &r);
		assert(r % 90 == 0);
		r /= 90;
		r %= 4;
		printf("%d\n", diff[r]);
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.179
advanced
----------
PROBLEM STATEMENT:
Help Shashank in calculating the value of [expression].

[expression]

Input Format 
The first line contains an integer [expression] i.e. number of the test cases. 
The next [expression].  

Output Format 
Print the last two digits of [expression] for each test case in separate lines.  

Constraints 
[expression] 
[expression] 
[expression]  

Sample Input#00  

3
2 2
2 3
3 3


Sample Output#00  

05
09
36


Sample Input#01  

3
5 2
3 4
3 3


Sample Output#01  

55
98
36


Explanation

For the first test case, [expression]
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
ll po(ll a,ll b)
    {
    if(b==0)return 1;
        ll x = po(a,b/2);
    x=(x*x)%100;
    if(b&1)x=(a*x)%100;
    return x;
}

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int t;
    ll n,k;
    scanf("%d",&t);
    while(t--)
        {
        scanf("%lld%lld",&n,&k);
        ll a[105];
        int i;
        for(i=0;i<100;i++)
            a[i] = po(i,k);
        for(i=1;i<100;i++)
            {
            a[i] = (a[i] + a[i-1] )%100;
        }
        ll fir,sec;
        fir = n/100;
        
        fir = a[99]*fir;
        sec = a[n%100];
        fir = (fir+sec)%100;
        printf("%02lld\n",fir);
        
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.180
easy
----------
PROBLEM STATEMENT:
As punishment for attacking Sunland, Wet Shark is now forced to walk on a line of numbered squares, starting from [expression]. 

Wet Shark does not know that this line of squares is infinitely long, and he is determined to continue walking until his strength reaches [expression], etc. 

Wet Shark’s punisher needs your help, and wants to compute where Wet Shark will stop in order to meet him there and punish him. Given Wet Shark’s initial strength [expression].
----------
TOP SOLUTION:
----------
/*
*/
 
//#pragma comment(linker, "/STACK:16777216")
#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <ctime> 
 
#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
 
#define eps 1e-11
//#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 256
#define right adsgasgadsg
#define free adsgasdg
 
using namespace std;

long long tests,s,l,r,mid;

long long get(long long x)
{
 return x/2-x/42;
}

int main(){
//freopen("repair.in","r",stdin);
//freopen("repair.out","w",stdout);
//freopen("C:/input.txt","r",stdin);
//freopen("C:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);
//cin.tie(0);

cin>>tests;
for (;tests;--tests)
{
 cin>>s;
 l=0;
 r=3e18;
 while (l<r)
 {
  mid=l+r;
  mid/=2;
  if (get(mid)<s)l=mid+1;
  else r=mid;
 }
 cout<<l%bs<<endl;
}
cin.get();cin.get();
return 0;}

----------
====================
----------
MATHEMATICS.181
hard
----------
PROBLEM STATEMENT:
Watson gives a square of side length 1 to Sherlock. Now, after each second, each square of some arbitrary side [expression](as shown in the image below). 



Now, Watson asks Sherlock: What will be the sum of length of solid lines after [expression] seconds?  

As the number can be large print result mod [expression].

For example, after 0 seconds, the length is 4. 
After 1 second, the length is 6.

Input Format 
First line contains [expression] in one line.   

Output Format

For each testcase, print the required answer in a new line. 

Constraints 
[expression] 
[expression]

Sample input

3
0
1
5


Sample output

4
6
66

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
ll hi = 1000000007;
ll po(ll a){
    if(a==0)return 1;
    ll x = po(a/2);
    x=(x*x)%hi;
    if(a%2)x=(2*x)%hi;
    return x;
}


int main() {
   int t;
    scanf("%d",&t);
    while(t--)
        {
        ll n;
        scanf("%lld",&n);
        n=po(n);
        n++;
        n=n*2;
        printf("%lld\n",n%hi);
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.182
medium
----------
PROBLEM STATEMENT:
Julia received a really simple function, [expression], for her birthday! The function is defined as:
[expression] 
Here, [expression]!

Julia wants your help finding the triplet [expression].  



You are given [expression] is defined as: 
[expression]

Note: It is guaranteed that the triplet [expression].
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.183
advanced
----------
PROBLEM STATEMENT:
Watson gives Sherlock an array [expression] elements each. Then he asks Sherlock to perform the following program:

for i = 1 to M do
    for j = 1 to N do
        if j % B[i] == 0 then
            A[j] = A[j] * C[i]
        endif
    end do
end do


This code needs to be optimized. Can you help Sherlock and tell him the resulting array [expression].

Input Format 
The first line contains two integer, [expression], respectively.

Output Format 
Print [expression].

Constraints 
[expression] 
[expression] 
[expression]

Sample Input

4 3
1 2 3 4
1 2 3
13 29 71


Sample Output

13 754 2769 1508

----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <typeinfo>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt(): x(0) { }
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }
	
	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	
	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
};
typedef ModInt<1000000007> mint;

int main() {
	int N, M;
	scanf("%d%d", &N, &M);
	vector<mint> A(N);
	rep(i, N) {
		int a;
		scanf("%d", &a);
		A[i] = a;
	}
	vector<int> B(M), C(M);
	rep(i, M) scanf("%d", &B[i]);
	rep(i, M) scanf("%d", &C[i]);
	map<int,mint> BC;
	rep(i, M) {
		int b = B[i];
		if(!BC.count(b)) BC[b] = 1;
		BC[b] *= C[i];
	}
	each(i, BC) {
		int b = i->first; mint c = i->second;
		for(int j = b; j <= N; j += b)
			A[j-1] *= c;
	}
	rep(i, N) {
		if(i != 0) putchar(' ');
		printf("%d", A[i].get());
	}
	puts("");
	return 0;
}

----------
====================
----------
MATHEMATICS.184
medium
----------
PROBLEM STATEMENT:
Manasa recently lost a bet to Amit. To settle the problem, they are playing a game:  

They have N balls in front of them. Each ball, except the 1st ball, is numbered from 0 to 9. The 1st ball is numbered from 1 to 9. 

Amit calculates all the subsequences of the number thus formed. Each subsequence of sequence S is represented by Sk. 

e.g. S = 1 2 3  

S0 = 1 2 3 , 
S1 = 1 2 , 
S2 = 1 3 , 
S3 = 2 3 , 
S4 = 1 , 
S5 = 2 , and 
S6 = 3 .  

Each subsequence Sk also represents a number. e.g. S1 represents tweleve, S2 represents thirteen.

Now Manasa has to throw Sk candies into an intially empty box, where k goes from 0 to ( maximum number of subsequences -  1).

At the end of the game, Manasa has to find out the total number of candies, T, in the box. As T can be large, Amit asks Manasa to tell T % (109 + 7 ). If Manasa answers correctly, she can keep all the candies. Manasa can't take all this Math and asks for your help.  

Help her!

Note: A subsequence can also be have preceding zeros. For example, the sequence 103 has subsequences 103, 10, 13, 03, 1, 0, and 3 (so both 03 and 3 are counted separately).

Input Format 
A single line containing a number having N digits.  

Output Format 
A number contaning the output.  

Constraints 
1 ≤ N ≤ 2*105  

Sample Input 00

111


Sample Output 00

147


Sample Input 01

123


Sample Output 01

177


Explanation  

The subsequence of number 111 are 111, 11 , 11, 11, 1, 1 and 1. Whose sum is 147.

The subsequence of number 123 are 123, 12 , 23, 13, 1, 2 and 3. Whose sum is 177.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <string>

using namespace std;

long long fast_power(long long a, long long b, long long c)
{
     long long result = 1;
     while ( b > 0 ) {
           if ( b&1 ) result = ((result%c)*(a%c))%c;
           a = ((a%c)*(a%c))%c;
           b = b/2;
     }
     return result%c;
}

int main()
{
    long long n,x,i,sum,p,q,k;
    string s;
    
    n = 1;
    
    while ( n-- ) {
          cin >> s;
          x = 1000000007;
          sum = 0;
          k = s.size();
          for ( i = 0; i < k; i++ ) {
              p = fast_power(11,i,x);
              q = fast_power(2,k-i-1,x);
              p = (p*q)%x;
              p = ((p%x)*((s[s.size()-i-1]-48)%x))%x;
              sum += p;
          }
          printf("%lld\n", sum%x);
    }
    return 0;
}


----------
====================
----------
MATHEMATICS.185
medium
----------
PROBLEM STATEMENT:
Eric has four integers [expression]. 

Instantly, he wondered how many pairs of integers, [expression], satisfy the following equation:

[expression]

where [expression]. 

Find and print the number of pairs that satisfy the above equation.  
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;
typedef long long int ll;

ll countSolutions(ll a, ll b, ll c, ll d){
   ll count=0;
double maxx=((double)a/2)+((double)(sqrt(a*a+b*b)))/2;
     for(ll x=1;x<=((c<maxx)?c:maxx);x++)
{
double y1=((double)b/2)+((double)(sqrt((b*b)-(4*((x*x)-a*x)))))/2;
double y2=((double)b/2)-((double)(sqrt((b*b)-(4*((x*x)-a*x)))))/2;
if((y1>=1 && y1<=d)&& ((y1-(ll)y1)==0))
count++;
if((y2>=1 && y2<=d)&& ((y2-(ll)y2)==0))
count++;
if((y1==y2) && ((y1>=1 && y1<=d)&& ((y1-(ll)y1)==0)) && ((y2>=1 && y2<=d)&& ((y2-(ll)y2)==0)))
count--;
}
   
   
    return count;
}

int main() {
    ll q;
    cin >> q;
    while(q--){
        ll a,b,c,d;
        cin >> a >> b >> c >> d;
        ll result = countSolutions(a, b, c, d);
        cout << result << endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.186
advanced
----------
PROBLEM STATEMENT:
You are given a sequence whose [expression] term is 
[expression]
You have to evaluate the series
[expression]
Find [expression].

Input Format  

The first line of input contains [expression], the number of test cases.  

Each test case consists of one line containing two space-separated integers [expression].  

Output Format  

For each test case, print the required answer in a line.  

Constraints  

[expression] 
[expression] 
[expression]  

Sample Input

3
5 3
4 2
4 1


Sample Output  

225
30
10


Explanation  

Case 1: We have [expression] 
Case 2: We have [expression] 
Case 3: We have [expression]  
----------
TOP SOLUTION:
----------
#include<stdio.h>
long long P;
long long pow(long long x,int y){
    long long an=1;
    while(y){
        if(y&1){
            an*=x;
            an%=P;
        }
        x=(x*x)%P;
        y>>=1;
    }
    return an;
}
void Q3(long long a,long long b,long long &x,long long &y){
    long long x2,y2,q,r;
    if(b==1){
        x=0;
        y=1;
        return;
    }
    q=a/b;
    r=a%b;
    Q3(b,r,x2,y2);
    x=y2;
    y=x2-q*y2;
}
long long Div(int n){
    long long x,y;
    Q3(P,n,x,y);
    y%=P;
    if(y<0)y+=P;
    return y;
}
int remain(int x){
    while(x%P==0)x/=P;
    return x;
}
long long Fra(long long N,int k){
    if(N<k)return 0;
    if(k==0)return 1;
    long long an=1;
    int i;
    for(i=1;i<=k;i++){
        an*=remain(N-i+1);
        an%=P;
        an*=Div(remain(i));
        an%=P;
    }
    return an;
}
int factor(int x){
    if(x<P)return 0;
    return x/P+factor(x/P);
}
bool check(int x,int y){
    return factor(x)-factor(x-y)-factor(y)==0;
}
long long Q2(int K,long long N,long long d[]){
    long long an=0,tmp;
    int i,j;
    for(i=0;i<K;i++){
        if(!check(N,i))continue;
        an+=(d[i]*Fra(N,i))%P;
        an%=P;
    }
    return an;
}
long long dd[1024][1024];
int Q(long long a,long long b,int x){
    int i,j,K=x+2,N=b-a;
    dd[0][0]=pow(a,x)%P;
    for(i=1;i<K;i++)dd[0][i]=(dd[0][i-1]+pow(a+i,x))%P;
    if(N<K)return dd[0][N];
    for(i=1;i<K;i++)
        for(j=0;j<K-i;j++)dd[i][j]=(dd[i-1][j+1]-dd[i-1][j]+P)%P;
    for(i=1;i<K;i++)dd[0][i]=dd[i][0];
    return Q2(K,N,dd[0]);
}
main(){
    int T,x;
    long long N,a,b;
    scanf("%d",&T);
    while(T--){
        scanf("%lld%d",&b,&x);
        a=1;
        P=1e9+7;
        b%=P;
        printf("%d\n",Q(a,b,x));
    }
}


----------
====================
----------
MATHEMATICS.187
hard
----------
PROBLEM STATEMENT:
Devendra loves the XOR operation very much which is denoted by [expression] .

For query [expression].

[expression]

Input Format 
The first line contains an integer [expression]. 
Next line will contain [expression] space seperated integers. 
Third line will contain a number [expression].

Output Format 
Print [expression] query. Answer will be 0 in case of P=R.

Constraints 
[expression] 
[expression] 
[expression] 
[expression] 
[expression]

Sample Input  

3
1 2 3
2
1 1 3
2 1 3


Sample Output  

5
4


Explanation

For first query, it will will be [expression]
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <set>
#include <math.h>

using namespace std;

#define N 22
#define M 100100
#define mod 1000000007ll
#define long long long

int n, s[N][M];

void read() {
    cin >> n;
    for (int i = 1, a; i <= n; ++i) {
        cin >> a;
        for (int j = 0; j < N; ++j) {
            s[j][i] = s[j][i - 1] + ((a >> j) & 1);
        }
    }
}

void kill() {
    int l, r, k;
    cin >> k >> l >> r;
    --l;

    long ans = 0;

    for (int j = 0; j < N; ++j) {
        long one = s[j][r] - s[j][l];
        long zero = (r - l) - one;
        long bon = (1 << j);
        long count;
        if ((k >> j) & 1) {
            count = one * (one - 1) + zero * (zero - 1);
            count /= 2;
            count %= mod;
        }
        else {
            count = one * zero;
            count %= mod;
        }

        ans += bon * count;
        ans %= mod;
    }

    cout << ans << "\n";
}

void dude() {
    int m; 
    cin >> m;
    while (m--) {
        kill();
    }
}

int main() {
#ifdef TROLL
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#else
    ios_base::sync_with_stdio(0);
#endif

    read();
    dude();

    return 0;
}

----------
====================
----------
MATHEMATICS.188
medium
----------
PROBLEM STATEMENT:
Manasa is a student in the department of Mathematics. She is pretty good at doing calculations involving small numbers, but large numbers scare her. So she wants you to help her in the following calculations.

Given two numbers in the following manner:

[expression]
[expression]

([expression]'s are distinct)

She wants you to calculate [expression]. In other words:

[expression] 

As the value of [expression].

Input Format 
The first line contains an integer [expression], the number of prime factors. 
Each of the next [expression].

Output Format 
Print the value of [expression].

Constraints  

[expression] 
[expression] 
[expression] 
[expression] 
[expression]  

Sample Input

2
2 1 2 
3 1 2


Sample Output

72


Explanation

We have [expression]:


[expression]  
[expression]  


Hence, [expression]
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
typedef long long LL;
using namespace std;
const int MOD = 1e9+7;
const int SIZE = 1e6+10;
int p[SIZE],a[SIZE],b[SIZE];
LL mypow(LL x,LL y){
    LL res=1;
    while(y){
        if(y&1)res=res*x%MOD;
        y>>=1;
        x=x*x%MOD;
    }
    return res;
}
int main(){
    DRI(N);
    REP(i,N)RIII(p[i],b[i],a[i]);
    LL res=1;
    int cnt=0;
    REP(i,N){
        if(a[i]!=b[i])res*=(mypow(p[i],a[i])+mypow(p[i],b[i]));
        else res*=mypow(p[i],a[i]),cnt++;
        res%=MOD;
    }
    if(cnt==N)res*=2;
    res%=MOD;
    cout<<res<<endl;
    return 0;
}

----------
====================
----------
MATHEMATICS.189
easy
----------
PROBLEM STATEMENT:
You are given the equation [expression] test cases.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

const i64 P = 1000000000 + 7;

i64 deg(i64 x, i64 d) {
    x %= P;
    d %= P - 1;
    if (d < 0) d += P - 1;
    i64 y = 1;
    while (d) {
        if (d & 1) y *= x, y %= P;
        x *= x, x %= P;
        d /= 2;
    }
    return y;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int T;
    cin >> T;
    forn(t, T) {
        i64 p, q, n;
        cin >> p >> q >> n;
        p *= deg(q, -1); p %= P;
        i64 y = 0;
        while (n) {
            if (n & 1) y = (y + p) * deg(1 - y * p, -1), y %= P;
            p = (p + p) * deg(1 - p * p, -1), p %= P;
            n /= 2;
        }
        if (y < 0) y += P;
        cout << y << '\n';
    }

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
MATHEMATICS.190
medium
----------
PROBLEM STATEMENT:
You are just learning to code and are finished with loops and functions. Now, you are given the following pseudocode:

[expression]
[expression]
[expression]
[expression]
[expression]
    [expression]

    [expression]
        [expression]
        [expression]
    [expression]

    [expression]
[expression]



For three given integers [expression] is defined as:
[expression]
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.191
advanced
----------
PROBLEM STATEMENT:
There are [expression] written on it. They play the following game:


In the [expression] increases his number by the sum of the numbers of his neighbors.  
In the [expression]nd round, the child next in clockwise order increases his number by the sum of the numbers of his neighbors.
In the [expression]rd round, the child next in clockwise order increases his number by the sum of the numbers of his neighbors.
And so on.  


The game ends after [expression] rounds have been played.  

For every [expression].  
----------
TOP SOLUTION:
----------
#include <vector>
#include <algorithm>
#include <cstdio>
#include <memory.h>


using std::swap;
using std::vector;
using std::scanf;
using std::printf;

static const int mod = 1000000007;

class Matrix
{
public:
	int n;
	Matrix(int n = 0)
	{
		this->n = n;
		for (int i = 0; i < n; ++i)
			for (int j = 0; j < n; ++j)
				data[i][j] = (int)(i == j);
	}
	Matrix (const Matrix& m)
	{
		n = m.n;
		memcpy(data, m.data, sizeof(data));
	}
	Matrix& operator = (const Matrix& m)
	{
		n = m.n;
		memcpy(data, m.data, sizeof(data));
		return *this;
	}
	Matrix operator * (const Matrix& m) const
	{
		Matrix ret(n);
		for (int i = 0; i < n; ++i)
		{
			for (int j = 0; j < n; ++j)
			{
				ret.data[i][j] = 0;
				for (int k = 0; k < n; ++k)
				{
					ret.data[i][j] = (ret.data[i][j] + (long long)data[i][k] * m.data[k][j]) % mod;
				}
			}
		}
		return ret;
	}

	vector<int> operator * (const vector<int>& v) const
	{
		vector<int> ret(n, 0);
		for (int i = 0; i < n; ++i)
		{
			for (int j = 0; j < n; ++j)
			{
				ret[i] = (ret[i] + (long long)v[j] * data[i][j]) % mod;
			}
		}
		return ret;
	}

	
	Matrix operator ^ (long long power) const
	{
		Matrix ret(n);
		Matrix cur(*this);
		while (power > 0)
		{
			if (power & 1)
				ret = ret * cur;
			power >>= 1;
			cur = cur * cur;
		}
		return ret;
	}

	void transform_for(int child_index)
	{
		memset(data, 0, sizeof(data));
		for (int i = 0; i < n; ++i)
		{
			if (i != child_index)
				data[i][i] = 1;
			else
				data[i][i] = data[i][(i - 1 + n) % n] = data[i][(i + 1) % n] = 1;
		}
	}
	int data[50][50];
};

void transform(vector<int> &v, int i)
{
	int n = v.size();
	v[i] = ((long long)v[i] + (long long)v[(i - 1 + n) % n] + v[(i + 1) %n]) % mod;
}



int main() 
{	
	

	int T;
	scanf("%d", &T);
	for (int t = 0; t < T; ++t)
	{
		int N, M;
		scanf("%d %d", &N, &M);

		vector<int> a(N);
		for (int i = 0; i < N; ++i)
			scanf("%d", &a[i]);
		
		Matrix A(N);
		for (int i = 0; i < N; ++i)
		{
			Matrix B(N);
			B.transform_for(i);
			A = B * A;
		}
		int K = M - N - N;
		if (K >= N)
		{
			K /= N;
			A = A ^ K;
		}
		else
			K = 0;
		for (int first = 0; first < N; ++first)
		{
			vector<int> v = a;
			int curM = 0;
			for (int i = first; curM < M && i < N; ++i, ++curM)
				transform(v, i);
			if (curM + (K * N) <= M && K > 0)
			{
				v = A * v;
				curM += K * N;
			}
			for (int i = 0; curM < M; ++curM, ++i)
				transform(v, i % N);

			for (int i = 0; i < N; ++i)
			{
				printf("%d", v[i]);
				if (i < N - 1)
					printf(" ");
			}
			printf("\n");
		}
		if (t < T - 1)
			printf("\n");
	}


	


	return 0;	
}
----------
====================
----------
MATHEMATICS.192
hard
----------
PROBLEM STATEMENT:
Mr. X wants to buy a necklace for his girlfriend.
The available necklaces are bi-colored (red and blue beads).

Mr. X desperately wants to impress his girlfriend and knows that she will like the necklace only if every prime length continuous sub-sequence of beads in the necklace has more or equal number of red beads than blue beads.

Given the number of beads in the necklace N, Mr. X wants to know the number of all possible such necklaces.

Note: - It is given that the necklace is a single string and not a loop.

Input Format 
The first line of the input contains an integer T, the number of testcases. 
T lines follow, each line containing N, the number of beads in the necklace.  

Constraints 
1 ≤ T ≤ 104 
2 ≤ N ≤ 1018  

Output Format 
For each testcase, print in a newline, the number of such necklaces that are possible.  If the answer is greater than or equal to 109+7, print the answer modulo ( % ) 109+7.

Sample Input

2
2
3


Sample Output

3
4


Explanation

For the first testcase, valid arrangement of beads are 

BR RB RR


For the second testcase, valid arrangement of beads are

BRR RBR RRR RRB

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
#include <iostream>
#include <set>
using namespace std;
#define Mo 1000000007   
#define Maxn 10
#define ll long long

ll c[Maxn][Maxn],b[Maxn][Maxn],a[Maxn][Maxn];

void pw(ll N){
    if (!N) return;
    pw(N/2);
    memset(c,0,sizeof(c));
    for (int i=1;i<=3;i++) 
        for (int j=1;j<=3;j++) 
        {
            for (int k=1;k<=3;k++) c[i][j] += b[i][k] * b[k][j] %Mo;
            c[i][j] %= Mo;
        }
    for (int i=1;i<=3;i++) for (int j=1;j<=3;j++) b[i][j] =c[i][j];
    if (N&1){
        memset(c,0,sizeof(c));
        for (int i=1;i<=3;i++) 
        for (int j=1;j<=3;j++) 
        {
            for (int k=1;k<=3;k++) c[i][j] += b[i][k] * a[k][j] %Mo;
            c[i][j] %= Mo;
        }
        for (int i=1;i<=3;i++) for (int j=1;j<=3;j++) b[i][j] = c[i][j];
    }
}
ll N,T;
int main()
{
    cin>>T;
    a[1][3] = a[2][1] = a[3][2] = a[3][3]= 1;
    while(T--){
        memset(b,0,sizeof(b));
        b[1][1]=b[2][2]=b[3][3] = 1;
        cin>>N;
        pw(N-2);
        ll ans =0;
        for (int i=1;i<=3;i++) for (int j=1;j<=3;j++) ans = (ans + b[i][j]) % Mo;    
        cout<<ans<<endl;
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.193
medium
----------
PROBLEM STATEMENT:
With the college fest approaching soon, Manasa is following a strict dieting regime . Today, she just cannot resist her temptation for having a pizza. An inner conflict ensues, and she decides that she will have a pizza, only if she comes up with a solution to the problem stated below. Help her get the pizza for herself.

Given a list L of N numbers, where 
L = { a1, a2, a3, a4 ....  , aN} 
Find the value of M that is computed as described below.  

  

Input Format 
The first line contains an integer N i.e. size of the list L. 
The next line contains N space separated integers, each representing an element of the list L.  

Output Format 
Print the value of M _modulo (109 + 7)_. 

Constraints 
1 ≤ N ≤ 5100
0 ≤ ai ≤ 1015 , where i ∈ [1 .. N]

Sample Input 00  

3
1 2 3


Sample Output 00  

40392


Explanation

There are 8 subsets of given set,


S = {1,2,3} and L - S  ={0} value of F(6) = 19601
S = {1,2} and L - S  ={3} value of F(0) = 1
S = {1,3} and L - S  ={2} value of F(2) = 17
S = {2,3} and L - S  ={1} value of F(4) = 577
S = {1} and L - S  ={2,3} value of F(4) = 577
S = {2} and L - S  ={1,3} value of F(2) = 17
S = {3} and L - S  ={1,2} value of F(0) = 1
S = {} and L - S  ={1,2,3} value of F(6) = 19601


Adding all these values, we get M = 40392.
----------
TOP SOLUTION:
----------
#include <cstring>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>

using namespace std;
typedef long long int64;
typedef pair<int, int> PII;
const int MOD = 1000000007;
const double EPSILON = 1e-10;

#define FORU(i, a, b) for (int i = (a); i <= (b); ++i)
#define FORD(i, a, b) for (int i = (a); i >= (b); --i)
#define REPU(i, a, b) for (int i = (a); i < (b); ++i)
#define REPD(i, a, b) for (int i = (a); i > (b); --i)
#define SIZE(A) ((int) A.size())
#define PB(X) push_back(X)
#define MP(A, B) make_pair(A, B)

template<class T> inline T tmin(T a, T b) {return (a < b) ? a : b;}
template<class T> inline T tmax(T a, T b) {return (a > b) ? a : b;}
template<class T> inline T tabs(T a) {return (a > 0) ? a : -a;}
template<class T> T gcd(T a, T b) {if (b == 0) return a; return gcd(b, a % b);}

struct Mat {
    int64 a11, a12, a21, a22;
};

Mat T = (Mat) {6, -1, 1, 0};

Mat mult(Mat A, Mat B) {
    Mat ans;
    ans.a11 = (A.a11*B.a11 + A.a12*B.a21) % MOD;
    ans.a12 = (A.a11*B.a12 + A.a12*B.a22) % MOD;
    ans.a21 = (A.a21*B.a11 + A.a22*B.a21) % MOD;
    ans.a22 = (A.a21*B.a12 + A.a22*B.a22) % MOD;
    return ans;
}

Mat exp(Mat A, int64 n) {
    if (n == 0) {
        return (Mat) {1, 0, 0, 1};
    }
    Mat ans = exp(A, n/2);
    ans = mult(ans, ans);
    if (n%2) ans = mult(ans, A);
    return ans;
}

int64 Fn(int64 n) {
    Mat xn = exp(T, n);
    int64 ans = (xn.a11 + 3*xn.a12) % MOD;
    return ans;
}

int main(int argc, char const *argv[])
{	
	ios_base::sync_with_stdio(false);
	int ntest, N;
    int64 a, s;
	cin >> N;
    s = 1;
    FORU(i, 1, N) {
        cin >> a;
        s = (2*Fn(a)*s) % MOD;
    }
    if (s < 0) s += MOD;
    cout << s << endl;
	return 0;
}
----------
====================
----------
MATHEMATICS.194
advanced
----------
PROBLEM STATEMENT:
Mobile Towers are on the rise in HacksVille and there are N such mobile towers. Each mobile tower 
is named according to its position in the 2D plane of HacksVille i.e. (A[i],B[i]) is the position
of the ith tower. The city due to its growing power needs, is not able to power all the mobile towers and it can power only a set of towers between a range, say [L..R] (both inclusive). 

All the Mobile Towers are monitored by a wireless control room. For the controller room to connect to all the active mobile towers, it has to position itself such that the sum of its distance to all the active mobile towers (S) is minimized. 

If the wireless control room is positioned at (X,Y). Then, its distance to the mobile tower i
is given by

max(|X-A[i]|,|Y-B[i]|) where |x| means absolute value of x. 


Input Format  

The first line contains two integers, N and Q separated by a space where Q is the indices of the mobile towers that are active at different points of time. 
The second line contains integers A1 to AN all separated by a single space. 
The third line contains integers B1 to BN all separated by a single space where (Ai,Bi) is the position of the ith tower.
Q lines follow each containing the range L and R separated by a single space which are the range of towers that are active. 

N Q
A1 A2 ... An
B1 B2 ... Bn
L1 R1
L2 R2
...
LQ RQ


Constraints 
1 
1 
-1000000000 
1 

Output Format

Your task is to find the optimal position and print its cumulative distance (S) to all the mobile towers. 

S1
S2
...
SQ


Error of at most 10-3 is tolerated. 

Sample Input  

4 2
1 2 0 1
4 3 1 1
1 4
3 4


Sample Output

5.0000000
1.0000000


Explanation

In the testcase, there are 4 mobile towers in the city of HacksVille positioned at (1,4), (2,3), (0,1) and (1,1)

At time T1, all the mobile towers are active ( indicated by L = 1 and R = 4 ). So, one possible location for the mobile control room would be at 

1.5 2.5 


The cumulative distance (S) is 

= max(|1.5-1|, |2.5-4|) + max(|1.5-2|,|2.5-3|) + max(|1.5-0|,|2.5-1|) + max(|1.5-1|,|2.5-1|)
= max(0.5, 1.5) + max(0.5,0.5) + max(1.5,1.5) + max(0.5,1.5)
= 1.5 + 0.5 + 1.5 + 1.5
= 5.0


At time T2, only the mobile towers indexed between 3 and 4 ( L = 3 and R = 4) are indexed. So, one possible location for the mobile control room would be, 

1 1


The cumulative distance (S) is 

= max(|1-0|,|1-1|) + max(|1-1|,|1-1|)
= max(1,0) + max(0,0)
= 1.0

----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cstdio>
#include <cmath>
#include <deque>
#include <map>

using namespace std;

#define MAXN 100200
#define x first
#define y second
#define mp make_pair
#define pb push_back
#define sz(a) (int)(a.size())
#define all(a) a.begin(), a.end()
#define R(a) ((a)%M)

typedef long long ll;
typedef vector<int> VI;
typedef vector<ll> VL;
typedef vector<VI> VVI;
typedef pair<double, int> PI;
typedef vector<PI> VPI;
typedef vector<VPI> VVPI;
typedef vector<VVPI> VVVPI;
typedef vector<VVI> VVVI;
typedef vector<double> VD;
typedef vector<VD> VVD;
typedef vector<string> VS;

int N, Q, a, b;
double _a, _b, A;
VPI x[2];
VI s[2][4*MAXN];
VD ss[2][4*MAXN];
VD _x[2], S[2];
PI u[2], tmp;

int search ( int idx, int at, int k, int lo, int hi )
{
	if(lo == hi)
	{
		if(s[idx][at][lo] <= k)
			return lo;
		return lo-1;
	}
	int mid = (lo+hi)/2;
	if (k < s[idx][at][mid+1])
		return search(idx, at, k, lo, mid);
	else
		return search(idx, at, k, mid+1, hi);
}

void build (int idx, int at, int l, int r)
{
	s[idx][at] = VI(r-l+1);
	ss[idx][at] = VD(r-l+2, 0.0);
	if(l == r)
		s[idx][at][0] = x[idx][l-1].y, ss[idx][at][1] = _x[idx][x[idx][l-1].y-1];
	else
	{
		int mid = (l+r)/2;
		build(idx, 2*at, l, mid);
		build(idx, 2*at+1, mid+1, r);
		int i = 0, j = 0;
		for (int k = 0; k <= r-l; k += 1)
		{
			if ( j == r-mid || (i <= mid-l && s[idx][2*at][i] < s[idx][2*at+1][j]) )
				s[idx][at][k] = s[idx][2*at][i], i += 1;
			else
				s[idx][at][k] = s[idx][2*at+1][j], j += 1;
			ss[idx][at][k+1] = ss[idx][at][k] + _x[idx][s[idx][at][k]-1];
		}
	}
	//cout << idx << "-> " << l << ' ' << r << ":";
	//for (int i = 0; i < sz(s[idx][at]); i += 1)
	//{
		//cout << " ( " << s[idx][at][i] << ", " << ss[idx][at][i+1] << ")";
	//}
	//cout << '\n';
}

PI query ( int idx, int at, int i, int j, int l, int r, int k )
{
	if(i == j)
		return mp(_x[idx][s[idx][at][0]-1], s[idx][at][0]);
	
	int mid = (i+j)/2;
	int s = search(idx, 2*at, l-1, 0, mid-i), t = search(idx, 2*at, r, 0, mid-i);
	////cout << idx << ' ' << i << ' ' << j << ' ' << s << ' ' << t << ' ' << k << " !!\n";
	////cout << ss[idx][2*at][t+1] << ' ' << ss[idx][2*at][s+1] << '\n';
	if( k <= t-s )
		return query(idx, at*2, i, mid, l, r, k);
	tmp = query(idx, at*2+1, mid+1, j, l, r, k-t+s);
	return mp(ss[idx][2*at][t+1]-ss[idx][2*at][s+1]+tmp.x, tmp.y);
}

int main ()
{
	cin >> N >> Q;
	
	x[0] = VPI(N), x[1] = VPI(N);
	_x[0] = VD(N), _x[1] = VD(N);
	S[0] = VD(N+1,0), S[1] = VD(N+1,0);
	for (int i = 0; i < N; x[0][i].y = ++i)
		cin >> x[0][i].x;
	for (int i = 0; i < N; x[1][i].y = ++i)
		cin >> x[1][i].x;
	
	for (int i = 0; i < N; i += 1)
	{
		_a = x[0][i].x + x[1][i].x;
		_b = x[0][i].x - x[1][i].x;
		x[0][i].x = _a;
		x[1][i].x = _b;
		_x[0][i] = x[0][i].x;
		_x[1][i] = x[1][i].x;
		S[0][i+1] = S[0][i]+_x[0][i];
		S[1][i+1] = S[1][i]+_x[1][i];
		//cout << i << ' ' << x[0][i].x << ' ' << x[0][i].y << ' ' << x[1][i].x << ' ' << x[1][i].y << '\n';
	}
	
	sort(all(x[0]));
	sort(all(x[1]));
	
	build(0, 1, 1, N);
	build(1, 1, 1, N);
	
	for (int q = 0; q < Q; q += 1)
	{
		cin >> a >> b;
		u[0] = query(0,1,1,N,a,b,1+(b-a)/2), u[1] = query(1,1,1,N,a,b,1+(b-a)/2);
		A = (S[0][b]-S[0][a-1]+S[1][b]-S[1][a-1]-2*u[0].x-2*u[1].x);
//		cout << query(0,1,1,N,a,b,(b-a+1)/2) << ' ' << query(1,1,1,N,a,b,(b-a+1)/2) << '\n';
//	cout << u[0].x << ' ' << u[0].y << ' ' << u[1].x << ' ' << u[1].y << '\n';
		if((b-a)%2 == 0)
			A += _x[0][u[0].y-1]+_x[1][u[1].y-1];
		printf("%.6lf\n",A/2.0);
	}
	
	return 0;
}








----------
====================
----------
MATHEMATICS.195
advanced
----------
PROBLEM STATEMENT:
You are given a sequence whose [expression] term is 
[expression]
You have to evaluate the series
[expression]
Find [expression].

Input Format  

The first line of input contains [expression], the number of test cases. 
Each test case consists of three lines, each containing [expression] respectively.  

Output Format 

For each test case, print the required answer in a line.  

Constraints  

[expression] 
[expression] 
[expression] 
[expression] 
[expression]  

Sample Input  

2
2
5
2
3
4
3


Sample Output  

1146
5988


Explanation  

Case 1: [expression] 
Case 2: [expression]  
----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <bitset>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt(): x(0) { }
	ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }
	ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }
	int get() const { return (int)x; }
	
	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }
	
	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
	
	ModInt inverse() const {
		long long a = x, b = MOD, u = 1, v = 0;
		while(b) {
			long long t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		return ModInt(u);
	}
	
	bool operator==(ModInt that) const { return x == that.x; }
	bool operator!=(ModInt that) const { return x != that.x; }
	ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }
};
typedef ModInt<1000000007> mint;

template<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {
	ModInt<MOD> r = 1;
	while(k) {
		if(k & 1) r *= a;
		a *= a;
		k >>= 1;
	}
	return r;
}

struct Polynomial {
	typedef mint Coef; typedef Coef Val;
	vector<Coef> coef;	//... + coef[2] x^2 + coef[1] x + coef[0]
	Polynomial() {}
	explicit Polynomial(int n): coef(n) {}
	static Polynomial One() {
		Polynomial r(1);
		r.coef[0] = 1;
		return r;
	}
	bool iszero() const { return coef.empty(); }
	int degree1() const { return coef.size(); }	//degree + 1
	int resize(int d) { if(degree1() < d) coef.resize(d); return d; }
	const Coef operator[](int i) const {
		return i >= degree1() ? Coef() : coef[i];
	}
	void canonicalize() {
		int i = coef.size();
		while(i > 0 && coef[i-1] == Coef()) i --;
		coef.resize(i);
	}
	Val evalute(Val x) const {
		int d = degree1();
		Val t = 0, y = 1;
		rep(i, d) {
			t += y * coef[i];
			y *= x;
		}
		return t;
	}
	Polynomial &operator+=(const Polynomial &that) {
		int d = resize(that.degree1());
		for(int i = 0; i < d; i ++) coef[i] += that[i];
		canonicalize();
		return *this;
	}
	Polynomial operator+(const Polynomial &that) const { return Polynomial(*this) += that; }
	Polynomial &operator-=(const Polynomial &that) {
		int d = resize(that.degree1());
		for(int i = 0; i < d; i ++) coef[i] -= that[i];
		canonicalize();
		return *this;
	}
	Polynomial operator-(const Polynomial &that) const { return Polynomial(*this) -= that; }
	//naive
	Polynomial operator*(const Polynomial &that) const {
		if(iszero() || that.iszero()) return Polynomial();
		int x = degree1(), y = that.degree1(), d = x + y - 1;
		Polynomial res(d);
		rep(i, x) rep(j, y)
			res.coef[i+j] += coef[i] * that.coef[j];
		res.canonicalize();
		return res;
	}
	//long division
	pair<Polynomial, Polynomial> divmod(const Polynomial &that) const {
		int x = degree1() - 1, y = that.degree1() - 1;
		int d = max(0, x - y);
		Polynomial q(d + 1), r = *this;
		for(int i = x; i >= y; i --) {
			Coef t = r.coef[i] / that.coef[y];
			q.coef[i - y] = t;
			r.coef[i] = 0;
			if(t == 0) continue;
			for(int j = 0; j < y; j ++)
				r.coef[i - y + j] -= t * that.coef[j];
		}
		q.canonicalize(); r.canonicalize();
		return make_pair(q, r);
	}
	Polynomial operator/(const Polynomial &that) const { return divmod(that).first; }
	Polynomial operator%(const Polynomial &that) const { return divmod(that).second; }

	static Polynomial interpolate(const vector<pair<Coef,Val> > &points) {
		int n = points.size();
		vector<Coef> dp(n+1);
		dp[0] = 1;
		rep(i, n) for(int j = i; j >= 0; j --) {
			dp[j+1] += dp[j];
			dp[j] *= -points[i].first;
		}
		Polynomial r(n);
		rep(i, n) {
			Coef den = 1;
			rep(j, n) if(i != j)
				den *= points[i].first - points[j].first;
			Coef iden = (Coef)1 / den, minus = 0;
			for(int j = n-1; j >= 0; j --) {
				minus = dp[j+1] + minus * points[i].first;
				r.coef[j] += minus * iden * points[i].second;
			}
		}
		r.canonicalize();
		return r;
	}
};


pair<Polynomial,Polynomial> polynomialCoefficientPowerSeries(const Polynomial &poly) {
	int deg = poly.degree1();
	Polynomial resnum, resden(1), den(2);
	resden.coef[0] = 1; den.coef[0] = 1; den.coef[1] = -1;
	vector<Polynomial::Val> A(deg);
	A[0] = 1;
	for(int i = 0; i < deg; i ++) {
		for(int j = i; j > 0; j --)
			A[j] = A[j-1] * (i-j) + A[j] * (j+1);
		Polynomial p(i+2);
		for(int j = 0; j <= i; j ++)
			p.coef[j] = poly.coef[i] * A[j];
		resnum = resnum * den + p;
		resden = resden * den;
	}
	return make_pair(resnum, resden);
}

pair<Polynomial,Polynomial> polynomialCoefficientPowerSeries2(const Polynomial &poly) {
	Polynomial p = poly, q(1), den(2), x(2);
	if(p.degree1() >= 1) p.coef[0] = 0;
	pair<Polynomial,Polynomial> r = polynomialCoefficientPowerSeries(p);
	q.coef[0] = poly.coef[0];
	pair<Polynomial,Polynomial> u = polynomialCoefficientPowerSeries(q);
	den.coef[0] = 1; den.coef[1] = -1; x.coef[1] = 1;
	for(int i = 2; i < r.second.degree1(); i ++)
		u.first = u.first * den;
	r.first = r.first * x + u.first;
	return r;
}

Polynomial::Val polynomialCoefficientPowerSeriesEvalue(const Polynomial &p, Polynomial::Val x) {
	pair<Polynomial,Polynomial> t = polynomialCoefficientPowerSeries2(p);
	return t.first.evalute(x) / t.second.evalute(x);
}

const int Combination_N = 1001;
mint C[Combination_N+1][Combination_N+1];
mint powersum(mint n, int m) {
	if(m == 0) return n;
	vector<mint> mem(m+1);
	mem[0] = n;
	for(int k = 1; k <= m; k ++){
		mint sum = ((n+1) ^ (k+1)) - 1;
		for(int i = 0; i < k; i ++)
			sum -= mem[i] * C[k+1][i];
		mem[k] = sum / mint(k+1);
	}
	return mem[m];
}

int main() {
	for(int i = 0; i <= Combination_N; i ++) {
		C[i][0] = 1;
		for(int j = 1; j <= i; j ++)
			C[i][j] = C[i-1][j-1] + C[i-1][j];
	}
	int T;
	scanf("%d", &T);
	rep(ii, T) {
		int K; ll N, R;
		scanf("%d%lld%lld", &K, &N, &R);
		if(mint(R) == 1) {	//???R=1????????(????????)
			mint ans = powersum(N, K);
			printf("%d\n", ans.get());
			continue;
		}
		//sum_(n=0)^\Infty n^K R^n
		Polynomial p(K+1);
		p.coef[K] = 1;
		mint t = polynomialCoefficientPowerSeriesEvalue(p, R);
		//R^(N+1) sum_(n=0)^\Infty (n+(N+1))^K R^n
		//r = (x + (N+1))^K = sum_k C(K,k) x^k (N+1)^(K-k)
		Polynomial r(K+1);
		rer(k, 0, K) r.coef[k] = C[K][k] * (mint(N+1) ^ (K-k));
		mint u = (mint(R) ^ (N+1)) * polynomialCoefficientPowerSeriesEvalue(r, R);
		mint ans = t - u;
		if(K == 0) ans -= 1;	//0^0???????
//		cerr << t.get() << " - " << u.get() << " = " << ans.get() << endl;
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.196
expert
----------
PROBLEM STATEMENT:
Jack Skellington kidnapped Sandy Claws so he can replace him on Christmas! The monsters of Halloween Town are helping Jack make toys for all the children.  

One of these toys is a special kind of gyroscopic exercise tool. It consists of [expression] balls that levitate around the center of the toy. To play with it, a child chooses some axis passing through the center and begins to rotate all the balls around it simultaneously. The effort needed to perform the exercise is proportional to the sum of squared distances from every ball to the chosen axis. If the needed effort for this axis is not less than for any other one, we call it The Axis of Awesome. Now Jack wants to improve these gyroscopic toys by adding zero or more balls to each toy so that every possible axis of play was an Axis of Awesome.

You are given the blueprints for [expression] coordinates denoting the locations of the toy's balls. For each toy, find the the minimum number of balls Jack must add so that any possible axis would be called Axis of Awesome. If no amount of additional balls makes this possible, print -1 instead.

Note: The center of each toy is always located at point [expression].
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.197
hard
----------
PROBLEM STATEMENT:
Emma is really fond of integers and loves playing with them. Her friends were jealous, and to test her, one of them gave her a problem. 
Emma is given a list [expression] elements. 
Emma has got stuck in this problem and you being her best friend have decided to help her write a code to solve it. Since the answers can be very large, print the answers modulo [expression].

Input Format 
First line has an integer [expression].

Output Format 
For each of the queries, print the corresponding answer in a new line.  

NOTE Sublist here refers to selecting [expression] ways to do that, it doesn't matter if two elements are same.

Constraints 
[expression] 
[expression] 
[expression] 
[expression]  

Sample Input #00  

3
1 2 3
2
1
2


Sample Output #00  

6
11


Sample Input #01  

3
1 2 2
1
2


Sample Output #01  

8


Explanation  

Sample #00: 
For [expression]. 
For [expression].

Sample #01: 
For [expression].
----------
TOP SOLUTION:
----------
/////////////////////////////////////
// Author: Andrés Herrera Poyatos
/////////////////////////////////////

# include <iostream>
# include <cmath>
# include <climits>
# include <cstdio>
# include <sstream>
# include <algorithm>
# include <assert.h>
# include <complex>
# include <set>
# include <vector>

using namespace std;

#define ll long long int

ll i, j, k, N, Q, tmp1, tmp;
const ll MAX = 30000;
const ll MOD = 100003;

ll A[MAX];
ll sol[MAX];

int main(){
    cin >> N;
    for (i=0; i<N; i++){
        cin >> A[i];
    }
    sol[0] = A[0];
    for (i= 1; i < N; i++){
        tmp = sol[0];
        sol[0] = (sol[0]+A[i])%MOD;
        for (j = 1; j <= i; j++){
            tmp1 = sol[j];
            sol[j] = (sol[j]+(tmp*A[i])%MOD)%MOD;
            tmp = tmp1;
        }
    }

    cin >> Q;

    for (i=0; i<Q; i++){
        cin >> k;
        cout << sol[k-1] << endl;
    }
    
    return 0;
}
----------
====================
----------
MATHEMATICS.198
advanced
----------
PROBLEM STATEMENT:
Julia found a series, [expression], defined as:
[expression]

For some integer [expression]):
[expression]

She realized that the values of [expression].

Next, she defines [expression]: 
[expression]
[expression]

She then finds the following interesting property of [expression]:
[expression]

where [expression] are integers such that:


[expression]
[expression]
[expression]


Julia wants you to answer [expression] queries in the following forms:


1 l r: Using [expression] where:

[expression].
[expression].
[expression].
2 p u v: Find the value of [expression]:
[expression]

----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }


template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }

	ModInt inverse() const {
		signed a = x, b = MOD, u = 1, v = 0;
		while(b) {
			signed t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		if(u < 0) u += Mod;
		ModInt res; res.x = (unsigned)u;
		return res;
	}

	bool operator==(ModInt that) const { return x == that.x; }
	bool operator!=(ModInt that) const { return x != that.x; }
	ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }
};
template<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {
	ModInt<MOD> r = 1;
	while(k) {
		if(k & 1) r *= a;
		a *= a;
		k >>= 1;
	}
	return r;
}
typedef ModInt<1000000007> mint;
typedef ModInt<1000000006> mintphi;

int main() {
	int a_; int b_; int q;
	while(~scanf("%d%d%d", &a_, &b_, &q)) {
		mint a = a_, b = b_;
		const int N = 1001, N2 = 1000001;
		vector<mint> G(N2 + 1);
		G[1] = 1;
		rer(n, 2, N2)
			G[n].x = ((ll)G[n - 1].x * a_ + (ll)G[n - 2].x * b_) % mint::Mod;
		vector<pair<mint,int>> fact(N2 + 1);
		fact[0] = make_pair(mint(1), 0);
		rer(n, 1, N2) {
			fact[n] = fact[n - 1];
			if(G[n].x == 0)
				++ fact[n].second;
			else
				fact[n].first *= G[n];
		}
		vector<vector<mint>> table(N + 1, vector<mint>(N + 1));
		rer(n, 0, N) {
			rer(k, 1, n - 1) {
				mint x;
				x += table[n - 1][k - 1] * G[n - k - 1] * b;
				x += table[n - 1][k] * G[k + 1];
				table[n][k] = x;
			}
			table[n][0] = table[n][n] = 1;
		}
		vector<mint> bpowcx2(N + 1);
		rer(x, 0, N) {
			bpowcx2[x] = b ^ (x * (x - 1) / 2);
		}
		vector<mintphi> bpowcx2sum(N2 + 1);
		bpowcx2sum[0] = 1;
		{
			mintphi bb = b_, bpow = 1, bpowcx2 = 1;
			rer(x, 1, N2) {
				bpowcx2 *= bpow;
				bpow *= bb;
				bpowcx2sum[x] = bpowcx2sum[x - 1] * bpowcx2;
			}
		}
		rer(n, 0, N) rer(k, 0, n)
			table[n][k] *= bpowcx2[n - k];
		vector<vector<int>> sign(N + 1, vector<int>(N + 1));
		rer(n, 0, N) rer(k, 0, n)
			sign[n][k] = (n - k + 1) % 4 < 2 ? 1 : -1;
		vector<int> count1(N + 1), count2(N + 1);
		rer(n, 1, N) {
			mint S1, S2;
			rer(k, 0, n)
				(sign[n][k] > 0 ? S1 : S2) += table[n][k];
			count1[n] = count1[n - 1] + (S1.get() > S2.get() ? 1 : 0);
			count2[n] = count2[n - 1] + (S1.get() < S2.get() ? 1 : 0);
		}
		for(int ii = 0; ii < q; ++ ii) {
			int ty;
			scanf("%d", &ty);
			if(ty == 1) {
				int l; int r;
				scanf("%d%d", &l, &r), ++ r;
				int ans1 = count1[r] - count1[l];
				int ans2 = count2[r] - count2[l];
				int ans3 = (r - l) - ans1 - ans2;
				printf("%d %d %d\n", ans1, ans2, ans3);
			} else if(ty == 2) {
				int p; int u; int v;
				scanf("%d%d%d", &p, &u, &v), ++ v;
				mint prod = fact[v - 1].first / fact[u - 1].first;
				if(fact[v - 1].second - fact[u - 1].second > 0)
					prod = mint();
				//z_i = i * 2 - (p + 2);
				mintphi w = bpowcx2sum[p + 1];
				int t = v - u;
				ll sumz = 0;
				sumz += ((ll)t * (t - 1) / 2 + (ll)u * t) * 2;
				sumz -= (ll)t * (p + 2);
				mintphi phi = abs(sumz);
				mint S = prod ^ (mintphi::Mod + (w + phi).get());
				printf("%d\n", S.get());
			} else abort();
		}
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.199
medium
----------
PROBLEM STATEMENT:
Let N be a positive integer. Let's define a mapping f on the set
of permutations of integers from 1 to N, inclusive.
 Let x = (x[1], ..., x[N]) be a permutation of integers from 1
to N, inclusive.
 We define the permutation y = (y[1], ..., y[N]) as follows.


y[1] = 1.
For i  1 we consider number z = x[y[i-1]].
If z does not equal any of the numbers y[1], ...,
y[i-1] then we set y[i] = z.
Otherwise y[i] is defined as the smallest integer from 1
to N (inclusive) that does not equal any of the numbers
y[1], ..., y[i-1].


We consider permutation y as an image of x when mapping f is
applied to x. That is, we set f(x) = y.

Denote by g(y) the number of solutions of the equation f(x) = y.
That is, g(y) is the number of permutations x of integers from
1 to N, inclusive, such that f(x) = y. 

Challenge 
For the given non-negative integers L and R, find the number of
permutations y of integers from 1 to N, inclusive, such that
L ≤ g(y) ≤ R. Since this number can be quite large output it modulo (109 + 7).

Input Format 
The first line contains an integer T denoting the
number of test cases. T test cases follow. 
Each test case consists of one line which contains three space-separated integers N, L and R.

Output Format 
For each test case, output a single line containing P mod (109+7), where P is the required number of permutations.

Constraints

1 ≤ T ≤ 1000 
1 ≤ N ≤ 200,000 
0 ≤ L, R ≤ 1018

Sample Input  

4  
2 0 0  
3 2 2  
3 0 10  
10 2 1  


Sample Output  

1  
1  
6  
0  


Explanation

Example case 1. The only permutation y for which equation f(x)
= y has no solutions is y = (2, 1).

Example case 2. The only permutation y for which equation f(x)
= y has 2 solutions is y = (1, 3, 2).
 The solutions are x = (3, 2, 1) and x = (3, 1, 2).

Example case 3. For all 6 permutations y of numbers {1, 2,
3} we have 0 ≤ g(y) ≤ 10.

Example case 4. Be careful, L could be greater than R. In
this case the answer is zero.
----------
TOP SOLUTION:
----------
#include <vector> 
#include <list> 
#include <map> 
#include <set> 
#include <queue>
#include <stack> 
#include <bitset> 
#include <algorithm> 
#include <numeric> 
#include <utility> 
#include <sstream> 
#include <iostream> 
#include <iomanip> 
#include <cstdio> 
#include <cmath> 
#include <cstdlib> 
#include <ctime> 
#include <cstring> 

using namespace std; 

typedef long long ll; 
typedef pair<int, int> pii;

#define INF 1000000000
#define pb push_back 
#define itr iterator 
#define sz size() 
#define mp make_pair

long long p[200011][60];
long long fac[200011];
const int mod = 1000000007;
int n, T;
long long L, R;

int main() {
	p[0][0] = 1;
	for (int i = 1; i <= 200000; i++) {
		for (int k = 1; k <= min(i,59); k++) {
			p[i][k] = ((i-1)*p[i-1][k] + p[i-1][k-1]) % mod;
		}
	}	

	fac[0]=fac[1]=1;
	for (int i = 2; i <= 200000; i++) {
		fac[i] = (i*fac[i-1])%mod;
	}

	for (scanf("%d", &T); T; T--) {
		scanf("%d %lld %lld", &n, &L, &R);
		long long ans = 0;

		if (L <= 0 && 0 <= R) {
			ans = (((ans + fac[n] - fac[n-1]) % mod) + mod) % mod;
		}

		long long pot = 1;
		int i = 0;
		while (pot < L) {
			pot <<= 1;
			i++;
		}
		while (pot <= R) {
			ans = (ans + p[n-1][i]) % mod;
			pot <<= 1;
			i++;
		}

		printf("%lld\n", ans);
	}

}
----------
====================
----------
MATHEMATICS.200
expert
----------
PROBLEM STATEMENT:
Sevenkplus was interested in contributing a challenge to hackerrank and he came up with this problem. 

You are given a linear congruence system with n variables and m equations: 
a11 x1 + a12 x2 + ... + a1n xn = b1 (mod p) 
a21 x1 + a22 x2 + ... + a2n xn = b2 (mod p) 
... 
am1 x1 + am2 x2 + ... + amn xn = bm (mod p)   

where, 

p is a prime number 
0 ij 
0 i 
0 i 

Given integers n, m, p, a, b, count the number of solutions to this equation. Since the output can be large, please output your answer modulo 10^9+7.

He writes the standard solution and a test data generator without difficulty, and generates some test data. 
However, when he attempts to remove hidden folders from the problem folder before uploading, he accidentally deletes the input file. 
Luckily, the output file remains and he still remembers some features of the input. He remembers n, m, p and that w entries of a are zero. However, he cannot recall more about the input. 

He wants to count how many possible inputs are there that will result in the desired output S (number of solutions to the equation system) output modulo 10^9+7. Can you help Sevenkplus?

Input Format 
The first line contains an integer T. T testcases follow. 
For each test case, the first line contains five numbers, m, n, p, S, w. separated by a single space. 
w lines follow. Each line contains two numbers x, y, which indicates that axy=0.

Output Format 
For each test case, output one line in the format Case #t: ans, where t is the case number (starting from 1), and ans is the answer. 

Constraints 
1 ≤ T ≤ 33 
1 
p 
0 
w 
1 
1 
In any test case, one pair (x, y) will not occur more than once.

Sample Input

6
2 2 2 0 1
1 1
2 2 2 1 1
1 1
2 2 2 2 1
1 1
2 2 2 3 1
1 1
2 2 2 4 1
1 1
488 629 183156769 422223791 10
350 205
236 164
355 8
3 467
355 164
350 467
3 479
72 600
17 525
223 370


Sample Output

Case #1: 13
Case #2: 8
Case #3: 10
Case #4: 0
Case #5: 1
Case #6: 225166925


Explanation  

For test case 1, the 13 possible equations are:

a11 a12 b1  a21 a22 b2
0   0   0   0   0   1
0   0   1   0   0   0
0   0   1   0   0   1
0   0   1   0   1   0
0   0   1   0   1   1
0   0   1   1   0   0
0   0   1   1   0   1
0   0   1   1   1   0
0   0   1   1   1   1
0   1   0   0   0   1
0   1   0   0   1   1
0   1   1   0   0   1
0   1   1   0   1   0


Timelimits 
Timelimits for this challenge is given here
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cassert>
#include <ctime>
#include <set>
#include <map>
#include <vector>
#include <string>
#include <sstream>
#include <numeric>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long ll;
typedef pair<int, int> PII;
typedef pair<PII, int> PI3;
typedef pair<PI3, vector<int> > PIV;

#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define mp3(x, y, z) mp(mp(x, y), z)
#define fi3 fi.fi
#define se3 fi.se
#define th3 se
#define pct __builtin_popcount
#define ctz __builtin_ctz

#define P 1000000007
#define N 1010

int n, m, p, S0, wn;
vector<PII> w;
int px[N], py[N], qx[N], qy[N];
int sx[N], sy[N];
int p0[N]; int mn, mm;

bool cmpx(int x, int y) { return sx[x] > sx[y]; }
bool cmpy(int x, int y) { return sy[x] > sy[y]; }

int F0[2010][1010];
map<PIV, int> F1;

int rem(int x, int w) {
    return (x >> w+1 << w) + (x & ((1 << w)-1));
}

int rem(int x, int w1, int w2) {
    if (w1 > w2) swap(w1, w2);
    return rem(rem(x, w1), w2-1);
}

int gg(int n, int m, vector<int> a, int r) {
    if (r < 0 || r > n || r > m) return 0;
    if (r == 0 || n == 0 || m == 0) return 1;

    PIV wp = mp(mp3(n, m, r), a);
    if (F1.find(wp) != F1.end()) return F1[wp];
    int &S = F1[wp];

    for (int j = 2; j >= 0; j --) {
        for (int i = n-1; i >= 0; i --)
            if (pct(a[i]) <= j || pct(a[i]) >= m-j) {
                swap(a[i], a[n-1]);
                break;
            }
    }

    int pc = pct(a[n-1]);
    if (pc == m) {
        vector<int> a1;
        for (int i = 0; i < n-1; i ++) a1.pb(a[i]);
        S = gg(n-1, m, a1, r);
    } else
        if (pc == 0) {
            vector<int> a1;
            for (int i = 0; i < n-1; i ++) a1.pb(a[i]);
            int S1 = gg(n-1, m, a1, r);
            int S2 = gg(n-1, m, a1, r-1);
            (S += (ll)p0[r]*S1%P) %= P;
            (S += (ll)(p0[m]-p0[r-1]+P)%P*S2%P) %= P;
        } else
            if (pc == m-1) {
                vector<int> a1;
                for (int i = 0; i < n-1; i ++) a1.pb(a[i]);
                (S += gg(n-1, m, a1, r)) %= P;
                int inva = (1 << m) - 1 - a[n-1];
                int w = ctz(inva), s = 0;
                for (int i = 0; i < n-1; i ++) {
                    if (~(a1[i] >> w)&1) s ++;
                    a1[i] = rem(a1[i], w);
                }
                (S += (ll)(p-1)*p0[s]%P*gg(n-1, m-1, a1, r-1)%P) %= P;
            } else
                if (pc == 1) {
                    vector<int> a1, a2;
                    for (int i = 0; i < n-1; i ++) a1.pb(a[i]);
                    int w = ctz(a[n-1]);
                    for (int i = 0; i < n-1; i ++)
                        a2.pb(rem(a[i], w));
                    int S1 = gg(n-1, m-1, a2, r);
                    int S2 = gg(n-1, m-1, a2, r-1);
                    int S3 = (gg(n-1, m, a1, r)-S1+P)%P;
                    int S4 = (gg(n-1, m, a1, r-1)-S2+P)%P;
                    (S += (ll)p0[r]*S1%P) %= P;
                    (S += (ll)(p0[m-1]-p0[r-1]+P)%P*S2%P) %= P;
                    (S += (ll)p0[r-1]*S3%P) %= P;
                    if (r >= 2) (S += (ll)(p0[m-1]-p0[r-2]+P)%P*S4%P) %= P;
                } else
                    if (pc == m-2) {
                        vector<int> a1;
                        for (int i = 0; i < n-1; i ++) a1.pb(a[i]);
                        (S += gg(n-1, m, a1, r)) %= P;
                        int inva = (1 << m) - 1 - a[n-1];
                        int w1 = ctz(inva), w2 = ctz(inva^(1 << w1));
                        int s1 = 0, s2 = 0;
                        for (int i = 0; i < n-1; i ++) {
                            if (~(a[i] >> w1) & 1) s1 ++;
                            if (~(a[i] >> w2) & 1) s2 ++;
                        }

                        for (int i = 0; i < n-1; i ++)
                            a1[i] = rem(a[i], w1);
                        (S += (ll)(p-1)*p0[s1]%P*gg(n-1, m-1, a1, r-1)%P) %= P;
                        for (int i = 0; i < n-1; i ++)
                            a1[i] = rem(a[i], w2);
                        (S += (ll)(p-1)*p0[s2]%P*gg(n-1, m-1, a1, r-1)%P) %= P;

                        int s3 = 0;
                        vector<int> a2;
                        for (int i = 0; i < n-1; i ++) {
                            if ((~(a[i] >> w1) & 1) && (~(a[i] >> w2) &1)) s3 ++;
                            int x = a[i];
                            if (~(x >> w1)&1)
                                if ((x >> w2) & 1) x ^= (1 << w2);
                            a2.pb(rem(x, w1));
                        }
                        (S += (ll)(p-1)*(p-1)%P*p0[s3]%P*gg(n-1, m-1, a2, r-1)%P) %= P;
                    } else
                        if (pc == 2) {
                            int w1 = ctz(a[n-1]), w2 = ctz(a[n-1] ^ (1 << w1));
                            vector<int> a0, a1, a2, a3, a4;
                            for (int i = 0; i < n-1; i ++)
                                a0.pb(rem(a[i], w1, w2));
                            int S1 = gg(n-1, m-2, a0, r);
                            int S2 = gg(n-1, m-2, a0, r-1);
                            (S += (ll)p0[r]*S1%P) %= P;
                            (S += (ll)(p0[m-2]-p0[r-1]+P)%P*S2%P) %= P;

                            for (int i = 0; i < n-1; i ++) {
                                a1.pb(rem(a[i], w1));
                                a2.pb(rem(a[i], w2));
                            }
                            int S3 = (gg(n-1, m-1, a1, r)-S1+P)%P;
                            int S4 = (gg(n-1, m-1, a1, r-1)-S2+P)%P;
                            int S5 = (gg(n-1, m-1, a2, r)-S1+P)%P;
                            int S6 = (gg(n-1, m-1, a2, r-1)-S2+P)%P;
                            (S += (ll)p0[r-1]*S3%P) %= P;
                            if (r >= 2) (S += (ll)(p0[m-2]-p0[r-2]+P)%P*S4%P) %= P;
                            (S += (ll)p0[r-1]*S5%P) %= P;
                            if (r >= 2) (S += (ll)(p0[m-2]-p0[r-2]+P)%P*S6%P) %= P;

                            for (int i = 0; i < n-1; i ++) {
                                int x = a[i];
                                if ((x >> w1) &1) x |= (1 << w2);
                                a3.pb(rem(x, w1));
                            }
                            int S7 = (ll)(p-1)*(gg(n-1, m-1, a3, r)-S1+P)%P;
                            int S8 = (ll)(p-1)*(gg(n-1, m-1, a3, r-1)-S2+P)%P;
                            (S += (ll)p0[r-1]*S7%P) %= P;
                            if (r >= 2)(S += (ll)(p0[m-2]-p0[r-2]+P)%P*S8%P) %= P;

                            for (int i = 0; i < n-1; i ++) a4.pb(a[i]);
                            int S9 = (gg(n-1, m, a4, r)-((ll)S1+S3+S5+S7)%P+P)%P;
                            int S10 = (gg(n-1, m, a4, r-1)-((ll)S2+S4+S6+S8)%P+P)%P;
                            if (r >= 2) (S += (ll)p0[r-2]*S9%P) %= P;
                            if (r >= 3) (S += (ll)(p0[m-2]-p0[r-3]+P)%P*S10%P) %= P;
                        } else {
                            vector<int> b;
                            for (int i = 0; i < m; i ++) b.pb(0);
                            for (int i = 0; i < n; i ++)
                                for (int j = 0; j < m; j ++)
                                    if ((a[i] >> j)&1) b[j] |= (1 << i);
                            S = gg(m, n, b, r);
                        }
    return S;
}

int ff(int n, int m, int r) {
    if (r < 0 || r > n || r > m) return 0;
    if (r == 0 || n == 0 || m == 0) return 1;
    if (F0[n+m][r] != -1) return F0[n+m][r];
    int &S = F0[n+m][r] = 0;
    if (n > mn) {
        (S += (ll)p0[r]*ff(n-1, m, r)%P) %= P;
        (S += (ll)(p0[m]-p0[r-1]+P)%P*ff(n-1, m, r-1)%P) %= P;
    } else
        if (m > mm) {
            (S += (ll)p0[r]*ff(n, m-1, r)%P) %= P;
            (S += (ll)(p0[n]-p0[r-1]+P)%P*ff(n, m-1, r-1)%P) %= P;
        } else {
            vector<int> a;
            for (int i = 0; i < n; i ++) a.pb(0);
            for (int i = 0; i < wn; i ++)
                a[w[i].fi] |= (1 << w[i].se);
            S = gg(n, m, a, r);
        }
    return S;
}

void solve() {
    static int _ = 0; _ ++;
    memset(F0, -1, sizeof F0);
    F1.clear();

    p0[0] = 1;
    for (int i = 1; i < N; i ++)
        p0[i] = (ll)p0[i-1]*p%P;

    memset(sx, 0, sizeof sx);
    memset(sy, 0, sizeof sy);
    w.clear();
    for (int i = 0; i < wn; i ++) {
        int x, y;
        scanf("%d%d", &x, &y);
        --x, --y;
        w.pb(mp(x, y));
        sx[x] ++; sy[y] ++;
    }

    for (int i = 0; i < n; i ++) px[i] = i;
    for (int i = 0; i < m; i ++) py[i] = i;
    sort(px, px+n, cmpx);
    sort(py, py+m, cmpy);

    for (int i = 0; i < n; i ++) qx[px[i]] = i;
    for (int i = 0; i < m; i ++) qy[py[i]] = i;
    for (int i = 0; i < wn; i ++)
        w[i] = mp(qx[w[i].fi], qy[w[i].se]);
    for (int i = 0; i < wn; i ++) {
        mn = max(mn, w[i].fi + 1);
        mm = max(mm, w[i].se + 1);
    }

    int S = 0;
    for (int i = 0; i <= min(n, m); i ++)
        if (S0 == 0) {
            (S += (ll)(p0[n]-p0[i]+P)%P*ff(n, m, i)%P) %= P;
        } else
            if (p0[m-i] == S0) {
                (S += (ll)p0[i]*ff(n, m, i)%P) %= P;
            }
    printf ("Case #%d: %d\n", _, S);
}

int main() {
    int _ = 0;
    int test;
    scanf("%d", &test);
    while (scanf("%d%d%d%d%d", &n, &m, &p, &S0, &wn) != EOF) {
        solve();
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.201
expert
----------
PROBLEM STATEMENT:
Little Tom loves to solve interesting math challenges. One day he bumped onto an interesting function called hRank. 
Given a positive integer k, hRank maps a non-negative integer x to another integer.

hRank(x) = 1 if 0 <= x < k
hRank(x) = hRank(x – k) + hRank(x / k) if x = k and k | x  (i.e., x modulo k = 0)
hRank(x) = hRank(x – 1) otherwise.


Because  x  and hRank(x) may be very large, Tom comes to you for help. Given k and x, can you calculate hRank(x)?

Input Format 
The input contains only one line with 2 space separated integers, k and x.

Output Format 
For each test case output the result in a single line.

Constraints 
2 
1 50  

Sample Input #00

2 1


Sample Output #00

1


Sample Input #01

3 9


Sample Output #01

5


Explanation

For the first sample input, when k = 2 and x = 1, the answer is 1 since hRank(x) = 1 as 1 
For the second sample input, when k = 3 and x = 9, we have 

hRank(9) = hRank(9-3) + hRank(9/3)  = hRank(6) + hRank(3) as 9  3 and 9 modulo 3 = 0. 
hRank(6) = hRank(6-3) + hRank(6/3) = hRank(3) + hRank(2) as 6  3 and 6 modulo 3 = 0. 
hRank(3) = hRank(3-3) + hRank(3/3)  = hRank(0) + hRank(1) as 3 =3 and 3 modulo 3 = 0. 
hRank(3) = hRank(0) + hRank(1)
hRank(3) = 1 + 1 = 2
hRank(6) = 2 + 1 = 3
hRank(9) = 3 + 2 = 5

----------
TOP SOLUTION:
----------
#include <cmath>
#include <vector>
#include <iostream>
typedef unsigned __int128 uint128_t;
typedef std::vector<uint64_t> uint64_vec;
uint64_t const prime = 9223372036854775783;
uint64_t const ten18 = 1000000000000000000;
uint64_t const ten19 = ten18 * 10;

class binomials
{
public:
	explicit binomials(size_t size)
	{
		values_.reserve((size + 1) * (size + 2) / 2);
		values_.push_back(1);
		for (size_t i = 0, j = 0; i < size; ++i, ++j)
		{
			values_.push_back(1);
			for (size_t k = 0; k < i; ++j, ++k)
			{
				values_.push_back(values_[j] + values_[j + 1]);
			}
			values_.push_back(1);
		}
	}
	uint64_t operator()(size_t upper, size_t lower) const
	{
		return values_[upper * (upper + 1) / 2 + lower];
	}
private:
	uint64_vec values_;
};

class big_number
{
public:
	explicit big_number(uint64_t base)
	: base_(base)
	{
	}
	uint64_t base() const
	{
		return base_;
	}
	uint64_vec const& digits() const
	{
		return digits_;
	}
	void swap_digits(uint64_vec& digits)
	{
		digits_.swap(digits);
	}
	double approx() const
	{
		double result = 0;
		for (auto i = digits_.size(); i; )
			result = result * base_ + digits_[--i];
		return result;
	}
	void strip_zeros()
	{
		while (digits_.size() && !digits_.back())
			digits_.pop_back();
	}
	void grow(uint64_t scale, uint64_t delta)
	{
		for (auto& digit : digits_)
		{
			auto value = uint128_t(digit)
				* scale + delta;
			digit = uint64_t(value % base_);
			delta = uint64_t(value / base_);
		}
		if (delta) digits_.push_back(delta);
	}
private:
	uint64_vec digits_;
	uint64_t base_;
};

std::istream& operator>>(
	std::istream& stream, big_number& value)
{
	std::istream::sentry _(stream);
	auto const base = value.base();
	if (base > 10) return stream;
	uint64_t power = base;
	while (power < ten18) power *= base;
	big_number compound(power);
	uint64_t scale = 1, delta = 0;
	for (;;)
	{
		auto digit = unsigned(stream.get() - '0');
		if (digit > 9) break;
		if (scale == ten18)
		{
			compound.grow(scale, delta);
			scale = 1, delta = 0;
		}
		scale = scale * 10;
		delta = delta * 10 + digit;
	}
	compound.grow(scale, delta);
	uint64_vec digits;
	for (auto digit : compound.digits())
	for (auto rest = power; rest /= base; digit /= base)
		digits.push_back(digit % base);
	value.swap_digits(digits);
	value.strip_zeros();
	return stream;
}

std::ostream& operator<<(
	std::ostream& stream, big_number const& value)
{
	uint64_t divisor = ten19;
	auto digits = value.digits();
	if (digits.empty() || value.base() != divisor)
		return stream << '0';
	while (divisor > digits.back()) divisor /= 10;
	for (auto index = digits.size(); index; divisor = ten18)
	for (auto digit = digits[--index]; divisor; divisor /= 10)
		stream.put(char('0' + ((digit / divisor) % 10)));
	return stream;
}

template <class T = void> class adic;
template <class L, class R> class adic_add;
template <class L, class R> class adic_sub;
template <class T> class adic_mul;
template <class T> class adic_div;
class small;

template <class L, class R>
class adic< adic_add<L, R> >
{
public:
	adic(adic<L> const& lhs, adic<R> const& rhs)
	: lhs_(lhs), rhs_(rhs), carry_(false)
	{
	}
	uint64_t generate()
	{
		auto lhs = lhs_.generate();
		auto rhs = rhs_.generate()
			+ (carry_ ? 1 : 0);
		auto result = lhs + rhs;
		if ((carry_ = (result >= prime)))
			result -= prime;
		return result;
	}
private:
	adic<L> lhs_;
	adic<R> rhs_;
	bool carry_;
};

template <class L, class R>
class adic< adic_sub<L, R> >
{
public:
	adic(adic<L> const& lhs, adic<R> const& rhs)
	: lhs_(lhs), rhs_(rhs), carry_(false)
	{
	}
	uint64_t generate()
	{
		auto lhs = lhs_.generate();
		auto rhs = rhs_.generate()
			+ (carry_ ? 1 : 0);
		auto result = lhs - rhs;
		if ((carry_ = (lhs < rhs)))
			result += prime;
		return result;
	}
private:
	adic<L> lhs_;
	adic<R> rhs_;
	bool carry_;
};

template <class T>
class adic< adic_mul<T> >
{
public:
	adic(adic<T> const& arg, uint64_t factor)
	: arg_(arg), factor_(factor), remain_(0)
	{
	}
	uint64_t generate()
	{
		auto result = uint128_t(factor_)
			* arg_.generate() + remain_;
		remain_ = uint64_t(result / prime);
		return uint64_t(result % prime);
	}
private:
	adic<T> arg_;
	uint64_t factor_;
	uint64_t remain_;
};

template <class T>
class adic< adic_div<T> >
{
public:
	adic(adic<T> const& arg, uint64_t factor)
	: arg_(arg), factor_(factor), modinv_(1), remain_(0)
	{
		uint64_t u = prime, v = factor, w = 0;
		while (uint64_t r = u % v)
		{
			uint64_t q = u / v + 1, t = w;
			u = v; v -= r; w = modinv_;
			modinv_ = modinv_ * q - t;
		}
	}
	uint64_t generate()
	{
		auto result = arg_.generate();
		if (result < remain_) result += prime;
		result = uint64_t((uint128_t(modinv_)
			* (result -  remain_)) % prime);
		remain_ = uint64_t((uint128_t(result)
			* factor_ + remain_) / prime);
		return result;
	}
private:
	adic<T> arg_;
	uint64_t factor_;
	uint64_t modinv_;
	uint64_t remain_;
};

template <>
class adic<void>
{
public:
	explicit adic(uint64_t* ptr)
	: ptr_(ptr)
	{
	}
	uint64_t generate()
	{
		return *(ptr_++);
	}
protected:
	uint64_t* ptr_;
};

template <>
class adic<small>
{
public:
	explicit adic(uint64_t value)
	: value_(value)
	{
	}
	uint64_t generate()
	{
		auto result = value_;
		value_ = 0;
		return result;
	}
private:
	uint64_t value_;
};

template <class L, class R>
inline adic< adic_add<L, R> > operator+(
	adic<L> const& lhs, adic<R> const& rhs)
{
	return adic< adic_add<L, R> >(lhs, rhs);
}

template <class L, class R>
inline adic< adic_sub<L, R> > operator-(
	adic<L> const& lhs, adic<R> const& rhs)
{
	return adic< adic_sub<L, R> >(lhs, rhs);
}

template <class T>
inline adic< adic_mul<T> > operator*(
	adic<T> const& lhs, uint64_t rhs)
{
	return adic< adic_mul<T> >(lhs, rhs);
}

template <class T>
inline adic< adic_mul<T> > operator*(
	uint64_t lhs, adic<T> const& rhs)
{
	return adic< adic_mul<T> >(rhs, lhs);
}

template <class T>
inline adic< adic_div<T> > operator/(
	adic<T> const& lhs, uint64_t rhs)
{
	return adic< adic_div<T> >(lhs, rhs);
}

class adic_number : public adic<>
{
public:
	adic_number(uint64_t* ptr, size_t length)
	: adic<>(ptr), length_(length)
	{
	}
	void store(big_number& value) const
	{
		for (size_t i = length_; i--; )
			value.grow(prime, ptr_[i]);
		value.strip_zeros();
	}
	template <class T>
	adic_number& operator=(adic<T> rhs)
	{
		for (size_t i = 0; i < length_; ++i)
			ptr_[i] = rhs.generate();
		return *this;
	}
private:
	size_t length_;
};

class adic_vector
{
public:
	adic_vector(size_t count, size_t length)
	: data_(count * length), length_(length)
	{
	}
	adic_number operator()(size_t index)
	{
		return adic_number(data_.data()
			+ index * length_, length_);
	}
private:
	uint64_vec data_;
	size_t length_;
};

int main()
{
	uint64_t base;
	std::cin >> base;
	big_number number(base);
	std::cin >> number;
	auto const& digits = number.digits();
	auto count = digits.size();
	if (count < 2)
	{
		std::cout << 1 << std::endl;
		return 0;
	}
	auto numlog = std::log(number.approx());
	size_t length = 1 + std::floor(numlog * numlog
		/ (std::log(prime) * std::log(base) * 2));
	binomials binom(count);
	auto digit = digits[1];
	adic_vector cffs(count, length);
	cffs(0) = adic<small>(1);
	adic_vector bufs(count, length);
	bufs(0) = adic<small>(digit + 1);
	for (size_t d = 2; d < count; ++d)
	{
		for (size_t k = 0; ++k < d;)
		{
			adic_number buf(bufs(k));
			buf = adic<small>(0);
			for (size_t n = d; --n >= k;)
			{
				adic_number cff(cffs(n - 1));
				cff = cff * base;
				buf = buf * digit + cff * binom(n, k);
			}
		}
		for (size_t k = d; k--;)
		{
			adic_number cff(cffs(k));
			cff = adic<small>(0);
			for (size_t n = d; --n > k;)
			{
				cff = cffs(n) * binom(n + 1, k) - cff;
			}
			cff = (bufs(k) + cff) / (k + 1);
		}
		digit = digits[d];
		adic_number buf(bufs(1));
		buf = adic<small>(0);
		for (size_t k = d; k--;)
			buf = buf * digit + cffs(k);
		bufs(0) = buf * digit + bufs(0);
	}
	big_number answer(ten19);
	bufs(0).store(answer);
	std::cout << answer << std::endl;
	return 0;
}

----------
====================
----------
MATHEMATICS.202
expert
----------
PROBLEM STATEMENT:
Today Konstantin learned about convergence of series. For instance, series 
[expression] 
[expression] converge, while 
[expression] diverges. See more at https://en.wikipedia.org/wiki/Convergent_series .

As you may note, some simple looking series can converge to quite complicated numbers, like [expression], etc. Konstantin noted this and decided to study only special case of rational functions sums, that is  

[expression] shows, sum of rational functions can be irrational. 

After some time, Konstantin decided to consider some very special case of rational functions when [expression] are distinct non-negative integers. Fortunately, it can be proven that in this case sum of the series above is rational number. Now Konstantin want you to calculate it.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <tuple>
#include <sstream>
#include <vector>
#include <cmath>
#include <ctime>
#include <bitset>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;
typedef pair<i64, i64> pi64;
typedef double ld;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

const int maxn = 5100, lim = 2 * maxn;
const i64 P = 1000000000 + 7;
i64 a[maxn], b[maxn], coef[maxn];
i64 d[lim];
int n;
    
i64 deg(i64 x, i64 d) {
    x %= P;
    d %= P - 1;
    if (d < 0) d += P - 1;
    i64 y = 1;
    while (d) {
        if (d % 2) (y *= x) %= P;
        (x *= x) %= P;
        d /= 2;
    }
    return y;
}

i64 evalb(i64 x) {
    i64 ans = 0;
    ford(i, n - 1) (ans = ans * x + b[i]) %= P;
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    cin >> n;
    forn(i, n) cin >> a[i];
    forn(i, n - 1) cin >> b[i];

    forn(i, n) {
        i64 z = evalb(P - a[i]);
        i64 y = 1;
        forn(j, n) {
            if (i != j) (y *= (P + a[j] - a[i])) %= P;
        }
        coef[i] = z * deg(y, -1) % P;
//        cerr << coef[i] << '\n';
    }

    forn(i, n) {
        for (int j = 1; a[i] + j < lim; ++j) (d[a[i] + j] += coef[i]) %= P;
    }

    i64 ans = 0;
    forn(i, lim) (ans += d[i] * deg(i, -1)) %= P;
    cout << ans << '\n';

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
MATHEMATICS.203
medium
----------
PROBLEM STATEMENT:
Welcome to Sevenkplus' perfect math class! In this class we will study an algebraic structure called magma. 

A magma is a nonempty set [expression].
Note that there are no restrictions on the binary operation. For example, we cannot assume that [expression] always holds.

There are many different types of magmas. Some are interesting, others are even more interesting. Studying specific types of magmas is an important part of mathematics.
Below we introduce the following types of magmas.

A quasigroup is a magma such that for all [expression].

A loop is a quasigroup such that there is a unique element [expression].

A semigroup is a magma such that for all [expression].

A monoid is a semigroup such that there is a uniqe element [expression].

A group is a monoid such that for all [expression].

An abelian group is a group such that for all [expression].

A rack is a magma such that (1) for all [expression].

A quandle is a rack such that for all [expression].

In this problem, you are given several magmas. You have to tell us what types they are.
----------
TOP SOLUTION:
----------

// Author : Vivek Hamirwasia (viv001)
#include<bits/stdc++.h>
using namespace std;

#define CLR(a,x) memset(a,x,sizeof(a))
#define PB push_back
#define INF 1000000000
#define MOD 1000000007
#define LET(x,a) __typeof(a) x(a)
#define MP make_pair
#define tr(container , it) for(LET(it,container.begin) ; it!=container.end() ; it++)
#define FOR(i,a,b) for(i=a;i<b;i++)
#define REP(i,a) FOR(i,0,a)
#define LLD long long
#define VI vector < int >
#define PII pair < int , int >
#define MAX 1000000000

//_____starts____here_______
int n, A[200][200];
int S;
int E;
bool quasigroup()
{
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		{
			int f = 0, g =0;
			for(int z=0;z<n;z++)
			{
				if(A[i][z]==j)
					f++;
				if(A[z][i]==j)
					g++;
			}
			if(!(f==1 && g==1))
				return false;
		}
	return true;
}

bool loop()
{
	int cnt = 0;
	for(int e=0;e<n;e++)
	{
		bool f = 1;
		for(int i=0;i<n;i++)
		{
			if(!(A[i][e]==A[e][i] && A[e][i]==i))
				 f=0;
		}
		if(f)
			cnt++;
	}
	if(cnt==1)
		return true;
	return false;
}

bool semigroup()
{
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			for(int k=0;k<n;k++)
			{
				int v1 = A[i][j];
				int v2 = A[j][k];	
				if(v1>=0 && v1<n && v2>=0 && v2<n)
				{
					if(A[v1][k]!=A[i][v2])
						return false;
				}
				else
					return false;
			}
	return true;
}

bool monoid()
{
	E = -1;
	for(int e=0;e<n;e++)
	{
		bool f = 1;
		for(int i=0;i<n;i++)
		{
			if(!(A[i][e]==A[e][i] && A[e][i]==i))
				 f=0;
		}
		if(f)
		{
			if(E!=-1)
				return false;
			E=e;
		}
	}
	if(E!=-1)
		return true;
	return false;
}

bool group()
{
	for(int i=0;i<n;i++)
	{
		bool f =0;
		for(int j=0;j<n;j++)
		{
			if(A[i][j] == A[j][i] && A[i][j]==E)
				f=1;
		}
		if(!f)
			return false;
	}
	return true;
}
bool abelian()
{
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			if(A[i][j]!=A[j][i])return false;
	return true;
}

bool rack()
{
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			for(int k=0;k<n;k++)
			{
				if(A[i][A[j][k]] != A[A[i][j]][A[i][k]])
					return false;
			}

	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		{
			int cnt = 0;	
			for(int k=0;k<n;k++)
			{
				if(A[i][k]==j)
					cnt++;
			}
			if(cnt!=1)
				return false;
		}
	return true;
}
bool quandle()
{
	for(int i=0;i<n;i++)
		if(A[i][i]!=i)
			return false;
	return true;
}

int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		S = 0;
		cin>>n;
		for(int i=0;i<n;i++)
			for(int j=0;j<n;j++)
				cin>>A[i][j];
		if(quasigroup())
		{
			S+=1;
			if(loop())
				S+=2;
		}
		if(semigroup())
		{
			S += 4;
			if(monoid())
			{
				S+=8;
				if(group())
				{
					S+=16;
					if(abelian())
						S+=32;
				}
			}
		}
		if(rack())
		{
			S+=64;
			if(quandle())
				S+=128;
		}
		cout<<S<<endl;

	}

	return 0;
}

----------
====================
----------
MATHEMATICS.204
medium
----------
PROBLEM STATEMENT:
You are given a N * N matrix, U. You have to choose 2 sub-matrices A and B made of only 1s of U, such that, they have at least 1 cell in common, and each matrix is not completely engulfed by the other, i.e., 

If U is of the form 



and A is of the form



and B is of the form



then, there exists atleast 1 ai, j : ai, j ∈ A and ai,j ∈ B 
then, there exists atleast 1 ai1, j1 : ai1, j1 ∈ A and ai1,j1 ∉ B 
then, there exists atleast 1 ai2, j2 : ai2, j2 ∈ B and ai2,j2 ∉ A 
ax,y = 1 ∀ ax,y ∈ A 
ax,y = 1 ∀ ax,y ∈ B  

How many such (A, B) exist?

Input Format 
The first line of the input contains a number N. 
N lines follow, each line containing N integers (0/1) NOT separated by any space.

Output Format 
Output the total number of such (A, B) pairs. If the answer is greater than or equal to 109 + 7,
then print answer modulo (%) 109 + 7.

Constraints  

2 ≤ N ≤ 1500 
ai,j ∈ [0, 1] : 0 ≤ i, j ≤ N - 1

Sample Input

4
0010
0001
1010
1110


Sample Output

10


Explanation

X means the common part of A and B. 
We can swap A and B to get another answer. 

0010
0001
A010
XB10

0010
0001
A010
XBB0

0010
0001
10A0
1BX0

0010
0001
10A0
BBX0

0010
0001
1010
AXB0


TimeLimits

Time limit for this challenge is mentioned here
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <string>
#include <iostream>
#include <sstream>
#include <map>
#include <set>
#include <vector>
#include <queue>
#include <bitset>
#include <numeric>
#include <ctime>
#include <cmath>
#include <cassert>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;
typedef long long ll;

#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define pct __builtin_popcount

#define N 1510
#define P 1000000007
#define I36 27777778

int add(int a, int b) {
    return (a+b)%P;
}

int sub(int a, int b) {
    return (a-b+P)%P;
}

int mul(int a, int b) {
    return (ll)a*b%P;
}

struct Poly {
    int A,B,C;
    // Ax^2+Bx+C
    Poly() {A = B = C = 0;}
    Poly(int _A, int _B, int _C):A(_A), B(_B), C(_C) {}
    
    Poly operator + (Poly a) {
        return Poly(add(A,a.A),add(B,a.B),add(C,a.C));
    }
    
    Poly operator - (Poly a) {
        return Poly(sub(A,a.A),sub(B,a.B),sub(C,a.C));
    }    
    
    Poly operator * (int a) {
        return Poly(mul(A,a),mul(B,a),mul(C,a));
    }
    
    int eval(int x) {
        return add(add(mul(mul(A,x),x),mul(B,x)),C);
    }
};

Poly pol(int L, int R, int H) {
    Poly p;
    p.A = 3;
    p.B = sub(sub(6,mul(3,L)),mul(3,R));
    p.C = add(add(sub(add(sub(2,mul(3,L)),mul(L,L)),mul(3,R)),mul(L,R)),mul(R,R));
    p = p*sub(L,R);
    p = p*H;
    p = p*add(1,H);
    p = p*add(2,H);
    p = p*I36;
    return p;
}

int n;
string s[N];
int h[N];

int a[N][N];
int st[N], sh[N];
int b[N][N], c[N][N], d[N][N];

string rots[N];
void rot() {
    for (int i = 0; i < n; i ++) 
        rots[i] = s[i];
    for (int i = 0; i < n; i ++)  {
        for (int j = 0; j < n; j ++) {
            s[n-j-1][i] = rots[i][j];
        }
    }
}

int roti[N][N];
void irot(int a[][N]) {
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) 
            roti[i][j] = a[i][j];
    }
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) {
            a[i][j] = roti[n-j-1][i];
        }
    }
}

void calc(int a[][N]) {
    memset(h,0,sizeof h);
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) {
            if (s[i][j] == '1') h[j] ++;
            else h[j] = 0;
        }
        int sn = 0;
        int uS = 0;
        st[0] = -1;
        sh[0] = 0;
        sn ++;
        for (int j = 0; j < n; j ++) {
            while (sn != 1 && sh[sn-1] > h[j]) {
                uS = sub(uS, mul(sub(st[sn-1],st[sn-2]),sh[sn-1]));
                sn --;
            }
            st[sn] = j;
            sh[sn] = h[j];
            sn ++;
            uS = add(uS, mul(sub(st[sn-1],st[sn-2]),sh[sn-1]));
            a[i][j] = uS;
        }
    }
}

void print(int a[][N]) {
    return;
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++)
            printf ("%d%c",a[i][j],j==n-1?'\n':' ');
    }
    puts ("");
}

int main()
{
	cin >> n;
    for (int i = 0; i < n; i ++)
        cin >> s[i];
    int S = 0;
    int T = 0;
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) {
            if (s[i][j] == '1') h[j] ++;
            else h[j] = 0;
        }
        int sn = 0;
        int uS = 0;
        Poly p;
        st[0] = -1;
        sh[0] = 0;
        sn ++;
        for (int j = 0; j < n; j ++) {
            while (sn != 1 && sh[sn-1] > h[j]) {
                uS = sub(uS, mul(sub(st[sn-1],st[sn-2]),sh[sn-1]));
                p = p-pol(st[sn-1],st[sn-2],sh[sn-1]); 
                sn --;
            }
            st[sn] = j;
            sh[sn] = h[j];
            sn ++;
            uS = add(uS, mul(sub(st[sn-1],st[sn-2]),sh[sn-1]));
            p = p+pol(st[sn-1],st[sn-2],sh[sn-1]); 
            S = add(S, uS);
            T = add(T, p.eval(j));
            a[i][j] = uS;
        }
    }
    
    rot(); calc(b); irot(b);
    rot(); calc(c); irot(c); irot(c); 
    rot(); calc(d); irot(d); irot(d); irot(d); 
    
    print(a); 
    print(b); 
    print(c); 
    print(d); 
    
    int TT = 0;
    for (int i = 0; i < n; i ++) {
        for (int j = n-1; j >= 0; j --) {
            if (i > 0) b[i][j] = add(b[i][j],b[i-1][j]);
            if (j < n-1) b[i][j] = add(b[i][j],b[i][j+1]);
            if (i > 0 && j < n-1) b[i][j] = sub(b[i][j],b[i-1][j+1]);
        }
    }
    
    for (int i = n-1; i >= 0; i --) {
        for (int j = n-1; j >= 0; j --) {
            if (i < n-1) c[i][j] = add(c[i][j],c[i+1][j]);
            if (j < n-1) c[i][j] = add(c[i][j],c[i][j+1]);
            if (i < n-1 && j < n-1) c[i][j] = sub(c[i][j],c[i+1][j+1]);
        }
    }
    
    print(b); 
    print(c); 
    
    for (int j = 0; j < n-1; j ++) {
        int U = 0;
        for (int i = 0; i < n; i ++) {
            U = add(U, a[i][j]);
        }
        TT = add(TT, mul(U, c[0][j+1]));
    }
    
    for (int i = 0; i < n-1; i ++) {
        int U = 0;
        for (int j = 0; j < n; j ++) {
            U = add(U, a[i][j]);
        }
        TT = add(TT, mul(U, c[i+1][0]));
    }
    
    for (int i = 0; i < n-1; i ++) {
        for (int j = 0; j < n-1; j ++) {
            TT = sub(TT, mul(a[i][j], c[i+1][j+1]));
        }
    }
    
    for (int i = 1; i < n; i ++) {
        for (int j = 0; j < n-1; j ++) {
            TT = sub(TT, mul(d[i][j], b[i-1][j+1]));
        }
    }
    
    int SS = 0;
    SS = add(SS, mul(S,S));
    SS = sub(SS, mul(2,T));
    SS = add(SS, S);
    SS = sub(SS, mul(2,TT));
    cout << SS << endl;
	return 0;
}
----------
====================
----------
MATHEMATICS.205
advanced
----------
PROBLEM STATEMENT:
Important note: Introduction to Algebra is a prerequisite for this challenge.  

Welcome back to Sevenkplus' perfect math class! 
You are now familiar with the following types of magmas: quasigroup, loop, semigroup, monoid, group, abelian group, rack, and quandle.
Furthermore, you are familiar with the magic number of a magma.

Or are you?

The following problem is an exercise to check whether you really are familiar with these definitions.

Find as many magmas as you can, such that no two of them have the same magic number.
----------
TOP SOLUTION:
----------
#include<cstdio>
int main(){
printf("12\n");
printf("2\n");
printf("0 0\n");
printf("0 0\n");
printf("2\n");
printf("0 0\n");
printf("0 1\n");
printf("2\n");
printf("0 0\n");
printf("1 0\n");
printf("2\n");
printf("0 1\n");
printf("0 1\n");
printf("2\n");
printf("0 1\n");
printf("1 0\n");
printf("2\n");
printf("1 0\n");
printf("1 0\n");
printf("1\n");
printf("0\n");
printf("3\n");
printf("0 1 2\n");
printf("2 0 1\n");
printf("1 2 0\n");
printf("3\n");
printf("0 2 1\n");
printf("2 1 0\n");
printf("1 0 2\n");
printf("3\n");
printf("0 1 2\n");
printf("0 1 2\n");
printf("1 0 2\n");
printf("6\n");
printf("0 1 2 3 4 5\n");
printf("1 2 0 5 3 4\n");
printf("2 0 1 4 5 3\n");
printf("3 4 5 0 1 2\n");
printf("4 5 3 2 0 1\n");
printf("5 3 4 1 2 0\n");
printf("5\n");
printf("0 1 2 3 4\n");
printf("1 0 3 4 2\n");
printf("2 4 1 0 3\n");
printf("3 2 4 1 0\n");
printf("4 3 0 2 1\n");
return 0;
}

----------
====================
----------
MATHEMATICS.206
advanced
----------
PROBLEM STATEMENT:
Let's define a new data structure - black box. A black box is a data structure that is capable of performing the following operations:


add an integer to the black box
delete an integer from the black box
find the subset from the set of numbers present inside the black box which produce a maximal value after being XORed.


We will give you N queries. Each query is an addition or a deletion operation as mentioned above. After each query we ask you to find the maximal possible XOR that can be obtained by combining some of the numbers that are present in the black box.

Input Format 
The first line of input contains an integer N. 
Then there is a line with N integers, separated with single spaces. Some of the integers are positive while some are negative.  

Let's denote the ith such integer by Ai. If it's positive, then it corresponds to the addition operation: addition of Ai to the black box. Otherwise, it corresponds to the deletion operation: deletion of |Ai| from the black box.

It is guaranteed that:


we will never add a number that is already present in the black box.
we will never delete a number that is currently not present in the black box.


Output Format

After each query, output the maximal XOR in a new line. If the black box has no numbers after the query, output 0. 

Constraints

1 ≤ N ≤ 5 * 105 
0 Ai| ≤ 2 * 109  

Sample Input

6
1 2 3 4 -2 -3

Sample Output

1
3
3
7
7
5

Explanation


1st Operation A = [1], maximum XOR is 1. 
2nd Operation A = [1,2], maximum XOR is 1⊕2 = 3
3rd Operation A = [1,2,3], maximum XOR is 1⊕2 or 3 = 3
4th Operation A = [1,2,3,4], maximum XOR is 4⊕3 = 7
5th Operation A = [1,3,4], maximum XOR is 4⊕3 = 7
6th Operation A = [1,4], maximum XOR is 4⊕1 = 5


TimeLimit

The timelimits for this challenge is given here, there might be chances of some submissions written in python TLEing post rerun on additional testcases, we will provide scores on a per submission basis if such a situation arises. 
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cassert>
#include <cstdio>
#include <algorithm>
#include <map>
using namespace std;

int xsz[32], xbasis[32][32], n, i, a[1000000 + 5], death[1000000 + 5], birth[1000000 + 5];
map<int, int> last_added;

void xorer_mk_clone (int x, int y) {
    xsz[x] = xsz[y];
    for(int i = 1; i <= xsz[x]; i++) xbasis[x][i] = xbasis[y][i];
}

void xorer_add (int x, int ai) {
    int i;
    for(i = 1; i <= xsz[x]; i++) if ((ai ^ xbasis[x][i]) < ai) ai ^= xbasis[x][i];
    if (!ai) return ;
    xbasis[x][i = ++xsz[x]] = ai;
    while (i > 1 && xbasis[x][i] > xbasis[x][i - 1]) swap(xbasis[x][i], xbasis[x][i--]);
}

int xorer_optimal (int x) {
    int ret = 0;
    for(int i = 1; i <= xsz[x]; i++) if ((ret ^ xbasis[x][i]) > ret) ret ^= xbasis[x][i];
    return ret;
}

void solve (int lvl, int l, int r) {
    if (l == r) {
        if (a[l] > 0) xorer_add(lvl, a[l]);
        printf("%d\n", xorer_optimal(lvl));
        return ;
    }
    int middle = (l + r) / 2;
    // spread to the left
    xorer_mk_clone(lvl + 1, lvl);
    for(i = middle + 1; i <= r; i++) if (birth[i] < l && a[i] < 0) xorer_add(lvl + 1, -a[i]);
    solve(lvl + 1, l, middle);
    // spread to the right
    xorer_mk_clone(lvl + 1, lvl);
    for(i = l; i <= middle; i++) if (death[i] > r && a[i] > 0) xorer_add(lvl + 1, a[i]);
    solve(lvl + 1, middle + 1, r);
}

int main (int argc, char * const argv[]) {
//  freopen("input.txt", "r", stdin);   
    scanf("%d", &n);
    for(i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        assert(a[i] != 0);
    }
    for(i = 1; i <= n; i++) if (a[i] > 0) {
        last_added[a[i]] = i; 
        death[i] = n + 1;
    } else {
        birth[i] = last_added[-a[i]];
        death[last_added[-a[i]]] = i;
    }
    solve(0, 1, n);
    return 0;
}
----------
====================
----------
MATHEMATICS.207
hard
----------
PROBLEM STATEMENT:
Given integers [expression].

Input Format 
The first line contains the number of test cases [expression]. 
Each of the next [expression]. 

Output Format 
For each test case output one integer: the value of the sum.

Note In this problem we take [expression]  

Constraints 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
The sum of all [expression] in one test file doesn't exceed 1000

Sample input  

5
3 1 1 100
3 0 1 100
3 1 0 100
44 44 4 444
77 7 47 747


Sample Output  

6
4
0
288
288


Explanation  

[expression] 
[expression] 
[expression]
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <vector>
#include <set>
#include <map>
#include <cassert>
#include <ctime> 
#include <cmath>
#include <string>
#include <cstring>
#include <queue>
using namespace std;

#define f first
#define s second
#define mp make_pair
#define pb push_back
#define pii pair<int, int>
#define vi vector<int>
#define all(v) (v).begin(), (v).end()
#define forit(it,v) for (__typeof(v.begin()) it = v.begin(); it != v.end(); ++it)
#define f0(a) memset(a, 0, sizeof(a))
#define ll long long
ll n, bb;
int mod, a, b, bpn;
int C[800][800];
int ans[800], oans[800];

int modPow(ll a, ll n) {
	a %= mod;
	int res = 1;
	while (n > 0) {
		if (n & 1) res = 1ll * res * a % mod;
		a = 1ll * a * a % mod;
		n >>= 1;
	}
	return res;
}

void Calc(ll n) {

	if (n == 0) {
		memset(ans, 0, sizeof(ans));
		ans[0] = 1 % mod;
		bpn = 1 % mod;
		return;
	}

	if (n % 2 == 0) {

		Calc(n - 1);
		bpn = (1ll * bpn * b) % mod;

		int np = 1;
		n %= mod;
		for (int i = 0; i <= a; ++i) {
			ans[i] = (ans[i] + 1ll * np * bpn) % mod;
			np = (1ll * np * n) % mod;
		}
		return;
	}

	ll m = (n + 1) / 2;
	Calc(m - 1);

	memcpy(oans, ans, sizeof(int) * (a + 1));
	int bpm = (1ll * bpn * b) % mod;
	bpn = (1ll * bpm * bpn) % mod;

	m %= mod;
	for (int i = 0; i <= a; ++i) {
		int pm = 1;
		for (int j = i; j >= 0; --j) {

			int now = (1ll * C[i][j] * pm) % mod;
			now = (1ll * now * oans[j]) % mod;
			now = (1ll * now * bpm) % mod;
			pm = (pm * m) % mod;
			ans[i] = (ans[i] + now) % mod;
		}
	}
}
void Solve() {
	scanf("%lld%d%lld%d", &n, &a, &bb, &mod);
	b = bb % mod; 
	if (b < 0) b += mod;

	for (int i = 0; i <= a; ++i) {
		C[i][0] = 1 % mod;
		for (int j = 1; j <= i; ++j) 
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
		
	}
	Calc(n);
	printf("%d\n", ans[a]);
}

int main() {
	int tests;
	scanf("%d", &tests);
	while (tests--) 
		Solve();
	return 0;
}


----------
====================
----------
MATHEMATICS.208
expert
----------
PROBLEM STATEMENT:
We consider two sequences of integers, [expression]. 

Given sequences [expression] instead.
----------
TOP SOLUTION:
----------
#define _USE_MATH_DEFINES
#include <cstdio>
#include <cstring>
#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <unordered_set>
#include <unordered_map>
#include <algorithm>
#include <complex>
#include <cmath>
#include <numeric>

using namespace std;

typedef long long int64;
typedef pair<int, int> ii;
const int INF = 1 << 30;

// typedef complex<double> atom;
typedef int atom;

const int MOD = 998244353; // prime, 2^23*7*17+1
const int G = 3;
const int THRESHOLD = 1 << 0;

int64 power_mod(int64 a, int64 n) {
  int64 ret = 1;
  for (; n; n >>= 1) {
    if (n & 1) ret = ret * a % MOD;
    a = a * a % MOD;
  }
  return ret;
}

int64 inv_mod(int64 a) {
  return power_mod(a, MOD - 2);
}

void bit_reverse(vector<atom>& a) {
  int n = a.size();
  for (int i = 1, j = n / 2; i < n - 1; ++i) {
    if (i < j) {
      swap(a[i], a[j]);
    }
    int k = n / 2;
    while (j >= k) {
      j -= k;
      k /= 2;
    }
    if (j < k) j += k;
  }
}

void fft(vector<atom>& a, int flag) {
  int n = a.size();
  bit_reverse(a);
  vector<atom> wn(n);
  wn[0] = 1;
  wn[1] = power_mod(G, flag == 1 ? (MOD - 1) / n : MOD - 1 - (MOD - 1) / n);
  for (int i = 2; i < n; ++i) {
    wn[i] = (int64)wn[i - 1] * wn[1] % MOD;
  }
  for (int k = 2; k <= n; k <<= 1) {
    for (int i = 0; i < n; i += k) {
      int wi = 0, step = n / k;
      for (int j = i; j < i + k / 2; ++j) {
        atom u = a[j];
        atom v = (int64)wn[wi] * a[j + k / 2] % MOD;
        a[j] = (u + v) % MOD;
        a[j + k / 2] = (u + MOD - v) % MOD;
        wi += step;
      }
    }
  }
  if (flag < 0) {
    int64 inv_n = inv_mod(n);
    for (int i = 0; i < n; ++i) {
      a[i] = a[i] * inv_n % MOD;
    }
  }
}

namespace polynomial {

vector<int> mul(const vector<int>& f, const vector<int>& g) {
  int n = f.size(), m = g.size();
  if (n <= THRESHOLD) {
    vector<int> h(n + m - 1);
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < m; ++j) {
        h[i + j] += (int64)f[i] * g[j] % MOD;
        h[i + j] %= MOD;
      }
    }
    return h;
  }
  int len = 1;
  while (len < n + m - 1) len <<= 1;
  vector<atom> x(len), y(len);
  copy(f.begin(), f.end(), x.begin());
  copy(g.begin(), g.end(), y.begin());
  fft(x, 1);
  fft(y, 1);
  for (int i = 0; i < len; ++i) {
    x[i] = (int64)x[i] * y[i] % MOD;
  }
  fft(x, -1);
  return x;
}

// g:=g*(2-f*g), n is power of 2
vector<int> inv(const vector<int>& f) {
  int n = f.size();
  if (n <= THRESHOLD) {
    vector<int> g(n);
    g[0] = inv_mod(f[0]);
    for (int i = 1; i < n; ++i) {
      int64 sum = 0;
      for (int j = 0; j < i; ++j) {
        sum += (int64)g[j] * f[i - j] % MOD;
      }
      sum = MOD - sum % MOD;
      g[i] = g[0] * sum % MOD;
    }
    return g;
  }
  vector<int> f1(f.begin(), f.begin() + (n >> 1));
  vector<int> g = inv(f1);

  int m = n << 1;
  vector<atom> x(m), y(m);
  copy(f.begin(), f.end(), x.begin());
  copy(g.begin(), g.end(), y.begin());
  fft(x, 1);
  fft(y, 1);
  for (int i = 0; i < m; ++i) {
    y[i] = (2 + MOD - (int64)x[i] * y[i] % MOD) % MOD * y[i] % MOD;
  }
  fft(y, -1);
  y.resize(n);
  return y;
}

vector<int> diffential(const vector<int>& f) {
  int n = f.size();
  vector<int> ret(n);
  for (int i = 0; i < n - 1; ++i) {
    ret[i] = (int64)f[i + 1] * (i + 1) % MOD;
  }
  return ret;
}

void integral(vector<int>& f) {
  int n = f.size();
  for (int i = n - 1; i > 0; --i) {
    f[i] = inv_mod(i) * f[i - 1] % MOD;
  }
  f[0] = 0;
}

// g=integral(f'/f), n is power of 2
vector<int> log(const vector<int>& f) {
  vector<int> g = diffential(f);
  vector<int> h = inv(f);
  vector<int> ret = mul(g, h);
  ret.resize(f.size());
  integral(ret);
  return ret;
}

// g:=g*(1-log(g)+f), n is power of 2
vector<int> exp(const vector<int>& f) {
  int n = f.size();
  if (n == 1) {
    vector<int> g(1);
    g[0] = 1;
    return g;
  }
  vector<int> f1(f.begin(), f.begin() + (n >> 1));
  vector<int> g = exp(f1);
  g.resize(n);
  vector<int> h = log(g);
  for (int i = 0; i < n; ++i) {
    h[i] = ((i == 0) + f[i] + MOD - h[i]) % MOD;
  }

  int m = n << 1;
  vector<atom> x(m), y(m);
  copy(g.begin(), g.end(), x.begin());
  copy(h.begin(), h.end(), y.begin());
  fft(x, 1);
  fft(y, 1);
  for (int i = 0; i < m; ++i) {
    x[i] = (int64)x[i] * y[i] % MOD;
  }
  fft(x, -1);
  x.resize(n);
  return x;
}

void print(vector<int>& a) {
  for (int i = 0; i < a.size(); ++i) {
    cout << a[i] << " ";
  }
  cout << endl;
}

}

int main() {
  int n, k;
  scanf("%d%d", &n, &k);
  int len = 1;
  while (len < n * 2) len <<= 1;
  vector<int> a(len), b(len);
  for (int i = 0; i < n; ++i) scanf("%d", &a[i]);
  for (int i = 0; i < n; ++i) scanf("%d", &b[i]);
  if (k >= n - 1) {
    puts("0");
    return 0;
  }
  vector<int> g(len);
  g[0] = 1; g[1] = MOD - 1;
  g = polynomial::log(g);
  for (int i = 0; i < len; ++i) g[i] = (int64)g[i] * (k + 1) % MOD;
  g = polynomial::exp(g);
  auto h = polynomial::mul(g, a);
  vector<int> A(h.begin() + k + 1, h.begin() + n);

  copy(b.begin(), b.begin() + n, b.begin() + n);
  h = polynomial::mul(g, b);
  vector<int> B(h.begin() + k + 1, h.begin() + n * 2);

  // for (auto& it : A) {
  //   printf("%d ", it);
  // } puts("");
  // for (auto& it : B) {
  //   printf("%d ", it);
  // } puts("");
  vector<int> f(A.size());
  f[0] = 0;
  k = 0;
  for (int i = 1; i < A.size(); ++i) {
    for (; k > 0 && A[k] != A[i]; k = f[k - 1]);
    if (A[k] == A[i]) ++k;
    f[i] = k;
  }
  k = 0;
  int ret = -1;
  for (int i = 0; i < B.size(); ++i) {
    for (; k > 0 && A[k] != B[i]; k = f[k - 1]);
    if (A[k] == B[i]) ++k;
    if (k == A.size()) {
      ret = i - A.size() + 1;
      break;
    }
  }
  printf("%d\n", ret);
  return 0;
}

----------
====================
----------
MATHEMATICS.209
easy
----------
PROBLEM STATEMENT:
Given [expression] two-dimensional points in space, determine whether they lie on some vertical or horizontal line. If yes, print YES; otherwise, print NO.
----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 350

using namespace std;

const int INF = 1e9;

const int N = 100000;

int n;
set<int> x, y;

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);
	
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		int a, b;
		cin >> a >> b;
		x.insert(a);
		y.insert(b);
	}
	if (x.size() == 1 || y.size() == 1)
		puts("YES");
	else
		puts("NO");
	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
MATHEMATICS.210
easy
----------
PROBLEM STATEMENT:
You are given an infinite 2-d grid with the bottom left cell referenced as (1,1). All the cells contain a value of zero initially. Let's play a game?  

The game consists of N steps wherein each step you are given two integers a and b. The value of each of the cells in the co-ordinate (u, v) satisfying 1 ≤ u ≤ a and 1 ≤ v ≤ b, is increased by 1. After N such steps, if X is the largest number amongst all the cells in the rectangular board, can you print the number of X's in the board?

Input Format 
The first line of input contains a single integer N. N lines follow. 
Each line contains two integers a and b separated by a single space.  

Output Format 
Output a single integer - the number of X's. 

Constraints 
1 ≤ N ≤ 100 
1 ≤ a ≤ 106 
1 ≤ b ≤ 106

Sample Input  

3
2 3
3 7
4 1


Sample Output  

2


Explanation

Assume that the following board corresponds to cells (i, j) where 1 ≤ i ≤ 4 and 1 ≤ j ≤ 7.

At the beginning board is in the following state:

0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0 


After the first step we will obtain:

0 0 0 0 0 0 0
0 0 0 0 0 0 0
1 1 1 0 0 0 0
1 1 1 0 0 0 0 


After the second step we will obtain:

0 0 0 0 0 0 0
1 1 1 1 1 1 1
2 2 2 1 1 1 1
2 2 2 1 1 1 1 


Finally, after the last step we will obtain:

1 0 0 0 0 0 0
2 1 1 1 1 1 1
3 2 2 1 1 1 1
3 2 2 1 1 1 1 


So, the maximum number is 3 and there are exactly two cells which correspond to 3. Hence 2.  
----------
TOP SOLUTION:
----------
//Program: a
//Author: gary
//Date: 29/03/2014
#include <bits/stdc++.h>
using namespace std;
#define SZ(x) ( (int) (x).size() )
#define mp make_pair
#define pb push_back
#define fi first
#define se second
typedef pair<int, int> i2;
typedef long long ll;
const int INF = 1e9;

int N;

int main(){
  ios::sync_with_stdio(0);
  cin >> N;
  int a, b, ma = INF, mb = INF;
  for(int i = 0; i < N; i++)
  {
    cin >> a >> b;
    ma = min(ma, a);
    mb = min(mb, b);
  }
  cout << (ll) ma * mb << endl;
  return 0;
}

----------
====================
----------
MATHEMATICS.211
easy
----------
PROBLEM STATEMENT:
Watson gives Sherlock two integers, [expression]'s such that: 
[expression]  

Given [expression]'s for each query on a new line.
----------
TOP SOLUTION:
----------
#include <iostream>
using namespace std;

typedef long long ll;

ll Solve(ll N, ll K) {
    if (N == 1) return 0;
    auto ok = [=](ll x) { return x * (N - x) <= N * K; };
    if (ok(N / 2)) return N - 1;
    if (!ok(1)) return 0;
    ll lo = 1, hi = N / 2;
    while (lo + 1 < hi) {
        ll mid = (lo + hi) / 2;
        if (ok(mid)) lo = mid; else hi = mid;
    }
    return lo * 2;
}

int main() {
    int T;
    for (cin >> T; T--;) {
        ll N, K;
        cin >> N >> K;
        cout << Solve(N, K) << endl;
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.212
easy
----------
PROBLEM STATEMENT:
Watson gives four 3-dimensional points to Sherlock and asks him if they all lie in the same plane. Your task here is to help Sherlock.   

Input Format 
First line contains T, the number of testcases. 
Each test case consists of four lines. Each line contains three integers, denoting xi yi zi.   

Output Format 
For each test case, print YES or NO whether all four points lie in same plane or not, respectively.  

Constraints 
1 ≤ T ≤ 104 
-103 ≤ xi,yi,zi ≤ 103  

Sample Input

1
1 2 0
2 3 0
4 0 0
0 0 0


Sample Output

YES


Explanation 
All points have zi = 0, hence they lie in the same plane, and output is YES
----------
TOP SOLUTION:
----------
#define _USE_MATH_DEFINES
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <iostream>
#include <sstream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <string>

using namespace std;

int T;
long long a[5][5];
int i,j;

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		for(i=0;i<4;i++)
			for(j=0;j<3;j++)
				scanf("%lld",&a[i][j]);
		for(i=0;i<3;i++)
			for(j=0;j<3;j++)
				a[i][j]-=a[3][j];
		puts(a[0][0]*a[1][1]*a[2][2]+a[0][1]*a[1][2]*a[2][0]+a[0][2]*a[1][0]*a[2][1]==a[0][0]*a[2][1]*a[1][2]+a[0][1]*a[1][0]*a[2][2]+a[0][2]*a[1][1]*a[2][0]?"YES":"NO");
	}
	return 0;
}
----------
====================
----------
MATHEMATICS.213
medium
----------
PROBLEM STATEMENT:
Roy lives in a city that is circular in shape on a [expression] additional police stations at some suburbs. Each of these police stations can protect the suburb it is located in.

Given the square of radius, [expression], of the city, Roy has to determine if it is possible to protect all the suburbs.

Input Format 
The first line of input contains integer [expression] test cases follow. 
Each of the next [expression], the maximum number of police stations the headquarters is willing to build.

Constraints 
[expression] 
[expression] 
[expression]  

Output Format 
For each test case, print in a new line possible if it is possible to protect all the suburbs;, otherwise, print impossible.

Sample Input

5
1 3
1 4
4 4
25 11
25 12


Sample Output

impossible
possible
possible
impossible
possible


Explanation  


For [expression] points on circumference - [(0,1), (0,-1), (1,0), (-1,0)].
For [expression] points on circumference - [(0,2), (0,-2), (2,0),(-2,0)].
For [expression] points on circumference - [(0,5), (0,-5), (3,4), (-3,4), (3,-4), (-3,-4), (4,3), (-4,3), (4,-3), (-4,-3), (5,0), (-5,0)].


Test Case #01: There are [expression] police stations. 
Test Case #02: We can cover all the [expression] stations are allowed. 
Test Case #03: We can cover all the [expression] stations are allowed. 
Test Case #04: It is impossible to cover [expression] police stations. 
Test Case #05: We can to cover all [expression] police stations.  

Timelimits  

Timelimits for this challenge are given here
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int main(){
    int t;
    cin>>t;
    for(int u =0; u < t; ++u){
        int r,k;
        cin>>r>>k;
        int cnt = 0;
        for(int x = 0; x*x <= r; ++x){
            int res = r - x*x;
            int y = sqrt(res);
            if(y*y == res){
                if(x == 0 || y == 0){
                    cnt+= 2;
                }
                else{
                    cnt += 4;
                }
            }
        }
        if(cnt <= k){
            cout<<"possible\n";
        }
        else{
            cout<<"impossible\n";
        }
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.214
easy
----------
PROBLEM STATEMENT:
Xrange makes the best polygonal pancakes in PancakeLand. To grow the business, they hired [expression] line cooks to be pancake rotators and flippers.

A regular n-gon has [expression] rotation points. We define the following:


Flipping Axes 
If [expression] total flipping axes).
If [expression] flipping axes pass through every pair of opposing sides.
The angle between consecutive axes is [expression]  degrees.
A [expression].
Rotation Points 
There are [expression] types of rotators.
A [expression]-rotator.




Each pancake passes through a long line of rotators and flippers who change the polygonal pancake's orientation during cooking. Xrange wants to hire one more rotator or flipper to restore the pancake to its initial orientation for plating.

Given [expression] and the sequence of rotators and flippers that the pancake passes through, determine which type of rotator or flipper must be added to the end of the line to restore the pancake to its initial orientation.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int n; cin >> n;
    int m; cin >> m;
    int side = 0; // a
    int base = 0; // first vertex
    for (int i = 0; i < m; ++i) {
        int type; cin >> type;
        int k; cin >> k;
        if (type == 1) {
            if (side == 0) {
                base = (base - k);
                if (base < 0) {
                    base = base + n;
                }
            } else {
                base = (base + k) % n;
            }
        } else {
            if (side == 0) {
                base = (base + k) % n;
            } else {
                base = (base - k);
                if (base < 0) {
                    base = base + n;
                }
            }
            side = !side;
        }
    }
    
    if (side == 0) {
        cout << 1 << " ";
        cout << base << endl;
    } else {
        cout << 2 << " ";
        cout << base << endl;
    }
    
    return 0;
}
----------
====================
----------
MATHEMATICS.215
medium
----------
PROBLEM STATEMENT:
Initially, two non-touching spheres of radii R1 and R2 are lying in space at rest. Both of them are then given accelerations a1 and a2 respectively at time=0. Find whether they will ever come in contact. Their initial positions are represented as (x1,y1,z1) and (x2,y2,z2) respectively. Accelerations have respective components in 3D. They are represented as (a1i,a1j,a1k) and (a2i,a2j,a2k) respectively.

Input Format 
The first line contains T, the number of test cases. 
Each test case consists of five lines, where the first line contains R1 and R2. The next two lines contain position and acceleration of the first sphere. The next two lines after this contain position and acceleration of the second sphere. All numbers in input are integers. 

Output Format 
For each test case, print YES, if the spheres come in contact. Otherwise, print NO (quotes for clarity).  

Constraints 
1 ≤ T ≤ 104 
1 ≤ R1, R2 ≤ 102 
-102 ≤ x1, y1, z1 , x2 , y2 , z2 ≤ 102 
-102 ≤ a1i , a1j , a1k , a2i , a2j , a2k ≤ 102     

Sample input  

2
1 2
0 0 0
-1 0 0
4 0 0
1 0 0
1 2
0 0 0
100 0 0
4 0 0
0 0 0


Sample output  

NO
YES


Explanation 
For first testcase, both spheres go in opposite directions, so they'll never come in contact. 
For second testcase, second sphere is not moving while first sphere is accelerating towards the second sphere. So they come in contact.
----------
TOP SOLUTION:
----------
#include <cstring>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>

using namespace std;
typedef long long int64;
typedef pair<int, int> PII;
const int MOD = 1000000007;
const double EPSILON = 1e-10;

#define FORU(i, a, b) for (int i = (a); i <= (b); ++i)
#define FORD(i, a, b) for (int i = (a); i >= (b); --i)
#define REPU(i, a, b) for (int i = (a); i < (b); ++i)
#define REPD(i, a, b) for (int i = (a); i > (b); --i)
#define SIZE(A) ((int) A.size())
#define PB(X) push_back(X)
#define MP(A, B) make_pair(A, B)

template<class T> inline T tmin(T a, T b) {return (a < b) ? a : b;}
template<class T> inline T tmax(T a, T b) {return (a > b) ? a : b;}
template<class T> inline T tabs(T a) {return (a > 0) ? a : -a;}
template<class T> T gcd(T a, T b) {if (b == 0) return a; return gcd(b, a % b);}

struct vect3D {
    double x, y, z;
};

vect3D x1, x2, a1, a2;

vect3D diff(vect3D &v1, vect3D &v2)
{
    vect3D ans;
    ans.x = v1.x-v2.x;
    ans.y = v1.y-v2.y;
    ans.z = v1.z-v2.z;
    return ans;
}

inline double norm(vect3D &v)
{
    return v.x*v.x+v.y*v.y+v.z*v.z;
}

inline double product(vect3D &v1, vect3D &v2)
{
    return v1.x*v2.x+v1.y*v2.y+v1.z*v2.z;
}

int main(int argc, char const *argv[])
{	
	ios_base::sync_with_stdio(false);
	int ntest;
    double R1, R2;
	cin >> ntest;
    while (ntest--) {
        cin >> R1 >> R2;
        cin >> x1.x >> x1.y >> x1.z >> a1.x >> a1.y >> a1.z;
        cin >> x2.x >> x2.y >> x2.z >> a2.x >> a2.y >> a2.z;
        vect3D dx = diff(x2, x1);
        vect3D da = diff(a2, a1);
        double ans = norm(dx);
        double t = product(dx, da);
        double s = norm(da);
        if (tabs(s) < EPSILON) {
            if (ans - (R1+R2)*(R1+R2) < EPSILON) cout << "YES" << "\n";
            else cout << "NO" << "\n";
        }
        else {
            double m = -t/s;
            if (m > EPSILON) {
                vect3D p = (vect3D) {dx.x+m*da.x, dx.y+m*da.y, dx.z+m*da.z};
                ans = tmin(ans, norm(p));
            }
            if (ans - (R1+R2)*(R1+R2) < EPSILON) cout << "YES" << "\n";
            else cout << "NO" << "\n";
        }
    }
	return 0;
}
----------
====================
----------
MATHEMATICS.216
medium
----------
PROBLEM STATEMENT:
You are standing at point [expression] in length.

You are given [expression] on a new line.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int q;
    cin >> q;
    while (q--) {
        int a, b, d;
        cin >> a >> b >> d;
        int ans;
        if (!d) ans = 0;
        else if (d == a || d == b) ans = 1;
        else ans = max(2, (d - 1) / b + 1);
        cout << ans << '\n';
    }

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
MATHEMATICS.217
easy
----------
PROBLEM STATEMENT:
You are given [expression]). For each set of points, print YES on a new line if all the points fall on the edges (i.e., sides and/or corners) of a non-degenerate rectangle which is axis parallel; otherwise, print NO instead. 
----------
TOP SOLUTION:
----------
/*
*/

#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 350

using namespace std;

const int INF = 1e9;
const int N = 200031;

int tests, n, x[N], y[N];
vector<int> xs, ys;
int flag;

bool lies_on_v(int x, int y, int x1, int y1, int y2)
{
	if (x != x1)
		return false;
	if (y<y1 || y>y2)
		return false;
	return true;
}

bool validate(int x1, int x2, int y1, int y2)
{
	if (x1 >= x2)
		return false;
	if (y1 >= y2)
		return false;
	for (int i = 0; i < n; i++)
	{
		if (lies_on_v(x[i], y[i], x1, y1, y2) || lies_on_v(x[i], y[i], x2, y1, y2) || lies_on_v(y[i], x[i], y1, x1, x2) || lies_on_v(y[i], x[i], y2, x1, x2))
			continue;
		return false;
	}
	return true;
}

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);

	cin >> tests;
	for (; tests; --tests)
	{
		cin >> n;
		for (int i = 0; i < n; i++)
		{
			cin >> x[i] >> y[i];
		}
		xs.clear();
		ys.clear();
		xs.push_back(-100000);
		xs.push_back(100000);
		ys.push_back(-100000);
		ys.push_back(100000);
		for (int i = 0; i < n; i++)
		{
			xs.push_back(x[i]);
			ys.push_back(y[i]);
		}
		flag = 0;

		for (int i = 0; i < xs.size(); i++)
		{
			for (int j = 0; j < xs.size(); j++)
			{
				for (int q = 0; q < ys.size(); q++)
				{
					for (int w = 0; w < ys.size(); w++)
					{
						if (validate(xs[i], xs[j], ys[q], ys[w]))
							flag = 1;
					}
				}
			}
		}
		if (flag == 0)
			cout << "NO" << endl;
		else
			cout << "YES" << endl;
	}
	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
MATHEMATICS.218
medium
----------
PROBLEM STATEMENT:
In this challenge, you must implement part of a raster graphics editor that takes the coordinates of a circle and a square as input and draws them as filled-in shapes on a rectangular canvas.



The rectangular canvas consists of uniformly sized square pixels, and is [expression] pixels high. Each point on the canvas belongs to a pixel, the intersection of two pixels has zero area, and each pixel is completely contained within the canvas. 

The Cartesian coordinate system set up in the following way: 


Point [expression] is the center of the top-left pixel of the canvas.
Point [expression] is the center of the top-right pixel of the canvas.
Point [expression] is the center of the bottom-left pixel of the canvas. 
Point [expression] is the center of the bottom-right pixel of the canvas. 


Thus, all pixel centers have integer coordinates and if the center of a pixel has coordinates [expression]. The two shapes should be drawn like so:


The circle is centered at the integer coordinates [expression].





The square is defined by the integer coordinates of two of its opposite corners [expression]. A pixel should be black as a part of the square if and only if its center falls within the square or along its border. The coordinates of different corners of the square do not coincide.




Given [expression], and the definition of the circle and the square, print a raster image of the canvas where each character is either a . (denoting a white pixel outside of both shapes) or a # (denoting a black pixel that's part of a shape).

Note: The first pixel of the first line of output should correspond to the top-left corner of the canvas.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int w, h;
    cin >> w >> h;
    int xc, yc, rc;
    cin >> xc >> yc >> rc;
    int x0, y0, x1, y1;
    cin >> x0 >> y0 >> x1 >> y1;
    int dx = x1 - x0, dy = y1 - y0;
    int vx = dx + dy, vy = dy - dx;
    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            bool f = (x - xc) * (x - xc) + (y - yc) * (y - yc) <= rc * rc;
            int xx = x - x0, yy = y - y0;
            bool c0 = (vx * yy - vy * xx >= 0) && (vx * xx + vy * yy >= 0);
            xx = x - x1; yy = y - y1;
            bool c1 = (vx * yy - vy * xx <= 0) && (vx * xx + vy * yy <= 0);
            f |= c0 && c1;
            cout << (f ? '#' : '.');
        }
        cout << "\n";
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.219
hard
----------
PROBLEM STATEMENT:
Jim likes to play with laser beams. 
Jim stays at point [expression]. 
There is a mirror at point [expression].

Jim wants to find out if he can point the laser beam on the mirror.

Input Format 
First line contains the number of test cases, [expression]. 
Each subsequent line contains one test case: space separated integers that denote endpoints of the wall [expression].  

Output Format 
The answer for each test case: Display YES if Jim can point the laser beam to the mirror, otherwise display NO .  

Constraints 
[expression] 
[expression] 
Mirror doesn't have common points with wall. 
Wall doesn't pass through the point [expression].  

Sample Input

5
1 2 2 1 2 2
-1 1 1 1 1 -1
1 1 2 2 3 3
2 2 3 3 1 1
0 1 1 1 0 2


Sample Output

NO
YES
NO
YES
NO

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

static bool IsOnSegment(long xi, long yi, long xj, long yj,
                        long xk, long yk) {
  return (xi <= xk || xj <= xk) && (xk <= xi || xk <= xj) &&
         (yi <= yk || yj <= yk) && (yk <= yi || yk <= yj);
}

static char ComputeDirection(long xi, long yi, long xj, long yj,
                             long xk, long yk) {
  double a = (xk - xi) * (yj - yi);
  double b = (xj - xi) * (yk - yi);
  return a < b ? -1 : a > b ? 1 : 0;
}

/** Do line segments (x1, y1)--(x2, y2) and (x3, y3)--(x4, y4) intersect? */
int DoLineSegmentsIntersect(long x1, long y1, long x2, long y2,
                             long x3, long y3, long x4, long y4) {
  char d1 = ComputeDirection(x3, y3, x4, y4, x1, y1);
  char d2 = ComputeDirection(x3, y3, x4, y4, x2, y2);
  char d3 = ComputeDirection(x1, y1, x2, y2, x3, y3);
  char d4 = ComputeDirection(x1, y1, x2, y2, x4, y4);
  return (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
          ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) ||
         (d1 == 0 && IsOnSegment(x3, y3, x4, y4, x1, y1)) ||
         (d2 == 0 && IsOnSegment(x3, y3, x4, y4, x2, y2)) ||
         (d3 == 0 && IsOnSegment(x1, y1, x2, y2, x3, y3)) ||
         (d4 == 0 && IsOnSegment(x1, y1, x2, y2, x4, y4));
}

int main(){
    int t;
    cin >> t;
    while(t--){
        long x1,x2,y1,y2,x,y;
        cin >> x1 >> y1 >> x2 >> y2 >> x >> y;
        if(DoLineSegmentsIntersect(0,0,x,y,x1,y1,x2,y2) == 0){
            cout << "YES\n";
        }
        else{
            cout << "NO\n";
        }
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.220
medium
----------
PROBLEM STATEMENT:
A group of [expression] units.

Given the coordinates, [expression].
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

void quicksort(int array[], int firstIndex, int lastIndex)
{
    int pivotIndex, temp, index1, index2;
    if(firstIndex < lastIndex)
    {   pivotIndex = firstIndex;
        index1 = firstIndex;
        index2 = lastIndex;
        while(index1 < index2)
        {
            while(array[index1] <= array[pivotIndex] && index1 < lastIndex)
                index1++;
            while(array[index2]>array[pivotIndex])
                index2--;
            if(index1<index2)
            {
                temp = array[index1];
                array[index1] = array[index2];
                array[index2] = temp;
            }
        }
        temp = array[pivotIndex];
        array[pivotIndex] = array[index2];
        array[index2] = temp;
        quicksort(array, firstIndex, index2-1);
        quicksort(array, index2+1, lastIndex);
    }
}

int main() {
   int n,m;
    cin>>n>>m;
    long int arr[m][n];
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++)
            {
            cin>>arr[j][i];
        }
    }
        for(int i=0;i<m;i++)
            {
            int arrs[n];
            for(int j=0;j<n;j++)
                {
                arrs[j]=arr[i][j];
            }
            quicksort(arrs,0,n-1);
            for(int j=0;j<n;j++)
                {
                arr[i][j]=arrs[j];
            }
        }
        if(n%2==1)
            {
            for(int i=0;i<m;i++)
                {
                cout<<arr[i][n/2]<<" ";
            }
        }
        else
            {
            for(int i=0;i<m;i++)
                {
                cout<<arr[i][n/2-1]<<" ";
            }
        }
    
    return 0;
}

----------
====================
----------
MATHEMATICS.221
medium
----------
PROBLEM STATEMENT:
You are given a straight line, [expression]. Find the point closest to the origin that also satisfies the following properties:  


[expression] are integers.  
[expression] is greater than zero.  


If more than one solution exists satisfying [expression] is minimal.  

Given [expression] values.

Note: It is guaranteed that there will always be integral points on the line.  
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int gcd (int a, int b, long long& x, long long& y) {
    if (a == 0) {
        x = 0;
        y = 1;
        return b;
    }
    
    long long x0, y0;
    int d = gcd(b % a, a, x0, y0);
    x = y0 - (b / a) * x0;
    y = x0;
    return d;
}

int main() {
    int tc;
    scanf("%d", &tc);
    for (int ti = 0; ti < tc; ++ti) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        
        if (a == 0) {
            printf("%d %d\n", 1, c / a);
        }
        
        long long x, y;
        int d = gcd(a, b, x, y);
        x *= c / d;
        
        int b1 = b / d;
        int a1 = a / d;
        
        x = ((x % b1) + b1) % b1;
        if (x == 0) {
            x += b1;
        }
        y = (c - a * x) / b;
        
        while (2 * b1 * x + b1 * (long long) b1 - 2 * a1 * y + a1 * (long long) a1 < 0) {
            x += b1;
            y -= a1;
        }
        
        cout << x << " " << y << "\n";
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.222
medium
----------
PROBLEM STATEMENT:
Little John has drawn [expression]. He draws a straight line that divides the paper into two parts such that each part has a subset of stars in them. Let the weight of each part be the summation of weights of the stars in the part. He wants to draw the line such that the difference in the sum of weights between the two parts is as small as possible while maximizing the smaller part's weight.  

Your task is to compute the weight of smaller part corresponding to this line where no stars are allowed to be on the line and line can be of any slope.  

Input Format 
The first line of the input contains an integer [expression]. 
Each of next [expression]. 
No three points lie on a line.  

Constraints 
[expression] 
[expression] 
[expression]  

Output Format 
Print an integer being the answer to the test.  

Sample Input 0  

4
1 1 2
-1 1 2
-1 -1 4
1 -1 5


Sample Output 0  

6


Explanation 
You can imagine a line along the [expression].  

Sample Input 1

10
748798831 -200797120 595
-774675771 179630170 159
-338760201 945958360 750
955629379 -312997434 516
755005057 -672683474 405
-743176829 190325067 86
-301478753 -718170081 923
-795908444 985440803 854
-102868895 671114060 246
-698209449 12550066 190


Sample Output 1

2358


Explanation  

[expression] are two sets of weights. 
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */

#include<iostream>
#include<algorithm>
using namespace std;

int main()
{
	int N;
	cin>>N;
	long long X[N], Y[N];
	int V[N];
	int i,j,k;
	for(i=0;i<N;i++) cin>>X[i]>>Y[i]>>V[i];
	int best=0;
	for(i=0;i<N;i++)
		for(j=i+1;j<N;j++)
		{
			int sum1=0,sum2=0;
			for(k=0;k<N;k++)
			{
				long long sign = ((Y[k]-Y[i])*(X[j]-X[i])-(X[k]-X[i])*(Y[j]-Y[i])); 
				if(sign<0) sum1+=V[k];
				else if(sign>0) sum2+=V[k];
			}
			best=max(best,max(
				max(min(sum1+V[i],sum2+V[j]),min(sum1+V[j],sum2+V[i])),
				max(min(sum1+V[i]+V[j],sum2),min(sum1,sum2+V[i]+V[j])))
			);
		}
	cout<<best<<endl;
}
----------
====================
----------
MATHEMATICS.223
medium
----------
PROBLEM STATEMENT:
A point (x,y), on the cartesian plane, makes an angle theta with the positive direction of the x-axis. Theta varies in the interval  [0 ,2PI) radians, i.e, greater than or equal to zero; but less than 2*PI radians.  

For example, the polar angle of the point (1,2) as marked in this plane below, is (approximately) 63.4 degrees (multiply by PI/180 to convert to radians)


Ref http://eldar.mathstat.uoguelph.ca/dashlock/Outreach/Articles/images/PRfig1.jpg  

The Task  

Given a list of points in the 2D plane, sort them in ascending order of their polar angle. In case multiple points share exactly the same polar angle, the one with lesser distance from the origin (0,0) should occur earlier in the sorted list.  

Input Format 
The first line contains an integer N. 
This is followed by N lines containing pairs of space separated integers, x and y which represent the coordinates of the points in the cartesian plane.  

Constraints 
    1 
    -100 
    The point (0,0) will not be present in the list of points.  

Output Format 
The output should contain N lines. 
Each line should contain two integers x and y, corresponding to a point in the original list. Display the points in ascending order of their polar angle.

Sample Input 

4  
1 0  
0 -1  
-1 0  
0 1  


Sample Output    

1 0    
0 1    
-1 0    
0 -1    


Explanation  

The point (0,1) has a polar angle of 90 degrees. The point (1,0) has a polar angle of 0 degrees. (-1,0) has a polar angle of 180 degrees and (0,-1) has a polar angle of 270 degrees.  
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <utility>
using namespace std;
typedef pair<int, int> point;

int quad(const point& x) {
    if (x.second == 0 && x.first > 0) return 0;
    if (x.second > 0 && x.first > 0) return 1;
    if (x.second > 0 && x.first == 0) return 2;
    if (x.second > 0 && x.first < 0) return 3;
    if (x.second == 0 && x.first < 0) return 4;
    if (x.second < 0 && x.first < 0) return 5;
    if (x.second < 0 && x.first == 0) return 6;
    return 7;
}

bool lt(const point& lhs, const point& rhs) {
    int q1 = quad(lhs), q2 = quad(rhs);
    if (q1 != q2) return q1 < q2;
    if (q1 % 2 == 1) {
        int x = lhs.second*rhs.first, y = rhs.second*lhs.first;
        if (x != y) return x < y;
    }
    return max(abs(lhs.first), abs(lhs.second)) < max(abs(rhs.first), abs(rhs.second));
}

int main() {
    int N;
    cin >> N;
    vector<point> V(N);
    for (auto &x : V) cin >> x.first >> x.second;
    sort(V.begin(), V.end(), lt);
    for (const auto &x : V) cout << x.first << " " << x.second << "\n";
    return 0;
}

----------
====================
----------
MATHEMATICS.224
advanced
----------
PROBLEM STATEMENT:
Watson gives a circle and a triangle in a 2-dimensional plane to Sherlock. Sherlock has to tell if they intersect/touch each other. 
The circle is centered at [expression].   

Input Format 
The first line contains [expression], the number of test cases. 
Each test case consists of [expression] in one line. 
The next three lines each contains [expression] denoting the vertices of the triangle.   

Output Format 
For each test case, print YES if the triangle touches or intersects the circle; otherwise, print NO.   

Constraints 
[expression] 
[expression] 
[expression] 
[expression] 
Note: There will be no degenerate triangles (i.e. triangles with area 0)  

Sample Input  

2
0 0 10
10 0
15 0
15 5
0 0 10
0 0
5 0
5 5


Sample Output    

YES
NO


Explanation 

 
In the first case, the triangle is touching the circle. In the second case, it neither touches nor intersects the circle.   
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include<math.h>
using namespace std;
typedef long long ll;
struct point {
    ll x,y;
};
struct line {
    ll a,b,c;// ax + by + c = 0
};
struct circle {
    ll x,y,r;
};
typedef struct point P;
typedef struct line L;
typedef struct circle C;
L getline(P a, P b)
    {
    L ans;
    ans.b = a.x - b.x;
    ans.a = b.y - a.y;
    ans.c = -(ans.a * a.x + ans.b *a.y);
    return ans;
}
long  double x1,x2,yy1,yy2;
int cross(L fir, C sec)
    {
    ll a,b,c,r;
    a = fir.a;b=fir.b;c=fir.c;r=sec.r;
    ll viv = ((r*r)*(a*a + b*b))-c*c;
    if(viv<0)return 0;
    long  double vi = sqrt(viv);
    vi*=b;
    x1 = (vi-a*c)/(a*a + b*b);
    x2 = 0-(vi+a*c)/(a*a+b*b);
    if(b){
    yy1 = 0-(a*x1+c)/b;
        yy2 = 0-(a*x2+c)/b;}
    else {
        yy1 = sqrt(r*r-x1*x1);
        yy2=0-yy1;
    }
    return 1;
    
}
int bet(long double a, long double b, long double c)
    {
    long double d;
    if(a>b){d=a;a=b;b=d;}
    if(c<a)return 0;
    if(c>b)return 0;
    return 1;
}
int betp(P a, P b)
    {
    if(bet(a.x,b.x,x1)&& bet(a.y,b.y,yy1))return 1;
    return bet(a.x,b.x,x2)&& bet(a.y,b.y,yy2);
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int t;
    scanf("%d",&t);
    while(t--)
        {
        ll x,y,r;
        scanf("%lld%lld%lld",&x,&y,&r);
        C my;
        my.x = my.y = 0;
        my.r = r;
        P a,b,c;
        scanf("%lld%lld",&a.x,&a.y);
        scanf("%lld%lld",&b.x,&b.y);
        scanf("%lld%lld",&c.x,&c.y);
        a.x-=x; a.y-=y;
        b.x-=x;b.y-=y;
        c.x-=x;c.y-=y;
       // printf("new points are %lld,%lld\n",a.x,a.y);
        //printf("new points are %lld,%lld\n",b.x,b.y);
       // printf("new points are %lld,%lld\n",c.x,c.y);
        L ab,bc,ca;
        ab = getline(a,b);
        bc = getline(b,c);
        ca = getline(c,a);
      //  printf("lines are %lldx + %lldy + %lld = 0\n",ab.a,ab.b,ab.c);
        // printf("lines are %lldx + %lldy + %lld = 0\n",bc.a,bc.b,bc.c);
         //printf("lines are %lldx + %lldy + %lld = 0\n",ca.a,ca.b,ca.c);
        int fir,sec,thi;
        fir=sec=thi=0;
        fir = cross(ab,my);
       // printf("line is ab\n");
        if(fir)
            {
           // printf("poinsts are %llf, %llf\n",x1,yy1);
             // printf("second poinsts are %llf, %llf\n",x2,yy2);
            if(betp(a,b))fir = 1;
            else fir = 0;
        }
        sec = cross(bc,my);
        // printf("line is bc\n");
        if(sec){
            
          //   printf("poinsts are %llf, %llf\n",x1,yy1);
            //  printf("second poinsts are %llf, %llf\n",x2,yy2);  
            if(betp(c,b))sec = 1;
            else sec = 0;
        }
        thi = cross(ca,my);
        // printf("line is ac\n");
        if(thi){
          //   printf("poinsts are %llf, %llf\n",x1,yy1);
            //  printf("second poinsts are %llf, %llf\n",x2,yy2);
            
            if(betp(a,c))thi = 1;
            else thi = 0;
            
        }
        if(fir||sec||thi)printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.225
hard
----------
PROBLEM STATEMENT:
The scoring system for this challenge is binary. Your score is zero unless you pass all tests.

Given [expression] coordinate. The point lying on the boundary of an ellipse or polygon is considered to be an inner point. 
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;
typedef double ld;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

struct TPoint {
    ld x, y;

    TPoint operator+(const TPoint &p) const {
        return {x + p.x, y + p.y};
    }

    TPoint operator-(const TPoint &p) const {
        return {x - p.x, y - p.y};
    }

    ld operator%(const TPoint &p) const {
        return x * p.y - y * p.x;
    }

    TPoint operator*(ld t) const {
        return {x * t, y * t};
    }

    ld operator~() const {
        return hypot(x, y);
    }

    TPoint norm() const {
        return *this * (1.0 / ~*this);
    }
}; 

struct TEll {
    TPoint a, b;
    ld l;

    ld eval(TPoint c) {
        return 2 * l - (~(a - c) + ~(b - c));
    }
};

vector< pair<TPoint, ld> > hp;
vector<TEll> ell;

pair<TPoint, ld> get_hp(TPoint a, TPoint b) {
    TPoint c = (b - a).norm();
    return {c, a % c};
}

ld f(TPoint p) {
    ld res = 1e9;
    for (auto h: hp) uin(res, -(p % h.fi - h.se));
    for (auto e: ell) uin(res, e.eval(p));
//    cerr << p.x << ' ' << p.y << ' ' << res << '\n';
    return res;
}

ld tern(vector<ld> &v, int k) {
    if (k == v.size()) return f({v[0], v[1]});
    ld l = -1e5, r = 1e5;
    ld alpha = 1.05;
    forn(its, 70) {
        ld m1 = (l * alpha + r) / (alpha + 1), m2 = (l + r * alpha) / (alpha + 1);
        v[k] = m1;
        ld f1 = tern(v, k + 1);
        v[k] = m2;
        ld f2 = tern(v, k + 1);
        if (f1 < f2) l = m1;
        else r = m2;
    }
    v[k] = l;
    return tern(v, k + 1);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int n;
    cin >> n;
    forn(i, n) {
        int m;
        cin >> m;
        vector<TPoint> v(m);
        forn(j, m) cin >> v[j].x >> v[j].y;
        TPoint p = v[0];
        v.pb(p);
        forn(j, m) hp.pb(get_hp(v[j], v[j + 1]));
    }

    int m;
    cin >> m;
    ell.resize(m);
    forn(i, m) cin >> ell[i].a.x >> ell[i].a.y >> ell[i].b.x >> ell[i].b.y >> ell[i].l;
    vector<ld> v(2);
    tern(v, 0);
//    assert(tern(v, 0) > -1e-9);
    cout << v[0] << '\n' << v[1] << '\n';

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
MATHEMATICS.226
expert
----------
PROBLEM STATEMENT:
Aaron is struggling with trigonometric functions, so his teacher gave him extra homework. Given an integer, [expression], he must answer the following question:


  What is the maximum value of [expression]?


Help Aaron by finding this maximal value and printing it correct to [expression] decimal places.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cmath>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	int i, n;
	double t, ans;
	scanf("%d", &n);	
	vector<double> u(n+1), d(n+1), m(n+1);
	u[0]=u[1]=-10.0;
	d[0]=d[1]=+10.0;
	for(i=2; i<n; i++) {
		t=cos(i/2.0-1);
		u[i]=max(u[i-2], t);
		d[i]=min(d[i-2], t);
		t=2*sin(i/2.0);
		m[i]=max(t*u[i], t*d[i]);		
	}	
	ans=-10;
	for(i=2; i<=n-1; i++) {
		t=m[i]+sin(n-i);
		ans=max(ans, t);
	}
	printf("%.9lf\n", ans);
	return 0;
}
----------
====================
----------
MATHEMATICS.227
hard
----------
PROBLEM STATEMENT:
Consider a regular polygon with N vertices labelled 1..N. In how many ways can you draw K diagonals such that no two diagonals intersect at a point strictly inside the polygon?&nbsp;A diagonal is a line segment joining two non adjacent vertices of the polygon.

Input: 
The first line contains the number of test cases T. Each of the next T lines contain two integers N and K.

Output: 
Output T lines, one corresponding to each test case. Since the answer can be really huge, output it modulo 1000003.

Constraints: 
1 
4 
1 

Sample Input: 
3 
4 1 
5 2 
5 3

Sample Output: 
2 
5 
0

Explanation:

For the first case, there are clearly 2 ways to draw 1 diagonal - 1 to 3, or 2 to 4. (Assuming the vertices are labelled 1..N in cyclic order). 
For the third case, at most 2 non-intersecting diagonals can be drawn in a 5-gon, and so the answer is 0.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;
const int MOD = 1000003;
vector<long long> f(MOD), g(MOD);

long long expn(long long x, int n) {
    if (n == 0) return 1;
    long long ans = expn(x, n>>1);
    ans = (ans * ans) % MOD;
    if (n & 1) ans = (x * ans) % MOD;
    return ans;
}

int main(int argc, char const *argv[]) {
    
    ios_base::sync_with_stdio(false);
    int ntest, N, K;
    
    f[0] = g[0] = 1;
    f[1] = g[1] = 1;
    for (int i = 2; i < MOD; ++i) {
        f[i] = (f[i-1] * i) % MOD;
        g[i] = expn(f[i], MOD-2);
    }
    cin >> ntest;
    for (; ntest > 0; --ntest) {
        cin >> N >> K;
        if (K > N-3) {
            printf("0\n");
            continue;
        }
        //assert((K+1)%MOD != 0 || (N-2)%MOD != 0);
        long long res = 0;
        if ((K+1) % MOD != 0) {
            res = expn(K+1, MOD-2);
            int m = N+K-1, p = N-3;
            while (m > 0) {
                int x = m % MOD, y = p % MOD, z = K % MOD;
                if (z > x || z > y) {
                    res = 0; break;
                }
                m /= MOD, p /= MOD, K /= MOD;
                res = (((res*f[x]*g[z]) % MOD)*g[x-z]) % MOD;
                res = (((res*f[y]*g[z]) % MOD)*g[y-z]) % MOD;
            }
        }
        else {
            res = expn(N-2, MOD-2);
            int m = N+K-1, p = N-2, q = K+1;
            while (m > 0) {
                int x = m % MOD, y = p % MOD, z = K % MOD, t = q % MOD;
                if (z > x || t > y) {
                    res = 0; break;
                }
                m /= MOD, p /= MOD, K /= MOD, q /= MOD;
                res = (((res*f[x]*g[z]) % MOD)*g[x-z]) % MOD;
                res = (((res*f[y]*g[t]) % MOD)*g[y-t]) % MOD;
            }
        }
        printf("%lld\n", res);
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.228
hard
----------
PROBLEM STATEMENT:
There are N points on X-Y plane with integer coordinates (xi, yi). You are given a set of polygons with all of its edges parallel to the axes (in other words, all angles of the polygons are 90 degree angles and all lines are in the cardinal directions. There are no diagonals). For each polygon your program should find the number of points lying inside it. A point located on the border of polygon is also considered to be inside the polygon.

Input Format 
The first line contains two integers N and Q. The next line contains N space-separated integer coordinates&nbsp;(xi,yi). Q queries follow. Each query consists of a single integer Mi in the first line, followed by&nbsp;Mi space separated integer coordinates (x[i][j],y[i][j]) specifying the boundary of the query polygon in clock-wise order.


Polygon is an alternating sequence of vertical line segments and horizontal line segments.
Polygon has Mi&nbsp;edges, where (x[i][j],y[i][j]) is connected to (x[i][(j+1)%Mi], y[i][(j+1)%Mi].
For each 0 
It is guaranteed that the polygon is not self-intersecting.


Output Format 
For each query output the number of points inside the query polygon in a separate line.

Constraints 
1 
1 
4 
-200,000 

Sample Input #1 
16 2 
0 0 
0 1 
0 2 
0 3 
1 0 
1 1 
1 2 
1 3 
2 0 
2 1 
2 2 
2 3 
3 0 
3 1 
3 2 
3 3 
8 
0 0 
0 1 
1 1 
1 2 
0 2 
0 3 
3 3 
3 0 
4 
0 0 
0 1 
1 1 
1 0

Sample Output #1: 
16 
4



Sample Input #2: 
6 1 
1 1 
3 3 
3 5 
5 2 
6 3 
7 4 
10 
1 3 
1 6 
4 6 
4 3 
6 3 
6 1 
4 1 
4 2 
3 2 
3 3

Sample Output #2: 
4


----------
TOP SOLUTION:
----------
#include <iostream>
#include <ctime>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <ctime>
using namespace std;

typedef long long int64;
const int N = 100000, X = 2000000001;
const int Q = 100000, PQ = 20;
struct Point {
    int x, y, idx;
    Point(int _x = 0, int _y = 0, int _idx = 0) {
        x = _x;
        y = _y;
        idx = _idx;
    }
} arr_x[N], arr_y[N];
struct VLineSegment {
    int x, y1, y2, idx, sign;
    VLineSegment(int _x = 0, int _y1 = 0, int _y2 = 0, int _sign = 1, int _idx = 0) {
        x = _x;
        y1 = _y1;
        y2 = _y2;
        sign = _sign;
        idx = _idx;
    }
    bool operator<(const VLineSegment& v) const {
        return x < v.x;
    }
} segs[Q * PQ];

struct TreeNode {
    int idx1, idx2, cnt;
    TreeNode *left, *right;
    TreeNode() { left = right = 0; cnt = 0; }
    ~TreeNode() { if(left) delete left; if(right) delete right; }
    
    void update_stat() {
        cnt = left->cnt + right->cnt;
    }
    
    void build(Point* arr, int from, int to, bool empty) {
        idx1 = from;
        idx2 = to;
        if(from == to) {
            if(!empty) {
                cnt = 1;
            } else { 
                cnt = 0;
            }
        } else {
            left = new TreeNode();
            right = new TreeNode();
            int mid = (from + to) / 2;
            left->build(arr, from, mid, empty);
            right->build(arr, mid + 1, to, empty);
            update_stat();
        }
    }
    void update(Point& p, bool add) {
        if(p.idx >= idx1 && p.idx <= idx2) {
            if(idx1 != idx2) {
                left->update(p, add);
                right->update(p, add);
                update_stat();
            } else {
                if(add) {
                    cnt = 1;
                } else {
                    cnt = 0;
                }
            }
        }
    }
    int query(int ya, int yb) {
        int y1 = arr_y[idx1].y, y2 = arr_y[idx2].y;
        if(ya <= y1 && y2 <= yb) {
            return cnt;
        } else if(max(ya, y1) <= min(yb, y2)) {
            return left->query(ya, yb) + right->query(ya, yb);
        }
        return 0;
    }
};

bool cmp_x(const Point& a, const Point& b) {
    return a.x < b.x;
}
bool cmp_y(const Point& a, const Point& b) {
    return a.y < b.y;
}

void calc_ys(int x1, int y1, int x2, int y2, int x3, int sign, int& ya, int& yb) {
    if(x2 < x3) {
        yb = 2 * y2 - sign;
    } else {
        yb = 2 * y2 + sign;
    }
    if(x2 < x1) {
        ya = 2 * y1 + sign;
    } else {
        ya = 2 * y1 - sign;
    }
}

bool process_polygon(int* x, int* y, int cnt, int &idx, int i) {
    for(int j = 0; j < cnt; j ++) {
        //cerr << x[(j + 1) % cnt] - x[j] << "," << y[(j + 1) % cnt] - y[j] << endl;
        if(x[j] == x[(j + 1) % cnt]) {
            int _x, y1, y2, sign;
            if(y[j] < y[(j + 1) % cnt]) {
                _x = x[j] * 2 - 1;
                sign = -1;
                calc_ys(x[(j + cnt - 1) % cnt], y[j], x[j], y[(j + 1) % cnt], x[(j + 2) % cnt], sign, y1, y2);
            } else {
                _x = x[j] * 2 + 1;
                sign = 1;
                calc_ys(x[(j + 2) % cnt], y[(j + 2) % cnt], x[j], y[j], x[(j + cnt - 1) % cnt], sign, y1, y2);
            }
            segs[idx++] = VLineSegment(_x, y1, y2, sign, i);
        }
    }
}
int results[Q];

int n, q, c;

int main() {
    int cl = clock();
    cin >> n >> q;
    for(int i = 0; i < n; i ++) {
        cin >> arr_y[i].x >> arr_y[i].y;
        arr_y[i].x *= 2;
        arr_y[i].y *= 2;
    }
    int idx = 0, cnt, x[PQ], y[PQ];
    for(int i = 0; i < q; i ++) {
        cin >> cnt;
        for(int j = 0; j < cnt; j ++) cin >> x[j] >> y[j];
        process_polygon(x, y, cnt, idx, i);
    }
    sort(segs, segs + idx);
    memset(results, 0, sizeof results);
    sort(arr_y, arr_y + n, cmp_y);
    for(int i = 0; i < n; i ++) {
        arr_y[i].idx = i;
        arr_x[i] = arr_y[i];
    }
    sort(arr_x, arr_x + n, cmp_x);
    TreeNode tleft;
    tleft.build(arr_y, 0, n - 1, true);
    for(int i = 0, j = 0; i < idx; i ++) {
        for(; j < n && arr_x[j].x <= segs[i].x; j ++) {
            tleft.update(arr_x[j], true);
        }
        int qcnt = tleft.query(segs[i].y1, segs[i].y2);
        //cerr << segs[i].x * 0.5 << ", " << segs[i].y1 * 0.5 << ", " << segs[i].y2 * 0.5 << " = " << qcnt << " * " << segs[i].sign << endl;
        results[segs[i].idx] += qcnt * segs[i].sign;
    }
    for(int i = 0; i < q; i ++) {
        cout << results[i] << endl;
    }
    cerr << (clock() - cl) * 0.001 << endl;
    return 0;
}

----------
====================
----------
MATHEMATICS.229
hard
----------
PROBLEM STATEMENT:
There is an infinite integer grid where &nbsp;N&nbsp;people live in N different houses. They decide to create a meeting point at one person's house.&nbsp;  

From any given cell, all 8 adjacent cells can be reached in 1 unit of time, e.g. (x,y) can be reached from (x-1,y+1) in one unit of time. Find a common meeting place which minimizes the combined travel time of everyone.  

Input Format 
A positive integer N that denotes N houses or people.

The following&nbsp;N&nbsp;lines will contain two integers x,y each that denote the coordinates of the respective house.  

Output Format 
An integer, M,&nbsp;that denotes the minimum combined travel time of everyone.  

Constraints 
N 5 
The absolute value of each co-ordinate in the input will be at most 109

HINT:&nbsp;You may need 64-bit integer.

Input #1  

4 
0 1
2 5 
3 1 
4 0 


Output #1 

8
 

Explanation 
The houses will have a travel-sum of 11, 13, 8, or 10. 8 is the minimum.

Input #2   

6 
12 -14 
-3 3 
-14 7 
-14 -3 
2 -12 
-1 -6


Output #2:

54
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */

#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

struct point
{
    long long x,y;
};

int main()
{
    int num;
    int i;
    
    vector<point> points;
    
    cin>>num;
    
    point hold;
    
    for(i=0; i<num; ++i)
    {
        cin>>hold.x>>hold.y;
        
        points.push_back(hold);
    }
    
    double ave_x, ave_y;
    
    for(i=0; i<points.size(); ++i)
    {
        ave_x += points[i].x;
        ave_y += points[i].y;
    }
    
    ave_x /= points.size();
    ave_y /= points.size();
    
    double diff_x, diff_y;
    
    diff_x = points[0].x - ave_x;
    diff_y = points[0].y - ave_y;
    
    int best = 0;
    double best_dist = diff_x*diff_x + diff_y*diff_y;
    
    double hold_dist;
    
    for(i=1; i<points.size(); ++i)
    {
        diff_x = points[i].x - ave_x;
        diff_y = points[i].y - ave_y;
        
        hold_dist = diff_x*diff_x + diff_y*diff_y;
        
        if(hold_dist < best_dist)
        {
            best_dist = hold_dist;
            best = i;
        }
    }
    
    point best_pt = points[best];
    
    long long total_dist = 0;
    
    for(i=0; i<points.size(); ++i)
    {
        diff_x = fabs(points[i].x-best_pt.x);
        diff_y = fabs(points[i].y-best_pt.y);
        
        total_dist += (diff_x < diff_y)?diff_y:diff_x;
    }
    
    cout<<total_dist<<endl;
}
----------
====================
----------
MATHEMATICS.230
hard
----------
PROBLEM STATEMENT:
&nbsp;Adam and Martha are planning to leave the city after their retirement and build a house in a huge land belonging to their family. To keep everyone happy, they want to build the house at a location having distance&nbsp;_a*d1_&nbsp;from aunt Kimberly's house, where&nbsp;a&nbsp;is some ratio and&nbsp;d1&nbsp;is the distance of that location to uncle Bob's house. Also, the house should be at a distance&nbsp;_b*d2_&nbsp;from uncle Jack's house where b is some ratio and&nbsp;d2&nbsp;is the distance of the location to aunt Janet's house.

You need to help them find the location of their house.

Input Format 
The first line of input contains two integers a and b (the ratios above). In the next four lines, there are 4 pairs of integers that indicate the coordinates of Kimberly's, Bob's, Jack's, and Janet's houses, respectively.

Output Format 
You must output the coordinate of house with exactly two points after decimal point (rounded to closest one hundredth). If there is no location&nbsp;satisfying&nbsp;the above constraints, output Impossible! If there are more than one possible locations, output a location with minimum &nbsp;x-coordinate and among the ones having the minimum x-coordinate, a location with minimum y-coordinate.&nbsp;

Constraints  

1 a, b 

-1000 

Sample Input  

3 4

4 0

0 0

-2 -4

-2 -1


Sample Output  

-2.00 0.00

Explanation 
As required, the point (-2.00, 0.00) has distance 2 from Bob's house and distance 3*2=6 from Kimberly's house. It also has distance 1 from Janet's house and distance 4*1=4 from Jack's house.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <complex>
#include <vector>
#include <cmath>
#include <algorithm>

using namespace std;

const double eps = 1e-6;

typedef complex<double> point;

struct circle 
{
    point c; double r;
    circle(point c, double r):c(c),r(r){}
    circle(){}
};

// Intersects two circles and intersection points are in 'inter'
// -1-> outside, 0-> inside, 1-> tangent, 2-> 2 intersections
int circ_circ_inter(circle &a, circle &b, vector<point> &inter) {
    double d2 = norm(b.c-a.c), rS = a.r+b.r, rD = a.r-b.r;
    if (d2 > rS*rS) return -1;
    if (d2 < rD*rD) return 0;
    double ca = 0.5*(1 + rS*rD/d2);
    point z = point(ca, sqrt((a.r*a.r/d2)-ca*ca));
    inter.push_back(a.c + (b.c-a.c)*z);
    if(abs(z.imag())>eps)
        inter.push_back(a.c + (b.c-a.c)*conj(z));
    return inter.size();
}


int main()
{
	double a, b;
	cin >> a >> b;
	
	double x, y;
	cin >> x >> y;
	point kimberly(x,y);

	cin >> x >> y;
	point bob(x,y);

	cin >> x >> y;
	point jack(x,y);

	cin >> x >> y;
	point janet(x,y);

	point c1 = (a * a * bob - kimberly) / (a * a - 1);
	double r12 = (norm(kimberly) - a * a * norm(bob)) / (a * a - 1) + norm(c1);
	circle circle1(c1, sqrt(r12));
	point c2 = (b * b * janet - jack) / (b * b - 1);
	double r22 = (norm(jack) - b * b * norm(janet)) / (b * b - 1) + norm(c2);
	circle circle2(c2, sqrt(r22));

	vector<point> res;
	if (c1 == c2 && abs(r12 - r22) < eps)
	{
		if (c1.real() * c1.real() > r12)
		{
			res.push_back(c1 + sqrt(r12));
			res.push_back(c1 - sqrt(r12));
		}
		else
			res.push_back(point(0.00, c1.imag() - sqrt(r12 - c1.real() * c1.real())));
	}
	else
		circ_circ_inter(circle1, circle2, res);
	
	if (res.size() == 0)
		cout << "Impossible!" << endl;
	else
	{
		if (res.size() > 1)
			if (res[1].real() < res[0].real() || (abs(res[1].real() - res[0].real()) < eps && res[1].imag() < res[0].imag()))
			{
				point ptmp = res[0];
				res[0] = res[1];
				res[1] = ptmp;
			}
			
		cout.setf(ios::showpoint | ios::fixed);
		cout.precision(2);
		cout << ((abs(res[0].real()) < eps) ? 0.00 : res[0].real()) << ' ' << ((abs(res[0].imag()) < eps) ? 0.00 : res[0].imag()) << endl;
	}
	
	/*
	cerr << "------------------------------" << endl;
	cerr << c1 << endl;
	cerr << sqrt((norm(kimberly) - a * a * norm(bob)) / (a * a - 1) + norm(c1)) << endl;
	cerr << c2 << endl;
	cerr << sqrt((norm(jack) - b * b * norm(janet)) / (b * b - 1) + norm(c2)) << endl;
	for (int i = 0; i < res.size(); i++)
		cerr << res[i] << endl;
	*/	
	return 0;
}

----------
====================
----------
MATHEMATICS.231
medium
----------
PROBLEM STATEMENT:
Hey buddy,

How are you? Last night I saw you programming on Hackerrank in my burger restauraunt. So I wonder if you can help me out on a problem I've been struggling with for like 10 hours.

It is called "The Challenge" and for some reasons the online judge always gives me TLE (Time Limit Exceeded). My code and the important part of the problem are attached with this email. I omitted the problem statement because it was three A4 sheets long and included a very boring story. 

I want you to send me an AC (Accepted) code so that I can learn from you and figure out why my implementation is so slow.

Your favourite burger cook,

Jim

PS: Tuesday is "Happy Burgers Day" so there is a -[expression]% discount on all burgers!

the_challenge.psc

### author: jim
### problem: the challenge
### status: TLE
### a..b : iterate from a to b ( both inclusive )
define n, d as integers
define H as an integer array
define X as a two-dimensional integer array

function m(i, j)
   for k = 1..d
      dist = dist + abs(X[i][k] - X[j][k])

function main()
  read n and d from input
  for i = 1..n
     read H[i]
    for j = 1..d
      read X[i][j]  
  sum = 0
  for i = 1..n
      for j = i+1..n
       sum = sum + H[i] * H[j] * m(i, j)
  print sum mod 1000000009


the_challenge.pdf

Input Format

On the first line, you will be given [expression]. 

Output Format

Print the answer to the challenge modulo [expression] on a single line.

Constraints


[expression]
[expression]
[expression]
[expression]


Sample Input

3 3
5 1 2 3
7 2 3 4
8 4 5 6


Sample Output

801


Explanation

Compare point 1 and point 2: Our first term of the sum is [expression].

Compare point 1 and point 3: The second term is [expression]

Compare point 2 and point 3: The final term will be [expression]

So the answer is [expression].
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

const long long MOD=1000000009;
int N, D;
int H[300100];
int X[300100][4];
pair<int, int> A[300100];

int main()
{
    scanf("%d%d", &N, &D);
    for(int i=1; i<=N; i++)
    {
        scanf("%d", H+i);
        for(int j=0; j<D; j++)
            scanf("%d", X[i]+j);
    }
    long long ans=0;
    for(int i=0; i<D; i++)
    {
        for(int j=1; j<=N; j++)
            A[j]=make_pair(X[j][i], j);
        sort(A+1, A+1+N);
        long long SHj=0, tmp, tmp2, suma=0;
        for(int j=1; j<=N; j++)
        {
            long long xx=A[j].first;
            long long ii=A[j].second;
            SHj=(SHj+(long long)H[ii])%MOD;
            suma=((suma+(long long)H[ii]*xx%MOD)%MOD+MOD)%MOD;
            tmp2=(SHj*xx%MOD+MOD)%MOD;
            tmp=((long long)H[ii]*((tmp2-suma+MOD)%MOD)%MOD)%MOD;
            ans=(ans+tmp)%MOD;
        }
    }
    printf("%lld\n", ans);
    return 0;
}

----------
====================
----------
MATHEMATICS.232
advanced
----------
PROBLEM STATEMENT:
Little Nina is learning to read. Her favorite letter is N, and she looks for it everywhere.

There is a set of [expression] (in that order). Nina says that these four points form the letter N if all the following conditions are met:


[expression] (in this order).
[expression] (in this order).
Angle [expression] 
Angle [expression]


How many Ns can she find? We consider letters to be sets of four points, and two letters differ if the value of one or more of the points (i.e., [expression] values, then they are different letters. In addition, letters that can be transformed into each other only by reversing point order are considered to be the same letter. 
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <cctype>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <set>
#include <map>
#include <sstream>
#include <iostream>
#include <functional>

using namespace std;

#define forn(i, n) for (int i = 0; i < (int)(n); i++)
#define forit(i, a) for (__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)
#define pb push_back
#define mp make_pair
#define sz(a) (int)(a).size()
#define all(a) (a).begin(), (a).end()

typedef long long ll;
typedef vector <int> vi;
typedef pair <int, int> pii;

#define TOP 2500

int pts[TOP][2];

short counts[TOP][TOP];
int idx[TOP*2];  // Indirection from sorted order to original index
int angles[TOP*2][2]; // Angle is [0]/[1] = dy/dx starting at 0, going up to 1 for 90 degrees	
int quadrants[TOP*2];
	
// Is angle(i)<angle(j)
// Should i come before j
bool cmp(int i, int j) {
	if (quadrants[i]<quadrants[j])
		return true;
	if (quadrants[i]>quadrants[j])
		return false;
	return (angles[j][0]*angles[i][1] - angles[i][0]*angles[j][1]) > 0;
}

int main(int argc,char *argv[])
{
	ll total = 0;
	int N;
	cin >> N;
	for(int n=0;n<N;n++) {
		int x,y;
		cin >> x >> y;
		pts[n][0] = x;
		pts[n][1] = y;
	}
	forn(b,N) {
		int bx=pts[b][0];
		int by=pts[b][1];
		int num=0;
		// Prepare angles
		forn(i,N) {
			int dx = pts[i][0]-bx;
			int dy = pts[i][1]-by;
			int quadrant = 0;
			if (dx==0 && dy==0)
				continue;
			while(dx<=0 || dy<0) {
				int dx2 = dy;
				int dy2 = -dx;
				dy = dy2;
				dx = dx2;
				quadrant++;
			}
			angles[i][0] = dy;
			angles[i][1] = dx;
			quadrants[i] = quadrant;
			angles[i+N][0] = dy;
			angles[i+N][1] = dx;
			quadrants[i+N] = quadrant+4;
			
			idx[num++]=i;
		}
		// Sort
		sort(idx,idx+num,cmp);
		// Add in double angles
		forn(i,num) idx[num+i]=idx[i]+N;
		forn(i,2*num) {
			int id = idx[i];
		}
		// Linear scan
		int start_i = 0;
		int end_i = 0;
		for(int i=num;i<num*2;i++) {
			int id=idx[i];
			int start = 2*TOP-1;
			angles[start][0] = angles[id][0];
			angles[start][1] = angles[id][1];
			quadrants[start] = quadrants[id]-1;
			// We want all points with start <= angle < end
			while(end_i<i && cmp(idx[end_i],id))  
				end_i++;
			while(start_i<end_i && cmp(idx[start_i],start))  
				start_i++;
			counts[b][id-N] = end_i - start_i;
		}
	}
	forn(b,N) {
		forn(c,b) {
			ll A = counts[b][c];
			ll D = counts[c][b];
			total += A*D;
		}
	}
	cout << total << endl;
	return 0;
}

----------
====================
----------
MATHEMATICS.233
advanced
----------
PROBLEM STATEMENT:
You are given two arrays A and B of length N. Let S be the set of integers from 1 to N. Can you find the maximum possible value of (Ai1+Ai2+...+Aik)2+(Bi1+Bi2+...+Bik)2 where {i1,i2...ik} is a non-empty subset of S?

Input Format 
The first line contains a single integer T, denoting the number of test cases. 
T testcases follow, each test case given in following format.  

N  
A1 A2 ... AN  
B1 B2 ... BN  


Output Format 
For each test case, output the maximum possible value in one line.  

Constraints 
1 
1 
-106 i, Bi 6  

Sample Input  

1  
2  
-1 5  
4 -5  


Sample Output  

50


Explanation 
All possible non-empty subsets for N = 2 of S = {1,2} are {1}, {2} and {1,2}. The maximum possible values of the above equation now are 


(-1)2 + (4)2 = 17  
(5)2 + (-5)2 = 50  
(-1 + 5)2 + (4 - 5)2 = 17


hence 50. 

Timelimits

Timelimits for this challenge can be seen here
----------
TOP SOLUTION:
----------
#include<iostream>
#include<cmath>

using namespace std;

struct point{
long long A,B;
double arctang;
}P[10000];
long max(long a,long b){
    if(a<b) return b;
    return a;

}

void quickSort(point arr[], int left, int right)
 {
  int i = left, j = right;
  point tmp;
  point pivot = arr[(left + right) / 2];

  /* partition */
  while (i <= j) {
        while (arr[i].arctang < pivot.arctang)
              i++;
        while (arr[j].arctang > pivot.arctang)
              j--;
        if (i <= j) {
              tmp = arr[i];
              arr[i] = arr[j];
              arr[j] = tmp;
              i++;
              j--;
    }
}
/* recursion */
if (left < j)
    quickSort(arr, left, j);
if (i < right)
        quickSort(arr, i, right);
}


int main(){
	int t,n;
	cin >> t;
    int k=0;
	while(k<t){
		cin >> n;
		for(int i = 0; i < n; i++) 
               cin >> P[i].A;
        for(int i = 0; i < n; i++){
               cin >> P[i].B; P[i].arctang=atan2(P[i].B,P[i].A);
        }
        quickSort(P,0,n-1); 
        long long best = 0;
		for(int i = 0; i < n; i++){
			long long tempa = 0, tempb = 0;
			for(int j = i; j < n+i; j++){   //starting calc first from all indexes
                tempa += P[j%n].A, tempb += P[j%n].B;
                //cout<<tempa<<" "<<tempb<<"\n";
				best = max(best, tempa*tempa + tempb*tempb);
            }
		}
		cout <<best<< "\n";
        ++k;
	}
}



----------
====================
----------
MATHEMATICS.234
advanced
----------
PROBLEM STATEMENT:
There are [expression]. The slope of each line is negative, i.e. it goes from upper-left to lower-right.

There are [expression] is under it. If there is, then the answer is YES, otherwise NO.

As you know, any line splits an infinite plane into two regions. The point [expression]. If the point lies on the line it does not count.

Input Format 
The first line contains [expression].  

The next line contains [expression].  

Output Format 
For each query, output one line containing either YES or NO.  

Constraints 
[expression] (Number of lines) 
[expression] (Number of queries) 
[expression] 
[expression] 
[expression] 
[expression] 
[expression]  

Sample Input  

2
-1 3
-2 -4
3
1 2 0 0
1 1 0 0
2 2 0 0


Sample Output  

YES
YES
NO


Explanation 
The image shows the two lines of the sample input.



Time Limits: C/C++ 1 sec, Java/C# 2 sec, other languages follow standard TL given in Environment
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <vector>
#include <set>
#include <map>
#include <cassert>
#include <ctime> 
#include <cmath>
#include <string>
#include <cstring>
#include <queue>
using namespace std;

#define f first
#define s second
#define mp make_pair
#define pb push_back
#define pii pair<int, int>
#define vi vector<int>
#define all(v) (v).begin(), (v).end()
#define forit(it,v) for (__typeof(v.begin()) it = v.begin(); it != v.end(); ++it)
#define f0(a) memset(a, 0, sizeof(a))
#define ll long long
#define SZ(M) (int)M.size()
const int maxn = (int)1e6;
struct Line {
	int a, b;
	Line() {
	}
	void read() {
		scanf("%d%d", &a, &b);
	}
	bool operator < (Line o) const {	
		return a < o.a;
	}
};

struct Tree { 
	vector<Line> lines;
	vector<Line> M;
	vector<double> X;
	
	Tree() {}

	double getX(Line u, Line v) {
		return (u.b - v.b + 0.0) / (v.a - u.a + 0.0);
	}

	void add(Line l) {
		while (SZ(M) >= 2 && getX(l, M[SZ(M) - 2]) <=
				getX(M[SZ(M) - 1], M[SZ(M) - 2])) {
			M.pop_back();
		}
		M.pb(l);
	}

	void build() {
		sort(all(lines));
		forit(it, lines) add(*it);
		X.pb(-1e18);
		for (int i = 0; i + 1 < SZ(M); ++i) 
			X.pb(getX(M[i], M[i + 1]));
	}
	double find(double x) {
		int p = upper_bound(all(X), x) - X.begin() - 1;
		return M[p].a * x + M[p].b;
	}
} T[maxn*2+10];
int n;

inline bool Ok(int w, int x, int y) {	
	return (T[w].find(x) > y);
}
bool check(int l, int r, int x, int y) {
	l += n; r += n;
	while (l <= r) {
		if ((l & 1) && Ok(l, x, y)) return true;
		if (!(r & 1) && Ok(r, x, y)) return true;
		l = (l + 1) / 2;
		r = (r - 1) / 2;
	}
	return false;
}

int main() {
	scanf("%d", &n);
	for (int i = 0; i < n; ++i) {
		Line l;
		l.read();
		T[i + n].lines.pb(l);
	}
	
	for (int i = n - 1; i >= 1; --i) {
		T[i].lines = T[i + i].lines;
		//check
		T[i].lines.insert(T[i].lines.begin(), all(T[i + i + 1].lines));
	}

	for (int i = 1; i <= n + n; ++i)
		T[i].build();

	int qn;
	scanf("%d", &qn);
	for (int i = 0; i < qn; ++i) {
		int l, r, x, y;
		scanf("%d%d%d%d", &l, &r, &x, &y);
		if (check(l - 1, r - 1, x,  y)) 
			puts("YES");
		else
			puts("NO");
	}
	return 0;
}


----------
====================
----------
MATHEMATICS.235
advanced
----------
PROBLEM STATEMENT:
You are given a regular N-gon with vertices at (cos(2πi / N), sin(2πi / N)), ∀ i ∈ [0,N-1]. Some of these vertices are blocked and all others are unblocked. We consider triangles with vertices at the vertices of N-gon and with at least one vertex at unblocked point. Can you find how many pairs of such triangles have equal area?

Input Format 
The first line of input contains single integer T - number of testcases. 2T lines follow. 
Each testcase has two lines. 
The first line of testcase contains a single integer N - the number of vertices in N-gon. The second line contains string S with length N. If S[j] equals '1' it means that the vertex (cos(2πj / N), sin(2πj / N)) is unblocked, and if S[j] equals '0' it means that the vertex (cos(2πj / N), sin(2πj / N)) is blocked.

Output Format 
For each testcase output single line with an answer.

Constraints 
1 
3 4    

There will be no more than 50 blocked vertices in each of the testcase.  

Sample Input  

1
4
1111


Sample Output  

6


Explanation

The testcase given is a square and there are 4 triangles that have the same area. So, the number of pairs are 4C2 = 6. 
----------
TOP SOLUTION:
----------
#include <iostream>
#include <string>
#include <cstring>
#include <cstdio>
#include <set>
#include <map>
#include <vector>
#include <algorithm>
#include <cmath>
#include <bitset>
#include <queue>
#include <ctime>
#pragma comment(linker, "/STACK:256000000")

using namespace std;

const int maxN = 11000;

int get_total(int a, int b, int c) {
  int n = a + b + c;
  if (a == b && b == c) {
    return n / 3;
  }
  if (a == b) {
    return n;
  }
  if (b == c) {
    return n;
  }
  return 2 * n;
}

void order(int& a, int& b, int& c) {
  if (a > b) swap(a, b);
  if (a > c) swap(a, c);
  if (b > c) swap(b, c);
}

long long total[maxN];

long long total_equal(int n) {
  if (n == 3) {
    return 0;
  }
  if (n == 4) {
    return 6;
  }

  long long partitions = total[n];

  int equalsides = 0;
  for (int i = 1; 2 * i < n; ++i) {
    ++equalsides;
  }
  partitions -= equalsides;

  long long cn = 2 * n;
  long long value = (cn * (cn - 1)) / 2;
  long long result = partitions * value;

  for (int i = 1; 2 * i < n; ++i) {
    int rest = n - 2 * i;
    int a = i, b = i, c = n - 2 * i;
    order(a, b, c);
    long long cn = get_total(a, b, c);
    result += (cn * (cn - 1)) / 2;
  }

  if (n % 4 == 0) {
    for (int a = 1; a < n / 4; ++a) {
      int b = n / 4 - a;
      if (a >= b) {
        break;
      }

      int na1 = a, nb1 = 2 * b, nc1 = n - na1 - nb1;
      int na2 = b, nb2 = 2 * a, nc2 = n - na2 - nb2;
      order(na1, nb1, nc1);
      order(na2, nb2, nc2);

      result += get_total(na1, nb1, nc1) * get_total(na2, nb2, nc2);
    }
  }

  if (n % 24 == 0) {
    result += 4LL * n * n;
  }
  if (n % 30 == 0) {
    result += 8LL * n * n;
  }
  return result;
}

long long solve(int n, const string& s) {
  vector <int> unused;
  for (int i = 0; i < n; ++i) {
    if (s[i] == '0') {
      unused.push_back(i);
    }
  }

  long long result = total_equal(n);

  map<pair<int, int>, int> lengths;

  for (int i = 0; i < unused.size(); ++i) {
    for (int j = i + 1; j < unused.size(); ++j) {
      for (int k = j + 1; k < unused.size(); ++k) {
        int a = unused[j] - unused[i];
        int b = unused[k] - unused[j];
        int c = n - a - b;
        order(a, b, c);
        ++lengths[make_pair(a, b)];
      }
    }
  }

  long long inpart = 0;

  for (map<pair<int, int>, int>::iterator it = lengths.begin(); it != lengths.end(); ++it) {
    int a = it->first.first;
    int b = it->first.second;
    int c = n - a - b;
    int ctotal = it->second;
    result -= (ctotal * (ctotal - 1)) / 2;

    int totaltype = get_total(a, b, c) - ctotal;

    if (n % 4 == 0) {
      if (b % 2 == 0) {
        int na = 2 * a, nb = b / 2, nc = n - na - nb;
        if (nc > 0) {
          if (a + b / 2 == n / 4) {
            order(na, nb, nc);
            if (!(na == a && nb == b)) {
              totaltype += get_total(na, nb, nc);
              if (lengths.count(make_pair(na, nb))) {
                totaltype -= lengths[make_pair(na, nb)];
                inpart += ctotal * lengths[make_pair(na, nb)];
              }
            }
          }
        }
      } 
      if (a % 2 == 0 && a != b) {
        int na = a / 2, nb = 2 * b, nc = n - na - nb;
        if (nc > 0) {
          if (b + a / 2 == n / 4) {
            order(na, nb, nc);
            if (!(na == a && nb == b)) {
              totaltype += get_total(na, nb, nc);
              if (lengths.count(make_pair(na, nb))) {
                totaltype -= lengths[make_pair(na, nb)];
                inpart += ctotal * lengths[make_pair(na, nb)];
              }
            }
          }
        }
      }
    }

    if (n % 24 == 0) {
      int k = n / 24;
      if (a % k == 0 && b % k == 0 && c % k == 0) {
        int na = a / k, nb = b / k, nc = c / k;

        if (na == 3 && nb == 6 && nc == 15) {
          int ua = 2 * k, ub = 10 * k, uc = 12 * k;
          totaltype += get_total(ua, ub, uc);
          if (lengths.count(make_pair(ua, ub))) {
            totaltype -= lengths[make_pair(ua, ub)];
            inpart += ctotal * lengths[make_pair(ua, ub)];
          }
        }

        if (na == 2 && nb == 10 && nc == 12) {
          int ua = 3 * k, ub = 6 * k, uc = 15 * k;
          totaltype += get_total(ua, ub, uc);
          if (lengths.count(make_pair(ua, ub))) {
            totaltype -= lengths[make_pair(ua, ub)];
            inpart += ctotal * lengths[make_pair(ua, ub)];
          }
        }
      }
    }

    if (n % 30 == 0) {
      int k = n / 30;
      if (a % k == 0 && b % k == 0 && c % k == 0) {
        int na = a / k, nb = b / k, nc = c / k;

        if (na == 1 && nb == 11 && nc == 18) {
          int ua = 2 * k, ub = 6 * k, uc = 22 * k;
          totaltype += get_total(ua, ub, uc);
          if (lengths.count(make_pair(ua, ub))) {
            totaltype -= lengths[make_pair(ua, ub)];
            inpart += ctotal * lengths[make_pair(ua, ub)];
          }
        }

        if (na == 2 && nb == 6 && nc == 22) {
          int ua = 1 * k, ub = 11 * k, uc = 18 * k;
          totaltype += get_total(ua, ub, uc);
          if (lengths.count(make_pair(ua, ub))) {
            totaltype -= lengths[make_pair(ua, ub)];
            inpart += ctotal * lengths[make_pair(ua, ub)];
          }
        }

        if (na == 4 && nb == 12 && nc == 14) {
          int ua = 6 * k, ub = 7 * k, uc = 17 * k;
          totaltype += get_total(ua, ub, uc);
          if (lengths.count(make_pair(ua, ub))) {
            totaltype -= lengths[make_pair(ua, ub)];
            inpart += ctotal * lengths[make_pair(ua, ub)];
          }
        }

        if (na == 6 && nb == 7 && nc == 17) {
          int ua = 4 * k, ub = 12 * k, uc = 14 * k;
          totaltype += get_total(ua, ub, uc);
          if (lengths.count(make_pair(ua, ub))) {
            totaltype -= lengths[make_pair(ua, ub)];
            inpart += ctotal * lengths[make_pair(ua, ub)];
          }
        }
      }
    }
    result -= ctotal * totaltype;
  }
  result -= inpart / 2;
  return result;
}

void solve_test() {
  int n;
  cin >> n;
  string s;
  cin >> s;
  long long res = solve(n, s);
  cout << res << endl;
}

long long get_n(int n) {
  int res = 0;
  for (int i = 1; i <= n; ++i) {
    for (int j = i; j + i <= n && j <= n - i - j; ++j) {
      ++res;
    }
  }
  return res;
}

void precalc() {
  for (int i = 0; i < 10; ++i) {
    total[i] = get_n(i);
  }
  for (int i = 10; i < maxN; ++i) {
    total[i] = 1 + total[i - 2] + total[i - 3] - total[i - 5];
  }
}

int main() {
  //freopen("input.txt", "r", stdin);
  //freopen("output.txt", "w", stdout);

  ios_base::sync_with_stdio(false);

  precalc();

  int t;
  cin >> t;
  for (int i = 0; i < t; ++i) {
    solve_test();
  }

  return 0;
}
----------
====================
----------
MATHEMATICS.236
hard
----------
PROBLEM STATEMENT:
Sevenkplus has a regular polygon. Each vertex of the polygon has a color, either white or black. Sevenkplus wants to count the number of isosceles triangles whose vertices are vertices of the regular polygon and have the same color.  

Input Format 
The first line contains an integer T. T testcases follow. 
For each test case, there is only one line, which consists of a 01-string with length = 3. Number of vertices n of the regular polygon equals length of the string. The string represents color of vertices in clockwise order. 0 represents white and 1 represents black. 

Output Format 
For each test case, output one line in the format Case #t: ans, where t is the case number (starting from 1), and ans is the answer. 

Constraints 
Sum of all n in the input 

Sample Input

5
001
0001
10001
111010
1101010


Sample Output

Case 1: 0
Case 2: 1
Case 3: 1
Case 4: 2
Case 5: 3


Explanation

In case 5, indices of vertices of the three monochromatic isosceles triangles are (0,3,5), (1,3,5) and (2,4,6) (assuming indices start from 0). 

Timelimits 
Timelimits for this challenge is given here
----------
TOP SOLUTION:
----------
#include<cstdio>
#include<algorithm>
#include<stack>
#include<queue>
#include<vector>
#include<string>
#include<string.h>
#include<cstdlib>
#include<ctime>
#include<cmath>
#include<complex>
#include<map>
#include<set>
#include<bitset>
#include<iostream>
#include<sstream>
#define fi first
#define se second
#define rep(i,n) for(int i = 0; i < n; i++)
#define rrep(i,n) for(int i = 1; i <= n; i++)
#define drep(i,n) for(int i = n-1; i >= 0; i--)
#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)
#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)
#define rng(a) a.begin(),a.end()
#define maxs(x,y) x = max(x,y);
#define mins(x,y) x = min(x,y);
#define pb push_back
#define sz(x) (int)(x).size()
#define popcount __builtin_popcount
#define snuke srand((unsigned)clock()+(unsigned)time(NULL))
using namespace std;
typedef long long int ll;
typedef pair<int,int> P;
typedef vector<int> vi;

const int MX = 100005, INF = 1000000000;
const ll LINF = 1000000000000000000ll;
const double eps = 1e-10;
const int dx[] = {-1,0,1,0}, dy[] = {0,-1,0,1}; //<^>v

string s;
int ts; ll n;

int main(){
	cin >> ts;
	bool z = false;
	rrep(ti,ts){
		cin >> s;
		n = s.size();
		ll ans = 0;
		
		//0
		if(n&1){
			ans = n*(n-1)/2;
		} else {
			ans = n*(n/2-1)*2/2;
		}
		if(n%3 == 0) ans -= n/3*2;
		if(z) cerr << ans << endl;
		
		//1
		ll c = 0;
		rep(i,n) if(s[i] == '1') c++;
		ll base = (n-1)/2;
		if(n&1){
			base += (n-1);
		} else {
			base += (n/2-1)*2;
		}
		if(n%3 == 0) base -= 2;
		
		ans -= base*c;
		if(z) cerr << base << endl;
		if(z) cerr << c << endl;
		
		//2
		ll t = c*(c-1)/2*2;
		if(n&1){
			t += c*(c-1)/2;
		} else {
			ll d = 0;
			for(int i = 0; i < n; i+=2) if(s[i] == '1') d++;
			ll e = c-d;
			t += d*(d-1)+e*(e-1);
			
			rep(i,n/2) if(s[i] == '1' && s[i+n/2] == '1') t -= 2;
		}
		if(n%3 == 0){
			rep(i,n){
				if(s[i] == '1' && s[(i+n/3)%n] == '1') t -= 2;
			}
		}
		
		ans += t;
		if(z) cerr << t << endl;
		
		printf("Case %d: ",ti);
		printf("%lld\n",ans);
	}
	
	return 0;
}






----------
====================
----------
MATHEMATICS.237
expert
----------
PROBLEM STATEMENT:
There is an obstacle on a 2D plane in the form of a simple polygon with vertices at points [expression] and no other point on the rope is fixed.

If the shape of the rope is a line that has never intersects with or overlaps itself, what's the maximum possible length of the rope? 
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.238
expert
----------
PROBLEM STATEMENT:
Carl is an abstract artist painting [expression]. Carl wants to make sure he has enough paint for all the figures, so he wants to know the total area they will cover.

Given the locations for all the figures, find and print a real number denoting the total area covered by all [expression].
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.239
easy
----------
PROBLEM STATEMENT:
Random number generator

There is an ideal random number generator, which given a positive integer M can generate any real number between 0 to M, and probability density function is uniform in [0, M].

Given two numbers A and B and we generate x and y using the random number generator with uniform probability density function [0, A] and [0, B] respectively,  what's the probability that x + y is less than C?&nbsp;where C is a positive integer.

Input Format

The first line of the input is an integer N, the number of test cases.

N lines follow. Each line contains 3 positive integers A, B and C.

Constraints

All the integers are no larger than 10000.

Output Format

For each output, output a fraction that indicates the probability. The greatest common divisor of&nbsp;each pair of numerator and denominator should be 1.

Sample Input

3
1 1 1
1 1 2
1 1 3


Sample Output

1/2
1/1
1/1

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int gcd(int x,int y) {
    return y?gcd(y, x % y):x;
}

pair<int,int> make(int x,int y) {
int g = gcd(x, y);
        return make_pair(x / g, y / g);
}

pair<int,int> calculate(int a,int b,int c) {
int t;
    if (a + b <= c) {
        return make_pair(1,1);
    }
    if (a < b) {
        t = a;
        a = b;
        b = t;
    }
    // a >= b
    t = (a * b) << 1;
    if (c >= a) {  // (a, c - a)  (c - b, b)
        a += b - c;
        return make(t - a * a , t);
        
    }
    if (c >= b) { //(c,  0) (c - b, b)
        return make((c + c - b) * b, t);
    }
    return make(c * c, t);
    
}

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
int z,a,b,c;
    for (scanf("%d",&z);z;--z) {
        scanf("%d%d%d",&a,&b,&c);
        pair<int,int> answer = calculate(a,b,c);
        printf("%d/%d\n",answer.first,answer.second);
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.240
hard
----------
PROBLEM STATEMENT:
Watson gave a string [expression]?

Input Format 
First line contains [expression] in one line and string in second line.     

Output Format 
Print the required probability as an irreducible fraction. If required answer is 0, output 0/1.   

Constraints 
[expression] 
[expression] 
[expression] 
[expression]    

Sample input   

2
4 3
1011
4 1
1011


Sample output   

9/16
5/16


Explanation 
test1: Out of 16 choices, 9 pairs of [expression] satisfy our condition.  

(1,1), (1,3), (1,4), (3,1), (3,3), (3,4), (4,1), (4,3), (4,4)      


test2: Out of 16 choices, 5 pairs of [expression] satisfy our condition.   

(1,1), (3,3), (4,4), (4,3), (3,4)  

----------
TOP SOLUTION:
----------
#include<iostream>

using namespace std;

long long GCD(long long a , long long b){
    if(b == 0){
        return a;
    }
    else{
        return GCD(b,a%b);
    }
}

int main(){
    long t;
    cin >> t;
    while(t--){
        long n,k;
        cin >> n >> k;
        char a[n+2];
        cin >> a;
        long long counter = 0;
        long long total = n*(n-1)+n;
        long long favour = 0;
        if(k < n/2){
            for(long i = 0 ; i < n ; i++){
                if(a[i] == '1'){
                    counter++;
                    for(long j = i ; j <= i+k ; j++){
                        if(j == n){
                            break;
                        }
                        if(a[j] == '1'){
                            favour++;
                        }
                    }
                }
            }
            favour = favour - counter;
        }
        else{
            for(long i = 0 ; i < n ; i++){
                if(a[i] == '1'){
                    counter++;
                    for(long j = i+k+1 ; j < n ; j++){
                        if(j == n){
                            break;
                        }
                        if(a[j] == '1'){
                            favour++;
                        }
                    }
                }
            }
            favour = (counter*(counter-1))/2 - favour;
        }
        //cout << favour;
        favour = 2*favour;
        favour = favour + counter;
        long long gcd = GCD(favour,total);
        cout << favour/gcd << "/" << total/gcd << "\n";
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.241
medium
----------
PROBLEM STATEMENT:
Objective 
In this challenge, we practice solving problems with normally distributed variables.

Task 
[expression]. Find:


[expression] 
[expression] 
[expression]

----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.242
medium
----------
PROBLEM STATEMENT:
Objective 
In this challenge, we practice solving problems with normally distributed variables.

Task 
In a certain plant, the time taken to assemble a car is a random variable having a normal distribution with a mean of [expression] hours. What is the probability that a car can be assembled at this plant in:


Less than [expression] hours? 
Between [expression] hours?

----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.243
medium
----------
PROBLEM STATEMENT:
Given an array of integers [expression]. 

For example, if we have [expression], as shown in the picture below:



For each permutation [expression]?
----------
TOP SOLUTION:
----------
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <vector>
using namespace std;

const int N = 50;
int t, n, arr[N];
double dp[N + 1];
int main() {
    for(cin >> t; t--; ) {
        cin >> n;
        for(int i = 0; i < n; i ++) {
            cin >> arr[i];
        }
        double result = 0;
        for(int i = 0; i < n; i ++) {
            int gte = 0;
            for(int j = 0; j < n; j ++) if(arr[i] <= arr[j]) gte ++;
            gte --;
            for(int j = 1; j <= n; j ++) {
                dp[0] = j;
                for(int k = 1; k < j; k ++) {
                    double p = (double)gte / (double)(n - j + k);
                    dp[k] = p * (j - k) + (1 - p) * dp[k - 1];
                }
                result += dp[j - 1] / n;
            }
        }
        cout.precision(2);
        cout.setf(ios::fixed | ios::showpoint);
        cout << result << endl;
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.244
hard
----------
PROBLEM STATEMENT:
A large group of students took a test in physics and the final grades have a mean of 70 and a standard deviation of 10. If we can approximate the distribution of these grades by a normal distribution, what percent of the students 

a) scored higher than 80? 

b) should pass the test (grades≥60)? 

c) should fail the test (grades

Submission Modes and Output Format

You may submit either an R or Python program to accomplish the above task or solve the problem on pen-and-paper. Your output should be three floating point/decimal numbers separated by a line, correct to 2 places of decimal.


In the text box below, enter three floating point/decimal numbers, correct to 2 places of decimal.
Alternatively, you may submit an R program, which uses the above parameters (hard-coded) and computes the answer.


Your answer should resemble something like:

65.12
15.45
2.78


(This is NOT the answer, just a demonstration of what the answering format should resemble).
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.245
easy
----------
PROBLEM STATEMENT:
Isaac has to buy a new HackerPhone for his girlfriend Amy. He is exploring the shops in the town to compare the prices whereupon he finds a shop located on the first floor of a building, that has a unique pricing policy. There are N steps leading to the shop. A numbered ball is placed on each of the steps. 
The shopkeeper gives Isaac a fair coin and asks him to toss the coin before climbing each step. If the result of the toss is a 'Heads', Isaac should pick up the ball, else leave it and proceed to the next step.

The shopkeeper then asks Isaac to find the sum of all the numbers he has picked up (let's say S). The price of the HackerPhone is then the expected value of S. Help Isaac find the price of the HackerPhone.

Input Format 
The first line of the input contains an integer N, the number of steps.
N lines follow, which are the numbers written on the ball on each step.  

Output Format 
A single line containing expected value. 

Note : Expected value must be printed as a decimal number having exactly one digit after decimal. It is guaranteed that the correct answer will have at most one digit after decimal.

Constraints 
1 
1 9

Sample Input #00:

3
1 
1
2


Sample Output #00:

2.0


Sample Input #01:

4
1 
2
2
2


Sample Output #01:

3.5


Explanation 
In the first case there can be 8 different ways depending on the ball choice. So, we can multiply sum for each way by its probability to occur i.e. 1/8 and sum up to get the expected value as 2. 
Similarly in the second case we have 4 items , there can be 16 ways and following the expected value one gets is 3.5.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <iomanip>
#include <algorithm>
using namespace std;


int main() {
    int N;
    cin >> N;
    
    cout << fixed;
    cout << setprecision(1);
    double total = 0;
    for(int i=0;i<N;i++){
        int cur;
        cin >> cur;
        total+=0.5*cur;
    }
    
    cout << total << endl;
    
    return 0;
}

----------
====================
----------
MATHEMATICS.246
medium
----------
PROBLEM STATEMENT:
A recent lab accident resulted in the creation of an extremely dangerous virus that replicates so rapidly it's hard to predict exactly how many cells it will contain after a given period of time. However, a lab technician made the following observations about its growth per millisecond:


The probability of the number of virus cells growing by a factor of [expression].
The probability of the number of virus cells growing by a factor of [expression]. 


Given [expression].
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

const int MOD = 1e9 + 7;

int exp_log(int nr, long long exp) {
    int sol = 1;
    for (int i = 0; (1LL << i) <= exp; i++) {
        if (exp & (1LL << i))
            sol = (1LL * sol * nr) % MOD;
        nr = (1LL * nr * nr) % MOD;
    }
    return sol;
}

int main() {
    int a, b;
    long long t;
    cin >> a >> b >> t;
    cout << exp_log((a + b) / 2, t);
    return 0;
}

----------
====================
----------
MATHEMATICS.247
medium
----------
PROBLEM STATEMENT:
In an [expression] matchsticks are placed in the following way:





The Experiment




For each of the [expression].  
We define a connected component to be a maximal set of cells not isolated from one another by matchsticks. We calculate our [expression]. 


For example, suppose our grid looks like this after performing the first step:





To calculate our [expression] connected cells:




As you can see, there are [expression]. From this, we perform the following calculation:
[expression]



You are given [expression] on a new line.

Need Help? Check out this learning aid explaining some important properties of expected values.
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.248
medium
----------
PROBLEM STATEMENT:
Given a string, you keep swapping any two characters in the string randomly till the string becomes a palindrome. What is the expected number of swaps you will make?&nbsp;There will always be at least one palindrome which can be formed with the letters of the given string.

Input: 
The first line contains the number of test cases T. Each of the next T lines contains a string each.

Output: 
Output T lines containing the answer for the corresponding test case. Print the answer correct to 4 decimal places.

Constraints: 
T 
The length of the string will be at most 8 characters. 
The string will consist of only lower-case letters 'a'-'z'.

Sample Input:  

4  
b  
bb  
abb  
cbaabbb


Sample Output:  

0.0000  
0.0000  
3.0000  
59.3380


Explanation:

For the first two cases, the string is already a palindrome so no swaps are needed.

For the third case, there are 3 possible swaps. The string will become "bab","bba" or remain "abb" with 1/3rd probability each. It's easy to see that the expected number of swaps needed is 3.0000

For the last case, the answer is 59.337962..., which should be printed as 59.3380
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */

#include<iostream>
#include<set>
#include<map>
#include<string>
#include<stdio.h>
#include<sstream>
#include<algorithm>
#include<queue>
#include<cmath>
#include<string.h>
using namespace std ;
#define INF (int)1e9
#define MAXN 700
int N ;
double matrix[MAXN][MAXN] ;

string normalize(string s)
{
 int mp[26],c = 0 ;
 memset(mp,255,sizeof mp) ;
 for(int i = 0;i < s.size();i++)
  if(mp[s[i] - 'a'] == -1)
   mp[s[i] - 'a'] = c++ ;
 string ret ;
 for(int i = 0;i < s.size();i++)
  ret.push_back(mp[s[i] - 'a'] + 'a') ;
 return ret ;
}

int ct = 0 ;
map<string,int> id ;
int getId(string s)
{
 if(id.count(s)) return id[s] ;
 return id[s] = ct++ ;
}

int tot = 0 ;
map<string,double> memo ;
double solve(string s)
{
 s = normalize(s) ;
 if(memo.count(s)) return memo[s] ;

 ct = 0 ;
 id.clear() ;

 int n = s.size() ;
 int swaps = n * (n - 1) / 2 ;
 
 N = 0 ;
 string t = s ;
 sort(t.begin(),t.end()) ;
 do { getId(normalize(t)) ; }
 while(next_permutation(t.begin(),t.end())) ;
 N = id.size() ;

 for(int i = 0;i <= N;i++)
  for(int j = 0;j <= N;j++)
   matrix[i][j] = 0 ;

 t = s ;
 sort(t.begin(),t.end()) ;
 do
 {
  string x = normalize(t) ;
  int id1 = getId(x) ;
  matrix[id1][id1]++ ;
    
  string tt = x ;
  reverse(tt.begin(),tt.end()) ;
  if(x == tt) continue ;  
  for(int i = 0;i < n;i++)
   for(int j = i + 1;j < n;j++)
   {
    swap(x[i],x[j]) ;
    int id2 = getId(normalize(x)) ;
    matrix[id1][id2] += -1. / swaps ;
    swap(x[i],x[j]) ;
   }
  matrix[id1][N]++ ;
 }
 while(next_permutation(t.begin(),t.end())) ;
 
 for(int i = 0;i < N;i++)
 {
  for(int j = N;j >= i;j--) matrix[i][j] /= matrix[i][i] ;
   for(int k = 0;k < N;k++) if(i != k)
    for(int j = N;j >= i;j--)
     matrix[k][j] -= matrix[k][i] * matrix[i][j] ;
 }

 sort(t.begin(),t.end()) ;
 do
 {
  string tt = normalize(t) ;
  memo[tt] = matrix[getId(tt)][N] ;
 }
 while(next_permutation(t.begin(),t.end())) ;
 
 return memo[s] ;
}

int main()
{
 int runs ;
 cin >> runs ; 
 while(runs--)
 {
  string s ;
  cin >> s ;
  double ret = solve(s) ;
  printf("%.4lf\n",ret) ;
 }
 return 0 ;
}
----------
====================
----------
MATHEMATICS.249
medium
----------
PROBLEM STATEMENT:
Logan is cleaning his apartment. In particular, he must sort his old favorite sequence, [expression] positive integers in nondecreasing order. He's tired from a long day, so he invented an easy way (in his opinion) to do this job. His algorithm can be described by the following pseudocode:

while isNotSorted(P) do {   
    WaitOneMinute();
    RandomShuffle(P)
}


Can you determine the expected number of minutes that Logan will spend waiting for [expression] to be sorted?
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;
#define FOR(i,n) for(int i = 0; i < (n); i++)
#define sz(c) ((int)c.size())
#define ten(n) ((int)1e##n)
using ll = long long;

template<typename ...> static inline int getchar_unlocked(void) { return getchar(); }
template<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }
#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)
void reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }
void reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }
int reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\n'&&i != '\r'&&i != '\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\n' || i == '\r' || i == '\t' || i == EOF) break; c[s++] = i; }c[s] = '\0'; return s; }
int reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\n'&&i != '\r'&&i != '\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\n' || i == '\r' || i == '\t' || i == EOF) break; c.push_back(i); }; return sz(c); }
template <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }
template <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }
template <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }
void writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }
void writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }
void writer(const char c[]) { int i; for (i = 0; c[i] != '\0'; i++)mypc(c[i]); }
void writer(const char x[], char c) { int i; for (i = 0; x[i] != '\0'; i++)mypc(x[i]); mypc(c); }
template<class T> void writerLn(T x) { writer(x, '\n'); }
template<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\n'); }
template<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\n'); }
template<class T> void writerArr(T x[], int n) { if (!n) { mypc('\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\n'); }
template<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }

template<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }
template<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }
ll mod_pow(ll a, ll n, ll mod) {
	ll ret = 1;
	ll p = a % mod;
	while (n) {
		if (n & 1) ret = ret * p % mod;
		p = p * p % mod;
		n >>= 1;
	}
	return ret;
}
template<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }
template<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }

using Pii = pair<int, int>;

template<class T> void chmax(T& l, T r) {
	if (l < r) l = r;
}

class UnionFind {
private:
	int n;
	vector<int> a;
public:
	UnionFind(int n) : n(n), a(n, -1) {}
	int find(int x) { return a[x] < 0 ? x : (a[x] = find(a[x])); }
	bool same(int x, int y) { return find(x) == find(y); }
	bool same(Pii& p) { return same(p.first, p.second); }
	bool unite(int x, int y) {
		x = find(x), y = find(y);
		if (x == y) return false;
		if (a[x] > a[y]) swap(x, y);
		a[x] += a[y];
		a[y] = x;
		n--;
		return true;
	}
	bool unite(Pii& p) { return unite(p.first, p.second); }
	int size() const { return n; }
	int size(int x) { return -a[find(x)]; }
};


int main() {
	int n; reader(n);
	map<int,int> mp;
	vector<int> o;
	FOR(i, n) {
		int x; reader(x);
		o.push_back(x);
		mp[x]++;
	}
	vector<int> x = o;
	sort(x.begin(), x.end());
	if (x == o) {
		puts("0");
		return 0;
	}
	double ans = 1;
	FOR(i, n) ans *= i + 1;
	for (auto k : mp) {
		FOR(i, k.second) {
			ans /= i + 1;
		}
	}
	printf("%.10lf\n", ans);

	return 0;
}
----------
====================
----------
MATHEMATICS.250
medium
----------
PROBLEM STATEMENT:
A blindfolded marksman finds that on the average he hits the target 4 times out of 5. If he fires 4 shots, what is the probability of

(a) more than 2 hits?

(b) at least 3 misses?

Submission Modes and Output Format

Your output should be two floating point/decimal numbers rounded to a scale of [expression] format). There are two submission options:


Complete the challenge manually using pen and paper. Select Plain Text from the editor's language drop-down. Put the answer to question (a) on the first line and the answer to question (b) on the second line.
Hard-code the given parameters into a Python or R program that solves the probem, printing  the solution to (a) on the first line and (b) on the second line.


Your answer should resemble something like:

0.123
0.456


(This is NOT the answer, just a demonstration of what the answering format should resemble).
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.251
hard
----------
PROBLEM STATEMENT:
The ratio of boys to girls born in Russia is 1.09:1.

What proportion of Russian families with exactly 6 children will have at least 3 boys? (Ignore the probability of multiple births.)

Submission Modes and Output Format

You may submit either an R or Python program to accomplish the above task, or solve the problem on pen-and-paper. Your output should be a floating point/decimal number, correct to 3 places of decimal.


In the text box below, enter a floating point/decimal number, correct to 3 places of decimal.
Alternatively, you may submit an R program, which uses the above parameters (hard-coded) and computes the answer.


Your answer should resemble something like:

0.123


(This is NOT the answer, just a demonstration of what the answering format should resemble).
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.252
hard
----------
PROBLEM STATEMENT:
A manufacturer of metal pistons finds that on average, 12% of his pistons are rejected because they are either oversized or undersized. What is the probability that a batch of 10 pistons will contain

(a) no more than 2 rejects?

(b) at least 2 rejects?

Submission Modes and Output Format

You may submit either an R or Python program to accomplish the above task, or solve the problem on pen-and-paper. Your output should be two floating point/decimal numbers separated by a line, correct to 3 places of decimal.


In the text box below, enter two floating point/decimal numbers, correct to 3 places of decimal.
Alternatively, you may submit an R program, which uses the above parameters (hard-coded) and computes the answer.


Your answer should resemble something like:

0.123
0.456


(This is NOT the answer, just a demonstration of what the answering format should resemble).
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.253
medium
----------
PROBLEM STATEMENT:
Kevinsogo is a professor of mathematics, One day he gave an assignment to his students which was hard for them. The students want you to help them in solving the problem.

Given the value of [expression], 
[expression] 
[expression]

Note that [expression] (inclusive) uniformly at random.

Find out the expected value of [expression].

Input Format 
The first line contains an integer [expression] i.e. the number of test cases.
The next [expression].

Output Format 
Print the output corresponding to each test case in a separate line. The answer will be considered correct if its absolute error doesn't exceed [expression].  

Constraints 
Task 1: 30 points 
[expression] 
[expression]  

Task 2: 10 additional points 
[expression] 
[expression]  

Sample Input

3
1
5
10


Sample Output

0.0
1.69647248786
2.43798952788

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;

int main() {
    long t;
    cin >> t;
    while(t--){
        long long n;
        cin >> n;
        double answer = (sqrt(4*(0-1)+1)+1)/2;
        cout << answer/n << "\n";
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.254
medium
----------
PROBLEM STATEMENT:
As usual Gary and Flo are sitting at their favourite burger restaurant called Jim's Burgers. They want to treat themselves with delicious burger after an interesting day with lots of competitive programming. So they have ordered their burgers and are waiting for them. But with nothing to do, they get bored and decide to play a game.

The game is played on a sheet of paper with [expression] columns and goes as follows: 

Flo places his white lotus tile somewhere at the top row and Gary places a caterpillar tile somewhere on the bottom row. Flo begins the game and their turns alternate. Flo can move his tile to any of the 8 adjacent cells, while Gary's caterpillar tile can only move  left or right, or stay at the same cell. Of course, they cannot step outside of the grid. Flo's goal is to catch Gary as fast as possible, that is, with the minimum number of moves, while Gary (with the caterpillar tile) has to survive for as long as possible.  

Now they are wondering: If they place their tiles in the corresponding rows and some random columns, what is the expected number of moves Flo has to make to win the game (assuming they will play optimally)? 

Can you help them answer this question?

Constraints

[expression]

Input Format

You will be given two space separated integers [expression], denoting the number of rows and the number of columns on the board respectively. 

Output Format

Output the answer in one line. 

Note: The answer will be considered valid if it differs from the correct answer by at most [expression].

Sample input

2 3


Sample output

1.2222222


Consider the pair [expression] as the starting column of the lotus and the starting column of the caterpillar respectively. 

For [expression] we get the following scenario. 

[expression] will lead to 1 move. 
The remaining pairs [expression]
----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

int main() {
	//moves = max(n-1, x, )
	int n, m;
	scanf("%d%d", &n, &m);
	long long sum = 0;
	rep(x1, m) rep(x2, m) {
		int moves = 0;
		amax(moves, n - 1);
		if(x2 + 1 < x1)
			amax(moves, x1);
		else if(x1 + 1 < x2)
			amax(moves, m - 1 - x1);
		sum += moves;
	}
	double ans = sum * 1. / (m * m);
	printf("%.10f\n", ans);
	return 0;
}

----------
====================
----------
MATHEMATICS.255
expert
----------
PROBLEM STATEMENT:
Calvin has a math assignment at school where he has to evaluate a lot of expressions. Calvin decides to not to waste much of his time. There are [expression] expressions overall. By looking at Susie’s answers, Calvin has figured that the answers to all questions form a non decreasing sequence. 

He decides that all his answers are going to be between [expression]. 

Here is the part where the real problem starts for Calvin. He does not want to choose a large value of [expression], a lot of answers would become equal and the teacher will become suspicious.  

If [expression]. Help him solve the problem.  

For example, if [expression], the possible sequences are:  

1 1 1 (x = 3)  
1 1 2 (x = 2)  
1 1 3 (x = 2)  
1 2 2 (x = 2)  
1 2 3 (x = 1)  
1 3 3 (x = 2)  
2 2 2 (x = 3)  
2 2 3 (x = 2)  
2 3 3 (x = 2)  
3 3 3 (x = 3)  


expected value of [expression]

Input Format 
The first line contains an integer [expression] for the corresponding test cases.  

Constraints 
[expression] 
[expression] 
[expression]  

Output Format 
Output [expression] is allowed.  

Sample Input  

4
1 5
3 3
2 9
9 6


Sample Output  

1.0000000000
2.2000000000
1.2000000000
4.3146853147


Explanation 
For second testcase we have  

[expression]  

[expression]
----------
TOP SOLUTION:
----------
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
#include <cmath>
#define ll long long
#define ldb long double
#define nextLine() {int c = 0; while ((c = getchar()) != 10 && c != EOF);}
const int INF = 1 << 28;
const ldb eps = 1e-9;
const ldb pi = M_PI;
using namespace std;

int M, N;
ldb p1[252];
ldb dp[252][252];

void load() {
	cin >> M >> N;
}

ldb count_prob_less(int m)
{
	memset(dp, 0, sizeof dp);
	dp[0][0] = 1;
	for (int l = 1; l <= M; l++)
	{
		for (int n = 1; n <= M; n++)
		{
			dp[l][n] = dp[l][n - 1] + dp[l - 1][n - 1];
			if (n - 1 - m >= 0)
				dp[l][n] -= dp[l - 1][n - 1 - m];
		}
	}
	ldb up = 0, down = 0;
	ldb C = N, CM = 1;
	for (int g = 1; g <= M; g++) {
		up += dp[g][M] * C;
		down += C * CM;
		CM /= g;
		CM *= (M - g);
		C /= g + 1;
		C *= (N - g);
	}
	return up / down;
}

void solve(int test_number) {
	for (int i = 1; i <= M; i++)
		p1[i] = count_prob_less(i);
	ldb res = 0;
	for (int i = 1; i <= M; i++)
		res += i * (p1[i] - p1[i - 1]);
	cout << fixed << setprecision(5) << res << "\n";
}


int main() {
	int t;
	cin >> t;
	nextLine();
	for (int i = 0; i < t; i++)
	{
		load();
		solve(t + 1);
	}
	return 0;
}
----------
====================
----------
MATHEMATICS.256
hard
----------
PROBLEM STATEMENT:
We have a country containing _N _cities. Each day we choose 2 cities such that there is no road between them and build a road between them. We choose each pair of nonadjacent cities with equal probability. Let X be the number of days before we obtain a connected country. What is the expected value of X? Output the integer part of answer.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <string.h>
#include <sstream>
#include <set>
#include <map>
#include <ctime>
#include <string>
#include <vector>
#include <utility>
#include <string.h>
#include <cassert>
#include <fstream>
#include <queue>

using namespace std;

#define debug1(x) cout << #x" = " << x << endl;
#define debug2(x, y) cout << #x" = " << x << " " << #y" = " << y << endl;
#define debug3(x, y, z) cout << #x" = " << x << " " << #y" = " << y << " " << #z" = " << z << endl;
#define debug4(x, y, z, w) cout << #x" = " << x << " " << #y" = " << y << " " << #z" = " << z << " " << #w" = " << w << endl;

template <class T>
ostream & operator << (ostream & out, const vector<T> & data)
{ out << "["; for (int i = 0; i < (int) data.size(); ++i) out << data[i] << (i == data.size() - 1 ? "" : ","); out << "]"; return out; }

template <class T>
ostream & operator << (ostream & out, const set<T> & s)
{ out << "{"; for (typename set<T>::iterator itr = s.begin(); itr != s.end(); ++itr) out << *itr << " "; out << "}"; return out; }

template <class T>
ostream & operator << (ostream & out, const multiset<T> & s)
{ out << "{"; for (typename multiset<T>::iterator itr = s.begin(); itr != s.end(); ++itr) out << *itr << " "; out << "}"; return out; }

template <class T1, class T2>
ostream & operator << (ostream & out, const pair<T1, T2> & p)
{ out << "(" << p.first << "," << p.second << ")"; return out; }

template <class T1, class T2>
ostream & operator << (ostream & out, const map<T1, T2> & m)
{ 
  for (typename map<T1, T2>::const_iterator itr = m.begin(); itr != m.end(); ++itr)
    out << itr->first << "->" << itr->second << " ";
  return out;
}

/////////////////////////////////////////////////////////

int ans[30] = {0,1,2,3,4,6,7,9,10,12,14,16,18,20,22,24,26,28,30,32,34,37,39,41,44,46,48,51,53,55};

int N;

struct State
{
  int cnt[31];
  int edges;
  
  inline int getTotal()
  {
    int total = 0;
    for (int i = 1; i <= N; ++i)
      for (int j = i; j <= N; ++j)
      {
        if (i == j) total += cnt[i] * (cnt[i] - 1) * i * (i) / 2;
        else total += cnt[i] * cnt[j] * i * j;
      }
    return total;
  }
  
  bool operator < (const State & s) const
  {
    if (edges < s.edges) return true;
    if (edges > s.edges) return false;
    for (int i = 1; i <= N; ++i)
    {
      if (cnt[i] < s.cnt[i]) return true;
      if (cnt[i] > s.cnt[i]) return false;
    }
    return false;
  }
};

map<State, double> ept;

double getEpt(State s)
{
  if (ept.find(s) != ept.end()) return ept[s];
  double & ret = ept[s];
  if (s.cnt[N] == 1) return ret = 0;
  
  ret = 1;
  int newe = s.getTotal();
  int total = N * (N - 1) / 2 - s.edges;
  int remain = total - newe;
  for (int i = 1; i <= N; ++i)
    if (s.cnt[i] > 0)
    {
      s.cnt[i]--;
      for (int j = i; j <= N; ++j)
        if (s.cnt[j] > 0)
        {
          s.cnt[j]--;
          s.cnt[i + j]++;
          double p = (double) i * j * (s.cnt[i] + 1) * (s.cnt[j] + 1);
          if (i == j) p = (double) i * i * (s.cnt[i] + 1) * (s.cnt[i] + 2) / 2;
          p /= total;
          s.edges++;
          
          ret += getEpt(s) * p;
          
          s.edges--;
          s.cnt[j]++;
          s.cnt[i + j]--;
        }
      s.cnt[i]++;
    } 
  
  if (remain > 0)
  {
    s.edges++;
    ret += (remain) / (double) total * getEpt(s);
  }
  return ret;
}

void init()
{
  cin >> N;
  cout << ans[N - 1] << endl;
}

void york()
{
  
}

int main()
{
  init();
  york();
  
  return 0;
}
----------
====================
----------
MATHEMATICS.257
hard
----------
PROBLEM STATEMENT:
Given an integer range [A,B],  


What’s the probability to get a 1-bit if we first randomly choose a number x in the range and then randomly choose a bit from x?  
What’s the expected number of bit 1s if we randomly choose a number x in the range?  


Input Format 
The first line of input is the number of test cases [expression] 
Each test cases is a line contains 2 integers [expression] separated by a space. 

Output Format 
For each test case output a line containing 2 float numbers separated by a space. The first one is the probability and the second one is the expected number. You should output the number accurate to 5 fractional digits.&nbsp;

Constraints 
[expression] 
[expression]  

Sample Input

1
2 4


Sample Output

0.61111 1.33333


Explanation 
(10)  (11)  (100) 
(1) So we got a one in [expression] 
(2) The expected 1 we have is : [expression]  
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define ll long long

#define mygc(c) (c)=getchar_unlocked()
void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}

int T;
ll A, B;

ll cnt(ll A){
  ll p, all, rest;
  ll res = 0;

  for(p=1;;p*=2){
    if(A < p) break;
    all = (A/(2*p));
    rest = (A%(2*p));
    res += all * p;
    if(rest >= p) res += rest - p;
  }

  return res;
}

ll cntRange(ll A, ll B){
  return cnt(B+1) - cnt(A);
}

int main(){
  int i, j, k;
  ll st, ed, dig, r, tmp;
  double res1, res2;

  reader(&T);
  while(T--){
    reader(&A);
    reader(&B);
    res1 = res2 = 0;

    st = ed = dig = 1;
    for(;;){
      if(st > B) break;

      if(max(st,A) <= min(ed,B)){
        tmp = cntRange(max(st,A), min(ed,B));
        r = min(ed,B) - max(st,A) + 1;

        res1 += tmp / (double)dig;
        res2 += tmp;
      }

      st = st*2;
      ed = st*2-1;
      dig++;
    }

    res1 /= (B-A+1);
    res2 /= (B-A+1);
    printf("%.5f %.5f\n",res1,res2);
  }

  return 0;
}

----------
====================
----------
MATHEMATICS.258
medium
----------
PROBLEM STATEMENT:
The expected value is the weighted average of all possible outcomes of an experiment, weighted with the probabilities of each particular outcome. For a random variable [expression].  

Intuitively, the expected value is the long run average value of repetitions of the experiment.  

The variance is the expected value of the outcome's squared deviation from its expected value. For a random variable [expression].  

Intuitively, the variance is a measure of how far the outcomes of an experiment are spread out. The higher the variance, the more spread out the outcomes.  

Let's say we perform the following experiment involving throwing a die:  

Throw the die, and record the outcome as d[1].  

For i from 2 to N:
    Repeatedly throw the die until the outcome is different from d[i-1].
    Record the outcome as d[i].  

Output d[1] + d[2] + ... + d[N].


The die used in this experiment is a standard 6-sided die with outcomes [expression].  

Find the expected value and variance of the outcome of this experiment.  

Note: Certain formulas for variance are not fit for computation because of loss of significance/numerical instability. This link contains a discussion about how to avoid/mitigate this problem.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define MP make_pair
#define PB push_back
#define int long long
#define st first
#define nd second
#define rd third
#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)
#define RE(i, n) FOR(i, 1, n)
#define FORD(i, a, b) for(int i = (a); i >= (b); --i)
#define REP(i, n) for(int i = 0;i <(n); ++i)
#define VAR(v, i) __typeof(i) v=(i)
#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)
#define ALL(x) (x).begin(), (x).end()
#define SZ(x) ((int)(x).size())
using namespace std;
template<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<"="<<h<<"\n"; }
template<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {
  while(*sdbg != ',')cerr<<*sdbg++; cerr<<"="<<h<<","; _dbg(sdbg+1, t...);
}
#ifdef LOCAL
#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)
#define debugv(x) {{cerr <<#x <<" = "; FORE(itt, (x)) cerr <<*itt <<", "; cerr <<"\n"; }}
#else
#define debug(...) (__VA_ARGS__)
#define debugv(x)
#define cerr if(0)cout
#endif
#define make(type, x) type x; cin>>x;
#define make2(type, x, y) type x, y; cin>>x>>y;
#define make3(type, x, y, z) type x, y, z; cin>>x>>y>>z;
#define make4(type, x, y, z, t) type x, y, z, t; cin>>x>>y>>z>>t;
#define next ____next
#define prev ____prev
#define left ____left
#define hash ____hash
typedef long long ll;
typedef long double LD;
typedef pair<int, int> PII;
typedef pair<ll, ll> PLL;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<ll> VLL;
typedef vector<pair<int, int> > VPII;
typedef vector<pair<ll, ll> > VPLL;

template<class C> void mini(C&a4, C b4){a4=min(a4, b4); }
template<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }
template<class T1, class T2>
ostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << "(" << pair.first << ", " << pair.second << ")";}
template<class A, class B, class C> struct Triple { A first; B second; C third;
  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };
template<class T> void ResizeVec(T&, vector<int>) {}
template<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {
  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }
  for (T& v : vec) { ResizeVec(v, sz); }
}
typedef Triple<int, int, int> TIII;
template<class A, class B, class C>
ostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << "(" << t.st << ", " << t.nd << ", " << t.rd << ")"; }
template<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<"("; for (auto& v: vec) out<<v<<", "; return out<<")"; }

const int N = 1e4 + 5;
LD p[N];
LD dp[2][N][7];    

#undef int
int main() {
#define int long long

  ios_base::sync_with_stdio(0);
  cout << fixed << setprecision(10);
  cerr << fixed << setprecision(10);
  cin.tie(0);
  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;
  
  LD E1 = 0;
  RE (i, 6) {
    cin>>p[i];
    E1 += i * p[i];
    dp[0][i][i] = p[i];
  }
  int n;
  cin>>n;
  LD V1 = 0;
  RE (i, 6) {
    LD diff = i - E1;
    V1 += diff * diff * p[i];
  }
  debug(E1, V1);
  
  int cap = min(n, (int)1500);
  int cur = 1;
  RE (i, cap - 1) {
    debug(i);
    RE (sum, 6 * i) {
      RE (last, 6) {
        dp[cur][sum][last] = 0;
      }
    }
    RE (sum, 6 * i) {
      RE (last, 6) {
        RE (now, 6) {
          if (now != last) {
            dp[cur][sum + now][now] += dp[cur ^ 1][sum][last] * p[now] / (1 - p[last]);
          }
        }
      }
    }
    cur ^= 1;
  }
  LD E[2], V[2];
  REP (tr, 2) {
    E[tr] = V[tr] = 0;
    RE (sum, 6 * cap) {
      RE (last, 6) {
        E[tr] += dp[tr][sum][last] * sum;
      }
    }
    RE (sum, 6 * cap) {
      RE (last, 6) {
        LD diff = sum - E[tr];
        V[tr] += diff * diff * dp[tr][sum][last];
      }
    }
  }
  if (E[0] > E[1]) {
    swap(E[0], E[1]);
    swap(V[0], V[1]);
  }
  LD resE = (n - cap) * (E[1] - E[0]) + E[1];
  LD resV = (n - cap) * (V[1] - V[0]) + V[1];
  cout<<resE<<"\n"<<resV<<"\n";
    
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  return 0;
}

----------
====================
----------
MATHEMATICS.259
medium
----------
PROBLEM STATEMENT:
James has a tree with [expression] moves. During each move, he performs the following steps:


Randomly chooses some node [expression] from the tree. Each node has an equal probability of being chosen.
Calculates the distance from node [expression] using one or more edges.
Deletes node [expression].


For example, the diagram below shows what happens when we choose a random node and delete it from the tree:



After [expression] moves, the tree is empty and the game ends.

James defines the magic number, [expression].

Give the tree's edges and their respective lengths, calculate and the print the value of [expression] is an integer.

Note

Due to a bug in the system, you might see accepted verdict in this problem even if you don't pass all the test cases. Please ignore that verdict, only the score you get is important in the ranklist.
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<stack>
#include<queue>
#include<cmath>
#include<algorithm>
#include<functional>
#include<list>
#include<deque>
#include<bitset>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<cstring>
#include<sstream>
#include<complex>
#include<iomanip>
#include<numeric>
#include<cassert>
#define X first
#define Y second
#define pb push_back
#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))
#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))
#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))
#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))
#define peat(X,Y) for (;(X) < (Y);++(X))
#define all(X) (X).begin(),(X).end()
#define rall(X) (X).rbegin(),(X).rend()
#define eb emplace_back
#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())
#define Endl endl

using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
template<class T> using vv=vector<vector<T>>;
template<class T> ostream& operator<<(ostream &os, const vector<T> &t) {
os<<"{"; rep(i,t.size()) {os<<t[i]<<",";} os<<"}"<<endl; return os;}
template<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<"("<<t.first<<","<<t.second<<")";}
template<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}
template<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}
#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }
vector<string> s_p_l_i_t(const string& s, char c) { vector<string> v; stringstream ss(s); string x; while(getline(ss,x,c)) v.emplace_back(x); return move(v);}
void e_r_r(vector<string>::iterator it) {}
template<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==" 1"||*it=="1") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << " = " << a << ", "; e_r_r(++it, args...);}
const ll MOD=1e9+9;
ll modpow(ll r,ll n,ll m=MOD){
  ll re=1,d=r%m;
  if(n<0)(n%=MOD-1)+=MOD-1;
  for(;n;n/=2){
    if(n&1)(re*=d)%=m;
    (d*=d)%=m;
  }
  return re;
}
vector<ll> fact,finv,inv;
ll comb(ll n,ll r){
  if(n<r||r<0)return 0;
  return fact[n]*finv[n-r]%MOD*finv[r]%MOD;
}
class Doralion{
  void Modinvs(vector<ll> &re,int n){
    re.resize(n+1); re[1]=1;
    for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i)%MOD;
  }
  void Facts(vector<ll> &re,int n){
    re.resize(n+1); re[0]=1;
    rep(i,n)re[i+1]=re[i]*(i+1)%MOD;
  }
  void Factinvs(vector<ll> &re,const vector<ll> &inv,int n){
    re.resize(n+1); re[0]=1;
    rep(i,n)re[i+1]=re[i]*inv[i+1]%MOD;
  }
public:
  Doralion(int n){
    Modinvs(inv,n);
    Facts(fact,n);
    Factinvs(finv,inv,n);
  }
} doralion(2123456);

//unordered_map<int,ll>
ll dfs(const vv<pll> &g,int v,int p,ll d,ll t){
  ll re=d*inv[t+1]%MOD;
  for(const pll &w:g[v])if(w.X!=p) (re+=dfs(g,w.X,v,(d+w.Y)%MOD,t+1))%=MOD;
  return re;
}

int main(){
  ios_base::sync_with_stdio(false);
  cout<<fixed<<setprecision(0);
  int n;
  cin>>n;
  vv<pll> g(n);
  rep(i,n-1){
    ll x,y,z;
    cin>>x>>y>>z; --x; --y;
    g[x].eb(y,z);
    g[y].eb(x,z);
  }
  ll re=0;
  rep(i,n) (re+=dfs(g,i,-1,0,0))%=MOD;
  cout<<re*fact[n]%MOD<<endl;
  return 0;
}

----------
====================
----------
MATHEMATICS.260
hard
----------
PROBLEM STATEMENT:
Sabya is writing code to output a random number between [expression].


For evaluation, the code is run twice. If the output in both cases are different, his score is equal to the sum of the outputs. Otherwise, his score is equal to [expression].


Sabya is very intelligent, and he writes code that maximizes his expected score. Find the expected score. Output the ratio of the expected score to the maximum possible score. The maximum possible score is [expression].

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <map>
#include <set>
#include <algorithm>
#define ll long long
using namespace std;


long double H[1111111];

int main() {
    
    H[0]=0;
    for(int i=1;i<1111111;i++)
        H[i]=H[i-1]+1.0/i;
    
    int T;
    cin>>T;
    for(int t=1;t<=T;t++) {
        ll N;
        cin>>N;
        
        
        int low = 0;
        int high = N;
        while(low < high) {
            int mid = (low + high)/2;
            
            double val = 0.5 - (N-mid-2)/(2*(H[N]-H[mid])*(mid+1));
            if (val > 0) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        double lambda = -(N-low-2)/(2*(H[N]-H[low]));
        
        
        double answer = 0;
        for(int j=low+1;j<=N;j++) {
            double p = 0.5 + lambda/j;
            answer += 2*j*(p-p*p);
        }
        
        printf("%1.12f\n",answer/(2*N-1));
        
        
    }
}
----------
====================
----------
MATHEMATICS.261
hard
----------
PROBLEM STATEMENT:
Zombies have placed themselves at every junction in Bucharest. Each junction 'i' initially has a presence of ai number of zombies. Every timestep, each zombie randomly chooses one of its neighboring junctions and walks towards it. Each neighboring junction is choosen by the zombie with an equal probability. In order to safegaurd the citizens of Bucharest we need to find out the expected number of zombies at every junction after 'k' timesteps. 

The network of Bucharest is given as an edge list.  

Input Format  


t - the number of test cases. 't' cases follow.
n, m, k - 'n' junctions (nodes) in Bucharest, 'm' roads (edges) and 'k' time steps. 
This is followed by m lines containing 1 edge on each line. Each edge is denoted by 2 integers representing the nodes it connects, which can range from 0 to n-1.  All the edges are bidirectional. A node cannot connect itself. 
This is followed by n lines, where the ith line contains the initial number of Zombies at the location ai.


Output Format 
Output the number of zombies (rounded of to its nearest integer) in the 5 most highly populated junctions after 'k' timesteps.

Constraints 
1

5

1

1

1

Sample Input  

1

10 18 100

0 8 

0 5 

1 2 

1 5 

2 8 

2 4 

2 5 

2 6 

3 5 

4 8 

4 6 

4 7 

5 8 

5 9 

6 8 

6 9 

7 9 

8 9 

1

1

1

1

1

1

1

1

1

1

Sample Output 
2 2 1 1 1
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

const double eps=1.e-6;
pair<int,int> e[200002];
double d[1002],a[1002][1002],q[2][1002];
int p[100002];

int main() {
int z,i,j,m,n,k,total,last,now;
bool yes;
	for (scanf("%d",&z);z;--z) {
		scanf("%d%d%d",&n,&m,&k);
		for (i=0;i<m;++i) {
			scanf("%d%d",&e[i].first,&e[i].second);
		
		}
		for (i=total=0;i<n;++i) {
			scanf("%d",&p[i]);
			total+=p[i];
		}
		if (i>1000) {
			total=total*1./n+.5;
			printf("%d %d %d %d %d\n",total,total,total,total,total);
		}
		else {
			memset(d,0,sizeof(d));
			memset(a,0,sizeof(a));
			for (i=0;i<m;++i) {
				a[e[i].first][e[i].second]=a[e[i].second][e[i].first]=1;
				++d[e[i].first];
				++d[e[i].second];
			}
			for (i=0;i<n;++i) {
				if (d[i]) {
					for (j=0;j<n;++j) {
						a[i][j]/=d[i];
					}
				}
				else {
					a[i][i]=1.;
				}
				q[0][i]=p[i];
			}
			for (last=0,yes=false;(!yes) && (k);--k) {
				now=1^last;
				yes=true;
				for (i=0;i<n;++i) {
					q[now][i]=0;
					for (j=0;j<n;++j) {
						q[now][i]+=q[last][j]*a[j][i];
					}
					if (fabs(q[now][i]-q[last][i])>=eps) {
						yes=false;
					}
				}
				last=now;
			}
			for (i=0;i<n;++i) {
				p[i]=-(int) (q[last][i]+.5);
			}
			sort(p,p+n);
			for (i=0;(i<n) && (i<5);++i) {
				if (i) {
					putchar(' ');
				}
				printf("%d",-p[i]);
			}
			puts("");
		}
	}
		
	return 0;
}
----------
====================
----------
MATHEMATICS.262
hard
----------
PROBLEM STATEMENT:
Bear Limak is a dance teacher.
Today is the first day of the course.
The course will take one or more days.
Your task will be to calculate the expected value of the number of dances in the course.

There are [expression] girls.
A classroom is very small and thus only one pair can dance at each moment.
For each new dance Limak chooses uniformly at random one boy and one girl.
The chosen pair will dance, unless the following will happen.

It's possible that the chosen pair has already danced with each other on the same day.
Then, with probability [expression] they will now get upset about it and they will refuse to dance (but otherwise they dance like a normal pair).
In such a situation Limak will apologize them and there will be no more dances on that day.
Classes will start again on the next day though, and Limak won't care who danced the day before and who got angry.
So, the situation will be exactly as on the first day.

Limaks waits for the possibility to say "Nice, kids. Every person has danced today. The course is over!".
So, the course ends immediately when there is a situation that every person has danced on that day.
What is the expected value of the number of dances in the course?
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

pair<double, double> ex[31][31][901];
int n, m;
double r;

pair<double, double> operator*(double x, pair<double, double> t) {
    return mp(x * t.fi, x * t.se);
}

pair<double, double> operator+(pair<double, double> r, pair<double, double> t) {
    return mp(r.fi + t.fi, r.se + t.se);
}


pair<double, double> get_ex(int a, int b, int k) {
    if (a == n && b == m) return mp(0, 0);
    if (a > n || b > m || k > a * b) return mp(0, 0);
    auto &res = ex[a][b][k];
    if (res.fi > -0.5) return res;
    res = mp(0.0, 1.0);
    res = res + (1.0 * (n - a) * (m - b) / n / m) * get_ex(a + 1, b + 1, k + 1);
    res = res + (1.0 * a * (m - b) / n / m) * get_ex(a, b + 1, k + 1);
    res = res + (1.0 * (n - a) * b / n / m) * get_ex(a + 1, b, k + 1);
    res = res + (1.0 * (a * b - k) / n / m) * get_ex(a, b, k + 1);
    res = res + (1.0 * k / n / m * r) * mp(1.0, -1.0);
    res = (1.0 / (1.0 - 1.0 * k / n / m * (1.0 - r))) * res;
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    cin >> n >> m >> r;
    forn(i, n + 1) forn(j, m + 1) forn(k, n * m + 1) ex[i][j][k] = mp(-1, -1);
    auto w = get_ex(0, 0, 0);
//    cerr << w.fi << ' ' << w.se << '\n';
    cout << w.se / (1 - w.fi) << '\n';

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
MATHEMATICS.263
advanced
----------
PROBLEM STATEMENT:
You're given a string [expression] characters. It's known that the string consists of lowercase Latin letters. The string is generated randomly. That means that every symbol is chosen randomly and independently from others from the set {'a', 'b', ..., 'z'}. All the letters have equal probability to appear.

You're given [expression] were chosen at random and independently from other queries. 

When you have a query of the form P C you have to change the [expression].
----------
TOP SOLUTION:
----------
#include<cstdio>
#include<vector>
#include<iostream>
#include<map>
#include<list>
#include<cassert>
using namespace std;
typedef long long ll;
typedef vector<ll> vl;
typedef vector<int> vi;
class mpair {
public:
    ll hash;
    int cnt;
    mpair(ll x) {
        hash = x;
        cnt = 1;
    }
};

char s[100000];
const int M = 9;
const int P = 131;
const int N = 2000000;
vector<list<mpair> > was(N);
//map<ll, int> was;
ll total = 0;

inline int remN(ll x) {
    x %= N;
    return (x >= 0) ? x : N+x;
}

int add(ll x) {
    int b = remN(x);
    for (list<mpair>::iterator it = was[b].begin(); it != was[b].end(); ++it) {
        if (it->hash == x) {
            it->cnt++;
            return it->cnt;
        }
    }
    was[b].push_back(mpair(x));
    return 1;
}

int rem(ll x) {
    int b = remN(x);
    for (list<mpair>::iterator it = was[b].begin(); it != was[b].end(); ++it) {
        if (it->hash == x) {
            it->cnt--;
            if (it->cnt) {
                return it->cnt;
            } else {
                was[b].erase(it);
                return 0;
            }
        }
    }
}

int main() {
    vl pw(M, 1);
    for (int i = 1; i < pw.size(); ++i)
        pw[i] = P * pw[i-1];
    int n,q;
    scanf("%d%d%s",&n,&q,s);
    vector<vl> h(n, vl(M));
    for (int i = 0; i < n; ++i) {
        ll cur = 0;
        for (int j = 0; j < min(M, n - i); ++j) {
            cur += s[i+j]*pw[j];
            h[i][j] = cur;
            int cnt = add(cur);
            //cerr << cur << ' ' << cnt << endl;
            if (cnt == 1) ++total;
            //assert(cnt == 1 || j < 10);
        }
    }
    if (n > M) total += (n-M)*(ll)(n-M+1)/2;
    for (int t = 0; t < q; ++t) {
        int pos;
        char c;
        scanf("%d %c", &pos, &c);
        --pos;
        int diff = (int)c - (int)s[pos];
        s[pos] = c;
        for (int i = max(0, pos - M + 1); i <= pos; ++i) {
            ll add1 = diff * pw[pos - i];
            for (int j = pos - i; j < min(M, n - i); ++j) {
                int cnt = rem(h[i][j]);
                if (cnt == 0) --total;
                h[i][j] += add1;
                cnt = add(h[i][j]);
                if (cnt == 1) ++total;
            }
        }
        printf("%lld\n", total);
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.264
hard
----------
PROBLEM STATEMENT:
Given an array 'D' with n elements: d[0], d[1], ..., d[n-1], you can perform the following two steps on the array.  


Randomly choose two indexes (l, r) with l 
Randomly choose two indexes (l, r) with l 


After you perform the first operation a times and the second operation b times, you randomly choose two indices l & r with l r and calculate the S = sum(d[l...r]) (both inclusive).  

Now, you are to find the expected value of S.

Input Format 
The first line of the input contains 3 space separated integers - n, a and b. 
The next line contains n space separated integers which are the elements of the array d.   

n a b
d[0] d[1] ... d[n-1]


Output Format 
Print the expected value of S.  

E(S)


Constraints  

2 
1 9 
1 

The answer will be considered correct, if the absolute or relative error doesn't exceed 10-4.  

Sample Input #00:

3 1 1 
1 2 3


Sample Output #00:

4.666667


Explanation #00:

At step 1): 
You have three choices: 
1. swap(0, 1), 2 1 3 
2. swap(0, 2), 3 2 1 
3. swap(1, 2), 1 3 2  

At step 2): 
For every result you have three choices for reversing: 
1. [2 1 3] - [1 2 3] [3 1 2] [2 3 1] 
2. [3 2 1] - [2 3 1] [1 2 3] [3 1 2] 
3. [1 3 2] - [3 1 2] [2 3 1] [1 2 3]  

So you have 9 possible arrays with each having a 1/9 probability.

For the last step: 
Each of the 9 arrays will have 3 possible sums with equal probability. For [1 2 3], you can get 1+2, 2+3 and 1+2+3. 
Since there will be 27 outcome for this input, one can calculate the expected value by finding sum of all 27 S and dividing it by 27. 
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int n,a,b;
    cin >> n >> a >> b;
    vector<double> d(n);
    for(int i=0; i<n; i++) cin >> d[i];
    double ee=0;
    for(int i=0; i<n; i++) ee+=d[i]/n;
    for(int i=0; i<n; i++) d[i]-=ee;
    for(int i=0; i<n; i++) d[i]*=pow((n-3.0)/(n-1), a);
    for(int i=0; i<n; i++) d[i]=ee+d[i];
    for(int bb=0; bb<b; bb++) {
        vector<double> e(n);
        for(int i=0; i<n; i++) for(int j=0; j<n; j++) {
            e[i] += d[j] * min( min(i,j)+1, n-max(i,j) );
        }
        for(int i=0; i<n; i++) e[i] += d[i] * (i*(i-1)/2 + (n-i-1)*(n-i-2)/2 - 1);
        for(int i=0; i<n; i++) d[i] = e[i]/(n*(n-1)/2);
    }
    //for(int i=0; i<n; i++) cout << d[i] << " "; cout << endl;
    double ret=0;
    for(int i=0; i<n; i++) ret += d[i] * ((i+1)*(n-i)-1);
    printf("%.09lf\n",ret / (n*(n-1)/2));
}

----------
====================
----------
MATHEMATICS.265
hard
----------
PROBLEM STATEMENT:
Let's consider a random permutation p1, p2, ..., pN of numbers 1, 2, ..., N and calculate the value F=(X2+...+XN-1)K, where Xi equals 1 if one of the following two conditions holds: pi-1 i  pi+1 or pi-1  pi i+1 and Xi equals 0 otherwise. What is the expected value of F?

Input Format: 
The first line contains two integers K and N.

Output Format: 
Print the expected value of F as an irreducible fraction p / q. Follow sample input for more clarification.

Constraints: 
1000 9 
1 

Sample input  

1 1000


Sample Output  

1996 / 3

----------
TOP SOLUTION:
----------
#include <iostream>
#include <string>
#include <sstream>
#include <cmath>
#include <algorithm>
#include <iomanip>
#define MAX 10000 // for strings

using namespace std;
class BigInteger {
private:
    string number;
    bool sign;
public:
    BigInteger(); // empty constructor initializes zero
    BigInteger(string s); // "string" constructor
    BigInteger(string s, bool sin); // "string" constructor
    BigInteger(int n); // "int" constructor
    void setNumber(string s);
    const string& getNumber(); // retrieves the number
    void setSign(bool s);
    const bool& getSign();
    BigInteger absolute(); // returns the absolute value
    void operator = (BigInteger b);
    bool operator == (BigInteger b);
    bool operator != (BigInteger b);
    bool operator > (BigInteger b);
    bool operator < (BigInteger b);
    bool operator >= (BigInteger b);
    bool operator <= (BigInteger b);
    BigInteger& operator ++(); // prefix
    BigInteger  operator ++(int); // postfix
    BigInteger& operator --(); // prefix
    BigInteger  operator --(int); // postfix
    BigInteger operator + (BigInteger b);
    BigInteger operator - (BigInteger b);
    BigInteger operator * (BigInteger b);
    BigInteger operator / (BigInteger b);
    BigInteger operator % (BigInteger b);
    BigInteger& operator += (BigInteger b);
    BigInteger& operator -= (BigInteger b);
    BigInteger& operator *= (BigInteger b);
    BigInteger& operator /= (BigInteger b);
    BigInteger& operator %= (BigInteger b);
    BigInteger& operator [] (int n);
    BigInteger operator -(); // unary minus sign
    operator string(); // for conversion from BigInteger to string
    long long toInt();
private:
    bool equals(BigInteger n1, BigInteger n2);
    bool less(BigInteger n1, BigInteger n2);
    bool greater(BigInteger n1, BigInteger n2);
    string add(string number1, string number2);
    string subtract(string number1, string number2);
    string multiply(string n1, string n2);
    pair<string, long long> divide(string n, long long den);
    string toString(long long n);
    long long toInt(string s);
};

//------------------------------------------------------------------------------
long long BigInteger::toInt() {
    return toInt(number);
}

BigInteger::BigInteger() { // empty constructor initializes zero
    number = "0";
    sign = false;
}

BigInteger::BigInteger(string s) { // "string" constructor
    if( isdigit(s[0]) ) { // if not signed
        setNumber(s);
        sign = false; // +ve
    } else {
        setNumber( s.substr(1) );
        sign = (s[0] == '-');
    }
}

BigInteger::BigInteger(string s, bool sin) { // "string" constructor
    setNumber( s );
    setSign( sin );
}

BigInteger::BigInteger(int n) { // "int" constructor
    stringstream ss;
    string s;
    ss << n;
    ss >> s;


    if( isdigit(s[0]) ) { // if not signed
        setNumber( s );
        setSign( false ); // +ve
    } else {
        setNumber( s.substr(1) );
        setSign( s[0] == '-' );
    }
}

void BigInteger::setNumber(string s) {
    number = s;
}

const string& BigInteger::getNumber() { // retrieves the number
    return number;
}

void BigInteger::setSign(bool s) {
    sign = s;
}

const bool& BigInteger::getSign() {
    return sign;
}

BigInteger BigInteger::absolute() {
    return BigInteger( getNumber() ); // +ve by default
}

void BigInteger::operator = (BigInteger b) {
    setNumber( b.getNumber() );
    setSign( b.getSign() );
}

bool BigInteger::operator == (BigInteger b) {
    return equals((*this) , b);
}

bool BigInteger::operator != (BigInteger b) {
    return ! equals((*this) , b);
}

bool BigInteger::operator > (BigInteger b) {
    return greater((*this) , b);
}

bool BigInteger::operator < (BigInteger b) {
    return less((*this) , b);
}

bool BigInteger::operator >= (BigInteger b) {
    return equals((*this) , b)
           || greater((*this), b);
}

bool BigInteger::operator <= (BigInteger b) {
    return equals((*this) , b)
           || less((*this) , b);
}

BigInteger& BigInteger::operator ++() { // prefix
    (*this) = (*this) + 1;
    return (*this);
}

BigInteger BigInteger::operator ++(int) { // postfix
    BigInteger before = (*this);

    (*this) = (*this) + 1;

    return before;
}

BigInteger& BigInteger::operator --() { // prefix
    (*this) = (*this) - 1;
    return (*this);

}

BigInteger BigInteger::operator --(int) { // postfix
    BigInteger before = (*this);

    (*this) = (*this) - 1;

    return before;
}

BigInteger BigInteger::operator + (BigInteger b) {
    BigInteger addition;
    if( getSign() == b.getSign() ) { // both +ve or -ve
        addition.setNumber( add(getNumber(), b.getNumber() ) );
        addition.setSign( getSign() );
    } else { // sign different
        if( absolute() > b.absolute() ) {
            addition.setNumber( subtract(getNumber(), b.getNumber() ) );
            addition.setSign( getSign() );
        } else {
            addition.setNumber( subtract(b.getNumber(), getNumber() ) );
            addition.setSign( b.getSign() );
        }
    }
    if(addition.getNumber() == "0") // avoid (-0) problem
        addition.setSign(false);

    return addition;
}

BigInteger BigInteger::operator - (BigInteger b) {
    b.setSign( ! b.getSign() ); // x - y = x + (-y)
    return (*this) + b;
}

BigInteger BigInteger::operator * (BigInteger b) {
    BigInteger mul;

    mul.setNumber( multiply(getNumber(), b.getNumber() ) );
    mul.setSign( getSign() != b.getSign() );

    if(mul.getNumber() == "0") // avoid (-0) problem
        mul.setSign(false);

    return mul;
}

// Warning: Denomerator must be within "long long" size not "BigInteger"
BigInteger BigInteger::operator / (BigInteger b) {
    long long den = toInt( b.getNumber() );
    BigInteger div;

    div.setNumber( divide(getNumber(), den).first );
    div.setSign( getSign() != b.getSign() );

    if(div.getNumber() == "0") // avoid (-0) problem
        div.setSign(false);

    return div;
}

// Warning: Denomerator must be within "long long" size not "BigInteger"
BigInteger BigInteger::operator % (BigInteger b) {
    long long den = toInt( b.getNumber() );

    BigInteger rem;
    long long rem_int = divide(number, den).second;
    rem.setNumber( toString(rem_int) );
    rem.setSign( getSign() != b.getSign() );

    if(rem.getNumber() == "0") // avoid (-0) problem
        rem.setSign(false);

    return rem;
}

BigInteger& BigInteger::operator += (BigInteger b) {
    (*this) = (*this) + b;
    return (*this);
}

BigInteger& BigInteger::operator -= (BigInteger b) {
    (*this) = (*this) - b;
    return (*this);
}

BigInteger& BigInteger::operator *= (BigInteger b) {
    (*this) = (*this) * b;
    return (*this);
}

BigInteger& BigInteger::operator /= (BigInteger b) {
    (*this) = (*this) / b;
    return (*this);
}

BigInteger& BigInteger::operator %= (BigInteger b) {
    (*this) = (*this) % b;
    return (*this);
}

BigInteger& BigInteger::operator [] (int n) {
    return *(this + (n*sizeof(BigInteger)));
}

BigInteger BigInteger::operator -() { // unary minus sign
    return (*this) * -1;
}

BigInteger::operator string() { // for conversion from BigInteger to string
    string signedString = ( getSign() ) ? "-" : ""; // if +ve, don't print + sign
    signedString += number;
    return signedString;
}

bool BigInteger::equals(BigInteger n1, BigInteger n2) {
    return n1.getNumber() == n2.getNumber()
           && n1.getSign() == n2.getSign();
}

bool BigInteger::less(BigInteger n1, BigInteger n2) {
    bool sign1 = n1.getSign();
    bool sign2 = n2.getSign();

    if(sign1 && ! sign2) // if n1 is -ve and n2 is +ve
        return true;

    else if(! sign1 && sign2)
        return false;

    else if(! sign1) { // both +ve
        if(n1.getNumber().length() < n2.getNumber().length() )
            return true;
        if(n1.getNumber().length() > n2.getNumber().length() )
            return false;
        return n1.getNumber() < n2.getNumber();
    } else { // both -ve
        if(n1.getNumber().length() > n2.getNumber().length())
            return true;
        if(n1.getNumber().length() < n2.getNumber().length())
            return false;
        return n1.getNumber().compare( n2.getNumber() ) > 0; // greater with -ve sign is LESS
    }
}

bool BigInteger::greater(BigInteger n1, BigInteger n2) {
    return ! equals(n1, n2) && ! less(n1, n2);
}

string BigInteger::add(string number1, string number2) {
    string add = (number1.length() > number2.length()) ?  number1 : number2;
    char carry = '0';
    int differenceInLength = abs( (int) (number1.size() - number2.size()) );

    if(number1.size() > number2.size())
        number2.insert(0, differenceInLength, '0'); // put zeros from left

    else// if(number1.size() < number2.size())
        number1.insert(0, differenceInLength, '0');

    for(int i=number1.size()-1; i>=0; --i) {
        add[i] = ((carry-'0')+(number1[i]-'0')+(number2[i]-'0')) + '0';

        if(i != 0) {
            if(add[i] > '9') {
                add[i] -= 10;
                carry = '1';
            } else
                carry = '0';
        }
    }
    if(add[0] > '9') {
        add[0]-= 10;
        add.insert(0,1,'1');
    }
    return add;
}

string BigInteger::subtract(string number1, string number2) {
    string sub = (number1.length()>number2.length())? number1 : number2;
    int differenceInLength = abs( (int)(number1.size() - number2.size()) );

    if(number1.size() > number2.size())
        number2.insert(0, differenceInLength, '0');

    else
        number1.insert(0, differenceInLength, '0');

    for(int i=number1.length()-1; i>=0; --i) {
        if(number1[i] < number2[i]) {
            number1[i] += 10;
            number1[i-1]--;
        }
        sub[i] = ((number1[i]-'0')-(number2[i]-'0')) + '0';
    }

    while(sub[0]=='0' && sub.length()!=1) // erase leading zeros
        sub.erase(0,1);

    return sub;
}

string BigInteger::multiply(string n1, string n2) {
    if(n1.length() > n2.length())
        n1.swap(n2);

    string res = "0";
    for(int i=n1.length()-1; i>=0; --i) {
        string temp = n2;
        int currentDigit = n1[i]-'0';
        int carry = 0;

        for(int j=temp.length()-1; j>=0; --j) {
            temp[j] = ((temp[j]-'0') * currentDigit) + carry;

            if(temp[j] > 9) {
                carry = (temp[j]/10);
                temp[j] -= (carry*10);
            } else
                carry = 0;

            temp[j] += '0'; // back to string mood
        }

        if(carry > 0)
            temp.insert(0, 1, (carry+'0'));

        temp.append((n1.length()-i-1), '0'); // as like mult by 10, 100, 1000, 10000 and so on

        res = add(res, temp); // O(n)
    }

    while(res[0] == '0' && res.length()!=1) // erase leading zeros
        res.erase(0,1);

    return res;
}

pair<string, long long> BigInteger::divide(string n, long long den) {
    long long rem = 0;
    string result;
    result.resize(MAX);

    for(int indx=0, len = n.length(); indx<len; ++indx) {
        rem = (rem * 10) + (n[indx] - '0');
        result[indx] = rem / den + '0';
        rem %= den;
    }
    result.resize( n.length() );

    while( result[0] == '0' && result.length() != 1)
        result.erase(0,1);

    if(result.length() == 0)
        result = "0";

    return make_pair(result, rem);
}

string BigInteger::toString(long long n) {
    stringstream ss;
    string temp;

    ss << n;
    ss >> temp;

    return temp;
}

long long BigInteger::toInt(string s) {
    long long sum = 0;

    for(int i=0; i<s.length(); i++)
        sum = (sum*10) + (s[i] - '0');

    return sum;
}

BigInteger ggT(BigInteger a, BigInteger b){
    if(b == 0)
        return a;
    else return ggT(b, a % b);
}

int main() {
    BigInteger K, N, z, n;
    uint64_t _tmp;
    cin >> _tmp;
    K = _tmp;
    cin >> _tmp;
    N = _tmp;
    
    N -= 2;
    
    if(K == 1) {
        z = N*2;
        n = 3;
        BigInteger tmp(ggT(z, n));
        z /= tmp;
        n /= tmp;
    } else if(K == 2) {
        z = N*N*40 + N*16 + 3;
        n = 90;
        BigInteger tmp(ggT(z, n));
        z /= tmp;
        n /= tmp;
    } else if(K == 3) {
        z = N*N*N*280 + N*N*336 + N*47 - 48;
        n = 945;
        BigInteger tmp(ggT(z, n));
        z /= tmp;
        n /= tmp;
    } else if(K == 4) {
        z = N*N*N*N*2800+N*N*N*6720+N*N*1964-N*2472+423;
        n = 14175;
        BigInteger tmp(ggT(z, n));
        z /= tmp;
        n /= tmp;
    } else {
        z = N*N*N*N*N*12320+N*N*N*N*49280+N*N*N*31768-N*N*36080+N*1674+2448;
        n = 93555;
        BigInteger tmp(ggT(z, n));
        z /= tmp;
        n /= tmp;
    }
    
    cout << z.getNumber() << " / " << n.getNumber() << endl;

    return 0;
}

----------
====================
----------
MATHEMATICS.266
medium
----------
PROBLEM STATEMENT:
You are given regular [expression] colors. Your task is to find the number of special subsets of polygon vertices. Each special subset must meet all the requirements:


The subset must contain at least two vertices.
If vertices belonging to the subset are erased from the polygon (note, that the adjacent edges of those vertices will also get erased), the remaining vertices and edges form some continuous paths. None of those paths should contain two vertices of the same color.


Please, calculate the number of described special subsets and print it modulo [expression].

Input Format

The first line contains an integer [expression] in clockwise order.

You may assume that each [expression].

Output Format

Print a single integer [expression].

Sample Input #1

4
1 1 1 1


Sample Output #1

7


Sample Input #2

4
4 2 3 1


Sample Output #2

11

----------
TOP SOLUTION:
----------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

#define M 100100
#define mod 1000000007ll
#define long long long

long d[M], s[M];
int n, a[M], h[M];
bool u[M];

void read() {
    cin >> n;
    for (int i = 1; i <= n; ++i)
        cin >> a[i];
}

void pre() {
    int l = 0;
    for (int i = 1; i <= n; ++i) {
        while (u[a[i]]) {
            ++l;
            u[a[l]] = false;
        }
        u[a[i]] = true;
        h[i] = l;
        //cout << i << " -> " << h[i] << "\n";
    }
}

void rundin(int x) {
    fill(d, d + M, 0);
    fill(s, s + M, 0);
    d[x] = 1;
    s[x] = 1;
    for (int i = x + 1; i <= n; ++i) {
        int l = h[i - 1];
        d[i] = (s[i - 1] - s[max(0, l - 1)]) % mod;
        s[i] = (d[i] + s[i - 1]) % mod;
    }
}

void kill() {
    long ans = 0;
    for (int i = 1; i < n && h[i - 1] == 0; ++i) {
        rundin(i);
        fill(u, u + M, false);

        for (int j = 1; j < i; ++j)
            u[a[j]] = true;

        //for (int j = 1; j <= n; ++j)
        //    cout << j << ": " << d[j] << "\n";

        int l = n;
        while (true) {

            ans = (ans + d[l]) % mod;

            if (u[a[l]])
                break;

            u[a[l]] = true;

            --l;

            if (l == i)
                break;
        }
    }

    if (ans < 0)
        ans += mod;

    cout << ans << "\n";
}

int main() {
#ifdef TROLL
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#else
    ios_base::sync_with_stdio(0);
#endif

    read();
    pre();
    kill();

    return 0;
}
----------
====================
----------
MATHEMATICS.267
easy
----------
PROBLEM STATEMENT:
Matrix Addition  

Add the two [expression]:

[1  2  3]       [4  5  6]     [a b c]
[2  3  4]   +   [7  8  9]  =  [d e f] 
[1  1  1]       [4  5  7]     [g h i]


To submit your answer, enter the resultant values of each of the nine integers (i.e., [expression]) on a new line and click Submit Code. 
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.268
easy
----------
PROBLEM STATEMENT:
Matrix Subtraction  

A matrix of size 3x3 is subtracted from another of a similar size. Find the integers [expression] in the resultant matrix. 

[1  2  3 ]        [4  5  6 ]      [A  B  C]
[2  3  4 ]   -    [7  8  9 ]   =  [D  E  F] 
[1  1  1 ]        [4  5  0 ]      [G  H  I]


In the text box below, enter each of the 9 integers, [expression] on a new line.  
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.269
easy
----------
PROBLEM STATEMENT:
Matrix Multiplication  

Two matrices of size 2x2 are multiplied as shown below. Find the integers [expression] in the resultant matrix. 

[1  2 ]   x     [4  5 ]      [A  B]
[2  3 ]         [7  8 ]   =  [C  D] 


In the text box below, enter each of the four integers, [expression] on a new line. 
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.270
easy
----------
PROBLEM STATEMENT:
Matrix Multiplication  

Two matrices of size 3x3 are multiplied as shown below. Find the integers [expression] in the resultant matrix. 

[1  2  3 ]        [4  5  6 ]      [A  B  C ]
[2  3  4 ]   x    [7  8  9 ]   =  [D  E  F ] 
[1  1  1 ]        [4  5  7 ]      [G  H  I ]


In the text box below, enter each of the 9 integers, [expression] on a new line. 
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.271
medium
----------
PROBLEM STATEMENT:
Given the following matrix [expression]:  

            [1   1   0 ]
      A =   [0   1   0 ]
            [0   0   1 ]


We compute that     

A100 = 

    [A B 0]
    [0 C 0]
    [0 D E]


In the text box below, enter the values of the integers [expression] each in a new line. Do not leave any extra leading or trailing spaces.  
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.272
medium
----------
PROBLEM STATEMENT:
Given the following matrix [expression]:  

            [1   1   0 ]
      A =   [0   1   0 ]
            [0   0   1 ]


Calculate the real numbers [expression] such that:

[expression] is the 3 x 3 identity matrix)

In the text box below, enter the integers [expression] each on a new line, respectively. Do not leave any leading or trailing spaces.  
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.273
hard
----------
PROBLEM STATEMENT:
You are provided a matrix [expression] =  

       [-2     -9 ]                  
       [ 1      4 ]          


The 1000th power of [expression]1000 = 

        [A  B]
        [C  D]


In the text box below, enter the integers [expression] each on a new line, respectively. Do not leave any leading or trailing spaces.      
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.274
hard
----------
PROBLEM STATEMENT:
There are more than one integer values of [expression] for which the following system of equations in x, y, z has no solutions:  

[expression] x + y  + 2 z = 0 
   x + 2 y +  z = b 
2 x + y + [expression] z = 0  

What is the smallest integer value of [expression] for which the above system has no solutions? Fill in the required integer value into the text box. Do not leave any leading or trailing spaces.  
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.275
hard
----------
PROBLEM STATEMENT:
Given the matrix [expression] =  

[0   1]
[-2 -3]


Compute the two eigenvalues of this matrix, and enter each of the two integers on a new line in the text box below, for submitting your answer. Enter the smaller eigenvalue in the first line and the larger eigenvalue in the second line.

For example, your answer may look like:  

-1
4

----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.276
medium
----------
PROBLEM STATEMENT:
Given the matrix [expression] =  

[0   1]
[-2 -3]


The two Eigenvectors of this matrix are computed as:

[expression] = k1 [+1  A ]T  and 
[expression] = k1 [+1  B ]T 

Also, A B 
In the text box, enter the two integers A and B, each on a new line. 
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.277
medium
----------
PROBLEM STATEMENT:
Find determinant of the following matrix -



Your answer’s determinant value should look like this:

5

----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.278
hard
----------
PROBLEM STATEMENT:
Let A be a 3 × 3 matrix with |A| = 5. Find each of the following -


|AT|
|2A|


Your answer should have first answer followed by the second answer separated by a line(resembling this) -

5
6

----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.279
medium
----------
PROBLEM STATEMENT:
Given following expression -


Find the following determinant value -


Your answer’s determinant value should look like this:

5

----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.280
hard
----------
PROBLEM STATEMENT:
Find the eigenvalues for the following matrix:



Then print the smallest eigenvalue on the first line and the largest eigenvalue on the second line. For example:

5
6


Note: You must print exactly two distinct values.
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.281
hard
----------
PROBLEM STATEMENT:
Find the eigenvalues of the matrix:


Your answer should have the eigenvalues separated by a single line resembling this(with smaller value coming first):

5
6

----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.282
hard
----------
PROBLEM STATEMENT:
Find the eigenvalues of A and A2 where A is -


Your answer should have the eigenvalues of A followed by eigenvalues of A2 separated by a single line resembling this(with smaller value coming first):

5
6
2
3

----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
MATHEMATICS.283
hard
----------
PROBLEM STATEMENT:
Find the eigenvalues and eigenvectors of A-1 and A - 4I where I is identity matrix and A is:


Your answer should have the eigenvalues of A-1 followed by eigenvalues of A - 4I each on a new line (with the smaller value coming first, for each pair):

5
6
2
3

----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================