
----------
MATHEMATICS.1
easy
----------
PROBLEM STATEMENT:
Consider two points, [expression].

Given [expression] on a new line.
----------
TOP SOLUTION:
----------
# Enter your code here. Read input from STDIN. Print output to STDOUT
N = int(raw_input())
for i in range(0, N):
   px, py, qx, qy = map(int, raw_input().split())
   print 2 * qx - px, 2 * qy - py 
----------
====================
----------
MATHEMATICS.2
easy
----------
PROBLEM STATEMENT:
Jim is off to a party and is searching for a matching pair of socks. His drawer is filled with socks, each pair of a different color. In its worst case scenario, how many socks (x) should Jim remove from his drawer until he finds a matching pair?  

Input Format 
The first line contains the number of test cases T. 
Next T lines contains an integer N which indicates the total pairs of socks present in the drawer.

Output Format 
Print the number of Draws (x) Jim makes in the worst case scenario.

Constraints 
[expression] 
[expression]  

Sample Input

2
1
2


Sample Output

2
3


Explanation 
Case 1 : A pair of socks are present, hence exactly 2 draws for the socks to match. 
Case 2 : 2 pair of socks are present in the drawer. The first and the second draw might result in 2 socks of different color. The 3rd sock picked will definitely match one of previously picked socks. Hence, 3. 
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int pigeonhole(int num) {
    return num+1;
}
int main() {
    int testC;
    cin &gt;&gt; testC; 
    int ar [testC];
    for(int i = 0; i &lt; testC; i++){
        cin &gt;&gt; ar[i];
    }
    for(int c = 0 ; c &lt; testC; c++){
        cout &lt;&lt; pigeonhole(ar[c]) &lt;&lt; endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.3
easy
----------
PROBLEM STATEMENT:
At the annual meeting of Board of Directors of Acme Inc, every one starts shaking hands with everyone else in the room. Given the fact that any two persons shake hand exactly once, Can you tell the total count of handshakes?

Input Format 
The first line contains the number of test cases T, T lines follow. 
Each line then contains an integer N, the total number of Board of Directors of Acme. 

Output Format  

Print the number of handshakes for each test-case in a new line. 

Constraints  

1 &lt;= T &lt;= 1000 
0 &lt; N &lt; 106  

Sample Input

2
1
2


Sample Output  

0
1


Explanation

Case 1 : The lonely board member shakes no hands, hence 0. 
Case 2 : There are 2 board members, 1 handshake takes place. 
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int T = s.nextInt();
        for (int t = 0; t &lt; T; t++) {
            long N = s.nextLong();
            System.out.println(N*(N-1)/2);
        }
    }
}
----------
====================
----------
MATHEMATICS.4
easy
----------
PROBLEM STATEMENT:
Given integers [expression].


----------
TOP SOLUTION:
----------
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdbool.h&gt;
int lowestTriangle(int base, int area)
{
    long int x;
    for(x=1;;x++)
    {
        if((base*x)/2&gt;=area)
            return x;
    }
}

int main() {
    int base; 
    int area; 
    scanf("%d %d", &amp;base, &amp;area);
    int height = lowestTriangle(base, area);
    printf("%ld\n", height);
    return 0;
}
----------
====================
----------
MATHEMATICS.5
easy
----------
PROBLEM STATEMENT:
Luke is daydreaming in Math class. He has a sheet of graph paper with [expression] bases. He wants to drop supplies at strategic points on the sheet, marking each drop point with a red dot. If a base contains at least one package inside or on top of its border fence, then it's considered to be supplied. For example:



Given [expression], what's the minimum number of packages that Luke must drop to supply all of his bases?
----------
TOP SOLUTION:
----------
#!/bin/python3

import sys


n,m = input().strip().split(' ')
n,m = [int(n),int(m)]

print(((n+1)//2)*((m+1)//2))

----------
====================
----------
MATHEMATICS.6
easy
----------
PROBLEM STATEMENT:
Leonardo loves primes and created [expression] and then print this value on a new line.

Note: Recall that a prime number is only divisible by [expression] is not a prime number.
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
    int a[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
    int i,t;
    unsigned long long int n;
    cin&gt;&gt;t;
    while(t&gt;0)
        {
    cin&gt;&gt;n;
        if(n&lt;2)
            cout&lt;&lt;0&lt;&lt;endl;
        else
   {unsigned long long int s=a[0];
            for(i=1;i&lt;25;i++)
       { s=s*a[i];
        if(n&lt;s)
        break; 
       }
    
    cout&lt;&lt;i&lt;&lt;endl;}
       
        t--;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.7
easy
----------
PROBLEM STATEMENT:
Gandalf is travelling from Rohan to Rivendell to meet Frodo but there is no direct route from Rohan (T1) to Rivendell (Tn). 

But there are towns T2,T3,T4...Tn-1 such that there are N1 routes from Town T1 to T2, and in general, Ni routes from Ti to Ti+1 for i=1 to n-1 and 0 routes for any other Ti to Tj  for  j ≠ i+1 

Find the total number of routes Gandalf can take to reach Rivendell from Rohan. 

Note 
Gandalf has to pass all the towns Ti for i=1 to n-1 in numerical order to reach Tn. 
For each Ti , Ti+1 there are only Ni distinct routes Gandalf can take.

Input Format 
The first line contains an integer T, T test-cases follow. 
Each test-case has 2 lines. The first line contains an integer N (the number of towns). 
The second line contains N - 1 space separated integers where the ith integer denotes the number of routes, Ni, from the town Ti to Ti+1  

Output Format 
Total number of routes from T1 to Tn modulo 1234567 
http://en.wikipedia.org/wiki/Modular_arithmetic

Constraints 
1 &lt;= T&lt;=1000
2&lt; N &lt;=100
1 &lt;= Ni &lt;=1000

Sample Input  

2
3
1 3
4
2 2 2


Sample Output  

3
8


Explanation 
Case 1: 1 route from T1 to T2, 3 routes from T2 to T3, hence only 3 routes. 
Case 2: There are 2 routes from each city to the next, at each city, Gandalf has 2 choices to make, hence 2 * 2 * 2 = 8. 
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    int t,n;
    cin&gt;&gt;t;
    while(t)
    {
        cin&gt;&gt;n;
        int product =1;
        while(n-1)
        {
            int temp;
            cin&gt;&gt;temp;
            product=(temp*product)%1234567;
            --n;
        }
        cout&lt;&lt;product&lt;&lt;endl;
        --t;
    }
    
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
MATHEMATICS.8
easy
----------
PROBLEM STATEMENT:
Mary has an [expression] pieces according to the following rules:


She can only cut one piece of paper at a time, meaning she cannot fold the paper or layer already-cut pieces on top of one another. 
Each cut is a straight line from one side of the paper to the other side of the paper. For example, the diagram below depicts the three possible ways to cut a [expression] piece of paper: 



Given [expression] unit in size. 
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;
#define sz(x) ((int) (x).size())
#define forn(i,n) for (int i = 0; i &lt; int(n); ++i)
typedef long long ll;
typedef long long i64;
typedef long double ld;
const int inf = int(1e9) + int(1e5);
const ll infl = ll(2e18) + ll(1e10);

int main() {
    #ifdef LOCAL
    assert(freopen("a.in", "r", stdin));
    #else
    #endif
    ll n, m;
    cin &gt;&gt; n &gt;&gt; m;
    cout &lt;&lt; n * m - 1 &lt;&lt; '\n';
}

----------
====================
----------
MATHEMATICS.9
medium
----------
PROBLEM STATEMENT:
You are given a sequence whose [expression] term is
[expression]
You have to evaluate the series
[expression]
Find [expression].
----------
TOP SOLUTION:
----------
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;cassert&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;

using namespace std;

#define vi vector &lt; int &gt;
#define pb push_back
#define ll long long
#define llu unsigned long long
#define MOD 1000000007
#define INF 2000000000
#define dbg(x) { cout&lt;&lt; #x &lt;&lt; ": " &lt;&lt; (x) &lt;&lt; endl; }
#define all(x) x.begin(),x.end()

int main()
{
    int t;
    scanf("%d",&amp;t);
    while(t--)
    {
              ll n;
              scanf("%lld",&amp;n);
              n%=MOD;
              ll ans = (n*n)%MOD;
              printf("%lld\n",ans);
    }
    //system("pause");
    return 0;
}

----------
====================
----------
MATHEMATICS.10
easy
----------
PROBLEM STATEMENT:
Sherlock is given [expression] plane; so that the bottom left corner of each square coincides with the the origin and their sides are parallel to the axes.  

At [expression].     

For each query of form [expression].  



Note: Assume all distances in meter, time in seconds and velocities in meter per second unless otherwise specified.  

Input Format 
First line contains integers [expression] in one line.

Constraints 
[expression] 
[expression] 
[expression] 
[expression]  

Output Format 
For each query, print the required answer in one line. Your answer will be considered correct if it is at most [expression] away from the true answer. See the explanation for more details.

Sample Input  

10 1 2
2
50
100


Sample Output  

4.1421
0.0000


Explanation  

For the first case, note that the answer is around 4.1421356237..., so any of the following will be accepted:  

4.1421356237
4.14214
4.14215000
4.1421
4.1422

----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;

typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef pair&lt;int,int&gt; ii;
#define sz(a) int((a).size())
#define pb push_back
#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin() i = (c).begin(); i != (c).end(); i++)
#define present(c,x) ((c).find(x) != (c).end())
#define cpresent(c,x) (find(all(c),x) != (c).end())

#define S(x) scanf("%d",&amp;x)
#define S1(x) scanf("%lld",&amp;x)
#define P(x) printf("%d\n",x)
#define Sd(x) scanf("%lf",&amp;x)
#define Pd(x) printf("%0.10lf\n",x)
#define P1(x) printf("%lld\n",x)
#define Ps(x) printf("%d ",x)
#define P1s(x) printf("%lld ",x)
#define St(x) scanf("%s",x)
#define Pt(x) printf("%s",x)
#define Sa(a,n) for(i=0;i&lt;n;i++){scanf("%lld",&amp;a[i]);}
#define Pa(a,n) for(i=0;i&lt;n;i++){printf("%lld ",a[i]);}putchar('\n')
#define Y printf("Yes\n")
#define N printf("No\n")
#define mod 1000000007
#define ll long long

ll power(ll b, ll e) {
    ll p = 1;
    while (e &gt; 0) {
        if(e&amp;1) {
            p = (p*b)%mod;
        }
        e = e&gt;&gt;1;
        b = (b * b)%mod;
    }
    return p;
}

ll inp()
{
	ll n=0,s=1;
	char c;
	for(c=getchar_unlocked();c&lt;48||c&gt;58;c=getchar_unlocked())
	if(c=='-')s=-1;
	for(;c&gt;47&amp;&amp;c&lt;59;c=getchar_unlocked())
	n=n*10+c-48;
	return n*s;
}

int main()
{
	ll n,i,t,j,k,l,s1,s2,v,qi;
	double vi;
	S1(l);
	S1(s1);
	S1(s2);
	vi=sqrt(2)/abs(s1-s2);
	for(S1(t);t--;)
        Pd((l-sqrt(inp()))*vi);
	return 0;
}

----------
====================
----------
MATHEMATICS.11
easy
----------
PROBLEM STATEMENT:
Kristen loves playing with and comparing numbers. She thinks that if she takes two different positive numbers, the one whose digits sum to a larger number is better than the other. If the sum of digits is equal for both numbers, then she thinks the smaller number is better. For example, Kristen thinks that [expression].

Given an integer, [expression] that Kristin will consider to be the best?
----------
TOP SOLUTION:
----------
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;
#include &lt;cstdio&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_map&gt;

using namespace std;


int main(){
    int n;
    cin &gt;&gt; n;
    int res = -1 , www = -1 &lt;&lt; 30;
    for (int i = 1 ; i &lt;= n ; ++ i) {
        if (n % i == 0) {
            int sum = 0 , x = i;
            while (x) {
                sum += x % 10;
                x /= 10;
            }
            if (sum &gt; www || sum == www &amp;&amp; i &lt; res) {
                res = i;
                www = sum;
            }
        }    
        
    }
    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
}

----------
====================
----------
MATHEMATICS.12
easy
----------
PROBLEM STATEMENT:
Martha is interviewing at Subway. One of the rounds of the interview requires her to cut a bread of size [expression] into smaller identical pieces such that each piece is a square having maximum possible side length with no left over piece of bread.
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int gcd(int a, int b) {
    return a==0?b:gcd(b%a,a);
}

int main() {
    int test;
    cin &gt;&gt; test;
    while(test--) {
        int a,b;
        cin &gt;&gt; a &gt;&gt; b;
        cout &lt;&lt; (a/gcd(a,b))*(b/gcd(a,b)) &lt;&lt; endl;
    }
    
    return 0;
}

----------
====================
----------
MATHEMATICS.13
easy
----------
PROBLEM STATEMENT:
Akash and Akhil are playing a game. They have [expression]. Akash will win the game, if he can answer. Help Akash.

Input Format 
The first line contains an integer [expression], i.e., the number of the test cases. 
The next [expression]. 

Output Format 
Print the final index of ball [expression] in the array.  

Constraints 
[expression] 
[expression] 
[expression]

Sample Input  

2
3 1
5 2


Sample Output  

2
4


Explanation 
For first test case, The rotation will be like this: 
0 1 2 -&gt; 2 1 0 -&gt; 2 0 1 -&gt; 2 0 1
So, Index of 1 will be 2.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

int main(){
    int t,n,k;
    scanf("%d",&amp;t);
    while(t--){
        scanf("%d %d",&amp;n,&amp;k);
        if(k&lt;n/2){
            printf("%d\n",2*k+1);
        }
        else{
            printf("%d\n",(n-1-k)*2);
        }
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.14
easy
----------
PROBLEM STATEMENT:
A strange grid has been recovered from an old book. It has [expression] columns and infinite number of rows. The bottom row is considered as the first row. First few rows of the grid are like this:

..............

..............

20 22 24 26 28

11 13 15 17 19

10 12 14 16 18

 1  3  5  7  9

 0  2  4  6  8


The grid grows upwards forever!

Your task is to find the integer in [expression]th row of the grid.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long     LL;
typedef pair&lt;int,int&gt; pii;

double PI  = acos(-1);
double EPS = 1e-7;
int INF    = 1000000000;
LL INFLL   = 1000000000000000000LL;

#define fi            first
#define se            second
#define mp            make_pair
#define pb            push_back

#define input(in)     freopen(in,"r",stdin)
#define output(out)   freopen(out,"w",stdout)

#define MIN(a, b)     (a) = min((a), (b))
#define MAX(a, b)     (a) = max((a), (b))

#define RESET(a, b)   memset(a,b,sizeof(a))
#define ALL(a)        (a).begin(), (a).end()
#define SIZE(a)       (int)a.size()
#define SORT(a)       sort(ALL(a))
#define UNIQUE(a)     (a).erase( unique( ALL(a) ), (a).end() )
#define FOR(a, b, c)  for (int (a)=(b); (a)&lt;=(c); (a)++)
#define FORD(a, b, c) for (int (a)=(b); (a)&gt;=(c); (a)--)
#define FORIT(a, b)   for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); a++)

int mx[8] = {-1,1,0,0,-1,-1,1,1};
int my[8] = {0,0,-1,1,-1,1,-1,1};

// ----- //

int main()
{
	int r,c;
	scanf("%d%d",&amp;r,&amp;c);
	r--;
	c--;
	int u = r/2;
	long long ans = 2LL*c+10LL*u;
	if (r%2==1) ans += 1;
	cout &lt;&lt; ans &lt;&lt; endl;
}

----------
====================
----------
MATHEMATICS.15
medium
----------
PROBLEM STATEMENT:
On the eve of Diwali, Hari is decorating his house with a serial light bulb set. The serial light bulb set has N bulbs placed sequentially on a string which is programmed to change patterns every second. If at least one bulb in the set is on at any given instant of time, how many different patterns of light can the serial light bulb set produce? 

Note: Lighting two bulbs *-* is different from **- 

Input Format 
The first line contains the number of test cases T, T lines follow. 
Each line contains an integer N, the number of bulbs in the serial light bulb set. 

Output Format 
Print the total number of patterns modulo 105

Constraints 
1 &lt;= T &lt;= 1000 
0&lt; N &lt; 104

Sample Input

2
1
2


Sample Output

1
3


Explanation

Case 1: 1 bulb can be lit in only 1 way. 
Case 2: 2 bulbs can be lit in -*, *-, ** i.e. 3 ways. 
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int T = s.nextInt();
        int M = 100000; // 17 bits
        for (int t = 0; t &lt; T; ++t) {
            long N = s.nextInt(), res = 1;
            while (N &gt; 0) {
                if (N &gt; 46) {
                    res &lt;&lt;= 46;
                    N -= 46;
                } else {
                    res &lt;&lt;= N;
                    N = 0;
                }
                res %= M;
            }
            System.out.println(res-1);
        }
    }
}
----------
====================
----------
MATHEMATICS.16
easy
----------
PROBLEM STATEMENT:
Watson gives an integer [expression] that are divisible by 2?.    

Input Format 
First line contains [expression].   

Output Format 
For each testcase, print the required answer in one line.      

Constraints 
[expression] 
[expression]  

Sample Input  

2
9
8


Sample Output   

0
3


Explanation 
9 has three divisors 1, 3 and 9 none of which is divisible by 2. 
8 has four divisors 1,2,4 and 8, out of which three are divisible by 2.  
----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;

using namespace std;

int main()
{
	int t;
	scanf("%d",&amp;t);
	while( t-- ) {
		long long n,i,j,k,l;
		scanf("%lld",&amp;n);
		long long ans =0;
		for(i=1;i*i&lt;=n;i++){
			if(n%i==0){
			if(n/i!=i){
				k = n/i;
				if(!(k&amp;1))
				ans++;
			}
			if(!(i&amp;1))
				ans++;
				
				}
			}
			printf("%lld\n",ans);
	}
	return 0;
}
----------
====================
----------
MATHEMATICS.17
hard
----------
PROBLEM STATEMENT:
Watson asks Sherlock: 
Given a string S of N 0's and M 1's, how many unique permutations of this string start with 1?   

Help Sherlock by printing the answer modulo (109+7).   

Input Format 
First line contains T, the number of test cases. 
Each test case consists of N and M separated by a space.

Output Format 
For each test case, print the answer modulo (109+7).

Constraints 
1 ≤ T ≤ 200 
1 ≤ N,M ≤ 1000  

Sample Input   

2
1 1
2 3


Sample Output      

1
6


Explanation 
Test1: Out of all unique permutations ie. 01 and 10, only second permutation satisfies. Hence, output is 1. 
Test2: Out of all unique permutations ie. 00111 01011 01101 01110 10011 10101 10110 11001 11010 11100, only 10011 10101 10110 11001 11010 11100 satisfy. Hence, output is 6.
----------
TOP SOLUTION:
----------
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;deque&gt;
#include &lt;list&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;cassert&gt;
using namespace std;
#define FOR(i,c) for(auto &amp;i: c)
#define SZ size()
#define ALL(x) (x).begin(),(x).end()
#define REP(i,n) for(int i=0;i&lt;(n);i++)
#define REP1(i,a,b) for(int i=(a);i&lt;=(b);i++)
#define REPL(i,x) for(int i=0;x[i];i++)
#define PER(i,n) for(int i=(n)-1;i&gt;=0;i--)
#define PER1(i,a,b) for(int i=(a);i&gt;=(b);i--)
#define RI(x) scanf("%d",&amp;x)
#define RL(x) scanf("%lld",&amp;x)
#define DRI(x) int x;RI(x)
#define DRL(x) LL x;RL(x)
#define RII(x,y) scanf("%d%d",&amp;x,&amp;y)
#define DRII(x,y) int x,y;RII(x,y)
#define RIII(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)
#define DRIII(x,y,z) int x,y,z;RIII(x,y,z)
#define RS(x) scanf("%s",x)
#define PI(x) printf("%d\n",x)
#define PL(x) printf("%lld\n",x)
#define PIS(x) printf("%d ",x)
#define MP make_pair
#define PB push_back
#define PQ priority_queue
#define E emplace
#define EB emplace_back
#define MS0(x) memset(x,0,sizeof(x))
#define MS1(x) memset(x,-1,sizeof(x))
#define SEP(x) ((x)?'\n':' ')
#define F first
#define S second
#define V(x) vector&lt;x &gt;

typedef pair&lt;int,int&gt; PII;
typedef vector&lt;int&gt; VI;
typedef long long LL;
typedef unsigned long long ULL;
const int INF = 2000000000;

const int MOD = 1000000007;
struct Z {
  int i;
  Z():i(0) {}
  Z(int i): i(i) {}
  void operator +=(const Z&amp; z) { i += z.i; if(i &gt;= MOD) i -= MOD; }
  void operator -=(const Z&amp; z) { i -= z.i; if(i &lt; 0) i += MOD; }
  void operator *=(const Z&amp; z) { i = (LL) i * z.i % MOD; }
  void operator /=(const Z&amp; z) { (*this) *= z.inverse(); }
  Z operator +(const Z&amp; z) const { Z ret(i); ret += z; return ret; }
  Z operator -(const Z&amp; z) const { Z ret(i); ret -= z; return ret; }
  Z operator *(const Z&amp; z) const { Z ret(i); ret *= z; return ret; }
  Z operator /(const Z&amp; z) const { return (*this) * z.inverse(); }
  // Z operator -() const { return Z(-i); }
  Z inverse() const {
    int a = i, d = MOD, x = 0, s = 1;
    while(a) {
      int q = d / a, r = d % a, t = x - q * s;
      d = a, a = r, x = s, s = t;
    }
    if (d != 1) return -1;
    return x &lt; 0 ? x + MOD : x;
  }
  Z pow(int b) {
    Z x=1,y=*this; // ll is taken to avoid overflow of intermediate results
    while(b &gt; 0){
      if(b%2 == 1)
        x *= y;
      y *= y; // squaring the base
      b /= 2;
    }
    return x;
  }
};

vector&lt;Z&gt; factorial(1, 1), inv_factorial(1, 1);

Z inv_fact(int n) {
  while(inv_factorial.size() &lt;= n)
    inv_factorial.push_back(inv_factorial.back() / inv_factorial.size());
  return inv_factorial.at(n);
}

Z fact(int n) {
  while(factorial.size() &lt;= n)
    factorial.push_back(factorial.back() * factorial.size());
  return factorial.at(n);
}

Z choose(int n, int k) {
  if(n &lt; k) return 0;
  return fact(n) * (inv_fact(k) * inv_fact(n-k));
}

int main() {
  DRI(T);
  while(T--) {
    DRII(N, M);
    PI(choose(N+M-1, N).i);
  }
  return 0;
}
----------
====================
----------
MATHEMATICS.18
hard
----------
PROBLEM STATEMENT:
You are given an array A of size N. You are also given an integer Q. Can you figure out the answer to each of the Q queries?

Each query contains 2 integers x and y, and you need to find whether the value find(x,y) is Odd or Even:

find(int x,int y)
{
    if(x&gt;y) return 1;
    ans = pow(A[x],find(x+1,y))
    return ans
}


Note : pow(a,b) = ab.

Input Format 
The first line of the input contains an integer N. 
The next line contains N space separated non-negative integers(whole numbers less than or equal to 9). 
The line after that contains a positive integer, Q , the denotes the number of queries to follow.
Q lines follow, each line contains two positive integer x and y separated by a single space.   

Output Format 
For each query, display 'Even' if the value returned is Even, otherwise display 'Odd'.

Constraints 
2 ≤ N ≤ 105 
2 ≤ Q ≤ 105 
1 ≤ x,y ≤ N 
x ≤ y

Array is 1-indexed.  

No 2 consecutive entries in the array will be zero.

Sample Input 

3
3 2 7
2
1 2
2 3


Sample Output 

Odd
Even


Explanation

find(1,2) = 9, which is Odd 
find(2,3) = 128, which is even  
----------
TOP SOLUTION:
----------
def isEoR(x,y,A):
    if x == y:
        if A[x]%2 == 0:
            return "Even"
        else:
            return "Odd"
    if A[x+1] == 0:
        return "Odd"
    elif A[x]%2 == 0:
        return "Even"
    else:
        return "Odd"

N = int(raw_input())
A = [int(j) for j in raw_input().split()]
A = [0]+A
for k in range(int(raw_input())):
        x,y = [int(j) for j in raw_input().split()]
        print isEoR(x,y,A)
            
----------
====================
----------
MATHEMATICS.19
medium
----------
PROBLEM STATEMENT:
You are given an integer N. Can you find the least positive integer X made up of only 9's and 0's, such that, X is a multiple of N?

Update  

X is made up of one or more occurences of 9 and zero or more occurences of 0. 

Input Format 
The first line contains an integer T which denotes the number of test cases. T lines follow. 
Each line contains the integer N for which the solution has to be found.

Output Format 
Print the answer X to STDOUT corresponding to each test case. The output should not contain any leading zeroes. 

Constraints 
1 &lt;= T &lt;= 104 
1 &lt;= N &lt;= 500

Sample Input  

3
5
7
1


Sample Output  

90
9009
9


Explanation 
90 is the smallest number made up of 9's and 0's divisible by 5. 
Similarly, you can derive for other cases. 

Timelimits
Timelimits for this challenge is given here
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int N = 5555;

bool was[N];
int x[N], pr[N], pd[N];

int main() {
    int tt;
    cin &gt;&gt; tt;
    while (tt--) {
        int n;
        cin &gt;&gt; n;
        for (int i = 0; i &lt; n; i++) was[i] = false;
        int b = 1, e = 1;
        x[1] = 9 % n;
        was[x[1]] = true;
        pr[x[1]] = -1;
        pd[x[1]] = -1;
        while (b &lt;= e) {
            int nx = (x[b] * 10 + 0) % n;
            if (!was[nx]) {
                e++;
                x[e] = nx;
                was[nx] = true;
                pr[nx] = x[b];
                pd[nx] = 0;
            }
            nx = (x[b] * 10 + 9) % n;
            if (!was[nx]) {
                e++;
                x[e] = nx;
                was[nx] = true;
                pr[nx] = x[b];
                pd[nx] = 9;
            }
            b++;
        }
        int p = 0;
        string res = "";
        while (pr[p] != -1) {
            res += (char)(pd[p] + 48);
            p = pr[p];
        }
        res += "9";
        reverse(res.begin(), res.end());
        cout &lt;&lt; res &lt;&lt; endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.20
hard
----------
PROBLEM STATEMENT:
A word from the English dictionary is taken and arranged as a matrix. e.g. "MATHEMATICS"

MATHE  
ATHEM  
THEMA  
HEMAT  
EMATI  
MATIC  
ATICS  


There are many ways to trace this matrix in a way that helps you construct this word. You start tracing the matrix from the top-left position and at each iteration, you either move RIGHT or DOWN, and ultimately reach the bottom-right of the matrix. It is assured that any such tracing generates the same word. How many such tracings can be possible for a given
word of length m+n-1 written as a matrix of size m * n?

Input Format 
The first line of input contains an integer T. T test cases follow. 
Each test case contains 2 space separated integers m &amp; n (in a new line) indicating that the matrix has m rows and each row has n characters.  

Constraints 
1 &lt;= T &lt;= 103 
1 ≤ m,n ≤ 106

Output Format 
Print the number of ways (S) the word can be traced as explained in the problem statement.
If the number is larger than 109+7, 
print  S mod (10^9 + 7) for each testcase (in a new line). 

Sample Input

1
2 3


Sample Output

3


Explanation 
Let's consider a word AWAY written as the matrix

AWA
WAY


Here, the word AWAY can be traced in 3 different ways, traversing either RIGHT or DOWN.

AWA
  Y

AW
 AY

A
WAY


Hence the answer is 3.

Timelimit
Time limit for this challenge is given here
----------
TOP SOLUTION:
----------
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

#define P 1000000007LL

long long a[2001000],i,j,k,l,m,n,t;


long long inv(long long xx)
{
long long zz,nn, vv;
    
vv = 1;
nn = P-2;
zz = xx;

while(nn)
{
if(nn&amp;1) vv = (vv*zz)%P;
zz = (zz*zz)%P;
nn/=2;    
}    
    
return vv;    
}

int main() {

    a[0] = 1;
    for(i=1;i&lt;=2000010;i++) a[i] = (i*a[i-1])%P;
    
    scanf("%lld",&amp;t);
    
    while(t)
    {
      t--;
        
        scanf("%lld %lld", &amp;m, &amp;n);
        m--;
        n--;
        
        printf("%lld\n", (a[m+n]*inv((a[m]*a[n])%P))%P);
    }

    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    
    return 0;
}

----------
====================
----------
MATHEMATICS.21
medium
----------
PROBLEM STATEMENT:
Simon: On the fountain, there should be 2 jugs - a 5 gallon and a 3 gallon. Do you see them? Fill one of the jugs with exactly 4 gallons of water and place it on the scale and the timer will stop. You must be precise; one ounce more or less will result in detonation. If you’re still alive in 5 minutes, we’ll speak. 

Bruce: Wait, wait a second. I don’t get it. Do you get it?   

Samuel: No. 

Bruce: Get the jugs. Obviously, we can’t ﬁll the 3 gallon jug with 4 gallons of water. 

Samuel: Obviously. 

Bruce: All right. I know, here we go. We ﬁll the 3 gallon jug exactly to the top, right? 

Samuel: Uh huh. 

Bruce: Okay, now we pour this 3 gallons into the 5 gallon jug, giving us exactly 3 gallons in the 5 gallon jug, right? 

Samuel: Right, then what? 

Bruce: We take the 3 gallon jug and ﬁll it a third of the way... 

Samuel: No! He said, “Be precise.” Exactly 4 gallons. 

Bruce: Damn! Every cop within 50 miles is running his ass off and I’m out here playing a kids' games in the park. 

Samuel: Hey, you want to focus on the problem at hand? 

Given 2 jugs of capacity a and b gallons, and an infinite supply of water, can you fill one of the jugs with exactly c gallons of water ? 

Input Format

First line contains the number of testcases T. T lines follow. 
Each line contains 3 space separated integers a, b and c . a and b indicate the capacity of the two jugs respectively, and c denotes the exact capacity with which one of the jugs should be filled.  

Output Format

For each test case, print "YES" (in a new line) if one of the jugs can be filled with exactly c gallons of water and "NO" (in a new line) if they cannot be filled. ( quotes are for clarity )

Constraints

1 ≤ a, b, c ≤ 103 
1 ≤ T ≤ 100

Sample Input

2
5 3 4
3 6 4


Sample Output

YES
NO


Explanation

Bruce can do the following, fill jug a with 5 gallons. 

a = 5, b = 0


Now, he can fill jug b with 3 gallons from jug a.  

a = 2, b = 3


He can empty jug b and empty 2 gallons from jug a to jug b.  

a = 0, b = 2


Now, he can fill jug a with 5 gallons and fill jug b with 1 gallon from jug a.  This results in jug a containing exactly 4 gallons of water.  

a = 5, b = 2
a = 4, b = 3


In the second testcase, it is impossible to generate 4 gallons of water, hence NO.  
----------
TOP SOLUTION:
----------
A = 0
B = 0

def CUP():
    s = set()
    cup_B = B
    cup_A = cup_B
    cup_B = 0
    s.update(set([cup_A]))
    while(1):
        cup_B = B
        if cup_A + cup_B &gt; A:
            cup_A = cup_A + cup_B - A
            if cup_A not in s:
                s.update(set([cup_A]))
            else:
                return s
        else:
            cup_B = B
            cup_A += cup_B
            cup_B = 0
            if cup_A not in s:
                s.update(set([cup_A]))
            else:
                return s

        

for iteration in range(int(raw_input())):
    a,b,c = [int(x) for x in raw_input().split()]
    a,b = [max(a,b),min(a,b)] 
    A = a
    B = b

    if c in CUP():
        print 'YES'
    else:
        print 'NO'

----------
====================
----------
MATHEMATICS.22
easy
----------
PROBLEM STATEMENT:
Alex is attending a Halloween party with his girlfriend, Silvia. At the party, Silvia spots the corner of an infinite chocolate bar (two dimensional, infinitely long in width and length).  

If the chocolate can be served only as 1 x 1 sized pieces and Alex can cut the chocolate bar exactly [expression] times, what is the maximum number of chocolate pieces Alex can cut and give Silvia?

Input Format 
The first line contains an integer [expression] lines follow.
Each line contains an integer [expression].  

Output Format
[expression] lines; each line should contain an integer that denotes the maximum number of pieces that can be obtained for each test case.

Constraints
[expression]
[expression]

Note: Chocolate must be served in 1 x 1 sized pieces. Alex can't relocate any of the pieces, nor can he place any piece on top of another.

Sample Input #00  

4
5
6
7
8


Sample Output #00  

6
9
12
16


Explanation
The explanation below is for the first two test cases. The rest of them follow a similar logic.

For the first test-case where [expression] vertical cuts. 

For the second test case, where [expression] vertical cuts.
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int t,k;
    for(cin&gt;&gt;t;t--;) {
        cin&gt;&gt;k;
        int l=k/2;
        long long r=k-l;
        cout&lt;&lt;l*r&lt;&lt;'\n';
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.23
easy
----------
PROBLEM STATEMENT:
Animesh has [expression] (both inclusive).
Can you tell the average number of candies after [expression] operations?
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    int N, M;
    long long tot = 0;
    cin &gt;&gt; N &gt;&gt; M;
    for(int i=0;i&lt;M;i++){
        int a, b;
        long long k;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;
        tot+= (b-a+1)*k;
    }
    
    cout &lt;&lt; tot/N &lt;&lt; endl;
    return 0;
}

----------
====================
----------
MATHEMATICS.24
medium
----------
PROBLEM STATEMENT:
You are given an integer, [expression] is an element of the Fibonacci sequence.  

The first few elements of the Fibonacci sequence are [expression]. 

Formally: 
[expression]

Input Format 
The first line contains [expression], number of test cases. 
[expression].

Output Format 
Display IsFibo if [expression] is a Fibonacci number and IsNotFibo  if it is not. The output for each test case should be displayed in a new line.

Constraints 
[expression] 
[expression]

Sample Input  

3
5
7
8


Sample Output  

IsFibo
IsNotFibo
IsFibo


Explanation 
[expression] 
[expression] is not a Fibonacci number 
[expression]  

Time Limit 
Time limit for this challenge is given here. 

----------
TOP SOLUTION:
----------
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;set&gt;

using namespace std;

set&lt;long long&gt; fib;

int main() {
    long long a = 1, b = 1;
    fib.insert(0); fib.insert(1);
    
    while (b &lt;= 10000000000LL) {
        long long c = a + b;
        fib.insert(c);
        a = b; b = c;
    }
    
    int n; scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; ++ i) {
        long long q;
        scanf("%lld", &amp;q);
        if (fib.count(q)) printf("IsFibo\n");
        else printf("IsNotFibo\n");
    }
    
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    
    return 0;
}

----------
====================
----------
MATHEMATICS.25
medium
----------
PROBLEM STATEMENT:
Jim enters a candy shop which has N different types of candies, each candy is of the same price. Jim has enough money to buy K candies. In how many different ways can he purchase K candies if there are infinite candies of each kind? 

Input Format 
The first line contains an integer T, the number of tests. 
This is followed by 2T lines which contain T tests: 
The first line (of each testcase) is an integer N and the second line (of each testcase) is an integer K.   

Output Format 
For each testcase, print the number of ways Jim can buy candies from the shop in a newline. If the answer has more than 9 digits, print the last 9 digits.  

Note 
This problem may expect you to have solved nCr Table

Constraints 
1 &lt;= T &lt;= 200 
1 &lt;= N &lt; 1000 
1 &lt;= K &lt; 1000  

Sample Input  

2
4
1
2
3


Sample Output  

4
4


Explanation 
There are 2 testcases, for the first testcase we have N = 4 and K = 1, as Jim can buy only 1 candy, he can choose to buy any of the 4 types of candies available. Hence, his answer is 4.
For the 2nd testcase, we have N = 2 and K = 3, If we name two chocolates as a and b, he can buy 

aaa bbb aab abb 


chocolates, hence 4. 
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int C[2002][2002];

int Comb(int n, int r){
    //cout&lt;&lt;n&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;
    if(C[n][r] != -1){
        return C[n][r];
    }
    else if(n == 1){
        C[1][1] = 1;
        C[1][0] = 1;
        return C[1][1];
    }
    else if(r==0 || r == n){
        C[n][0] = 1;
        C[n][n] = 1;
        return C[n][0];
    }
    else{
        long long a = ((long long)Comb(n-1,r) + (long long)Comb(n-1,r-1))%1000000000;
        C[n][r] = (int)a;
        C[n][n-r] = (int)a;
        return C[n][r];
    }
}


int main() {
    int t, n, r,i,j,k;
    cin&gt;&gt;t;
    for(i=0;i&lt;=2001;i++){
        for(j=0;j&lt;=2001;j++){
            C[i][j] = -1;
        }
    }
    while(t-- &gt; 0){
        cin&gt;&gt;n;
        cin&gt;&gt;k;
        cout&lt;&lt;Comb(n+k-1,k)&lt;&lt;endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.26
easy
----------
PROBLEM STATEMENT:
Famous wizard Sumar moonji kumaru is stuck in a huge room and has to save Hermione Granger from a monster. Kumaru is at location P1 given by integral coordinates (x1,y1) and Hermione is at location P2 given by integral coordinates (x2,y2). 
Sadly P1 and P2 are the only points at which floating rocks are present. Rest of the room is without floor and underneath is hot lava. 

Kumaru has to go from P1 to P2 but there are no floating rocks to walk on. Kumaru knows a spell that can make the rocks appear but only on the integral coordinates on the straight line joining P1 and P2.

How many rocks can appear at locations (x,y) on the line segment between P1 and P2 (excluding P1 and P2) which satisfy the condition that both x and y are integers?

Input Format 
The first line contains a single integer T, the number of test cases. T lines follow. 
 Each of the following T lines contains one test case each. Each test case contains 4 integers x1, y1, x2 and y2 separated by a single space. 

Output Format 
A single line containing the number of rocks.

Constraints 
1 &lt;= T &lt;= 105 
-109 &lt;= x1, y1, x2, y2 &lt;= 109

Sample input  

3
0 2 4 0
2 2 5 5
1 9 8 16


Sample Output

1
2
6


Explanation   



Case 1: As shown in the figure, between (0,2) and (4,0) there's only 1 integral point (2,1) hence 1 rock. 
Case 2: Between (2,2) and (5,5) lies (3,3) and (4,4), hence 2 rocks. 
Case 3: Between (1,9) and (8,16) there lies 6 rocks at positions (2,10) (3,11) (4,12) (5,13) (6,14) (7,15).  
----------
TOP SOLUTION:
----------
import java.io.OutputStreamWriter;
import java.io.BufferedWriter;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.List;
import java.io.IOException;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.math.BigInteger;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Egor Kulikov (egor@egork.net)
 */
public class Solution {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		HarryPotterAndTheFloatingRocks solver = new HarryPotterAndTheFloatingRocks();
		int testCount = Integer.parseInt(in.next());
		for (int i = 1; i &lt;= testCount; i++)
			solver.solve(i, in, out);
		out.close();
	}
}

class HarryPotterAndTheFloatingRocks {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
		int x0 = in.readInt();
		int y0 = in.readInt();
		int x1 = in.readInt();
		int y1 = in.readInt();
		int dx = x0 - x1;
		int dy = y0 - y1;
		out.printLine(IntegerUtils.gcd(dx, dy) - 1);
    }
}

class InputReader {

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar &gt;= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars &lt;= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c &lt; '0' || c &gt; '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do {
			if (Character.isValidCodePoint(c))
				res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	public boolean isSpaceChar(int c) {
		if (filter != null)
			return filter.isSpaceChar(c);
		return isWhitespace(c);
	}

	public static boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	public String next() {
		return readString();
	}

	public interface SpaceCharFilter {
		public boolean isSpaceChar(int ch);
	}
}

class OutputWriter {
	private final PrintWriter writer;

	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
	}

	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}

	public void close() {
		writer.close();
	}

	public void printLine(int i) {
		writer.println(i);
	}
}

class IntegerUtils {

    public static int gcd(int a, int b) {
        a = Math.abs(a);
        b = Math.abs(b);
        while (b != 0) {
            int temp = a % b;
            a = b;
            b = temp;
        }
        return a;
    }

    }

----------
====================
----------
MATHEMATICS.27
easy
----------
PROBLEM STATEMENT:
We all know how to calculate [expression] can be large, which makes exponentiation very slow.

There is a well known method called Russian Peasant Multiplication that you can read about here. Now let's use this to raise some complex numbers to powers!

You're given [expression] as two space-separated integers on a new line. 
----------
TOP SOLUTION:
----------
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MOD 1000000007

typedef long long LL;
typedef struct ComplexNumber{

	LL re;
	LL im;

}CPLXN;

CPLXN mul_cplxn(CPLXN a, CPLXN b, LL mod)
{
	CPLXN res;
	
	res.re = ((a.re * b.re) - (a.im * b.im)) % mod;
	res.im = ((a.re * b.im) + (a.im * b.re)) % mod;

	return res;
}

CPLXN quickPowComplex(CPLXN x, LL p, LL mod)
{
	CPLXN I;
	I.re = 1;
	I.im = 0;

	while(p)
	{
		if(p &amp; 1)
			I = mul_cplxn(I, x, mod);
		x = mul_cplxn(x, x, mod);
		p = p &gt;&gt; 1;
	}

	return I;
}

int main(int argc, char const *argv[])
{
	int i, q;
	LL a, b, k, m;
	CPLXN r, res;
	LL x;

	scanf("%d", &amp;q);
	for(i = 0; i &lt; q; i++)
	{
		scanf("%lld%lld%lld%lld", &amp;a, &amp;b, &amp;k, &amp;m);
		r.re = a;
		r.im = b;

		res = quickPowComplex(r, k, m);
        if(res.re &lt; 0)
            res.re += m;
        if(res.im &lt; 0)
            res.im += m;

		printf("%lld %lld\n", res.re, res.im);
	}

    return 0;
}


----------
====================
----------
MATHEMATICS.28
medium
----------
PROBLEM STATEMENT:
There are [expression] people. 

They live near a bus stop, and only a single bus operates on this route. An empty bus arrives at the bus stop and all the groups want to travel by the bus. 

However,  group of friends do not want to get separated. So they enter the bus only if the bus can carry the entire group. 

Moreover, the groups do not want to change their relative positioning while travelling.  In other words, group 3 cannot travel by bus, unless group 1 and group 2 have either (a) already traveled by the bus in the previous trip or (b) they are also sitting inside the bus at present.

You are given that a bus of size [expression] people simultaneously. 

Find the size [expression] of the bus so that 
(1) the bus can transport all the groups and 
(2) every time when the bus starts from the bus station, there is no empty space in the bus (i.e. the total number of people present inside the bus is equal to [expression])?

Input Format 
The first line contains an integer [expression].

Output Format

Print all possible sizes of the bus in an increasing order.

Sample Input

8
1 2 1 1 1 2 1 3


Sample Output

3 4 6 12


Sample Explanation

In the above example, 
[expression] = 3.

If x = 1 : 
In the first trip, [expression] go by the bus.
There will be no second trip because the bus cannot accommodate group 2. Hence "x = 1" is not the required answer.

If x = 2 :
No bus trip is possible. That's because [expression] cannot go together, because the bus is cannot accommodate both the groups simultaneously.

If x = 3 : 
In the first trip, [expression] go by the bus. 
In the second trip, [expression] go by the bus. 
In the third trip, [expression] go by the bus. 
In the fourth trip, [expression] go by the bus. 

If x = 4 : 
In the first trip, [expression] go by the bus. 
In the second trip,  [expression]go by the bus. 
In the third trip, [expression] go by the bus. 

Similarly you can figure out the output for x= 5, 6 &amp; 7.
----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;

#define REP(i,a,b) for(i=a;i&lt;b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'&lt;=k&amp;&amp;k&lt;='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k&lt;'0'||k&gt;'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void writer(int x, char c){int i,sz=0,m=0;char buf[10];if(x&lt;0)m=1,x=-x;while(x)buf[sz++]=x%10,x/=10;if(!sz)buf[sz++]=0;if(m)mypc('-');while(sz--)mypc(buf[sz]+'0');mypc(c);}

int N, A[110000];

int res[100000], ress;
int sum;

int check(int k){
  int i, j;
  int now;

  now = 0;
  rep(i,N){
    now += A[i];
    if(now &gt; k) return 0;
    if(now==k) now = 0;
  }

  return 1;
}

int main(){
  int i, j, k;

  reader(&amp;N);
  rep(i,N) reader(A+i);

  sum = 0;
  rep(i,N) sum += A[i];

  ress = 0;
  for(i=1;i*i&lt;=sum;i++) if(sum%i==0){
    if(check(i)) res[ress++] = i;
    if(i!=sum/i &amp;&amp; check(sum/i)) res[ress++] = sum/i;
  }

  sort(res,res+ress);
  rep(i,ress) writer(res[i], i==ress-1?'\n':' ');

  return 0;
}

----------
====================
----------
MATHEMATICS.29
easy
----------
PROBLEM STATEMENT:
Keko has [expression] coordinate to zero.   

Help Keko calculate the distance!
----------
TOP SOLUTION:
----------

  <div id="main-frame-error" class="interstitial-wrapper" jstcache="0">
    <div id="main-content" jstcache="0">
      <div class="icon icon-generic" jseval="updateIconClass(this.classList, iconClass)" alt="" jstcache="1"></div>
      <div id="main-message" jstcache="0">
        <h1 jstcache="0">
          <span jsselect="heading" jsvalues=".innerHTML:msg" jstcache="10">This <span jscontent="hostName" jstcache="23">www.hackerrank.com</span> page can’t be found</span>
          <a id="error-information-button" class="hidden" onclick="toggleErrorInformationPopup();" jstcache="0"></a>
        </h1>
        <p jsselect="summary" jsvalues=".innerHTML:msg" jstcache="2">No webpage was found for the web address: <strong jscontent="failedUrl" jstcache="24">https://www.hackerrank.com/rest/contests/master/challenges/most-distant/hackers/[deleted]/download_solution?primary=true</strong></p>
        <!--The suggestion list and error code are normally presented inline,
          in which case error-information-popup-* divs have no effect. When
          error-information-popup-container has the use-popup-container class, this
          information is provided in a popup instead.-->
        <div id="error-information-popup-container" jstcache="0">
          <div id="error-information-popup" jstcache="0">
            <div id="error-information-popup-box" jstcache="0">
              <div id="error-information-popup-content" jstcache="0">
                <div id="suggestions-list" style="display:none" jsdisplay="(suggestionsSummaryList &amp;&amp; suggestionsSummaryList.length)" jstcache="17">
                  <p jsvalues=".innerHTML:suggestionsSummaryListHeader" jstcache="19"></p>
                  <ul jsvalues=".className:suggestionsSummaryList.length == 1 ? 'single-suggestion' : ''" jstcache="20">
                    <li jsselect="suggestionsSummaryList" jsvalues=".innerHTML:summary" jstcache="22"></li>
                  </ul>
                </div>
                <div class="error-code" jscontent="errorCode" jstcache="18">HTTP ERROR 404</div>
                <p id="error-information-popup-close" jstcache="0">
                  <a class="link-button" jscontent="closeDescriptionPopup" onclick="toggleErrorInformationPopup();" jstcache="21">null</a>
                </p>
              </div>
            </div>
          </div>
        </div>
        <div id="diagnose-frame" class="hidden" jstcache="0"></div>
        <div id="download-links-wrapper" class="hidden" jstcache="0">
          <div id="download-link-wrapper" jstcache="0">
            <a id="download-link" class="link-button" onclick="downloadButtonClick()" jsselect="downloadButton" jscontent="msg" jsvalues=".disabledText:disabledMsg" jstcache="7" style="display: none;">
            </a>
          </div>
          <div id="download-link-clicked-wrapper" class="hidden" jstcache="0">
            <div id="download-link-clicked" class="link-button" jsselect="downloadButton" jscontent="disabledMsg" jstcache="12" style="display: none;">
            </div>
          </div>
        </div>
        <div id="save-page-for-later-button" class="hidden" jstcache="0">
          <a class="link-button" onclick="savePageLaterClick()" jsselect="savePageLater" jscontent="savePageMsg" jstcache="11" style="display: none;">
          </a>
        </div>
        <div id="cancel-save-page-button" class="hidden" onclick="cancelSavePageClick()" jsselect="savePageLater" jsvalues=".innerHTML:cancelMsg" jstcache="5" style="display: none;">
        </div>
        <div id="offline-content-list" class="list-hidden" hidden="" jstcache="0">
          <div id="offline-content-list-visibility-card" onclick="toggleOfflineContentListVisibility(true)" jstcache="0">
            <div id="offline-content-list-title" jsselect="offlineContentList" jscontent="title" jstcache="13" style="display: none;">
            </div>
            <div jstcache="0">
              <div id="offline-content-list-show-text" jsselect="offlineContentList" jscontent="showText" jstcache="15" style="display: none;">
              </div>
              <div id="offline-content-list-hide-text" jsselect="offlineContentList" jscontent="hideText" jstcache="16" style="display: none;">
              </div>
            </div>
          </div>
          <div id="offline-content-suggestions" jstcache="0"></div>
          <div id="offline-content-list-action" jstcache="0">
            <a class="link-button" onclick="launchDownloadsPage()" jsselect="offlineContentList" jscontent="actionText" jstcache="14" style="display: none;">
            </a>
          </div>
        </div>
      </div>
    </div>
    <div id="buttons" class="nav-wrapper suggested-right" jstcache="0">
      <div id="control-buttons" jstcache="0">
        <button id="reload-button" class="blue-button text-button" onclick="trackClick(this.trackingId);
                     reloadButtonClick(this.url);" jsselect="reloadButton" jsvalues=".url:reloadUrl; .trackingId:reloadTrackingId" jscontent="msg" jstcache="6">Reload</button>
        <button id="download-button" class="blue-button text-button" onclick="downloadButtonClick()" jsselect="downloadButton" jscontent="msg" jsvalues=".disabledText:disabledMsg" jstcache="7" style="display: none;">
        </button>
      </div>
      <button id="details-button" class="secondary-button text-button small-link" onclick="detailsButtonClick(); toggleHelpBox()" jscontent="details" jsdisplay="(suggestionsDetails &amp;&amp; suggestionsDetails.length > 0) || diagnose" jsvalues=".detailsText:details; .hideDetailsText:hideDetails;" jstcache="3" style="display: none;"></button>
    </div>
    <div id="details" class="hidden" jstcache="0">
      <div class="suggestions" jsselect="suggestionsDetails" jstcache="4" jsinstance="*0" style="display: none;">
        <div class="suggestion-header" jsvalues=".innerHTML:header" jstcache="8"></div>
        <div class="suggestion-body" jsvalues=".innerHTML:body" jstcache="9"></div>
      </div>
    </div>
  </div>
  <div id="sub-frame-error" jstcache="0">
    <!-- Show details when hovering over the icon, in case the details are
         hidden because they're too large. -->
    <div class="icon icon-generic" jseval="updateIconClass(this.classList, iconClass)" jstcache="1"></div>
    <div id="sub-frame-error-details" jsselect="summary" jsvalues=".innerHTML:msg" jstcache="2">No webpage was found for the web address: <strong jscontent="failedUrl" jstcache="24">https://www.hackerrank.com/rest/contests/master/challenges/most-distant/hackers/[deleted]/download_solution?primary=true</strong></div>
  </div>

  <div id="offline-resources" jstcache="0">
    <img id="offline-resources-1x" src="data:image/png;base64,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" jstcache="0">
    <img id="offline-resources-2x" src="data:image/png;base64,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" jstcache="0">
    <template id="audio-resources" jstcache="0">
      <audio id="offline-sound-press" src="data:audio/mpeg;base64,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"></audio>
      <audio id="offline-sound-hit" src="data:audio/mpeg;base64,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"></audio>
      <audio id="offline-sound-reached" src="data:audio/mpeg;base64,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"></audio>
    </template>
  </div>


<script jstcache="0">// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This file defines a singleton which provides access to all data
 * that is available as soon as the page's resources are loaded (before DOM
 * content has finished loading). This data includes both localized strings and
 * any data that is important to have ready from a very early stage (e.g. things
 * that must be displayed right away).
 *
 * Note that loadTimeData is not guaranteed to be consistent between page
 * refreshes (https://crbug.com/740629) and should not contain values that might
 * change if the page is re-opened later.
 */

// #import {assert} from './assert.m.js';
// #import {parseHtmlSubset} from './parse_html_subset.m.js';

/**
 * @typedef {{
 *   substitutions: (Array<string>|undefined),
 *   attrs: (Object<function(Node, string):boolean>|undefined),
 *   tags: (Array<string>|undefined),
 * }}
 */
/* #export */ let SanitizeInnerHtmlOpts;

// eslint-disable-next-line no-var
/* #export */ /** @type {!LoadTimeData} */ var loadTimeData;

// Expose this type globally as a temporary work around until
// https://github.com/google/closure-compiler/issues/544 is fixed.
/** @constructor */
function LoadTimeData(){}

(function() {
  'use strict';

  LoadTimeData.prototype = {
    /**
     * Sets the backing object.
     *
     * Note that there is no getter for |data_| to discourage abuse of the form:
     *
     *     var value = loadTimeData.data()['key'];
     *
     * @param {Object} value The de-serialized page data.
     */
    set data(value) {
      expect(!this.data_, 'Re-setting data.');
      this.data_ = value;
    },

    /**
     * Returns a JsEvalContext for |data_|.
     * @returns {JsEvalContext}
     */
    createJsEvalContext: function() {
      return new JsEvalContext(this.data_);
    },

    /**
     * @param {string} id An ID of a value that might exist.
     * @return {boolean} True if |id| is a key in the dictionary.
     */
    valueExists: function(id) {
      return id in this.data_;
    },

    /**
     * Fetches a value, expecting that it exists.
     * @param {string} id The key that identifies the desired value.
     * @return {*} The corresponding value.
     */
    getValue: function(id) {
      expect(this.data_, 'No data. Did you remember to include strings.js?');
      const value = this.data_[id];
      expect(typeof value != 'undefined', 'Could not find value for ' + id);
      return value;
    },

    /**
     * As above, but also makes sure that the value is a string.
     * @param {string} id The key that identifies the desired string.
     * @return {string} The corresponding string value.
     */
    getString: function(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'string');
      return /** @type {string} */ (value);
    },

    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument.
     * @param {string} id The ID of the string we want.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    getStringF: function(id, var_args) {
      const value = this.getString(id);
      if (!value) {
        return '';
      }

      const args = Array.prototype.slice.call(arguments);
      args[0] = value;
      return this.substituteString.apply(this, args);
    },

    /**
     * Make a string safe for use with with Polymer bindings that are
     * inner-h-t-m-l (or other innerHTML use).
     * @param {string} rawString The unsanitized string.
     * @param {SanitizeInnerHtmlOpts=} opts Optional additional allowed tags and
     *     attributes.
     * @return {string}
     */
    sanitizeInnerHtml: function(rawString, opts) {
      opts = opts || {};
      return parseHtmlSubset('<b>' + rawString + '</b>', opts.tags, opts.attrs)
          .firstChild.innerHTML;
    },

    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument. Any standalone $ signs must be escaped as
     * $$.
     * @param {string} label The label to substitute through.
     *     This is not an resource ID.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    substituteString: function(label, var_args) {
      const varArgs = arguments;
      return label.replace(/\$(.|$|\n)/g, function(m) {
        assert(m.match(/\$[$1-9]/), 'Unescaped $ found in localized string.');
        return m == '$$' ? '$' : varArgs[m[1]];
      });
    },

    /**
     * Returns a formatted string where $1 to $9 are replaced by the second to
     * tenth argument, split apart into a list of pieces describing how the
     * substitution was performed. Any standalone $ signs must be escaped as $$.
     * @param {string} label A localized string to substitute through.
     *     This is not an resource ID.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {!Array<!{value: string, arg: (null|string)}>} The formatted
     *     string pieces.
     */
    getSubstitutedStringPieces: function(label, var_args) {
      const varArgs = arguments;
      // Split the string by separately matching all occurrences of $1-9 and of
      // non $1-9 pieces.
      const pieces = (label.match(/(\$[1-9])|(([^$]|\$([^1-9]|$))+)/g) ||
                      []).map(function(p) {
        // Pieces that are not $1-9 should be returned after replacing $$
        // with $.
        if (!p.match(/^\$[1-9]$/)) {
          assert(
              (p.match(/\$/g) || []).length % 2 == 0,
              'Unescaped $ found in localized string.');
          return {value: p.replace(/\$\$/g, '$'), arg: null};
        }

        // Otherwise, return the substitution value.
        return {value: varArgs[p[1]], arg: p};
      });

      return pieces;
    },

    /**
     * As above, but also makes sure that the value is a boolean.
     * @param {string} id The key that identifies the desired boolean.
     * @return {boolean} The corresponding boolean value.
     */
    getBoolean: function(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'boolean');
      return /** @type {boolean} */ (value);
    },

    /**
     * As above, but also makes sure that the value is an integer.
     * @param {string} id The key that identifies the desired number.
     * @return {number} The corresponding number value.
     */
    getInteger: function(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'number');
      expect(value == Math.floor(value), 'Number isn\'t integer: ' + value);
      return /** @type {number} */ (value);
    },

    /**
     * Override values in loadTimeData with the values found in |replacements|.
     * @param {Object} replacements The dictionary object of keys to replace.
     */
    overrideValues: function(replacements) {
      expect(
          typeof replacements == 'object',
          'Replacements must be a dictionary object.');
      for (const key in replacements) {
        this.data_[key] = replacements[key];
      }
    }
  };

  /**
   * Checks condition, displays error message if expectation fails.
   * @param {*} condition The condition to check for truthiness.
   * @param {string} message The message to display if the check fails.
   */
  function expect(condition, message) {
    if (!condition) {
      console.error(
          'Unexpected condition on ' + document.location.href + ': ' + message);
    }
  }

  /**
   * Checks that the given value has the given type.
   * @param {string} id The id of the value (only used for error message).
   * @param {*} value The value to check the type on.
   * @param {string} type The type we expect |value| to be.
   */
  function expectIsType(id, value, type) {
    expect(
        typeof value == type, '[' + value + '] (' + id + ') is not a ' + type);
  }

  expect(!loadTimeData, 'should only include this file once');
  loadTimeData = new LoadTimeData;

  // Expose |loadTimeData| directly on |window|. This is only necessary by the
  // auto-generated load_time_data.m.js, since within a JS module the scope is
  // local.
  window.loadTimeData = loadTimeData;
})();
</script><script jstcache="0">loadTimeData.data = {"details":"Details","errorCode":"HTTP ERROR 404","fontfamily":"system-ui, sans-serif","fontsize":"75%","heading":{"hostName":"www.hackerrank.com","msg":"This \u003Cspan jscontent=\"hostName\">\u003C/span> page can’t be found"},"hideDetails":"Hide details","iconClass":"icon-generic","language":"en","reloadButton":{"msg":"Reload","reloadTrackingId":-1,"reloadUrl":"https://www.hackerrank.com/rest/contests/master/challenges/most-distant/hackers/[deleted]/download_solution?primary=true"},"suggestionsDetails":[],"suggestionsSummaryList":[],"summary":{"failedUrl":"https://www.hackerrank.com/rest/contests/master/challenges/most-distant/hackers/[deleted]/download_solution?primary=true","hostName":"www.hackerrank.com","msg":"No webpage was found for the web address: \u003Cstrong jscontent=\"failedUrl\">\u003C/strong>"},"textdirection":"ltr","title":"www.hackerrank.com"};</script><script jstcache="0">// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file serves as a proxy to bring the included js file from /third_party
// into its correct location under the resources directory tree, whence it is
// delivered via a chrome://resources URL.  See ../webui_resources.grd.

// Note: this <include> is not behind a single-line comment because the first
// line of the file is source code (so the first line would be skipped) instead
// of a licence header.
// clang-format off
(function(){var i=null;function k(){return Function.prototype.call.apply(Array.prototype.slice,arguments)}function l(a,b){var c=k(arguments,2);return function(){return b.apply(a,c)}}function m(a,b){var c=new n(b);for(c.f=[a];c.f.length;){var e=c,d=c.f.shift();e.g(d);for(d=d.firstChild;d;d=d.nextSibling)d.nodeType==1&&e.f.push(d)}}function n(a){this.g=a}function o(a){a.style.display=""}function p(a){a.style.display="none"};var q=":",r=/\s*;\s*/;function s(){this.i.apply(this,arguments)}s.prototype.i=function(a,b){if(!this.a)this.a={};if(b){var c=this.a,e=b.a,d;for(d in e)c[d]=e[d]}else for(c in d=this.a,e=t,e)d[c]=e[c];this.a.$this=a;this.a.$context=this;this.d=typeof a!="undefined"&&a!=i?a:"";if(!b)this.a.$top=this.d};var t={$default:i},u=[];function v(a){for(var b in a.a)delete a.a[b];a.d=i;u.push(a)}function w(a,b,c){try{return b.call(c,a.a,a.d)}catch(e){return t.$default}}
function x(a,b,c,e){if(u.length>0){var d=u.pop();s.call(d,b,a);a=d}else a=new s(b,a);a.a.$index=c;a.a.$count=e;return a}var y="a_",z="b_",A="with (a_) with (b_) return ",D={};function E(a){if(!D[a])try{D[a]=new Function(y,z,A+a)}catch(b){}return D[a]}function F(a){for(var b=[],a=a.split(r),c=0,e=a.length;c<e;++c){var d=a[c].indexOf(q);if(!(d<0)){var f;f=a[c].substr(0,d).replace(/^\s+/,"").replace(/\s+$/,"");d=E(a[c].substr(d+1));b.push(f,d)}}return b};var G="jsinstance",H="jsts",I="*",J="div",K="id";function L(){}var M=0,N={0:{}},P={},Q={},R=[];function S(a){a.__jstcache||m(a,function(a){T(a)})}var U=[["jsselect",E],["jsdisplay",E],["jsvalues",F],["jsvars",F],["jseval",function(a){for(var b=[],a=a.split(r),c=0,e=a.length;c<e;++c)if(a[c]){var d=E(a[c]);b.push(d)}return b}],["transclude",function(a){return a}],["jscontent",E],["jsskip",E]];
function T(a){if(a.__jstcache)return a.__jstcache;var b=a.getAttribute("jstcache");if(b!=i)return a.__jstcache=N[b];for(var b=R.length=0,c=U.length;b<c;++b){var e=U[b][0],d=a.getAttribute(e);Q[e]=d;d!=i&&R.push(e+"="+d)}if(R.length==0)return a.setAttribute("jstcache","0"),a.__jstcache=N[0];var f=R.join("&");if(b=P[f])return a.setAttribute("jstcache",b),a.__jstcache=N[b];for(var h={},b=0,c=U.length;b<c;++b){var d=U[b],e=d[0],g=d[1],d=Q[e];d!=i&&(h[e]=g(d))}b=""+ ++M;a.setAttribute("jstcache",b);N[b]=
h;P[f]=b;return a.__jstcache=h}function V(a,b){a.h.push(b);a.k.push(0)}function W(a){return a.c.length?a.c.pop():[]}
L.prototype.e=function(a,b){var c=X(b),e=c.transclude;if(e)(c=Y(e))?(b.parentNode.replaceChild(c,b),e=W(this),e.push(this.e,a,c),V(this,e)):b.parentNode.removeChild(b);else if(c=c.jsselect){var c=w(a,c,b),d=b.getAttribute(G),f=!1;d&&(d.charAt(0)==I?(d=parseInt(d.substr(1),10),f=!0):d=parseInt(d,10));var h=c!=i&&typeof c=="object"&&typeof c.length=="number",e=h?c.length:1,g=h&&e==0;if(h)if(g)d?b.parentNode.removeChild(b):(b.setAttribute(G,"*0"),p(b));else if(o(b),d===i||d===""||f&&d<e-1){f=W(this);
d=d||0;for(h=e-1;d<h;++d){var j=b.cloneNode(!0);b.parentNode.insertBefore(j,b);Z(j,c,d);g=x(a,c[d],d,e);f.push(this.b,g,j,v,g,i)}Z(b,c,d);g=x(a,c[d],d,e);f.push(this.b,g,b,v,g,i);V(this,f)}else d<e?(f=c[d],Z(b,c,d),g=x(a,f,d,e),f=W(this),f.push(this.b,g,b,v,g,i),V(this,f)):b.parentNode.removeChild(b);else c==i?p(b):(o(b),g=x(a,c,0,1),f=W(this),f.push(this.b,g,b,v,g,i),V(this,f))}else this.b(a,b)};
L.prototype.b=function(a,b){var c=X(b),e=c.jsdisplay;if(e){if(!w(a,e,b)){p(b);return}o(b)}if(e=c.jsvars)for(var d=0,f=e.length;d<f;d+=2){var h=e[d],g=w(a,e[d+1],b);a.a[h]=g}if(e=c.jsvalues){d=0;for(f=e.length;d<f;d+=2)if(g=e[d],h=w(a,e[d+1],b),g.charAt(0)=="$")a.a[g]=h;else if(g.charAt(0)=="."){for(var g=g.substr(1).split("."),j=b,O=g.length,B=0,$=O-1;B<$;++B){var C=g[B];j[C]||(j[C]={});j=j[C]}j[g[O-1]]=h}else g&&(typeof h=="boolean"?h?b.setAttribute(g,g):b.removeAttribute(g):b.setAttribute(g,""+
h))}if(e=c.jseval){d=0;for(f=e.length;d<f;++d)w(a,e[d],b)}e=c.jsskip;if(!e||!w(a,e,b))if(c=c.jscontent){if(c=""+w(a,c,b),b.innerHTML!=c){for(;b.firstChild;)e=b.firstChild,e.parentNode.removeChild(e);b.appendChild(this.j.createTextNode(c))}}else{c=W(this);for(e=b.firstChild;e;e=e.nextSibling)e.nodeType==1&&c.push(this.e,a,e);c.length&&V(this,c)}};function X(a){if(a.__jstcache)return a.__jstcache;var b=a.getAttribute("jstcache");if(b)return a.__jstcache=N[b];return T(a)}
function Y(a,b){var c=document;if(b){var e=c.getElementById(a);if(!e){var e=b(),d=H,f=c.getElementById(d);if(!f)f=c.createElement(J),f.id=d,p(f),f.style.position="absolute",c.body.appendChild(f);d=c.createElement(J);f.appendChild(d);d.innerHTML=e;e=c.getElementById(a)}c=e}else c=c.getElementById(a);return c?(S(c),c=c.cloneNode(!0),c.removeAttribute(K),c):i}function Z(a,b,c){c==b.length-1?a.setAttribute(G,I+c):a.setAttribute(G,""+c)};window.jstGetTemplate=Y;window.JsEvalContext=s;window.jstProcess=function(a,b){var c=new L;S(b);c.j=b?b.nodeType==9?b:b.ownerDocument||document:document;var e=l(c,c.e,a,b),d=c.h=[],f=c.k=[];c.c=[];e();for(var h,g,j;d.length;)h=d[d.length-1],e=f[f.length-1],e>=h.length?(e=c,g=d.pop(),g.length=0,e.c.push(g),f.pop()):(g=h[e++],j=h[e++],h=h[e++],f[f.length-1]=e,g.call(c,j,h))};
})()
</script><script jstcache="0">var tp = document.getElementById('t');jstProcess(loadTimeData.createJsEvalContext(), tp);</script>
----------
====================
----------
MATHEMATICS.30
medium
----------
PROBLEM STATEMENT:
Jim runs a big burger restaurant and, to entertain his customers, he always tell them jokes. He is running out of jokes and he needs you to help him find new ones.

An often heard programmer joke goes like this:

"Why do programmers always mix up Christmas and Halloween? Because Dec 25 is Oct 31".

Got it? :-) It is because [expression] (31 in Octal).

If we are talking about dates, then let [expression]). Let's describe some slightly different jokes:

"Why do programmers always mix up event [expression]". 

Here [expression].  

Jim knows that his customers love this kind of jokes. That's why he gives you a calendar with [expression] events in it and asks you to count the number of such jokes he can create using the given events.

Two jokes ([expression]) differ if they don't contain the same events.

Note: 


The given numbers are all represented with digits from 0-9, that's why for months like [expression], we can't use additional characters to represent 10 or 11. 
It might happen, that a special event cannot be used for a joke because the base conversion is invalid. For example [expression].  
Unary base is invalid.  
Two events can have the same date.


Input Format

On the first line you will get [expression] of the special events, each separated by a single space. 

Output Format

Print the number of jokes Jim can make.

Constraints 


[expression]
([expression]) will be a valid date in the Gregorian Calendar without leap day. 


Sample Input #1

2
10 25
8 31


Sample Output #1

1


Sample Input #2

2
2 25
2 25


Sample Output #2

0


Sample Input #3

2
11 10
10 11


Sample Output #3

1


Explanation

There are two special events happening on [expression]. He can make one joke, namely the one described in the description.

In the second test case there are no valid dates we can use for our jokes since 25 is not defined for base 2.

In the third test case [expression].
----------
TOP SOLUTION:
----------
#define _USE_MATH_DEFINES
#define _CRT_SECURE_NO_DEPRECATE

#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
#include &lt;cfloat&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;map&gt;
#include &lt;utility&gt;
#include &lt;set&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;sstream&gt;
#include &lt;complex&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;numeric&gt;
#include &lt;list&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;
#include &lt;bitset&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; Pii;
typedef pair&lt;ll, ll&gt; Pll;

#define FOR(i,n) for(int i = 0; i &lt; (n); i++)
#define sz(c) ((int)(c).size())
#define ten(x) ((int)1e##x)
#define tenll(x) ((ll)1e##x)
template&lt;class T&gt; T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }


int main(){
	int n; cin &gt;&gt; n;
	map&lt;int, int&gt; mp;
	FOR(i, n){
		int x, y; cin &gt;&gt; x &gt;&gt; y;
		int val = 0;
		int cur = 1;
		while (y) {
			int a = y % 10;
			if (a &gt;= x) {
				val = -1;
				break;
			}
			val += a * cur;
			cur *= x;
			y /= 10;
		}
		if (val &gt;= 0) {
			mp[val]++;
		}
	}

	ll ans = 0;
	for (auto kv : mp) {
		ll x = kv.second * ll(kv.second - 1) / 2;
		ans += x;
	}
	cout &lt;&lt; ans &lt;&lt; endl;

	return 0;
}
----------
====================
----------
MATHEMATICS.31
easy
----------
PROBLEM STATEMENT:
Adam is standing at point [expression]) co-ordinates.  

Tell Adam whether he can reach [expression] or not.
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
	int t;
	scanf("%d", &amp;t);
	for (int i = 0; i &lt; t; i++) {
        long long a, b, c, d;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
        puts(__gcd(a,b) == __gcd(c,d) ? "YES" : "NO");
	}

	return 0;
}

----------
====================
----------
MATHEMATICS.32
medium
----------
PROBLEM STATEMENT:
Since you know how to compute large Fibonacci numbers quickly using matrix exponentiation, let's take things to the next level.  

Let [expression] be positive integers. We define two bi-infinite sequences
[expression]
and
[expression]
as follows:  

[expression]

and  

[expression]

Given [expression].  

This link may help you get started: http://fusharblog.com/solving-linear-recurrence-for-programming-contest/
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;fstream&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i &lt; (int)(n); ++i)
#define for1(i, n) for (int i = 1; i &lt;= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i &gt;= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i &lt;= (int)(b); ++i)

using namespace std;

typedef pair&lt;int, int&gt; pii;
typedef vector&lt;int&gt; vi;
typedef vector&lt;pii&gt; vpi;
typedef vector&lt;vi&gt; vvi;
typedef long long i64;
typedef vector&lt;i64&gt; vi64;
typedef vector&lt;vi64&gt; vvi64;

template&lt;class T&gt; bool uin(T &amp;a, T b) { return a &gt; b ? (a = b, true) : false; }
template&lt;class T&gt; bool uax(T &amp;a, T b) { return a &lt; b ? (a = b, true) : false; }

const i64 P = 1000000000;

vvi64 mul(const vvi64 &amp;a, const vvi64 &amp;b) {
    int n = a.size();
    vvi64 c(n, vi64(n));
    forn(i, n) forn(j, n) forn(k, n) {
        c[i][k] += a[i][j] * b[j][k];
        c[i][k] %= P;
    }
    return c;
}

vvi64 deg(vvi64 a, i64 d) {
    int n = a.size();
    vvi64 c(n, vi64(n));
    forn(i, n) c[i][i] = 1;
    while (d) {
        if (d &amp; 1) c = mul(c, a);
        a = mul(a, a);
        d /= 2;
    }
    return c;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout &lt;&lt; fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int T;
    cin &gt;&gt; T;
    forn(t, T) {
        int a, b, c, d, e, f, g, h;
        i64 n;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g &gt;&gt; h &gt;&gt; n;
        vvi64 m(24, vi64(24));
        forn(i, 9) m[i + 1][i] = m[i + 11][i + 10] = 1;
//        m[0][a - 1] = m[0][10 + b - 1] = m[0][10 + c - 1] = m[0][20] = 1;
        ++m[0][a - 1];
        ++m[0][10 + b - 1];
        ++m[0][10 + c - 1];
        ++m[0][20];
//        m[10][f - 1] = m[10][g - 1] = m[10][10 + e - 1] = m[10][22] = 1;
        ++m[10][f - 1];
        ++m[10][g - 1];
        ++m[10][10 + e - 1];
        ++m[10][22];
        m[20][20] = m[20][21] = d;
        m[21][21] = d;
        m[22][22] = m[22][23] = h;
        m[23][23] = h;
        vvi64 mm = deg(m, n + 1);
        vi64 v0(24, 1);
        v0[20] = v0[22] = 0;
        i64 x = 0, y = 0;
        forn(i, 24) {
            x += mm[0][i] * v0[i]; x %= P;
            y += mm[10][i] * v0[i]; y %= P;
        }
        cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';
    }

#ifdef LOCAL_DEFINE
    cerr &lt;&lt; "Time elapsed: " &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; " s.\n";
#endif
    return 0;
}

----------
====================
----------
MATHEMATICS.33
easy
----------
PROBLEM STATEMENT:
Manipulating numbers is at the core of a programmer's job. To test how well you know their properties, you are asked to solve the following problem.

You are given [expression]. You can reorder the digits as you want. The resulting number can contain leading zeros.

For example, consider the numbers [expression] from which you have to construct a new integer as described above. Numerous arrangements of digits are possible; but we have illustrated one below. 



Complete the function canConstruct which takes an integer array as input and return "Yes" or "No" based on whether or not the required integer can be formed.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef long double ld;

int main() {
#ifdef AZINO777
    freopen("in", "r", stdin);
#endif
    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);
    int t;
    cin &gt;&gt; t;
    for (int tt = 0; tt &lt; t; tt++) {
        int n;
        cin &gt;&gt; n;
        int sm = 0;
        for (int i = 0; i &lt; n; i++) {
            int x;
            cin &gt;&gt; x;
            while (x) {
                sm += x % 10;
                x /= 10;
            }
        }
        if (sm % 3 == 0) {
            cout &lt;&lt; "Yes" &lt;&lt; endl;
        } else {
            cout &lt;&lt; "No" &lt;&lt; endl;
        }
    }
}
----------
====================
----------
MATHEMATICS.34
medium
----------
PROBLEM STATEMENT:
You are given 3 numbers a, b and x. You need to output the multiple of x which is closest to ab. If more than one answer exists , display the smallest one. 
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

int main() {
	int x, a , b, t, ab, rem;
	cin&gt;&gt;t;
	
	while( t-- ){
		cin&gt;&gt;a&gt;&gt;b&gt;&gt;x;
		ab = pow(a,b);
		rem = ab % x;
		
		if( rem &lt;= x/2 )	cout&lt;&lt;ab-rem;
		else	cout&lt;&lt;ab+(x-rem);
		
		cout&lt;&lt;endl;
	}
	return 0;
}
----------
====================
----------
MATHEMATICS.35
easy
----------
PROBLEM STATEMENT:
Sherlock is stuck while solving a problem: Given an array [expression] of this array which follows these statements:


[expression] is a non-empty subset.
There exists no integer [expression].
There are no elements of [expression] which are equal to another.

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;map&gt;

using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    int t;
    cin &gt;&gt; t;
    while(t--&gt;0)
    {
        int n;
        cin &gt;&gt; n;
        int g, x;
        cin &gt;&gt; g;
        for(int i = 0 ; i &lt; n-1 ; ++i)
        {
            cin &gt;&gt; x;
            g = __gcd(g, x);
        }
        if(g == 1)
            cout &lt;&lt; "YES\n";
        else
            cout &lt;&lt; "NO\n";
    }
    return 0;
}
----------
====================
----------
MATHEMATICS.36
easy
----------
PROBLEM STATEMENT:
We define a primitive root of prime number [expression] are different. 

For example: if [expression]) are as follows:


[expression]  
[expression]  
[expression]  
[expression]  
[expression]  
[expression]


Note that each of these evaluates to one of the six distinct integers in the range [expression].

Given prime [expression], find and print the following values as two space-separated integers on a new line:


The smallest primitive root of prime [expression].
The total number of primitive roots of prime [expression].  


Need Help? Check out a breakdown of this process at Math Stack Exchange.
----------
TOP SOLUTION:
----------
SOLUTION NOT FOUND
----------
====================
----------
MATHEMATICS.37
easy
----------
PROBLEM STATEMENT:
A Smith number is a composite number, the sum of whose digits is the sum of the digits of its prime factors obtained as a result of prime factorization (excluding [expression].

Example: 
[expression] 
So, its prime factors are [expression]. 
The sum of its digits is [expression]. 
The sum of the digits of its factors is [expression].  

Similarly, [expression] is a Smith number. 
[expression].

Task: 
Write a program to check whether a given integer is a Smith number.
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class Solution {
  private static InputReader in;
  private static PrintWriter out;

  public static void main(String[] args) throws IOException {
    in = new InputReader(System.in);
    out = new PrintWriter(System.out, true);
    
    long N = Long.parseLong(in.next());
    long s = sumdig(N);
    long t = 0;
    for (int i = 2; i * i &lt;= N; i++) {
      while (N % i == 0) {
        N /= i;
        t += sumdig(i);
      }
    }
    if (N &gt; 1) t += sumdig(N);
    
    out.println(s == t ? 1 : 0);
    out.close();
    System.exit(0);
  }
  
  public static long sumdig(long N) {
    long s = 0;
    long T = N;
    while (T &gt; 0) {
      s += (T % 10);
      T /= 10;
    }
    return s;
  }

  static class InputReader {
    public BufferedReader reader;
    public StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
      reader = new BufferedReader(new InputStreamReader(stream), 32768);
      tokenizer = null;
    }

    public String next() {
      while (tokenizer == null || !tokenizer.hasMoreTokens()) {
        try {
          tokenizer = new StringTokenizer(reader.readLine());
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
      return tokenizer.nextToken();
    }

    public int nextInt() {
      return Integer.parseInt(next());
    }
  }


}

----------
====================
----------
MATHEMATICS.38
easy
----------
PROBLEM STATEMENT:
Your friend gives you an equation [expression].  

However, you know your friend's mischievous nature and suspect that there is no solution to such an equation. Thus, you first want to find out whether there is a solution to it.  

You may find this link helpful: http://mathworld.wolfram.com/EulersCriterion.html
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

long long modpow(long long a , long long b , long long m){
    if(a == 0)return 1LL ;
    long long y = a; long long x = 1LL ;
    
    while(b){
        if(b&amp;1)
            x = (x*y)%m ;
        b /= 2;
        y = (y*y)%m ;
        
    }
    return x%m ;
}
int main() {
   int t;
    cin&gt;&gt;t;
    long long a, m ;
    while(t--){
        cin&gt;&gt;a&gt;&gt;m;
        if(modpow(a,(m-1)/2 , m) == 1)
            cout&lt;&lt;"YES"&lt;&lt;endl;
        else
            cout&lt;&lt;"NO"&lt;&lt;endl;
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.39
medium
----------
PROBLEM STATEMENT:
Lia is fascinated by anything she considers to be a twin. She calls a pairs of positive integers, [expression], twins if:


They are both prime. A prime number is an integer greater than [expression] and itself.
Their absolute difference is exactly equal to [expression]).


Given an inclusive interval of integers from [expression] are considered to be the same pair.
----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class C {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	void solve()
	{
		int n = ni(), m = ni();
		int[] primes = sieveEratosthenes(100000);
		boolean[] si = sieveBySegment(n, m, primes);
		int ct = 0;
		for(int i = 0;i &lt; si.length-2;i++){
			if(si[i] &amp;&amp; si[i+2]){
				ct++;
			}
		}
		out.println(ct);
	}
	public static int[] sieveEratosthenes(int n) {
		if (n &lt;= 32) {
			int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };
			for (int i = 0; i &lt; primes.length; i++) {
				if (n &lt; primes[i]) {
					return Arrays.copyOf(primes, i);
				}
			}
			return primes;
		}

		int u = n + 32;
		double lu = Math.log(u);
		int[] ret = new int[(int) (u / lu + u / lu / lu * 1.5)];
		ret[0] = 2;
		int pos = 1;

		int[] isnp = new int[(n + 1) / 32 / 2 + 1];
		int sup = (n + 1) / 32 / 2 + 1;

		int[] tprimes = { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };
		for (int tp : tprimes) {
			ret[pos++] = tp;
			int[] ptn = new int[tp];
			for (int i = (tp - 3) / 2; i &lt; tp &lt;&lt; 5; i += tp)
				ptn[i &gt;&gt; 5] |= 1 &lt;&lt; (i &amp; 31);
			for (int j = 0; j &lt; sup; j += tp) {
				for (int i = 0; i &lt; tp &amp;&amp; i + j &lt; sup; i++) {
					isnp[j + i] |= ptn[i];
				}
			}
		}

		// 3,5,7
		// 2x+3=n
		int[] magic = { 0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17,
				9, 6, 16, 5, 15, 14 };
		int h = n / 2;
		for (int i = 0; i &lt; sup; i++) {
			for (int j = ~isnp[i]; j != 0; j &amp;= j - 1) {
				int pp = i &lt;&lt; 5 | magic[(j &amp; -j) * 0x076be629 &gt;&gt;&gt; 27];
				int p = 2 * pp + 3;
				if (p &gt; n)
					break;
				ret[pos++] = p;
				if ((long) p * p &gt; n)
					continue;
				for (int q = (p * p - 3) / 2; q &lt;= h; q += p)
					isnp[q &gt;&gt; 5] |= 1 &lt;&lt; q;
			}
		}

		return Arrays.copyOf(ret, pos);
	}

	
	public static boolean[] sieveBySegment(long low, long high, int[] primes)
	{
		int m = (int)(high-low+1);
		boolean[] isp = new boolean[m];
		Arrays.fill(isp, true);
		// d*k-1 = 0 (mod p)
		if(low == 1)isp[0] = false;
		for(int p : primes){
			long sp = (-low)%p;
			if(sp &lt; 0)sp += p;
			if(sp+low == p)sp += p;
			for(int u = (int)sp;u &lt; m;u+=p)isp[u] = false;
		}
		return isp;
	}

	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new C().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
MATHEMATICS.40
easy
----------
PROBLEM STATEMENT:
You're given three numbers: [expression] where 
[expression]  

As the number can be very large, output it modulo [expression].  

Consider the following link: http://en.wikipedia.org/wiki/Fibonacci_number#Matrix_form
----------
TOP SOLUTION:
----------
mod=1000000007
def Multiply(a,b):
    x0=((a[0][0]*b[0][0])+(a[0][1]*b[1][0])+(a[0][2]*b[2][0]))
    x1=((a[0][0]*b[0][1])+(a[0][1]*b[1][1])+(a[0][2]*b[2][1]))
    x2=((a[0][0]*b[0][2])+(a[0][1]*b[1][2])+(a[0][2]*b[2][2]))
    y0=((a[1][0]*b[0][0])+(a[1][1]*b[1][0])+(a[1][2]*b[2][0]))
    y1=((a[1][0]*b[0][1])+(a[1][1]*b[1][1])+(a[1][2]*b[2][1]))
    y2=((a[1][0]*b[0][2])+(a[1][1]*b[1][2])+(a[1][2]*b[2][2]))
    z0=((a[2][0]*b[0][0])+(a[2][1]*b[1][0])+(a[2][2]*b[2][0]))
    z1=((a[2][0]*b[0][1])+(a[2][1]*b[1][1])+(a[2][2]*b[2][1]))
    z2=((a[2][0]*b[0][2])+(a[2][1]*b[1][2])+(a[2][2]*b[2][2]))
    a[0][0]=x0%mod
    a[0][1]=x1%mod
    a[0][2]=x2%mod
    a[1][0]=y0%mod
    a[1][1]=y1%mod
    a[1][2]=y2%mod
    a[2][0]=z0%mod
    a[2][1]=z1%mod
    a[2][2]=z2%mod
    return a
def multiply(c,d):
    return (c[0][0]*d[0][0]+c[0][1]*d[1][0]+c[0][2]*d[2][0])%mod
def Fastfib(a,b,n):
    ans=[[1,1,0],[1,0,0],[0,1,0]]
    final=[[1,0,0],[0,1,0],[0,0,1]]
    mat=[[a+b],[b],[a]]
    if n==0:
        return a
    elif n==1:
        return b
    elif n==2:
        return a+b
    else:
        n-=2
        while n!=0:
            if n&amp;1==1:
                Multiply(final,ans)
            Multiply(ans,ans)
            n&gt;&gt;=1
        return multiply(final,mat)
for _ in range(input()):
    a,b,n=map(int,raw_input().split())
    print Fastfib(a,b,n)
----------
====================
----------
MATHEMATICS.41
hard
----------
PROBLEM STATEMENT:
Little Panda has a thing for powers and modulus and he likes challenges. His friend Lucy, however, is impractical and challenges Panda to find both positive and negative powers of a number modulo a particular number. We all know that [expression] (see Wikipedia).  

Since Lucy is impractical, she says that [expression].  

Now she wants Panda to compute [expression].   

She also thinks that this problem can be very difficult if the constraints aren't given properly. Little Panda is very confused and leaves the problem to the worthy programmers of the world. Help him in finding the solution.

Input Format 
The first line contains [expression], the number of test cases. 
Then [expression].  

Output Format 
Output the value of [expression].  

Constraints 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] are coprime to each other (see Wikipedia)  

Sample Input  

3  
1 2 3  
3 4 2  
4 -1 5


Sample Output  

1  
1  
4  


Explanation 
Case 1: [expression] 
Case 2: [expression] 
Case 3: [expression]  
----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
#define ll long long int
#define MOD 1000000007
using namespace std;
ll modmulinverse(ll a,ll m)
{
    ll x = 0,y = 1,u = 1,v = 0;
    ll e = m,f = a;
    ll c,d,q,r;
    while(f != 1)
    {
        q = e/f;
        r = e%f;
        c = x-q*u;
        d = y-q*v;
        x = u;
        y = v;
        u = c;
        v = d;
        e = f;
        f = r;
    }
    u = (u+m)%m;
    return u;
}
ll mod(ll a,ll b,ll n){
    ll res=1;

      while (b)
{
    if (b % 2) { res = (res * a) % n; }

    a = (a * a) % n;
    b /= 2;
}

return res;
}

int main()
{
    ll t;
    cin&gt;&gt;t;
    while(t--){
            ll a,b,x,ans;
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;x;
    a=a%x;
    if (b&lt;0) a=modmulinverse(a,x);
    ans=mod(a,b,x);
    cout&lt;&lt;ans&lt;&lt;endl;

    }
    return 0;
}


----------
====================
----------
MATHEMATICS.42
hard
----------
PROBLEM STATEMENT:
Mehta is a very lazy boy. He always sleeps in Maths class. One day his teacher catches him sleeping and tells him that she would mark him absent for the whole semester. While she pretends to be strict, she is actually very kind-hearted. So she wants to give Mehta a chance to prove himself. She gives him a problem. If Mehta can answer it correctly, she will forgive him. Can you help Mehta find the answer to this problem?  

The problem: The teacher gives Mehta a number [expression] would be an even perfect square.  

Note: Even perfect square means the number should be even and a perfect square.  

Input Format 
The first line of input contains an integer [expression], the number of test cases. 
[expression], the number that the teacher provides.  

Output Format 
For each test case, print in a newline the output in [expression] are positive coprime integers. 
if [expression] is 0, you should simply output 0.  

Constraints 
[expression] 
[expression]  

Sample Input

4
2
8
36
900


Sample Output

0
1/3
1/8
3/26


Explaination 
For the first case [expression]. 
For the second case [expression]. 
For the third case [expression]. 
For the fourth case [expression] are even perfect squares.   
----------
TOP SOLUTION:
----------
# Enter your code here. Read input from STDIN. Print output to STDOUT
def gcd(a,b)
    while 1 do
        if a%b==0
            return b
        end
        t=a%b;a=b;b=t
    end
end
def cal(n,fa)
    i=2
  # print " at starting for ",n, "  fa is ",fa, "\n"
    while i*i&lt;=n do
        if n%i==0
          #  print n," is divisible by ",i,"\n"
            po = 0
            while n%i==0 do
                n=n/i
                po+=1
            end
           # print " by power ",po,"\n"
            return (po+1)*fa[n]
        end
        i = i+1
    end
    return 2
end
m = 2
fa = [1,1]
sq = [0]
ch=[0]
while m&lt;=1000005 do
    fa&lt;&lt;cal(m,fa)
    sq&lt;&lt;0
    ch&lt;&lt;0
    m+=1
end
m=2

while m&lt;=1000 do
    j=m*m
    ch[j]=1
    while j&lt;=1000001 do
        sq[j]+=1
        j+=m*m
    end
    m+=2
end
t=gets.to_i
t.times do
    n=gets.to_i
    if sq[n]-ch[n] ==0
        print 0,"\n"
    else
    x,y= sq[n]-ch[n],fa[n]-1
        g=gcd(x,y)
        x/=g
        y/=g
        print x,"/",y,"\n"
    end
end
            
----------
====================
----------
MATHEMATICS.43
hard
----------
PROBLEM STATEMENT:
Given two long integers, [expression], choose the one with the smallest denominator.
----------
TOP SOLUTION:
----------
#!/bin/python3

import sys


Min,Max = input().strip().split(' ')
Min,Max = [int(Min),int(Max)]
# your code goes here

import decimal
Decimal = decimal.Decimal
decimal.getcontext().prec=50

          # 0  1   2    3    4       5       6       7
DenArr =   [1, 7 , 106, 113, 33102,  33215,  66317,  99532,  265381, 364913,  1360120, 1725033, 25510582, 52746197,  78256779, 131002976, 340262731, 811528438, 1963319607, 4738167652, 6701487259, 567663097408, 1142027682075, 1709690779483, 2851718461558, 44485467702853, 136308121570117, 1816491048114374]
NumArr =   [3, 22, 333, 355, 103993, 104348, 208341, 312689, 833719, 1146408, 4272943, 5419351, 80143857, 165707065, 245850922, 411557987, 1068966896, 2549491779, 6167950454, 14885392687, 21053343141, 1783366216531, 3587785776203, 5371151992734, 8958937768937, 139755218526789, 428224593349304, 5706674932067741]    
    
Pi = Decimal(314159265358979323846264338327950288419716939937510)/Decimal(int(100000000000000000000000000000000000000000000000000))

def Ceil(n,k=1):
    return -(-n//k)

def NumberTheorySoln(Min,Max,Pi):
    ExactSoln = None
    PairArr = []
    for I1,i1 in enumerate(DenArr):
        if i1 &lt;= Max:
            PairArr.append((NumArr[I1],i1))
            if i1 &gt;= Min:
                ExactSoln = i1
    if ExactSoln != None:
        return ExactSoln
        
    PairArr2 = [m for m in PairArr]
    MaxLeft = Max
    MinLeft = Min
    Denom = 0
    # Approach Min, but do not exceed
    while len(PairArr2) &gt; 0:
        Current = PairArr2.pop()
        if Current[1] &lt;= MaxLeft:
            Inc = Ceil(MinLeft,Current[1])
            if Current[1] * Inc &gt; MaxLeft:
                Inc -= 1
            Inc *= Current[1]
            Denom += Inc
            MaxLeft -= Inc
            MinLeft -= Inc
            assert MaxLeft &gt;= 0
            if MinLeft == 0:
                break
            elif MinLeft &lt; 0:
                Denom -= Current[1]
                MinLeft += Current[1]
                MaxLeft += Current[1]
                break
            
    Count = 0
    Basis = []
    MaxBasis = 4

    for i1 in reversed(PairArr):
        if i1[1] &lt;= MaxLeft:
            Basis.append(i1)
            if len(Basis) == MaxBasis:
                break
    DenomSet = {Denom}
    

    TempCount = 0
    for i1 in Basis:
        DenomNew = {m for m in DenomSet}
        for Start in DenomSet:
            Delta = Max - Start
            nInc = Delta // i1[1]
            for i2 in range(nInc,0,-1):
                NewDenom = Start + i2*i1[1]
                if NewDenom &gt;= Min:
                    DenomNew.add(NewDenom)
                    TempCount += 1
                else:
                    break
#            print(i1)
#            print(Start,Delta,nInc,Start+nInc*i1[1]&lt;=Max)
        DenomSet = DenomNew
#        break
    DenomCand = sorted(list(DenomSet))
    BestResid = 1
    BestDenom = Min
    for i1 in DenomCand:
        if i1 &gt;= Min and i1 &lt;= Max:
            Num = Decimal(round(Pi*i1))
            Resid = abs(Num/Decimal(i1)-Pi)
            if Resid &lt; BestResid:
                BestResid = Resid
                BestDenom = i1
    return BestDenom

Denom = NumberTheorySoln(Min,Max,Pi)
Num = round(Denom*Pi)
print('{}/{}'.format(Num,Denom))
----------
====================
----------
MATHEMATICS.44
hard
----------
PROBLEM STATEMENT:
Harvey Specter has agreed to take Mike Ross to a meeting filled with brilliant scientists at NSA Headquarters. But, as always, it's not going to be easy for Mike. He has to solve a puzzle given by Harvey. 

Harvey gives two numbers N and K and defines a set A.

A = { x : x is a natural number ≤ N } 
(i.e), A = {1,2,3,4,5,6,...., N}   

Mike has to find the total number of pairs of elements A[i] and A[j] belonging to the given set, such that, i &lt; j and their sum is divisible by K

Input Format 
An integer T followed by T lines, each containing a pair of space separated integers N and K. 

Output Format 
T integers on separate lines. Each integer denotes the answer corresponding to that test case.

Constraints 
1&lt;=T&lt;=100 
K&lt;=N&lt;=109 
1&lt;=K&lt;=10000  

Sample Input  

2
10 4
7 3


Sample Output

10
7


Explanation  

For the 1st test case, there are 10 pairs whose sum is divisible by 4. 
(1,3), (1,7), (2,6), (2,10), (3,5), (3,9), (4,8), (5,7), (6,10) and (7,9)

For the 2nd test case, there are 7 pairs whose sum is divisible by 3. 
(1,2), (1,5), (2,4), (2,7), (3,6), (4,5) and (5,7)
----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;memory.h&gt;

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash

#define  INF 100000000
#define eps 1e-8
//#define M_PI 3.141592653589793
//#define mx 1000000000000ll
#define bs 1000000007

//#define free asdfasdfsdadsg
//#define szz 400
//#define pb push_back
#define MAXN 10000
#define free afdshjioey
//#define SIZE 60
//#define bsize 250
#define clone agsdahfaassdg

using namespace std;

long long n,k,ans,p,d[11000],tests;

int main(){
//freopen("line3.in","r",stdin);
//freopen("line3.out","w",stdout);
//freopen("C:/input.txt","r",stdin);
//freopen("C:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);

cin&gt;&gt;tests;
for (;tests;--tests)
{
    cin&gt;&gt;n&gt;&gt;k;
    for (int i=0;i&lt;=k;i++)
    d[i]=0;
    
    for (int i=0;i&lt;k;i++)
    {
        d[i]=n/k;if (n%k&gt;=i&amp;&amp;i&gt;0)++d[i];
    }
    /*
    for (int i=0;i&lt;k;i++)
    cout&lt;&lt;d[i]&lt;&lt;" ";
    cout&lt;&lt;endl;
    */
    
    ans=0;
    for (int i=0;i&lt;k;i++)
    {
        p=k-i;
        if (p==k)p=0;
        if (p&gt;i)ans+=d[i]*d[p];
        else if (p==i)ans+=d[i]*(d[p]-1)/2;
//cout&lt;&lt;ans&lt;&lt;endl;
    }
//    cout&lt;&lt;ans/2&lt;&lt;endl;
cout&lt;&lt;ans&lt;&lt;endl;
}

cin.get();cin.get();
return 0;}

----------
====================
----------
MATHEMATICS.45
hard
----------
PROBLEM STATEMENT:
Bob is a dance teacher and he started dance classes recently. He observes a strange attendance pattern among his students. Initially, there are no students. On day i, a new student starts attending the class. The student stops attending the class, if and only if he has attended the class for i consecutive days. 
Also, the student resumes attending the class, if and only if he has not attended the class for i consecutive days. 

We denote the student who starts coming on day i as student i. 
To mark attendance, o denotes present and x denotes absent.  

For example, the schedule for student 1 from day 1 is as follows: 
oxoxoxoxoxoxoxoxoxox...  

The schedule for the student 3 from day 1 is as follows:  

xxoooxxxoooxxxoooxxx... 
(Student 3 starts attending the class from day 3, and stops attending from day 6, and then starts attending from day 9, and so on. )  

The schedule for the student 5 from day 1 is as follows.
xxxxoooooxxxxxoooooxxxxx...

Bob wants his students to dance in pairs. However, if the number of students coming on day i is odd, then there will be someone who can't find a partner. So Bob wants to know if the number of students coming on day i is even or odd. We denote the number of students coming on day i as N(i).  Please find out whether N(i) is even or odd.

Input format  

The first line contains an integer, T, which denotes the number of test cases. 
For each test case, there is an integer i

Output Format 
For each test case, if N(i) is even, then print even. 
If N(i) is odd, then print one line odd.

Constraints 
1 ≤ T ≤ 100 
1 ≤ i ≤ 1018  

Sample Input

4
1
2
3
4


Sample Output  

odd
odd
odd
even


Explanation 
The number of students coming on day 1 is 1: only student #1 attends the class. So N(1)=1 and it is odd. 
The number of students coming on day 2 is 1:  student #2, so n(2)=1 and it is odd. 
The number of students coming on day 3 is 3: student #1, student #2, and student #3. So N(3)=3 and it is odd. 
The number of students coming on day 4 is 2: student #3 and student #4. So N(4)=2 and it is even. 
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;

/** HEADER FOR CODING CONTESTS **/
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;tuple&gt;
#include &lt;cassert&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;queue&gt;

typedef long long LL;
typedef unsigned long long ULL;

template &lt;typename T&gt; using V = std::vector&lt;T&gt;;
#define RI(x, ...) read_these(x, ##__VA_ARGS__)
#define RV(v) read_these(v)
#define RNP(n, p) read_these(n,p)
inline void read_this(int&amp;v){scanf("%d",&amp;v);}
inline void read_this(unsigned int&amp;v){scanf("%u",&amp;v);}
inline void read_this(long long&amp;v){scanf("%lld",&amp;v);}
inline void read_this(unsigned long long&amp;v){scanf("%llu",&amp;v);}
inline void read_these(){}
template &lt;typename T, typename...Ts&gt;
inline void read_these(T&amp;v,Ts&amp;... vs){read_this(v);read_these(vs...);}
template &lt;typename T&gt;
inline void read_these(std::vector&lt;T&gt;&amp;vs){for(auto&amp;v:vs)read_this(v);}
template&lt;typename T&gt;
inline void read_these(size_t n,T*vs){for(size_t i=0;i&lt;n;++i)read_this(vs[i]);}
/** END OF HEADER **/

using namespace std;

LL msqrt(LL v) {
  LL l = 0;
  LL r = LL(1e9) + 1;

  while (r - l &gt; 1) {
    auto m = (l + r) / 2;
    if (m * m &gt; v) {
      r = m;
    } else {
      l = m;
    }
  }
  return l;
}

int main(int argc, char* argv[]) {
  int t;RI(t);
  while (t --) {
    LL n; RI(n);

    cout &lt;&lt; ((msqrt(n) &amp; 1) ? "odd" : "even") &lt;&lt; endl;

  }
  return 0;
}


----------
====================
----------
MATHEMATICS.46
medium
----------
PROBLEM STATEMENT:
You are given a sequence of [expression] except for exactly one element.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
#define endl '\n'

using namespace std;
const int MAXN = (1 &lt;&lt; 20);

int n;
int64_t a[MAXN];

void read()
{
	cin &gt;&gt; n;
	for(int i = 0; i &lt; n; i++)
		cin &gt;&gt; a[i];
}

int64_t pref[MAXN], suff[MAXN];

void solve()
{
	if(n == 1)
	{
		cout &lt;&lt; a[0] + 1 &lt;&lt; endl;
		return;
	}

	pref[0] = a[0]; for(int i = 1; i &lt; n; i++) pref[i] = __gcd(pref[i - 1], a[i]);
	suff[n - 1] = a[n - 1]; for(int i = n - 2; i &gt;= 0; i--) suff[i] = __gcd(suff[i + 1], a[i]);

	if(a[n - 1] % pref[n - 2] != 0) { cout &lt;&lt; pref[n - 2] &lt;&lt; endl; return; }
	if(a[0] % suff[1] != 0) { cout &lt;&lt; suff[1] &lt;&lt; endl; return; }

    for(int i = 1; i &lt; n - 1; i++)
	{
		int64_t g = __gcd(pref[i - 1], suff[i + 1]);
        if(a[i] % g != 0)
		{
			cout &lt;&lt; g &lt;&lt; endl;
			return;
		}
	}
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	read();
	solve();
	return 0;
}

----------
====================
----------
MATHEMATICS.47
medium
----------
PROBLEM STATEMENT:
The city of Hackerland has formed a new football club and wants to participate in the upcoming Football League of their country. The coach is worried that they will not be able to qualify because they don't have a famous footballer in their team. The assistant coach suggests that the team should buy Cristiano Ronaldo as he can single-handedly get their team qualified.  

On day 1, today, the club has to pay 'A' HackerCoins in order to buy Ronaldo. After each passing day, the price of buying Ronaldo becomes A times the price on the previous day. Any normal person would buy him on the 1st day itself as the price will be the lowest but since the coach always failed in high school Mathematics, he wants 'B' days to think before making him an offer.  

As the coach doesn't know how to calculate the price of Ronaldo on the Bth day, he has asked for your help.  

Your task is to tell the price of Ronaldo on the Bth day. Since, the price can be a very large number, please tell him the price modulo 109 + 7.

Input Format 
The first line contains an integer T, the number of testcases. It's followed by T lines. 
Each testcase will contain two integers A &amp; B separated by a space.  

Output Format 
Output T lines, each corresponding to the answer of the testcase.  

Constraints 
1 &lt;= T &lt;= 10 
1 &lt;= A,B &lt;= 10100000 
A % (109 + 7) != 0

Note 
Both integers will have a maximum of 100000 digits.  

Sample Input #00:  

5
3 2
4 5
7 4
34534985349875439875439875349875 93475349759384754395743975349573495
34543987529435983745230948023948 3498573497543987543985743989120393097595572309482304


Sample Output #00:  

9
1024
2401
735851262
985546465


Explanation #00:  

As value of 32 = 9, So output for first case will be 9. 
Similarly 45 modulo (109 + 7) = 1024 
Similarly 74 modulo (109 + 7) = 2401 
Similarly we can do for others.  
----------
TOP SOLUTION:
----------
#!/usr/bin/env python

import sys


if __name__ == '__main__':
    T = int(sys.stdin.readline())
    
    for _ in range(T):
        A, B = [int(x) for x in sys.stdin.readline().split()]
        print(pow(A, B, 1000000007))
----------
====================
----------
MATHEMATICS.48
medium
----------
PROBLEM STATEMENT:
Manager of HackerX company is having big trouble. Workers are very unhappy with the way salary is given to them. They want every worker to have the same salary, otherwise they will go on a strike.

Their current salaries are denoted by a sequence of N integers: A1, A2, A3 ... AN .
Manager has decided to take action and make their salaries equal. He uses the following process until all salaries are equal. This method is called normalization:

a) Select any two different values from A.  

b) Replace larger value with the difference of the two. Difference of two positive integers B and C is defined as |B-C|.    

He knows that the final value will always be unique. 
Now, Q queries are given. In each query you are given an integer K. K is the amount to be added to everyone's salary as bonus, before the normalization.

Input Format 
First line contains, N and Q, the number of employees and the number of queries. Next line contains N space seperated positive integers denoting the array A. Next Q lines contain queries. Each query consists of one integer per line denoting K.

Output Format 
For each query, print the normalized salary (which is same for everyone in the end) in one line.

Constraints 
1 ≤ N ≤ 105 
1 ≤ Q ≤ 105 
1 ≤ A[i] ≤ 1014 
0 ≤ K ≤ 109  

Sample Input  

4 2
9 12 3 6
0
3


Sample Output  

3
3


Explanation 
for sample input: 
If 0 is added to every element of array A, it will remain same. 
One way to normalise A is this: 
1. Picking 12 and 3 gives:  9 9 3 6 
2. Picking 3 and 6 gives:  9 9 3 3 
3. Picking 9 and 3 gives:  6 9 3 3 
4. Picking 9 and 3 gives:  6 6 3 3 
5. Picking 6 and 3 gives:  3 6 3 3 
6. Picking 6 and 3 gives:  3 3 3 3  
----------
TOP SOLUTION:
----------
#include &lt;stdio.h&gt;

long long min,a[200000],i,j,k,l,m,n,q;

long long gcd(long long xx, long long yy)
{
 long long zz;
 
 while(yy)
 {
  zz = yy;
  yy = xx%yy;
  xx = zz;
 }
 
 return xx;
}


int main()
{

scanf("%lld %lld",&amp;n,&amp;q);

for(i=0;i&lt;n;i++) 
   scanf("%lld",a+i);

min = a[0];

for(i=0;i&lt;n;i++) 
  if(a[i] &lt; min) min = a[i]; 

for(i=0;i&lt;n;i++) a[i] -= min;

m = a[0];

for(i=1;i&lt;n;i++) m = gcd(m, a[i]);

for(i=0;i&lt;q;i++)
{
scanf("%lld",&amp;k);

printf("%lld\n",gcd(m,min+k));
}


return 0;
}
----------
====================
----------
MATHEMATICS.49
hard
----------
PROBLEM STATEMENT:
After dating for a long time, Akhil is finally going to propose to his girlfriend. She is very strong in mathematics, and will accept his proposal, if and only if Akhil solves a problem given by her. The problem is given below. Help Akhil solve it.

Akhil is given two numbers N and M, and he has to tell her the remainder when [expression].  

Input Format 
The first line contains an integer [expression] i.e. the number of test cases. 
Each of the next [expression].  

Output Format 
[expression] lines each containing ouptut for the corresponding test case. 

Constraints 
[expression] 
[expression] 
[expression]  

Sample Input 00  

3
3 3
4 7
5 18


Sample Output 00  

0
5   
5


Explanation 

111 % 3  = 0 
  1111 % 7 = 5 
  11111%18 = 5  
----------
TOP SOLUTION:
----------
#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;math.h&gt;

using namespace std;

long long num,t,n,m,p,rem,count,counter,num1,first;

int main(){
    cin &gt;&gt; t;
    while(t--){
        cin &gt;&gt; n &gt;&gt; m;
        num = 1%m;
        num1 = 1%m;
        p = 10%m;
        rem = 1%m;
        count = 0;
        first = 0;
        counter = 1;
        while(count+counter &lt;= n){
            num = ((((num%m)*(p%m))%m + num1%m)%m);
            num1 = ((((num1%m)*(p%m))%m + num1%m)%m);
            p = (p*p)%m;
            rem = num;
            counter = counter*2;
            if(count+2*counter &gt;= n)
            {
                break;
            }
        }
        count = count + counter;
        if(count == n){
            cout &lt;&lt; rem%m &lt;&lt; "\n";
        }
        else{
            while(1){
                num1 = 1%m;
                p = 10%m;
                counter = 0;
                while(count+counter &lt;= n){
                    num = ((((num%m)*(p%m))%m + num1%m)%m);
                    num1 = ((((num1%m)*(p%m))%m + num1%m)%m);
                    p = (p*p)%m;
                    rem = num;
                    counter = counter*2;
                    if(counter == 0)
                        counter = 1;
                    count = count + counter;
                    if(count+2*counter &gt;= n)
                    {
                        break;
                    }
                }
                if(count == n){
                    cout &lt;&lt; rem%m &lt;&lt; "\n";
                    break;
                }
                first++;
            }
        }
    }
    return 0;
}

----------
====================
----------
MATHEMATICS.50
hard
----------
PROBLEM STATEMENT:
Little Ashish is doing internship at multiple places. Instead of giving parties to his friends he decided to donate candies to children. He likes solving puzzles and playing games. Hence he plays a small game. Suppose there are [expression] children. The rules of the game are:  


The [expression]).  
The [expression].  


One of his jealous friends, Pipi, asks him "Given [expression] (the number of candies) how many children will you be able to serve?". Little Ashish fears calculations and cannot solve this problem so he leaves this problem to the worthy programmers of the world. Help little Ashish in finding the solution.  

Input Format 
The first line contains [expression] i.e. number of test cases. 
[expression].  

Output Format 
For each testcase, print the output that little Ashish wants in one line.   

Constraints 
[expression] 
[expression]  

Note: If the [expression] number of candies then it's not counted as a successful donation  

Sample Input  

3
1
5
13


Sample Output  

1  
2  
2  


Explanation  


For [expression] candy) and no other child.  
For [expression] candies) children can get the candies.  
For [expression] children can get 1 and 4 candies respectively.  

----------
TOP SOLUTION:
----------
# Enter your code here. Read input from STDIN. Print output to STDOUT
# Enter your code here. Read input from STDIN. Print output to STDOUT
from sys import stdin;
def sum(m):
    return (m*(m+1)*(2*m+1))/6
t=int(stdin.readline())
x = stdin.readlines()
for i in xrange(t):
    n=int(x[i])
    lo = int((3*n)**(1.0/3))-5
    
    while 1:
        if sum(lo) &gt; n:
            lo-=1
            break
        lo+=1
    print lo
----------
====================
----------
MATHEMATICS.51
hard
----------
PROBLEM STATEMENT:
Manasa was sulking her way through a boring class when suddenly her teacher singled her out and asked her a question. He gave her a number n and Manasa has to come up with the smallest number m which contains atleast n number of zeros at the end of m!. Help Manasa come out of the sticky situation. 

Input Format 
The first line contains an integer T i.e. the number of Test cases. 
Next T lines will contain an integer n.  

Output Format 
Print smallest such number m. 

Constraints 
1 ≤ T ≤ 100 
1 ≤ n ≤ 1016  

Sample Input  

3
1
2
3


Sample Output  

5
10
15


Explanation


As 4! = 24 and 5! = 120, so minimum value of m will be 5.
As 9! = 362880 and 10! = 3628800, so minimum value of m will be 10.
As 14! = 87178291200 and 15! = 1307674368000, so minimum value of m will be 15.

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
using namespace std;
const long long MAXV = 1000000000;

long long f( long long x )
{
    long long res = 0;
    long long exp = 5;
    long long delta = 0;
    do
    {
        delta = (x / exp);
        exp *= 5;
        res += delta;
    }
    while( delta != 0 );
    return res;

}

int main()
{

    int T;
    cin &gt;&gt; T;

    for ( int t = 1 ; t &lt;= T ; t++ )
    {
        long long N ;
        cin &gt;&gt; N;
        long long l = 1 ,  r = MAXV * MAXV;
        while ( r - l &gt; 1 )
        {
            long long mid = ( l + r ) / 2;
            if ( f( mid ) &lt; N ) l = mid ;
            else r = mid ;
        }
        cout &lt;&lt; r &lt;&lt; endl;
    }

    return 0;
}

----------
====================
----------
MATHEMATICS.52
medium
----------
PROBLEM STATEMENT:
You are given an integer [expression] denotes xor operation) are there? 
Print your answer modulo [expression]. 
Note that the  xorsum of an empty set is zero!  

Input Format 
The first line contains one integer [expression], the number of testcases. 
The next [expression] each.

Output Format 
Output [expression].

Constraints 
[expression] 
[expression]

Sample Input  

2
1
2


Sample Output  

2
4


Explanation 
For [expression]. 
For [expression].
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;

using namespace std;

typedef long long ll;

ll mod=1000000007ll;

ll pow(ll a, ll p, ll m){
    if (p==2ll) return (a*a)%m;
    if (p==0ll) return 1ll;
    if (p%2ll==0ll) return pow(pow(a, p/2ll, m), 2ll, m);
    return (a*pow(a, p-1ll, m))%m;
}

int main(){
    int t;
    cin&gt;&gt;t;
    for (int tc=0;tc&lt;t;tc++){
        ll n;
        cin&gt;&gt;n;
        cout&lt;&lt;(pow(2ll, pow(2ll, n, mod-1ll), mod)*pow(pow(2, n, mod), mod-2ll, mod))%mod&lt;&lt;endl;
    }
}

----------
====================
----------
MATHEMATICS.53
medium
----------
PROBLEM STATEMENT:
You recently received a bag of chocolate sticks for Halloween. To prevent you from compulsively eating all the chocolate sticks in one go, your dietician devises the following fun game.

In each move, you choose one of the sticks from your bag. Then, you either eat it, or  break it into some number of equally-sized parts and save the pieces for later. The lengths of all sticks must always be integers, so breaking a stick into [expression].

Note that this means that a stick of length [expression] cannot be broken anymore, and can only be eaten.

For example, a chocolate stick of length [expression] will be dealt with as shown below. 



Given the chocolate sticks you received, determine the length of the longest sequence of moves you can perform.

Complete the function longestSequence which takes an integer array [expression], denoting the lengths of the chocolate sticks, as input. Return the maximum number of moves you can perform to consume the chocolate sticks according the game. 
----------
TOP SOLUTION:
----------
/**
 *    author:  tourist
 *    created: 14.12.2017 19:11:30       
**/
#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
  int tt;
  cin &gt;&gt; tt;
  long long ans = 0;
  while (tt--) {
    long long x;
    cin &gt;&gt; x;
    ans += (x &gt; 1 ? x : 0);
    while (x &gt; 1) {
      bool found = false;
      for (long long i = 2; i * i &lt;= x; i++) {
        if (x % i == 0) {
          found = true;
          x /= i;
          ans += x;
          break;
        }
      }
      if (!found) {
        break;
      }
    }
    ans += 1;
  }
  cout &lt;&lt; ans &lt;&lt; endl;
  return 0;
}

----------
====================
----------
MATHEMATICS.54
easy
----------
PROBLEM STATEMENT:
Waiter: Good day, sir! What would you like to order? 
Lucas: One Cheese &amp; Random Toppings (CRT) pizza for me, please. 
Waiter: Very good, sir. There are [expression] toppings. 
Lucas: Hmm, let's see...  

...Then Lucas started writing down all the ways to choose R toppings from N toppings in a piece of napkin. Soon he realized that it's impossible to write them all, because there are a lot. So he asked himself: How many ways are there to choose exactly [expression] toppings?

Since Lucas doesn't have all the time in the world, he only wished to calculate the answer modulo [expression], where M is a squarefree number whose prime factors are each less than 50.

Fortunately, Lucas has a Wi-Fi-enabled laptop with him, so he checked the internet and discovered the following useful links: 
Lucas' theorem 
Chinese remainder theorem (CRT)  

Input Format 
The first line of input contains [expression], the number of test cases. The following lines describe the test cases.

Each test case consists of one line containing three space-separated integers: [expression].  

Constraints 
[expression] 
[expression] 
[expression] 
[expression]

Output Format 
For each test case, output one line containing a single integer: the number of ways to choose [expression].  

Sample Input  

6
5 2 1001
5 2 6
10 5 15
20 6 210
13 11 21
10 9 5    


Sample Output  

10
4
12
120
15
0


Explanation  

Case 1 and 2: Lucas wants to choose 2 toppings from 5 toppings. There are ten ways, namely (assuming the toppings are A, B, C, D and E):  

AB, AC, AD, AE, BC, BD, BE, CD, CE, DE  

Thus, 
Case 1: [expression] 
Case 2: [expression]  

Case 6: We can choose 9 toppings from 10 by removing only one from our choice. Thus, we have ten ways and [expression]
----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class C {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";
	
	static void solve()
	{
		int[][][] c = new int[51][51][51];
		for(int i = 1;i &lt;= 50;i++){
			for(int j = 0;j &lt;= i;j++){
				c[i][j][0] = 1;
				for(int k = 1;k &lt;= j;k++){
					c[i][j][k] = c[i][j-1][k] + c[i][j-1][k-1];
					c[i][j][k] %= i;
				}
			}
		}
		
		int[] primes = sieveEratosthenes(52);
		for(int T = ni();T &gt;= 1;T--){
			int n = ni(), r = ni(), mod = ni();
			if(mod == 1){
				out.println(0);
				continue;
			}
			int[] f = factorToSeq(mod, primes);
			long[] divs = new long[f.length];
			long[] mods = new long[f.length];
			for(int i = 0;i &lt; f.length;i++){
				divs[i] = f[i];
				mods[i] = 1;
				long mul = 1;
				int p = f[i];
				int nn = n, rr = r;
				while(nn&gt;0){
					mul *= c[p][nn%p][rr%p];
					mul %= p;
					nn /= p; rr /= p;
				}
				mods[i] = mul;
			}
			out.println(crt(divs, mods));
		}
	}
	
	public static long crt(final long[] divs, final long[] mods)
	{
		long div = divs[0];
		long mod = mods[0];
		for(int i = 1;i &lt; divs.length;i++){
			long[] apr = exgcd(div, divs[i]);
			if((mods[i] - mod) % apr[0] != 0)return -1;
			long ndiv = div / apr[0] * divs[i];
			long da = div / apr[0];
			long nmod = (mul(mul(apr[1], mods[i]-mod, ndiv), da, ndiv)+mod)%ndiv;
			if(nmod &lt; 0)nmod += ndiv;
			div = ndiv;
			mod = nmod;
		}
		return mod;
	}
	
	public static long mul(long a, long b, long mod)
	{
		a %= mod; if(a &lt; 0)a += mod;
		b %= mod; if(b &lt; 0)b += mod;
		long ret = 0;
		int x = 63-Long.numberOfLeadingZeros(b);
		for(;x &gt;= 0;x--){
			ret += ret;
			if(ret &gt;= mod)ret -= mod;
			if(b&lt;&lt;~x&lt;0){
				ret += a;
				if(ret &gt;= mod)ret -= mod;
			}
		}
		return ret;
	}

	
	public static long[] exgcd(long a, long b)
	{
		if(a == 0 || b == 0)return null;
		int as = Long.signum(a);
		int bs = Long.signum(b);
		a = Math.abs(a); b = Math.abs(b);
		long p = 1, q = 0, r = 0, s = 1;
		while(b &gt; 0){
			long c = a / b;
			long d;
			d = a; a = b; b = d % b;
			d = p; p = q; q = d - c * q;
			d = r; r = s; s = d - c * s;
		}
		return new long[]{a, p * as, r * bs};
	}
	
	public static int[] factorToSeq(int n, int[] primes)
	{
		int[] ret = new int[31];
		int rp = 0;
		for(int p : primes){
			if(p * p &gt; n)break;
			for(;n % p == 0;n /= p)ret[rp++] = p;
		}
		if(n != 1)ret[rp++] = n;
		return Arrays.copyOf(ret, rp);
	}

	
	public static int[] sieveEratosthenes(int n) {
		if (n &lt;= 32) {
			int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };
			for (int i = 0; i &lt; primes.length; i++) {
				if (n &lt; primes[i]) {
					return Arrays.copyOf(primes, i);
				}
			}
			return primes;
		}

		int u = n + 32;
		double lu = Math.log(u);
		int[] ret = new int[(int) (u / lu + u / lu / lu * 1.5)];
		ret[0] = 2;
		int pos = 1;

		int[] isnp = new int[(n + 1) / 32 / 2 + 1];
		int sup = (n + 1) / 32 / 2 + 1;

		int[] tprimes = { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };
		for (int tp : tprimes) {
			ret[pos++] = tp;
			int[] ptn = new int[tp];
			for (int i = (tp - 3) / 2; i &lt; tp &lt;&lt; 5; i += tp)
				ptn[i &gt;&gt; 5] |= 1 &lt;&lt; (i &amp; 31);
			for (int j = 0; j &lt; sup; j += tp) {
				for (int i = 0; i &lt; tp &amp;&amp; i + j &lt; sup; i++) {
					isnp[j + i] |= ptn[i];
				}
			}
		}

		// 3,5,7
		// 2x+3=n
		int[] magic = { 0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4,
				13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14 };
		int h = n / 2;
		for (int i = 0; i &lt; sup; i++) {
			for (int j = ~isnp[i]; j != 0; j &amp;= j - 1) {
				int pp = i &lt;&lt; 5 | magic[(j &amp; -j) * 0x076be629 &gt;&gt;&gt; 27];
				int p = 2 * pp + 3;
				if (p &gt; n)
					break;
				ret[pos++] = p;
				if ((long) p * p &gt; n)
					continue;
				for (int q = (p * p - 3) / 2; q &lt;= h; q += p)
					isnp[q &gt;&gt; 5] |= 1 &lt;&lt; q;
			}
		}

		return Arrays.copyOf(ret, pos);
	}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static boolean eof()
	{
		if(lenbuf == -1)return true;
		int lptr = ptrbuf;
		while(lptr &lt; lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;
		
		try {
			is.mark(1000);
			while(true){
				int b = is.read();
				if(b == -1){
					is.reset();
					return true;
				}else if(!isSpaceChar(b)){
					is.reset();
					return false;
				}
			}
		} catch (IOException e) {
			return true;
		}
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private static int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private static double nd() { return Double.parseDouble(ns()); }
	private static char nc() { return (char)skip(); }
	
	private static String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private static char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private static char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private static int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
MATHEMATICS.55
medium
----------
PROBLEM STATEMENT:
We call a sequence of [expression].

Given an awesome sequence, [expression], satisfying the following conditions:


[expression]
[expression] is also awesome.

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
#define ll long long
#define mod 1000000007
#define upperlimit 1000100
#define INF 1000000000
#define INFL 1000000000000000000
#define eps 1e-8
#define endl '\n'
#define sd(n) scanf("%d",&amp;n)
#define slld(n) scanf("%lld",&amp;n)
#define pd(n) printf("%d",n)
#define plld(n) printf("%lld",n)
#define pds(n) printf("%d ",n)
#define pllds(n) printf("%lld ",n)
#define pdn(n) printf("%d\n",n)
#define plldn(n) printf("%lld\n",n)
#define REP(i,a,b) for(i=a;i&lt;=b;i++)
#define mp make_pair
#define pb push_back
#define pcc pair&lt;char,char&gt;
#define pii pair&lt;int,int&gt;
#define pll pair&lt;ll,ll&gt;
#define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++)
#define F first
#define S second

using namespace std;

ll gcd(ll n1,ll n2){
	if(n1%n2==0)return n2;
	return gcd(n2,n1%n2);
}
ll powmod(ll base,ll exponent)
{
	ll ans=1;
	while(exponent){
		if(exponent&amp;1)ans=(ans*base)%mod;
		base=(base*base)%mod;
		exponent/=2;
	}
	return ans;
}
int arr[upperlimit+1];
int f(int n){
	int i;
	for(i=2;i*i&lt;=n;i++)if(n%i==0)return i;
	return n;
}
int main()
{
	int n,i,j,k;
	sd(n);
	sd(k);
	for(i=1;i&lt;=n;i++)sd(arr[i]);
	int g=arr[1];
	for(i=2;i&lt;=n;i++)g=gcd(g,arr[i]);
	int q=f(g);
	pd(k-(k%q));
	return 0;
}

----------
====================
----------
MATHEMATICS.56
hard
----------
PROBLEM STATEMENT:
Given a positive integer, [expression] are positive integers) has at least one solution.
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
#define MAXN 300009
#define INF 1000000007
#define mp(x,y) make_pair(x,y)
#define all(v) v.begin(),v.end()
#define pb(x) push_back(x)
#define wr cout&lt;&lt;"----------------"&lt;&lt;endl;
#define ppb() pop_back()
#define tr(ii,c) for(typeof((c).begin()) ii=(c).begin();ii!=(c).end();ii++)
#define ff first
#define ss second

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; PII;
template&lt;class T&gt;bool umin(T&amp; a,T b){if(a&gt;b){a=b;return 1;}return 0;}
template&lt;class T&gt;bool umax(T&amp; a,T b){if(a&lt;b){a=b;return 1;}return 0;}
int vis[MAXN];
vector&lt;int&gt;dv[MAXN];
int main(){
	for(int i=1;i&lt;MAXN;i++)
		for(int j=i;j&lt;MAXN;j+=i)
			dv[j].pb(i);
	int n,ans=0;
	scanf("%d",&amp;n);
	for(int a=1;a&lt;n;a++){
		stack&lt;int&gt;s;
		for(int x=1;x&lt;n;x++){
			if(x*a&gt;=n)
				break;
			int rem=n-a*x;
			int p=upper_bound(all(dv[rem]),a)-dv[rem].begin();
			for(int i=p;i&lt;int(dv[rem].size());i++){
				int to=dv[rem][i];
				if(!vis[to]){
					ans++;vis[to]=1;
					s.push(to);
				}
			}
		}
		while(!s.empty()){
			vis[s.top()]=0;
			s.pop();
		}
	}
	printf("%d\n",ans);
	return 0;
}

----------
====================
----------
MATHEMATICS.57
medium
----------
PROBLEM STATEMENT:
You are given an integer N. Is there a permutation of digits of integer that's divisible by 8? A permutation of digits of integer N is defined as an integer formed by rearranging the digits of N. For example, if the number N = 123, then {123, 132, 213, 231, 312, 321} are the possible permutations.

Input Format 
The first line contains an integer T i.e. number of test cases. 
T lines follow, each containing the integer N. 

Output Format 
For each test case print YES if there exists one such re-arrangement of N such that it is divisible by 8 or NO if there isn't. 

Constraints 
1 &lt;= T &lt;= 45
0 &lt;= N &lt;= 10110  

Note 
Re-arrangements of 10 are {10, 01} which boils down to {10, 1}.

Sample Input  

2
61
75


Sample Output  

YES
NO


Explanation 
Test case #00: 16 is permutation of 61 which is divisible by 8. 
Test case #01: None of permutation of 75, {57, 75}, are divisible by 8.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long LL;
typedef unsigned long long ULL;
typedef pair &lt;int, int&gt; pnt;

#define tup(name, pos) get&lt;(pos)&gt;(name)
#define FI(i,a) for (auto i=0; i&lt;(a); ++i)
#define FOR(i,s,e) for (auto i=(s); i&lt;(e); ++i)
#define MEMS(a,b) memset(a,b,sizeof(a))
#define pb push_back
#define mp make_pair
#define ALL(a) a.begin(),a.end()
#define V(t) vector &lt; t &gt;
#define MAX(a,b) ((a)&gt;(b)?(a):(b))
#define MIN(a,b) ((a)&lt;(b)?(a):(b))
#define ABS(a) ((a)&gt;(0)?(a):(-(a)))
#define ALL(a) a.begin(),a.end()

#define lbl cerr &lt;&lt; "debug_label" &lt;&lt; endl;
#define dval(x) cerr&lt;&lt;#x&lt;&lt;"="&lt;&lt;(x)&lt;&lt;"\n"

void dout(){cerr &lt;&lt; endl;}

template &lt;typename Head, typename... Tail&gt;
void dout(Head H, Tail... T) {
  cerr &lt;&lt; H &lt;&lt; ' ';
  dout(T...);
}


constexpr double pi  {3.14159265358979323846264338327950288419716939937511};
constexpr double eps {1e-9};

//*
char ch_ch_ch[1&lt;&lt;20];
inline string gs() {scanf("%s",ch_ch_ch); return string(ch_ch_ch);}
inline string gl() {gets(ch_ch_ch); return string(ch_ch_ch);}
inline int gi() {int x; scanf("%d",&amp;x); return x;}
//*/

constexpr int inf = 1000000000;

// code starts here

int sti(string s) {
    int r = 0;
    FI(i,s.size()) r = r*10 + (s[i] - '0');
    return r;
}

int a[55][55][55];

void solution() {
    int tn = gi();
    FI(i,10) FI(j,10) FI(k,10) {
        string s = "";
        s+= (i + '0');
        s+= (j + '0');
        s+= (k + '0');
        sort(ALL(s));
        bool found = false;
        do {
            if (sti(s) % 8 == 0) {found = true; break;}
        } while (next_permutation(ALL(s)));
        a[i][j][k] = found;
    }

    FI(it,tn) {
        string s = gs();
        if (s.size() &lt; 4) {
            sort(ALL(s));
            bool found = false;
            do {
                if (sti(s) % 8 == 0) found = true;
            } while (next_permutation(ALL(s)));
            if (found) printf("YES\n");
            else printf("NO\n");
        } else {
            bool found = false;
            FI(i,s.size()) FOR(j,i+1,s.size()) FOR(k,j+1,s.size()) if (a[s[i]-'0'][s[j]-'0'][s[k]-'0']) {found = true; break;}
            if (found) printf("YES\n");
            else printf("NO\n");
        }
    }



}


// code ends here

int main(int argc, char** argv) {

#ifdef IGEL_ACM
  freopen("in.txt","r",stdin);
  //freopen("out.txt", "w", stdout);
  clock_t beg_time = clock();
#else
  //freopen(argv[1],"r",stdin);
  //freopen("painting.in", "r", stdin);
  //freopen("painting.out", "w", stdout);
#endif

  solution();

#ifdef IGEL_ACM
  fprintf(stderr,"*** Time: %.3lf ***\n",1.0*(clock()-beg_time)/CLOCKS_PER_SEC);
#endif

  return 0;
}

----------
====================
----------
MATHEMATICS.58
hard
----------
PROBLEM STATEMENT:
Given a matrix you need to find the submatrix with the largest number of elements, where the GCD (Greatest Common Divisor) of its elements is greater than one. A submatrix of the matrix is a sub-section composed of contiguous rows and columns of the original matrix.


Input
Two numbers n,m in the first line. Followed by n lines with m numbers in each line.

Constraints  

1&lt;=N,M&lt;=200
1&lt;=numbers&lt;=10000

Output
Just a largest area where GCD is greater than 1.

Sample Input  

3 3
2 6 8
4 8 3
6 9 4


Sample Output  

4


If you observe the following submatrix:  

2 6  
4 8  


The GCD is 2.
There is no matrix larger than this with a GCD &gt; 1.
----------
TOP SOLUTION:
----------
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;math.h&gt;
#include&lt;string.h&gt;
#define fo(i,a,b) dfo(int,i,a,b)
#define fr(i,n) dfr(int,i,n)
#define fe(i,a,b) dfe(int,i,a,b)
#define fq(i,n) dfq(int,i,n)
#define nfo(i,a,b) dfo(,i,a,b)
#define nfr(i,n) dfr(,i,n)
#define nfe(i,a,b) dfe(,i,a,b)
#define nfq(i,n) dfq(,i,n)
#define dfo(d,i,a,b) for (d i = (a); i &lt; (b); i++)
#define dfr(d,i,n) dfo(d,i,0,n)
#define dfe(d,i,a,b) for (d i = (a); i &lt;= (b); i++)
#define dfq(d,i,n) dfe(d,i,1,n)
#define ffo(i,a,b) dffo(int,i,a,b)
#define ffr(i,n) dffr(int,i,n)
#define ffe(i,a,b) dffe(int,i,a,b)
#define ffq(i,n) dffq(int,i,n)
#define nffo(i,a,b) dffo(,i,a,b)
#define nffr(i,n) dffr(,i,n)
#define nffe(i,a,b) dffe(,i,a,b)
#define nffq(i,n) dffq(,i,n)
#define dffo(d,i,a,b) for (d i = (b)-1; i &gt;= (a); i--)
#define dffr(d,i,n) dffo(d,i,0,n)
#define dffe(d,i,a,b) for (d i = (b); i &gt;= (a); i--)
#define dffq(d,i,n) dffe(d,i,1,n)
#define ll long long
#define alok(n,t) ((t*)malloc((n)*sizeof(t)))
#define pf printf
#define sf scanf
#define pln pf("\n")

int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}
int main() {
	int r, c;
	sf("%d%d", &amp;r, &amp;c);
	int **g = alok(r, int*);
	int ***gr = alok(r+1, int**);
	fr(i,r) {
		int *gi = g[i] = alok(c, int);
		int **gri = gr[i] = alok(c, int*);
		fr(j,c) {
			sf("%d", &amp;gi[j]);
			gri[j] = alok(c, int);
			gri[j][j] = gi[j];
			ffr(k,j) {
				gri[k][j] = gcd(gri[k + 1][j], gi[k]);
			}
		}
	}
	int **grr = gr[r] = alok(c, int*);
	fr(j,c) {
		grr[j] = alok(c, int);
		fe(k,0,j) grr[k][j] = 1;
	}
	r++;
	int area = 0;
	int ht = 1;
	for (int sz = r, nsz = sz + 1 &gt;&gt; 1; sz &gt; 1; ht++, sz = nsz, nsz = sz + 1 &gt;&gt; 1);
	int **t = alok(ht, int*);
	int *v = t[0] = alok(r, int);
	for (int h = 1, sz = r, nsz = sz + 1 &gt;&gt; 1; sz &gt; 1; h++, sz = nsz, nsz = sz + 1 &gt;&gt; 1) {
		t[h] = alok(nsz, int);
	}
	fr(j,c) fo(k,j,c) {
		fr(i,r) v[i] = gr[i][j][k];
		for (int h = 1, sz = r, nsz = sz + 1 &gt;&gt; 1; sz &gt; 1; h++, sz = nsz, nsz = sz + 1 &gt;&gt; 1) {
			fr(i,nsz) t[h][i] = 0;
			fr(i,sz) {
				int p = i &gt;&gt; 1;
				t[h][p] = gcd(t[h][p], t[h - 1][i]);
			}
		}
		int w = 0;
		int mlen = 0;
		fr(i,r) {
			int g = 0;
			for (int L = i, R = w, h = 0; L &lt; R; h++, L &gt;&gt;= 1, R &gt;&gt;= 1) {
				if (L &amp; 1) g = gcd(g, t[h][L++]);
				if (R &amp; 1) g = gcd(g, t[h][--R]);
			}
			while (g != 1) g = gcd(g, v[w++]);
			if (mlen &lt; w - i) mlen = w - i;
		}
		int narea = (k - j + 1) * (mlen - 1);
		if (area &lt; narea) area = narea;
	}
	pf("%d\n", area);
}

----------
====================
----------
MATHEMATICS.59
easy
----------
PROBLEM STATEMENT:
John is new to Mathematics and does not know how to calculate GCD of numbers. So he wants you to help him in a few GCD calculations. John has a list A of numbers, indexed 1 to N. He wants to create another list B having N+1 numbers, indexed from 1 to N+1, and having the following property:

GCD(B[i], B[i+1]) = A[i],  ∀ 1  ≤ i  ≤ N

As there can be many such lists, John wants to know the list B in which sum of all elements is minimum. It is guaranteed that such a list will always exist.

Input Format 
The first line contains an integer T, i.e., the number of the test cases. T testcases follow. 
The first line of each test case contains an integer N, i.e., the number of elements in the array. 
The second line of each test case contains N space separated integers that  denote the elements of the list A.  

Output Format 
For each test case, print in a new line the list B such that each element is separated by a single space. 

Constraints 
1 ≤ T ≤ 10 
2 ≤ N ≤ 103 
1 ≤ A[i] ≤ 104 
1 ≤ B[i]  

Sample Input  

2
3
1 2 3
3
5 10 5


Sample Output  

1 2 6 3
5 10 10 5


Explanation  

For the first testcase, 

 GCD(1,2) = 1
 GCD(2,6) = 2
 GCD(6,3) = 3
 sum = 1+2+6+3 = 12 which is minimum among all possible list B


For the second testcase, 

GCD(5, 10) = 5
GCD(10, 10) = 10
GCD(10, 5) = 5
sum = 5 + 10 + 10 + 5 = 30 which is the minimum among all possible list B

----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;
#define X first
#define Y second
#define Maxn 100010
int nCase,n;
int a[Maxn],b[Maxn];
int main(){
    scanf("%d",&amp;nCase);
    while(nCase--) {      
        scanf("%d",&amp;n);
        for (int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]);
        a[++n]=a[0]=1;
        for (int i=1;i&lt;=n;i++) b[i] = a[i-1] * a[i] / __gcd(a[i-1],a[i]);
        for (int i=1;i&lt;=n;i++) printf("%d ",b[i]);
        puts("");
    }
}
----------
====================
----------
MATHEMATICS.60
hard
----------
PROBLEM STATEMENT:
You are given [expression], such that:
[expression]

For each query, find the following value: 

[expression]  

where [expression] on a new line.
----------
TOP SOLUTION:
----------
SOLUTION NOT FOUND
----------
====================
----------
MATHEMATICS.61
hard
----------
PROBLEM STATEMENT:
Let [expression] in its decimal representation. 
John is looking for new methods of determining which numbers are strange all day long. 
All non-negative numbers of length 1 are strange. Further, a number [expression] can also be considered strange if and only if  


[expression]  
the number [expression] is recursively strange


Your task is to calculate how many strange numbers belong to an interval [expression].  

Input Format 
The first line contains single integer [expression].  

Output Format 
In [expression].

Constraints 
[expression] 
[expression]  

Sample Input

5
7 25
45 50
1 100
99 103
0 1000000


Sample Output

10
1
26
0
96


Explanation 
First testcase: There are [expression]. 
Second testcase: Only [expression] satisfies the given constraints.  
----------
TOP SOLUTION:
----------
import bisect
def c(n):
	l = range(10)
	li = [10,12,14,16,18]
	for i in xrange(2,n+1):
		if li[-1]&gt;=pow(10,n):break
		for j in li:
			x = str(j*i)
			if len(x) &lt; i:continue
			elif len(x) &gt; i:break
			li.append(int(x))
	return l + li
l = c(18)
for _ in xrange(input()):
	w = map(int,raw_input().split())
	i = bisect.bisect_left(l,w[0])
	j = bisect.bisect_right(l,w[1])
	print j-i
----------
====================
----------
MATHEMATICS.62
medium
----------
PROBLEM STATEMENT:
Charlie and Johnny play a game. For every integer X Charlie gives, Johnny has to find the smallest positive integer Y, such that X * Y contains only 4's and 0's and starts with one or more 4's followed by zero or more 0's. (i.e.), 404 is an invalid number but 400 is a valid number. 

If a is the number of 4's and b is the number of 0's, can you print the value of 2 * a + b.

Input Format
The first line contains an integer T. T lines follow, each line containing the integer X as stated above.

Output Format
For every X, print the output 2 * a + b in a newline as stated in the problem statement. 

Constraints
1&lt;=T&lt;=103 
1&lt;=X&lt;=105

Sample Input #00

3
4
5
80


Sample Output #00

2
3
4


Explanation 
For the 1st test-case, the smallest such multiple of 4 is 4 itself. Hence value of a will be 1 and and value of b will be 0. The required value of 2 * a+b is 2.     

For the 2nd test-case, Y = 8 and 40 is the minimum such multiple of 5. Hence value of a,b and 2 * a+b will be 1, 1 and 3 respectively.
----------
TOP SOLUTION:
----------

/*===============*\
|  ID: TMANDZU    |
|    LANG: C++    |
\*===============*/
//Tornike Mandzulashvili
//#pragma comment(linker,"/STACK:256000000")
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
#include &lt;stack&gt;
#include &lt;math.h&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;cstring&gt;

#define EPS 0.000000001
#define Pi 3.1415926535897932384626433832795028841971
#define hash1 1000003
#define hash2 1000033
#define md 1000000007
#define INF 1000000500ll
#define mp make_pair
#define pb push_back
#define S size()
#define MX(aa,bb) (aa&gt;bb?aa:bb)
#define MN(aa,bb) (aa&lt;bb?aa:bb)
#define fi first
#define se second
#define PI pair &lt; int,int &gt;
#define REP(i,a,n) for(i=a;i&lt;n;i++)
#define sc scanf
#define pt printf
#define big long long
#define VI vector &lt;int&gt;
#define DID (long long)
#define ll long long
#define AL(a) (a).begin(),(a).end()
#define INFF DID INF*INF


using namespace std;

int x,t,now,n4,n0,raod;
int fix[1000000],id[1000000];

main()
{
    //#ifndef ONLINE_JUDGE
   //         freopen("text.in","r",stdin); freopen("text.out","w",stdout);
   // #endif

    cin&gt;&gt;t;
    while (t--){
        cin&gt;&gt;x;

        now=0;
        raod++;
        n4=0;
        n0=0;

        fix[0]=raod;
        id[0]=0;

        while (now || n4==0){
            n4++;
            now=(now*10+4)%x;
            if (fix[now]==raod){
                n0=id[now];
                n4-=n0;
                break;
            }else fix[now]=raod , id[now]=n4;
        }
        cout&lt;&lt;2*n4+n0&lt;&lt;endl;
    }

}

----------
====================
----------
MATHEMATICS.63
medium
----------
PROBLEM STATEMENT:
Find the number of positive integral solutions for the equations 
[expression]

Input Format 
An integer N&nbsp;  

Output Format 
The number of positive integral solutions for the above equation modulo 1000007  

Constraints 
[expression]  

Sample Input00  

1  


Sample Output00  

1


Sample Input01

32327


Sample Output01

656502  


Sample Input02

40921


Sample Output02

686720

----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
typedef long long int64;
/*
 * 1/x + 1/y = 1/n
 * xy - nx - ny = 0
 * n^2 + xy - nx - ny = n^2
 * n(n-x) + y(x-n) = n^2
 * (n-y)*(n-x) = n^2
 * Number of factors of n^2 ;)
 * = product (1 + 2*e) where e is an exponent of a prime number
 */
int main() {   
    int n;
    cin&gt;&gt;n;
    bool *prime = new bool[n+1];
    for (int i=1; i &lt;= n; i++) 
        prime[i] = 1;
    int64 answer = 1;
    for (int p=2; p &lt;= n; p ++)
        if (prime[p]) {
            for (int j=2*p; j &lt;= n; j += p)
                prime[j] = 0;
           int64 e = 0;
           for (int64 j=p; j &lt;= n; j *= p)
               e += n/j;
            answer = ( answer * ( 1 + 2*e ) ) % 1000007;
        }
    cout &lt;&lt; answer &lt;&lt; endl;
    
}

----------
====================
----------
MATHEMATICS.64
medium
----------
PROBLEM STATEMENT:
In mathematics, binomial coefficients are a family of positive integers that occur as coefficients in the binomial theorem. &nbsp;
[expression]
denotes the number of ways of choosing k objects from n different objects.

However when n and k are too large, we often save them after&nbsp;modulo operation by a prime number P. Please calculate how many&nbsp;binomial coefficients&nbsp;of n become to 0 after modulo by P.

Input Format 
The first of input is an integer [expression], the number of test cases. 
Each of the following [expression].  

Constraints 
[expression] 
[expression] 
[expression]

Output Format

For each test case, output a line contains the number of &nbsp; [expression]s&nbsp;(0&lt;=k&lt;=n) &nbsp;each of which after modulo operation by P is 0.

Sample Input

3
2 2
3 2
4 3


Sample Output

1
0
1

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

/*
??n
?c(n,m)=n!/m!/(n-m)! ????p???m??? ?n??p??? (a1a2...ak)
???n+1-(a1+1)*(a2+1)*...*(ak+1)
*/

typedef long long ll;
int a[1000],b[1000],c[1000],g[1000],t[1000];
char s[1001];

void make(int x,int *a) {
	a[0]=0;
	while (x) {
		a[++a[0]]=x%10;
		x/=10;
	}
}

void mul(int *a,int *b) {  // a*=b
int i,j;
	if (a[0]*b[0]==0) {
		a[0]=0;
		return;
	}
	c[0]=a[0]+b[0]-1;
	for (i=1;i&lt;=c[0];++i)
		c[i]=0;
	c[c[0]+1]=0;
	for (i=1;i&lt;=a[0];++i)
		for (j=1;j&lt;=b[0];++j)
			c[i+j-1]+=a[i]*b[j];
	for (i=1;i&lt;=c[0];++i) {
		c[i+1]+=c[i]/10;
		c[i]%=10;
	}
	if (c[c[0]+1])
		++c[0];
	for (i=0;i&lt;=c[0];++i)
		a[i]=c[i];
}

void dec(int *a,int *b) {  //a-=b a&gt;=b
int i;
	for (i=1;i&lt;=a[0];++i) {
			a[i]-=(i&gt;b[0])?0:b[i];
			if (a[i]&lt;0) {
				a[i]+=10;
				--a[i+1];
			}
	}
	while (a[0] &amp;&amp; !a[a[0]])
		--a[0];
}


void divp(int *b,int p) {
int ca,i;
ll temp;

	while (b[0]) {
		ca=0;
		for (i=b[0];i&gt;0;--i) {
			temp=((ll) ca*(ll) 10)+b[i];
			ca=temp%p;
			b[i]=temp/p;
		}
		while (b[0] &amp;&amp; (b[b[0]]==0)) {
			--b[0];
		}
		make(ca+1,t);
		mul(g,t);

	}
}

void print(int *a) {
int i;
	if (a[0]==0) {
		printf("0\n");
		return;
	}
	for (i=a[0];i&gt;0;--i)
		printf("%d",a[i]);
	printf("\n");
}

int main() {
int i,z,p;
	for (scanf("%d",&amp;z);z;--z) {
		g[0]=g[1]=1;
		scanf("%s%d",s,&amp;p);
		b[0]=a[0]=strlen(s);
		for (i=1;i&lt;=a[0];++i)
			b[i]=a[i]=s[a[0]-i]-'0';
		divp(b,p);
		++a[1];
		a[a[0]+1]=0;
		for (i=1;i&lt;=a[0];++i) {
			if (a[i]&gt;=10) {
				a[i]-=10;
				++a[i+1];
			}
			else {
				break;
			}
		}
		if (a[a[0]+1]) {
			++a[0];
		}
		dec(a,g);
		print(a);
	}
	return 0;
}



----------
====================
----------
MATHEMATICS.65
medium
----------
PROBLEM STATEMENT:
Little Lucy loves to arrange her flowers in patterns similar to those of a binary search tree. Her father, a computer scientist himself, takes note of this and finds out that she has N flowers. Every day she takes some of these N flowers and arranges them into all possible different patterns. The more the number of arrangements, the more time she spends outside.

Now, her father knows that she takes a non-empty subset of these N flowers any given day. He wants to find out the total number of arrangements that she can ever make. As this may be too large to handle, you only need to report final answer modulo 109+9 if the answer is no less than 109+9. 

Note: All flowers are distinct and are labelled by distinct numbers.

Input Format 
The first line contains an integer, T, the number of test cases. 
The next T lines contain an integer each, N ,that denotes the number of flowers the girl has.

Output Format 
Output T lines each containing an answer to corresponding query.

Constraints

1 ≤ T ≤ 5000 
1 ≤ N ≤ 5000

Sample Input

4
1
2
3
4


Sample Output

1
4
14
50    


Explanation

For the first case, only one BST is possible. 
For the second case, only 4 BSTs are possible (shown below). 

1    2    1      2
           \    / 
            2   1


Similarly, 14 BSTs are possible for N = 3, and 50 are possible for N = 4. 
----------
TOP SOLUTION:
----------
#include&lt;iostream&gt;
using namespace std;
int main()
{
	long long int arr[]={0,1,4,14,50,187,730,2949,12234,51821,223190,974426,4302644,19181099,86211884,390248054,777495625,140539877,463689441,164231407,539467117,930490070,709550495,506039991,170374877,788103207,2630865,927411523,986039480,58705900,724965387,330867037,227124320,752283562,13879020,27739771,473175206,239615414,374760792,685439374,562346731,50588752,78281607,623101219,587154951,397288232,675470470,994904954,363413376,826790368,85240219,100296851,233127698,659095763,335454446,501307199,55905810,666240709,959086916,473146463,7472042,625417516,462309624,30452951,230853801,967065611,761139748,137121291,154919282,760078651,862897493,275569562,426935666,985660918,704408075,958951040,807931728,580092308,535054443,303871212,529678214,327021583,719528916,223898708,962266514,102254980,742480403,774092792,957234082,384974466,671946140,416306403,228312138,972772391,784557224,129432080,985869444,935478320,788319346,823006767,345940295,151417222,899656874,759286996,409078302,547848467,631493635,90705907,823366280,89578368,911783315,19250123,689007502,868324555,129635706,295210115,156711862,665054559,897916613,124453638,670225885,545666843,876830374,358793376,607792065,445845793,419666836,703624580,538666555,981006544,425825649,198432259,690569071,274087210,796959358,987534762,232888522,995977938,698914634,30515709,856925523,830169999,597986051,350384455,527388797,722579913,239305879,939904332,891714177,772532269,75542487,821652712,4375059,542542203,483077337,913706881,809027309,99963943,455845648,768709624,571593336,308939986,997172723,371946238,367002673,455438108,316935768,862631787,373764536,927288317,550575842,299968577,151591278,155606833,165804940,604463824,960596300,203954544,370323043,297037536,689322329,867536370,588950457,315389163,90103737,933746849,977796931,57170166,344621612,538798456,625577058,967716776,339109834,572179737,454522371,366672374,138650029,516505608,185956626,621598750,635066944,589217081,540445269,108197034,652023573,632640621,793982437,389030673,880193306,530524352,244538544,424746005,274362725,812411562,861931699,976331744,183394920,238417983,325983549,35521879,872696176,848539017,749899633,892801795,684452961,587188420,480368019,34112243,604277852,679048914,362905894,876532373,477354870,998332697,742740475,854785323,265596566,825632143,245269866,469684186,806258788,151308519,546730539,610476855,327508391,471546985,165435120,825972544,132862724,296100951,673884989,61098528,693806816,302468424,677220880,283822660,501662815,989409802,88767679,813187713,724108444,470845725,415461109,734692460,992272114,533586713,399912639,724589166,519727967,825377791,444380611,321375363,86835585,959826746,750927026,697699635,998088581,618710588,664584802,775635969,61997701,711041782,963087753,763478566,546215266,338447947,713390351,385593173,127400230,853113912,710029680,271495172,406223115,329744343,419975153,492540153,256912051,511221571,403101426,348792053,775719207,497381998,118165058,294542546,349627717,11159461,212652079,396772233,721749512,747260816,946326689,499034229,340754034,836819026,811470910,494465844,998270130,388230203,102534855,408626953,913406228,681957919,464897184,278051547,969745098,302515131,386173675,170124200,912067550,641192451,519418586,230599191,72836739,438884663,702608717,446133666,743749576,215590469,736189570,951733254,11117432,78296824,57006608,108482609,582390747,646803382,385723844,980849858,813243337,973218032,7697443,679158754,415059340,499847912,715767700,23659707,624655911,314663018,348902620,82198985,618019980,523306781,911982517,959584278,716615410,217243534,105747134,252956603,986385570,860661402,989395190,543525014,184270000,965431023,983554108,695940480,128609794,894947207,605596030,95957795,217814670,217719617,254937276,243467491,301966964,402803548,629976753,871482516,995021366,265932666,770931025,781871467,28569442,301628285,970397603,938620683,523300339,605492116,360784495,700168017,292363665,424144837,615384385,718409774,851824532,682369993,982663120,236487546,764618836,674172639,709174766,440176485,292691957,796960703,425656778,868570714,992751891,553235977,948739082,959450892,95698256,973212191,500666657,340124829,754558448,163263563,399387471,520281618,714103449,402956752,893435305,315462499,431165824,18219994,802148107,822167112,511379168,711162381,216740147,838669238,659103887,881444249,305876258,739674694,531456437,582618739,338773901,501505072,794839538,254081482,173164271,890603670,225277036,632352755,929696056,764846667,768123115,521412518,291149152,724364797,571823854,403640913,270046109,838873911,543205301,515598523,52740786,261388147,459073351,730353183,173265931,383417419,50803430,694543098,951034442,513611221,843060033,466018786,235723735,594195156,325437224,254133994,784204395,265687993,144686500,374039923,57674675,843223460,752216754,975580170,148848406,239915263,100055145,148930091,966656565,607216412,375023376,127857355,61821599,453210827,781399526,510551992,823768769,287700591,528025238,778369421,696862113,128319267,216728967,983384060,433685351,662465969,61802037,576245528,243624231,568528348,72909679,994627187,400463388,304149351,514654871,373550764,706573532,852761632,157499533,231127511,557001699,61098494,245252113,669131464,911126073,289148549,77568783,522049995,751183678,671499527,61048678,146762130,641074084,716965367,304693527,133983985,13355367,611008238,45594557,734543264,642869216,498737079,485615190,589282927,224031565,115348279,364549450,231921876,399036481,236636344,622296844,366706831,769059668,790671319,459095392,840777964,248062436,717859437,523017426,469292282,608913190,831351559,390710911,484328443,136360897,270216186,252235870,24153583,745184130,882073054,886093503,691199176,183621054,396494302,5893672,217697747,491670696,9212842,25715054,869124428,606280551,16280560,308950517,320929444,957003559,72430290,109919117,805519738,909833793,811901591,199297741,772607343,608791584,61139026,942841000,961099439,355442398,821805329,694082741,713333489,35673152,533634577,28511716,288320800,885203449,356220552,791244545,382052189,465937628,710191154,615377487,672342962,470538719,546935449,443137941,525314797,647641869,855546477,672080781,900405376,806809145,683652166,841474391,637100946,428732835,812432082,345127145,379837976,276876487,761413969,896310861,129484419,412609262,350099042,818086639,851102948,715052364,203728965,15361126,618281079,412181221,423171695,131030747,38300590,351921552,545130082,950924909,597397343,902629868,926891465,265263624,274976737,532120183,100402255,511431373,712970559,54619037,146434881,369987349,539558164,627867117,713682305,447047047,546050541,933917587,280974765,371522762,387819962,523546952,33083998,368023016,159807552,352017091,331861746,329271919,285068300,283687356,105117699,988905827,972190349,651511844,188395214,128266303,304227291,784392350,475343537,645887619,731441357,816199030,419275924,232089080,30160664,336798432,932283291,154942528,869497006,885503289,300209334,694950026,585710823,329845523,778228564,994858316,717194978,663914901,975970463,171355384,510169190,343583938,237407713,845350277,527975706,373967533,298771142,493315553,4875804,875117129,357605231,66446216,342117386,556687150,729766287,705900978,887465470,960758902,216827942,632061263,298298404,15789190,897885356,441303468,648161565,332286601,168889257,127842830,810300932,700109608,182085962,339007231,226976573,987538502,290842034,912231091,218657104,221323890,998508864,762554770,566716206,537313882,463541219,485252292,610632715,249349658,879923250,329051506,70974725,5653370,533319535,900787565,90773768,713823059,18128273,670984945,983077893,573173259,758423934,913221081,126843069,540911069,354731902,887891750,834467553,746041277,378751366,745157659,651135721,550428960,809787924,175405639,286820750,493781296,494215942,964049614,398318913,943184964,486249672,753328408,31840293,531668386,161543820,979709387,772013077,886999609,87712424,604595262,156640799,851853350,993029982,104595480,137725164,505287035,238312900,377047142,311911866,367585892,525486109,647671038,315197017,137434452,707019305,127426024,158617084,998339574,908658637,659662147,852403906,832853142,390270695,767911654,452435332,401123426,274171827,967300285,465476655,555575363,314013805,208299234,623939510,60334251,184600711,450050734,228667901,956880289,282027472,97195738,567387091,357765969,80764327,315793463,351791728,757690494,234656463,171547171,920676235,909976118,102868664,807398039,7526728,295905611,312225273,36135428,976004603,495552198,179099062,597440519,91713287,723263365,838341304,350755155,244899918,455587237,910872100,210620779,947782321,50953881,58864694,973606191,628320265,806701509,766906340,298753485,474252371,124435659,788701028,659329486,285274924,118638704,452769424,826885421,345222282,629699256,521019505,81252738,312261816,692126989,182916512,451486703,181605285,530591534,732633614,638546174,687282661,917491459,890238655,543156659,429206930,17816992,82714150,701693265,751570706,600742215,499363829,201506567,228024211,296057954,443147477,734362229,18178395,611246361,523411287,556346252,750196832,170550793,450731020,144899957,706143913,576068811,629646650,13993691,914329922,686588486,79832379,505930482,940454186,841897252,345538938,43441558,559836750,38022010,17937854,732070675,908622610,461298914,155952616,951607298,755726390,899832212,97436103,467697749,185002555,535198150,393315813,65574790,148352385,943385399,462601312,362702979,298981118,785853685,344382793,257303665,622936632,89880949,836592480,139563279,424946849,76159655,605709381,356997800,969755762,393226958,461566169,899484867,690542029,851255772,803070749,176830103,877881596,817749540,771430266,478427604,579760813,131519995,356382711,772708658,831305949,642173009,549329125,876000166,185303920,744262007,630043249,514361267,14926653,265507593,875292535,811077978,570753988,561641333,936976063,542958223,626001401,339937576,757158981,196255097,501517690,349815096,663231076,968810768,919056952,780849593,590749085,393549330,966717991,769457163,786622916,315098851,85038149,316479167,633446600,352105989,964575465,796112665,262893622,291076568,195494548,48324245,171426206,414362186,247365041,856551385,859313077,418982572,150574016,487469402,245207928,333913184,579935375,530529071,34033380,425260856,495982272,975946187,532642903,215740639,573264369,403616742,101838104,930955904,886841935,623497327,501316703,928759102,136050208,31877028,799134225,887011531,858556738,479317521,104665983,773466828,326222366,85396570,357285576,431146882,828818460,236443421,549377125,76458225,787738148,356755044,556730314,958958116,784952843,241079570,303355853,953026133,336767954,796719991,679188258,322294399,176242120,557021520,108424285,646846850,902646777,944570957,900935305,709704720,972089297,471059390,886822030,177001,936554477,503418286,115519580,552156013,19376497,822480362,697136440,384589770,371851558,307133278,19234105,314449845,541596358,818590681,486956518,88776895,441603349,728188128,990164836,803529483,808617062,651846457,426331026,255724065,140766033,45286292,683519649,376015593,47642973,232749516,410616540,713013709,560473742,181252403,422294053,837666004,33106206,798339034,209560182,426256658,931584651,908100711,654683696,672544385,127955833,646160060,603475430,462729323,312894153,61632390,221670853,769315363,915648385,683505933,753290569,880212642,949806601,339802258,445511972,559642720,723320785,678817845,259951290,340560918,928942704,759140842,143017607,723980780,376325398,578712185,39899172,835470597,241654038,725212266,375490359,973875008,770226958,660793001,965617,124070135,219094511,197621976,377469175,20061055,978858813,854013295,977197686,518117551,994896049,174566294,588639958,228895253,442062810,892306718,82109148,728392390,93867547,580496089,380890212,767013774,376348195,13834212,197617342,461509854,60942327,694194724,812844529,44722774,362520266,239703762,648710895,274268895,708459047,367418942,556026772,76016926,875762196,708584674,721280635,30679045,6569782,654193773,813792370,522775946,178036271,477221428,872787492,469179758,496276112,792317021,102541403,182822099,233622333,127819119,603144292,785854249,671463249,446278290,932034622,716395189,437864035,610326914,420284177,430931000,948310495,651582702,219942487,574883138,766064860,654677506,820662701,831073337,343318171,452059812,529382726,373254750,31064143,599569055,643627315,51145727,330359502,213133864,67579579,423280392,357517736,789957580,986595888,659530303,96213291,302523887,567840306,493536200,220058550,676245054,639765073,959060295,289126565,834704667,354561732,977890073,743132139,372516232,673879477,400125479,574163816,603891136,328476407,444285391,148315030,488835668,828604834,112352686,778663924,296419780,283497587,570401191,523015439,756576107,47964481,336700059,592615182,59352732,931315537,492322870,68128154,769068270,511831112,584624543,144617357,121401544,482610915,737814657,734972827,638260502,58259953,598040017,162023218,687129924,195020607,670540614,488282520,248082175,627033336,314222141,868702377,281554175,137936739,28590679,488803212,758308225,909485981,159172775,405958882,560028528,352717656,91090506,294869138,178533917,671797897,88765592,573610003,313608725,64073238,964650512,201362568,48619963,937320625,543866251,84084885,247288595,444547841,166053980,880229289,309347573,492385086,406200445,200889610,411495719,562980952,188169234,983832487,965117652,168967571,963013540,535891475,453670839,182486206,66118556,19844312,934538173,942361950,337694265,934562969,257791591,679860906,300199421,408039169,513980905,181093484,113216701,573033670,129265024,889063378,138295561,553149577,393207098,400461163,623171854,183038239,132310294,458940067,689953932,913814688,489075809,84475028,745380864,121253229,524395751,244011342,981968270,849151701,368409238,977300573,897468410,534601181,848363890,181188232,836028756,973696049,889745673,320435931,421306212,464768818,63047567,132890980,152262738,633268621,993135600,265757121,462651346,80424842,66516375,678469880,150294984,255942692,247400597,463574462,484292338,891662684,640078609,842577964,521971393,476076392,536419452,960655405,414943182,766527262,980661533,638041545,80786460,153066392,989367058,114736074,913232130,330985384,138556165,984349783,508732419,643701003,652760537,71124122,151809952,531311752,447024203,801027548,786312092,817658588,814972858,762633160,932300211,507647820,84773075,925219138,202085319,458242606,403877766,705783931,241665120,443104365,325469748,237178370,600894157,666781305,296063034,218632425,587937797,926608451,762065665,342055798,123479734,821369988,980205210,333057977,152405063,891007088,958522939,653312139,959593113,743268858,468036894,47071943,143667730,191640843,999883723,422443997,75729757,713368943,660173012,121244635,476053263,911441371,625919784,42887631,725795282,29639065,865928815,125832708,316235726,27081540,300420502,229693600,653651806,51117726,608082,505045449,675714467,75968401,675213815,864649065,518806712,260122137,315545793,881074694,167481137,16601162,623615162,677931237,478063158,495162039,70991749,426708536,180503662,194435319,693016493,551014348,238067266,661277880,824541443,958932843,312756379,870820026,974763974,478106478,835603621,135537968,407373732,899427798,202169352,246031200,625868995,524702991,586725712,862178632,35275894,982588402,265100441,570096040,715688267,884202016,174209912,129699966,26882345,592099624,215051429,358253577,588916715,754360418,136398627,873580987,975384569,279872169,358693845,254677490,408651715,818725881,448353373,564945788,429314345,975784018,622400597,359164165,12014918,227601730,52706367,649547460,35232692,270901022,231224347,849608543,649898952,5336376,394450346,527692595,713627754,481414589,136301428,817875452,516117316,348667842,98816217,559429899,279539595,640991346,396566131,414865026,446576893,135572336,188177111,562496548,76608908,774053295,122345563,826829266,828729235,947729367,995506008,757124729,904918447,840610848,473904610,992308144,339633408,478993018,956054172,38473603,637724212,858781033,911193758,412625893,9848928,65129225,987784544,330252840,636085309,970798041,522881355,971812666,323079098,406888864,430588200,256216278,407812319,563647705,928598631,121901394,182183304,936992337,512702641,427437514,408499025,47347055,472364930,540630018,756209023,333712689,291074435,491618607,549577950,737748185,592846648,505087277,943872361,477688734,23127067,222260635,496147916,497379854,728031061,399471371,179267593,783405690,921811640,691133538,990953533,721413893,302927848,746386431,652376498,663288979,383050574,498965440,746905286,822139441,373977834,971419270,17115026,975651896,507970030,916695861,610560929,94340130,357585291,355192011,53703515,70680462,265934095,127480620,962563286,199335754,830818588,96721959,504023836,325955795,392161725,6616554,131320620,590345430,199311791,700155962,856755766,483370960,271179802,230590808,335260093,68479649,492820708,786121667,807775385,144029339,782540525,838944362,316237561,165238358,919781451,180416439,689279162,250078724,970728955,627958512,257145065,302044373,487700178,172726487,930124559,3823849,826970003,598217813,905808328,42566270,671825980,336651120,579913204,438675809,140619089,247372300,931816865,511308773,182071552,810716604,55342049,346092546,812357762,551813591,151392841,968272484,553397162,83405187,32166987,373559926,970938099,52667840,111966523,283820066,972436955,557516066,166253084,575681439,456094156,504408066,801989940,540256204,724317719,196048675,574938756,420274050,873232228,14136840,866152435,953839054,397942469,780241974,304804124,76240168,508963617,627874357,82183901,548338222,52117755,318521879,760139457,705926261,575766506,23987446,622672527,704247286,537663231,990712266,735784466,551761162,373368380,495108761,906028874,631222530,504826353,418148491,238632763,556127866,744570149,734392633,503722150,269988715,985762041,467410982,151373030,911240456,983831739,122669511,343619320,743986578,679755575,509982783,336832630,830025126,167872920,361498508,573035114,259039004,959646278,875726191,120001868,591818339,349289178,255811259,134250741,979016205,619561499,955274664,85703311,719721383,347493101,960896669,634570818,225939609,99061918,802441687,900033191,488657452,175432051,328283907,922411619,912562949,659041277,631309855,804937031,13568342,804118340,199827518,712451709,612314340,743983370,868367043,770400419,713893689,523099303,891109123,844959888,873993571,133032549,552918367,2485668,311348705,227793949,476664179,606396224,606942426,955629698,406688967,495570118,160587391,997536273,605609831,913818627,9748028,950719269,939722564,608466723,680614768,80587669,52849137,893604641,457690446,789163897,93855038,147390859,458466686,179260221,633254734,497676967,241584286,575755144,652857992,639924152,875154102,77398926,149939001,849617995,832560637,127261029,29270669,762087940,734698474,592881755,530803387,57343963,444694600,601403613,778251777,71400827,941344917,361878968,445972505,893154481,355693253,870732149,942578161,797978815,64043646,296541774,477941739,239627267,203712417,309284746,430051094,496000582,521347035,446930846,400726344,926457083,299195607,307455910,189447739,226832564,502824918,376447164,47565983,106717687,394016454,486635752,695886563,136828208,709507721,638692081,915914371,699380210,169983125,843118006,815655118,239668840,495383885,692088201,205567272,927384154,934335642,254192490,832652721,545864693,651781218,310257242,113380866,870803762,260044416,593615224,923982770,608191491,623112043,791402854,316427547,959539147,989877587,830079876,364724896,474471073,226980592,146613279,803083157,473301612,869052012,106671261,966070455,774101326,100855630,747718639,738353941,228883122,795214778,215753185,232959910,402684453,855486301,563026415,480651948,159078483,142342644,744289167,785851802,142615384,251442139,670595751,455627882,467862551,506442585,82964481,612127786,282373951,85631878,186778722,775943695,429621165,142392227,871582088,269994671,608430497,140486597,579684366,771088978,709565196,685693495,917653835,838365189,450079273,534779918,365122600,623872033,572913427,63997575,431624343,296010377,316484293,456540377,788911735,741534081,298814615,148713772,869827099,795220899,966335606,998835226,698727860,473165786,915832111,615146557,113794812,384333422,640141137,579024223,236651984,637154946,980299580,317374854,603172924,738674660,35453114,245029200,261440696,77850056,340428062,678636700,874772335,900051176,204953054,388375529,906139296,227564620,903639835,776770979,962195341,659922245,95989079,716280393,472753679,338878947,783467878,325486373,461160533,164394188,806488483,874952239,991495989,590007586,569191322,209026608,411095752,685995500,513025668,512262768,932444509,525042104,445444619,223552437,845382125,546622624,567450116,193063014,361323412,591851778,914841295,484273493,403096030,371669141,972065721,107353427,82155551,551987437,470526615,872041743,419156046,763164037,469481263,670837707,889250129,360266905,642878223,947250922,495073119,339913510,116943566,601556803,717280965,519828737,42248668,650980566,475976492,759628137,412310623,101475324,685327697,528170029,842817955,951085371,799054430,351161896,927363845,621737871,335661334,128114690,841824903,464938923,223793426,122303108,48820437,39740014,510531404,564914640,663515838,663210732,390043928,978316056,526138664,570453797,132512358,962639813,755594113,861435161,471302009,882216556,357510979,652332878,172041079,542197957,439477386,21201458,225622469,922256,874300010,595631817,719601695,700577351,109651011,106185650,896257204,138730968,725053178,738426119,925098981,348796060,896458783,448336841,958015577,769411640,844026137,45971046,329915021,430579151,60722751,304764950,843131137,239583543,396292169,384234514,479217618,277424732,254116531,115103498,315898048,821522503,668363114,430283988,756156628,230949102,112284834,905968603,188733203,705894033,575057296,896580735,332124408,430200375,587041304,48603579,539973871,992375650,273136546,35774087,21779323,969955244,445578888,489822999,677907426,566695183,161262862,458595354,315336082,176025895,960242024,853480152,820243641,672916815,243341108,383066920,651175059,300514514,807681390,815981560,512900661,955444532,37732293,108944211,590397530,718113730,972219097,486229570,600606971,400887118,527922715,564965886,645397553,615893586,616805807,736680298,755472319,952242658,639309260,349246168,268482040,367476225,991824096,751746120,292563279,677418343,78677388,542558823,375652974,944492603,965535879,658084693,898926210,396774308,346453756,618306077,746857265,787061747,770634608,182207333,731161481,20335348,66270180,358190910,838346670,203513123,557101173,274856458,852397548,214217508,899274520,142837992,977219963,771881581,737142958,485574699,976307833,842657010,791610156,630657601,746030395,879275500,494270558,730760933,759576149,282777985,597496862,785894628,74118911,769482760,197489692,75421473,887801226,354579310,347785479,217959958,538401082,592499498,526186735,794845893,132479365,60443048,276434794,230483735,405959552,792103,423447014,345609629,153953767,722902923,543437016,712751868,42221751,321037125,762752113,501012750,433028449,179607331,363764485,489904432,721855089,930076319,986076653,95449952,281639196,212885401,371516306,601917289,131495801,252047310,979558838,15019168,129495888,755210360,62416378,544380393,11360561,128964796,486905955,553565136,142466873,754943261,914728624,48218923,508950705,678771845,282714046,831461517,856933472,183894911,824668361,158502413,425972352,585882157,537341891,722664250,427491359,210617089,945136509,170239926,465200557,958529733,39905590,566846391,85801224,9836156,957786920,821253329,478781867,763226539,955773852,656759598,489698261,674781363,204092433,542907051,339825527,955677531,527096798,871375430,480900608,202238522,996481806,473562347,316694035,169634412,67854379,471934851,744691658,116286589,291996032,386361417,342940549,707349136,357713868,341353067,129970943,853298415,353582906,835811491,311956187,912175332,444046247,204215983,343834528,367523394,220774732,44018632,63937272,925681052,992234798,882478331,612814564,402138883,324826014,591236461,269735107,612744603,793359899,541740878,682165996,492738612,284361350,993153420,775890259,382652562,284318822,885909138,384952827,881718993,148929154,966005268,749447660,408141422,398884193,860314695,387600428,90764762,935900972,335897003,956208146,784621739,111327224,659738886,900305664,658629754,316347820,314716830,968750323,63205795,931009739,406873563,966336772,611316228,898545443,536038665,991101857,599790899,365256639,847551315,222984294,311423122,77147946,86909818,939948576,526913716,443257859,424866914,611442479,85560069,613792004,952192103,612611245,488569009,508171892,418413120,829697377,104410425,138939845,266616072,172649214,571012593,825418006,957664124,475760089,547333035,530799577,727023063,626369916,948147862,110644648,23207018,813132967,984521260,637735215,61198673,442321398,334020031,427619157,233162252,44168977,182726188,39321333,892850606,340969875,195625317,94088994,864662764,431146644,937316050,982952173,404282362,888198788,578935776,342177713,472094663,482155888,409483237,655185848,984351875,685719712,985123144,465957332,234530333,582237027,826557484,630755231,430176860,503973774,423811990,937926099,561458375,82611946,952697854,991468359,827234237,363182818,67775498,534717600,618017437,193311380,720773164,505309819,134239287,393074829,700621488,375254249,621075954,299143440,374031085,945503719,520564317,634187219,773670449,796428435,114799852,893128709,148198232,189685788,442988458,66032283,723559755,140079350,20082227,633616272,555100236,447861416,150414648,187502905,888824955,760423337,45197314,711714299,92542908,14226297,10128415,826279119,954712546,606769711,369637713,771370948,10386138,718229227,11049421,7724122,45003979,529101308,412748403,727557906,908948614,635342785,149804717,179371593,239739769,268805732,311469500,942264887,142822850,897539198,505825309,394530580,570230625,778131785,45266488,120114353,121355871,106651012,443951282,649153458,359850171,995534568,800341517,532777264,165916098,248245399,552461613,426552467,872334578,27237826,638572287,365264995,298448973,941319558,798864385,686141912,140156351,590501469,689453385,543315340,892317786,931803936,257626791,930694609,412107251,324274408,205928503,981354640,396677152,20494612,974349213,110908316,73604482,639070346,58878356,770985686,173667106,454588534,508857302,628557032,236094034,750458307,814155503,800180444,941010369,635963780,971421404,113523389,939691048,709847052,321749135,824777895,419435232,910812518,703613667,257637802,117741705,842163601,583093982,966506396,587557591,719636023,947881565,264756673,27598646,992320915,209658928,183387309,431445385,356753334,861993097,100658124,136527713,886530342,861422175,589041860,261203262,415193242,53769238,721185256,951961917,129003235,947822145,356411091,791309633,990639279,369853219,317214038,522343163,131534845,246877917,362974152,30988475,234920819,443989939,177520028,276009242,747332519,268206758,698130228,442566449,153157688,592751346,745137807,383800260,218249678,413990914,419032948,95813681,154716929,213406081,11001094,813916209,381909909,918181022,250056707,858003961,105712645,701823381,149521334,622811297,555251875,82537161,980855140,567484514,680561755,590282143,346626304,493121598,752141608,861527288,637525495,840506763,250204813,975909693,424054937,258822753,56500174,632617810,790099866,135803174,476630486,79299946,433743797,629434856,8432948,78360895,700105162,379650570,626877391,111489650,218062277,242407166,286380751,322579015,605580842,159676045,1680830,784936177,689611768,504266673,779791293,408421682,964690539,561672517,560272244,308340657,418039492,538483158,315861828,147188545,772845097,779899885,116958882,577240785,745847872,295747350,758746908,364775923,289840423,717207554,234050586,554107308,366835696,472033735,641733256,57035147,543285128,840806925,288112226,201062358,856205002,966019467,59260125,230430117,239545657,425786217,166137345,908647884,867351623,503587420,151165574,282054431,426146577,85535596,879324428,50468248,947682444,823478903,387515595,542845497,633131567,957661211,683543991,741768997,119218054,392109580,509668750,950226481,679764454,18539529,413663382,917016842,744083063,241050680,159858729,396852504,821352354,893815693,22902983,902825782,808225374,844880821,201651291,185376078,248743978,450070464,5106825,803526367,319085364,232129350,888629003,301438777,546107145,513568140,826754712,914487295,781505607,555235787,855225317,273944033,2539621,969358613,83547618,27589068,828649565,635080120,337676060,651228482,604331408,899227595,752081562,703929636,64864761,900212764,888330277,986776391,888833571,394537151,529326966,413411150,94801993,839481072,526687198,952421338,827604790,542688159,182587436,364141143,516278077,720626142,923695351,77408011,378714102,776416043,692540388,467874576,968190222,731944793,728260202,871064366,783957162,139237539,495991316,392731530,835232081,333973831,236959934,820878150,59812769,623318990,333293302,900116605,451543176,185227252,836576797,424321640,117901178,712522439,295140427,102078986,449125960,415931292,804357892,126506008,777093928,444277304,627835140,933862441,597901497,982867500,197917020,881264301,146533455,841392630,365479509,574614772,484671503,367114068,407896808,868723778,794642954,470389848,86749815,722680221,807670761,591232460,534842535,301417770,387903238,450955474,837519857,400506864,50238254,61404715,427992380,389364013,938952064,854024288,779623488,18757861,947576816,451996684,6317822,512624284,545319549,840012694,26044056,769016941,341348053,472943065,742259032,998621484,702354540,606943268,271891596,759248483,508727751,696767135,308482980,547710556,373886227,255761922,796256523,731769412,528155483,166887862,203146123,657118667,767625990,501518420,251787810,574706306,971967736,479888743,64681880,668262427,111655565,194996490,380733522,29506352,82388535,62007130,446776006,166059976,608730847,52300801,397897834,98512062,14754642,750456991,12211796,384281782,207622723,371975103,294530000,164029557,748778282,75706716,612982418,263032803,236339660,171674081,721489523,156978042,866511242,915374607,616862245,215161908,261394647,239455270,516777220,854852248,990655602,306777835,370307421,491139509,552096913,207210032,311311628,872966924,532907110,746971650,498588380,664224729,826613889,594749783,169168436,697665042,377753522,347743494,393578301,816723881,357052734,219594219,881116059,88056061,707997791,843281847,813526192,298186914,260947028,399696948,159271546,679096046,55651064,922943978,730072021,336293041,483467740,456036617,476904482,363586584,304893485,245775600,5606561,258262967,443199232,508669234,285505696,898278787,485153854,677157379,680610950,858514041,217818955,290277250,491502564,332780979,891076574,819304748,299103795,426127475,100402716,36317909,164787822,635658903,645389844,565810937,564550096,559898111,416871502,262516885,203125373,113164017,648960692,270836905,779167306,603022822,357342859,718043470,137245857,388213796,928578844,784099998,677955530,499029023,697329487,997270029,873528181,485656898,788831632,205326188,734129368,506391488,435693861,689464611,601784810,919462362,144164061,176024377,593052159,329913639,605092663,286918599,325459027,650392907,437987488,804849304,953960362,414749400,223046534,465661930,626601078,558560375,247434316,355390524,490496416,258946733,605416424,192839539,304950849,60036086,30270882,544223830,714225024,994069511,395876243,516825920,326816857,838484583,892745123,44086529,346801398,888608245,190453009,88400100,941204875,405025676,409502809,454130534,396861360,126648158,589068955,993625506,667472465,894485343,799546223,955116611,37686345,749172179,582637484,246780113,25036975,398883096,908732802,4172348,826182239,268554235,922186626,979639011,117161542,489187191,302906094,871334878,27497593,512330340,518350187,855918740,263579657,360555051,326836111,354567132,322594498,746986593,12325983,788796515,815235157,890709759,975945751,195763047,397608904,952364475,217105763,816629600,58326229,145898531,231457800,752631026,482388659,98276833,196597298,212445132,132879482,986924363,717585366,280750970,713414409,372750160,560867421,772656854,670157021,884034346,906773595,921143331,935307560,474641315,526667435,661423595,442548369,720581184,615098407,779228789,45323743,556213077,46491323,179647525,889622378,434183569,408269138,207904733,806885497,507556433,997743720,147116627,763219193,788458254,703679108,860901166,558704990,809991660,338073976,705240414,502214209,526471072,295546160,280305485,886844726,882866604,750451005,733962613,479919314,572522646,71831234,82418803,59621619,909244958,692272606,241925827,593044377,279887079,165874470,568328700,578812917,310558266,474684983,71336781,823670108,349616707,54005815,873669159,432340275,152232788,373815047,457688767,372695899,413751914,779931641,285119701,878265815,322204406,940993384,990186918,984114899,166067508,611107232,33042360,255356393,558579434,387577770,398459034,348949646,698031169,701455384,118266372,716318465,584419081,125128781,452954530,828987392,889192996,807435633,163625554,366393886,625051218,243379376,952247115,373439866,159204529,507201985,293728574,212219198,977889892,73896256,476578368,395553993,79918783,626949139,874275104,612329950,599097065,266702552,332177036,413352616,78472151,591292291,50584858,680929308,15109385,242299126,344402700,177747733,622719653,655839477,469382884,217469195,404739859,675891859,514927888,504720765,174655347,660008669,286676405,731513380,512870821,610718791,61546245,17256436,436185329,82939527,691547421,229206137,783067658,473801386,193872951,84808594,565832822,368511160,946714144,959849769,655182473,716389785,870045880,899652867,18095106,651475545,190646438,140101860,570551226,492817621,191087566,196512966,358287080,907568465,860176869,67655124,129712083,848808514,123031584,455889518,865660771,170489355,278490741,184083893,327187901,530628140,321681534,346481368,247803625,707493663,57030351,74248934,625288206,841722553,519200493,98379997,21233476,26522727,637808682,247768813,989409800,698069814,326492066,836396291,714955154,542327396,179133617,148273841,983685768,113263013,408717773,689611338,179610588,58767739,569854132,793121540,453934660,95286366,118791885,532466260,136448828,468911087,572337944,106870312,30362154,883813798,444661655,847421011,803896168,747220536,428042606,507881491,533582083,885406880,971782023,827678446,426392511,980604440,465905868,859304074,509412775,857427574,946446490,684491482,740075641,840235235,336628042,802124535,209764814,713448322,64832537,474241679,736228358,362331778,163090898,750574092,281346200,812608592,11130433,329731382,338965624,589427013,316454677,769722522,766326820,518169186,266379857,778810951,198233053,129734404,487111084,69141611,801873603,721532510,993599577,353440605,231068940,590337969,782007312,311600759,186027942,811971948,979075134,365170601,943221742,522162641,745819663,403819187,222290583,190892918,990376993,71244929,374941580,955754732,575675079,970698481,775178046,643001087,823081674,151364900,44485447,604103976,664112845,479780421,718413245,84902341,975715555,739485821,713094582,234538582,921728863,133286088,202401538,314611691,846194639,306865640,247764925,513288838,3266510,80050629,727876705,933507900,620586402,260021226,553406190,286896348,860260278,602884025,699648708,12293132,553869623,116001832,885307876,537750416,129338079,502847708,17612928,484935152,432833827,529478334,784283317,173903098,484747307,901586818,231207944,766695830,398349462,260020868,115836933,516021293,426220070,689675712,645554578,723340074,578711728,972270233,945639372,747329755,85998318,336786253,610816591,368522213,194100969,140390421,794200839,52146498,95494848,752569335,709312405,120312171,928262347,312664038,901371003,572760354,793942186,940432448,551602141,665636135,987105530,100062983,360052547,392112232,574675081,511921882,832462136,665868262,257718596,639351314,450128801,595093982,198368396,15006558,771448937,909516930,224908828,57808766,339118449,328159312,994235785,189208503,143265050,680612467,489525572,895546383,773761223,769940013,287276535,517103216,507647583,46502304,940859534,660226796,302652243,530467027,402065013,106391154,57618780,148260328,110342065,569778383,116835412,801412426,735725230,368747067,879153668,80531527,58483538,855140963,366226875,65775983,366671747,307875747,212914229,662083576,99646727,238873379,575978686,225195828,959553555,727658017,817574203,819492724,982493006,868061750,563827245,517544589,206060051,818663737,569592814,821285182,946972880,201704344,131674426,662111994,554131564,781299686,925082510,168640785,145213142,830709641,803372618,758179547,285318762,335439553,513037466,204719229,5878900,789995779,25104138,770410666,453206845,365453606,34033103,212661312,183146936,368097702,354579325,103068415,455950873,706858185,748815166,481917616,514051529,341129372,29374211,16247142,750548266,542289959,665828317,584271585,552088173,6649490,211106930,637522350,917482120,484985640,752571646,448192539,294645589,568756134,720229643,507579961,820105976,38027851,24290590,240642006,655817424,957733514,245093705,262920243,696346783,442709605,889112884,946847335,218252189,883449024,561384855,823388223,532612180,321859938,391966340,991654459,128610317,610962929,983428420,526948881,899585455,640946759,348782086,207719225,23889791,845079090,504021896,688090157,490411138,100358924,64668264,95418002,356828056,479073106,851097849,624018245,719017383,457188707,898980900,415958796,659837749,944297572,301793493,686741691,416221953,876876687,565231519,809977139,682720678,401241124,478958805,752788893,216073162,807566893,675821437,217639663,949139122,453957403,650298498,910997168,962045801,108685009,565236612,630832007,347711057,167848267,692859862,96402855,482524938,784583678,662668482,518186885,592230663,785447196,551015351,170213686,129380114,601664972,495185802,111088398,623305211,648155800,184201359,483902600,161365040,510630725,282986487,626815615,582713811,114649640,131933284,852222241,998967662,60423930,168202778,473665922,219524323,739163271,241498217,199214055,152155224,760251256,157356264,375201995,108514955,572083128,185581743,96309211,587826264,891593075,182970124,781568103,656006582,924217585,544910779,170536869,956188052,204821581,590604229,206404506,278732712,628669721,852903449,551244692,465042861,694865217,416205635,664723783,587305268,820086,104554103,259867185,556062204,307290493,22394317,631709931,621284944,501120478,34509678,396512480,50047099,932972795,240651922,251195105,308134863,537476164,48441547,383445380,572467839,734007889,800929484,415797839,527333183,310129226,761311998,343712039,138830757,113994696,925254941,16644114,741193771,189086130,786983660,606667383,607960557,107688782,168117352,718847131,848310236,513133300,717079250,954868522,191265464,955203312,599092675,776055299,490654429,396685932,55988764,625293077,888240740,494417418,638292426,943956122,728988323,485810731,681595413,71322718,309374803,518794432,805949442,284671878,381536530,507883299,597845089,390978740,230274512,919273739,218169368,506512770,949278423,792573765,825078958,946327355,715096012,734628505,562329997,183435090,884033011,330463696,49495720,893050054,392682582,475453962,954625436,207330118,108154424,369850693,726896928,131001807,825659877,670181500,805641933,656197481,674448938,887877908,360078613,749833275,227502710,548967711,674408450,878103552,782150653,532938623,473071333,262973448,344498861,880144479,329097850,764000178,284710632,491269288,905197475,439463133,60951227,761890847,488103568,192370214,920261937,44185424,948870393,971631094,739999923,227746432,812164884,861675136,505628055,952319260,344293209,332376353,877790558,253599097,829096,632637533,639992331,51287034,253112632,577967949,114852449,920278436,44660397,85838264,69722584,944591862,399481700,524229960,33322764,523986242,734808925,269968229,188967443,354550217,265810664,539202937,313510007,581983960,898130860,979644177,855453220,353682150,537906535,554147233,558166079,439852008,612682167,510430043,766656634,637373479,243823806,789680404,464510864,922392006,472012041,853482154,759321633,148885153,80481745,113704510,113208146,692201839,72742028,112350900,570106031,673140531,178519324,294434593,646933905,424169997,531029950,24411160,806525473,403421687,156582054,513563800,101391592,23627913,6567615,605690175,106275928,265513223,355932399,190384546,956265995,783770408,761000854,376283869,34584019,336756239,498660455,876829625,418477800,93480270,621786006,127063865,996226671,63887537,47992880,108606483,454653225,861287422,35763722,124659509,304923371,20421895,259421338,587604191,829371736,504202382,789063661,498634750,129921527,530792362,494427708,835977401,824139419,387120273,719847283,646847098,852723844,46862045,888573625,559618715,892072598,387341168,44574601,692160901,212763359,762366077,646441037,431025734,128358212,198483445,991268768,264599535,323586225,889452810,854605360,109230574,922267545,816314530,772666746,948223376,783425616,801657794,625495592,881634172,663827272,286886061,369864546,700132833,368414217,455183321,754739631,997151432,109154934,707332826,211116291,441585968,130976905,94538318,937551145,321919882,355281704,116014430,343720631,875078594,686523313,722389179,508332105,385642903,797208489,717378011,156262413,862321965,276008455,308508948,655519583,872167206,823762934,300515646,743740247,515165517,372127866,681196305,255366792,115380287,205967804,135433782,378303957,979135053,963651913,919038830,101304560,706338096,891563699,979042620,518034563,413387643,868144749,647349105,817368665,457615545,259449664,272080196,331038642,263577707,543631589,260536675,572267083,402548183,678418268,322259779,101992611,281639086,917321914,475578471,515046003,272106707,70005007,863433064,975486001,815111678,538473789,80443062,453333419,980775404,2106590,918202881,679584540,499237770,835247398,72136094,511976623,946579761,718730230,831605711,671204335,414746909,107706846,387099832,513482979,962084249,599283993,666593666,905944509,783402322,325342363,237694603,963136613,700488675,805377232,743257584,100609273,134391492,912904422,720161630,515488146,383069547,594761375,871038404,664612637,572326946,521737909,45680364,786947685,155913271,350675921,829249149,852019583,507209859,31743335,97899385,595706453,439638118,210784003,495486021,246891019,94884303,685462511,563937105,277383913,169382617,738841903,926757155,589173844,693804504,34070873,938833277,354326739,740317277,660363621,198459389,801325162,357951121,225889352,598448225,823397409,802145023,77548233,233057684,197850972,837100182,553458487,814798695,28073853,497646374,569845141,229888493,431376067,525583274,941735431,655136797,268696255,144306116,469248157,118287667,558593550,692460723,305606669,959792367,373566163,14635072,848661446,510873317,441227591,126984334,720208588,482044354,681711086,805911487,721579956,628305373,958272594,187746926,563735179,689655514,850274786,623103936,297124385,137033448,293573914,754497942,52859338,16179188,948752400,703834380,301546283,293018382,14371337,390058243,628341363,528646984,809450266,582001761,986315788,308583456,707535663,701243872,75092184,674587217,851766640,32888329,13957629,830638824,411630803,115582982,829002979,351217464,641233965,559845789,197864426,897252321,235659792,767662154,508420224,512143948,122647773,228349106,879485109,189263465,810334939,109880866,880201913,115714037,84646216,956400642,977540190,625807911,556079104,382625714,107067263,507299623,815541836,197553763,970364457,388881182,370742341,586758030,752794825,391240750,959130839,982504558,502501000,912504879,132771282,328130850,810323011,676528099,200158410,480162164,314050926,628138805,934968052,798312555,754508765,356281786,884832389,862769071,161881929,825890240,278193942,595061391,302305977,559801234,260365594,320521441,109302367,254414436,800413572,880452433,706848751,28047300,534231055,85734880,34718618,433171024,267856592,462344070,512725377,71051973,859197816,918878664,50520128,115359089,917347745,314571563,915182545,785841543,454480335,631846629,590217079,445731580,325632090,954329035,622267058,100954517,200830863,724375225,157709536,980549794,848288073,905797005,949125147,772250906,122226793,718893753,331207220,650134683,326484502,72355097,818012712,167107980,824881051,541020983,456082072,869559506,688650138,185264868,387416998,528858928,829095275,3952493,58609836,669085247,63419652,101978245,81051577,953261010,213589726,90132577,796074811,329700374,963302132,815218633,634620704,161940057,378164563,887736159,433516483,606681381,622123001,78945671,405283918,900379103,784325576,110073784,312682828,704281830,396149723,966868709,43724287,472749698,610022345,995529616,189200106,748367986,529532638,805222152,885146308,474243684,327241121,739516963,642438565,958255995,332280700,756785891,410828997,136256329,896036551,246231460,645942318,444517561,737593629,744125123,667853564,880592264,311578808,585696814,583867524,39529116,931689238,560284412,436336372,939331153,631456117,745366119,711111896,451806550,547144177,542047188,935939740,978311263,648215769,292959052,740836316,222574119,867977021,4624481,304369252,881300992,316969618,590119822,739266158,177370287,515512599,358134883,92170780,388002087,749471538,630964979,336467947,503951634,762276438,835075914,678017208,157226556,770521870,265784408,351290933,710473988,986649564,2067047,176714674,125998951,253601257,795227739,352108304,751841297,887636130,832377674,699863757,941361633,905940029,262812816,663710371,736345291,132841510,675475466,371184384,614234174,760781713,404841274,382082251,129971246,716711763,635514695,811175638,957786275,398073884,10952732,712557330,542043446,358341255,212174081,971100506,69306983,591433364,399885353,442734810,182585949,316947269,204047913,199103652,281397670,636870330,198261144,39628456,138266884,166400560,148318985,477243607,160980196,109421725,81608690,963409242,989134613,952476219,781567284,835209436,100639551,293292965,254110264,570270208,42665448,961498627,221914132,419080098,4018114,433056503,523595794,763731186,771505809,631815402,789355733,180246369,796007268,68488388,446052725,290205959,965273601,243189199,701321156,417963998,227080068,755111635,899939533,258017902,32928625,233151657,735976942,86179702,297522001,627298215,151089550,762123529,355447780,687587421,121501850,358348746,939700904,516998485,345071548,40128391,590370811,823534583,331599401,439228296,423105850,61699656,179136837,466447558,55610633,296772095,587001941,851536830,972002792,27522030,468725492,885695713,556337641,32500844,198410373,285258166,444225766,57754884,630829906,396829383,847941514,77348982,581180192,33525667,755679461,476722826,391606332,773687497,7445746,467835097,500351816,880673521,541142899,975281990,628799502,425202877,618827993,906839264,181806180,568014140,139408945,340438307,997200671,951938018,487726150,871670557,18654566,888383524,518434047,553262539,819628966,423779239,145991600,867685797,21201874,608762692,86905351,780956035,724613481,949029286,940940170,266196183,693886422,773475393,739209031,117628500,33655647,784374910,923183412,654843595,852869094,296794612,341396808,533707866,626689618,238613857,133082045,157047881,914805625,522747028,688209284,762308151,960169234,124746118,256645858,944966889,923015349,344980775,842477536,476206065,207622098,475508212,178956421,68958265,555503015,891422880,15671867,948481991,881874463,326471891,905523348,570466645,82223438,641226534,1358623,966119816,987851826,82241349,298119717,16817033,650187991,490876154,129991690,581598803,749771565,288300878,870363313,614965965,406784556,653924119,342976759,964177307,35724382,964813700,847109327,185435641,873107157,155877340,251486367,102043337,194099478,559804160,18546513,33441678,426261846,523610969,312803830,721514133,662500893,867624796,499409202,454568992,944579603,767191591,950247030,316161128,798495223,557484971,947400566,513478446,103321992,959358689,558033607,81882386,787257035,197467876,451232279,984202636,129633471,937632739,258662185,919083858,743465078,849092377,387487576,370660084,756035042,471356388,301068539,371244706,633176258,239294390,480823260,500461485,166564452,785671493,876337628,468342247,771455542,863147216,224758898,740567218,986753753,909228541,638826954,225909906,16000879,836495064,571182287,578869132,59663243,271959221,902870165,423796387,552896267,448049622,172624563,827744668,674883083,341202651,907265990,139583042,91809303,266770328,606790437,471606822,417752889,176622111,957403740,45199432,131099621,492938510,172066942,158043169,244286818,947003253,543363320,653766112,415100217,955570688,982643435,982323868,575573455,112507123,169058660,833810757,71266390,637118233,739193193,552271420,149767302,248197521,28205160,323161121,445668916,557936249,759670630,707166222,310497911,244247883,245480146,772487405,755352617,182017439,226928765,514900994,154345557,878572508,116305817,758639193,453167756,450772227,560963347,616793134,903179904,278104099,440862797,464561823,46201512,669899780,617591257,702839218,660890483,41616887,113759964,968302497,355241222,790307419,144928274,213894967,768180026,214897145,83405469,271840736,658684540,69559887,517196674,229645131,457612205,927006623,952113923,351591731,991851170,961518870,155537211,77719857,880516511,305973554,239093446,620073047,666648850,662489510,771019683,338319641,38575463,256368591,956747385,525195967,20036098,992646851,932335584,280792868,859140607,736402538,638418200,314009901,916596433,290791069,208691757,17544793,237325843,274914766,660006754,412144520,750364515,186979205,801230368,944493358,842554016,210451318,525361669,50254002,121554109,301490038,72504664,82064777,579989027};
	int t,n;
	cin&gt;&gt;t;
	while(t--)
	{
		cin&gt;&gt;n;
		cout&lt;&lt;arr[n]&lt;&lt;endl;
	}
	return 0;
}
----------
====================
----------
MATHEMATICS.66
hard
----------
PROBLEM STATEMENT:
You are given [expression], such that:
[expression]  

Using this value of [expression] as follows :-  


The value [expression] is the root of the tree.  
A node is expanded such that all it's divisors are it's children.  
Continue expanding till the tree has depth [expression].  


For example, if [expression], then the tree will look like the following:



Once the tree is built, we create another tree [expression] as follows :- 


Every leaf node [expression] is the totient function.   
Every non-leaf node is equal to the sum of the values of it's children.  


From our previous example tree, after constructing a new tree, we get the following tree.  



Print the value at the root of tree [expression].  
----------
TOP SOLUTION:
----------
#pragma comment(linker, "/STACK:512000000")
#define _CRT_SECURE_NO_WARNINGS
//#include "testlib.h"
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define all(a) a.begin(), a.end()
typedef long long li;
typedef long double ld;
void solve(bool);
void precalc();
clock_t start;
int main() {
#ifdef AIM
  freopen("/home/alexandero/ClionProjects/ACM/input.txt", "r", stdin);
  //freopen("/home/alexandero/ClionProjects/ACM/output.txt", "w", stdout);
  //freopen("out.txt", "w", stdout);
#else
  //freopen("input.txt", "r", stdin);
  //freopen("output.txt", "w", stdout);
#endif
  start = clock();
  int t = 1;
  cout.sync_with_stdio(0);
  cin.tie(0);
  precalc();
  cout.precision(10);
  cout &lt;&lt; fixed;
  cin &gt;&gt; t;
  int testNum = 1;
  while (t--) {
    //cout &lt;&lt; "Case #" &lt;&lt; testNum++ &lt;&lt; ": ";
    //cerr &lt;&lt; testNum &lt;&lt; endl;
    solve(true);
    //cerr &lt;&lt; testNum - 1 &lt;&lt; endl;
  }
  cout.flush();
#ifdef AIM1
  while (true) {
      solve(false);
  }
#endif

#ifdef AIM
  cerr &lt;&lt; "\n\n time: " &lt;&lt; (clock() - start) / 1.0 / CLOCKS_PER_SEC &lt;&lt; "\n\n";
#endif

  return 0;
}

//BE CAREFUL: IS INT REALLY INT?

template&lt;typename T&gt;
T binpow(T q, T w, T mod) {
  if (!w)
    return 1 % mod;
  if (w &amp; 1)
    return q * 1LL * binpow(q, w - 1, mod) % mod;
  return binpow(q * 1LL * q % mod, w / 2, mod);
}

template&lt;typename T&gt;
T gcd(T q, T w) {
  while (w) {
    q %= w;
    swap(q, w);
  }
  return q;
}
template&lt;typename T&gt;
T lcm(T q, T w) {
  return q / gcd(q, w) * w;
}

void precalc() {

}

template&lt;typename T&gt;
void relax_min(T&amp; cur, T val) {
  cur = min(cur, val);
}

template&lt;typename T&gt;
void relax_max(T&amp; cur, T val) {
  cur = max(cur, val);
}

#define int li
const int mod = 1000000007;

const int C = 3100;
int c[C][C];

void solve(bool read) {
  for (int i = 0; i &lt; C; ++i) {
    c[i][i] = c[i][0] = 1;
    for (int j = 1; j &lt; i; ++j) {
      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;
    }
  }
  int m, a, d;
  cin &gt;&gt; m &gt;&gt; a &gt;&gt; d;
  vector&lt;int&gt; primes;
  for (int i = 2; primes.size() &lt; m; ++i) {
    bool f = true;
    for (int j = 2; j * j &lt;= i; ++j) {
      if (i % j == 0) {
        f = false;
        break;
      }
    }
    if (f) {
      primes.push_back(i);
    }
  }

  int res = 1;
  for (int i = 0; i &lt; m; ++i) {
    int sum = 0;
    int init = i + a + 1;
    int step = 1;
    for (int rest = 0; rest &lt;= init; ++rest) {
      int add = c[init - rest + d - 1][d - 1];
      if (rest) {
        add = add * step % mod * (primes[i] - 1) % mod;
        step = step * primes[i] % mod;
      }
      sum = (sum + add) % mod;
    }
    res = res * sum % mod;
  }

  cout &lt;&lt; res &lt;&lt; endl;

}

----------
====================
----------
MATHEMATICS.67
advanced
----------
PROBLEM STATEMENT:
You will be given two integers [expression].

Constraints

[expression]
----------
TOP SOLUTION:
----------
//#pragma comment (linker, "/STACK:128000000")
//#include "testlib.h"
#include &lt;cstdio&gt;
#include &lt;cassert&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;memory.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cmath&gt;
//#include &lt;unordered_map&gt;
//#include &lt;unordered_set&gt;
#include &lt;ctime&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
using namespace std;
//#define FILENAME ""
#define mp make_pair
#define all(a) a.begin(), a.end()
typedef long long li;
typedef long double ld;
void solve();
void precalc();
clock_t start;
//int timer = 1;

bool doing = true;

int main() {
#ifdef room111
	freopen("in.txt", "r", stdin);
	//freopen("out.txt", "w", stdout);
#else
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	//freopen(FILENAME".in", "r", stdin);
	//freopen(FILENAME ".out", "w", stdout);
#endif
	int t = 1;
	cout.sync_with_stdio(0);
	cin.tie(0);
	precalc();
	cout.precision(10);
	cout &lt;&lt; fixed;
	//cin &gt;&gt; t;
	start = clock();
	int testNum = 1;
	while (t--) {
		//cout &lt;&lt; "Case #" &lt;&lt; testNum++ &lt;&lt; ": ";
		solve();
		//++timer;
	}

#ifdef room111
	cerr &lt;&lt; "\n\n" &lt;&lt; (clock() - start) / 1.0 / CLOCKS_PER_SEC &lt;&lt; "\n\n";
#endif

	return 0;
}

//BE CAREFUL: IS INT REALLY INT?

#define int li

void precalc() {

}

int binpow(int q, int w, int mod) {
	if (!w)
		return 1;
	if (w &amp; 1)
		return q * binpow(q, w - 1, mod) % mod;
	return binpow(q * q % mod, w / 2, mod);
}

int mod = 1000000007;

int gcd(int q, int w) {
	while (w) {
		q %= w;
		swap(q, w);
	}
	return q;
}

//ld eps = 1e-9;


void solve() {
	int a, b;
	cin &gt;&gt; a &gt;&gt; b;

	int cur = 2;
	for (int i = 0; i &lt; a; ++i) {
		cur = cur * cur % b;
	}
	
	cout &lt;&lt; cur &lt;&lt; "\n";

}




----------
====================
----------
MATHEMATICS.68
hard
----------
PROBLEM STATEMENT:
Sherlock Holmes is bored to death as there aren't any interesting cases to solve. Dr Watson finding it impossible to be around Sherlock goes out to get some fresh air. Just as he lays his feet out of the door, he is thrown right back into his house by the explosion in front of his apartment. The metropolitan police arrive at the scene a few minutes later. They search the place thoroughly for any evidence that could throw some light on the event that unfolded. Unable to get any clues, they call Sherlock for help. After repeated persuasion by Mycroft Holmes and Dr Watson, Sherlock agrees to look at the crime scene. 

Sherlock walks into the apartment, the walls are all black and dripping wet as the fire was recently extinguished. With his skills, he observes, deduces and eliminates the impossible. What's left after it is a simple puzzle left by an evil computer genius and the future Arch Nemesis of Sherlock, Jim Moriarty. 

Given a binary string (S) which contains '0's and '1's and an integer K, 
find the length (L) of the longest contiguous subsequence of (S * K) such that twice the number of zeroes is &lt;= thrice the number of ones (2 * #0s &lt;= 3 * #1s) in that sequence.

S * K is defined as follows:
S * 1 = S 
S * K = S + S * (K - 1)  

Input Format 
The first (and only) line contains an integer K and the binary string S separated by a single space. 

Constraints 
1 &lt;= |S| &lt;= 1,000,000 
1 &lt;=  K  &lt;= 1,000,000  

Output Format 
A single integer L - the answer to the test case

Sample Input

2 00010


Sample Output

2


Explanation

S * K = 0001000010


"1" and "10" meet the requirement that 2 * #0 &lt;= 3 * #1 
The longest one is "10", length = 2.
----------
TOP SOLUTION:
----------
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;cassert&gt;
#include&lt;cstring&gt;
#include&lt;time.h&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;string&gt;
#include&lt;sstream&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#pragma comment(linker, "/STACK:16777216")
#define pb push_back
#define ppb pop_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
#define LL long long
#define bit __builtin_popcountll
#define sqr(x) (x) * (x)
#define forit(it,S) for(__typeof((S).begin()) it = (S).begin(); it != (S).end(); it++)
using namespace std;
typedef pair&lt;int, int&gt; pii;
const double eps = 1e-9;
const double pi = acos(-1.0);
const int maxn = (int)1e6 + 10;
const int INF = (int)1e9;
char s[maxn];
int cnt[maxn],f[maxn],m;
LL x[maxn];
void update(int p, int val) {
    while(p &lt; m) {
        f[p] = min(f[p],val);
        p = p | (p + 1);
    }
}
int get(int p) {
    int res = INF;
    while(p &gt;= 0) {
        res = min(res,f[p]);
        p = (p &amp; (p + 1)) - 1;
    }
    return res;
}
int main() {
    int k; cin &gt;&gt; k;
    scanf("%s",s);
    int n = strlen(s);
    for (int i = 1; i &lt;= n; i++) {
        cnt[i] = cnt[i - 1] + 5 * (s[i - 1] == '1');
    }
    for (int i = 0; i &lt;= n; i++) {
        x[i] = cnt[i] - 2 * i;
    }
    sort(x,x + n + 1);    
    m = unique(x,x + n + 1) - x;
    for (int i = 0; i &lt; m; i++) {
        f[i] = INF;
    }
    LL res = 0;
    int p = lower_bound(x,x + m,cnt[0]) - x;
    update(p,0);
    for (int i = 1; i &lt;= n; i++) {
        p = lower_bound(x,x + m,cnt[i] - 2 * i) - x;
        int w = get(p);
        if (w != INF) {
            res = max(res,(LL)(i - w));
        }
        update(p,i);
    }
    if (k == 1) {
        cout &lt;&lt; res &lt;&lt; endl;
        return 0;
    }
    for (int i = 1; i &lt;= n; i++) if (x[0] &lt;= cnt[i] + cnt[n] - 2 * (i + n)) {
        int l = 0;
        int r = k - 1;
        while(l &lt; r - 1) {
            int e = (l + r) &gt;&gt; 1;
            if (cnt[i] + (e + 1) * 1LL * cnt[n] - 2 * (i + (e + 1) * 1LL * n) &gt;= x[0]) {
                l = e;
            } else {
                r = e;
            }
        }
        p = upper_bound(x,x + m,cnt[i] + (l + 1) * 1LL * cnt[n] - 2 * (i + (l + 1) * 1LL * n)) - x - 1;
        res = max(res,i + (l + 1) * 1LL * n - get(p));
    }
    cout &lt;&lt; res &lt;&lt; endl;
	return 0;
}

----------
====================
----------
MATHEMATICS.69
medium
----------
PROBLEM STATEMENT:
You are given an array [expression] queries. 

Each query is of the form : 

[expression] 

You need to print Yes if [expression] function, otherwise print No.

find(int i,int j)
{
    if(i&gt;j) return 1;
    ans = pow(A[i],find(i+1,j))
    return ans
}


Input Format

First line of the input contains [expression].

Output Format

For each query display Yes or No as explained above.

Constraints 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression]

No 2 consecutive entries in the array will be zero.

Sample Input

4
2 3 4 5
2
1 2 4
1 3 7


Sample Output

Yes
No

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
using namespace std;

#define THRESHOLD 70
#define INFI 1000

long long A[200001];



long long gcd(long long x, long long y){
	
	if(y&gt;x) return gcd(y,x);
	if(y==0) return x;
	return gcd(y, x%y);
}


long long greaterHelper(int L, int R){
	
	if(L&gt;R) return 1;
	
	long long ret = greaterHelper(L+1, R);
	long long a = A[L];

	if(ret == 0){
		return 1;
	}
	
	if(ret &gt; 7 ||  a &gt; THRESHOLD)
		return INFI;
	
	for(int i=1;i&lt;ret;i++){
		a = a * A[L];
		if(a &gt; THRESHOLD)
			return INFI;
	}
	return a;
}



bool mygreater(int L, int R, int K){  //K&lt;60
	
	int nsteps = 20;
	int Rprime = min(L+nsteps, R);
	for(int i=Rprime; i&gt;=L; i--){
		if(A[i]==0 || A[i]==1) Rprime = i;
	}
	long long ans = greaterHelper(L, Rprime);	
	if(ans &gt; K)
		return true;
	else 
		return false;
}








void funct(long long x, int L, int R, int K, long long a){
	
	//cout&lt;&lt;x&lt;&lt;" : "&lt;&lt;L&lt;&lt;" : "&lt;&lt;R&lt;&lt;" : "&lt;&lt;K&lt;&lt;" : "&lt;&lt;a&lt;&lt;endl;
	
	if(L==R || A[L+1]==1){
		if(a%x == 0)
			printf("Yes\n");
		else	
			printf("No\n");
		return;	
	}
	
	
	if(A[L+1] == 0){
		if(x==1)
			printf("Yes\n");
		else
			printf("No\n");
		return;
	}
	
	
	if(a%x == 0){
		printf("Yes\n");
		return;
	}
	
	
	long long g = gcd(a, x);
	if(g == 1) {
		printf("No\n");
		return;
	}
	
	if(!mygreater(L+1, R, K+1)){
		printf("No\n");
		return;
	}
	funct(x/g, L, R, K+1, g);
}




int main(){
	
	int N,Q,L,R;
	long long x;
	scanf("%d", &amp;N); 
	for(int i=0;i&lt;N;i++)
		scanf("%lld", &amp;A[i]);
	scanf("%d", &amp;Q);
	for(int i=0;i&lt;Q;i++){
		scanf("%d", &amp;L);
		scanf("%d", &amp;R);
		scanf("%lld", &amp;x);
		funct(x, L-1, R-1, 0, A[L-1]);
	}
}

----------
====================
----------
MATHEMATICS.70
hard
----------
PROBLEM STATEMENT:
It is holi festival, festival of colors. Devu is having fun playing holi and is throwing balloons with his girlfriend Glynis. Police saw this mischief and tried arresting his girlfriend, Devu being a mathematician asked police not to arrest his girlfriend and instead torture him with brain teaser. Devu was a young engineering fellow and he did not knew that policeman was equally good in mathematics, policeman gave Devu a problem which is as follows:

Let [expression]

Your aim is to answer [expression]

Can you help devu and his girlfriend rescue from modern police.
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cassert&gt;
using namespace std;

int multi(long long x,long long y,int m) {
	return x * y % m;
}

int f(int n,int k,int m) {  // n &gt; 0, k &gt; 0,	
int r = (m == 1)?0:1;
	for (;k;k &gt;&gt;= 1) {
      		if (k &amp; 1) {
        		r = multi(r, n, m);
      		}
      		n = multi(n, n, m);
    	}
    	return r;
}

int crt(int n1,int n2,int k2,int n) {
vector&lt;int&gt; a,m,b;
int M = n;
	for (int i = 2; i * i &lt;= n; ++i) {
		if (n % i == 0) { 
			int j = 1;
			for (;n % i == 0; n /= i, j *= i)
			;
			m.push_back(j);
			b.push_back(j - j / i);
			a.push_back((n1 % i)?f(n1,f(n2,k2,j - j / i), j):0);
				
		}
	}
	if (n &gt; 1) {
		m.push_back(n);
		b.push_back(n - 1);
		a.push_back((n1 % n)?f(n1,f(n2, k2, n - 1), n):0);
	}
	int r = 0;
	for (int i = 0; i &lt; a.size(); ++i) {
		int temp = M / m[i];
		if ((r +=multi(multi(a[i], f(temp , b[i] - 1, m[i]), M), temp, M)) &gt;= M) {
			r -= M;
		}
	}
	return r;
	
	
}

  

bool check(int &amp;n1,int k1,int n2,int k2,int n) {
	if (n == 1) {
        	puts("0");
        	return true;
    	}
    	if (k1 == 0) {
        	puts("1");
        	return true;
    	}
   	 if ((n2 == 0) &amp;&amp; (k2 &gt; 0)) {  
        	puts("1");
        	return true;
    	}
    	if ((n1 %= n) == 0) {
        	puts("0");
        	return true;
    	}
    
    	// f(n2,k2) &gt; 0
  	n1 = f(n1, k1, n);
  	if (n1 == 0) {
		puts("0");
      		return true;
    	}
    	if ((n2 == 1) || (k2 == 0)) { 
		printf("%d\n",n1);
      		return true;
    	}
    	return false;
}



int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
int c,n1,n2,k1,k2,n;
        for (scanf("%d",&amp;c);c;--c) {
            scanf("%d%d%d%d%d",&amp;n1,&amp;k1,&amp;n2,&amp;k2,&amp;n);
        	if (check(n1,k1,n2,k2,n)) {
            		continue;
        	}
       		// f(n2,k2) &gt; 0, n1 &gt; 0, k1 &gt; 0
		long long r = 1LL;
		for (int i = 0; (i &lt; k2) &amp;&amp; (r &lt; 30); r *= n2, ++i)
		;
		printf("%d\n",(r &lt; 30)?f(n1, (int) r, n):crt(n1, n2, k2, n));
	}
	return 0;
}

----------
====================
----------
MATHEMATICS.71
medium
----------
PROBLEM STATEMENT:
Ma5termind is going through the Euler's book of knowledge when he finds the following function: 

def function(L,R):
    sum=0
    for i in range(L,R+1):              #[L,R]
        for j in range(1,i+1):          #[1,i]
            cnt=0
            if (j)*(j+1) == 2*i :
                for k in range(1,i+1):  #[1,i]
                    if __gcd(k,i)==1:   #__gcd Greatest Common Divisor 
                        cnt+=1
            sum=sum+cnt
    return sum


The function seems weird as well as interesting. Don't you think ?? 

Fascinated by the function, Ma5termind codes it and successfully compiles it in the first go itself. After all, he is a good coder. Ma5termind checks the output computed by the function for all the values of [expression] and finds that the results are correct.

But as we all know, Ma5termind loves large numbers - very large numbers. When he inputs [expression], the code does not produce any output #TimeLimitExceeded. He still wants to know the answer for such large ranges. Can you help him by writing a code that can also produce an answer for such large ranges?   

Input Format 
First line of input contains a single integer [expression] denoting inputs to the above function.  

Output Format 
Output consists of [expression] lines each containing result computed by the function when corresponding range is inputted to the function.

Constraints 
[expression] 
[expression]

Sample Input  

2
1 10
2 5


Sample Output  

9
2


Explanation 
Pass Parameters to the function and check the result.
----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class E {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";
	
	static void solve()
	{
		int Z = 2000000;
		int[] lpf = enumLowestPrimeFactors(Z+10);
		int[] ts = enumTotientByLpf(Z+10, lpf);
		long[] u = new long[Z];
		for(int i = 1;i &lt; Z;i++){
			if(i % 2 == 0){
				u[i] = (long)ts[i/2]*ts[i+1];
			}else{
				u[i] = (long)ts[i]*ts[(i+1)/2];
			}
		}
		long[] ucum = new long[Z+1];
		for(int i = 1;i &lt;= Z;i++){
			ucum[i] = ucum[i-1] + u[i-1];
		}
		
		for(int T = ni();T &gt;= 1;T--){
			long l = nl(), r = nl();
			out.println(ucum[upper(r)+1]-ucum[upper(l-1)+1]);
		}
	}
	
	static int upper(long n)
	{
		long low = 0, high = 3000000L;
		while(high - low &gt; 1){
			long h = (high+low)/2;
			if(h*(h+1)/2 &lt;= n){
				low = h;
			}else{
				high = h;
			}
		}
		return (int)low;
	}
	
	public static int[] enumTotientByLpf(int n, int[] lpf)
	{
		int[] ret = new int[n+1];
		ret[1] = 1;
		for(int i = 2;i &lt;= n;i++){
			int j = i/lpf[i];
			if(lpf[j] != lpf[i]){
				ret[i] = ret[j] * (lpf[i]-1);
			}else{
				ret[i] = ret[j] * lpf[i];
			}
		}
		return ret;
	}
	
	public static int[] enumLowestPrimeFactors(int n)
	{
		int tot = 0;
		int[] lpf = new int[n+1];
		int u = n+32;
		double lu = Math.log(u);
		int[] primes = new int[(int)(u/lu+u/lu/lu*1.5)];
		for(int i = 2;i &lt; n;i++)lpf[i] = i;
		for(int p = 2;p &lt;= n;p++){
			if(lpf[p] == p)primes[tot++] = p;
			int tmp;
			for(int i = 0;i &lt; tot &amp;&amp; primes[i] &lt;= lpf[p] &amp;&amp; (tmp = primes[i]*p) &lt;= n;i++){
				lpf[tmp] = primes[i];
			}
		}
		return lpf;
	}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static boolean eof()
	{
		if(lenbuf == -1)return true;
		int lptr = ptrbuf;
		while(lptr &lt; lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;
		
		try {
			is.mark(1000);
			while(true){
				int b = is.read();
				if(b == -1){
					is.reset();
					return true;
				}else if(!isSpaceChar(b)){
					is.reset();
					return false;
				}
			}
		} catch (IOException e) {
			return true;
		}
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private static int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private static double nd() { return Double.parseDouble(ns()); }
	private static char nc() { return (char)skip(); }
	
	private static String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private static char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private static char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private static int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

----------
====================