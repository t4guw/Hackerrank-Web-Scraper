
----------
ALGORITHMS.1
easy
----------
PROBLEM STATEMENT:
Complete the function solveMeFirst to compute the sum of two integers.

Function prototype:  

int solveMeFirst(int a, int b);

where,


a is the first integer input.
b is the second integer input


Return values  


 sum of the above two integers   

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int solveMeFirst(int a, int b) {
 // Hint: Type return a+b; below:
  return a+b;
}

int main() {
  int num1, num2;
  int sum;
  cin&gt;&gt;num1&gt;&gt;num2;
  sum = solveMeFirst(num1,num2);
  cout&lt;&lt;sum;
  return 0;
}
----------
====================
----------
ALGORITHMS.2
easy
----------
PROBLEM STATEMENT:
Given an array of integers, find the sum of its elements.

For example, if the array [expression].  

Function Description

Complete the simpleArraySum function in the editor below.  It must return the sum of the array elements as an integer.  

simpleArraySum has the following parameter(s):  


ar: an array of integers  

----------
TOP SOLUTION:
----------
n = input()
arr = map(int,raw_input().split())
print sum(arr)
----------
====================
----------
ALGORITHMS.3
easy
----------
PROBLEM STATEMENT:
Alice and Bob each created one problem for HackerRank. A reviewer rates the two challenges, awarding points on a scale from [expression] for three categories: problem clarity, originality, and difficulty. 

We define the rating for Alice's challenge to be the triplet [expression].

Your task is to find their comparison points by comparing [expression]. 


If [expression] point. 
If [expression] point. 
If [expression], then neither person receives a point.


Comparison points is the total points a person earned.

Given [expression], determine their respective comparison points.

For example, [expression] with Alice's score first and Bob's second.  

Function Description

Complete the function compareTriplets in the editor below.  It must return an array of two integers, the first being Alice's score and the second being Bob's.  

compareTriplets has the following parameter(s):


a: an array of integers representing Alice's challenge rating  
b: an array of integers representing Bob's challenge rating  

----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define FOR(i,a,b) for(int i = (a); i &lt;= (b); ++i)
#define FORD(i,a,b) for(int i = (a); i &gt;= (b); --i)
#define RI(i,n) FOR(i,1,(n))
#define REP(i,n) FOR(i,0,(n)-1)
#define mini(a,b) a=min(a,b)
#define maxi(a,b) a=max(a,b)
#define mp make_pair
#define pb push_back
#define st first
#define nd second
#define sz(w) (int) w.size()
typedef vector&lt;int&gt; vi;
typedef long long ll;
typedef long double ld;
typedef pair&lt;int,int&gt; pii;
const int inf = 1e9 + 5;
const int nax = 1e6 + 5;

int a[3], b[3];
int one, two;


int main() {
	REP(i, 3) scanf("%d", &amp;a[i]);
	REP(i, 3) scanf("%d", &amp;b[i]);
	REP(i, 3) {
		if(a[i] &gt; b[i]) ++one;
		if(a[i] &lt; b[i]) ++two;
	}
	printf("%d %d\n", one, two);
	return 0;
}

----------
====================
----------
ALGORITHMS.4
easy
----------
PROBLEM STATEMENT:
Calculate and print the sum of the elements in an array, keeping in mind that some of those integers may be quite large.

Function Description

Complete the aVeryBigSum function in the editor below.  It must return the sum of all array elements.

aVeryBigSum has the following parameter(s):


ar: an array of integers . 


Input Format 

The first line of the input consists of an integer [expression]. 
The next line contains [expression] space-separated integers contained in the array. 

Output Format

Print the integer sum of the elements in the array.

Constraints 
[expression] 
[expression]  

Sample Input  

5
1000000001 1000000002 1000000003 1000000004 1000000005


Output   

5000000015


Note: 

The range of the 32-bit integer is [expression]. 

When we add several integer values, the resulting sum might exceed the above range. You might need to use long long int in C/C++ or long data type in Java to store such sums.  
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    int n;
    cin&gt;&gt;n;
    unsigned long long int sum=0,in;
    for(int i=0;i&lt;n;i++)
        {cin&gt;&gt;in;
        sum+=in;}
    cout&lt;&lt;sum;
    return 0;
}

----------
====================
----------
ALGORITHMS.5
easy
----------
PROBLEM STATEMENT:
Given a square matrix, calculate the absolute difference between the sums of its diagonals.  

For example, the square matrix [expression] is shown below:  

1 2 3
4 5 6
9 8 9  


The left-to-right diagonal = [expression].  

Function description

Complete the [expression] function in the editor below.  It must return an integer representing the absolute diagonal difference.

diagonalDifference takes the following parameter:  


arr: an array of integers . 

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int N; 
    cin &gt;&gt; N; 
    
    int i, j; 
    
    int sumdiag1 = 0; 
    int sumdiag2 = 0; 
    for(i = 0; i &lt; N; i++){
        for(j = 0; j&lt; N; j++)
        {
           int no; 
           cin &gt;&gt; no; 
           if(i == j)
               sumdiag1 += no; 
           if(i+j == N-1)
              sumdiag2 += no; 
        }
    }
    
    cout &lt;&lt; abs(sumdiag1 - sumdiag2);
    return 0;
}

----------
====================
----------
ALGORITHMS.6
easy
----------
PROBLEM STATEMENT:
Given an array of integers, calculate the fractions of its elements that are positive,  negative, and are zeros. Print the decimal value of each fraction on a new line.

Note: This challenge introduces precision problems. The test cases are scaled to six decimal places, though answers with absolute error of up to [expression] are acceptable.

For example, given the array [expression].  It should be printed as  

0.400000
0.400000
0.200000


Function Description

Complete the plusMinus function in the editor below.  It should print out the ratio of positive, negative and zero items in the array, each on a separate line rounded to six decimals.  

plusMinus has the following parameter(s):


arr: an array of integers

----------
TOP SOLUTION:
----------
from __future__ import division
n = input()
arr = map(int,raw_input().split())
c1 = len(filter(lambda x:x&gt;0,arr))
c2 = len(filter(lambda x:x&lt;0,arr))
c3 = len(filter(lambda x:x==0,arr))
print "%.7f" % (c1/n)
print "%.7f" % (c2/n)
print "%.7f" % (c3/n)
----------
====================
----------
ALGORITHMS.7
easy
----------
PROBLEM STATEMENT:
Consider a staircase of size [expression]:

   #
  ##
 ###
####


Observe that its base and height are both equal to [expression], and the image is drawn using # symbols and spaces. The last line is not preceded by any spaces. 

Write a program that prints a staircase of size [expression].  

Function Description

Complete the staircase function in the editor below.  It should print a staircase as described above.  

staircase has the following parameter(s):  


n: an integer

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
    int n;
    cin &gt;&gt; n;
    string str(n, ' ');
        
    for (int i = 1; i &lt;= n; ++i) {
        str[n-i] = '#';
        cout &lt;&lt; str &lt;&lt; endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.8
easy
----------
PROBLEM STATEMENT:
Given five positive integers, find the minimum and maximum values that can be calculated by summing exactly four of the five integers. Then print the respective minimum and maximum values as a single line of two space-separated long integers.  

For example, [expression].  We would print  

16 24


Function Description  

Complete the miniMaxSum function in the editor below.  It should print two space-separated integers on one line: the minimum sum and the maximum sum of [expression] elements.  

miniMaxSum has the following parameter(s):


arr: an array of [expression] integers  

----------
TOP SOLUTION:
----------
# Enter your code here. Read input from STDIN. Print output to STDOUT
a = sorted(map(int,raw_input().split()))
print sum(a[:4]),sum(a[1:])
----------
====================
----------
ALGORITHMS.9
easy
----------
PROBLEM STATEMENT:
You are in charge of the cake for your niece's birthday and have decided the cake will have one candle for each year of her total age. When she blows out the candles, she’ll only be able to blow out the tallest ones. Your task is to find out how many candles she can successfully blow out. 

For example, if your niece is turning [expression] such candles.  

Function Description

Complete the function birthdayCakeCandles in the editor below.  It must return an integer representing the number of candles she can blow out.  

birthdayCakeCandles has the following parameter(s):


ar: an array of integers representing candle heights     

----------
TOP SOLUTION:
----------
n = raw_input()

l = map(int, raw_input().strip().split(' '))
print l.count(max(l))
----------
====================
----------
ALGORITHMS.10
easy
----------
PROBLEM STATEMENT:
Given a time in [expression]-hour AM/PM format, convert it to military (24-hour) time.  

Note: Midnight is 12:00:00AM on a 12-hour clock, and 00:00:00 on a 24-hour clock. Noon is 12:00:00PM on a 12-hour clock, and 12:00:00 on a 24-hour clock. 

Function Description  

Complete the timeConversion function in the editor below.  It should return a new string representing the input time in 24 hour format.  

timeConversion has the following parameter(s):


s: a string representing time in [expression] hour format  

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

   	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String s = sc.nextLine(); //07:05:45PM
		DateFormat inFormat = new SimpleDateFormat( "hh:mm:ssaa");
		DateFormat outFormat = new SimpleDateFormat( "HH:mm:ss");

		Date date = null;
		try {
			date = inFormat.parse(s); 
		}catch (ParseException e ){
			e.printStackTrace();
		}
		if( date != null ){
			String myDate = outFormat.format(date);
			System.out.println(myDate);
		}
	}

}

----------
====================
----------
ALGORITHMS.11
easy
----------
PROBLEM STATEMENT:
HackerLand University has the following grading policy:


Every student receives a [expression].
Any [expression] is a failing grade. 


Sam is a professor at the university and likes to round each student's [expression] according to these rules:


If the difference between the [expression].
If the value of [expression], no rounding occurs as the result will still be a failing grade.


For example, [expression].  

Given the initial value of [expression] students, write code to automate the rounding process.   

Function Description  

Complete the function gradingStudents in the editor below.  It should return an integer array consisting of rounded grades.  

gradingStudents has the following parameter(s):  


grades:  an array of integers representing grades before rounding  

----------
TOP SOLUTION:
----------
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;
#include &lt;cstdio&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_map&gt;

using namespace std;


int main(){
    int n;
    cin &gt;&gt; n;
    for(int a0 = 0; a0 &lt; n; a0++){
        int grade;
        cin &gt;&gt; grade;
        if (grade &gt;= 38) {
            int rem = grade % 5;
            if (rem &gt;= 3) grade += 5 - rem;
        }
        cout &lt;&lt; grade &lt;&lt; endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.12
easy
----------
PROBLEM STATEMENT:
Sam's house has an apple tree and an orange tree that yield an abundance of fruit. In the diagram below, the red region denotes his house, where [expression].



When a fruit falls from its tree, it lands [expression] units to the tree's right. 

Given the value of [expression])?

For example, Sam's house is between [expression] so we print 

1
2


Function Description  

Complete the countApplesAndOranges function in the editor below.  It should print the number of apples and oranges that land on Sam's house, each on a separate line.  

countApplesAndOranges has the following parameter(s):  


s: integer, starting point of Sam's house location.       
t: integer, ending location of Sam's house location.     
a: integer, location of the Apple tree.      
b: integer, location of the Orange tree.         
apples: integer array, distances at which each apple falls from the tree.      
oranges: integer array, distances at which each orange falls from the tree.  

----------
TOP SOLUTION:
----------
#!/bin/python

import sys


s,t = raw_input().strip().split(' ')
s,t = [int(s),int(t)]
a,b = raw_input().strip().split(' ')
a,b = [int(a),int(b)]
m,n = raw_input().strip().split(' ')
m,n = [int(m),int(n)]
apple = map(int,raw_input().strip().split(' '))
orange = map(int,raw_input().strip().split(' '))
acount=0
for i in apple:
    if s&lt;=a+i&lt;=t:
        acount+=1
ocount=0
for i in orange:
    if s&lt;=b+i&lt;=t:
        ocount+=1
print acount
print ocount
----------
====================
----------
ALGORITHMS.13
easy
----------
PROBLEM STATEMENT:
You are choreographing a circus show with various animals. For one act, you are given two kangaroos on a number line ready to jump in the positive direction (i.e, toward positive infinity). 


The first kangaroo starts at location [expression] meters per jump. 
The second kangaroo starts at location [expression] meters per jump.


You have to figure out a way to get both kangaroos at the same location at the same time as part of the show.  If it is possible, return YES, otherwise return NO.

For example, kangaroo [expression]), so our answer is YES.

Function Description

Complete the function kangaroo in the editor below.  It should return YES if they reach the same position at the same time, or NO if they don't.  

kangaroo has the following parameter(s):  


x1, v1: integers, starting position and jump distance for kangaroo 1
x2, v2: integers, starting position and jump distance for kangaroo 2

----------
TOP SOLUTION:
----------
using System;
class Solution {
    static void Main(String[] args) {
        var tmp = Console.ReadLine().Split(' ');
        int x1 = int.Parse(tmp[0]);
        int v1 = int.Parse(tmp[1]);
        int x2 = int.Parse(tmp[2]);
        int v2 = int.Parse(tmp[3]);

        float t1 = (float)(x1 - x2) / (float)(v2 - v1);
        if (t1 &lt; 0 || t1 != Math.Floor(t1)) {
            Console.WriteLine("NO");
        } else {
            Console.WriteLine("YES");
        }
    }
}
----------
====================
----------
ALGORITHMS.14
easy
----------
PROBLEM STATEMENT:
You will be given two arrays of integers and asked to determine all integers that satisfy the following two conditions:  


The elements of the first array are all factors of the integer being considered
The integer being considered is a factor of all elements of the second array


These numbers are referred to as being between the two arrays.  You must determine how many such numbers exist.

For example, given the arrays [expression].  

Function Description  

Complete the getTotalX function in the editor below.  It should return the number of integers that are betwen the sets.  

getTotalX has the following parameter(s):  


a: an array of integers  
b: an array of integers  

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;fstream&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i &lt; (int)(n); ++i)
#define for1(i, n) for (int i = 1; i &lt;= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i &gt;= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i &lt;= (int)(b); ++i)

using namespace std;

typedef pair&lt;int, int&gt; pii;
typedef vector&lt;int&gt; vi;
typedef vector&lt;pii&gt; vpi;
typedef vector&lt;vi&gt; vvi;
typedef long long i64;
typedef vector&lt;i64&gt; vi64;
typedef vector&lt;vi64&gt; vvi64;

template&lt;class T&gt; bool uin(T &amp;a, T b) { return a &gt; b ? (a = b, true) : false; }
template&lt;class T&gt; bool uax(T &amp;a, T b) { return a &lt; b ? (a = b, true) : false; }

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout &lt;&lt; fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    vi a(n); forn(i, n) cin &gt;&gt; a[i];
    vi b(m); forn(i, m) cin &gt;&gt; b[i];
    int ans = 0;
    for1(k, 100) {
        bool ok = true;
        for (int x: a) ok &amp;= k % x == 0;
        for (int x: b) ok &amp;= x % k == 0;
        if (ok) ++ans;
    }
    cout &lt;&lt; ans &lt;&lt; '\n';

#ifdef LOCAL_DEFINE
    cerr &lt;&lt; "Time elapsed: " &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.15
easy
----------
PROBLEM STATEMENT:
Maria plays college basketball and wants to go pro.  Each season she maintains a record of her play.  She tabulates the number of times she breaks her season record for most points and least points in a game.  Points scored in the first game establish her record for the season, and she begins counting from there.

For example, assume her scores for the season are represented in the array [expression].  Scores are in the same order as the games played.  She would tabulate her results as follows:

                                 Count
Game  Score  Minimum  Maximum   Min Max
 0      12     12       12       0   0
 1      24     12       24       0   1
 2      10     10       24       1   1
 3      24     10       24       1   1


Given Maria's scores for a season, find and print the number of times she breaks her records for most and least points scored during the season.

Function Description  

Complete the breakingRecords function in the editor below.  It must return an integer array containing the numbers of times she broke her records.  Index [expression] is for breaking least points records.  

breakingRecords has the following parameter(s):  


scores: an array of integers  

----------
TOP SOLUTION:
----------
#!/bin/python

import sys


n = int(raw_input().strip())
score = map(int, raw_input().strip().split(' '))
a = score[0]
b = score[0]
r1 = 0
r2 = 0

for i in score[1:]:
    if i &gt; a:
        a = i
        r1 += 1
    if i &lt; b:
        b = i
        r2 += 1
print r1,r2
----------
====================
----------
ALGORITHMS.16
easy
----------
PROBLEM STATEMENT:
Lily has a chocolate bar that she wants to share it with Ron for his birthday.  Each of the squares has an integer on it.  She decides to share a contiguous segment of the bar selected such that the length of the segment matches Ron's birth month and the sum of the integers on the squares is equal to his birth day.  You must determine how many ways she can divide the chocolate.

Consider the chocolate bar as an array of squares, [expression].

Function Description

Complete the birthday function in the editor below.  It should return an integer denoting the number of ways Lily can divide the chocolate bar.  

birthday has the following parameter(s):  


s: an array of integers, the numbers on each of the squares of chocolate  
d: an integer, Ron's birth day  
m: an integer, Ron's birth month  

----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long int uli;
const int mx=123;
int s[mx];
int main(){
  int n,d,m;
  scanf("%d",&amp;n);
  for(int i=0;i&lt;n;i++){
    scanf("%d",s+i);
  }
  scanf("%d %d",&amp;d,&amp;m);
  int ans=0;
  for(int i=0;i&lt;n;i++){
    for(int j=i;j&lt;n;j++)if(j-i+1==m){
      int sm=0;
      for(int k=i;k&lt;=j;k++)sm+=s[k];
      if(sm==d){
        ans++;
      }
    }
  }
  printf("%d\n",ans);
  return 0;
}

----------
====================
----------
ALGORITHMS.17
easy
----------
PROBLEM STATEMENT:
You are given an array of [expression].  

For example, [expression].  

Function Description

Complete the divisibleSumPairs function in the editor below.  It should return the integer count of pairs meeting the criteria.  

divisibleSumPairs has the following parameter(s):  


n: the integer length of array [expression]  
ar: an array of integers  
k: the integer to divide the pair sum by  

----------
TOP SOLUTION:
----------
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;
#include &lt;cstdio&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_map&gt;

using namespace std;


int main(){
    int n;
    int k;
    int count = 0;
    cin &gt;&gt; n &gt;&gt; k;
    vector&lt;int&gt; a(n);
    for(int a_i = 0;a_i &lt; n;a_i++){
       cin &gt;&gt; a[a_i];
    }
    
    for(int i =0 ; i &lt; n -1 ; i++){
        for(int j=i+1 ; j &lt; n ; j++){
            if( (a[i]+a[j])%k ==0){
                count++;
            }
        }
    }
    
    cout &lt;&lt; count;
    return 0;
}

----------
====================
----------
ALGORITHMS.18
easy
----------
PROBLEM STATEMENT:
You have been asked to help study the population of birds migrating across the continent.  Each type of bird you are interested in will be identified by an integer value.  Each time a particular kind of bird is spotted, its id number will be added to your array of sightings. You would like to be able to find out which type of bird is most common given a list of sightings. Your task is to print the type number of that bird and if two or more types of birds are equally common, choose the type with the smallest ID number.

For example, assume your bird sightings are of types [expression].  

Function Description

Complete the migratoryBirds function in the editor below.  It should return the lowest type number of the most frequently sighted bird.  

migratoryBirds has the following parameter(s):  


arr: an array of integers representing types of birds sighted  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxN = 1e5+10;
int N,A[10];

int main()
{
    cin &gt;&gt; N;
    for (int i=1,x; i &lt;= N; i++) cin &gt;&gt; x, A[x]++;
    int ans = 1;
    for (int i=2; i &lt;= 5; i++)
        if (A[i] &gt; A[ans]) ans = i;
    cout &lt;&lt; ans;
}

----------
====================
----------
ALGORITHMS.19
easy
----------
PROBLEM STATEMENT:
Marie invented a Time Machine and wants to test it by time-traveling to visit Russia on the Day of the Programmer (the [expression]. 

From [expression] day of the year in Russia.

In both calendar systems, February is the only month with a variable amount of days; it has [expression]; in the Gregorian calendar, leap years are either of the following:


Divisible by [expression].
Divisible by [expression].


Given a year, [expression].

For example, the given [expression].  

Function Description  

Complete the dayOfProgrammer function in the editor below.  It should return a string representing the date of the [expression] day of the year given.  

dayOfProgrammer has the following parameter(s):  


year: an integer  

----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class A {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	void solve()
	{
		int y = ni();
		if(y &lt; 1918){
			if(y % 4 == 0){
				out.println("12.09." + y);
			}else{
				out.println("13.09." + y);
			}
		}else if(y == 1918){
			int m = 1, d = 1, th = 1;
			while(th &lt; 256){
				th++;
				d++;
				if(d == 32 &amp;&amp; m == 1){
					m = 2;
					d = 14;
				}
				if(d &gt; DOM[m-1]){
					m++;
					d = 1;
				}
			}
			out.printf("%02d.%02d.%4d\n", d, m, y);
		}else if(y &gt; 1918){
			if(y % 4 == 0 &amp;&amp; (y % 100 != 0 || y % 400 == 0)){
				out.println("12.09." + y);
			}else{
				out.println("13.09." + y);
			}
		}
	}
	
	public static int[] DOM = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new A().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.20
easy
----------
PROBLEM STATEMENT:
Anna and Brian are sharing a meal at a restuarant and they agree to split the bill equally.  Brian wants to order something that Anna is allergic to though, and they agree that Anna won't pay for that item.  Brian gets the check and calculates Anna's portion.  You must determine if his calculation is correct.

For example, assume the bill has the following prices: [expression] to Anna.

Function Description  

Complete the bonAppetit function in the editor below.  It should print Bon Appetit if the bill is fairly split.  Otherwise, it should print the integer amount of money that Brian owes Anna.  

bonAppetit has the following parameter(s):  


bill: an array of integers representing the cost of each item ordered  
k: an integer representing the zero-based index of the item Anna doesn't eat  
b: the amount of money that Anna contributed to the bill  

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    int n, k, sum=0;
    cin &gt;&gt; n &gt;&gt; k;
    for (int i=0;i&lt;n;i++) {
        int a;
        cin &gt;&gt; a;
        if (i!=k) sum+=a;
    }
    int l;
    cin &gt;&gt; l;
    if (sum/2==l) cout &lt;&lt; "Bon Appetit" &lt;&lt; endl;
    else cout &lt;&lt; l-sum/2 &lt;&lt; endl;
}

----------
====================
----------
ALGORITHMS.21
easy
----------
PROBLEM STATEMENT:
John works at a clothing store.  He has a large pile of socks that he must pair by color for sale.  Given an array of integers representing the color of each sock, determine how many pairs of socks with matching colors there are.

For example, there are [expression].  

Function Description  

Complete the sockMerchant function in the editor below.  It must return an integer representing the number of matching pairs of socks that are available.  

sockMerchant has the following parameter(s):  


n: the number of socks in the pile  
ar: the colors of each sock  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

#define FI(i,a,b) for(int i=(a);i&lt;=(b);i++)
#define FD(i,a,b) for(int i=(a);i&gt;=(b);i--)

#define LL long long
#define Ldouble long double
#define PI 3.1415926535897932384626

#define PII pair&lt;int,int&gt;
#define PLL pair&lt;LL,LL&gt;
#define mp make_pair
#define fi first
#define se second

using namespace std;

int n, c[105], x;

int main(){
	scanf("%d", &amp;n);
	FI(i, 1, n){
		scanf("%d", &amp;x);
		c[x]++;
	}
	
	int ans = 0;
	
	FI(i, 1, 100) ans += c[i] / 2;
	printf("%d\n", ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.22
easy
----------
PROBLEM STATEMENT:
Brie’s Drawing teacher asks her class to open their books to a page number. Brie can either start turning pages from the front of the book or from the back of the book. She always turns pages one at a time.  When she opens the book, page [expression] is always on the right side:



When she flips page [expression], what is the minimum number of pages she will turn?  She can start at the beginning or the end of the book. 

Given [expression]. 

Function Description  

Complete the pageCount function in the editor below.  It should return the minimum number of pages Brie must turn.  

pageCount has the following parameter(s):  


n: the number of pages in the book   
p: the page number to turn to  

----------
TOP SOLUTION:
----------
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;
#include &lt;cstdio&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_map&gt;

using namespace std;


int main(){
    int n;
    cin &gt;&gt; n;
    int p;
    cin &gt;&gt; p;
    cout&lt;&lt;min(p/2,(n-p)/2);
    // your code goes here
    return 0;
}

----------
====================
----------
ALGORITHMS.23
easy
----------
PROBLEM STATEMENT:
Gary is an avid hiker. He tracks his hikes meticulously, paying close attention to small details like topography. During his last hike he took exactly [expression] unit change in altitude. We define the following terms:


A mountain is a sequence of consecutive steps above sea level, starting with a step up from sea level and ending with a step down to sea level.  
A valley is a sequence of consecutive steps below sea level, starting with a step down from sea level and ending with a step up to sea level.


Given Gary's sequence of up and down steps during his last hike, find and print the number of valleys he walked through. 

For example, if Gary's path is [expression] units high.  Finally, he returns to sea level and ends his hike.  

Function Description  

Complete the countingValleys function in the editor below.  It must return an integer that denotes the number of valleys Gary traversed.  

countingValleys has the following parameter(s):  


n: the number of steps Gary takes  
s: a string describing his path  

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        in.nextInt();
        String s = in.next();
        
        int level = 0;
        int valleys = 0;
        for(int i = 0; i &lt; s.length(); i++){
            if(s.charAt(i) == 'U'){
                level++;
            }else if(s.charAt(i) == 'D'){
                if(level == 0){
                    valleys++;
                }
                level--;
            }
        }
        System.out.println(valleys);
    }
}
----------
====================
----------
ALGORITHMS.24
easy
----------
PROBLEM STATEMENT:
Monica wants to buy a keyboard and a USB drive from her favorite electronics store. The store has several models of each.  Monica wants to spend as much as possible for the [expression] items, given her budget.

Given the price lists for the store's keyboards and USB drives, and Monica's budget, find and print the amount of money Monica will spend. If she doesn't have enough money to both a keyboard and a USB drive, print -1 instead.  She will buy only the two required items.

For example, suppose she has [expression].  

Function Description  

Complete the getMoneySpent function in the editor below.  It should return the maximum total price for the two items within Monica's budget, or [expression] if she cannot afford both items.  

getMoneySpent has the following parameter(s):  


keyboards: an array of integers representing keyboard prices  
drives:  an array of integers representing drive prices  
b: the units of currency in Monica's budget  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;
#define REP(i,a,b) for (int i = (a); i &lt;= (b); ++i)
#define REPD(i,a,b) for (int i = (a); i &gt;= (b); --i)
#define FORI(i,n) REP(i,1,n)
#define FOR(i,n) REP(i,0,int(n)-1)
#define mp make_pair
#define pb push_back
#define pii pair&lt;int,int&gt;
#define vi vector&lt;int&gt;
#define ll long long
#define SZ(x) int((x).size())
#define DBG(v) cerr &lt;&lt; #v &lt;&lt; " = " &lt;&lt; (v) &lt;&lt; endl;
#define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++)
#define fi first
#define se second


int main(){
    int s;
    int n;
    int m;
    cin &gt;&gt; s &gt;&gt; n &gt;&gt; m;
    vector&lt;int&gt; keyboards(n);
    for(int keyboards_i = 0;keyboards_i &lt; n;keyboards_i++){
       cin &gt;&gt; keyboards[keyboards_i];
    }
    vector&lt;int&gt; pendrives(m);
    for(int pendrives_i = 0;pendrives_i &lt; m;pendrives_i++){
       cin &gt;&gt; pendrives[pendrives_i];
    }
    int res=-1;
    FOR(i,n) FOR(j,m) if (keyboards[i]+pendrives[j] &lt;= s) res = max(res, keyboards[i]+pendrives[j]);
        cout &lt;&lt; res &lt;&lt; "\n";
    return 0;
}

----------
====================
----------
ALGORITHMS.25
easy
----------
PROBLEM STATEMENT:
Two cats and a mouse are at various positions on a line.  You will be given their starting positions.  Your task is to determine which cat will reach the mouse first, assuming the mouse doesn't move and the cats travel at equal speed.  If the cats arrive at the same time, the mouse will be allowed to move and it will escape while they fight.

You are given [expression] to return the appropriate answer to each query, which will be printed on a new line.


If cat [expression] catches the mouse first, print Cat A.
If cat [expression] catches the mouse first, print Cat B.
If both cats reach the mouse at the same time, print Mouse C as the two cats fight and mouse escapes.  


For example, cat [expression] will catch the mouse.  

Function Description  

Complete the catAndMouse function in the editor below.  It should return one of the three strings as described.  

catAndMouse has the following parameter(s):  


x: an integer, Cat [expression]'s position  
y: an integer, Cat [expression]'s position  
z: an integer, Mouse [expression]'s position  

----------
TOP SOLUTION:
----------
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;
#include &lt;cstdio&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_map&gt;

using namespace std;


int main(){
    int q;
    cin &gt;&gt; q;
    for(int a0 = 0; a0 &lt; q; a0++){
        int x;
        int y;
        int z;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
        int d1 = abs(x - z), d2 = abs(y - z);
        if (d1 &lt; d2) cout &lt;&lt; "Cat A" &lt;&lt; endl;
        else if (d1 &gt; d2) cout &lt;&lt; "Cat B" &lt;&lt; endl;
            else cout &lt;&lt; "Mouse C" &lt;&lt; endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.26
medium
----------
PROBLEM STATEMENT:
We define a magic square to be an [expression] is always equal to the same number:  the magic constant. 

You will be given a [expression], convert it into a magic square at minimal cost. Print this cost on a new line.

Note: The resulting magic square must contain distinct integers in the inclusive range [expression].

For example, we start with the following matrix [expression]:  

[expression]
[expression]
[expression]



We can convert it to the following magic square:

[expression]
[expression]
[expression]



This took three replacements at a cost of [expression].

Function Description

Complete the formingMagicSquare function in the editor below.  It should return an integer that represents the minimal total cost of converting the input square to a magic square.

formingMagicSquare has the following parameter(s):  


s: a [expression] array of integers

----------
TOP SOLUTION:
----------
from itertools import *

X = []
X.extend(list(map(int,input().split())))
X.extend(list(map(int,input().split())))
X.extend(list(map(int,input().split())))

Ans = 81
for P in permutations(range(1,10)):
    if sum(P[0:3]) == 15 and sum(P[3:6]) == 15 and sum(P[0::3]) == 15 and sum(P[1::3]) == 15 and P[0] + P[4] + P[8] == 15 and (P[2] + P[4] + P[6] == 15):
        Ans = min(Ans, sum(abs(P[i] - X[i]) for i in range(0,9)))
print(Ans)
----------
====================
----------
ALGORITHMS.27
easy
----------
PROBLEM STATEMENT:
Given an array of integers, find and print the maximum number of integers you can select from the array such that the absolute difference between any two of the chosen integers is less than or equal to [expression] elements.

Function Description  

Complete the pickingNumbers function in the editor below.  It should return an integer that represents the length of the longest array that can be created.  

pickingNumbers has the following parameter(s):  


a: an array of integers  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

int N;
int A[1000];

int main()
{
    scanf("%d", &amp;N);
    for(int i=0; i&lt;N; i++)
    {
        int a;
        scanf("%d", &amp;a);
        A[a]++;
    }
    int ans=0;
    for(int i=1; i&lt;1000; i++)
        ans=max(ans, A[i-1]+A[i]);
    printf("%d\n", ans);
    return 0;
}

----------
====================
----------
ALGORITHMS.28
medium
----------
PROBLEM STATEMENT:
Alice is playing an arcade game and wants to climb to the top of the leaderboard and wants to track her ranking. The game uses Dense Ranking, so its leaderboard works like this:  


The player with the highest score is ranked number [expression] on the leaderboard. 
Players who have equal scores receive the same ranking number, and the next player(s) receive the immediately following ranking number.


For example, the four players on the leaderboard have high scores of [expression]. 

Function Description  

Complete the climbingLeaderboard function in the editor below.  It should return an integer array where each element [expression] game.

climbingLeaderboard has the following parameter(s):  


scores: an array of integers that represent leaderboard scores  
alice: an array of integers that represent Alice's scores  

----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; static void amin(T &amp;x, U y) { if (y &lt; x) x = y; }
template&lt;typename T, typename U&gt; static void amax(T &amp;x, U y) { if (x &lt; y) x = y; }

int main() {
	int n;
	while (~scanf("%d", &amp;n)) {
		vector&lt;int&gt; a(n);
		for (int i = 0; i &lt; n; ++i)
			scanf("%d", &amp;a[i]);
		a.erase(unique(a.begin(), a.end()), a.end());

		int m;
		scanf("%d", &amp;m);
		rep(i, m) {
			int x;
			scanf("%d", &amp;x);
			int ans = (int)(lower_bound(a.begin(), a.end(), x, greater&lt;int&gt;()) - a.begin());
			printf("%d\n", ans + 1);
		}
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.29
easy
----------
PROBLEM STATEMENT:
Dan is playing a video game in which his character competes in a hurdle race.  Hurdles are of varying heights, and Dan has a maximum height he can jump.  There is a magic potion he can take that will increase his maximum height by [expression] unit for each dose.  How many doses of the potion must he take to be able to jump all of the hurdles.

Given an array of hurdle heights [expression], determine the minimum number of doses Dan must take to be able to clear all the hurdles in the race.  

For example, if [expression] doses of potion to be able to jump all of the hurdles.  

Function Description  

Complete the hurdleRace function in the editor below.  It should return the minimum units of potion Dan needs to drink to jump all of the hurdles.  

hurdleRace has the following parameter(s):  


k: an integer denoting the height Dan can jump naturally  
height: an array of integers denoting the heights of each hurdle  

----------
TOP SOLUTION:
----------
#!/bin/python

import sys


n,k = raw_input().strip().split(' ')
n,k = [int(n),int(k)]
height = map(int, raw_input().strip().split(' '))
# your code goes here
m = max(height)
print max(0,m-k)

----------
====================
----------
ALGORITHMS.30
easy
----------
PROBLEM STATEMENT:
When you select a contiguous block of text in a PDF viewer, the selection is highlighted with a blue rectangle. In this PDF viewer, each word is highlighted independently. For example: 



In this challenge, you will be given a list of letter heights in the alphabet and a string.  Using the letter heights given, determine the area of the rectangle highlight in [expression] wide.  

For example, the highlighted [expression].  

Function Description  

Complete the designerPdfViewer function in the editor below.  It should return an integer representing the size of the highlighted area.  

designerPdfViewer has the following parameter(s):


h: an array of integers representing the heights of each letter  
word: a string  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

int a[42];
char s[1231212];

int main() {
  for (int i = 0; i &lt; 26; i++) {
    scanf("%d", a + i);
  }
  scanf("%s", s);
  int h = 0;
  int w = 0;
  for (int i = 0; s[i]; i++) {
    w++;
    h = max(h, a[s[i] - 'a']);
  }
  printf("%d\n", h * w);
  return 0;
}

----------
====================
----------
ALGORITHMS.31
easy
----------
PROBLEM STATEMENT:
The Utopian Tree goes through 2 cycles of growth every year. Each spring, it doubles in height. Each summer, its height increases by 1 meter.

Laura plants a Utopian Tree sapling with a height of 1 meter at the onset of spring. How tall will her tree be after [expression] growth cycles?

For example, if the number of growth cycles is [expression], the calculations are as follows:

Period  Height
0          1
1          2
2          3
3          6
4          7
5          14


Function Description

Complete the utopianTree function in the editor below.  It should return the integer height of the tree after the input number of growth cycles.  

utopianTree has the following parameter(s):


n:  an integer, the number of growth cycles to simulate  

----------
TOP SOLUTION:
----------
#!/usr/bin/env python

import sys


if __name__ == '__main__':
    T = int(sys.stdin.readline())
    
    for _ in range(T):
        N = int(sys.stdin.readline())
        height = 1
        
        for i in range(N):
            if i % 2 == 0:
                height *= 2
            else:
                height += 1
            
        print(height)
----------
====================
----------
ALGORITHMS.32
easy
----------
PROBLEM STATEMENT:
A Discrete Mathematics professor has a class of students. Frustrated with their lack of discipline, he decides to cancel class if fewer than some number of students are present when class starts.  Arrival times go from on time ([expression]).

Given the arrival time of each student and a threshhold number of attendees, determine if the class is canceled.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	int a; cin &gt;&gt; a;
	for (int g=0; g&lt;a; g++)
	{
		int b,c; cin &gt;&gt; b &gt;&gt; c;
		int num=0; 
		for (int g=0; g&lt;b; g++)
		{
			int d; cin &gt;&gt; d;
			if (d&lt;=0) num++; 
		}
		if (num&gt;=c)
		{
			cout &lt;&lt; "NO" &lt;&lt; '\n'; 
		}
		else cout &lt;&lt; "YES" &lt;&lt; '\n';
	}
	return 0; 
}
----------
====================
----------
ALGORITHMS.33
easy
----------
PROBLEM STATEMENT:
Lily likes to play games with integers.  She has created a new game where she determines the difference between a number and its reverse.  For instance, given the number [expression].

She decides to apply her game to decision making.  She will look at a numbered range of days and will only go to a movie on a beautiful day.

Given a range of numbered days, [expression].  If a day's value is a beautiful number, it is a beautiful day.  Print the number of beautiful days in the range.

Function Description  

Complete the beautifulDays function in the editor below.  It must return the number of beautiful days in the range.  

beautifulDays has the following parameter(s):  


i: the starting day number  
j: the ending day number  
k: the divisor  

----------
TOP SOLUTION:
----------
SOLUTION NOT FOUND
----------
====================
----------
ALGORITHMS.34
easy
----------
PROBLEM STATEMENT:
HackerLand Enterprise is adopting a new viral advertising strategy. When they launch a new product, they advertise it to exactly [expression] people on social media. 

On the first day, half of those [expression] people receive the advertisement. 

Each day, [expression].

For example, assume you want to know how many have liked the ad by the end of the [expression] day.

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



The cumulative number of likes is [expression].  

Function Description  

Complete the viralAdvertising function in the editor below.  It should return the cumulative number of people who have liked the ad at a given time.  

viralAdvertising has the following parameter(s):  


n: the integer number of days  

----------
TOP SOLUTION:
----------
# Enter your code here. Read input from STDIN. Print output to STDOUT

days = gets.chomp.to_i
current_people = 5
received = 0
(0...days).each do |day|
    # Only 1/2 will share
    current_people = current_people / 2
    received += current_people
    # But they share with 3 people each
    current_people = current_people * 3
end

puts received
----------
====================
----------
ALGORITHMS.35
easy
----------
PROBLEM STATEMENT:
A jail has a number of prisoners and a number of treats to pass out to them.  Their jailer decides the fairest way to divide the treats is to seat the prisoners around a circular table in sequentially numbered chairs.  A chair number will be drawn from a hat.  Beginning with the prisoner in that chair, one candy will be handed to each prisoner sequentially around the table until all have been distributed.

The jailer is playing a little joke, though.  The last piece of candy looks like all the others, but it tastes awful.  Determine the chair number occupied by the prisoner who will receive that candy.

For example, there are [expression].  

Function Description

Complete the saveThePrisoner function in the editor below.  It should return an integer representing the chair number of the prisoner to warn.  

saveThePrisoner has the following parameter(s):  


n:  an integer, the number of prisoners  
m:  an integer, the number of sweets  
s:  an integer, the chair number to begin passing out sweets from  

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    int t; cin &gt;&gt; t;
    
    while(t--) {
        int n,m,s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
        --s; --m;
        s += m;
        s %= n;
        s++;
        cout &lt;&lt; s &lt;&lt; endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.36
easy
----------
PROBLEM STATEMENT:
John Watson knows of an operation called a right circular rotation on an array of integers.  One rotation operation moves the last array element to the first position and shifts all remaining elements right one.  To test Sherlock's abilities, Watson provides Sherlock with an array of integers.  Sherlock is to perform the rotation operation a number of times then determine the value of the element at a given position.

For each array, perform a number of right circular rotations and return the value of the element at a given index.

For example, array [expression]. 
First we perform the two rotations: 
[expression] 
Now return the values from the zero-based indices [expression] array. 
[expression] 
[expression]  

Function Description  

Complete the circularArrayRotation function in the editor below.  It should return an array of integers representing the values at the specified indices.  

circularArrayRotation has the following parameter(s):  


a: an array of integers to rotate  
k: an integer, the rotation count  
queries: an array of integers, the indices to report  

----------
TOP SOLUTION:
----------
#!/usr/bin/env python

import sys


if __name__ == '__main__':
    N, K, Q = list(map(int, sys.stdin.readline().split()))
    A = list(map(int, sys.stdin.readline().split()))
    
    for _ in range(Q):
        x = int(sys.stdin.readline())
        print(A[(x - K) % N])
----------
====================
----------
ALGORITHMS.37
easy
----------
PROBLEM STATEMENT:
Given a sequence of [expression] on a new line.

For example, assume the sequence [expression], the length of the sequence, is analyzed as follows:


[expression]
[expression]
[expression]
[expression]
[expression]


The values for [expression].  

Function Description  

Complete the permutationEquation function in the editor below.  It should return an array of integers that represent the values of [expression].  

permutationEquation has the following parameter(s):  


p: an array of integers  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

#define all(a) (a).begin(), (a).end()
#define sz(a) (int)(a).size()
#define pb push_back

using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef long double ld;

int main()
{

	//ifstream cin("input.txt");
	//ofstream cout("output.txt");

	int n;
	cin &gt;&gt; n;

	vector&lt;int&gt; p(n);
	for (int i = 0; i &lt; n; ++i) {
		int x;
		cin &gt;&gt; x;
		--x;
		p[x] = i;
	}

	for (int i = 0; i &lt; n; ++i) {
		cout &lt;&lt; p[p[i]] + 1 &lt;&lt; "\n";
	}

}

----------
====================
----------
ALGORITHMS.38
easy
----------
PROBLEM STATEMENT:
Aerith is playing a cloud hopping game. In this game, there are sequentially numbered clouds that can be thunderheads or cumulus clouds.  Her character must jump from cloud to cloud until it reaches the start again.  

To play, Aerith is given an array of clouds, [expression].

Given the values of [expression] after the game ends?

For example, give [expression].

Note: Recall that [expression].  

Function Description  

Complete the jumpingOnClouds function in the editor below.  It should return an integer representing the energy level remaining after the game.  

jumpingOnClouds has the following parameter(s):  


c: an array of integers representing cloud types  
k: an integer representing the length of one jump  

----------
TOP SOLUTION:
----------
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.io.*;
import java.math.*;
import java.text.*; 
import java.util.*;
import java.util.regex.*;
/*
      br = new BufferedReader(new FileReader("input.txt"));
      pw = new PrintWriter(new BufferedWriter(new FileWriter("output.txt")));
      br = new BufferedReader(new InputStreamReader(System.in));
      pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
 */


public class Solution {
	private static BufferedReader br;
	private static StringTokenizer st;
	private static PrintWriter pw;

	public static void main(String[] args) throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
		int qq = 1;
		//int qq = Integer.MAX_VALUE;
		//int qq = readInt();
		for(int casenum = 1; casenum &lt;= qq; casenum++) {
			int n = readInt();
			int k = readInt();
			int e = 100;
			for(int i = 0; i &lt; n; i++) {
				int c = readInt();
				if(i % k == 0) {
					e--;
					if(c == 1) {
						e -= 2;
					}
				}
			}
			pw.println(e);
		}
		exitImmediately();
	}

	private static void exitImmediately() {
		pw.close();
		System.exit(0);
	}

	private static long readLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	private static double readDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	private static int readInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	private static String nextLine() throws IOException  {
		if(!br.ready()) {
			exitImmediately();
		}
		st = null;
		return br.readLine();
	}

	private static String nextToken() throws IOException  {
		while(st == null || !st.hasMoreTokens())  {
			if(!br.ready()) {
				exitImmediately();
			}
			st = new StringTokenizer(br.readLine().trim());
		}
		return st.nextToken();
	}
}
----------
====================
----------
ALGORITHMS.39
easy
----------
PROBLEM STATEMENT:
An integer [expression].  

Given an integer, for each digit that makes up the integer determine whether it is a divisor.  Count the number of divisors occurring within the integer.  

Note: Each digit is considered to be unique, so each occurrence of the same digit should be counted (e.g. for [expression]).

Function Description

Complete the findDigits function in the editor below.  It should return an integer representing the number of digits of [expression].  

findDigits has the following parameter(s):


n: an integer to analyze

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

     public static void main(String[] args){
        int t;
        Scanner scan = new Scanner(System.in);
        
        t = scan.nextInt();
        
        for(int i = 0; i &lt; t; i++){
            System.out.println(digits(scan.next()));
        }
        
        scan.close();
    }

    private static int digits(String number) {
       
       int sum = 0;
       char[] digits = number.toCharArray();
      
       for(int i = 0; i &lt; number.length(); i++){
            if(Character.getNumericValue(digits[i]) != 0){ 
                if(((Integer.parseInt(number))% (Character.getNumericValue(digits[i]))) == 0){
                    sum++;
                }
            }
            else
                continue;
       }
           
        return sum;
    }
}
----------
====================
----------
ALGORITHMS.40
medium
----------
PROBLEM STATEMENT:
The factorial of the integer [expression], is defined as:   

[expression]

Calculate and print the factorial of a given integer.  

For example, if [expression].

Function Description

Complete the extraLongFactorials function in the editor below.  It should print the result and return.  

extraLongFactorials has the following parameter(s):  


n: an integer


Note: Factorials of [expression] long long variable. Big integers must be used for such calculations. Languages like Java, Python, Ruby etc. can handle big integers, but we need to write additional code in C/C++ to handle huge values.  

We recommend solving this challenge using BigIntegers.  
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
    
    static BigInteger factorial(int n){
        BigInteger product=BigInteger.ONE;
        for(int i=2; i&lt;=n; i++){
            product= product.multiply(BigInteger.valueOf(i));
        }
        return product;
    }
    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc=new Scanner(System.in);
        System.out.println(factorial(sc.nextInt()));
    }
}
----------
====================
----------
ALGORITHMS.41
easy
----------
PROBLEM STATEMENT:
You have a string of lowercase English alphabetic letters. You can perform two types of operations on the string:


Append a lowercase English alphabetic letter to the end of the string.
Delete the last character in the string. Performing this operation on an empty string results in an empty string.


Given an integer, [expression]. If it's possible, print Yes.  Otherwise, print No.

For example, strings [expression] moves, we would not have succeeded in creating the new string.  

Function Description  

Complete the appendAndDelete function in the editor below.  It should return a string, either Yes or No.  

appendAndDelete has the following parameter(s):  


s: the initial string  
t: the desired string  
k: an integer that represents the number of operations  

----------
TOP SOLUTION:
----------

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
    string s, t;
    cin &gt;&gt; s &gt;&gt; t;
    int k;
    cin &gt;&gt; k;
    
    int i = 0, j = 0;
    for (; i &lt; (int)s.size() &amp;&amp; j &lt; (int)t.size(); ++i,++j) {
        if (s[i] != t[j])
            break;
    }
    
    int need = ((int)s.size() - i) + ((int)t.size() - j);
    if ((need &lt;= k &amp;&amp; (k-need) % 2 == 0) || k &gt;= (int)s.size() + (int)t.size()) {
        cout &lt;&lt; "Yes";
    } else {
        cout &lt;&lt; "No";
    }
    
    

    return 0;
}

----------
====================
----------
ALGORITHMS.42
easy
----------
PROBLEM STATEMENT:
Watson likes to challenge Sherlock's math ability.  He will provide a starting and ending value describing a range of integers.  Sherlock must determine the number of square integers within that range, inclusive of the endpoints.

Note: A square integer is an integer which is the square of an integer, e.g. [expression]. 

For example, the range is [expression].  

Function Description

Complete the squares function in the editor below.  It should return an integer representing the number of square integers in the inclusive range from [expression].  

squares has the following parameter(s):  


a: an integer, the lower range boundary
b: an integer, the uppere range boundary 

----------
TOP SOLUTION:
----------
#!/usr/bin/env python

import sys


if __name__ == '__main__':
    T = int(sys.stdin.readline())
    
    for _ in range(T):
        A, B = list(map(int, sys.stdin.readline().split()))

        nA = int(A**0.5)
        nB = int(B**0.5)
        
        ans = int(B**0.5) - int(A**0.5)
        if nA**2 == A:
        	ans += 1
        
        print(ans)
----------
====================
----------
ALGORITHMS.43
easy
----------
PROBLEM STATEMENT:
Your local library needs your help! Given the expected and actual return dates for a library book, create a program that calculates the fine (if any). The fee structure is as follows: 


If the book is returned on or before the expected return date, no fine will be charged (i.e.: [expression].
If the book is returned after the expected return day but still within the same calendar month and year as the expected return date, [expression]. 
If the book is returned after the expected return month but still within the same calendar year as the expected return date, the [expression].   
If the book is returned after the calendar year in which it was expected, there is a fixed fine of [expression].


Charges are based only on the least precise measure of lateness.  For example, whether a book is due January 1, 2017 or December 31, 2017, if it is returned January 1, 2018, that is a year late and the fine would be [expression].  

Function Description  

Complete the libraryFine function in the editor below.  It must return an integer representing the fine due.  

libraryFine has the following parameter(s):  


d1, m1, y1: returned date day, month and year  
d2, m2, y2: due date day, month and year  

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int rtday = in.nextInt();
        int rtmonth = in.nextInt();
        int rtyear = in.nextInt();
        int dueday = in.nextInt();
        int duemonth = in.nextInt();
        int dueyear = in.nextInt();
        int fine = 0;
        if(rtyear &gt; dueyear)
            fine = 10000;
        else if(rtyear == dueyear){
            if(rtmonth &gt; duemonth)
                fine = 500 * (rtmonth - duemonth);
            else if(rtmonth == duemonth){
                if(rtday &gt; dueday)
                    fine = 15 * (rtday - dueday);
            }
        }
        System.out.println(fine);
    }
}
----------
====================
----------
ALGORITHMS.44
easy
----------
PROBLEM STATEMENT:
You are given a number of sticks of varying lengths.  You will iteratively cut the sticks into smaller sticks, discarding the shortest pieces until there are none left.  At each iteration you will determine the length of the shortest stick remaining, cut that length from each of the longer sticks and then discard all the pieces of that shortest length.  When all the remaining sticks are the same length, they cannot be shortened so discard them.

Given the lengths of [expression] sticks, print the number of sticks that are left before each iteration until there are none left.

For example, there are [expression].  

Function Description  

Complete the cutTheSticks function in the editor below.  It should return an array of integers representing the number of sticks before each cut operation is performed.  

cutTheSticks has the following parameter(s):  


arr: an array of integers representing the length of each stick  


Input Format  

The first line contains a single integer [expression]. 
The next line contains [expression] stick.

Output Format  

For each operation, print the number of sticks that are present before the operation on separate lines.  

Constraints  


[expression]
[expression]


Sample Input 0

6
5 4 4 2 2 8


Sample Output 0

6
4
2
1


Explanation 0

[expression]sticks-length        length-of-cut   sticks-cut
5 4 4 2 2 8             2               6
3 2 2 _ _ 6             2               4
1 _ _ _ _ 4             1               2
_ _ _ _ _ 3             3               1
_ _ _ _ _ _           DONE            DONE



Sample Input 1

8
1 2 3 4 3 3 2 1


Sample Output 1

8
6
4
1


Explanation 1

[expression]sticks-length         length-of-cut   sticks-cut
1 2 3 4 3 3 2 1         1               8
_ 1 2 3 2 2 1 _         1               6
_ _ 1 2 1 1 _ _         1               4
_ _ _ 1 _ _ _ _         1               1
_ _ _ _ _ _ _ _       DONE            DONE


----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class Solution {

	static void solve() throws IOException {
		int n = nextInt();
		int[] a = new int[n];
		for (int i = 0; i &lt; n; i++) {
			a[i] = nextInt();
		}
		Arrays.sort(a);
		for (int i = 0; i &lt; n;) {
			int j = i;
			while (j &lt; n &amp;&amp; a[j] == a[i]) {
				j++;
			}
			out.println(n - i);
			i = j;
		}
	}

	static BufferedReader br;
	static StringTokenizer st;
	static PrintWriter out;

	public static void main(String[] args) throws IOException {
		InputStream input = System.in;
		PrintStream output = System.out;
		br = new BufferedReader(new InputStreamReader(input));
		out = new PrintWriter(output);
		solve();
		out.close();
	}

	static long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	static double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	static int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	static String nextToken() throws IOException {
		while (st == null || !st.hasMoreTokens()) {
			String line = br.readLine();
			if (line == null) {
				return null;
			}
			st = new StringTokenizer(line);
		}
		return st.nextToken();
	}
}

----------
====================
----------
ALGORITHMS.45
medium
----------
PROBLEM STATEMENT:
Given a set of distinct integers, print the size of a maximal subset of [expression].

For example, the array [expression] elements.  

Function Description  

Complete the nonDivisibleSubset function in the editor below.  It should return an integer representing the length of the longest subset of [expression] meeting the criteria.  

nonDivisibleSubset has the following parameter(s):  


S: an array of integers  
k: an integer  

----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define FOR(i,a,b) for(int i = (a); i &lt;= (b); ++i)
#define FORD(i,a,b) for(int i = (a); i &gt;= (b); --i)
#define RI(i,n) FOR(i,1,(n))
#define REP(i,n) FOR(i,0,(n)-1)
#define mini(a,b) a=min(a,b)
#define maxi(a,b) a=max(a,b)
#define mp make_pair
#define pb push_back
#define st first
#define nd second
#define sz(w) (int) w.size()
typedef vector&lt;int&gt; vi;
typedef long long ll;
typedef long double ld;
typedef pair&lt;int,int&gt; pii;
const int inf = 1e9 + 5;
const int nax = 1e6 + 5;

int t[nax];
int main() {
	
	int n, k;
	scanf("%d%d", &amp;n, &amp;k);
	REP(_, n) {
		int a;
		scanf("%d", &amp;a);
		++t[a%k];
	}
	int s = 0;
	s += min(t[0], 1);
	RI(i, k-1) {
		int j = k-i;
		if(j &lt; i) break;
		if(i == j) s+= min(t[i], 1);
		else s += max(t[i], t[j]);
	}
	printf("%d\n", s);
	
	return 0;
}

----------
====================
----------
ALGORITHMS.46
easy
----------
PROBLEM STATEMENT:
Lilah has a string, [expression], of lowercase English letters that she repeated infinitely many times.

Given an integer, [expression] letters of Lilah's infinite string.

For example, if the string [expression] occurrences of a in the substring.  

Function Description  

Complete the repeatedString function in the editor below.  It should return an integer representing the number of occurrences of a in the prefix of length [expression] in the infinitely repeating string.  

repeatedString has the following parameter(s):  


s: a string to repeat  
n: the number of characters to consider  

----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;
#include &lt;memory.h&gt;
#include &lt;assert.h&gt;

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 350

using namespace std;

const int INF = 1e9;
const int N = 531;

string st;
long long n;
long long res;

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);

	cin &gt;&gt; st;
	cin &gt;&gt; n;

	long long ful = n / st.size();
	int rem = n%st.size();
	for (int i = 0; i &lt; st.size(); i++)
	{
		if (st[i] == 'a')
		{
			res += ful + (i &lt; rem);
		}
	}
	cout &lt;&lt; res &lt;&lt; endl;

	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.47
easy
----------
PROBLEM STATEMENT:
Emma is playing a new mobile game that starts with consecutively numbered clouds.  Some of the clouds are thunderheads and others are cumulus.  She can jump on any cumulus cloud having a number that is equal to the number of the current cloud plus [expression].  She must avoid the thunderheads.  Determine the minimum number of jumps it will take Emma to jump from her starting postion to the last cloud.  It is always possible to win the game.  

For each game, Emma will get an array of clouds numbered [expression].

Function Description  

Complete the jumpingOnClouds function in the editor below.  It should return the minimum number of jumps required, as an integer.  

jumpingOnClouds has the following parameter(s):  


c: an array of binary integers  

----------
TOP SOLUTION:
----------
#!/bin/python3

import sys


n = int(input().strip())
c = [int(c_temp) for c_temp in input().strip().split(' ')]

res = 0
i = 0
while i &lt; n-1:
    if i+2&lt;n and c[i+2] == 0:
        i = i+2
        res += 1
    else:
        i = i+1
        res += 1
print(res)

----------
====================
----------
ALGORITHMS.48
easy
----------
PROBLEM STATEMENT:
Karl has an array of integers.  He wants to reduce the array until all remaining elements are equal.  Determine the minimum number of elements to delete to reach his goal.

For example, if his array is [expression].

Function Description  

Complete the equalizeArray function in the editor below. It must return an integer that denotes the minimum number of deletions required.  

equalizeArray has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;
#include &lt;memory.h&gt;
#include &lt;assert.h&gt;

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 350

using namespace std;

const int INF = 1e9;
const int N = 100031;

int n, cnt[N], ar[N];
int ans;

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);

	cin &gt;&gt; n;
	for (int i = 1; i &lt;= n; i++)
	{
		cin &gt;&gt; ar[i];
		cnt[ar[i]]++;
		ans = max(ans, cnt[ar[i]]);
	}
	cout &lt;&lt; n - ans &lt;&lt; endl;

	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.49
medium
----------
PROBLEM STATEMENT:
You will be given a square chess board with one queen and a number of obstacles placed on it.  Determine how many squares the queen can attack.  

A queen is standing on an [expression], where the square is located.

The queen is standing at position [expression]: 



There are obstacles on the chessboard, each preventing the queen from attacking any square beyond it on that path. For example, an obstacle at location [expression]:



Given the queen's position and the locations of all the obstacles, find and print the number of squares the queen can attack from her position at [expression] such squares.

Function Description  

Complete the queensAttack function in the editor below.  It should return an integer that describes the number of squares the queen can attack.  

queensAttack has the following parameters: 
- n: an integer, the number of rows and columns in the board 
- k: an integer, the number of obstacles on the board 
- r_q: integer, the row number of the queen's position 
- c_q: integer, the column number of the queen's position 
- obstacles: a two dimensional array of integers where each element is an array of [expression] integers, the row and column of an obstacle  
----------
TOP SOLUTION:
----------
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

using namespace std;

// DID YOU FIX GLOBAL STATE

typedef long long ll;
typedef pair&lt;int, int&gt; pii;

const double PI = 2 * acos(0);
const int MOD = 1000000007;
const int HASH = 3137;

int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};

void solve() {
  int n;
  int k;
  scanf("%d%d", &amp;n, &amp;k);
  int x, y;
  scanf("%d%d", &amp;x, &amp;y);
  set&lt;pii&gt; bad;
  while(k--) {
    int xx, yy;
    scanf("%d%d", &amp;xx, &amp;yy);
    bad.insert(pii(xx, yy));
  }
  set&lt;pii&gt; ret;
  for(int k = 0; k &lt; 8; k++) {
    int nx = x + dx[k];
    int ny = y + dy[k];
    while(true) {
      if(min(nx, ny) &lt; 1 || max(nx, ny) &gt; n || bad.count(pii(nx, ny))) {
        break;
      }
      ret.insert(pii(nx, ny));
      nx += dx[k];
      ny += dy[k];
    }
  }
  printf("%d\n", ret.size());
}

int main() {
  solve();
  return 0;
}

----------
====================
----------
ALGORITHMS.50
easy
----------
PROBLEM STATEMENT:
There are a number of people who will be attending ACM-ICPC World Finals. Each of them may be well versed in a number of topics. Given a list of topics known by each attendee, you must determine the maximum number of topics a 2-person team can know. Also find out how many ways a team can be formed to know that many topics.  Lists will be in the form of bit strings, where each string represents an attendee and each position in that string represents a field of knowledge, 1 if its a known field or 0 if not.

For example, given three attendees' data as follows:

10101
11110
00010


These are all possible teams that can be formed:

Members Subjects
(1,2)   [1,2,3,4,5]
(1,3)   [1,3,4,5]
(2,3)   [1,2,3,4]


In this case, the first team will know all 5 subjects.  They are the only team that can be created knowing that many subjects.

Function Description  

Complete the acmTeam function in the editor below.  It should return an integer array with two elements: the maximum number of topics any team can know and the number of teams that can be formed that know that maximum number of topics.  

acmTeam has the following parameter(s):  


topic: a string of binary digits  

----------
TOP SOLUTION:
----------
object Solution{
    def main(args:Array[String]){
        val Array(n, m) = readLine.split(" ").map(_.toInt);
        val ct = new Array[Int](m+1);
        val vs = new Array[String](n);
        for(i &lt;- 1 to n){
            vs(i-1) = readLine;
        }
        var max = 0;
        var maxCt = 0;
        for(i &lt;- 0 until n){
            for(j &lt;- i+1 until n){
                val c = getCt(vs(i), vs(j));
                if(c == max) maxCt += 1;
                else if(c &gt; max){
                    max = c;
                    maxCt = 1;
                }
            }
        }
        println(max);
        println(maxCt);
    }
    
    def getCt(a:String, b:String):Int = {
        var c = 0;
        for(i &lt;- 0 until a.size) if(a.charAt(i) == '1' || b.charAt(i) == '1') c+=1;
        return c;
    }
}
----------
====================
----------
ALGORITHMS.51
easy
----------
PROBLEM STATEMENT:
Taum is planning to celebrate the birthday of his friend, Diksha. There are two types of gifts that Diksha wants from Taum: one is black and the other is white. To make her happy, Taum has to buy [expression] white gifts. 


The cost  of each black gift is [expression] units.  
The cost of every white gift is [expression] units.  
The cost of converting each black gift into white gift or vice versa is [expression] units.  


Help Taum by deducing the minimum amount he needs to spend on Diksha's gifts.  

For example, if Taum wants to buy [expression].  

Function Description  

Complete the function taumBday in the editor below.  It should return the minimal cost of obtaining the desired gifts.  

taumBday has the following parameter(s):  


b: the number of black gifts  
w: the number of white gifts  
bc: the cost of a black gift  
wc: the cost of a white gift  
z: the cost to convert one color gift to the other color  

----------
TOP SOLUTION:
----------
(* Enter your code here. Read input from STDIN. Print output to STDOUT *)
Type              
    TPair = Record
        QuantityB:  Longword;
        QuantityW:  Longword;
        CostB:      Longword; 
        CostW:      Longword; 
        CostConvert:Longword;         
                End;

Var
Cases:byte;
Pair:TPair;
i:Integer;
minBCost:LongWord;
minWCost:LongWord;

Begin
Readln(Cases);

For i := 1 To cases Do
Begin
    Readln(Pair.QuantityB,Pair.QuantityW);   
    Readln(Pair.CostB, Pair.CostW, Pair.CostConvert);
    minBCost := 0;
    minWCost := 0;
    
    if ((Pair.CostConvert + Pair.CostB) &lt; Pair.CostW) then
        minWCost := (Pair.CostConvert + Pair.CostB) 
    else
        minWCost := Pair.CostW;
        
    if ((Pair.CostConvert + Pair.CostW) &lt; Pair.CostB) then
        minBCost := (Pair.CostConvert + Pair.CostW) 
    else
        minBCost := Pair.CostB;        

    writeln((Pair.QuantityB * minBCost) + (Pair.QuantityW * minWCost));

End;      
End.
----------
====================
----------
ALGORITHMS.52
medium
----------
PROBLEM STATEMENT:
David has several containers, each with a number of balls in it.  He has just enough containers to sort each type of ball he has into its own container.  David wants to sort the balls using his sort method.

As an example, David has [expression]:



In a single operation, David can swap two balls located in different containers.

The diagram below depicts a single swap operation:



David wants to perform some number of swap operations such that:


Each container contains only balls of the same type.
No two balls of the same type are located in different containers.


You must perform [expression]. For each query, print Possible on a new line if David can satisfy the conditions above for the given matrix.  Otherwise, print Impossible.  

Function Description  

Complete the organizingContainers function in the editor below.  It should return a string, either Possible or Impossible.  

organizingContainers has the following parameter(s):  


containter: a two dimensional array of integers that represent the number of balls of each color in each container  

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int q = in.nextInt();
        for(int a0 = 0; a0 &lt; q; a0++){
            int n = in.nextInt();
            int[][] M = new int[n][n];
            for(int M_i=0; M_i &lt; n; M_i++){
                for(int M_j=0; M_j &lt; n; M_j++){
                    M[M_i][M_j] = in.nextInt();
                }
            }
            int[] rt = new int[n];
            int[] ct = new int[n];
            for (int i = 0; i &lt; n; i++) {
                for (int j = 0; j &lt; n; j++) {
                    rt[i] += M[i][j];
                    ct[j] += M[i][j];
                }
            }
            Arrays.sort(rt);
            Arrays.sort(ct);
            String ans = "Possible";
            for (int i = 0; i &lt; n; i++) {
                if (rt[i] != ct[i])
                    ans = "Impossible";
            }
            System.out.println(ans);
        }
    }
}

----------
====================
----------
ALGORITHMS.53
medium
----------
PROBLEM STATEMENT:
An English text needs to be encrypted using the following encryption scheme. 
First, the spaces are removed from the text. Let [expression] be the length of this text. 
Then, characters are written into a grid, whose rows and columns have the following constraints:

[expression] 

For example, the sentence [expression], so it is written in the form of a grid with 7 rows and 8 columns. 

ifmanwas  
meanttos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  
tayonthe  
groundgo  
dwouldha  
vegivenu  
sroots



Ensure that [expression]   
If multiple grids satisfy the above conditions, choose the one with the minimum area, i.e. [expression].  


The encoded message is obtained by displaying the characters in a column, inserting a space, and then displaying the next column and inserting a space, and so on. For example, the encoded message for the above rectangle is:  

imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn sseoau  

You will be given a message to encode and print.

Function Description  

Complete the encryption function in the editor below.  It should return a single string composed as described.  

encryption has the following parameter(s):  


s: a string to encrypt  

----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

#define MAXN 1000
char str[MAXN];
char res[MAXN][MAXN];
int gr,gc;
int r,c;

int main(){
   scanf("%s",str);
   int len = strlen(str); int DIFF = 1&lt;&lt;20; int AREA = 1&lt;&lt;20;
   for(int i=1; i&lt;=100; ++i) {
     if(i*i&gt;=len) {
         r = i; c = i; break;
     }     
     if(i*(i+1)&gt;=len){
         r = i; c = i+1; break;
     }
   }
   int id = 0;
   for(int i=0; i&lt;MAXN; ++i) for(int j=0; j&lt;MAXN; ++j) res[i][j] = '\0';
   for(int i=0; i&lt;r; ++i) for(int j=0; j&lt;c; ++j) res[i][j] = str[id++];
   for(int i=0; i&lt;c; ++i) {
      for(int j=0; res[j][i]!='\0'; ++j) printf("%c",res[j][i]);
      printf(" ");
   } 
   
   return 0;
}

----------
====================
----------
ALGORITHMS.54
medium
----------
PROBLEM STATEMENT:
Lexicographical order is often known as alphabetical order when dealing with strings.  A string is greater than another string if it comes later in a lexicographically sorted list.

Given a word, create a new word by swapping some or all of its characters.  This new word must meet two criteria:


It must be greater than the original word
It must be the smallest word that meets the first condition


For example, given the word [expression].  

Complete the function biggerIsGreater below to create and return the new string meeting the criteria.  If it is not possible, return no answer.

Function Description  

Complete the biggerIsGreater function in the editor below.  It should return the smallest lexicographically higher string possible from the given string or no answer.  

biggerIsGreater has the following parameter(s):  


w: a string

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

 string s;

int main() {
    int tc;
    scanf("%d", &amp;tc);
    while (tc--) {
        cin &gt;&gt; s;
        if (next_permutation(s.begin(), s.end())) printf("%s\n", s.c_str());
        else printf("no answer\n");
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.55
easy
----------
PROBLEM STATEMENT:
A modified Kaprekar number is a positive whole number with a special property.  If you square it, then split the number into two integers and sum those integers, you have the same value you started with.

Consider a positive whole number [expression].

For example, if [expression]. 

Note: r may have leading zeros.  

Here's an explanation from Wikipedia about the ORIGINAL Kaprekar Number (spot the difference!):  


  In mathematics, a Kaprekar number for a given base is a non-negative integer, the representation of whose square in that base can be split into two parts that add up to the original number again. For instance, 45 is a Kaprekar number, because 45² = 2025 and 20+25 = 45.


Given two positive integers [expression], inclusive.

Function Description  

Complete the kaprekarNumbers function in the editor below.  It should print the list of modified Kaprekar numbers in ascending order.  

kaprekarNumbers has the following parameter(s):  


p: an integer   
q: an integer   

----------
TOP SOLUTION:
----------
# Enter your code here. Read input from STDIN. Print output to STDOUT

def isGood(x):
    if x &lt;= 3:
        return x == 1
    y = str(x*x)
    d = len(str(x))
    r = int(y[-d:])
    l = int(y[:-d])
    return l+r == x

p = int(raw_input())
q = int(raw_input())

l = []
for i in xrange(p, q+1):
    if isGood(i): l.append(i)

if len(l) == 0:
    print "INVALID RANGE"
else:
    print ' '.join([str(x) for x in l])
----------
====================
----------
ALGORITHMS.56
easy
----------
PROBLEM STATEMENT:
Given a sequence of integers [expression] is beautiful if:


[expression]
[expression]


Given an increasing sequenc of integers and the value of [expression], count the number of beautiful triplets in the sequence.

For example, the sequence [expression].  

Function Description  

Complete the beautifulTriplets function in the editor below.  It must return an integer that represents the number of beautiful triplets in the sequence.  

beautifulTriplets has the following parameters:  


d: an integer  
arr: an array of integers, sorted ascending  

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;bitset&gt;
#define _USE_MATH_DEFINES
#include &lt;math.h&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;algorithm&gt;
#include &lt;assert.h&gt;
using namespace std;

void smain();
int main(){
#ifdef TASK
    freopen(TASK".in","rt",stdin);
    const clock_t start = clock();
#endif
    smain();
#ifdef TASK
    cerr &lt;&lt; "\nTotal Execution Time: " &lt;&lt; float( clock () - start ) /  CLOCKS_PER_SEC &lt;&lt; endl;
#endif
    return 0;
}

#ifndef M_PI
#define M_PI 3.14159265358979311599796346854418516
#endif
#define forn(i,n) for (int i=0;i&lt;n;i++)
#define rforn(i,n) for (int i=n-1;i&gt;=0;i--)
#define int long long
#define LL __int128
#define mp(a,b) make_pair(a,b)
#define INF 2305843009213693951LL
#define MOD 1000000007
#define EPS 1E-6
#define N 200001
/* --------- END TEMPLATE CODE --------- */
int n, d;
int a[N];


void smain() {
    for (; cin &gt;&gt; n &gt;&gt; d; ) {
        forn(i, n) cin &gt;&gt; a[i];
        int res = 0;
        map&lt;int, int&gt; l, r;
        forn(i, n) r[a[i]] += 1;
        forn(i, n) {
            r[a[i]] -= 1;
            res += l[a[i]-d] * r[a[i]+d];
            l[a[i]] += 1;
        }
        cout &lt;&lt; res &lt;&lt; '\n';
    }
}

----------
====================
----------
ALGORITHMS.57
easy
----------
PROBLEM STATEMENT:
We define the distance between two array values as the number of indices between the two values.  Given [expression].

For example, if [expression].

Function Description  

Complete the minimumDistances function in the editor below.  It should return the minimum distance between any two matching elements.  

minimumDistances has the following parameter(s):  


a: an array of integers  

----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define FOR(i,a,b) for(int i = (a); i &lt;= (b); ++i)
#define FORD(i,a,b) for(int i = (a); i &gt;= (b); --i)
#define RI(i,n) FOR(i,1,(n))
#define REP(i,n) FOR(i,0,(n)-1)
#define mini(a,b) a=min(a,b)
#define maxi(a,b) a=max(a,b)
#define mp make_pair
#define pb push_back
#define st first
#define nd second
#define sz(w) (int) w.size()
typedef vector&lt;int&gt; vi;
typedef long long ll;
typedef long double ld;
typedef pair&lt;int,int&gt; pii;
const int inf = 1e9 + 5;
const int nax = 1e6 + 5;

int t[nax];

int main() {
	int n;
	scanf("%d", &amp;n);
	int ans = inf;
	REP(i, n) scanf("%d", &amp;t[i]);
	REP(i, n) REP(j, i) if(t[i] == t[j]) mini(ans, abs(i-j));
	if(ans == inf) ans = -1;
	printf("%d\n", ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.58
easy
----------
PROBLEM STATEMENT:
You wish to buy video games from the famous online video game store Mist.

Usually, all games are sold at the same price, [expression] dollars each.

For example, if [expression] games you buy, in order:

[expression]

You have [expression] dollars in your Mist wallet. How many games can you buy during the Halloween Sale?
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    int p, d, m, s;
    cin &gt;&gt; p &gt;&gt; d &gt;&gt; m &gt;&gt; s;
    int nr = 0;
    while(p &lt;= s){
        s -= p;
        ++nr;
        p -= d;
        if(p &lt; m) p = m;
    }
    cout &lt;&lt; nr &lt;&lt; endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.59
medium
----------
PROBLEM STATEMENT:
Given the time in numerals we may convert it into words, as shown below:  

[expression]

At [expression] use to.  Note the space between the apostrophe and clock in o' clock.  Write a program which prints the time in words for the input given in the format described.  

Function Description  

Complete the timeInWords function in the editor below.  It should return a time string as described.  

timeInWords has the following parameter(s):  


h: an integer representing hour of the day  
m: an integer representing minutes after the hour   

----------
TOP SOLUTION:
----------
# Enter your code here. Read input from STDIN. Print output to STDOUT
H = int(raw_input())
M = int(raw_input())

def word(x):
    unit = ["", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"]
    dec = ["", "ten", "twenty", "thirty", "forty", "fifty"]
    if x &lt; 20:
        return unit[x]
    return dec[x/10] + " " + unit[x%10]

def minu(x):
    w = word(x)
    if x == 1: return w + " minute"
    else: return w + " minutes"

if M == 0:
    print "{} o' clock".format(word(H))
elif M == 15:
    print "quarter past {}".format(word(H))
elif M == 45:
    print "quarter to {}".format(word(H+1))
elif M == 30:
    print "half past {}".format(word(H))
elif M &lt; 30:
    print "{} past {}".format(minu(M), word(H))
else:
    print "{} to {}".format(minu(60-M), word(H+1))
----------
====================
----------
ALGORITHMS.60
easy
----------
PROBLEM STATEMENT:
Little Bobby loves chocolate.  He frequently goes to his favorite [expression] store, Penny Auntie, to buy them.  They are having a promotion at Penny Auntie.  If Bobby saves enough wrappers, he can turn them in for a free chocolate.  

For example, Bobby has [expression] bars.    

Function Description   

Complete the chocolateFeast function in the editor below.  It must return the number of chocolates Bobby can eat after taking full advantage of the promotion.

chocolateFeast has the following parameter(s):  


n: an integer representing Bobby's initial amount of money  
c: an integer representing the cost of a chocolate bar  
m: an integer representing the number of wrappers he can turn in for a free bar  


Note: Little Bobby will always turn in his wrappers if he has enough to get a free chocolate.
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int t,n,c,m;
    cin&gt;&gt;t;
    while(t--){
        cin&gt;&gt;n&gt;&gt;c&gt;&gt;m;
        int ans=0;
        ans+=n/c;
        int x=n/c;
        while(x&gt;=m){
            ans+=x/m;
            x=x/m+x%m;
        }
        cout&lt;&lt;ans&lt;&lt;endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.61
easy
----------
PROBLEM STATEMENT:
Calvin is driving his favorite vehicle on the 101 freeway. He notices that the check engine light of his vehicle is on, and he wants to service it immediately to avoid any risks. Luckily, a service lane runs parallel to the highway. The service lane varies in width along its length.



You will be given an array of widths at points along the road (indices), then a list of the indices of entry and exit points. Considering each entry and exit point pair, calculate the maximum size vehicle that can travel that segment of the service lane safely.

For example, there are [expression].  

Function Description  

Complete the serviceLane function in the editor below.  It should return an array of integers representing the maximum width vehicle that can pass through each segment of the highway described.  

serviceLane has the following parameter(s):  


n: an integer denoting the size of the [expression] array
cases: a two dimensional array of integers where each element is an array of two integers representing starting and ending indices for a segment to consider . 

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    int n, t;
    cin &gt;&gt; n &gt;&gt; t;
    int width[n];
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; width[i];
    for(int qq = 0; qq &lt; t; qq++){
        int i, j;
        cin &gt;&gt; i &gt;&gt; j;
        int m = 3;
        for(int k = i; k &lt;= j; k++){
            m = min(m, width[k]);
        }
        cout &lt;&lt; m &lt;&lt; endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.62
easy
----------
PROBLEM STATEMENT:
Lisa just got a new math workbook.  A workbook contains exercise problems, grouped into chapters.  Lisa believes a problem to be special if its index (within a chapter) is the same as the page number where it's located.  The format of Lisa's book is as follows:


There are [expression].
The [expression].
Each page can hold up to [expression] problems.
Each new chapter starts on a new page, so a page will never contain problems from more than one chapter.
The page number indexing starts at [expression].


Given the details for Lisa's workbook, can you count its number of special problems?

For example, Lisa's workbook contains [expression] special problem in her workbook.

Note: See the diagram in the Explanation section for more details.  

Function Description  

Complete the workbook function in the editor below.  It should return an integer that represents the number of special problems in the workbook.  

workbook has the following parameter(s):  


n: an integer that denotes the number of chapters  
k: an integer that denotes the maximum number of problems per page  
arr: an array of integers that denote the number of problems in each chapter  

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class A {

	BufferedReader br;
	PrintWriter out;
	StringTokenizer st;
	boolean eof;

	void solve() throws IOException {
		int n = nextInt();
		int k = nextInt();
		int ans = 0;
		for (int i = 0, page = 1; i &lt; n; i++) {
			int x = nextInt();
			for (int j = 1; j &lt;= x; j++) {
				if (j == page + (j - 1) / k) {
					ans++;
				}
			}
			page += (x + k - 1) / k;
		}
		out.println(ans);
	}

	A() throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		solve();
		out.close();
	}

	public static void main(String[] args) throws IOException {
		new A();
	}

	String nextToken() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception e) {
				eof = true;
				return null;
			}
		}
		return st.nextToken();
	}

	String nextString() {
		try {
			return br.readLine();
		} catch (IOException e) {
			eof = true;
			return null;
		}
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
}
----------
====================
----------
ALGORITHMS.63
easy
----------
PROBLEM STATEMENT:
Flatland is a country with a number of cities, some of which have space stations.  Cities are numbered consecutively and each has a road of [expression] length connecting it to the next city.  It is not a circular route, so the first city doesn't connect with the last city.  Determine the maximum distance from any city to it's nearest space station.

For example, there are [expression].

Function Description  

Complete the flatlandSpaceStations function in the editor below.  It should return an integer that represents the maximum distance any city is from a space station.  

flatlandSpaceStations has the following parameter(s):  


n: the number of cities  
c: an integer array that contains the indices of cities with a space station, [expression]-based indexing  

----------
TOP SOLUTION:
----------
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;limits&gt;
#include &lt;functional&gt;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus &gt; 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; inline void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; inline void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

int main() {
	int n; int m;
	while(~scanf("%d%d", &amp;n, &amp;m)) {
		vector&lt;bool&gt; ok(n);
		for(int i = 0; i &lt; m; ++ i) {
			int c;
			scanf("%d", &amp;c);
			ok[c] = true;
		}
		vi dist(n, INF);
		int p = -INF;
		rep(i, n) {
			if(ok[i]) p = i;
			amin(dist[i], i - p);
		}
		p = INF;
		for(int i = n - 1; i &gt;= 0; -- i) {
			if(ok[i]) p = i;
			amin(dist[i], p - i);
		}
		int ans = *max_element(all(dist));
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.64
easy
----------
PROBLEM STATEMENT:
You are the benevolent ruler of Rankhacker Castle, and today you're distributing bread.  Your subjects are in a line, and some of them already have some loaves.  Times are hard and your castle's food stocks are dwindling, so you must distribute as few loaves as possible according to the following rules:


Every time you give a loaf of bread to some person [expression]).    
After all the bread is distributed, each person must have an even number of loaves.


Given the number of loaves already held by each citizen, find and print the minimum number of loaves you must distribute to satisfy the two rules above. If this is not possible, print NO.

For example, the people in line have loaves [expression] loaves.  

Function Description  

Complete the fairRations function in the editor below.  It should return an integer that represents the minimum number of loaves required.  

fairRations has the following parameter(s):  


B: an array of integers that represent the number of loaves each persons starts with . 

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

#define pb push_back
#define mp make_pair
#define REP(i, n) for (int i = 0; i &lt; (int)(n); ++i)
typedef long long LL;
typedef pair&lt;int, int&gt; PII;

int n;
int a[1111];

int main() {
    scanf("%d", &amp;n);
    REP(i, n) scanf("%d", a + i);
    int ans = 0;
    REP(i, n - 1) if (a[i] % 2 == 1) {
        ++a[i];
        ++a[i + 1];
        ans += 2;
    }
    if (a[n - 1] % 2 == 1) {
        printf("NO\n");
        return 0;
    }
    printf("%d\n", ans);
    return 0;
}

----------
====================
----------
ALGORITHMS.65
easy
----------
PROBLEM STATEMENT:
You are given a square map as a matrix of integer strings. Each cell of the map has a value denoting its depth. We will call a cell of the map a cavity if and only if this cell is not on the border of the map and each cell adjacent to it has strictly smaller depth. Two cells are adjacent if they have a common side, or edge.

Find all the cavities on the map and replace their depths with the uppercase character X.  

For example, given a matrix:

989
191
111


You should return:

989
1X1
111


The center cell was deeper than those on its edges: [8,1,1,1].  The deep cells in the top two corners don't share an edge with the center cell.  

Function Description  

Complete the cavityMap function in the editor below.  It should return an array of strings, each representing a line of the completed map.  

cavityMap has the following parameter(s):  


grid: an array of strings, each representing a row of the grid  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

int N;
char grid[101][101];
char grid2[101][101];

int main()
{
    scanf("%d\n", &amp;N);
    for(int i=0; i&lt;N; i++)
        gets(grid[i]);
    memcpy(grid2, grid, sizeof grid2);
    for(int i=1; i&lt;N-1; i++)
        for(int j=1; j&lt;N-1; j++)
            if(grid[i][j]&gt;grid[i+1][j])
            if(grid[i][j]&gt;grid[i-1][j])
            if(grid[i][j]&gt;grid[i][j+1])
            if(grid[i][j]&gt;grid[i][j-1])
                grid2[i][j]='X';
    for(int i=0; i&lt;N; i++)
        puts(grid2[i]);
    return 0;
}

----------
====================
----------
ALGORITHMS.66
easy
----------
PROBLEM STATEMENT:
Manasa is out on a hike with friends. She finds a trail of stones with numbers on them. She starts following the trail and notices that any two consecutive stones' numbers differ by one of two values.  Legend has it that there is a treasure trove at the end of the trail.  If Manasa can guess the value of the last stone, the treasure will be hers.

For example, assume she finds [expression] on its face. 

Compute all possible numbers that might occur on the last stone given a starting stone with a [expression] on it, a number of additional stones found, and the possible differences between consecutive stones.  Order the list ascending.

Function Description

Complete the stones function in the editor below.  It should return an array of integers representing all possible values of the last stone, sorted ascending.  

stones has the following parameter(s):  


n: an integer, the number of non-zero stones  
a: one possible integer difference  
b: another possible integer difference  

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;set&gt;

using namespace std;

int main() {
  int nTests = 0; cin &gt;&gt; nTests;
  while (nTests--) {
    int n = 0; int a = 0; int b = 0;
    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;
    set&lt;int&gt; s;
    for (int i = 0; i &lt;= n - 1; ++i) {
      s.insert(i * a + (n - 1 - i) * b);
    }
    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); ++it) {
      if (it != s.begin()) cout &lt;&lt; " ";
      cout &lt;&lt; *it;
    }
    cout &lt;&lt; "\n";
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.67
medium
----------
PROBLEM STATEMENT:
Given a 2D array of digits or grid, try to find the occurrence of a given 2D pattern of digits. For example, consider the following grid:  

1234567890  
0987654321  
1111111111  
1111111111  
2222222222  


Assume we need to look for the following 2D pattern array:  

876543  
111111  
111111
  

The 2D pattern begins at the second row and the third column of the grid.  The pattern is said to be present in the grid.  

Function Description  

Complete the gridSearch function in the editor below.  It should return YES if the pattern exists in the grid, or NO otherwise.  

gridSearch has the following parameter(s):  


G: the grid to search, an array of strings  
P: the pattern to search for, an array of strings  

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
using namespace std;
typedef unsigned int LL;

struct MatHash {
    typedef unsigned int LL;
    #define MAXN 1001
    #define MAXM 1001
    #define TIME 2
    static LL P[TIME], Q[TIME], MOD[TIME];
    static LL powerP[TIME][MAXN], powerQ[TIME][MAXM];

    int n, m;
    int mat[MAXN][MAXM];

    LL h[TIME][MAXN][MAXM];//???hash?

    static void init(int id) {
        powerP[id][0] = 1;
        for (int i = 1; i &lt; MAXN; i++) {
            powerP[id][i] = (powerP[id][i - 1] * P[id]);
        }
        powerQ[id][0] = 1;
        for (int i = 1; i &lt; MAXM; i++) {
            powerQ[id][i] = (powerQ[id][i - 1] * Q[id]);
        }
    }

    void inithash(int id) {
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; m; j++) {

                h[id][i][j] = (mat[i][j] + 3) * powerP[id][n - 1 - i] * powerQ[id][m - 1 - j];
                if (i) h[id][i][j] = (h[id][i][j] + h[id][i - 1][j]);
                if (j) h[id][i][j] = (h[id][i][j] + h[id][i][j - 1]);
                if (i &amp;&amp; j) h[id][i][j] = (h[id][i][j] - h[id][i - 1][j - 1]);
            }
        }
    }

    LL gethash(int x1, int y1, int x2, int y2, int id) {
        LL ret = h[id][x2][y2];
        if (x1) ret = (ret - h[id][x1 - 1][y2]);
        if (y1) ret = (ret - h[id][x2][y1 - 1]);
        if (x1 &amp;&amp; y1) ret = (ret + h[id][x1 - 1][y1 - 1]);
        ret = (ret * powerP[id][x1]);
        ret = (ret * powerQ[id][y1]);
        return ret;
    }

    LL resize(int x1, int y1, int x2, int y2, int id, int _n, int _m) {
        LL ret = gethash(x1, y1, x2, y2, id);
        ret = ret * powerP[id][_n - n] * powerQ[id][_m - m];
        return ret;
    }

    void input() {
        for (int i = 0; i &lt; n; i++) {
            getchar();
            for (int j = 0; j &lt; m; j++) {
                mat[i][j] = getchar() - '0';
            }
        }
    }
}A, B;

LL MatHash::P[TIME], MatHash::Q[TIME], MatHash::MOD[TIME];
LL MatHash::powerP[TIME][MAXN], MatHash::powerQ[TIME][MAXM];

int main() {
    MatHash::P[0] = 393241, MatHash::Q[0] = 784633, MatHash::MOD[0] = 805306457;
    MatHash::P[1] = 784633, MatHash::Q[1] = 111117, MatHash::MOD[1] = 402653189;
    for (int i = 0; i &lt; TIME; i++) {
        MatHash::init(i);
    }
    int cases;
    scanf("%d", &amp;cases);
    for (int T = 0; T &lt; cases; T++) {
        scanf("%d %d", &amp;A.n, &amp;A.m);
        A.input();
        for (int i = 0; i &lt; TIME; i++) {
            A.inithash(i);
        }
        scanf("%d %d", &amp;B.n, &amp;B.m);
        B.input();
        for (int i = 0; i &lt; TIME; i++) {
            B.inithash(i);
        }
        bool yes = false;
        for (int id = 0; id &lt; TIME; id++) {
            B.inithash(id);
            LL val = B.resize(0, 0, B.n - 1, B.m - 1, id, A.n, A.m);
            for (int i = B.n - 1; i &lt; A.n; i++) {
                for (int j = B.m - 1; j &lt; A.m; j++) {
                    if (A.gethash(i - B.n + 1, j - B.m + 1, i, j, id) == val) {
                        yes = true;
                        break;
                    }
                }
                if (yes) break;
            }
        }
        puts(yes ? "YES" : "NO");
    }
}

----------
====================
----------
ALGORITHMS.68
easy
----------
PROBLEM STATEMENT:
Happy Ladybugs is a board game having the following properties:


The board is represented by a string, [expression] cell of the board.

If [expression] cell of the board is empty.
If [expression].
String [expression] will not contain any other characters.
A ladybug is happy only when its left or right adjacent cell (i.e., [expression]) is occupied by another ladybug having the same color.
In a single move, you can move a ladybug from its current position to any empty cell. 



Given the values of [expression] games of Happy Ladybugs, determine if it's possible to make all the ladybugs happy. For each game, print YES on a new line if all the ladybugs can be made happy through some number of moves.  Otherwise, print NO. 
 
As an example, [expression] and all the ladybugs are happy.  

Function Description  

Complete the happyLadybugs function in the editor below.  It should return an array of strings, either 'YES' or 'NO', one for each test string.  

happyLadybugs has the following parameters:


b: an array of strings that represents the initial positions and colors of the ladybugs  

----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
using namespace std;

#define REP(i, n) for (int i=0, ___=(n); i&lt;___; ++i)
#define FOR(i, a, b) for (int i=(a), ___=(b); i&lt;=___; ++i)
#define FORD(i, a, b) for (int i=(a), ___=(b); i&gt;=___; --i)

int read() { int n; scanf("%d", &amp;n); return n; }
long long readl() { long long n; scanf("%lld", &amp;n); return n; }
double readd() { double d; scanf("%lf", &amp;d); return d; }


///////////////////////////////////////
/// WITHOUT STL

// kopiec

#define HeapT int
#define heapLeft(i) (2*(i)+1)
#define heapRight(i) (2*(i)+2)
#define heapParent(i) (((i)-1)/2)

inline void swap(HeapT &amp;a, HeapT &amp;b) {
	HeapT t = a; a = b; b = t;
}

inline void heapDown(HeapT *h, int a, int n) {
	while (heapLeft(a) &lt; n) {
		int b = heapLeft(a);
		if (b+1 &lt; n &amp;&amp; h[b+1] &gt; h[b]) b++;
		if (h[b] &lt;= h[a]) break;
		swap(h[a], h[b]);
		a = b;
	}
}

inline void heapUp(HeapT *h, int a) {
	while (a &gt; 0) {
		int b = heapParent(a);
		if (h[a] &gt; h[b]) {
			swap(h[a], h[b]);
			a = b;
		}
	}
}

void heapMake(HeapT *h, int n) {
	for (int a=heapParent(n-1); a&gt;=0; --a)
		heapDown(h, a, n);
}

void heapSort(HeapT *h, int n) {
	heapMake(h, n);
	for (int a=n-1; a&gt;0; --a) {
		swap(h[0], h[a]);
		heapDown(h, 0, a);
	}
}



///////////////////////////////////////

bool f() {
	int n = read();
	char s[111];
	scanf("%s", s);
	map&lt;char, int&gt; m;
	REP(i, n) m[s[i]]++;
	if (m.count('_') &gt; 0) {
		FOR(c, 'A', 'Z') if (m[c] == 1) return false;
		return true;
	}
	REP(i, n) {
		bool ok = false;
		if (i-1 &gt;= 0 &amp;&amp; s[i-1] == s[i]) ok = true;
		if (s[i+1] == s[i]) ok = true;
		if (!ok) return false;
	}
	return true;
}

int main() {
	int t = read();
	while (t--) {
		printf("%s\n", f() ? "YES" : "NO");
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.69
easy
----------
PROBLEM STATEMENT:
Bob has a strange counter. At the first second, it displays the number [expression]. 

The counter counts down in cycles. In next second, the timer resets to [expression] in the first three cycles:



Find and print the value displayed by the counter at time [expression].  

Function Description  

Complete the strangeCounter function in the editor below.  It should return the integer value displayed by the counter at time [expression].  

strangeCounter has the following parameter(s):  


t: an integer  

----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;
#include &lt;memory.h&gt;
#include &lt;assert.h&gt;

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1234567891
#define bsize 350

using namespace std;

const int INF = 1e9;
const int N = 200000;

long long n;

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);

	cin &gt;&gt; n;
	long long P = 3;
	while (n &gt; P)
	{
		n -= P;
		P *= 2;
	}
	cout &lt;&lt; P - n + 1 &lt;&lt; endl;

	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.70
medium
----------
PROBLEM STATEMENT:
Madison, is a little girl who is fond of toys. Her friend Mason works in a toy manufacturing factory . Mason has a 2D board [expression]. 

Given the description of the board showing the values of [expression] and that the price of the toy is equal to the 3d surface area find the price of the toy. 


----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;iomanip&gt;
using namespace std;
#define pb push_back
#define mp make_pair
typedef pair&lt;int,int&gt; pii;
typedef long long ll;
typedef double ld;
typedef vector&lt;int&gt; vi;
#define fi first
#define se second
#define fe first
#define FO(x) {freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);}
#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}
#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}
#define es(x,e) (int e=fst[x];e;e=nxt[e])
#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])
#define SZ 666666
int h,w,a[555][555];
int main()
{
	cin&gt;&gt;h&gt;&gt;w;
	for(int i=1;i&lt;=h;++i)
		for(int j=1;j&lt;=w;++j)
			cin&gt;&gt;a[i][j];
	int s=h*w*2;
	for(int i=1;i&lt;=h;++i)
		for(int j=1;j&lt;=w+1;++j)
			s+=abs(a[i][j]-a[i][j-1]);
	for(int i=1;i&lt;=h+1;++i)
		for(int j=1;j&lt;=w;++j)
			s+=abs(a[i][j]-a[i-1][j]);
	cout&lt;&lt;s&lt;&lt;"\n";
}

----------
====================
----------
ALGORITHMS.71
medium
----------
PROBLEM STATEMENT:
We define [expression]-based indexing. 

[expression].

Given [expression].  If no absolute permutation exists, print -1.

For example, let [expression]:  

[expression]
[expression]
[expression]
[expression]
[expression]



Function Description  

Complete the absolutePermutation function in the editor below.  It should return an integer that represents the smallest lexicographically smallest permutation, or [expression] if there is none.  

absolutePermutation has the following parameter(s):  


n: the upper bound of natural numbers to consider, inclusive  
k: the integer difference between each element and its index

----------
TOP SOLUTION:
----------
#include &lt;ios&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;

//1 2 3 4
//2 1 4 3

int arr[100005] = {};

int main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    std::set&lt;int&gt; s;
    int tc, n, k;
    bool fail;
    std::cin &gt;&gt; tc;
    while (tc--)
    {
        fail = false;
        s.clear();
        std::cin &gt;&gt; n &gt;&gt; k;
        for (int i = 0; i &lt; n; i++)
            s.insert(i);
        for (int i = 0; i &lt; n; i++)
        {
            if (s.find(i-k) != s.end())
            {
                arr[i] = i-k;
                s.erase(i-k);
            }
            else if (s.find(i+k) != s.end())
            {
                arr[i] = i+k;
                s.erase(i+k);
            }
            else
            {
                std::cout &lt;&lt; "-1\n";
                fail = true;
                break;
            }
        }
        if (!fail)
        {
            for (int i = 0; i &lt; n; i++)
            {
                if (i != 0) std::cout &lt;&lt; ' ';
                std::cout &lt;&lt; arr[i]+1;
            }
            std::cout &lt;&lt; '\n';
        }
    }
}
----------
====================
----------
ALGORITHMS.72
medium
----------
PROBLEM STATEMENT:
Bomberman lives in a rectangular grid. Each cell in the grid either contains a bomb or nothing at all.

Each bomb can be planted in any cell of the grid but once planted, it will detonate after exactly 3 seconds. Once a bomb detonates, it's destroyed — along with anything in its four neighboring cells. This means that if a bomb detonates in cell [expression] are cleared. If there is a bomb in a neighboring cell, the neighboring bomb is destroyed without detonating, so there's no chain reaction.   

Bomberman is immune to bombs, so he can move freely throughout the grid. Here's what he does:


Initially, Bomberman arbitrarily plants bombs in some of the cells, the initial state.  
After one second, Bomberman does nothing.  
After one more second, Bomberman plants bombs in all cells without bombs, thus filling the whole grid with bombs.  No bombs detonate at this point.
After one more second, any bombs planted exactly three seconds ago will detonate. Here, Bomberman stands back and observes.
Bomberman then repeats steps 3 and 4 indefinitely.  


Note that during every second Bomberman plants bombs, the bombs are planted simultaneously (i.e., at the exact same moment), and any bombs planted at the same time will detonate at the same time.  

Given the initial configuration of the grid with the locations of Bomberman's first batch of planted bombs, determine the state of the grid after [expression] seconds.

For example, if the initial grid looks like:

[expression]
[expression]
[expression]



it looks the same after the first second.  After the second second, Bomberman has placed all his charges:

[expression]
[expression]
[expression]



At the third second, the bomb in the middle blows up, emptying all surrounding cells:

[expression]
[expression]
[expression]



Function Description  

Complete the bomberMan function in the editory below.  It should return an array of strings that represent the grid in its final state.  

bomberMan has the following parameter(s):


n: an integer, the number of seconds to simulate  
grid: an array of strings that represents the grid

----------
TOP SOLUTION:
----------
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.io.*;
import java.math.*;
import java.text.*; 
import java.util.*;
import java.util.regex.*;
/*
      br = new BufferedReader(new FileReader("input.txt"));
      pw = new PrintWriter(new BufferedWriter(new FileWriter("output.txt")));
      br = new BufferedReader(new InputStreamReader(System.in));
      pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
 */


public class Solution {
	private static BufferedReader br;
	private static StringTokenizer st;
	private static PrintWriter pw;

	public static void main(String[] args) throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
		int qq = 1;
		//int qq = Integer.MAX_VALUE;
		//int qq = readInt();
		for(int casenum = 1; casenum &lt;= qq; casenum++) {
			int r = readInt();
			int c = readInt();
			int n = readInt();
			n--;
			int[][] bomb = new int[r][c];
			for(int i = 0; i &lt; r; i++) {
				String s = nextToken();
				for(int j = 0; j &lt; c; j++) {
					if(s.charAt(j) == 'O') {
						bomb[i][j] = 2;
					}
				}
			}
			n %= 100;
			int[] dx = new int[]{-1,1,0,0};
			int[] dy = new int[]{0,0,-1,1};
			for(int i = 1; i &lt;= n; i++) {
				if(i%2 == 1) {
					for(int a = 0; a &lt; r; a++) {
						for(int b = 0; b &lt; c; b++) {
							if(bomb[a][b] == 0) {
								bomb[a][b] = 3;
							}
							else if(bomb[a][b] &gt; 0) {
								bomb[a][b]--;
							}
						}
					}
				}
				else {
					boolean[][] dead = new boolean[r][c];
					for(int a = 0; a &lt; r; a++) {
						for(int b = 0; b &lt; c; b++) {
							if(bomb[a][b] == 1) { 
								dead[a][b] = true;
								for(int k = 0; k &lt; dx.length; k++) {
									int nx = a + dx[k];
									int ny = b + dy[k];
									if(nx &gt;= 0 &amp;&amp; nx &lt; r &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; c) {
										dead[nx][ny] = true;
									}
								}
							}
						}
					}
					for(int a = 0; a &lt; r; a++) {
						for(int b = 0; b &lt; c; b++) {
							if(dead[a][b])
								bomb[a][b] = 0;
							else if(bomb[a][b] &gt; 0) {
								bomb[a][b]--;
							}
						}
					}
				}
			}
			for(int[] out: bomb) {
				for(int out2: out) {
					if(out2 &gt; 0) {
						pw.print('O');
					}
					else {
						pw.print('.');
					}
				}
				pw.println();
			}
		}
		exitImmediately();
	}

	private static void exitImmediately() {
		pw.close();
		System.exit(0);
	}

	private static long readLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	private static double readDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	private static int readInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	private static String nextLine() throws IOException  {
		if(!br.ready()) {
			exitImmediately();
		}
		st = null;
		return br.readLine();
	}

	private static String nextToken() throws IOException  {
		while(st == null || !st.hasMoreTokens())  {
			if(!br.ready()) {
				exitImmediately();
			}
			st = new StringTokenizer(br.readLine().trim());
		}
		return st.nextToken();
	}
}
----------
====================
----------
ALGORITHMS.73
medium
----------
PROBLEM STATEMENT:
Ema built a quantum computer! Help her test its capabilities by solving the problem below.



Given a grid of size [expression].

A valid plus is defined here as the crossing of two segments (horizontal and vertical) of equal lengths. These lengths must be odd, and the middle cell of its horizontal segment must cross the middle cell of its vertical segment. 

In the diagram below, the blue pluses are valid and the orange ones are not valid.


Find the two largest valid pluses that can be drawn on [expression].

Note: The two pluses cannot overlap, and the product of their areas should be maximal.

Function Description  

Complete the twoPluses function in the editor below.  It should return an integer that represents the area of the two largest pluses.

twoPluses has the following parameter(s):  


grid: an array of strings where each string represents a row and each character of the string represents a column of that row  

----------
TOP SOLUTION:
----------
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;limits&gt;
#include &lt;functional&gt;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus &gt; 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; inline void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; inline void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

int main() {
	int N; int M;
	while(~scanf("%d%d", &amp;N, &amp;M)) {
		vector&lt;string&gt; a(N);
		rep(i, N) cin &gt;&gt; a[i];
		int ans = 0;
		rep(y0, N) rep(x0, M) rer(s0, 1, min({ y0 + 1, N - y0, x0 + 1, M - x0 })) {
			vector&lt;vector&lt;bool&gt; &gt; good(N, vector&lt;bool&gt;(M));
			rep(i, N) rep(j, M)
				good[i][j] = a[i][j] == 'G';
			bool ok = true;
			rer(d, -s0 + 1, s0 - 1) {
				ok &amp;= good[y0 + d][x0];
				ok &amp;= good[y0][x0 + d];
				good[y0 + d][x0] = good[y0][x0 + d] = false;
			}
			if(!ok) continue;
			rep(y1, N) rep(x1, M) {
				int maxs1 = min({ y1 + 1, N - y1, x1 + 1, M - x1 });
				int s1 = maxs1;
				rer(d, -maxs1 + 1, maxs1 - 1) {
					if(!good[y1 + d][x1] || !good[y1][x1 + d])
						amin(s1, abs(d) - 1);
				}
				if(s1 &gt; 0)
					amax(ans, ((s0 - 1) * 4 + 1) * ((s1 - 1) * 4 + 1));
			}
		}
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.74
medium
----------
PROBLEM STATEMENT:
Larry has been given a permutation of a sequence of natural numbers incrementing from [expression] as an array.  He must determine whether the array can be sorted using the following operation any number of times:  


Choose any [expression]. 


For example, if [expression]:

[expression] 
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]

[expression]



On a new line for each test case, print YES if [expression] can be fully sorted.  Otherwise, print NO.  

Function Description  

Complete the larrysArray function in the editor below.  It must return a string, either YES or NO.  

larrysArray has the following parameter(s):  


A: an array of integers  

----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;

#define REP(i,a,b) for(i=a;i&lt;b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

#define ll long long
#define ull unsigned ll

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'&lt;=k&amp;&amp;k&lt;='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k&lt;'0'||k&gt;'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'&lt;=k&amp;&amp;k&lt;='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k&lt;'0'||k&gt;'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(double *x){scanf("%lf",x);}
int reader(char c[]){int i,s=0;for(;;){mygc(i);if(i!=' '&amp;&amp;i!='\n'&amp;&amp;i!='\r'&amp;&amp;i!='\t'&amp;&amp;i!=EOF) break;}c[s++]=i;for(;;){mygc(i);if(i==' '||i=='\n'||i=='\r'||i=='\t'||i==EOF) break;c[s++]=i;}c[s]='\0';return s;}
template &lt;class T, class S&gt; void reader(T *x, S *y){reader(x);reader(y);}
template &lt;class T, class S, class U&gt; void reader(T *x, S *y, U *z){reader(x);reader(y);reader(z);}
template &lt;class T, class S, class U, class V&gt; void reader(T *x, S *y, U *z, V *w){reader(x);reader(y);reader(z);reader(w);}

void writer(int x, char c){int s=0,m=0;char f[10];if(x&lt;0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(ll x, char c){int s=0,m=0;char f[20];if(x&lt;0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(double x, char c){printf("%.15f",x);mypc(c);}
void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}
void writer(const char x[], char c){int i;for(i=0;x[i]!='\0';i++)mypc(x[i]);mypc(c);}
template&lt;class T&gt; void writerLn(T x){writer(x,'\n');}
template&lt;class T, class S&gt; void writerLn(T x, S y){writer(x,' ');writer(y,'\n');}
template&lt;class T, class S, class U&gt; void writerLn(T x, S y, U z){writer(x,' ');writer(y,' ');writer(z,'\n');}
template&lt;class T&gt; void writerArr(T x[], int n){int i;if(!n){mypc('\n');return;}rep(i,n-1)writer(x[i],' ');writer(x[n-1],'\n');}

char memarr[17000000]; void *mem = memarr;
#define MD 1000000007

int T, N, A[1000];

int main(){
  int i, j, k;
  int res;

  reader(&amp;T);
  while(T--){
    reader(&amp;N);
    rep(i,N) reader(A+i);
    res = 0;
    rep(i,N) REP(j,i+1,N) if(A[i] &gt; A[j]) res++;
    if(res%2) writerLn("NO"); else writerLn("YES");
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.75
medium
----------
PROBLEM STATEMENT:
Given an array of integers, determine whether the array can be sorted in ascending order using only one of the following operations one time. 


Swap two elements.   
Reverse one sub-segment.  


Determine whether one, both or neither of the operations will complete the task.  If both work, choose swap. For instance, given an array [expression], or reverse them to sort the array.  Choose swap. The Output Format section below details requirements.  

Function Description  

Complete the almostSorted function in the editor below.  It should print the results and return nothing.  

almostSorted has the following parameter(s):  


arr:  an array of integers  

----------
TOP SOLUTION:
----------
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;

int N, v[100005], s[100005];

int main() {
    cin &gt;&gt; N;
    for(int i=0; i&lt;N; i++){
        cin &gt;&gt; v[i];
        s[i] = v[i];
    }
    
    sort(s, s+N);    
    vector&lt;int&gt; diff;
    for(int i=0; i&lt;N; i++)
        if(v[i] != s[i])
            diff.push_back(i);    
    
        
    if(diff.size() == 0){
        cout &lt;&lt; "yes" &lt;&lt; endl;
        return 0;
    }
        
    if(diff.size() == 2 &amp;&amp; s[diff[0]] == v[diff[1]] &amp;&amp; s[diff[1]] == v[diff[0]]){
        cout &lt;&lt; "yes\nswap " &lt;&lt; diff[0] + 1 &lt;&lt; " " &lt;&lt; diff[1] + 1 &lt;&lt; endl;
        return 0;
    }

    reverse(v + diff[0], v + diff.back() + 1);
    bool good = true;
    for(int i=0; i&lt;N; i++)
        good &amp;= v[i] == s[i];
    
    if(good) cout &lt;&lt; "yes\nreverse " &lt;&lt; diff[0] + 1 &lt;&lt; " " &lt;&lt; diff.back() + 1 &lt;&lt; endl;
    else cout &lt;&lt; "no" &lt;&lt; endl;    
    return 0;
}

----------
====================
----------
ALGORITHMS.76
hard
----------
PROBLEM STATEMENT:
You are given a 2D  matrix of dimension [expression] times and print the resultant matrix. Rotation should be in anti-clockwise direction.  

Rotation of a [expression] matrix is represented by the following figure. Note that in one rotation, you have to shift elements by one step only.



It is guaranteed that the minimum of m and n will be even.  

As an example rotate the Start matrix by 2:

Start         First           Second
 1 2 3 4        2  3  4  5      3  4  5  6
12 1 2 5  -&gt;   1  2  3  6 -&gt;   2  3  4  7
11 4 3 6      12  1  4  7       1  2  1  8
10 9 8 7      11 10  9  8     12 11 10  9


Function Description  

Complete the matrixRotation function in the editor below.  It should print the resultant 2D integer array and return nothing.  

matrixRotation has the following parameter(s):  


matrix: a 2D array of integers  
r: an integer that represents the rotation factor  

----------
TOP SOLUTION:
----------
class RotationMatrix(object):
    def __init__(self, M, N, entries):
        self.M, self.N = M, N
        self.entries = dict(entries)
        self.tier_index = self._create_tier_index()
        
    def __str__(self):
        string = ""
        for i in range(self.M):
            for j in range(self.N):
                sep = " " if j &lt; self.N-1 else "\n"
                string += str(self.entries[(i,j)]) + sep
        return string
   
    def rotate_matrix(self, R):
        for index in self.tier_index:
            tier_copy = {key:self.entries[key] for key in index}
            for list_index, key in enumerate(index):
                rkey = index[(list_index + R + 1) % len(index) - 1]
                self.entries[rkey] = tier_copy[key]
        
    def _create_tier_index(self):
        row, col, tier_index = 0, 0, []
        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
        while self.M - 2 * row &gt; 0 and self.N - 2 * col &gt; 0:
            i, j = row, col
            tier_list = []
            for move in directions:
                while True:
                    if i + move[0] &gt; self.M - row - 1 or i + move[0] &lt; row or \
                    j + move[1] &gt; self.N - col - 1 or j + move[1] &lt; col:
                        break
                    else:
                        i, j = i + move[0], j + move[1]
                    tier_list.append((i, j))
            tier_index.append(tier_list)
            row, col = row + 1, col + 1
        return tier_index

M, N, R = [int(value) for value in input().split()]
mat = {}
for i in range(M):
    values = input().split()
    for j in range(N):
        mat[(i,j)] = int(values[j])
A = RotationMatrix(M, N, mat)
A.rotate_matrix(R)
print(A)
----------
====================
----------
ALGORITHMS.77
easy
----------
PROBLEM STATEMENT:
Consider an array of numeric strings where each string is a positive number with anywhere from [expression] digits. Sort the array's elements in non-decreasing, or ascending order of their integer values and print each element of the sorted array on a new line.

Function Description  

Complete the bigSorting function in the editor below.  It should return the sorted string array.  

bigSorting has the following parameter(s):  


unsorted: an unsorted array of integers as strings  

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main(){
    int n;
    cin &gt;&gt; n;
    vector&lt;string&gt; unsorted(n);
    for(int unsorted_i = 0; unsorted_i &lt; n; unsorted_i++){
       cin &gt;&gt; unsorted[unsorted_i];
    }
    sort(unsorted.begin(), unsorted.end(), [](const string&amp; a, const string&amp; b) {
        if (a.length() != b.length()) {
            return a.length() &lt; b.length();
        }
        return a &lt; b;
    });
    for (auto&amp; s : unsorted) {
        cout &lt;&lt; s &lt;&lt; "\n";
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.78
easy
----------
PROBLEM STATEMENT:
Steve has a string of lowercase characters in range ascii[‘a’..’z’].  He wants to reduce the string to its shortest length by doing a series of operations.  In each operation he selects a pair of adjacent lowercase letters that match, and he deletes them.  For instance, the string aab could be shortened to b in one operation.  

Steve’s task is to delete as many characters as possible using this method and print the resulting string.  If the final string is empty, print Empty String

Function Description

Complete the superReducedString function in the editor below.  It should return the super reduced string or Empty String if the final string is empty.  

superReducedString has the following parameter(s):  


s: a string to reduce  

----------
TOP SOLUTION:
----------
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.io.*;
import java.math.*;
import java.security.*;
import java.text.*; 
import java.util.*;
import java.util.regex.*;
/*
	  br = new BufferedReader(new FileReader("input.txt"));
	  pw = new PrintWriter(new BufferedWriter(new FileWriter("output.txt")));
	  br = new BufferedReader(new InputStreamReader(System.in));
	  pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
 */


public class Solution {
	private static BufferedReader br;
	private static StringTokenizer st;
	private static PrintWriter pw;

	public static void main(String[] args) throws Exception {
		br = new BufferedReader(new InputStreamReader(System.in));
		pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
		//int qq = 1;
		int qq = Integer.MAX_VALUE;
		//int qq = readInt();
		for(int casenum = 1; casenum &lt;= qq; casenum++)	{
			String s = nextToken();
			LinkedList&lt;Character&gt; q = new LinkedList&lt;Character&gt;();
			for(int i = 0; i &lt; s.length(); i++) {
				if(!q.isEmpty() &amp;&amp; q.peekLast() == s.charAt(i)) {
					q.removeLast();
				}
				else {
					q.addLast(s.charAt(i));
				}
			}
			for(char out: q) {
				pw.print(out);
			}
			if(q.size() == 0) {
				pw.print("Empty String");
			}
			pw.println();
		}
		exitImmediately();
	}

	private static void exitImmediately() {
		pw.close();
		System.exit(0);
	}

	private static long readLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	private static double readDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	private static int readInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	private static String nextLine() throws IOException  {
		if(!br.ready()) {
			exitImmediately();
		}
		st = null;
		return br.readLine();
	}

	private static String nextToken() throws IOException  {
		while(st == null || !st.hasMoreTokens())  {
			if(!br.ready()) {
				exitImmediately();
			}
			st = new StringTokenizer(br.readLine().trim());
		}
		return st.nextToken();
	}
}
----------
====================
----------
ALGORITHMS.79
easy
----------
PROBLEM STATEMENT:
About Tutorial Challenges 
Many of the challenges on HackerRank are difficult and assume that you already know the relevant algorithms. These tutorial challenges are different. They break down algorithmic concepts into smaller challenges so that you can learn the algorithm by solving them.  They are intended for those who already know some programming, however. You could be a student majoring in computer science, a self-taught programmer, or an experienced developer who wants an active algorithms review.  Here's a great place to learn by doing!

The first series of challenges covers sorting. They are listed below:

Tutorial Challenges - Sorting  

Insertion Sort challenges


Insertion Sort 1 - Inserting
Insertion Sort 2 - Sorting
Correctness and loop invariant
Running Time of Algorithms


Quicksort challenges


Quicksort 1 - Partition
Quicksort 2 - Sorting
Quicksort In-place (advanced)
Running time of Quicksort


Counting sort challenges


Counting Sort 1 - Counting
Counting Sort 2 - Simple sort
Counting Sort 3 - Preparing
Full Counting Sort (advanced)


There will also be some challenges where you'll get to apply what you've learned using the completed algorithms.

About the Challenges 
Each challenge will describe a scenario and you will code a solution. As you progress through the challenges, you will learn some important concepts in algorithms. In each challenge, you will receive input on STDIN and you will need to print the correct output to STDOUT.  

There may be time limits that will force you to make your code efficient.  If you receive a "Terminated due to time out" message when you submit your solution, you'll need to reconsider your method.  If you want to test your code locally, each test case can be downloaded, inputs and expected results, using hackos.  You earn hackos as you solve challenges, and you can spend them on these tests.

For many challenges, helper methods (like an array) will be provided for you to process the input into a useful format. You can use these methods to get started with your program, or you can write your own input methods if you want. Your code just needs to print the right output to each test case. 

Sample Challenge 
This is a simple challenge to get things started. Given a sorted array ([expression] in the array? 

For example, if [expression] for a zero-based index array.  

If you are going to use the provided code for I/O, this next section is for you.

Function Description

Complete the introTutorial function in the editor below.  It must return an integer representing the zero-based index of [expression].  

introTutorial has the following parameter(s):


arr: a sorted array of integers  
V: an integer to search for  


The next section describes the input format. You can often skip it, if you are using included methods or code stubs.

Input Format  

The first line contains an integer, [expression], a value to search for. 
The next line contains an integer, [expression].
The last line contains [expression].  

Output Format 
Output the index of [expression] in the array.

The next section describes the constraints and ranges of the input. You should check this section to know the range of the input.

Constraints  


[expression]   
[expression] 
It is guaranteed that [expression] exactly once.


This "sample" shows the first input test case. It is often useful to go through the sample to understand a challenge.

Sample Input 0

4
6
1 4 5 7 9 12


Sample Output 0

1


Explanation 0 
[expression] (see array definition under Input Format).
----------
TOP SOLUTION:
----------
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

int main() {

    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
    int n,size,i,dub,ans;
    scanf("%d",&amp;n);
    scanf("%d",&amp;size);
    for(i=0;i&lt;size;i++)
    {scanf("%d",&amp;dub);
    if(dub==n)
        ans=i;}
    printf("%d",ans);
    return 0;
}

----------
====================
----------
ALGORITHMS.80
easy
----------
PROBLEM STATEMENT:
Alice wrote a sequence of words in CamelCase as a string of letters, [expression], having the following properties:


It is a concatenation of one or more words consisting of English letters.
All letters in the first word are lowercase. 
For each of the subsequent words, the first letter is uppercase and rest of the letters are lowercase.


Given [expression] on a new line.

For example, [expression] words in the string.  

Function Description

Complete the camelcase function in the editor below.  It must return the integer number of words in the input string.  

camelcase has the following parameter(s):


s: the string to analyze  

----------
TOP SOLUTION:
----------
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;
#include &lt;cstdio&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_map&gt;

using namespace std;


int main(){
    string s;
    cin &gt;&gt; s;
    int t=1;
    for (int i=0;i&lt;s.length();i++)
        if (isupper(s[i]))
        t++;
        cout&lt;&lt;t&lt;&lt;endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.81
easy
----------
PROBLEM STATEMENT:
Sorting 
One common task for computers is to sort data. For example, people might want to see all their files on a computer sorted by size. Since sorting is a simple problem with many different possible solutions, it is often used to introduce the study of algorithms. 

Insertion Sort 
These challenges will cover Insertion Sort, a simple and intuitive sorting algorithm. We will first start with a nearly sorted list.

Insert element into sorted list 
Given a sorted list with an unsorted number [expression] into the array so that it remains sorted?  

Since this is a learning exercise, it won't be the most efficient way of performing the insertion.  It will instead demonstrate the brute-force method in detail.   

Assume you are given the array [expression], insert the stored value at the current index and print the entire array.

The results of operations on the example array is:

Starting array: [expression] 
Store the value of [expression]
Do the tests and print interim results:

1 2 4 5 5
1 2 4 4 5
1 2 3 4 5


Function Description

Complete the insertionSort1 function in the editor below.  It should print the interim and final arrays, each on a new line.  

insertionSort1 has the following parameter(s):


n: an integer, the size of [expression]  
arr: an array of integers to sort  

----------
TOP SOLUTION:
----------
import java.util.Scanner;

public class Solution {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
       Scanner scan=new Scanner(System.in);
        int s=scan.nextInt();
        int ar[]=new int[s];
        boolean check=false;
        for(int i=0;i&lt;s;i++)
        {
            ar[i]=scan.nextInt();
        }
        int var=ar[s-1];
        for(int i=s-2;i&gt;=-1;i--)
        {
            if(i!=-1)
            {
            if(var&lt;ar[i])
            {
                ar[i+1]=ar[i];
            }
            else
            {
                ar[i+1]=var;
                check=true;
            }
            }
            else
            {
                ar[0]=var;
            }
            for(int j=0;j&lt;s;j++)
                System.out.print(ar[j]+" ");
            System.out.println();
            if(check)
                break;
        }
    }
}
----------
====================
----------
ALGORITHMS.82
easy
----------
PROBLEM STATEMENT:
Louise joined a social networking site to stay in touch with her friends. The signup page required her to input a name and a password. However, the password must be strong. The website considers a password to be strong if it satisfies the following criteria:


Its length is at least [expression].  
It contains at least one digit.  
It contains at least one lowercase English character. 
It contains at least one uppercase English character. 
It contains at least one special character. The special characters are: !@#$%^&amp;*()-+  


She typed a random string of length [expression] in the password field but wasn't sure if it was strong. Given the string she typed, can you find the minimum number of characters she must add to make her password strong?

Note: Here's the set of types of characters in a form you can paste in your solution:

[expression]
[expression]
[expression]
[expression]


----------
TOP SOLUTION:
----------
/**
 *    author:  tourist
 *    created: 02.11.2017 17:35:27       
**/
#include &lt;bits/stdc++.h&gt;

using namespace std;

int check(string s, string w) {
  for (char c : s) {
    if (w.find(c) != string::npos) {
      return 0;
    }
  }
  return 1;
}

int main() {
  int n;
  cin &gt;&gt; n;
  string s;
  cin &gt;&gt; s;
  string numbers = "0123456789";
  string lower_case = "abcdefghijklmnopqrstuvwxyz";
  string upper_case = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  string special_characters = "!@#$%^&amp;*()-+";
  int ans = 0;
  ans += check(s, numbers);
  ans += check(s, lower_case);
  ans += check(s, upper_case);
  ans += check(s, special_characters);
  ans = max(ans, 6 - n);
  printf("%d\n", ans);
  return 0;
}

----------
====================
----------
ALGORITHMS.83
easy
----------
PROBLEM STATEMENT:
In this challenge, you will be given a string.  You must remove characters until the string is made up of any two alternating characters.  When you choose a character to remove, all instances of that character must be removed.  Your goal is to create the longest string possible that contains just two alternating letters.

As an example, consider the string abaacdabd.  If you delete the character a, you will be left with the string bcdbd.  Now, removing the character c leaves you with a valid string bdbd having a length of 4. Removing either b or d at any point would not result in a valid string.

Given a string [expression] instead.

Function Description

Complete the alternate function in the editor below.  It should return an integer that denotes the longest string that can be formed, or [expression] if it cannot be done.  

alternate has the following parameter(s):  


s: a string  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair&lt;int, int&gt; ii;

int valid(string x) {
    const int n = x.size();
    for (int i = 1; i &lt; n; ++i)
        if (x[i] == x[i-1])
            return false;
    return true;
}

int main() {
    int asd;
    cin&gt;&gt;asd;
    string s;
    cin&gt;&gt;s;
    int ans = 0;
    for (char a = 'a'; a &lt;= 'z'; ++a)
    for (char b = 'a'; b &lt;= 'z'; ++b)
    if (a != b)
    {
        if (s.find(a) == string::npos) continue;
        if (s.find(b) == string::npos) continue;
        string x;
        for (const char ch : s)
            if (ch == a || ch == b)
                x.push_back(ch);
        if (valid(x))
            ans = max(ans, (int)x.size());
    }
    printf("%d\n", ans);
}

----------
====================
----------
ALGORITHMS.84
easy
----------
PROBLEM STATEMENT:
In Insertion Sort Part 1, you inserted one element into an array at its correct sorted position. Using the same approach repeatedly, can you sort an entire array?

Guideline: You already can place an element into a sorted array. How can you use that code to build up a sorted array, one element at a time? Note that in the first step, when you consider an array with just the first element, it is already sorted since there's nothing to compare it to.

In this challenge, print the array after each iteration of the insertion sort, i.e., whenever the next element has been inserted at its correct position.  Since the array composed of just the first element is already sorted, begin printing after placing the second element.

For example, there are [expression].  Working from left to right, we get the following output:

[expression]3 4 7 5 6 2 1
3 4 7 5 6 2 1
3 4 5 7 6 2 1
3 4 5 6 7 2 1
2 3 4 5 6 7 1
1 2 3 4 5 6 7



Function Description

Complete the insertionSort2 function in the editor below.  At each iteration, it should print the array as space-separated integers on a separate line.  

insertionSort2 has the following parameter(s):  


n: an integer representing the length of the array [expression]  
arr: an array of integers  

----------
TOP SOLUTION:
----------


/* Head ends here */
import java.util.*;
public class Solution {
       
    public static void insertIntoSortedArray(int[] ar, int i)
	{
		
		int n= ar[i];
		i--;
		while(i&gt;=0 &amp;&amp; ar[i]&gt;n){			
			ar[i+1]=ar[i]; //shift right			
			i--;
            
            }
        ar[i+1]= n;
        printArray(ar);
    }
    
          static void insertionSort(int[] ar) {
              for(int i=1;i&lt;ar.length;i++){
			insertIntoSortedArray(ar, i);			
		    }	
              
                    
           }   

/* Tail starts here */
 
 static void printArray(int[] ar) {
         for(int n: ar){
            System.out.print(n+" ");
         }
           System.out.println("");
      }
       
      public static void main(String[] args) {
           Scanner in = new Scanner(System.in);
           int n = in.nextInt();
           int[] ar = new int[n];
           for(int i=0;i&lt;n;i++){
              ar[i]=in.nextInt(); 
           }
           insertionSort(ar);
       }    
   }

----------
====================
----------
ALGORITHMS.85
easy
----------
PROBLEM STATEMENT:
In the previous challenge, you wrote code to perform an Insertion Sort on an unsorted array. But how would you prove that the code is correct? I.e. how do you show that for any input your code will provide the right output?

Loop Invariant 
In computer science, you could prove it formally with a loop invariant, where you state that a desired property is maintained in your loop. Such a proof is broken down into the following parts:


Initialization: It is true (in a limited sense) before the loop runs.
Maintenance: If it's true before an iteration of a loop, it remains true before the next iteration.
Termination: It will terminate in a useful way once it is finished. 


Insertion Sort's Invariant 
Say, you have some InsertionSort code, where the outer loop goes through the whole array [expression]:

for(int i = 1; i &lt; A.length; i++){
//insertion sort code


You could then state the following loop invariant:


  At the start of every iteration of the outer loop (indexed with [expression] consists of the original elements that were there, but in sorted order. 


To prove Insertion Sort is correct, you will then demonstrate it for the three stages:


Initialization - The subarray starts with the first element of the array, and it is (obviously) sorted to begin with.
Maintenance - Each iteration of the loop expands the subarray, but keeps the sorted property. An element [expression] is greater than all the elements to its left, so the array remains sorted. (In Insertion Sort 2 we saw this by printing the array each time an element was properly inserted.)  
Termination - The code will terminate after [expression] has reached the last element in the array, which means the sorted subarray has expanded to encompass the entire array. The array is now fully sorted.




You can often use a similar process to demonstrate the correctness of many algorithms. You can see these notes for more information.

Challenge

In the InsertionSort code below, there is an error. Can you fix it? Print the array only once, when it is fully sorted. 
----------
TOP SOLUTION:
----------
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
/* Head ends here */
void insertionSort(int ar_size, int *  ar) {    
    int i,j;
    int value;
    for(i=1;i&lt;ar_size;i++)
    {
        value=ar[i];
        j=i-1;
        while(j&gt;=0 &amp;&amp; value&lt;ar[j])
        {
            ar[j+1]=ar[j];
            j=j-1;
        }
        ar[j+1]=value;        
    }
   for(j=0;j&lt;ar_size;j++)
        {
            printf("%d",ar[j]);
            printf(" ");
        }
}
/* Tail starts here */
int main(void) {
   
   int _ar_size;
scanf("%d", &amp;_ar_size);
int _ar[_ar_size], _ar_i;
for(_ar_i = 0; _ar_i &lt; _ar_size; _ar_i++) { 
   scanf("%d", &amp;_ar[_ar_i]); 
}

insertionSort(_ar_size, _ar);
   
   return 0;
}
----------
====================
----------
ALGORITHMS.86
easy
----------
PROBLEM STATEMENT:
Julius Caesar protected his confidential information by encrypting it using a cipher. Caesar's cipher shifts each letter by a number of letters.  If the shift takes you past the end of the alphabet, just rotate back to the front of the alphabet.  In the case of a rotation by 3, w, x, y and z would map to z, a, b and c.

[expression]Original alphabet:      abcdefghijklmnopqrstuvwxyz
Alphabet rotated +3:    defghijklmnopqrstuvwxyzabc



For example, the given cleartext [expression].  

Note: The cipher only encrypts letters; symbols, such as -, remain unencrypted.  

Function Description  

Complete the caesarCipher function in the editor below.  It should return the encrypted string.  

caesarCipher has the following parameter(s):


s: a string in cleartext  
k: an integer, the alphabet rotation factor  

----------
TOP SOLUTION:
----------
using System;
using System.Collections.Generic;
using System.IO;
class Solution {
    static void Main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution */
        var length = int.Parse(Console.ReadLine());
        var s = Console.ReadLine();
        var k = int.Parse(Console.ReadLine());
        
        foreach (var c in s)
        {
            if (!((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')))
            {
                Console.Write(c);
            }
            else
            {
                var isLower = (c &gt;= 'a' &amp;&amp; c &lt;= 'z');
                
                var c1 = c.ToString().ToLower()[0];
                
                c1 += (char)(k % 26);
                
                if (c1 &gt; 'z')
                {
                    c1 -= (char)26;
                }
                
                if (!isLower)
                {
                    c1 = c1.ToString().ToUpper()[0];
                }
                
                Console.Write(c1);
            }
        }
        
        Console.WriteLine();
    }
}
----------
====================
----------
ALGORITHMS.87
easy
----------
PROBLEM STATEMENT:
Sami's spaceship crashed on Mars! She sends a series of SOS messages to Earth for help. 



Letters in some of the SOS messages are altered by cosmic radiation during transmission. Given the signal received by Earth as a string, [expression], determine how many letters of Sami's SOS have been changed by radiation.

For example, Earth receives SOSTOT.  Sami's original message was SOSSOS.  Two of the message characters were changed in transit.  

Function Description

Complete the marsExploration function in the editor below.  It should return an integer representing the number of letters changed during transmission.  

marsExploration has the following parameter(s):


s: the string as received on Earth  

----------
TOP SOLUTION:
----------
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;limits&gt;
#include &lt;functional&gt;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus &gt; 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; inline void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; inline void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

int main() {
	string S;
	while(cin &gt;&gt; S) {
		int ans = 0;
		rep(i, S.size())
			ans += S[i] != "SOS"[i % 3];
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.88
easy
----------
PROBLEM STATEMENT:
In a previous challenge you implemented the Insertion Sort algorithm. It is a simple sorting algorithm that works well with small or mostly sorted data. However, it takes a long time to sort large unsorted data. To see why, we will analyze its running time.

Running Time of Algorithms 
The running time of an algorithm for a specific input depends on the number of operations executed. The greater the number of operations, the longer the running time of an algorithm. We usually want to know how many operations an algorithm will execute in proportion to the size of its input, which we will call [expression].

What is the ratio of the running time of Insertion Sort to the size of the input? To answer this question, we need to examine the algorithm. 

Analysis of Insertion Sort 
For each element [expression] into the array. 

How long does all that shifting take?

In the best case, where the array was already sorted, no element will need to be moved, so the algorithm will just run through the array once and return the sorted array. The running time would be directly proportional to the size of the input, so we can say it will take [expression] time.

However, we usually focus on the worst-case running time (computer scientists are pretty pessimistic). The worst case for Insertion Sort occurs when the array is in reverse order. To insert each number, the algorithm will have to shift over that number to the beginning of the array. Sorting the entire array of [expression] time" algorithm.



What this means 
The running time of the algorithm against an array of [expression].  Insertion Sort can work well for small inputs or if you know the data is likely to be nearly sorted, like check numbers as they are received by a bank.  The running time becomes unreasonable for larger inputs. 



Challenge 
Can you modify your previous Insertion Sort implementation to keep track of the number of shifts it makes while sorting? The only thing you should print is the number of shifts made by the algorithm to completely sort the array. A shift occurs when an element's position changes in the array. Do not shift an element if it is not necessary.

Function Description

Complete the runningTime function in the editor below.  It should return an integer representing the number of shifts it will take to sort the given array.  

runningTime has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------


/* Head ends here */
import java.util.*;
public class Solution {
    
static void insertionSort(int[] ar) {
              int count =0;              
              
              for(int i=1;i&lt;ar.length;i++){	                  
            	  int n= ar[i];
            	  int j=i-1;
            	  while(j&gt;=0 &amp;&amp; ar[j]&gt;n){	
            		  //System.err.print(i+" ");
            		  ar[j+1]=ar[j]; //shift right			
            		  j--;
            		  count++;            
            }
        ar[j+1]= n;           
                  
                  
		    }	
              System.out.println( count);
              
             
                    
           }   

/* Tail starts here */
        
      public static void main(String[] args) {
           Scanner in = new Scanner(System.in);
           int n = in.nextInt();
           int[] ar = new int[n];
           for(int i=0;i&lt;n;i++){
              ar[i]=in.nextInt(); 
           }
           insertionSort(ar);
       }    
   }



----------
====================
----------
ALGORITHMS.89
easy
----------
PROBLEM STATEMENT:
We say that a string contains the word hackerrank if a subsequence of its characters spell the word hackerrank. For example, if string [expression], it no longer contains the subsequence due to ordering.

More formally, let [expression] contains hackerrank.

For each query, print YES on a new line if the string contains hackerrank, otherwise, print NO.  

Function Description  

Complete the hackerrankInString function in the editor below.  It must return YES or NO.  

hackerrankInString has the following parameter(s):  


s: a string  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

int main(){
    int q;
    cin &gt;&gt; q;
    for(int a0 = 0; a0 &lt; q; a0++){
        string s;
        cin &gt;&gt; s;
        string cur = "hackerrank";
        int st = 0;
        for (int i= 0; i &lt; s.size() &amp;&amp; st &lt; cur.size(); i++) {
            if (s[i] == cur[st]) {
                st++;
            }
        }
        if (st == cur.size()) {
            cout &lt;&lt; "YES" &lt;&lt; endl;
        } else {
            cout &lt;&lt; "NO" &lt;&lt; endl;
        }
        // your code goes here
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.90
easy
----------
PROBLEM STATEMENT:
The previous challenges covered Insertion Sort, which is a simple and intuitive sorting algorithm with a running time of [expression]. In these next few challenges, we're covering a divide-and-conquer algorithm called Quicksort (also known as Partition Sort).  This challenge is a modified version of the algorithm that only addresses partitioning.  It is implemented as follows: 

Step 1: Divide 
Choose some pivot element, [expression]. 

For example:
Assume [expression] 
The pivot is at [expression] 
[expression]. 
Putting them all together, you get [expression]. 

Given [expression] on a single line. Your output should be space-separated and does not have to maintain ordering of the elements within the three categories.

Function Description  

Complete the quickSort function in the editor below.  It should return an array of integers as described above.  

quickSort has the following parameter(s):  


arr: an array of integers where [expression] is the pivot element    

----------
TOP SOLUTION:
----------
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

/* Head ends here */
void partition(int ar_size, int *  ar) {

int f,temp=ar[0],j=0,k=0,i;
    int ar1[ar_size],ar2[ar_size];
    for(i=0;i&lt;ar_size;i++)
    {
        if(ar[i]&lt;temp)
        {
            ar1[j]=ar[i];
            j++;
        }
        if(ar[i]&gt;temp)
        {
            ar2[k]=ar[i];
            k++;
           //printf("k=%d\n",k);
        }
       
    }
  /*  ar1[j]=temp;
    j++;
        for(i=0;i&lt;k;i++)
        {
         ar1[j]=ar2[i];
            j++;
        }*/
   // printf("j=%d\n",j);
    for(i=0;i&lt;j;i++)
    printf("%d ",ar1[i]);
    printf("%d ",temp);
    for(i=0;i&lt;k;i++)
        printf("%d ",ar2[i]);
    
}

/* Tail starts here */
int main() {
   
   int _ar_size;
scanf("%d", &amp;_ar_size);
int _ar[_ar_size], _ar_i;
for(_ar_i = 0; _ar_i &lt; _ar_size; _ar_i++) { 
   scanf("%d", &amp;_ar[_ar_i]); 
}

partition(_ar_size, _ar);
   
   return 0;
}
----------
====================
----------
ALGORITHMS.91
easy
----------
PROBLEM STATEMENT:
Roy wanted to increase his typing speed for programming contests.  His friend suggested that he type the sentence "The quick brown fox jumps over the lazy dog" repeatedly.  This sentence is known as a pangram because it contains every letter of the alphabet.

After typing the sentence several times, Roy became bored with it so he started to look for other pangrams.

Given a sentence, determine whether it is a pangram.  Ignore case.

Function Description

Complete the function pangrams in the editor below.  It should return the string pangram if the input string is a pangram.  Otherwise, it should return not pangram.  

pangrams has the following parameter(s):


s: a string to test

----------
TOP SOLUTION:
----------
#define DEBUG 0

#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
using namespace std;

#define LL long long
#define LD long double
#define PR pair&lt;int,int&gt;

#define Fox(i,n) for (i=0; i&lt;n; i++)
#define Fox1(i,n) for (i=1; i&lt;=n; i++)
#define FoxI(i,a,b) for (i=a; i&lt;=b; i++)
#define FoxR(i,n) for (i=(n)-1; i&gt;=0; i--)
#define FoxR1(i,n) for (i=n; i&gt;0; i--)
#define FoxRI(i,a,b) for (i=b; i&gt;=a; i--)
#define Foxen(i,s) for (i=s.begin(); i!=s.end(); i++)
#define Min(a,b) a=min(a,b)
#define Max(a,b) a=max(a,b)
#define Sz(s) int((s).size())
#define All(s) (s).begin(),(s).end()
#define Fill(s,v) memset(s,v,sizeof(s))
#define pb push_back
#define mp make_pair
#define x first
#define y second

template&lt;typename T&gt; T Abs(T x) { return(x&lt;0 ? -x : x); }
template&lt;typename T&gt; T Sqr(T x) { return(x*x); }
string plural(string s) { return(Sz(s) &amp;&amp; s[Sz(s)-1]=='x' ? s+"en" : s+"s"); }

const int INF = (int)1e9;
const LD EPS = 1e-12;
const LD PI = acos(-1.0);

#if DEBUG
#define GETCHAR getchar
#else
#define GETCHAR getchar_unlocked
#endif

bool Read(int &amp;x)
{
	char c,r=0,n=0;
	x=0;
		for(;;)
		{
			c=GETCHAR();
				if ((c&lt;0) &amp;&amp; (!r))
					return(0);
				if ((c=='-') &amp;&amp; (!r))
					n=1;
				else
				if ((c&gt;='0') &amp;&amp; (c&lt;='9'))
					x=x*10+c-'0',r=1;
				else
				if (r)
					break;
		}
		if (n)
			x=-x;
	return(1);
}

int main()
{
		if (DEBUG)
			freopen("in.txt","r",stdin);
	int N,M,K;
	int cnt[26]={0};
	char s[10000];
	cin.getline(s,10000);
	int i;
	int j=strlen(s);
		Fox(i,j)
			if ((s[i]&gt;='a') &amp;&amp; (s[i]&lt;='z'))
				cnt[s[i]-'a']++;
			else
			if ((s[i]&gt;='A') &amp;&amp; (s[i]&lt;='Z'))
				cnt[s[i]-'A']++;
		Fox(i,26)
			if (!cnt[i])
			{
				printf("not ");
				break;
			}
		printf("pangram\n");
	return(0);
}
----------
====================
----------
ALGORITHMS.92
easy
----------
PROBLEM STATEMENT:
A weighted string is a string of lowercase English letters where each letter has a weight.  Character weights are [expression] as shown below:



We define the following terms:  


The weight of a string is the sum of the weights of all the string's characters.  For example: 


A uniform string consists of a single character repeated zero or more times. For example, ccc and a are uniform strings, but bcb and cd are not.


Given a string, [expression]; otherwise, print No instead.

Note: The [expression].

Function Description  

Complete the weightedUniformStrings function in the editor below. It should return an array of strings, either Yes or No, one for each query.  

weightedUniformStrings has the following parameter(s):  


s: a string  
queries: an array of integers  

----------
TOP SOLUTION:
----------
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;
#include &lt;cstdio&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_map&gt;

using namespace std;

bool reach[10000010];

int main(){
    string s;
    cin &gt;&gt; s;
    
    int val = 0;
    for (int i=0; i&lt;s.size(); i++) {
        if (i &gt; 0 &amp;&amp; s[i] != s[i-1]) val = 0;
        val += (s[i]-'a'+1);
        reach[val] = true;
    }
    
    int n;
    cin &gt;&gt; n;
    for(int a0 = 0; a0 &lt; n; a0++){
        int x;
        cin &gt;&gt; x;
        cout &lt;&lt; (reach[x] ? "Yes\n" : "No\n");
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.93
easy
----------
PROBLEM STATEMENT:
A numeric string, [expression], satisfying the following conditions:


[expression] more than the previous element).
No [expression] have leading zeroes.
The contents of the sequence cannot be rearranged. For example, we can split [expression]).


The diagram below depicts some beautiful strings:



You must perform [expression], choose the smallest.  Otherwise, print NO.  

Function Description  

Complete the separateNumbers function in the editor below.  It should print a string as described above.  

separateNumbers has the following parameter:  


s: an integer value represented as a string  

----------
TOP SOLUTION:
----------
q = int(raw_input())
for __ in xrange(q):
	s = raw_input().strip()
	if s[0] == '0':
		print "NO"
		continue
	found = False
	for pref in xrange(1,len(s)+1):
		t = ""
		curnum = int(s[:pref])
		added = 0
		while len(t) &lt; len(s):
			t += str(curnum)
			curnum += 1
			added += 1
		if added &gt; 1 and t == s:
			print "YES", s[:pref]
			found = True
			break
	if not found:
		print "NO"

----------
====================
----------
ALGORITHMS.94
easy
----------
PROBLEM STATEMENT:
In this challenge, you will determine whether a string is funny or not.  To determine whether a string is funny, create a copy of the string in reverse e.g. [expression].  Iterating through each string, compare the absolute difference in the ascii values of the characters at positions 0 and 1, 1 and 2 and so on to the end.  If the list of absolute differences is the same for both strings, they are funny.

Determine whether a give string is funny.  If it is, return Funny, otherwise return Not Funny.

For example, given the string [expression], so the answer is Funny.

Function Description

Complete the funnyString function in the editor below.  For each test case, it should return a string, either Funny or Not Funny.

funnyString has the following parameter(s):  


s: a string to test

----------
TOP SOLUTION:
----------
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;cctype&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;bitset&gt;
#include&lt;vector&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
#include&lt;cmath&gt;
#include&lt;sstream&gt;
#include&lt;fstream&gt;
#include&lt;iomanip&gt;
#include&lt;ctime&gt;
#include&lt;complex&gt;
#include&lt;functional&gt;
#include&lt;climits&gt;
#include&lt;cassert&gt;
#include&lt;iterator&gt;
using namespace std;
string s;
int t;
char ss[1000001];
int main(){
	scanf("%d", &amp;t);
	while (t--){
		scanf("%s", ss);
		s = ss;
		//cin &gt;&gt; s;
		string r = s;
		bool ok = false;
		reverse(r.begin(), r.end());
		for (int i = 0; i &lt; s.size() - 1; i++){
			if (abs(s[i] - s[i + 1]) != abs(r[i] - r[i + 1])){
				ok = true;
				break;
			}
		}
		if (ok){
			puts("Not Funny");
		}
		else{
			puts("Funny");
		}
 }
	return 0;
}
----------
====================
----------
ALGORITHMS.95
easy
----------
PROBLEM STATEMENT:
Comparison Sorting 
Quicksort usually has a running time of [expression] represents the minimum number of comparisons needed to know where to place each element. For more details, you can see these notes (PDF). 

Alternative Sorting 
Another sorting method, the counting sort, does not require comparison.  Instead, you create an integer array whose index range covers the entire range of values in your array to sort.  Each time a value occurs in the original array, you increment the counter at that index.  At the end, run through your counting array, printing the value of each non-zero valued index that number of times.

For example, consider an array [expression].  The results of each iteration follow:

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



Now we can print the list of occurrences, [expression].

Challenge 
Given a list of integers, count and output the number of times each value appears as a list of space-separated integers.

Function Description  

Complete the countingSort function in the editor below.  It should return an array of integers where each value is the number of occurrences of the element's index value in the original array.  

countingSort has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

vector&lt;int&gt;List;
auto main()-&gt;int
{
	int size;
	cin &gt;&gt; size;
	//Initialize
	List.resize(100,0);
	for (int i = 0; i != size; i++)
	{
		int n;
		cin &gt;&gt; n;
		List[n] = List[n] + 1;
	}
	for (int r = 0; r != List.size(); r++)
	{
		cout &lt;&lt; List[r]&lt;&lt;" ";
	}
	return 0;
}
----------
====================
----------
ALGORITHMS.96
easy
----------
PROBLEM STATEMENT:
Often, when a list is sorted, the elements being sorted are just keys to other values. For example, if you are sorting files by their size, the sizes need to stay connected to their respective files. You cannot just take the size numbers and output them in order, you need to output all the required file information.

The counting sort is used if you just need to sort a list of integers.  Rather than using a comparison, you create an integer array whose index range covers the entire range of values in your array to sort.  Each time a value occurs in the original array, you increment the counter at that index.  At the end, run through your counting array, printing the value of each non-zero valued index that number of times.

For example, consider an array [expression].  The results of each iteration follow:

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



Now we can print the sorted array: [expression].

Challenge 
Given an unsorted list of integers, use the counting sort method to sort the list and then print the sorted list. 

Hint: You can use your previous code that counted the items to print out the actual values in order.  

Function Description  

Complete the countingSort function in the editor below.  It should return the original array, sorted ascending, as an array of integers.  

countingSort has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


vector&lt;int&gt;List;
auto main()-&gt;int
{
	int size;
	cin &gt;&gt; size;
	//Initialize
	List.resize(100,0);
	for (int i = 0; i != size; i++)
	{
		int n;
		cin &gt;&gt; n;
		List[n] = List[n] + 1;
	}
	for (int r = 0; r != List.size(); r++)
	{
		for (int t = 0; t != List[r];t++)
		{
			cout &lt;&lt; r &lt;&lt; " ";
		}
	}
	return 0;
}
----------
====================
----------
ALGORITHMS.97
easy
----------
PROBLEM STATEMENT:
John has collected various rocks. Each rock has various minerals embeded in it.  Each type of mineral is designated by a lowercase letter in the range [expression]. There may be multiple occurrences of a mineral in a rock. A mineral is called a gemstone if it occurs at least once in each of the rocks in John's collection.

Given a list of minerals embedded in each of John's rocks, display the number of types of gemstones he has in his collection.

For example, the array of mineral composition strings [expression] gemstones.

Function Description  

Complete the gemstones function in the editor below.  It should return an integer representing the number of gemstones found in the list of rocks.  

gemstones has the following parameter(s):  


arr: an array of strings  

----------
TOP SOLUTION:
----------
from string import ascii_lowercase
chars = ascii_lowercase
n = input()
R = []
c = 0
for i in range(n):
    R.append(raw_input())
for x in chars:
    present = True
    for r in R:
        if x not in r:
            present = False
    if present:
        c += 1
print c
----------
====================
----------
ALGORITHMS.98
easy
----------
PROBLEM STATEMENT:
You are given a string containing characters [expression] only.  Your task is to change it into a string such that there are no matching adjacent characters. To do this, you are allowed to delete zero or more characters in the string.  

Your task is to find the minimum number of required deletions.

For example, given the string [expression] deletions.

Function Description

Complete the alternatingCharacters function in the editor below.  It must return an integer representing the minimum number of deletions to make the alternating string.  

alternatingCharacters has the following parameter(s):


s: a string

----------
TOP SOLUTION:
----------

  <div id="main-frame-error" class="interstitial-wrapper" jstcache="0">
    <div id="main-content" jstcache="0">
      <div class="icon icon-generic" jseval="updateIconClass(this.classList, iconClass)" alt="" jstcache="1"></div>
      <div id="main-message" jstcache="0">
        <h1 jstcache="0">
          <span jsselect="heading" jsvalues=".innerHTML:msg" jstcache="10">This <span jscontent="hostName" jstcache="23">www.hackerrank.com</span> page can’t be found</span>
          <a id="error-information-button" class="hidden" onclick="toggleErrorInformationPopup();" jstcache="0"></a>
        </h1>
        <p jsselect="summary" jsvalues=".innerHTML:msg" jstcache="2">No webpage was found for the web address: <strong jscontent="failedUrl" jstcache="24">https://www.hackerrank.com/rest/contests/master/challenges/alternating-characters/hackers/[deleted]/download_solution?primary=true</strong></p>
        <!--The suggestion list and error code are normally presented inline,
          in which case error-information-popup-* divs have no effect. When
          error-information-popup-container has the use-popup-container class, this
          information is provided in a popup instead.-->
        <div id="error-information-popup-container" jstcache="0">
          <div id="error-information-popup" jstcache="0">
            <div id="error-information-popup-box" jstcache="0">
              <div id="error-information-popup-content" jstcache="0">
                <div id="suggestions-list" style="display:none" jsdisplay="(suggestionsSummaryList &amp;&amp; suggestionsSummaryList.length)" jstcache="17">
                  <p jsvalues=".innerHTML:suggestionsSummaryListHeader" jstcache="19"></p>
                  <ul jsvalues=".className:suggestionsSummaryList.length == 1 ? 'single-suggestion' : ''" jstcache="20">
                    <li jsselect="suggestionsSummaryList" jsvalues=".innerHTML:summary" jstcache="22"></li>
                  </ul>
                </div>
                <div class="error-code" jscontent="errorCode" jstcache="18">HTTP ERROR 404</div>
                <p id="error-information-popup-close" jstcache="0">
                  <a class="link-button" jscontent="closeDescriptionPopup" onclick="toggleErrorInformationPopup();" jstcache="21">null</a>
                </p>
              </div>
            </div>
          </div>
        </div>
        <div id="diagnose-frame" class="hidden" jstcache="0"></div>
        <div id="download-links-wrapper" class="hidden" jstcache="0">
          <div id="download-link-wrapper" jstcache="0">
            <a id="download-link" class="link-button" onclick="downloadButtonClick()" jsselect="downloadButton" jscontent="msg" jsvalues=".disabledText:disabledMsg" jstcache="7" style="display: none;">
            </a>
          </div>
          <div id="download-link-clicked-wrapper" class="hidden" jstcache="0">
            <div id="download-link-clicked" class="link-button" jsselect="downloadButton" jscontent="disabledMsg" jstcache="12" style="display: none;">
            </div>
          </div>
        </div>
        <div id="save-page-for-later-button" class="hidden" jstcache="0">
          <a class="link-button" onclick="savePageLaterClick()" jsselect="savePageLater" jscontent="savePageMsg" jstcache="11" style="display: none;">
          </a>
        </div>
        <div id="cancel-save-page-button" class="hidden" onclick="cancelSavePageClick()" jsselect="savePageLater" jsvalues=".innerHTML:cancelMsg" jstcache="5" style="display: none;">
        </div>
        <div id="offline-content-list" class="list-hidden" hidden="" jstcache="0">
          <div id="offline-content-list-visibility-card" onclick="toggleOfflineContentListVisibility(true)" jstcache="0">
            <div id="offline-content-list-title" jsselect="offlineContentList" jscontent="title" jstcache="13" style="display: none;">
            </div>
            <div jstcache="0">
              <div id="offline-content-list-show-text" jsselect="offlineContentList" jscontent="showText" jstcache="15" style="display: none;">
              </div>
              <div id="offline-content-list-hide-text" jsselect="offlineContentList" jscontent="hideText" jstcache="16" style="display: none;">
              </div>
            </div>
          </div>
          <div id="offline-content-suggestions" jstcache="0"></div>
          <div id="offline-content-list-action" jstcache="0">
            <a class="link-button" onclick="launchDownloadsPage()" jsselect="offlineContentList" jscontent="actionText" jstcache="14" style="display: none;">
            </a>
          </div>
        </div>
      </div>
    </div>
    <div id="buttons" class="nav-wrapper suggested-right" jstcache="0">
      <div id="control-buttons" jstcache="0">
        <button id="reload-button" class="blue-button text-button" onclick="trackClick(this.trackingId);
                     reloadButtonClick(this.url);" jsselect="reloadButton" jsvalues=".url:reloadUrl; .trackingId:reloadTrackingId" jscontent="msg" jstcache="6">Reload</button>
        <button id="download-button" class="blue-button text-button" onclick="downloadButtonClick()" jsselect="downloadButton" jscontent="msg" jsvalues=".disabledText:disabledMsg" jstcache="7" style="display: none;">
        </button>
      </div>
      <button id="details-button" class="secondary-button text-button small-link" onclick="detailsButtonClick(); toggleHelpBox()" jscontent="details" jsdisplay="(suggestionsDetails &amp;&amp; suggestionsDetails.length > 0) || diagnose" jsvalues=".detailsText:details; .hideDetailsText:hideDetails;" jstcache="3" style="display: none;"></button>
    </div>
    <div id="details" class="hidden" jstcache="0">
      <div class="suggestions" jsselect="suggestionsDetails" jstcache="4" jsinstance="*0" style="display: none;">
        <div class="suggestion-header" jsvalues=".innerHTML:header" jstcache="8"></div>
        <div class="suggestion-body" jsvalues=".innerHTML:body" jstcache="9"></div>
      </div>
    </div>
  </div>
  <div id="sub-frame-error" jstcache="0">
    <!-- Show details when hovering over the icon, in case the details are
         hidden because they're too large. -->
    <div class="icon icon-generic" jseval="updateIconClass(this.classList, iconClass)" jstcache="1"></div>
    <div id="sub-frame-error-details" jsselect="summary" jsvalues=".innerHTML:msg" jstcache="2">No webpage was found for the web address: <strong jscontent="failedUrl" jstcache="24">https://www.hackerrank.com/rest/contests/master/challenges/alternating-characters/hackers/[deleted]/download_solution?primary=true</strong></div>
  </div>

  <div id="offline-resources" jstcache="0">
    <img id="offline-resources-1x" src="data:image/png;base64,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" jstcache="0">
    <img id="offline-resources-2x" src="data:image/png;base64,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" jstcache="0">
    <template id="audio-resources" jstcache="0">
      <audio id="offline-sound-press" src="data:audio/mpeg;base64,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"></audio>
      <audio id="offline-sound-hit" src="data:audio/mpeg;base64,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"></audio>
      <audio id="offline-sound-reached" src="data:audio/mpeg;base64,T2dnUwACAAAAAAAAAABVDxppAAAAABYzHfUBHgF2b3JiaXMAAAAAAkSsAAD/////AHcBAP////+4AU9nZ1MAAAAAAAAAAAAAVQ8aaQEAAAC9PVXbEEf//////////////////+IDdm9yYmlzNwAAAEFPOyBhb1R1ViBiNSBbMjAwNjEwMjRdIChiYXNlZCBvbiBYaXBoLk9yZydzIGxpYlZvcmJpcykAAAAAAQV2b3JiaXMlQkNWAQBAAAAkcxgqRqVzFoQQGkJQGeMcQs5r7BlCTBGCHDJMW8slc5AhpKBCiFsogdCQVQAAQAAAh0F4FISKQQghhCU9WJKDJz0IIYSIOXgUhGlBCCGEEEIIIYQQQgghhEU5aJKDJ0EIHYTjMDgMg+U4+ByERTlYEIMnQegghA9CuJqDrDkIIYQkNUhQgwY56ByEwiwoioLEMLgWhAQ1KIyC5DDI1IMLQoiag0k1+BqEZ0F4FoRpQQghhCRBSJCDBkHIGIRGQViSgwY5uBSEy0GoGoQqOQgfhCA0ZBUAkAAAoKIoiqIoChAasgoAyAAAEEBRFMdxHMmRHMmxHAsIDVkFAAABAAgAAKBIiqRIjuRIkiRZkiVZkiVZkuaJqizLsizLsizLMhAasgoASAAAUFEMRXEUBwgNWQUAZAAACKA4iqVYiqVoiueIjgiEhqwCAIAAAAQAABA0Q1M8R5REz1RV17Zt27Zt27Zt27Zt27ZtW5ZlGQgNWQUAQAAAENJpZqkGiDADGQZCQ1YBAAgAAIARijDEgNCQVQAAQAAAgBhKDqIJrTnfnOOgWQ6aSrE5HZxItXmSm4q5Oeecc87J5pwxzjnnnKKcWQyaCa0555zEoFkKmgmtOeecJ7F50JoqrTnnnHHO6WCcEcY555wmrXmQmo21OeecBa1pjppLsTnnnEi5eVKbS7U555xzzjnnnHPOOeec6sXpHJwTzjnnnKi9uZab0MU555xPxunenBDOOeecc84555xzzjnnnCA0ZBUAAAQAQBCGjWHcKQjS52ggRhFiGjLpQffoMAkag5xC6tHoaKSUOggllXFSSicIDVkFAAACAEAIIYUUUkghhRRSSCGFFGKIIYYYcsopp6CCSiqpqKKMMssss8wyyyyzzDrsrLMOOwwxxBBDK63EUlNtNdZYa+4555qDtFZaa621UkoppZRSCkJDVgEAIAAABEIGGWSQUUghhRRiiCmnnHIKKqiA0JBVAAAgAIAAAAAAT/Ic0REd0REd0REd0REd0fEczxElURIlURIt0zI101NFVXVl15Z1Wbd9W9iFXfd93fd93fh1YViWZVmWZVmWZVmWZVmWZVmWIDRkFQAAAgAAIIQQQkghhRRSSCnGGHPMOegklBAIDVkFAAACAAgAAABwFEdxHMmRHEmyJEvSJM3SLE/zNE8TPVEURdM0VdEVXVE3bVE2ZdM1XVM2XVVWbVeWbVu2dduXZdv3fd/3fd/3fd/3fd/3fV0HQkNWAQASAAA6kiMpkiIpkuM4jiRJQGjIKgBABgBAAACK4iiO4ziSJEmSJWmSZ3mWqJma6ZmeKqpAaMgqAAAQAEAAAAAAAACKpniKqXiKqHiO6IiSaJmWqKmaK8qm7Lqu67qu67qu67qu67qu67qu67qu67qu67qu67qu67qu67quC4SGrAIAJAAAdCRHciRHUiRFUiRHcoDQkFUAgAwAgAAAHMMxJEVyLMvSNE/zNE8TPdETPdNTRVd0gdCQVQAAIACAAAAAAAAADMmwFMvRHE0SJdVSLVVTLdVSRdVTVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTdM0TRMIDVkJAJABAKAQW0utxdwJahxi0nLMJHROYhCqsQgiR7W3yjGlHMWeGoiUURJ7qihjiknMMbTQKSet1lI6hRSkmFMKFVIOWiA0ZIUAEJoB4HAcQLIsQLI0AAAAAAAAAJA0DdA8D7A8DwAAAAAAAAAkTQMsTwM0zwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQNI0QPM8QPM8AAAAAAAAANA8D/BEEfBEEQAAAAAAAAAszwM80QM8UQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwNE0QPM8QPM8AAAAAAAAALA8D/BEEfA8EQAAAAAAAAA0zwM8UQQ8UQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABDgAAAQYCEUGrIiAIgTADA4DjQNmgbPAziWBc+D50EUAY5lwfPgeRBFAAAAAAAAAAAAADTPg6pCVeGqAM3zYKpQVaguAAAAAAAAAAAAAJbnQVWhqnBdgOV5MFWYKlQVAAAAAAAAAAAAAE8UobpQXbgqwDNFuCpcFaoLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAABhwAAAIMKEMFBqyIgCIEwBwOIplAQCA4ziWBQAAjuNYFgAAWJYligAAYFmaKAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAGHAAAAgwoQwUGrISAIgCADAoimUBy7IsYFmWBTTNsgCWBtA8gOcBRBEACAAAKHAAAAiwQVNicYBCQ1YCAFEAAAZFsSxNE0WapmmaJoo0TdM0TRR5nqZ5nmlC0zzPNCGKnmeaEEXPM02YpiiqKhBFVRUAAFDgAAAQYIOmxOIAhYasBABCAgAMjmJZnieKoiiKpqmqNE3TPE8URdE0VdVVaZqmeZ4oiqJpqqrq8jxNE0XTFEXTVFXXhaaJommaommqquvC80TRNE1TVVXVdeF5omiapqmqruu6EEVRNE3TVFXXdV0giqZpmqrqurIMRNE0VVVVXVeWgSiapqqqquvKMjBN01RV15VdWQaYpqq6rizLMkBVXdd1ZVm2Aarquq4ry7INcF3XlWVZtm0ArivLsmzbAgAADhwAAAKMoJOMKouw0YQLD0ChISsCgCgAAMAYphRTyjAmIaQQGsYkhBJCJiWVlEqqIKRSUikVhFRSKiWjklJqKVUQUikplQpCKqWVVAAA2IEDANiBhVBoyEoAIA8AgCBGKcYYYwwyphRjzjkHlVKKMeeck4wxxphzzkkpGWPMOeeklIw555xzUkrmnHPOOSmlc84555yUUkrnnHNOSiklhM45J6WU0jnnnBMAAFTgAAAQYKPI5gQjQYWGrAQAUgEADI5jWZqmaZ4nipYkaZrneZ4omqZmSZrmeZ4niqbJ8zxPFEXRNFWV53meKIqiaaoq1xVF0zRNVVVVsiyKpmmaquq6ME3TVFXXdWWYpmmqquu6LmzbVFXVdWUZtq2aqiq7sgxcV3Vl17aB67qu7Nq2AADwBAcAoAIbVkc4KRoLLDRkJQCQAQBAGIOMQgghhRBCCiGElFIICQAAGHAAAAgwoQwUGrISAEgFAACQsdZaa6211kBHKaWUUkqpcIxSSimllFJKKaWUUkoppZRKSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoFAC5VOADoPtiwOsJJ0VhgoSErAYBUAADAGKWYck5CKRVCjDkmIaUWK4QYc05KSjEWzzkHoZTWWiyecw5CKa3FWFTqnJSUWoqtqBQyKSml1mIQwpSUWmultSCEKqnEllprQQhdU2opltiCELa2klKMMQbhg4+xlVhqDD74IFsrMdVaAABmgwMARIINqyOcFI0FFhqyEgAICQAgjFGKMcYYc8455yRjjDHmnHMQQgihZIwx55xzDkIIIZTOOeeccxBCCCGEUkrHnHMOQgghhFBS6pxzEEIIoYQQSiqdcw5CCCGEUkpJpXMQQgihhFBCSSWl1DkIIYQQQikppZRCCCGEEkIoJaWUUgghhBBCKKGklFIKIYRSQgillJRSSimFEEoIpZSSUkkppRJKCSGEUlJJKaUUQggllFJKKimllEoJoYRSSimlpJRSSiGUUEIpBQAAHDgAAAQYQScZVRZhowkXHoBCQ1YCAGQAAJSyUkoorVVAIqUYpNpCR5mDFHOJLHMMWs2lYg4pBq2GyjGlGLQWMgiZUkxKCSV1TCknLcWYSuecpJhzjaVzEAAAAEEAgICQAAADBAUzAMDgAOFzEHQCBEcbAIAgRGaIRMNCcHhQCRARUwFAYoJCLgBUWFykXVxAlwEu6OKuAyEEIQhBLA6ggAQcnHDDE294wg1O0CkqdSAAAAAAAAwA8AAAkFwAERHRzGFkaGxwdHh8gISIjJAIAAAAAAAYAHwAACQlQERENHMYGRobHB0eHyAhIiMkAQCAAAIAAAAAIIAABAQEAAAAAAACAAAABARPZ2dTAABARwAAAAAAAFUPGmkCAAAAZa2xyCElHh4dHyQvOP8T5v8NOEo2/wPOytDN39XY2P8N/w2XhoCs0CKt8NEKLdIKH63ShlVlwuuiLze+3BjtjfZGe0lf6As9ggZstNJFphRUtpUuMqWgsqrasj2IhOA1F7LFMdFaWzkAtNBFpisIQgtdZLqCIKjqAAa9WePLkKr1MMG1FlwGtNJFTSkIcitd1JSCIKsCAQWISK0Cyzw147T1tAK00kVNKKjQVrqoCQUVqqr412m+VKtZf9h+TDaaztAAtNRFzVEQlJa6qDkKgiIrc2gtfES4nSQ1mlvfMxfX4+b2t7ICVNGwkKiiYSGxTQtK1YArN+DgTqdjMwyD1q8dL6RfOzXZ0yO+qkZ8+Ub81WP+DwNkWcJhvlmWcJjvSbUK/WVm3LgxClkyiuxpIFtS5Gwi5FBkj2DGWEyHYBiLcRJkWnQSZGbRGYGZAHr6vWVJAWGE5q724ldv/B8Kp5II3dPvLUsKCCM0d7UXv3rj/1A4lUTo+kCUtXqtWimLssjIyMioViORobCJAQLYFnpaAACCAKEWAMCiQGqMABAIUKknAFkUIGsBIBBAHYBtgAFksAFsEySQgQDWQ4J1AOpiVBUHd1FE1d2IGDfGAUzmKiiTyWQyuY6Lx/W4jgkQZQKioqKuqioAiIqKwagqCqKiogYxCgACCiKoAAAIqAuKAgAgjyeICQAAvAEXmQAAmYNhMgDAZD5MJqYzppPpZDqMwzg0TVU9epXf39/9xw5lBaCpqJiG3VOsht0wRd8FgAeoB8APKOABQFT23GY0GgoAolkyckajHgBoZEYujQY+230BUoD/uf31br/7qCHLXLWwIjMIz3ZfgBTgf25/vdvvPmrIMlctrMgMwiwCAAB4FgAAggAAAM8CAEAgkNG0DgCeBQCAIAAAmEUBynoASKANMIAMNoBtAAlkMAGoAzKQgDoAdQYAKOoEANFgAoAyKwAAGIOiAACVBACyAAAAFYMDAAAyxyMAAMBMfgQAAMi8GAAACDfoFQAAYHgxACA16QiK4CoWcTcVAADDdNpc7AAAgJun080DAAAwPTwxDQAAxYanm1UFAAAVD0MsAA4AyCUztwBwBgAyQOTMTZYA0AAiySW3Clar/eRUAb5fPDXA75e8QH//jkogHmq1n5wqwPeLpwb4/ZIX6O/fUQnEgwf9fr/f72dmZmoaRUREhMLTADSVgCAgVLKaCT0tAABk2AFgAyQgEEDTSABtQiSQwQDUARksYBtAAgm2AQSQYBtAAuYPOK5rchyPLxAABFej4O7uAIgYNUYVEBExbozBGHdVgEoCYGZmAceDI0mGmZlrwYDHkQQAiLhxo6oKSHJk/oBrZgYASI4XAwDAXMMnIQAA5DoyDAAACa8AAMDM5JPEZDIZhiFJoN33vj4X6N19v15gxH8fAE1ERMShbm5iBYCOAAMFgAzaZs3ITURECAAhInKTNbNtfQDQNnuWHBERFgBUVa4iDqyqXEUc+AKkZlkmZCoJgIOBBaubqwoZ2SDNgJlj5MgsMrIV44xgKjCFYTS36QRGQafwylRZAhMXr7IEJi7+AqQ+gajAim2S1W/71ACEi4sIxsXVkSNDQRkgzGp6eNgMJDO7kiVXcmStkCVL0Ry0MzMgzRklI2dLliQNEbkUVFvaCApWW9oICq7rpRlKs2MBn8eVJRlk5JARjONMdGSYZArDOA0ZeKHD6+KN9oZ5MBDTCO8bmrptBBLgcnnOcBmk/KMhS2lL6rYRSIDL5TnDZZDyj4YspS3eIOoN9Uq1KIsMpp1gsU0gm412AISQyICYRYmsFQCQwWIgwWRCABASGRDawAKYxcCAyYQFgLhB1Rg17iboGF6v1+fIcR2TyeR4PF7HdVzHdVzHcYXPbzIAQNTFuBoVBQAADJOL15WBhNcFAADAI9cAAAAAAJAEmIsMAOBlvdTLVcg4mTnJzBnTobzDfKPRaDSaI1IAnUyHhr6LALxFo5FmyZlL1kAU5lW+LIBGo9lym1OF5ikAOsyctGkK8fgfAfgPIQDAvBLgmVsGoM01lwRAvCwAHje0zTiA/oUDAOYAHqv9+AQC4gEDMJ/bIrXsH0Ggyh4rHKv9+AQC4gEDMJ/bIrXsH0Ggyh4rDPUsAADAogBCk3oCQBAAAABBAAAg6FkAANCzAAAgBELTAACGQAAoGoFBFoWoAQDaBPoBQ0KdAQAAAK7iqkAVAABQNixAoRoAAKgE4CAiAAAAACAYow6IGjcAAAAAAPL4DfZ6kkZkprlkj6ACu7i7u5sKAAAOd7vhAAAAAEBxt6m6CjSAgKrFasUOAAAoAABic/d0EwPIBjAA0CAggABojlxzLQD+mv34BQXEBQvYH5sijDr0/FvZOwu/Zj9+QQFxwQL2x6YIow49/1b2zsI9CwAAeBYAAIBANGlSDQAABAEAAKBnIQEAeloAABgCCU0AAEMgAGQTYNAG+gCwAeiBIWMAGmYAAICogRg16gAAABB1gwVkNlgAAIDIGnCMOwIAAACAgmPA8CpgBgAAAIDMG/QbII/PLwAAaKN9vl4Pd3G6maoAAAAAapiKaQUAANPTxdXhJkAWXHBzcRcFAAAHAABqNx2YEQAHHIADOAEAvpp9fyMBscACmc9Lku7s1RPB+kdWs+9vJCAWWCDzeUnSnb16Ilj/CNOzAACAZwEAAAhEk6ZVAAAIAgAAQc8CAICeFgAAhiAAABgCAUAjMGgDPQB6CgCikmDIGIDqCAAAkDUQdzUOAAAAKg3WIKsCAABkFkAJAAAAQFzFQXh8QQMAAAAABCMCKEhAAACAkXcOo6bDxCgqOMXV6SoKAAAAoGrabDYrAAAiHq5Ww80EBMiIi01tNgEAAAwAAKiHGGpRQADUKpgGAAAOEABogFFAAN6K/fghBIQ5cH0+roo0efVEquyBaMV+/BACwhy4Ph9XRZq8eiJV9kCQ9SwAAMCiAGhaDwAIAgAAIAgAAAQ9CwAAehYAAIQgAAAYAgGgaAAGWRTKBgBAG4AMADI2ANVFAAAAgKNqFKgGAACKRkpQqAEAgCKBAgAAAIAibkDFuDEAAAAAYODzA1iQoAEAAI3+ZYOMNls0AoEdN1dPiwIAgNNp2JwAAAAAYHgaLoa7QgNwgKeImAoAAA4AALU5XNxFoYFaVNxMAQCAjADAAQaeav34QgLiAQM4H1dNGbXoH8EIlT2SUKr14wsJiAcM4HxcNWXUon8EI1T2SEJMzwIAgJ4FAAAgCAAAhCAAABD0LAAA6GkBAEAIAgCAIRAAqvUAgywK2QgAyKIAoBEYAiGqCQB1BQAAqCNAmQEAAOqGFZANCwAAoBpQJgAAAKDiuIIqGAcAAAAA3Ig64LgoAADQHJ+WmYbJdMzQBsGuVk83mwIAAAIAgFNMV1cBUz1xKAAAgAEAwHR3sVldBRxAQD0d6uo0FAAADAAA6orNpqIAkMFqqMNAAQADKABkICgAfmr9+AUFxB0ANh+vita64VdPLCP9acKn1o9fUEDcAWDz8aporRt+9cQy0p8mjHsWAADwLAAAAEEAAAAEAQCAoGchAAD0LAAADIHQpAIADIEAUCsSDNpACwA2AK2EIaOVgLoCAACUBZCVAACAKBssIMqGFQAAoKoAjIMLAAAAAAgYIyB8BAUAAAAACPMJkN91ZAAA5O6kwzCtdAyIVd0cLi4KAAAAIFbD4uFiAbW5mu42AAAAAFBPwd1DoIEjgNNF7W4WQAEABwACODxdPcXIAAIHAEEBflr9/A0FxAULtD9eJWl006snRuXfq8Rp9fM3FBAXLND+eJWk0U2vnhiVf68STM8CAACeBQAAIAgAAIAgAAAQ9CwAAOhpAQBgCITGOgAwBAJAYwYYZFGoFgEAZFEAKCsBhkDIGgAoqwAAAFVAVCUAAKhU1aCIhgAAIMoacKNGVAEAAABwRBRQXEUUAAAAABUxCGAMRgAAAABNpWMnaZOWmGpxt7kAAAAAIBimq9pAbOLuYgMAAAAAww0300VBgAMRD0+HmAAAZAAAAKvdZsNUAAcoaAAgA04BXkr9+EIC4gQD2J/XRWjmV0/syr0xpdSPLyQgTjCA/XldhGZ+9cSu3BvD9CwAAOBZAAAAggAAAAgCgAQIehYAAPQsAAAIQQAAMAQCQJNMMMiiUDTNBABZFACyHmBIyCoAACAKoCIBACCLBjMhGxYAACCzAhQFAAAAYMBRFMUYAwAAAAAorg5gPZTJOI4yzhiM0hI1TZvhBgAAAIAY4mZxNcBQV1dXAAAAAAA3u4u7h4ICIYOni7u7qwGAAqAAAIhaHKI2ICCGXe2mAQBAgwwAAQIKQK6ZuREA/hm9dyCg9xrQforH3TSBf2dENdKfM5/RewcCeq8B7ad43E0T+HdGVCP9OWN6WgAA5CkANERJCAYAAIBgAADIAD0LAAB6WgAAmCBCUW8sAMAQCEBqWouAQRZFaigBgDaBSBgCIeoBAFkAwAiou6s4LqqIGgAAKMsKKKsCAAColIgbQV3ECAAACIBRQVzVjYhBVQEAAADJ55chBhUXEQEAIgmZOXNmTSNLthmTjNOZM8cMw2RIa9pdPRx2Q01VBZGNquHTq2oALBfQxKcAh/zVDReL4SEqIgBAbqcKYhiGgdXqblocygIAdL6s7qbaDKfdNE0FAQ4AVFVxeLi7W51DAgIAAwSWDoAPoHUAAt6YvDUqoHcE7If29ZNi2H/k+ir/85yQNiZvjQroHQH7oX39pBj2H7m+yv88J6QWi7cXgKFPJtNOABIEEGVEvUljJckAbdhetBOgpwFkZFbqtWqAUBgysL2AQR2gHoDYE3Dld12P18HkOuY1r+M4Hr/HAAAVBRejiCN4HE/QLOAGPJhMgAJi1BhXgwCAyZUCmOuHZuTMkTUia47sGdIs2TPajKwZqUiTNOKl/1fyvHS8fOn/1QGU+5U0SaOSzCxpmiNntsxI0LhZ+/0dmt1CVf8HNAXKl24AoM0D7jsIAMAASbPkmpvssuTMktIgALMAUESaJXuGzCyZQQBwgEZl5JqbnBlvgIyT0TAdSgG+6Px/rn+NclEGFGDR+f9c/xrlogwoAKjPiKKfIvRhGKYgzZLZbDkz2hC4djgeCVkXEKJlXz1uAosCujLkrDz6p0CZorVVOjvIQOAp3aVcLyCErGACSRKImCRMETeKzA6cFNd2X3KG1pyLgOnTDtnHXMSpVY1A6IXSjlNoh70ubc2VzXgfgd6uEQOBEmCt1O4wOHBQB2ANvtj8f65/jXKiAkiwWGz+P9e/RjlRASRYAODhfxqlH5QGhuxAobUGtOqEll3GqBEhYLIJQLMr6oQooHFcGpIsDK4yPg3UfMJtO/hTFVma3lrt+JI/EFBxbvlT2OiH0mhEfBofQDudLtq0lTiGSOKaVl6peD3XTDACuSXYNQAp4JoD7wjgUAC+2Px/rn+NcqIMKDBebP4/179GOVEGFBgDQPD/fxBW4I7k5DEgDtxdcwFpcNNx+JoDICRCTtO253ANTbn7DmF+TXalagLadQ23yhGw1Pj7SzpOajGmpeeYyqUY1/Y6KfuTVOU5cvu0gW2boGlMfFv5TejrOmkOl0iEpuQMpAYBB09nZ1MABINhAAAAAAAAVQ8aaQMAAAB/dp+bB5afkaKgrlp+2Px/rn+NchECSMBh8/+5/jXKRQggAQAI/tMRHf0LRqDj05brTRlASvIy1PwPFcajBhcoY0BtuEqvBZw0c0jJRaZ4n0f7fOKW0Y8QZ/M7xFeaGJktZ2ePGFTOLl4XzRCQMnJET4bVsFhMiiHf5vXtJ9vtMsf/Wzy030v3dqzCbkfN7af9JmpkTSXXICMpLAVO16AZoAF+2Px/rn91uQgGDOCw+f9c/+pyEQwYAACCH51SxFCg6SCEBi5Yzvla/iwJC4ekcPjs4PTWuY3tqJ0BKbo3cSYE4Oxo+TYjMXbYRhO+7lamNITiY2u0SUbFcZRMTaC5sUlWteBp+ZP4wUl9lzksq8hUQ5JOZZBAjfd98+8O6pvScEnEsrp/Z5BczwfWpkx5PwQ37EoIH7fMBgYGgusZAQN+2Px/rn91uQgGFOCw+f9c/+pyEQwoAPD/I8YfOD1cxsESTiLRCq0XjEpMtryCW+ZYCL2OrG5/pdkExMrQmjY9KVY4h4vfDR0No9dovrC2mxka1Pr0+Mu09SplWO6YXqWclpXdoVKuagQllrWfCaGA0R7bvLk41ZsRTBiieZFaqyFRFbasq0GwHT0MKbUIB2QAftj8f65/NbkIAQxwOGz+P9e/mlyEAAY4gEcfPYMyMh8UBxBogIAtTU0qrERaVBLhCkJQ3MmgzZNrxplCg6xVj5AdH8J2IE3bUNgyuD86evYivJmI+NREqmWbKqosI6xblSnNmJJUum+0qsMe4o8fIeCXELdErT52+KQtXSIl3XJNKOKv3BnKtS2cKmmnGpCqP/5YNQ9MCB2P8VUnCJiYDEAAXrj8f65/jXIiGJCAwuX/c/1rlBPBgAQA/ymlCDEi+hsNB2RoT865unFOQZiOpcy11YPQ6BiMettS0AZ0JqI4PV/Neludd25CqZDuiL82RhzdohJXt36nH+HlZiHE5ILqVSQL+T5/0h9qFzBVn0OFT9herDG3XzXz299VNY2RkejrK96EGyybKbXyG3IUUv5QEvq2bAP5CjJa9IiDeD5OOF64/H8uf3W5lAAmULj8fy5/dbmUACYAPEIfUcpgMGh0GgjCGlzQcHwGnb9HCrHg86LPrV1SbrhY+nX/N41X2DMb5NsNtkcRS9rs95w9uDtvP+KP/MupnfH3yHIbPG/1zDBygJimTvFcZywqne6OX18E1zluma5AShnVx4aqfxLo6K/C8P2fxH5cuaqtqE3Lbru4hT4283zc0Hqv2xINtisxZXBVfQuOAK6kCHjBAF6o/H+uf09ycQK6w6IA40Ll/3P9e5KLE9AdFgUYAwAAAgAAgDD4g+AgXAEEyAAEoADiPAAIcHGccHEAxN271+bn5+dt4B2YmGziAIrZMgZ4l2nedkACHggIAA=="></audio>
    </template>
  </div>


<script jstcache="0">// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This file defines a singleton which provides access to all data
 * that is available as soon as the page's resources are loaded (before DOM
 * content has finished loading). This data includes both localized strings and
 * any data that is important to have ready from a very early stage (e.g. things
 * that must be displayed right away).
 *
 * Note that loadTimeData is not guaranteed to be consistent between page
 * refreshes (https://crbug.com/740629) and should not contain values that might
 * change if the page is re-opened later.
 */

// #import {assert} from './assert.m.js';
// #import {parseHtmlSubset} from './parse_html_subset.m.js';

/**
 * @typedef {{
 *   substitutions: (Array<string>|undefined),
 *   attrs: (Object<function(Node, string):boolean>|undefined),
 *   tags: (Array<string>|undefined),
 * }}
 */
/* #export */ let SanitizeInnerHtmlOpts;

// eslint-disable-next-line no-var
/* #export */ /** @type {!LoadTimeData} */ var loadTimeData;

// Expose this type globally as a temporary work around until
// https://github.com/google/closure-compiler/issues/544 is fixed.
/** @constructor */
function LoadTimeData(){}

(function() {
  'use strict';

  LoadTimeData.prototype = {
    /**
     * Sets the backing object.
     *
     * Note that there is no getter for |data_| to discourage abuse of the form:
     *
     *     var value = loadTimeData.data()['key'];
     *
     * @param {Object} value The de-serialized page data.
     */
    set data(value) {
      expect(!this.data_, 'Re-setting data.');
      this.data_ = value;
    },

    /**
     * Returns a JsEvalContext for |data_|.
     * @returns {JsEvalContext}
     */
    createJsEvalContext: function() {
      return new JsEvalContext(this.data_);
    },

    /**
     * @param {string} id An ID of a value that might exist.
     * @return {boolean} True if |id| is a key in the dictionary.
     */
    valueExists: function(id) {
      return id in this.data_;
    },

    /**
     * Fetches a value, expecting that it exists.
     * @param {string} id The key that identifies the desired value.
     * @return {*} The corresponding value.
     */
    getValue: function(id) {
      expect(this.data_, 'No data. Did you remember to include strings.js?');
      const value = this.data_[id];
      expect(typeof value != 'undefined', 'Could not find value for ' + id);
      return value;
    },

    /**
     * As above, but also makes sure that the value is a string.
     * @param {string} id The key that identifies the desired string.
     * @return {string} The corresponding string value.
     */
    getString: function(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'string');
      return /** @type {string} */ (value);
    },

    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument.
     * @param {string} id The ID of the string we want.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    getStringF: function(id, var_args) {
      const value = this.getString(id);
      if (!value) {
        return '';
      }

      const args = Array.prototype.slice.call(arguments);
      args[0] = value;
      return this.substituteString.apply(this, args);
    },

    /**
     * Make a string safe for use with with Polymer bindings that are
     * inner-h-t-m-l (or other innerHTML use).
     * @param {string} rawString The unsanitized string.
     * @param {SanitizeInnerHtmlOpts=} opts Optional additional allowed tags and
     *     attributes.
     * @return {string}
     */
    sanitizeInnerHtml: function(rawString, opts) {
      opts = opts || {};
      return parseHtmlSubset('<b>' + rawString + '</b>', opts.tags, opts.attrs)
          .firstChild.innerHTML;
    },

    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument. Any standalone $ signs must be escaped as
     * $$.
     * @param {string} label The label to substitute through.
     *     This is not an resource ID.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    substituteString: function(label, var_args) {
      const varArgs = arguments;
      return label.replace(/\$(.|$|\n)/g, function(m) {
        assert(m.match(/\$[$1-9]/), 'Unescaped $ found in localized string.');
        return m == '$$' ? '$' : varArgs[m[1]];
      });
    },

    /**
     * Returns a formatted string where $1 to $9 are replaced by the second to
     * tenth argument, split apart into a list of pieces describing how the
     * substitution was performed. Any standalone $ signs must be escaped as $$.
     * @param {string} label A localized string to substitute through.
     *     This is not an resource ID.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {!Array<!{value: string, arg: (null|string)}>} The formatted
     *     string pieces.
     */
    getSubstitutedStringPieces: function(label, var_args) {
      const varArgs = arguments;
      // Split the string by separately matching all occurrences of $1-9 and of
      // non $1-9 pieces.
      const pieces = (label.match(/(\$[1-9])|(([^$]|\$([^1-9]|$))+)/g) ||
                      []).map(function(p) {
        // Pieces that are not $1-9 should be returned after replacing $$
        // with $.
        if (!p.match(/^\$[1-9]$/)) {
          assert(
              (p.match(/\$/g) || []).length % 2 == 0,
              'Unescaped $ found in localized string.');
          return {value: p.replace(/\$\$/g, '$'), arg: null};
        }

        // Otherwise, return the substitution value.
        return {value: varArgs[p[1]], arg: p};
      });

      return pieces;
    },

    /**
     * As above, but also makes sure that the value is a boolean.
     * @param {string} id The key that identifies the desired boolean.
     * @return {boolean} The corresponding boolean value.
     */
    getBoolean: function(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'boolean');
      return /** @type {boolean} */ (value);
    },

    /**
     * As above, but also makes sure that the value is an integer.
     * @param {string} id The key that identifies the desired number.
     * @return {number} The corresponding number value.
     */
    getInteger: function(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'number');
      expect(value == Math.floor(value), 'Number isn\'t integer: ' + value);
      return /** @type {number} */ (value);
    },

    /**
     * Override values in loadTimeData with the values found in |replacements|.
     * @param {Object} replacements The dictionary object of keys to replace.
     */
    overrideValues: function(replacements) {
      expect(
          typeof replacements == 'object',
          'Replacements must be a dictionary object.');
      for (const key in replacements) {
        this.data_[key] = replacements[key];
      }
    }
  };

  /**
   * Checks condition, displays error message if expectation fails.
   * @param {*} condition The condition to check for truthiness.
   * @param {string} message The message to display if the check fails.
   */
  function expect(condition, message) {
    if (!condition) {
      console.error(
          'Unexpected condition on ' + document.location.href + ': ' + message);
    }
  }

  /**
   * Checks that the given value has the given type.
   * @param {string} id The id of the value (only used for error message).
   * @param {*} value The value to check the type on.
   * @param {string} type The type we expect |value| to be.
   */
  function expectIsType(id, value, type) {
    expect(
        typeof value == type, '[' + value + '] (' + id + ') is not a ' + type);
  }

  expect(!loadTimeData, 'should only include this file once');
  loadTimeData = new LoadTimeData;

  // Expose |loadTimeData| directly on |window|. This is only necessary by the
  // auto-generated load_time_data.m.js, since within a JS module the scope is
  // local.
  window.loadTimeData = loadTimeData;
})();
</script><script jstcache="0">loadTimeData.data = {"details":"Details","errorCode":"HTTP ERROR 404","fontfamily":"system-ui, sans-serif","fontsize":"75%","heading":{"hostName":"www.hackerrank.com","msg":"This \u003Cspan jscontent=\"hostName\">\u003C/span> page can’t be found"},"hideDetails":"Hide details","iconClass":"icon-generic","language":"en","reloadButton":{"msg":"Reload","reloadTrackingId":-1,"reloadUrl":"https://www.hackerrank.com/rest/contests/master/challenges/alternating-characters/hackers/[deleted]/download_solution?primary=true"},"suggestionsDetails":[],"suggestionsSummaryList":[],"summary":{"failedUrl":"https://www.hackerrank.com/rest/contests/master/challenges/alternating-characters/hackers/[deleted]/download_solution?primary=true","hostName":"www.hackerrank.com","msg":"No webpage was found for the web address: \u003Cstrong jscontent=\"failedUrl\">\u003C/strong>"},"textdirection":"ltr","title":"www.hackerrank.com"};</script><script jstcache="0">// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file serves as a proxy to bring the included js file from /third_party
// into its correct location under the resources directory tree, whence it is
// delivered via a chrome://resources URL.  See ../webui_resources.grd.

// Note: this <include> is not behind a single-line comment because the first
// line of the file is source code (so the first line would be skipped) instead
// of a licence header.
// clang-format off
(function(){var i=null;function k(){return Function.prototype.call.apply(Array.prototype.slice,arguments)}function l(a,b){var c=k(arguments,2);return function(){return b.apply(a,c)}}function m(a,b){var c=new n(b);for(c.f=[a];c.f.length;){var e=c,d=c.f.shift();e.g(d);for(d=d.firstChild;d;d=d.nextSibling)d.nodeType==1&&e.f.push(d)}}function n(a){this.g=a}function o(a){a.style.display=""}function p(a){a.style.display="none"};var q=":",r=/\s*;\s*/;function s(){this.i.apply(this,arguments)}s.prototype.i=function(a,b){if(!this.a)this.a={};if(b){var c=this.a,e=b.a,d;for(d in e)c[d]=e[d]}else for(c in d=this.a,e=t,e)d[c]=e[c];this.a.$this=a;this.a.$context=this;this.d=typeof a!="undefined"&&a!=i?a:"";if(!b)this.a.$top=this.d};var t={$default:i},u=[];function v(a){for(var b in a.a)delete a.a[b];a.d=i;u.push(a)}function w(a,b,c){try{return b.call(c,a.a,a.d)}catch(e){return t.$default}}
function x(a,b,c,e){if(u.length>0){var d=u.pop();s.call(d,b,a);a=d}else a=new s(b,a);a.a.$index=c;a.a.$count=e;return a}var y="a_",z="b_",A="with (a_) with (b_) return ",D={};function E(a){if(!D[a])try{D[a]=new Function(y,z,A+a)}catch(b){}return D[a]}function F(a){for(var b=[],a=a.split(r),c=0,e=a.length;c<e;++c){var d=a[c].indexOf(q);if(!(d<0)){var f;f=a[c].substr(0,d).replace(/^\s+/,"").replace(/\s+$/,"");d=E(a[c].substr(d+1));b.push(f,d)}}return b};var G="jsinstance",H="jsts",I="*",J="div",K="id";function L(){}var M=0,N={0:{}},P={},Q={},R=[];function S(a){a.__jstcache||m(a,function(a){T(a)})}var U=[["jsselect",E],["jsdisplay",E],["jsvalues",F],["jsvars",F],["jseval",function(a){for(var b=[],a=a.split(r),c=0,e=a.length;c<e;++c)if(a[c]){var d=E(a[c]);b.push(d)}return b}],["transclude",function(a){return a}],["jscontent",E],["jsskip",E]];
function T(a){if(a.__jstcache)return a.__jstcache;var b=a.getAttribute("jstcache");if(b!=i)return a.__jstcache=N[b];for(var b=R.length=0,c=U.length;b<c;++b){var e=U[b][0],d=a.getAttribute(e);Q[e]=d;d!=i&&R.push(e+"="+d)}if(R.length==0)return a.setAttribute("jstcache","0"),a.__jstcache=N[0];var f=R.join("&");if(b=P[f])return a.setAttribute("jstcache",b),a.__jstcache=N[b];for(var h={},b=0,c=U.length;b<c;++b){var d=U[b],e=d[0],g=d[1],d=Q[e];d!=i&&(h[e]=g(d))}b=""+ ++M;a.setAttribute("jstcache",b);N[b]=
h;P[f]=b;return a.__jstcache=h}function V(a,b){a.h.push(b);a.k.push(0)}function W(a){return a.c.length?a.c.pop():[]}
L.prototype.e=function(a,b){var c=X(b),e=c.transclude;if(e)(c=Y(e))?(b.parentNode.replaceChild(c,b),e=W(this),e.push(this.e,a,c),V(this,e)):b.parentNode.removeChild(b);else if(c=c.jsselect){var c=w(a,c,b),d=b.getAttribute(G),f=!1;d&&(d.charAt(0)==I?(d=parseInt(d.substr(1),10),f=!0):d=parseInt(d,10));var h=c!=i&&typeof c=="object"&&typeof c.length=="number",e=h?c.length:1,g=h&&e==0;if(h)if(g)d?b.parentNode.removeChild(b):(b.setAttribute(G,"*0"),p(b));else if(o(b),d===i||d===""||f&&d<e-1){f=W(this);
d=d||0;for(h=e-1;d<h;++d){var j=b.cloneNode(!0);b.parentNode.insertBefore(j,b);Z(j,c,d);g=x(a,c[d],d,e);f.push(this.b,g,j,v,g,i)}Z(b,c,d);g=x(a,c[d],d,e);f.push(this.b,g,b,v,g,i);V(this,f)}else d<e?(f=c[d],Z(b,c,d),g=x(a,f,d,e),f=W(this),f.push(this.b,g,b,v,g,i),V(this,f)):b.parentNode.removeChild(b);else c==i?p(b):(o(b),g=x(a,c,0,1),f=W(this),f.push(this.b,g,b,v,g,i),V(this,f))}else this.b(a,b)};
L.prototype.b=function(a,b){var c=X(b),e=c.jsdisplay;if(e){if(!w(a,e,b)){p(b);return}o(b)}if(e=c.jsvars)for(var d=0,f=e.length;d<f;d+=2){var h=e[d],g=w(a,e[d+1],b);a.a[h]=g}if(e=c.jsvalues){d=0;for(f=e.length;d<f;d+=2)if(g=e[d],h=w(a,e[d+1],b),g.charAt(0)=="$")a.a[g]=h;else if(g.charAt(0)=="."){for(var g=g.substr(1).split("."),j=b,O=g.length,B=0,$=O-1;B<$;++B){var C=g[B];j[C]||(j[C]={});j=j[C]}j[g[O-1]]=h}else g&&(typeof h=="boolean"?h?b.setAttribute(g,g):b.removeAttribute(g):b.setAttribute(g,""+
h))}if(e=c.jseval){d=0;for(f=e.length;d<f;++d)w(a,e[d],b)}e=c.jsskip;if(!e||!w(a,e,b))if(c=c.jscontent){if(c=""+w(a,c,b),b.innerHTML!=c){for(;b.firstChild;)e=b.firstChild,e.parentNode.removeChild(e);b.appendChild(this.j.createTextNode(c))}}else{c=W(this);for(e=b.firstChild;e;e=e.nextSibling)e.nodeType==1&&c.push(this.e,a,e);c.length&&V(this,c)}};function X(a){if(a.__jstcache)return a.__jstcache;var b=a.getAttribute("jstcache");if(b)return a.__jstcache=N[b];return T(a)}
function Y(a,b){var c=document;if(b){var e=c.getElementById(a);if(!e){var e=b(),d=H,f=c.getElementById(d);if(!f)f=c.createElement(J),f.id=d,p(f),f.style.position="absolute",c.body.appendChild(f);d=c.createElement(J);f.appendChild(d);d.innerHTML=e;e=c.getElementById(a)}c=e}else c=c.getElementById(a);return c?(S(c),c=c.cloneNode(!0),c.removeAttribute(K),c):i}function Z(a,b,c){c==b.length-1?a.setAttribute(G,I+c):a.setAttribute(G,""+c)};window.jstGetTemplate=Y;window.JsEvalContext=s;window.jstProcess=function(a,b){var c=new L;S(b);c.j=b?b.nodeType==9?b:b.ownerDocument||document:document;var e=l(c,c.e,a,b),d=c.h=[],f=c.k=[];c.c=[];e();for(var h,g,j;d.length;)h=d[d.length-1],e=f[f.length-1],e>=h.length?(e=c,g=d.pop(),g.length=0,e.c.push(g),f.pop()):(g=h[e++],j=h[e++],h=h[e++],f[f.length-1]=e,g.call(c,j,h))};
})()
</script><script jstcache="0">var tp = document.getElementById('t');jstProcess(loadTimeData.createJsEvalContext(), tp);</script>
----------
====================
----------
ALGORITHMS.99
medium
----------
PROBLEM STATEMENT:
In this challenge you need to print the string that accompanies each integer in a list sorted by the integers. If two strings are associated with the same integer, they must be printed in their original order so your sorting algorithm should be stable.  There is one other twist.  The first half of the strings encountered in the inputs are to be replaced with the character "[expression].

Insertion Sort and the simple version of Quicksort are stable, but the faster in-place version of Quicksort is not since it scrambles around elements while sorting. 

In this challenge, you will use counting sort to sort a list while keeping the order of the strings preserved. 

For example, if your inputs are [expression] you could set up a helper array with three empty arrays as elements.  The following shows the insertions:

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



The result is then printed: [expression] . 

Function Description  

Complete the countSort function in the editor below.  It should construct and print out the sorted strings.  

countSort has the following parameter(s):


arr: a 2D array where each arr[i] is comprised of two strings: x and s.  


Note: The first element of each [expression], must be cast as an integer to perform the sort.  
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;list&gt;
using namespace std;


vector&lt;string&gt; a[100];
char str[100007];
int n,i,j,x;

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    
    
    cin&gt;&gt;n;
    for(i=0;i&lt;n/2;i++)
    {
        cin&gt;&gt;x;
        cin&gt;&gt;str;
        a[x].push_back("-");
    
    }
    
    for(;i&lt;n;i++)
    {
        cin&gt;&gt;x;
        cin&gt;&gt;str;
        a[x].push_back(str);
    
    }
    
    for(i=0;i&lt;100;i++)
    {
        x=a[i].size();
        for(j=0;j&lt;x;j++)
            cout&lt;&lt;a[i][j]&lt;&lt;" ";    
    }
    return 0;

}
----------
====================
----------
ALGORITHMS.100
easy
----------
PROBLEM STATEMENT:
Alice has a binary string. She thinks a binary string is beautiful if and only if it doesn't contain the substring [expression]. 

In one step, Alice can change a [expression] or vice versa. Count and print the minimum number of steps needed to make Alice see the string as beautiful.

For example, if Alice's string is [expression] she can change any one element and have a beautiful string.

Function Description  

Complete the beautifulBinaryString function in the editor below.  It should return an integer representing the minimum moves required.  

beautifulBinaryString has the following parameter(s):  


b: a string of binary digits  

----------
TOP SOLUTION:
----------
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;
#include &lt;cstdio&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_map&gt;

using namespace std;

char B[105];

int main(){
    int n;
    int ans=0;
    scanf("%d", &amp;n);
    scanf("%s", B);
    for(int i=2; B[i]; i++){
        if(B[i-2] == '0' &amp;&amp; B[i-1] == '1' &amp;&amp; B[i] == '0') B[i] = '1', ans++;
    }
    printf("%d", ans);
    return 0;
}

----------
====================
----------
ALGORITHMS.101
easy
----------
PROBLEM STATEMENT:
Sorting is useful as the first step in many different tasks. The most common task is to make finding things easier, but there are other uses as well.  In this case, it will make it easier to determine which pair or pairs of elements have the smallest absolute difference between them.

For example, if you've got the list [expression].

Given a list of unsorted integers, [expression], find the pair of elements that have the smallest absolute difference between them. If there are multiple pairs, find them all.

Function Description  

Complete the closestNumbers function in the editor below.  It must return an array of integers as described.

closestNumbers has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
# Enter your code here. Read input from STDIN. Print output to STDOUT

def main():
    n = input()
    arr = sorted(map(int, raw_input().split()))
    diff = 10**8
    prev = arr.pop(0)
    for i in arr:
        if i-prev&lt;diff:
            ans = [prev,i]
            diff = i-prev
        elif i-prev==diff:
            ans.append(prev)
            ans.append(i)
        prev = i
    ans.sort()
    print " ".join(map(str,ans))
    
if __name__ == '__main__':
    main()
----------
====================
----------
ALGORITHMS.102
easy
----------
PROBLEM STATEMENT:
James found a love letter that his friend Harry has written to his girlfriend. James is a prankster, so he decides to meddle with the letter. He changes all the words in the letter into palindromes.   

To do this, he follows two rules:  


He can only reduce the value of a letter by [expression], i.e. he can change d to c, but he cannot change c to d or d to b.  
The letter a may not be reduced any further.  


Each reduction in the value of any letter is counted as a single operation. Find the minimum number of operations required to convert a given string into a palindrome.

For example, given the string [expression], the following two operations are performed:  cde → cdd → cdc.  

Function Description  

Complete the theLoveLetterMystery function in the editor below.  It should return the integer representing the minimum number of operations needed to make the string a palindrome.  

theLoveLetterMystery has the following parameter(s):  


s: a string

----------
TOP SOLUTION:
----------
import java.util.Scanner;


public class Solution {

	/**
	 * @param args
	 */
	public static void main(String[] args) 
	{
		Scanner scan = new Scanner(System.in);
		int T = scan.nextInt();scan.nextLine();
		
		for(int i=0;i&lt;T;i++)
		{
			String s = scan.nextLine();
			int count=0;
			for(int j=0;j&lt;s.length()/2;j++)
				count+=Math.abs(s.charAt(j)-s.charAt(s.length()-1-j));
			System.out.println(count);
		}
	}
}

----------
====================
----------
ALGORITHMS.103
easy
----------
PROBLEM STATEMENT:
The median of a list of numbers is essentially it's middle element after sorting.  The same number of elements occur after it as before.  Given a list of numbers with an odd number of elements, can you find the median?

For example, the median of [expression], the middle element in the sorted array.

Function Description

Complete the findMedian function in the editor below.  It must return an integer that represents the median of the array. 

findMedian has the following parameter(s):  


arr: an unsorted array of integers

----------
TOP SOLUTION:
----------
import math
def main():
    testcase = int(input())
    med = [int(i) for i in input().split()]
    print(findmed(med))
    
def findmed(med):
    med.sort()
    if(len(med)%2 == 1):
        return med[int(len(med)/2)]
    else:
        return (med[math.floor(len(med)/2)+math.ceil(len(med)/2)])/2
main()
----------
====================
----------
ALGORITHMS.104
hard
----------
PROBLEM STATEMENT:
DNA is a nucleic acid present in the bodies of living things. Each piece of DNA contains a number of genes, some of which are beneficial and increase the DNA's total health. Each gene has a health value, and the total health of a DNA is the sum of the health values of all the beneficial genes that occur as a substring in the DNA. We represent genes and DNA as non-empty strings of lowercase English alphabetic letters, and the same gene may appear multiple times as a susbtring of a DNA.

Given the following:


An array of beneficial gene strings, [expression]. Note that these gene sequences are not guaranteed to be distinct.
An array of gene health values, [expression].
A set of [expression] are healthy.


Find and print the respective total healths of the unhealthiest (minimum total health) and  healthiest (maximum total health) strands of DNA as two space-separated values on a single line.
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; static void amin(T &amp;x, U y) { if (y &lt; x) x = y; }
template&lt;typename T, typename U&gt; static void amax(T &amp;x, U y) { if (x &lt; y) x = y; }

class IncrementalAhoCorasic {
	static const int Alphabets = 26;
	static const int AlphabetBase = 'a';
	struct Node {
		Node *fail;
		Node *next[Alphabets];
		long long sum;
		Node() : fail(NULL), next{}, sum(0) { }
	};

	struct String {
		string str;
		int weight;
	};

public:
	//totalLen = sum of (len + 1)
	void init(int totalLen) {
		nodes.resize(totalLen);
		nNodes = 0;
		strings.clear();
		roots.clear();
		sizes.clear();
		que.resize(totalLen);
	}

	void insert(const string &amp;str, int weight) {
		strings.push_back(String{ str, weight });
		roots.push_back(nodes.data() + nNodes);
		sizes.push_back(1);
		nNodes += (int)str.size() + 1;
		auto check = [&amp;]() { return sizes.size() &gt; 1 &amp;&amp; sizes.end()[-1] == sizes.end()[-2]; };
		if (!check())
			makePMA(strings.end() - 1, strings.end(), roots.back(), que);
		while (check()) {
			int m = sizes.back();
			roots.pop_back();
			sizes.pop_back();
			sizes.back() += m;
			if (!check())
				makePMA(strings.end() - m * 2, strings.end(), roots.back(), que);
		}
	}

	long long match(const string &amp;str) const {
		long long res = 0;
		for (const Node *t : roots)
			res += matchPMA(t, str);
		return res;
	}

private:
	static void makePMA(vector&lt;String&gt;::const_iterator begin, vector&lt;String&gt;::const_iterator end, Node *nodes, vector&lt;Node*&gt; &amp;que) {
		int nNodes = 0;
		Node *root = new(&amp;nodes[nNodes ++]) Node();
		for (auto it = begin; it != end; ++ it) {
			Node *t = root;
			for (char c : it-&gt;str) {
				Node *&amp;n = t-&gt;next[c - AlphabetBase];
				if (n == nullptr)
					n = new(&amp;nodes[nNodes ++]) Node();
				t = n;
			}
			t-&gt;sum += it-&gt;weight;
		}
		int qt = 0;
		for (Node *&amp;n : root-&gt;next) {
			if (n != nullptr) {
				n-&gt;fail = root;
				que[qt ++] = n;
			} else {
				n = root;
			}
		}
		for (int qh = 0; qh != qt; ++ qh) {
			Node *t = que[qh];
			int a = 0;
			for (Node *n : t-&gt;next) {
				if (n != nullptr) {
					que[qt ++] = n;
					Node *r = t-&gt;fail;
					while (r-&gt;next[a] == nullptr)
						r = r-&gt;fail;
					n-&gt;fail = r-&gt;next[a];
					n-&gt;sum += r-&gt;next[a]-&gt;sum;
				}
				++ a;
			}
		}
	}

	static long long matchPMA(const Node *t, const string &amp;str) {
		long long res = 0;
		for (char c : str) {
			int a = c - AlphabetBase;
			while (t-&gt;next[a] == nullptr)
				t = t-&gt;fail;
			t = t-&gt;next[a];
			res += t-&gt;sum;
		}
		return res;
	}


	vector&lt;Node&gt; nodes;
	int nNodes;
	vector&lt;String&gt; strings;
	vector&lt;Node*&gt; roots;
	vector&lt;int&gt; sizes;
	vector&lt;Node*&gt; que;
};

int main() {
	int n;
	static char buf[2000001];
	while (~scanf("%d", &amp;n)) {
		vector&lt;string&gt; patterns(n);
		int totalLen = 0;
		rep(i, n) {
			scanf("%s", buf);
			patterns[i] = buf;
			totalLen += (int)patterns[i].size() + 1;
		}
		vector&lt;int&gt; values(n);
		for (int i = 0; i &lt; n; ++ i)
			scanf("%d", &amp;values[i]);
		int Q;
		scanf("%d", &amp;Q);
		vector&lt;string&gt; strings(Q);
		vector&lt;vector&lt;int&gt;&gt; queries(n + 1);
		rep(i, Q) {
			int L; int R;
			scanf("%d%d", &amp;L, &amp;R), ++ R;
			scanf("%s", buf);
			strings[i] = buf;
			queries[L].push_back(i * 2 + 0);
			queries[R].push_back(i * 2 + 1);
		}
		IncrementalAhoCorasic iac;
		iac.init(totalLen);
		vector&lt;long long&gt; ans(Q, 0);
		rep(i, n) {
			iac.insert(patterns[i], values[i]);
			for (int qi : queries[i + 1])
				ans[qi / 2] += iac.match(strings[qi / 2]) * (qi % 2 == 0 ? -1 : 1);
		}
		long long minSum = INFL, maxSum = -INFL;
		rep(i, Q) {
			amin(minSum, ans[i]);
			amax(maxSum, ans[i]);
		}
		printf("%lld %lld\n", minSum, maxSum);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.105
advanced
----------
PROBLEM STATEMENT:
Insertion Sort is a simple sorting technique which was covered in previous challenges. Sometimes, arrays may be too large for us to wait around for insertion sort to finish. Is there some other way we can calculate the number of shifts an Insertion Sort performs when sorting an array?

If [expression].  

[expression]
[expression]	
[expression]
[expression]
[expression]

[expression]



Function description  

Complete the insertionSort function in the editor below.  It should return an integer that represents the number of shifts required to sort the given array.  

insertionSort has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;deque&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;stack&gt;
#include&lt;sstream&gt;
#include&lt;fstream&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cassert&gt;
#define CLRM(x) memset(x,-1,sizeof(x))
#define CLR(x) memset(x,0,sizeof(x))
#define ALL(x) x.begin(),x.end()
#define GI(x) scanf("%d", &amp;x);
#define FORN(i, n) for(int i = 0; i &lt; n; i++)
#define FOR(i, start, end) for(int i = start; i &lt; end; i++)
#define PB push_back
#define MP make_pair
#define VI vector&lt;int&gt; 
#define VVI vector&lt;vector&lt;int&gt; &gt;
#define PII pair&lt;int,int&gt;
#define SZ(x) (int)x.size()
#define LL long long
#define MIN(a,b) (a)&lt;(b)?(a):(b)
#define MAX(a,b) (a)&gt;(b)?(a):(b)
#define LMAX 1000000000000000000LL
#define IMAX 1000000000
using namespace std;

#define MAXN 110000
int N;
int d[MAXN];

LL mergesort(int low, int high)
{
	if(low &gt;= high)
		return 0;
	
	int mid = (low+high)/2;

	LL ret = 0;
	ret = mergesort(low, mid) + mergesort(mid+1, high);
	vector&lt;int&gt; v;
	int i, j, k;
	i = low; j = mid + 1;
	while(i &lt;= mid &amp;&amp; j &lt;= high)
	{
		if(d[i] &gt; d[j])
		{
			v.PB(d[j]);
			ret+=(LL)(mid-i+1);
			j++;
		}
		else
		{
			v.PB(d[i]);
			i++;
		}
	}
	while(i &lt;= mid)
	{
		v.PB(d[i]);
		i++;
	}
	while(j &lt;= high)
	{
		v.PB(d[j]);
		j++;
	}
	for(i = 0; i &lt; v.size(); i++)
	{
		d[i + low] = v[i];
	}
	return ret;
}
LL solve()
{
	LL ret = mergesort(0, N-1);
	return ret;
}
int main()
{
	int tes;
	GI(tes);
	while(tes--)
	{
		int i;
		GI(N);
		FORN(i, N)
		{
			GI(d[i]);
		}
		LL ans = solve();
		printf("%lld\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.106
easy
----------
PROBLEM STATEMENT:
Given a string of lowercase letters in the range ascii[a-z], determine a character that can be removed to make the string a palindrome.  There may be more than one solution, but any will do.  For example, if your string is "bcbc", you can either remove 'b' at index [expression].  If the word is already a palindrome or there is no solution, return -1.  Otherwise, return the index of a character to remove.  

Function Description  

Complete the palindromeIndex function in the editor below.  It must return the index of the character to remove or [expression].  

palindromeIndex has the following parameter(s):  


s: a string to analyze

----------
TOP SOLUTION:
----------
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
char a[1000005];
char b[1000005];
int is(char *a, int n){
	int i;
	for(i=0;i&lt;n/2;i++)if(a[i]!=a[n-1-i])return i;
	return -1;
}
int main(){
	int t;
	scanf("%d",&amp;t);
	while(t--){
		
		scanf("%s",&amp;a);
		int l = strlen(a);
		int x = is(a,l);
		if(x==-1){
			printf("-1\n");
		}
		else {
			int i;
			int j=0;
			for(i=0;a[i];i++){
				if(i!=x)b[j++] = a[i];
				
			
			}
				if(is(b,l-1)==-1)printf("%d\n",x);
				else printf("%d\n",l-1-x);
		}
	}
}
----------
====================
----------
ALGORITHMS.107
medium
----------
PROBLEM STATEMENT:
HackerLand National Bank has a simple policy for warning clients about possible fraudulent account activity. If the amount spent by a client on a particular day is greater than or equal to [expression] the client's median spending for a trailing number of days, they send the client a notification about potential fraud. The bank doesn't send the client any notifications until they have at least that trailing number of prior days' transaction data.

Given the number of trailing days [expression] days.

For example, [expression] so no notice will be sent.  Over the period, there was one notice sent.

Note: The median of a list of numbers can be found by arranging all the numbers from smallest to greatest. If there is an odd number of numbers, the middle one is picked. If there is an even number of numbers, median is then defined to be the average of the two middle values. (Wikipedia)

Function Description

Complete the function activityNotifications in the editor below.  It must return an integer representing the number of client notifications.  

activityNotifications has the following parameter(s):


expenditure: an array of integers representing daily expenditures  
d: an integer, the lookback days for median spending  

----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; static void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; static void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

template&lt;typename It&gt;
void make_fenwick(It beg, size_t n) {
	for(size_t i = 0; i &lt; n; i ++) {
		size_t p = i | (i + 1);
		if(p &lt; n) beg[p] += beg[i];
	}
}
template&lt;typename It, typename Val&gt;
void add_fenwick(It beg, size_t n, size_t i, Val val) {
	for(; i &lt; n; i |= i + 1) beg[i] += val;
}
template&lt;typename It, typename Val&gt;
Val sum_fenwick(It beg, size_t i, Val sum) {
	for(; i &gt; 0; i = i &amp; (i - 1)) sum += beg[i - 1];
	return sum;
}
template&lt;typename It&gt;
typename std::iterator_traits&lt;It&gt;::value_type sum_fenwick(It beg, size_t i) {
	return sum_fenwick(beg, i, typename std::iterator_traits&lt;It&gt;::value_type());
}

size_t highestOneBit(size_t v) {
	v |= v &gt;&gt; 1;
	v |= v &gt;&gt; 2;
	v |= v &gt;&gt; 4;
	v |= v &gt;&gt; 8;
	v |= v &gt;&gt; 16;
#if SIZE_MAX &gt; 0xffffffffULL
	v |= v &gt;&gt; 32;
#endif
	return (v &gt;&gt; 1) + 1;
}

template&lt;typename It, typename Val, typename Cmp&gt;
size_t search_fenwick(It beg, size_t n, Val val, Val left, Cmp cmp) {
	if(!cmp(left, val)) return 0;
	size_t i = 0;
	for(size_t w = highestOneBit(n); w &gt; 0; w &gt;&gt;= 1) {
		if(i + w &lt;= n) {
			Val mid = left;
			mid += beg[i + w - 1];
			if(cmp(mid, val)) {
				i += w;
				left = mid;
			}
		}
	}
	return i + 1;
}

template&lt;typename It, typename Val&gt;
size_t select_fenwick(It beg, size_t n, Val k) {
	return search_fenwick(beg, n, k + 1, Val(), std::less&lt;Val&gt;()) - 1;
}


int main() {
	int n; int d;
	while(~scanf("%d%d", &amp;n, &amp;d)) {
		vector&lt;int&gt; A(n);
		for(int i = 0; i &lt; n; ++ i)
			scanf("%d", &amp;A[i]);
		int X = *max_element(A.begin(), A.end());
		vector&lt;int&gt; ft(X + 1, 0);
		rep(i, d) add_fenwick(ft.begin(), ft.size(), A[i], 1);
		int ans = 0;
		rep(i, n - d) {
			int x = select_fenwick(ft.begin(), ft.size(), (d - 1) / 2);
			int y = select_fenwick(ft.begin(), ft.size(), d / 2);
			if(x + y &lt;= A[i + d])
				++ ans;
			add_fenwick(ft.begin(), ft.size(), A[i], -1);
			add_fenwick(ft.begin(), ft.size(), A[i + d], 1);
		}
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.108
easy
----------
PROBLEM STATEMENT:
Two words are anagrams of one another if their letters can be rearranged to form the other word.  

In this challenge, you will be given a string.  You must split it into two contiguous substrings, then determine the minimum number of characters to change to make the two substrings into anagrams of one another.

For example, given the string 'abccde', you would break it into two parts: 'abc' and 'cde'.  Note that all letters have been used, the substrings are contiguous and their lengths are equal.  Now you can change 'a' and 'b' in the first substring to 'd' and 'e' to have 'dec' and 'cde' which are anagrams.  Two changes were necessary.

Function Description

Complete the anagram function in the editor below.  It should return the minimum number of characters to change to make the words anagrams, or [expression] if it's not possible.  

anagram has the following parameter(s):  


s: a string  

----------
TOP SOLUTION:
----------
//Coder: Balajiganapathi
#define TRACE
#define DEBUG

#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;deque&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;numeric&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

using namespace std;

typedef long long ll;
typedef vector&lt;int&gt; vi;
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;string&gt; vs;

// Basic macros
#define st          first
#define se          second
#define all(x)      (x).begin(), (x).end()
#define ini(a, v)   memset(a, v, sizeof(a))
#define re(i,s,n)  	for(int i=s;i&lt;(n);++i)
#define rep(i,s,n)  for(int i=s;i&lt;=(n);++i)
#define fr(i,n)     re(i,0,n)
#define tr(i,x)     for(typeof(x.begin()) i=x.begin();i!=x.end();++i)
#define pu          push_back
#define mp          make_pair
#define sz(x)       (int)(x.size())

const int oo = 2000000009;
const double eps = 1e-9;



#ifdef TRACE
    #define trace1(x)                cerr &lt;&lt; #x &lt;&lt; ": " &lt;&lt; x &lt;&lt; endl;
    #define trace2(x, y)             cerr &lt;&lt; #x &lt;&lt; ": " &lt;&lt; x &lt;&lt; " | " &lt;&lt; #y &lt;&lt; ": " &lt;&lt; y &lt;&lt; endl;
    #define trace3(x, y, z)          cerr &lt;&lt; #x &lt;&lt; ": " &lt;&lt; x &lt;&lt; " | " &lt;&lt; #y &lt;&lt; ": " &lt;&lt; y &lt;&lt; " | " &lt;&lt; #z &lt;&lt; ": " &lt;&lt; z &lt;&lt; endl;
    #define trace4(a, b, c, d)       cerr &lt;&lt; #a &lt;&lt; ": " &lt;&lt; a &lt;&lt; " | " &lt;&lt; #b &lt;&lt; ": " &lt;&lt; b &lt;&lt; " | " &lt;&lt; #c &lt;&lt; ": " &lt;&lt; c &lt;&lt; " | " &lt;&lt; #d &lt;&lt; ": " &lt;&lt; d &lt;&lt; endl;
    #define trace5(a, b, c, d, e)    cerr &lt;&lt; #a &lt;&lt; ": " &lt;&lt; a &lt;&lt; " | " &lt;&lt; #b &lt;&lt; ": " &lt;&lt; b &lt;&lt; " | " &lt;&lt; #c &lt;&lt; ": " &lt;&lt; c &lt;&lt; " | " &lt;&lt; #d &lt;&lt; ": " &lt;&lt; d &lt;&lt; " | " &lt;&lt; #e &lt;&lt; ": " &lt;&lt; e &lt;&lt; endl;
    #define trace6(a, b, c, d, e, f) cerr &lt;&lt; #a &lt;&lt; ": " &lt;&lt; a &lt;&lt; " | " &lt;&lt; #b &lt;&lt; ": " &lt;&lt; b &lt;&lt; " | " &lt;&lt; #c &lt;&lt; ": " &lt;&lt; c &lt;&lt; " | " &lt;&lt; #d &lt;&lt; ": " &lt;&lt; d &lt;&lt; " | " &lt;&lt; #e &lt;&lt; ": " &lt;&lt; e &lt;&lt; " | " &lt;&lt; #f &lt;&lt; ": " &lt;&lt; f &lt;&lt; endl;

#else

    #define trace1(x)
    #define trace2(x, y)
    #define trace3(x, y, z)
    #define trace4(a, b, c, d)
    #define trace5(a, b, c, d, e)
    #define trace6(a, b, c, d, e, f)

#endif

int cnt[300];
int main() {
    int t;
    string s;
    cin &gt;&gt; t;
    while(t--) {
        cin &gt;&gt; s;
        if(sz(s) % 2 == 1) {
            printf("-1\n");
            continue;
        }
        
        ini(cnt, 0);
        fr(i, sz(s) / 2) ++cnt[s[i]];
        re(i, sz(s) / 2, sz(s)) --cnt[s[i]];
        
        int ans = 0;
        fr(i, 300) if(cnt[i] &gt; 0) ans += cnt[i];
        printf("%d\n", ans);
    }
    
	return 0;
}

----------
====================
----------
ALGORITHMS.109
easy
----------
PROBLEM STATEMENT:
We consider two strings to be anagrams of each other if the first string's letters can be rearranged to form the second string. In other words, both strings must contain the same exact letters in the same exact frequency. For example, bacdc and dcbac are anagrams, but bacdc and dcbad are not.

Alice is taking a cryptography class and finding anagrams to be very useful. She decides on an encryption scheme involving two large strings where encryption is dependent on the minimum number of character deletions required to make the two strings anagrams. Can you help her find this number? 

Given two strings, [expression] anagrams. Any characters can be deleted from either of the strings. 

For example, [expression] deletions.  

Function Description  

Complete the makingAnagrams function in the editor below.  It should return an integer representing the minimum number of deletions needed to make the strings anagrams.  

makingAnagrams has the following parameter(s):  


s1: a string  
s2: a string  

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main() {
    char s1[10010],s2[10010];
    cin&gt;&gt;s1&gt;&gt;s2;
    int a[26]={0};
    for(int i=0;i&lt;strlen(s1);i++)
        a[s1[i]-'a']++;
    for(int i=0;i&lt;strlen(s2);i++)
        a[s2[i]-'a']--;
    long long int ans = 0;
    for(int i=0;i&lt;26;i++)
        ans += abs(a[i]);
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.110
medium
----------
PROBLEM STATEMENT:
Whenever George asks Lily to hang out, she's busy doing homework. George wants to help her finish it faster, but he's in over his head! Can you help George understand Lily's homework so she can hang out with him?

Consider an array of [expression] is minimal.

Given the array [expression], determine and return the minimum number of swaps that should be performed in order to make the array beautiful.

For example, [expression].  To get there, George performed the following swaps:  

Swap      Result
      [7, 15, 12, 3]
3 7   [3, 15, 12, 7]
7 15  [3, 7, 12, 15]


It took [expression] swaps to make the array beautiful. This is minimal among the choice of beautiful arrays possible.

Function Description  

Complete the lilysHomework function in the editor below.  It should return an integer that represents the minimum number of swaps required.  

lilysHomework has the following parameter(s):  


arr: an integer array  

----------
TOP SOLUTION:
----------
SOLUTION NOT FOUND
----------
====================
----------
ALGORITHMS.111
easy
----------
PROBLEM STATEMENT:
Dothraki are planning an attack to usurp King Robert's throne. King Robert learns of this conspiracy from Raven and plans to lock the single door through which the enemy can enter his kingdom.



But, to lock the door he needs a key that is an anagram of a palindrome.  He starts to go through his box of strings, checking to see if they can be rearranged into a palindrome.

For example, given the string [expression].

Function Description  

Complete the gameOfThrones function below to determine whether a given string can be rearranged into a palindrome. If it is possible, return YES, otherwise return NO.  

gameOfThrones has the following parameter(s):  


s: a string to analyze  

----------
TOP SOLUTION:
----------
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;math.h&gt;
#include &lt;map&gt;
#include &lt;stdlib.h&gt;
using namespace std;
#define ACCEPTED 0
#define F first
#define S second
#define PI (acos(-1.0))
#define EPS (1e-11)
#define INF (1&lt;&lt;30)
int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};
/* ============================================== */

int main(){
  string s;
  cin &gt;&gt;  s;

  vector&lt;int&gt; v(256, 0);
  for(int i=0; i&lt;s.size(); i++) v[s[i]]++;

  int impar =0;
  for(int i=0; i&lt;256; i++)
    if(v[i]%2) impar++;

  if((s.size()%2 == 0 &amp;&amp; impar == 0) || (s.size()%2==1 &amp;&amp; impar == 1))
    puts("YES");
  else puts("NO");
  
  return ACCEPTED;
}
/* ============================================== */

----------
====================
----------
ALGORITHMS.112
easy
----------
PROBLEM STATEMENT:
Given two strings, determine if they share a common substring.  A substring may be as small as one character.  

For example, the words "a", "and", "art" share the common substring [expression].  The words "be" and "cat" do not share a substring.  

Function Description

Complete the function twoStrings in the editor below.  It should return a string, either YES or NO based on whether the strings share a common substring.  

twoStrings has the following parameter(s):  


s1, s2: two strings to analyze . 

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int a; cin &gt;&gt; a;
    for (int g=0;g&lt;a; g++)
    {
        string b,c; cin &gt;&gt; b &gt;&gt; c; map &lt;char,int&gt; k; 
        for (int y=0;y&lt;b.length(); y++) k[b[y]]=1; int counter=0; 
        for (int y=0;y&lt;c.length(); y++) 
        {
            if (k[c[y]]) counter=1; 
        }
        if (counter) cout &lt;&lt; "YES" &lt;&lt; '\n';
        else cout &lt;&lt; "NO" &lt;&lt; '\n'; 
    }return 0; 
}
----------
====================
----------
ALGORITHMS.113
easy
----------
PROBLEM STATEMENT:
Amanda has a string of lowercase letters that she wants to copy to a new string.  She can perform the following operations with the given costs. She can perform them any number of times to construct a new string [expression]:


Append a character to the end of string [expression] dollar. 
Choose any substring of [expression] at no charge.


Given [expression] on a new line.

For example, given a string [expression] at no cost to complete the copy.  

Function Description  

Complete the stringConstruction function in the editor below.  It should return the minimum cost of copying a string.  

stringConstruction has the following parameter(s):  


s: a string  

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include&lt;bits/stdc++.h&gt;
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int n;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++){
        string s;
        cin&gt;&gt;s;
        set&lt;char&gt; a;
        for(int i=0;i&lt;s.size();i++){
            a.insert(s[i]);
        }
        cout&lt;&lt;a.size()&lt;&lt;endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.114
medium
----------
PROBLEM STATEMENT:
Sherlock considers a string to be valid if all characters of the string appear the same number of times.  It is also valid if he can remove just [expression], determine if it is valid.  If so, return YES, otherwise return NO.

For example, if [expression].  

Function Description  

Complete the isValid function in the editor below.  It should return either the string YES or the string NO.  

isValid has the following parameter(s):  


s: a string  

----------
TOP SOLUTION:
----------
/*
*/
 
//#pragma comment(linker, "/STACK:16777216")
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;
#include &lt;memory.h&gt;
#include &lt;ctime&gt; 
 
#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
 
#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 256

using namespace std;

string st;
int cnt[1&lt;&lt;20],answ;

int main(){
//freopen("binomial.in","r",stdin);
//freopen("binomial.out","w",stdout);
//freopen("F:/in.txt","r",stdin);
//freopen("F:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);
//cin.tie(0);

cin&gt;&gt;st;
for (int i=0;i&lt;st.size();i++)
{
	cnt[st[i]-'a']++;
}

answ=1e9;
for (int ans=0;ans&lt;=100000;ans++)
{
	int s=0;
	for (int j=0;j&lt;26;j++)
		if (cnt[j]&gt;=ans)
			s+=cnt[j]-ans;
		else
			s+=cnt[j];
		answ=min(answ,s);
}
//cout&lt;&lt;answ&lt;&lt;endl;
if (answ&lt;=1)
	cout&lt;&lt;"YES"&lt;&lt;endl;
else cout&lt;&lt;"NO"&lt;&lt;endl;

//cin.get();cin.get();
return 0;}
----------
====================
----------
ALGORITHMS.115
medium
----------
PROBLEM STATEMENT:
Palindromes are strings that read the same from the left or right, for example madam or 0110.  

You will be given a string representation of a number and a maximum number of changes you can make.  Alter the string, one digit at a time, to create the string representation of the largest number possible given the limit to the number of changes.  The length of the string may not be altered, so you must consider [expression] is not.  

Given a string representing the starting number and a maximum number of changes allowed, create the largest palindromic string of digits possible or the string -1 if it's impossible to create a palindrome under the contstraints.  

Function Description  

Complete the highestValuePalindrome function in the editor below.  It should return a string representing the largest value palindrome achievable, or -1.  

highestValuePalindrome has the following parameter(s):  


s: a string representation of an integer    
n: an integer that represents the length of the integer string  
k: an integer that represents the maximum number of changes allowed  

----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define FOR(i,a,b) for(int i = (a); i &lt;= (b); ++i)
#define FORD(i,a,b) for(int i = (a); i &gt;= (b); --i)
#define RI(i,n) FOR(i,1,(n))
#define REP(i,n) FOR(i,0,(n)-1)
#define mini(a,b) a=min(a,b)
#define maxi(a,b) a=max(a,b)
#define mp make_pair
#define pb push_back
#define st first
#define nd second
#define sz(w) (int) w.size()
typedef vector&lt;int&gt; vi;
typedef long long ll;
typedef long double ld;
typedef pair&lt;int,int&gt; pii;
const int inf = 1e9 + 5;
const int nax = 1e6 + 5;

char sl[nax];
int n, k;

int f(int i) {
	return n - 1 - i;
}

int main() {
	scanf("%d%d", &amp;n, &amp;k);
	scanf("%s", sl);
	int must = 0;
	REP(i, n) {
		int j = f(i);
		if(sl[i] != sl[j] &amp;&amp; i &lt; j) ++must;
	}
	if(must &gt; k) {
		printf("%d\n", -1);
		return 0;
	}
	REP(i, n) {
		int j = f(i);
		int dis = 2;
		if(j &lt; i) break;
		if(i == j) dis = 1;
		if(sl[i] == sl[j] &amp;&amp; must + dis &lt;= k &amp;&amp; sl[i] != '9') {
			sl[i] = sl[j] = '9';
			must += dis;
		}
		if(sl[i] != sl[j]) {
			if(sl[i] == '9' || sl[j] == '9') {
				sl[i] = sl[j] = '9';
			}
			else {
				if(must + 1 &lt;= k) {
					must += 1;
					sl[i] = sl[j] = '9';
				}
				else {
					if(sl[i] &gt; sl[j]) sl[j] = sl[i];
					else sl[i] = sl[j];
				}
			}
		}
	}
	assert(must &lt;= k);
	printf("%s\n", sl);
	return 0;
}

----------
====================
----------
ALGORITHMS.116
medium
----------
PROBLEM STATEMENT:
Madam Hannah Otto, the CEO of Reviver Corp., is fond of palindromes, or words that read the same forwards or backwards. She thinks palindromic brand names are appealing to millennials.  

As part of the marketing campaign for the company's new juicer called the Rotator™, Hannah decided to push the marketing team's palindrome-searching skills to a new level with a new challenge.  

In this challenge, Hannah provides a string [expression]), and ask the following question:

Consider all the palindromes that can be constructed from some of the letters from [expression]. You can reorder the letters as you need. Some of these palindromes have the maximum length among all these palindromes. How many maximum-length palindromes are there?  

For example, if [expression], then we have,



Your job as the head of the marketing team is to answer all the queries. Since the answers can be very large, you are only required to find the answer modulo [expression].  

Complete the functions initialize and answerQuery and return the number of maximum-length palindromes modulo [expression]. 
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x&lt;(to);x++)
#define FORR(x,arr) for(auto&amp; x:arr)
#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
//-------------------------------------------------------

string S;
int N;
int P[26][101010];
int Q,L,R;
ll mo=1000000007;

const int NUM_=200003;
static ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];

void solve() {
	int i,j,k,l,r,x,y; string s;
	
	cin&gt;&gt;S;
	N=S.size();
	FOR(i,26) {
		FOR(x,N) {
			P[i][x+1]=P[i][x]+(S[x]=='a'+i);
		}
	}
	
	inv[1]=fact[0]=factr[0]=1;
	for (int i=2;i&lt;=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;
	for (int i=1;i&lt;=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;
	
	cin&gt;&gt;Q;
	while(Q--) {
		cin&gt;&gt;L&gt;&gt;R;
		L--;
		int num[26]={},odd=0,sum=0;
		FOR(i,26) {
			num[i]=(P[i][R]-P[i][L])/2;
			sum+=num[i];
			if((P[i][R]-P[i][L])&amp;1) odd++;
		}
		ll ret=odd?odd:1;
		(ret*=fact[sum])%=mo;
		FOR(i,26) {
			ret=ret*factr[num[i]]%mo;
		}
		cout&lt;&lt;ret&lt;&lt;endl;
		
		
	}
	
	
	
}


int main(int argc,char** argv){
	string s;int i;
	if(argc==1) ios::sync_with_stdio(false), cin.tie(0);
	FOR(i,argc-1) s+=argv[i+1],s+='\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);
	cout.tie(0); solve(); return 0;
}

----------
====================
----------
ALGORITHMS.117
medium
----------
PROBLEM STATEMENT:
Two strings are anagrams of each other if the letters of one string can be rearranged to form the other string. Given a string, find the number of pairs of substrings of the string that are anagrams of each other.  

For example [expression] respectively.

Function Description

Complete the function sherlockAndAnagrams in the editor below.  It must return an integer that represents the number of anagrammatic pairs of substrings in [expression].

sherlockAndAnagrams has the following parameter(s):


s: a string . 

----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
#include &lt;cstdio&gt;
#define MAX 5000
using namespace std;
map&lt;string,int&gt; mp ;
int main(){
	ios::sync_with_stdio(0);
	int t;
	cin&gt;&gt;t;
	while(t--){
		mp.clear();
		string s,sn,ss ;
		int j;
		cin&gt;&gt;s;
		int l=s.length();
		for(int k=0;k&lt;l;k++){
			ss = "";
			for(int i=0;i&lt;l-k;i++){	
					j = k+i;
					ss = ss + s[j];
					sn = ss ;
					sort(sn.begin() , sn.end());
					mp[sn]++;
			}
		}
		long long int ans = 0 ;
		map&lt;string,int&gt; :: iterator it ;
		for(it = mp.begin() ; it != mp.end() ; it++){
			long long  vl = (long long)(it-&gt;second) ;
			if(vl &gt; 1){				
				ans += (vl*(vl-1))/2LL ;
			}
		}
		cout&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}
----------
====================
----------
ALGORITHMS.118
medium
----------
PROBLEM STATEMENT:
A string is said to be a child of a another string if it can be formed by deleting 0 or more characters from the other string.  Given two strings of equal length, what's the longest string  that can be constructed such that it is a child of both?  

For example, ABCD and ABDC have two children with maximum length 3, ABC and ABD.  They can be formed by eliminating either the D or C from both strings.  Note that we will not consider ABCD as a common child because we can't rearrange characters and ABCD [expression] ABDC.  

Function Description

Complete the commonChild function in the editor below.  It should return the longest string which is a common child of the input strings.

commonChild has the following parameter(s):


s1, s2:  two equal length strings  

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;utility&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;sstream&gt;
#define FOR(a,b,c) for (int a=b,_c=c;a&lt;=_c;a++)
#define FORD(a,b,c) for (int a=b;a&gt;=c;a--)
#define REP(i,a) for(int i=0,_a=(a); i&lt;_a; ++i)
#define REPD(i,a) for(int i=(a)-1; i&gt;=0; --i)
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define sz(a) int(a.size())
#define reset(a,b) memset(a,b,sizeof(a))
#define oo 1000000007

using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; pii;

const int maxn=5007;

int dp[maxn][maxn],n;
char a[maxn],b[maxn];

int main(){
    //freopen("test.txt","r",stdin);
    scanf("%s",a+1);
    scanf("%s",b+1);
    n=strlen(a+1);
    reset(dp,0);
    FOR(i,1,n) FOR(j,1,n){
        dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
        if(a[i]==b[j]) dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1);
    }
    printf("%d\n",dp[n][n]);
    return 0;
}

----------
====================
----------
ALGORITHMS.119
medium
----------
PROBLEM STATEMENT:
A gene is represented as a string of length [expression].
It is considered to be steady if each of the four letters occurs exactly [expression] are both steady genes.

Bear Limak is a famous biotechnology scientist who specializes in modifying bear DNA to make it steady.  Right now, he is examining a gene represented as a string [expression] and replace it with any string of the same length.

Modifying a large substring of bear genes can be dangerous.
Given a string [expression] a steady gene?

Note: A substring of a string [expression].

As an example, consider [expression].

Function Description

Complete the [expression] function in the editor below.  It should return an integer that represents the length of the smallest substring to replace.  

steadyGene has the following parameter:  


gene: a string

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class B {

	BufferedReader br;
	PrintWriter out;
	StringTokenizer st;
	boolean eof;
	
	static final String GENES = "ACGT";

	void solve() throws IOException {
		int n = nextInt();
		String s = nextToken();
		int[] a = new int[n];
		
		int need = n / 4;
		
		int[] cnt = new int[4];
		for (int i = 0; i &lt; n; i++) {
			a[i] = GENES.indexOf(s.charAt(i));
			cnt[a[i]]++;
		}
		
		if (cnt[0] == need &amp;&amp; cnt[1] == need &amp;&amp; cnt[2] == need &amp;&amp; cnt[3] == need) {
			out.println(0);
			return;
		}
		
		int low = 0;
		int high = n;
		
		outer: while (high - low &gt; 1) {
			int mid = (low + high) &gt;&gt; 1;
			
			int[] tmp = cnt.clone();
			for (int i = 0; i &lt; mid; i++) {
				tmp[a[i]]--;
			}
			
			if (tmp[0] &lt;= need &amp;&amp; tmp[1] &lt;= need &amp;&amp; tmp[2] &lt;= need &amp;&amp; tmp[3] &lt;= need) {
				high = mid;
				continue outer;
			}
			
			for (int i = mid; i &lt; n; i++) {
				tmp[a[i - mid]]++;
				tmp[a[i]]--;
				
				if (tmp[0] &lt;= need &amp;&amp; tmp[1] &lt;= need &amp;&amp; tmp[2] &lt;= need &amp;&amp; tmp[3] &lt;= need) {
					high = mid;
					continue outer;
				}
			}
			
			low = mid;
		}
		
		out.println(high);
		
	}

	B() throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		solve();
		out.close();
	}

	public static void main(String[] args) throws IOException {
		new B();
	}

	String nextToken() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception e) {
				eof = true;
				return null;
			}
		}
		return st.nextToken();
	}

	String nextString() {
		try {
			return br.readLine();
		} catch (IOException e) {
			eof = true;
			return null;
		}
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
}
----------
====================
----------
ALGORITHMS.120
expert
----------
PROBLEM STATEMENT:
Jack and Daniel are friends. Both of them like letters, especially upper-case ones. 
They are cutting upper-case letters from newspapers, and each one of them has his collection of letters stored in a stack. 

One beautiful day, Morgan visited Jack and Daniel. He saw their collections. He wondered what is the lexicographically minimal string made of those two collections. He can take a letter from a collection only when it is on the top of the stack.  Morgan wants to use all of the letters in their collections.  

As an example, assume Jack has collected [expression] for each stack of letters. Assembling the string would go as follows:  

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
    	[expression]
    		[expression]



Note the choice when there was a tie at CA and CF.

Function Description  

Complete the morganAndString function in the editor below.  It should return the completed string.  

morganAndString has the following parameter(s):  


a: a string representing Jack's letters, top at index [expression]  
b: a string representing Daniel's letters, top at index [expression]  

----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus &gt; 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector&lt;int&gt; vi; typedef pair&lt;int,int&gt; pii; typedef vector&lt;pair&lt;int,int&gt; &gt; vpii;
typedef long long ll; typedef vector&lt;long long&gt; vl; typedef pair&lt;long long,long long&gt; pll; typedef vector&lt;pair&lt;long long,long long&gt; &gt; vpll;
typedef vector&lt;string&gt; vs; typedef long double ld;
template&lt;typename T, typename U&gt; inline void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; inline void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

class SuffixArray {
public:
	typedef char Alpha;
	typedef int Index;

	void build(const Alpha *str, Index n, int AlphaSize);
	void build(const Alpha *str, Index n);
	inline Index getKThSuffix(Index k) const { return suffixArray[k]; }
	inline Index length() const { return suffixArray.size() - 1; }
	std::vector&lt;Index&gt; suffixArray;
	template&lt;typename AlphaT&gt; void sa_is(const AlphaT *str, Index n, int AlphaSize, Index *sa, std::vector&lt;Index&gt; &amp;bucketOffsets);
	template&lt;typename AlphaT&gt; void inducedSort(const AlphaT *str, Index n, int AlphaSize, const std::vector&lt;bool&gt; &amp;types, Index *sa, std::vector&lt;Index&gt; &amp;bucketOffsets);
	template&lt;typename AlphaT&gt; void countingAlphabets(const AlphaT *str, Index n, int AlphaSize, std::vector&lt;Index&gt; &amp;bucketOffsets, bool b = false);
	template&lt;typename AlphaT&gt; void getBucketOffsets(const AlphaT *str, Index n, bool dir, int AlphaSize, std::vector&lt;Index&gt; &amp;bucketOffsets);
	void buildInverseSuffixArray();
	std::vector&lt;Index&gt; inverseSuffixArray;
};

void SuffixArray::build(const Alpha *str, Index n, int AlphaSize) {
	suffixArray.resize(n+1);
	if(n == 0) suffixArray[0] = 0;
	else {
		//I = sizeof(Index) * CHAR_BITS ???
		//suffixArray + bucketOffsets + types + ????????
		//= n*I + max(AlphaSize, n/2)*I + 2*n + O(log n) bits
		//I = 4 * 32?AlphaSize??????????:
		//(6+1/16) * n + O(log n) bytes
		std::vector&lt;Index&gt; bucketOffsets(std::max(AlphaSize, (n+1) / 2) + 1);
		sa_is&lt;Alpha&gt;(str, n, AlphaSize, &amp;suffixArray[0], bucketOffsets);
	}
}
void SuffixArray::build(const Alpha *str, Index n) {
	Alpha maxElem = *std::max_element(str, str + n);
	assert(maxElem+0 &lt; std::numeric_limits&lt;int&gt;::max());
	build(str, n, (int)(maxElem+1));
}

//str?[0,n)?????????????sa?[0,n]???
template&lt;typename AlphaT&gt;
void SuffixArray::sa_is(const AlphaT *str, Index n, int AlphaSize, Index *sa, std::vector&lt;Index&gt; &amp;bucketOffsets) {
	std::vector&lt;bool&gt; types(n+1);
	types[n-1] = 0; types[n] = 1;
	for(Index i = n-2; i &gt;= 0; i --)
		types[i] = str[i] &lt; str[i+1] || (str[i] == str[i+1] &amp;&amp; types[i+1]);

	countingAlphabets(str, n, AlphaSize, bucketOffsets);
	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	std::fill(sa, sa + n + 1, -1);
	for(Index i = 1; i &lt; n; i ++)
		if(types[i] &amp;&amp; !types[i-1]) sa[-- bucketOffsets[(int)str[i]]] = i;
	sa[0] = n;
	inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);

	Index n1 = 0;
	for(Index i = 0; i &lt;= n; i ++) {
		Index j = sa[i];
		if(j &gt; 0 &amp;&amp; types[j] &amp;&amp; !types[j-1]) sa[n1 ++] = j;
	}

	//LMS substrings????????sa[0..n1-1]??????????
	//???????sa???????????????
	//??????pos????????????????????
	//???LMS substring????????????LMS substring???n/2????????????????1???????
	Index *buffer = sa + n1;
	std::fill(buffer, sa + n + 1, -1);
	Index uniqueLMSCount = 0, prevPos = -1;
	assert(sa[0] == n);
	buffer[sa[0] / 2] = uniqueLMSCount ++;	//'$'
	for(Index i = 1; i &lt; n1; i ++) {
		Index pos = sa[i]; bool diff = false;
		if(prevPos == -1) diff = true;
		else for(Index j = pos, k = prevPos; ; j ++, k ++) {
				if(str[j] != str[k] || types[j] != types[k]) {
					diff = true;
					break;
				}else if(j != pos &amp;&amp; ((types[j] &amp;&amp; !types[j-1]) || (types[k] &amp;&amp; !types[k-1])))
					break;
			}
		if(diff) {
			uniqueLMSCount ++;
			prevPos = pos;
		}
		buffer[pos / 2] = uniqueLMSCount - 1;
	}
	for(Index i = n, j = n; i &gt;= n1; i --)
		if(sa[i] &gt;= 0) sa[j --] = sa[i];

	Index *sa1 = sa, *s1 = sa + n + 1 - n1;
	if(uniqueLMSCount == n1)
		for(Index i = 0; i &lt; n1; i ++) sa1[s1[i]] = i;
	else
		sa_is&lt;Index&gt;(s1, n1 - 1, uniqueLMSCount, sa1, bucketOffsets);

	countingAlphabets(str, n, AlphaSize, bucketOffsets);
	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	for(Index i = 1, j = 0; i &lt;= n; i ++)
		if(types[i] &amp;&amp; !types[i-1]) s1[j ++] = i;
	for(Index i = 0; i &lt; n1; i ++) sa1[i] = s1[sa1[i]];
	std::fill(sa + n1, sa + n + 1, -1);
	for(Index i = n1-1; i &gt;= 1; i --) {
		Index j = sa[i]; sa[i] = -1;
		sa[-- bucketOffsets[(int)str[j]]] = j;
	}
	inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);
}

template&lt;typename AlphaT&gt;
void SuffixArray::inducedSort(const AlphaT *str, Index n, int AlphaSize, const std::vector&lt;bool&gt; &amp;types, Index *sa, std::vector&lt;Index&gt; &amp;bucketOffsets) {
	getBucketOffsets(str, n, false, AlphaSize, bucketOffsets);
	for(Index i = 0; i &lt; n; i ++) {
		Index j = sa[i] - 1;
		if(j &gt;= 0 &amp;&amp; !types[j]) sa[bucketOffsets[(int)str[j]] ++] = j;
	}

	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	for(Index i = n; i &gt;= 1; i --) {
		Index j = sa[i] - 1;
		if(j &gt;= 0 &amp;&amp; types[j]) sa[-- bucketOffsets[(int)str[j]]] = j;
	}
}

template&lt;typename AlphaT&gt;
void SuffixArray::countingAlphabets(const AlphaT *str, Index n, int AlphaSize, std::vector&lt;Index&gt; &amp;bucketOffsets, bool b) {
	if(b || (int)bucketOffsets.size() / 2 &gt;= AlphaSize) {
		std::vector&lt;Index&gt;::iterator alphabetCounts =
			b ? bucketOffsets.begin() : bucketOffsets.begin() + AlphaSize;
		std::fill(alphabetCounts, alphabetCounts + AlphaSize, 0);
		for(Index i = 0; i &lt; n; i ++)
			alphabetCounts[(int)str[i]] ++;
	}
}

template&lt;typename AlphaT&gt;
void SuffixArray::getBucketOffsets(const AlphaT *str, Index n, bool dir, int AlphaSize, std::vector&lt;Index&gt; &amp;bucketOffsets) {
	//AlphaSize????????bucketOffset??????alphabet??????????????
	//AlphaSize????????bucketOffset?alphabetCounts??????????????
	std::vector&lt;Index&gt;::iterator alphabetCounts;
	if((int)bucketOffsets.size() / 2 &lt; AlphaSize) {
		countingAlphabets(str, n, AlphaSize, bucketOffsets, true);
		alphabetCounts = bucketOffsets.begin();
	}else alphabetCounts = bucketOffsets.begin() + AlphaSize;
	Index cumsum = 1;	//'$'??
	if(dir) {
		for(int i = 0; i &lt; AlphaSize; i ++) {
			cumsum += alphabetCounts[i];
			bucketOffsets[i] = cumsum;
		}
	}else {
		for(int i = 0; i &lt; AlphaSize; i ++) {
			Index x = alphabetCounts[i];
			bucketOffsets[i] = cumsum;
			cumsum += x;
		}
	}
}

void SuffixArray::buildInverseSuffixArray() {
	Index n = length();
	inverseSuffixArray.resize(n+1);
	for(Index i = 0; i &lt;= n; i ++)
		inverseSuffixArray[suffixArray[i]] = i;
}

struct StringInterspersal {
	string minimum(vector &lt;string&gt; W) {
		int n = W.size();
		string w; vi d;
		rep(i, n) {
			d.pb(w.size());
			w += W[i];
			w += '~';
		}
		SuffixArray sa;
		sa.build(&amp;w[0], w.size());
		sa.buildInverseSuffixArray();
		vi v(n);
		string s;
		while(1) {
			pair&lt;int,int&gt; p(INF,-1);
			rep(i, n) if(v[i] != W[i].size()) {
				p = min(p, mp(sa.inverseSuffixArray[d[i] + v[i]], i));
			}
			if(p.second == -1) break;
			s += W[p.second][v[p.second]];
			v[p.second] ++;
		}
		return s;
	}
};

char A[100001], B[100001];
int main() {
	int T;
	scanf("%d", &amp;T);
	rep(ii, T) {
		scanf("%s", A);
		scanf("%s", B);
		string w; vi d;
		d.pb(w.size()), w += A, w += '~';
		d.pb(w.size()), w += B, w += '~';
		SuffixArray sa;
		sa.build(&amp;w[0], w.size());
		sa.buildInverseSuffixArray();
		vi v(2);
		priority_queue&lt;pair&lt;int,int&gt;,vpii,greater&lt;pii&gt; &gt; q;
		rep(i, 2) q.push(mp(sa.inverseSuffixArray[d[i] + v[i]], i));
		string ans;
		while(!q.empty()) {
			int i = q.top().second; q.pop();
			ans += w[d[i] + v[i]];
			v[i] ++;
			if(w[d[i] + v[i]] != '~')
				q.push(mp(sa.inverseSuffixArray[d[i] + v[i]], i));
		}
		puts(ans.c_str());
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.121
hard
----------
PROBLEM STATEMENT:
A regular expression is used to describe a set of strings. For this problem the alphabet is limited to 'a' and 'b'.

We define [expression] to be a valid regular expression if: 
1) [expression]". 
2) [expression] are regular expressions. 
3) [expression] are regular expressions. 
4) [expression] is a regular expression.

Regular expressions can be nested and will always have have two elements in the parentheses. ('[expression]' is invalid.  

The set of strings recognized by [expression] are as follows: 
1) If [expression]. 
2) If [expression]. 
3) If [expression]. 
4) If [expression]. 
5) If [expression].

Task 
Given a regular expression and an integer, [expression] are recognized by it.
----------
TOP SOLUTION:
----------
#include&lt;iostream&gt;
using namespace std;

long int str_len1=653338565;
long int ans1[50]={487453258,753939081,735741532,657124990,540377902,562082545,514464775,973623226,670983611,560236450,963764934,415071209,891593594,211436788,650055884,217134804,422520289,447758258,103981540,511606624,831895899,28978530,251400148,691688924,731609600,905178997,404473648,396954058,716420728,487114776,386498644,93386798,439284603,54942296,935663298,574744738,404152547,126300345,527653958,976881496,3,256788711,35109291,809325810,668462037,137299939,332411686,432738634,483445023,919464569};

long int str_len2=2;
long int ans2[3]={2,32,100};

long int str_len3=1;
long int ans3[37]={1,1,3,8,8,20,21,49,55,120,0,1,7,0,0,3,0,2,128,0,256,1024,0,1,1,0,1,0,0,1,1,1,3,32768,65536,256,277};

long int str_len4=937477085;
long int ans4[50]={971722885,992234032,4718730,486357608,141092500,873705910,713870975,721850737,294222231,948473105,437600740,794356302,527158721,115404564,977150281,388567604,387595705,194824320,894280556,847776352,131339469,117159835,599878374,92682099,920903659,792684024,273141846,472919272,767600333,883824742,133595680,136080480,296528783,664488648,30864164,23904499,127608347,629123032,746788713,4,42478196,333029944,785494390,357144475,228359184,322942292,524149263,56430959,45523423,63137616};

long int str_len5=915989945;
long int ans5[50]={194519002,433197926,578675269,698694936,421324494,833298888,40472597,222297295,488397718,701637957,675191009,322106445,879822947,185058387,96631870,679295917,483197458,929842372,635880885,984507678,311257451,163171583,908519673,501781925,328133762,540351280,557734885,5,913664426,578583313,204572017,29795240,543336284,113372448,873343620,335782236,696105515,559571245,114373520,140947419,429077550,350623194,434489515,903144740,211956350,65253326,28917682,696473903,442015137,611952427};

long int str_len6=197882165;
long int ans6[50]={631290317,230263422,222589389,38923279,25748117,766857494,483799098,885447818,795111776,811188331,135676306,222054446,819849771,304937127,327168551,613581196,808008666,2,462373482,741172887,34724481,32109965,284447243,452339462,1900837,965370970,82018236,375811592,762963049,160312466,376383274,382053282,313048268,847585371,543341983,587280939,3,299651070,266819019,35030581,722500608,22608298,920605765,43696345,754815652,649835385,121551303,50689301,362648080,641477045};

long int str_len7=106981093;
long int ans7[50]={906415635,902192341,624743268,58514418,415619770,753102009,421396586,711192384,312090197,505474532,269315981,605960822,524099349,51722616,277034721,314935912,295003740,857846022,206660200,4276533,51867075,363544605,845102667,995140347,76743760,567145984,411832279,728348670,505080958,734751939,266675137,668861753,617137543,282777837,334041837,544988918,81933004,608051332,456993207,622822155,799368855,448487273,726826527,850167182,436120159,947482181,622007113,97779847,110171245,510214806};

long int str_len8=199889328;
long int ans8[50]={516621881,910457718,736811626,272027404,952768920,767254225,282014251,318142040,161972343,572616412,239547543,697382219,655188484,929163729,211762405,622057321,841245664,51176593,306403213,289507387,422155201,784049332,138640667,394596143,801618641,101518092,37709193,156575439,368097322,176198635,724860409,396899275,764924779,738584446,627735212,596150041,859070598,607179872,947889846,567838800,303772606,894713383,120823765,852393358,421396031,91815051,575670631,645739521,291539384,874060676};

long int str_len9=750333556;
long int ans9[50]={325571119,51564118,251293856,467993948,923716966,793691149,865606580,412309868,162334306,697985158,129501993,946331422,141347178,958055976,773977922,943408970,146108225,680774463,742662079,640270102,885500680,318860338,513197002,629393889,941168264,521661634,203498814,122382948,621200693,894310398,217572025,355890128,872630068,2,161095870,835297907,6,196069750,443052474,142865747,507889159,617592193,50219025,58604297,169253692,219374641,143103252,724035915,492380134,950802644};

long int str_len10=681185765;
long int ans10[50]={257627333,3,328967104,175563099,190771402,580271099,542691196,887894662,510155825,0,924014521,885022536,132390292,418489269,469403451,856129614,2,606927503,575237384,749463721,366580052,86526102,441971204,222631201,76056172,295116546,175057662,107855843,287854033,108255676,386594084,739640162,546382586,887390753,14356866,271480124,779846078,307765025,652412194,647696786,345279760,811297746,695337454,465392764,498325085,747642432,287614244,566180179,202813167,895174570};

long int str_len11=514928230;
long int ans11[50]={64685307,123588291,268830184,450808370,247476517,494100699,803986482,934572286,989838375,972767837,967239687,81718397,909699005,564233191,140597863,284427814,804142870,57164241,361698113,515702604,624875820,170733560,71651154,332021569,18183233,522115478,238799314,94354767,630909670,456075068,655472676,903718678,249730714,463337864,319256622,388612264,125114370,778866581,956918434,696541759,635211938,635053152,498899251,874187616,32463522,945657507,690231861,225820460,214278892,572797706};
int main() {
	int N,num,i;
	string str;
	cin&gt;&gt;N;
	cin&gt;&gt;str;
	cin&gt;&gt;num;
	if(num==str_len1) {
		for(i=0;i&lt;N;i++)
			cout&lt;&lt;ans1[i]&lt;&lt;endl;

	}
	else if(num==str_len2) {
		for(i=0;i&lt;N;i++)
			cout&lt;&lt;ans2[i]&lt;&lt;endl;

	}
	else if(num==str_len3) {
		for(i=0;i&lt;N;i++)
			cout&lt;&lt;ans3[i]&lt;&lt;endl;

	}
	else if(num==str_len4) {
		for(i=0;i&lt;N;i++)
		cout&lt;&lt;ans4[i]&lt;&lt;endl;

	}
	else if(num==str_len5) {
		for(i=0;i&lt;N;i++)
		cout&lt;&lt;ans5[i]&lt;&lt;endl;

	}
	else if(num==str_len6) {
		for(i=0;i&lt;N;i++)
		cout&lt;&lt;ans6[i]&lt;&lt;endl;

	}
	else if(num==str_len7) {
		for(i=0;i&lt;N;i++)
		cout&lt;&lt;ans7[i]&lt;&lt;endl;
	}
	else if(num==str_len8) {
		for(i=0;i&lt;N;i++)
		cout&lt;&lt;ans8[i]&lt;&lt;endl;
	}
	else if(num==str_len9) {
		for(i=0;i&lt;N;i++)
		cout&lt;&lt;ans9[i]&lt;&lt;endl;
	}
	else if(num==str_len10) {
		for(i=0;i&lt;N;i++)
		cout&lt;&lt;ans10[i]&lt;&lt;endl;
	}
	else if(num==str_len11) {
		for(i=0;i&lt;N;i++)
		cout&lt;&lt;ans11[i]&lt;&lt;endl;
	}
	while(--N) {
		cin&gt;&gt;str;
		cin&gt;&gt;num;
	}
	return 0;
}
----------
====================
----------
ALGORITHMS.122
advanced
----------
PROBLEM STATEMENT:
Jane loves strings more than anything. She has a string [expression] can be calculated as given below:

[expression]

Jane wants to know the maximum value of [expression]. Can you help her?

Input Format 
A single line containing string [expression] .

Output Format 
Print the maximum value of [expression].

Constraints 
[expression] 
The string consists of lowercase English alphabets.  

Sample Input 0  

aaaaaa


Sample Output 0  

12


Explanation 0  

f('a') = 6
f('aa') = 10
f('aaa') = 12
f('aaaa') = 12
f('aaaaa') = 10
f('aaaaaa') = 6


Sample Input 1  

abcabcddd


Sample Output 1  

9


Explanation 1

f values of few of the substrings are shown below:

f("a") = 2
f("b") = 2
f("c") = 2
f("ab") = 4
f("bc") = 4
f("ddd") = 3
f("abc") = 6
f("abcabcddd") = 9


Among the function values 9 is the maximum one.
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;   
#include &lt;cstdlib&gt;   
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;stack&gt;
using namespace std;

const int N = 201000;   
int wa[N], wb[N], ws[N*2], wv[N];   
int Rank[N], sa[N], height[N], r[N];   
char s[N];
   
int cmp( int* r, int a, int b, int L ){   
    return r[a]== r[b] &amp;&amp; r[a+ L]== r[b+ L];   
}

long long mul(long long x,long long y) {
	return x * y;
}   
   
void da( int* r, int* sa, int n, int m ){   
    int i, j, p, *x= wa, *y= wb, *t;   
    for( i= 0; i&lt; m; ++i ) ws[i]= 0;   
    for( i= 0; i&lt; n; ++i ) ws[ x[i]= r[i] ]++;   
    for( i= 1; i&lt; m; ++i ) ws[i]+= ws[i-1];   
    for( i= n- 1; i&gt;= 0; i-- ) sa[ --ws[ x[i] ] ]= i;   
   
    for( j= 1, p= 1; p&lt; n; j*= 2, m= p ){   
        for( p= 0, i= n- j; i&lt; n; ++i ) y[p++]= i;   
        for( i= 0; i&lt; n; ++i )   
            if( sa[i]&gt;= j ) y[p++]= sa[i]- j;   
   
        for( i= 0; i&lt; n; ++i ) wv[i]= x[y[i]];   
        for( i= 0; i&lt; m; ++i ) ws[i]= 0;   
        for( i= 0; i&lt; n; ++i ) ws[ wv[i] ]++;   
        for( i= 1; i&lt; m; ++i ) ws[i]+= ws[i-1];   
        for( i= n- 1; i&gt;= 0; i-- ) sa[ --ws[ wv[i] ] ]= y[i];   
   
        t= x, x= y, y= t, p= 1; x[ sa[0] ]= 0;   
        for( i= 1; i&lt; n; ++i )   
            x[ sa[i] ]= cmp( y, sa[i-1], sa[i], j )? p- 1: p++;   
    }   
}


long long largestRectangleArea(vector&lt;int&gt; &amp;height) {
        // IMPORTANT: Please reset any member data you declared, as
        // the same Solution instance will be reused for each test case.
        int n = height.size();
	long long result = 0;
        stack&lt;int&gt; s;
        for (int i = 0; i &lt; n; ++i) {
	   //printf("%d\n",height[i]);
            while ((!s.empty()) &amp;&amp; (height[s.top()] &gt; height[i])) {
                int h = height[s.top()];
                s.pop();
                result = max(result, mul((i  - (s.empty()?(-1):s.top())) , h));
                
            }
            s.push(i);
        }
        while (!s.empty()) {
            int h = height[s.top()];
            s.pop();
	    //printf("h = %d\n",h);
            result = max(result, mul((n  - (s.empty()?(-1):s.top())) , h));
        }
        return result;
        
    }   
   
void callheight( int* r, int*sa, int n ){   
    int i, j, k= 0;   
    for( i= 1; i&lt;= n; ++i ) Rank[ sa[i] ]= i;   
   
    for( i= 0; i&lt; n; height[ Rank[i++] ]= k )   
        for( k?k--:0, j= sa[ Rank[i]- 1]; r[i+k]== r[j+k]; k++ );   
   
}   
   
   
int main(){   
    scanf("%s",s );
    int n = strlen(s); 
    for(int i= 0; i &lt; n; ++i ){   
        r[i] = s[i] - 'a' + 1; 
    }   
    r[n]= 0;   
    da( r, sa, n + 1, 27);   
    callheight( r, sa, n );  
    vector&lt;int&gt; a; 
    for (int i = 0; i &lt;= n; ++i) {
	//printf("%d\n",height[i]);
	a.push_back(height[i]);
    }
    printf("%lld\n", max((long long) n, largestRectangleArea(a)));
    return 0;
}
	


----------
====================
----------
ALGORITHMS.123
advanced
----------
PROBLEM STATEMENT:
You have two strings, [expression], such that:


[expression].
[expression] is a palindromic string.
The length of [expression] is as long as possible.


For each of the [expression] instead.
----------
TOP SOLUTION:
----------
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cassert&gt;
#include &lt;ctime&gt;
#include &lt;map&gt;
#include &lt;math.h&gt;
#include &lt;cstdio&gt;
#include &lt;set&gt;
#include &lt;deque&gt;
#include &lt;memory.h&gt;
#include &lt;queue&gt;

#pragma comment(linker, "/STACK:64000000")
typedef long long ll;

using namespace std;

const int MAXN = 1 &lt;&lt; 18;
const int MOD = 1; // 1000 * 1000 * 1000 + 7;
const int INF = (int)(1e9);
const int SIGMA = 26;

struct state {
	int len, link;
	int nxt[SIGMA];
};

state st[MAXN * 2];
int sz, last;

void init() {
	sz = last = 0;
	st[0].len = 0;
	st[0].link = -1;
	++sz;
	for (int i = 0; i &lt; MAXN * 2; ++i) {
		memset(st[i].nxt, -1, sizeof(st[i].nxt));
	}
}

void add(char c) {
	int cur = sz++;
	st[cur].len = st[last].len + 1;
	int p;
	for (p = last; p != -1 &amp;&amp; st[p].nxt[c] == -1; p = st[p].link) st[p].nxt[c] = cur;
	if (p == -1) {
		st[cur].link = 0;
	}
	else {
		int q = st[p].nxt[c];
		if (st[p].len + 1 == st[q].len) {
			st[cur].link = q;
		}
		else {
			int clone = sz++;
			st[clone].len = st[p].len + 1;
			memcpy(st[clone].nxt, st[q].nxt, sizeof(st[clone].nxt));
			st[clone].link = st[q].link;
			for (; p != -1 &amp;&amp; st[p].nxt[c] == q; p = st[p].link) st[p].nxt[c] = clone;
			st[q].link = st[cur].link = clone;
		}
	}
	last = cur;
}

int main() {
#ifdef _MSC_VER
	freopen("input.txt", "r", stdin);
#endif

	int T;
	cin &gt;&gt; T;
	while (T--) {
		string a, b;
		cin &gt;&gt; a &gt;&gt; b;
		int ansLen = 0;
		string ansS;

		for (int it = 0; it &lt; 2; it++) {
			int n = a.length();
			int m = b.length();
			init();
			for (int i = 0; i &lt; m; i++) {
				add(b[i] - 'a');
			}

			vector&lt;int&gt; mx(n, 0);
			int l = n;
			int cur = 0, len = 0;
			for (int r = n - 1; r &gt;= 0; r--) {
				l = min(l, r);
				while (l &gt;= 0 &amp;&amp; st[cur].nxt[a[l] - 'a'] != -1) {
					cur = st[cur].nxt[a[l] - 'a'];
					len++;
					l--;
				}
				mx[r] = len;
				len = max(len - 1, 0);
				if (cur != 0 &amp;&amp; len == st[st[cur].link].len) {
					cur = st[cur].link;
				}
			}

			vector&lt;int&gt; d1(n);
			l = 0;
			int r = -1;
			for (int i = 0; i &lt; n; i++) {
				int k;
				if (i &gt; r) k = 1;
				else k = min(d1[l + r - i], r - i);

				while (0 &lt;= i - k &amp;&amp; i + k &lt; n &amp;&amp; a[i - k] == a[i + k]) k++;
				d1[i] = k;
				if (i + k - 1 &gt; r)
					r = i + k - 1, l = i - k + 1;
			}
			vector&lt;int&gt; d2(n);
			l = 0, r = -1;
			for (int i = 0; i &lt; n; i++) {
				int k;
				if (i &gt; r) k = 0;
				else k = min(d2[l + r - i + 1], r - i + 1);

				while (i + k &lt; n &amp;&amp; i - k - 1 &gt;= 0 &amp;&amp; a[i + k] == a[i - k - 1]) k++;
				d2[i] = k;

				if (i + k - 1 &gt; r)
					l = i - k, r = i + k - 1;
			}
			d2.push_back(0);
			// WHAT THE FUCK WHY AM I SHOULD DO THAT
			for (int i = 0; i &lt; n; i++) {
				if (i - d1[i] + 1 == 0) d1[i]--;
				if (i - d2[i] + 1 == 0) d2[i]--;
			}

			for (int i = 0; i &lt; n; i++) {
				int cans = d1[i] * 2 - 1;
				int l = i - d1[i] + 1;
				if (l &gt; 0) cans += 2 * mx[l - 1];
				if (l &gt; 0 &amp;&amp; mx[l - 1] &amp;&amp; cans &gt;= ansLen) {
					ansLen = cans;
				}
			}
			for (int i = 0; i &lt;= n; i++) {
				int cans = d2[i] * 2;
				int l = i - d2[i];
				if (l &gt; 0) cans += 2 * mx[l - 1];
				if (l &gt; 0 &amp;&amp; mx[l - 1] &amp;&amp; cans &gt;= ansLen) {
					ansLen = cans;
				}
			}

			reverse(a.begin(), a.end());
			reverse(b.begin(), b.end());
			swap(a, b);
		}
		for (int it = 0; it &lt; 2; it++) {
			int n = a.length();
			int m = b.length();
			init();
			for (int i = 0; i &lt; m; i++) {
				add(b[i] - 'a');
			}

			vector&lt;int&gt; mx(n, 0);
			int l = n;
			int cur = 0, len = 0;
			for (int r = n - 1; r &gt;= 0; r--) {
				l = min(l, r);
				while (l &gt;= 0 &amp;&amp; st[cur].nxt[a[l] - 'a'] != -1) {
					cur = st[cur].nxt[a[l] - 'a'];
					len++;
					l--;
				}
				mx[r] = len;
				len = max(len - 1, 0);
				if (cur != 0 &amp;&amp; len == st[st[cur].link].len) {
					cur = st[cur].link;
				}
			}

			vector&lt;int&gt; d1(n);
			l = 0;
			int r = -1;
			for (int i = 0; i &lt; n; i++) {
				int k;
				if (i &gt; r) k = 1;
				else k = min(d1[l + r - i], r - i);

				while (0 &lt;= i - k &amp;&amp; i + k &lt; n &amp;&amp; a[i - k] == a[i + k]) k++;
				d1[i] = k;
				if (i + k - 1 &gt; r)
					r = i + k - 1, l = i - k + 1;
			}
			vector&lt;int&gt; d2(n);
			l = 0, r = -1;
			for (int i = 0; i &lt; n; i++) {
				int k;
				if (i &gt; r) k = 0;
				else k = min(d2[l + r - i + 1], r - i + 1);

				while (i + k &lt; n &amp;&amp; i - k - 1 &gt;= 0 &amp;&amp; a[i + k] == a[i - k - 1]) k++;
				d2[i] = k;

				if (i + k - 1 &gt; r)
					l = i - k, r = i + k - 1;
			}
			d2.push_back(0);
			// WHAT THE FUCK WHY AM I SHOULD DO THAT
			for (int i = 0; i &lt; n; i++) {
				if (i - d1[i] + 1 == 0) d1[i]--;
				if (i - d2[i] + 1 == 0) d2[i]--;
			}

			for (int i = 0; i &lt; n; i++) {
				int cans = d1[i] * 2 - 1;
				int l = i - d1[i] + 1;
				if (l &gt; 0) cans += 2 * mx[l - 1];
				if (l &gt; 0 &amp;&amp; mx[l - 1] &amp;&amp; cans &gt;= ansLen) {
					int ansC = i;
					string nans = "";
					for (int i = ansC - d1[ansC] + 1; i &lt;= ansC + d1[ansC] - 1; i++) nans += a[i];
					string ss;
					int l = ansC - d1[ansC] + 1;
					if (l &gt; 0) {
						for (int i = 0; i &lt; mx[l - 1]; i++) ss += a[l - 1 - i];
					}
					nans += ss;
					reverse(ss.begin(), ss.end());
					nans = ss + nans;
					if (nans.length() &gt; ansS.length() || nans &lt; ansS) ansS = nans;
					ansLen = ansS.length();
				}
			}
			for (int i = 0; i &lt;= n; i++) {
				int cans = d2[i] * 2;
				int l = i - d2[i];
				if (l &gt; 0) cans += 2 * mx[l - 1];
				if (l &gt; 0 &amp;&amp; mx[l - 1] &amp;&amp; cans &gt;= ansLen) {
					int ansC = i;
					string nans = "";
					for (int i = ansC - d2[ansC]; i &lt; ansC + d2[ansC]; i++) nans += a[i];
					string ss;
					int l = ansC - d2[ansC];
					if (l &gt; 0) {
						for (int i = 0; i &lt; mx[l - 1]; i++) ss += a[l - 1 - i];
					}
					nans += ss;
					reverse(ss.begin(), ss.end());
					nans = ss + nans;
					if (nans.length() &gt; ansS.length() || nans &lt; ansS) ansS = nans;
					ansLen = ansS.length();
				}
			}

			reverse(a.begin(), a.end());
			reverse(b.begin(), b.end());
			swap(a, b);
		}
		if (ansS == "") cout &lt;&lt; -1 &lt;&lt; endl;
		else cout &lt;&lt; ansS &lt;&lt; endl;
	}

	return 0;
}
----------
====================
----------
ALGORITHMS.124
hard
----------
PROBLEM STATEMENT:
Greg wants to build a string, [expression] operations:


Add a character to the end of [expression] dollars.
Copy any substring of [expression] dollars.


Calculate minimum amount of money Greg needs to build [expression].
----------
TOP SOLUTION:
----------
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;limits&gt;
#include &lt;functional&gt;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus &gt; 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; inline void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; inline void amax(T &amp;x, U y) { if(x &lt; y) x = y; }


template&lt;typename Val, typename Compare = std::less&lt;Val&gt;, int BlockSize = 10&gt;
class DirectRMQ {
public:
	typedef int Index;
	typedef char InBlockIndex;
	typedef InBlockIndex(*BlockTypeRef)[BlockSize];

	DirectRMQ(Compare comp_ = Compare()) :
		blockTypes(0), innerBlockTable(0), sparseTable(0) {
		comp = comp_;
		calcBallotNumbers();
		buildInnerBlockTable();
	}
	~DirectRMQ() {
		delete[] innerBlockTable;
		delete[] blockTypes; delete[] sparseTable;
	}

	void build(const Val *a, Index n) {
		blocks = (n + BlockSize - 1) / BlockSize;
		stHeight = 0; while(1 &lt;&lt; stHeight &lt; blocks) ++ stHeight;
		delete[] blockTypes; delete[] sparseTable;

		blockTypes = new BlockTypeRef[blocks];
		calcBlockTypes(a, n);
		buildInnerBlockTable(a, n);
		sparseTable = new Index[blocks * stHeight];
		buildSparseTable(a);
	}

	Index query(const Val *a, Index l, Index r) const {
		Index x = l / BlockSize, y = r / BlockSize, z = y - x;
		if(z == 0) return x * BlockSize + blockTypes[x][l % BlockSize][r % BlockSize];
		if(z == 1) return assumeleft_minIndex(a,
			x * BlockSize + blockTypes[x][l % BlockSize][BlockSize - 1],
			y * BlockSize + blockTypes[y][0][r % BlockSize]);
		z -= 2;
		Index k = 0, s;
		s = ((z &amp; 0xffff0000) != 0) &lt;&lt; 4; z &gt;&gt;= s; k |= s;
		s = ((z &amp; 0x0000ff00) != 0) &lt;&lt; 3; z &gt;&gt;= s; k |= s;
		s = ((z &amp; 0x000000f0) != 0) &lt;&lt; 2; z &gt;&gt;= s; k |= s;
		s = ((z &amp; 0x0000000c) != 0) &lt;&lt; 1; z &gt;&gt;= s; k |= s;
		s = ((z &amp; 0x00000002) != 0) &lt;&lt; 0; z &gt;&gt;= s; k |= s;
		return assumeleft_minIndex(a
			, assumeleft_minIndex(a,
				x * BlockSize + blockTypes[x][l % BlockSize][BlockSize - 1],
				sparseTable[x + 1 + blocks * k])
			, assumeleft_minIndex(a,
				sparseTable[y + blocks * k - (1 &lt;&lt; k)],
				y * BlockSize + blockTypes[y][0][r % BlockSize])
			);
	}

	Val queryVal(const Val *a, Index l, Index r) const {
		Index x = l / BlockSize, y = r / BlockSize, z = y - x;
		if(z == 0) return a[x * BlockSize + blockTypes[x][l % BlockSize][r % BlockSize]];
		Val edge = minVal(
			a[x * BlockSize + blockTypes[x][l % BlockSize][BlockSize - 1]],
			a[y * BlockSize + blockTypes[y][0][r % BlockSize]]);
		if(z == 1) return edge;
		z -= 2;
		Index k = 0, s;
		s = ((z &amp; 0xffff0000) != 0) &lt;&lt; 4; z &gt;&gt;= s; k |= s;
		s = ((z &amp; 0x0000ff00) != 0) &lt;&lt; 3; z &gt;&gt;= s; k |= s;
		s = ((z &amp; 0x000000f0) != 0) &lt;&lt; 2; z &gt;&gt;= s; k |= s;
		s = ((z &amp; 0x0000000c) != 0) &lt;&lt; 1; z &gt;&gt;= s; k |= s;
		s = ((z &amp; 0x00000002) != 0) &lt;&lt; 0; z &gt;&gt;= s; k |= s;
		return minVal(edge, minVal(
			a[sparseTable[x + 1 + blocks * k]],
			a[sparseTable[y + blocks * k - (1 &lt;&lt; k)]]));
	}
private:
	Compare comp;

	int ballotNumbers[BlockSize + 1][BlockSize + 1];
	InBlockIndex(*innerBlockTable)[BlockSize][BlockSize];

	Index blocks;
	int stHeight;
	BlockTypeRef *blockTypes;
	Index *sparseTable;

	inline Index minIndex(const Val *a, Index x, Index y) const {
		return comp(a[x], a[y]) || (a[x] == a[y] &amp;&amp; x &lt; y) ? x : y;
	}
	inline Index assumeleft_minIndex(const Val *a, Index x, Index y) const {
		return comp(a[y], a[x]) ? y : x;
	}

	inline Val minVal(Val x, Val y) const {
		return comp(y, x) ? y : x;
	}

	void buildSparseTable(const Val *a) {
		Index *b = sparseTable;
		if(stHeight) for(Index i = 0; i &lt; blocks; i ++)
			b[i] = i * BlockSize + blockTypes[i][0][BlockSize - 1];
		for(Index t = 1; t * 2 &lt; blocks; t *= 2) {
			std::memcpy(b + blocks, b, blocks * sizeof(Index));
			b += blocks;
			for(Index i = 0; i &lt; blocks - t; ++ i)
				b[i] = assumeleft_minIndex(a, b[i], b[i + t]);
		}
	}

	void buildInnerBlockTable(const Val *a, Index n) {
		for(Index i = 0; i &lt; blocks; i ++) {
			BlockTypeRef table = blockTypes[i];
			if(table[0][0] != -1) continue;
			const Val *p = getBlock(a, n, i);
			for(InBlockIndex left = 0; left &lt; BlockSize; left ++) {
				Val minV = p[left];
				InBlockIndex minI = left;
				for(InBlockIndex right = left; right &lt; BlockSize; right ++) {
					if(comp(p[right], minV)) {
						minV = p[right];
						minI = right;
					}
					table[left][right] = minI;
				}
			}
		}
	}

	const Val *getBlock(const Val *a, Index n, Index i) {
		Index offset = i * BlockSize;
		if(offset + BlockSize &lt;= n)
			return a + offset;
		else {
			static Val tmp_a[BlockSize];
			std::copy(a + offset, a + n, tmp_a);
			Val maxVal = Val();
			for(Index j = i; j &lt; n; j ++)
				if(comp(maxVal, a[j])) maxVal = a[j];
			std::fill(tmp_a + (n - offset), tmp_a + BlockSize, maxVal);
			return tmp_a;
		}
	}

	void calcBlockTypes(const Val *a, Index n) {
		Val tmp_rp[BlockSize + 1];
		for(Index i = 0; i &lt; blocks; i ++)
			blockTypes[i] = calcBlockType(getBlock(a, n, i), tmp_rp);
	}

	BlockTypeRef calcBlockType(const Val *a, Val *rp) {
		int q = BlockSize, N = 0;
		for(int i = 0; i &lt; BlockSize; i ++) {
			while(q + i - BlockSize &gt; 0 &amp;&amp; comp(a[i], rp[q + i - BlockSize])) {
				N += ballotNumbers[BlockSize - i - 1][q];
				q --;
			}
			rp[q + i + 1 - BlockSize] = a[i];
		}
		return innerBlockTable[N];
	}

	void calcBallotNumbers() {
		for(int p = 0; p &lt;= BlockSize; p ++) {
			for(int q = 0; q &lt;= BlockSize; q ++) {
				if(p == 0 &amp;&amp; q == 0)
					ballotNumbers[p][q] = 1;
				else if(p &lt;= q)
					ballotNumbers[p][q] =
					(q ? ballotNumbers[p][q - 1] : 0) +
					(p ? ballotNumbers[p - 1][q] : 0);
				else
					ballotNumbers[p][q] = 0;
			}
		}
	}

	void buildInnerBlockTable() {
		int numberOfTrees = ballotNumbers[BlockSize][BlockSize];
		innerBlockTable = new InBlockIndex[numberOfTrees][BlockSize][BlockSize];
		for(int i = 0; i &lt; numberOfTrees; i ++)
			innerBlockTable[i][0][0] = -1;
	}
};

class SuffixArray {
public:
	typedef char Alpha;
	typedef int Index;

	void build(const Alpha *str, Index n, int AlphaSize);
	void build(const Alpha *str, Index n);
	void buildAll(const Alpha *str, Index n);
	inline Index getKThSuffix(Index k) const { return suffixArray[k]; }
	inline Index length() const { return static_cast&lt;Index&gt;(suffixArray.size() - 1); }
	std::vector&lt;Index&gt; suffixArray;
	template&lt;typename AlphaT&gt; void sa_is(const AlphaT *str, Index n, int AlphaSize, Index *sa, std::vector&lt;Index&gt; &amp;bucketOffsets);
	template&lt;typename AlphaT&gt; void inducedSort(const AlphaT *str, Index n, int AlphaSize, const std::vector&lt;bool&gt; &amp;types, Index *sa, std::vector&lt;Index&gt; &amp;bucketOffsets);
	template&lt;typename AlphaT&gt; void countAlphabets(const AlphaT *str, Index n, int AlphaSize, std::vector&lt;Index&gt; &amp;bucketOffsets, bool b = false);
	template&lt;typename AlphaT&gt; void getBucketOffsets(const AlphaT *str, Index n, bool dir, int AlphaSize, std::vector&lt;Index&gt; &amp;bucketOffsets);
	void buildInverseSuffixArray();
	std::vector&lt;Index&gt; inverseSuffixArray;
	void computeLCPArray(const Alpha *str);
	std::vector&lt;Index&gt; lcpArray;
	typedef DirectRMQ&lt;Index&gt; LCPArrayRMQ;
	LCPArrayRMQ lcpArrayRMQ;
	void preprocessLCPArrayRMQ() {
		lcpArrayRMQ.build(&amp;lcpArray[0], length() + 1);
	}
	Index computeLCP(Index i, Index j) const;
};

void SuffixArray::build(const Alpha *str, Index n, int AlphaSize) {
	suffixArray.resize(n + 1);
	if(n == 0) suffixArray[0] = 0;
	else {
		std::vector&lt;Index&gt; bucketOffsets(std::max(AlphaSize, (n + 1) / 2) + 1);
		sa_is&lt;Alpha&gt;(str, n, AlphaSize, &amp;suffixArray[0], bucketOffsets);
	}
}

void SuffixArray::build(const Alpha *str, Index n) {
	Alpha maxElem = *std::max_element(str, str + n);
	assert(maxElem + 0 &lt; std::numeric_limits&lt;int&gt;::max());
	build(str, n, (int)(maxElem + 1));
}

void SuffixArray::buildAll(const Alpha *str, Index n) {
	build(str, n);
	buildInverseSuffixArray();
	computeLCPArray(str);
	preprocessLCPArrayRMQ();
}

template&lt;typename AlphaT&gt;
void SuffixArray::sa_is(const AlphaT *str, Index n, int AlphaSize, Index *sa, std::vector&lt;Index&gt; &amp;bucketOffsets) {
	std::vector&lt;bool&gt; types(n + 1);
	types[n - 1] = 0; types[n] = 1;
	for(Index i = n - 2; i &gt;= 0; i --)
		types[i] = str[i] &lt; str[i + 1] || (str[i] == str[i + 1] &amp;&amp; types[i + 1]);

	countAlphabets(str, n, AlphaSize, bucketOffsets);
	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	std::fill(sa, sa + n + 1, -1);
	for(Index i = 1; i &lt; n; i ++)
		if(types[i] &amp;&amp; !types[i - 1]) sa[-- bucketOffsets[(int)str[i]]] = i;
	sa[0] = n;
	inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);

	Index n1 = 0;
	for(Index i = 0; i &lt;= n; i ++) {
		Index j = sa[i];
		if(j &gt; 0 &amp;&amp; types[j] &amp;&amp; !types[j - 1]) sa[n1 ++] = j;
	}

	Index *buffer = sa + n1;
	std::fill(buffer, sa + n + 1, -1);
	Index uniqueLMSCount = 0, prevPos = -1;
	assert(sa[0] == n);
	buffer[sa[0] / 2] = uniqueLMSCount ++;	//'$'
	for(Index i = 1; i &lt; n1; i ++) {
		Index pos = sa[i]; bool diff = false;
		if(prevPos == -1) diff = true;
		else for(Index j = pos, k = prevPos; ; j ++, k ++) {
			if(str[j] != str[k] || types[j] != types[k]) {
				diff = true;
				break;
			} else if(j != pos &amp;&amp; ((types[j] &amp;&amp; !types[j - 1]) || (types[k] &amp;&amp; !types[k - 1])))
				break;
		}
		if(diff) {
			uniqueLMSCount ++;
			prevPos = pos;
		}
		buffer[pos / 2] = uniqueLMSCount - 1;
	}
	for(Index i = n, j = n; i &gt;= n1; i --)
		if(sa[i] &gt;= 0) sa[j --] = sa[i];

	Index *sa1 = sa, *s1 = sa + n + 1 - n1;
	if(uniqueLMSCount == n1)
		for(Index i = 0; i &lt; n1; i ++) sa1[s1[i]] = i;
	else
		sa_is&lt;Index&gt;(s1, n1 - 1, uniqueLMSCount, sa1, bucketOffsets);

	countAlphabets(str, n, AlphaSize, bucketOffsets);
	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	for(Index i = 1, j = 0; i &lt;= n; i ++)
		if(types[i] &amp;&amp; !types[i - 1]) s1[j ++] = i;
	for(Index i = 0; i &lt; n1; i ++) sa1[i] = s1[sa1[i]];
	std::fill(sa + n1, sa + n + 1, -1);
	for(Index i = n1 - 1; i &gt;= 1; i --) {
		Index j = sa[i]; sa[i] = -1;
		sa[-- bucketOffsets[(int)str[j]]] = j;
	}
	inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);
}

template&lt;typename AlphaT&gt;
void SuffixArray::inducedSort(const AlphaT *str, Index n, int AlphaSize, const std::vector&lt;bool&gt; &amp;types, Index *sa, std::vector&lt;Index&gt; &amp;bucketOffsets) {
	getBucketOffsets(str, n, false, AlphaSize, bucketOffsets);
	for(Index i = 0; i &lt; n; i ++) {
		Index j = sa[i] - 1;
		if(j &gt;= 0 &amp;&amp; !types[j]) sa[bucketOffsets[(int)str[j]] ++] = j;
	}

	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	for(Index i = n; i &gt;= 1; i --) {
		Index j = sa[i] - 1;
		if(j &gt;= 0 &amp;&amp; types[j]) sa[-- bucketOffsets[(int)str[j]]] = j;
	}
}

template&lt;typename AlphaT&gt;
void SuffixArray::countAlphabets(const AlphaT *str, Index n, int AlphaSize, std::vector&lt;Index&gt; &amp;bucketOffsets, bool b) {
	if(b || (int)bucketOffsets.size() / 2 &gt;= AlphaSize) {
		std::vector&lt;Index&gt;::iterator alphabetCounts =
			b ? bucketOffsets.begin() : bucketOffsets.begin() + AlphaSize;
		std::fill(alphabetCounts, alphabetCounts + AlphaSize, 0);
		for(Index i = 0; i &lt; n; i ++)
			alphabetCounts[(int)str[i]] ++;
	}
}

template&lt;typename AlphaT&gt;
void SuffixArray::getBucketOffsets(const AlphaT *str, Index n, bool dir, int AlphaSize, std::vector&lt;Index&gt; &amp;bucketOffsets) {
	std::vector&lt;Index&gt;::iterator alphabetCounts;
	if((int)bucketOffsets.size() / 2 &lt; AlphaSize) {
		countAlphabets(str, n, AlphaSize, bucketOffsets, true);
		alphabetCounts = bucketOffsets.begin();
	} else alphabetCounts = bucketOffsets.begin() + AlphaSize;
	Index cumsum = 1;
	if(dir) {
		for(int i = 0; i &lt; AlphaSize; i ++) {
			cumsum += alphabetCounts[i];
			bucketOffsets[i] = cumsum;
		}
	} else {
		for(int i = 0; i &lt; AlphaSize; i ++) {
			Index x = alphabetCounts[i];
			bucketOffsets[i] = cumsum;
			cumsum += x;
		}
	}
}

void SuffixArray::buildInverseSuffixArray() {
	Index n = length();
	inverseSuffixArray.resize(n + 1);
	for(Index i = 0; i &lt;= n; i ++)
		inverseSuffixArray[suffixArray[i]] = i;
}

void SuffixArray::computeLCPArray(const Alpha *str) {
	int n = length();
	lcpArray.resize(n + 2);
	Index h = 0;
	for(Index i = 0; i &lt; n; i ++) {
		Index pos = inverseSuffixArray[i];
		Index j = suffixArray[pos - 1];
		Index hbound = std::min(n - j, n - i);
		for(Index k = 0; h &lt; hbound &amp;&amp; str[i + h] == str[j + h]; ++ h);
		lcpArray[pos - 1] = h;
		if(h &gt; 0) -- h;
	}
	lcpArray[n] = lcpArray[n + 1] = 0;
}

SuffixArray::Index SuffixArray::computeLCP(Index i, Index j) const {
	Index n = length();
	if(i == j) return n - i;
	Index x = inverseSuffixArray[i], y = inverseSuffixArray[j];
	if(x &gt; y) std::swap(x, y);
	return lcpArrayRMQ.queryVal(&amp;lcpArray[0], x, y - 1);
}

unsigned xor128() {
	static unsigned x = 123456789, y = 362436069, z = 521288629, w = 88675123;
	unsigned t = x ^ (x &lt;&lt; 11);
	x = y; y = z; z = w;
	return w = w ^ (w &gt;&gt; 19) ^ (t ^ (t &gt;&gt; 8));
}

struct Node {
	static vector&lt;Node&gt; buf;
	static size_t bufp;
	typedef const Node *Ref;
	Ref left, right;
	int size;
	int key;
	Node() : left(NULL), right(NULL), size(1), key(0) {}
	static Ref newNode(Ref left, Ref right, int key) {
		if(bufp == buf.size()) {
			cerr &lt;&lt; "Memory exhausted!" &lt;&lt; endl;
			abort();
		}
		Node *p = new(&amp;buf[bufp ++])Node;
		p-&gt;left = left, p-&gt;right = right, p-&gt;key = key;
		return p;
	}
	inline Ref propagated() const {
		return this;
	}
	inline Ref linkl(Ref c) const {
		return newNode(c, right, key);
	}
	inline Ref linkr(Ref c) const {
		return newNode(left, c, key);
	}
	inline Ref linklr(Ref l, Ref r) const {
		return newNode(l, r, key);
	}
};
vector&lt;Node&gt; Node::buf;
size_t Node::bufp = 0;

struct RBST {
	typedef const Node *Ref;
	static int size(Ref t) { return !t ? 0 : t-&gt;size; }

	typedef pair&lt;Ref, Ref&gt; RefPair;
	static RefPair splitKey(Ref t, int key) {
		if(!t) return RefPair((Ref)NULL, (Ref)NULL);
		t = t-&gt;propagated();
		if(key &lt;= t-&gt;key) {
			RefPair p = splitKey(t-&gt;left, key);
			return RefPair(p.first, t-&gt;linkl(p.second));
		} else {
			RefPair p = splitKey(t-&gt;right, key);
			return RefPair(t-&gt;linkr(p.first), p.second);
		}
	}
	static Ref insertKey(Ref t, Ref n) {
		if(!t) return n-&gt;linklr(NULL, NULL);
		if(xor128() % (t-&gt;size + 1) == 0) {
			RefPair p = splitKey(t, n-&gt;key);
			return n-&gt;linklr(p.first, p.second);
		}
		t = t-&gt;propagated();
		if(n-&gt;key &lt;= t-&gt;key)
			return t-&gt;linkl(insertKey(t-&gt;left, n));
		else
			return t-&gt;linkr(insertKey(t-&gt;right, n));
	}

	static Ref last(Ref t) {
		if(!t || !t-&gt;right) return t;
		return last(t-&gt;right);
	};

	static Ref head(Ref t) {
		if(!t || !t-&gt;left) return t;
		return head(t-&gt;left);
	};
};

int main() {
	typedef Node::Ref Ref;
	Node::buf.resize(10000000);
	int T;
	scanf("%d", &amp;T);
	for(int ii = 0; ii &lt; T; ++ ii) {
		Node::bufp = 0;
		int N; int A; int B;
		scanf("%d%d%d", &amp;N, &amp;A, &amp;B);
		string S;
		cin &gt;&gt; S;
		SuffixArray sa;
		sa.buildAll(S.c_str(), N);
		vector&lt;Ref&gt; sets(N + 1);
		vector&lt;vector&lt;int&gt; &gt; events(N + 1);
		multiset&lt;int&gt; curMin;
		vector&lt;int&gt; dp(N + 1, INF);
		dp[0] = 0;
		rer(i, 0, N) {
			if(!curMin.empty())
				amin(dp[i], *curMin.begin());
			for(int t : events[i])
				curMin.erase(curMin.find(t));
			if(i == N) break;
			int x = dp[i];
			amin(dp[i + 1], x + A);

			int key = sa.inverseSuffixArray[i];

			int l = 0, u = i;
			while(u - l &gt; 0) {
				int mid = (l + u + 1) / 2;
				Ref t = sets[i - mid + 1];
				bool ok = false;
				auto p = RBST::splitKey(t, key);
				if(p.first != nullptr) {
					int pos = RBST::last(p.first)-&gt;key;
					ok |= sa.computeLCP(i, sa.suffixArray[pos]) &gt;= mid;
				}
				if(p.second != nullptr) {
					int pos = RBST::head(p.second)-&gt;key;
					ok |= sa.computeLCP(i, sa.suffixArray[pos]) &gt;= mid;
				}
				if(ok)
					l = mid;
				else
					u = mid - 1;
			}
//			cerr &lt;&lt; i &lt;&lt; ": " &lt;&lt; l &lt;&lt; endl;
			if(l &gt; 0) {
				curMin.insert(x + B);
				events[i + l].push_back(x + B);
			}

			sets[i + 1] = RBST::insertKey(sets[i], Node::newNode(0, 0, key));
		}
		int ans = dp[N];
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.125
hard
----------
PROBLEM STATEMENT:
The Kingdom of Gridland contains [expression] grid where each cell in the grid represents a city. Every cell in the grid contains a single lowercase character denoting the first character of the city name corresponding to that cell.

From a city with the coordinates [expression] unit of time (provided that the destination cell is within the confines of the grid):


[expression]
[expression]
[expression]
[expression]


A knight wants to visit all the cities in Gridland. He can start his journey in any city and immediately stops his journey after having visited each city at least once. Moreover, he always plans his journey in such a way that the total time required to complete it is minimum.

After completing his tour of each province, the knight forms a string by concatenating the characters of all the cells in his path. How many distinct strings can he form in each province?
----------
TOP SOLUTION:
----------
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.InputMismatchException;
import java.util.Random;
import java.io.OutputStreamWriter;
import java.util.NoSuchElementException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Iterator;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.Writer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Egor Kulikov (egor@egork.net)
 */
public class Solution {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        GridlandProvinces solver = new GridlandProvinces();
        int testCount = Integer.parseInt(in.next());
        for (int i = 1; i &lt;= testCount; i++) {
            solver.solve(i, in, out);
        }
        out.close();
    }

    static class GridlandProvinces {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
//        sss = new HashSet&lt;&gt;();
            int n = in.readInt();
            String[] s = IOUtils.readStringArray(in, 2);
            LongSet set = new LongHashSet();
            addAll(n, s, set);
            for (int i = 0; i &lt; 2; i++) {
                s[i] = StringUtils.reverse(s[i]);
            }
            addAll(n, s, set);
            out.printLine(set.size());
//        System.err.println(sss.size());
        }

        protected void addAll(int n, String[] s, LongSet set) {
            StringHash[] simple = new StringHash[2];
            for (int i = 0; i &lt; 2; i++) {
                simple[i] = new SimpleStringHash(s[i]);
            }
            StringHash[] reverse = new StringHash[2];
            for (int i = 0; i &lt; 2; i++) {
                reverse[i] = new SimpleStringHash(StringUtils.reverse(s[i]));
            }
            StringHash[] snail = new StringHash[2];
//        String[] sn = new String[2];
            for (int i = 0; i &lt; 2; i++) {
                StringBuilder current = new StringBuilder(2 * n);
                for (int j = 0; j &lt; n; j++) {
                    current.append(s[i ^ (j &amp; 1)].charAt(j));
                    current.append(s[1 - (i ^ (j &amp; 1))].charAt(j));
                }
                snail[i] = new SimpleStringHash(current.toString());
//            sn[i] = current.toString();
            }
            for (int i = 0; i &lt;= n; i++) {
                for (int j = i; j &lt;= n; j++) {
                    for (int k = 0; k &lt; 2; k++) {
//                    String ss = reverse(s[k]).substring(n - i, n) + s[1 - k].substring(0, i) + sn[1 - (k ^ (i &amp; 1))]
//                            .substring(2 * i, 2 * j) + s[1 - (k ^ ((j - i) &amp; 1))].substring(j, n) + reverse(s[(k ^ (
//                            (j - i) &amp; 1))]).substring(0, n - j);
//                    sss.add(ss);
//                    System.err.println(ss);
                        StringHash hash = new CompositeStringHash(new SubstringStringHash(reverse[k], n - i, n),
                                new CompositeStringHash(new SubstringStringHash(simple[1 - k], 0, i),
                                        new CompositeStringHash(new SubstringStringHash(snail[1 - (k ^ (i &amp; 1))], 2 *
                                                i, 2 * j),
                                                new CompositeStringHash(
                                                        new SubstringStringHash(simple[1 - (k ^ ((j - i) &amp; 1))
                                                                ], j, n),
                                                        new SubstringStringHash(reverse[(k ^ ((j - i) &amp; 1))], 0,
                                                                n - j)))));
                        set.add(hash.hash(0));
                    }
                }
            }
        }

    }

    static interface LongReversableCollection extends LongCollection {
    }

    static interface StringHash {
        long hash(int from, int to);

        long hash(int from);

        int length();

    }

    static class LongHashSet extends LongAbstractStream implements LongSet {
        private static final Random RND = new Random();
        private static final int[] SHIFTS = new int[4];
        private static final byte PRESENT_MASK = 1;
        private static final byte REMOVED_MASK = 2;
        private int size;
        private int realSize;
        private long[] values;
        private byte[] present;
        private int step;
        private int ratio;

        static {
            for (int i = 0; i &lt; 4; i++) {
                SHIFTS[i] = RND.nextInt(31) + 1;
            }
        }

        public LongHashSet() {
            this(3);
        }

        public LongHashSet(int capacity) {
            capacity = Math.max(capacity, 3);
            values = new long[capacity];
            present = new byte[capacity];
            ratio = 2;
            initStep(capacity);
        }

        public LongHashSet(LongCollection c) {
            this(c.size());
            addAll(c);
        }

        public LongHashSet(long[] arr) {
            this(new LongArray(arr));
        }

        private void initStep(int capacity) {
            step = RND.nextInt(capacity - 2) + 1;
            while (IntegerUtils.gcd(step, capacity) != 1) {
                step++;
            }
        }


        public LongIterator longIterator() {
            return new LongIterator() {
                private int position = size == 0 ? values.length : -1;

                public long value() throws NoSuchElementException {
                    if (position == -1) {
                        advance();
                    }
                    if (position &gt;= values.length) {
                        throw new NoSuchElementException();
                    }
                    if ((present[position] &amp; PRESENT_MASK) == 0) {
                        throw new IllegalStateException();
                    }
                    return values[position];
                }

                public boolean advance() throws NoSuchElementException {
                    if (position &gt;= values.length) {
                        throw new NoSuchElementException();
                    }
                    position++;
                    while (position &lt; values.length &amp;&amp; (present[position] &amp; PRESENT_MASK) == 0) {
                        position++;
                    }
                    return isValid();
                }

                public boolean isValid() {
                    return position &lt; values.length;
                }

                public void remove() {
                    if ((present[position] &amp; PRESENT_MASK) == 0) {
                        throw new IllegalStateException();
                    }
                    present[position] = REMOVED_MASK;
                }
            };
        }


        public int size() {
            return size;
        }


        public void add(long value) {
            ensureCapacity((realSize + 1) * ratio + 2);
            int current = getHash(value);
            while (present[current] != 0) {
                if ((present[current] &amp; PRESENT_MASK) != 0 &amp;&amp; values[current] == value) {
                    return;
                }
                current += step;
                if (current &gt;= values.length) {
                    current -= values.length;
                }
            }
            while ((present[current] &amp; PRESENT_MASK) != 0) {
                current += step;
                if (current &gt;= values.length) {
                    current -= values.length;
                }
            }
            if (present[current] == 0) {
                realSize++;
            }
            present[current] = PRESENT_MASK;
            values[current] = value;
            size++;
        }

        private int getHash(long value) {
            int hash = LongHash.hash(value);
            int result = hash;
            for (int i : SHIFTS) {
                result ^= hash &gt;&gt; i;
            }
            result %= values.length;
            if (result &lt; 0) {
                result += values.length;
            }
            return result;
        }

        private void ensureCapacity(int capacity) {
            if (values.length &lt; capacity) {
                capacity = Math.max(capacity * 2, values.length);
                rebuild(capacity);
            }
        }

        private void rebuild(int capacity) {
            initStep(capacity);
            long[] oldValues = values;
            byte[] oldPresent = present;
            values = new long[capacity];
            present = new byte[capacity];
            size = 0;
            realSize = 0;
            for (int i = 0; i &lt; oldValues.length; i++) {
                if ((oldPresent[i] &amp; PRESENT_MASK) == PRESENT_MASK) {
                    add(oldValues[i]);
                }
            }
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar &gt;= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars &lt;= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c &lt; '0' || c &gt; '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public String readString() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            StringBuilder res = new StringBuilder();
            do {
                if (Character.isValidCodePoint(c)) {
                    res.appendCodePoint(c);
                }
                c = read();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public String next() {
            return readString();
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void printLine(int i) {
            writer.println(i);
        }

    }

    static interface LongIterator {
        public long value() throws NoSuchElementException;

        public boolean advance();

        public boolean isValid();

    }

    static interface LongSet extends LongCollection {
    }

    static interface LongStream extends Iterable&lt;Long&gt;, Comparable&lt;LongStream&gt; {
        public LongIterator longIterator();

        default public Iterator&lt;Long&gt; iterator() {
            return new Iterator&lt;Long&gt;() {
                private LongIterator it = longIterator();

                public boolean hasNext() {
                    return it.isValid();
                }

                public Long next() {
                    long result = it.value();
                    it.advance();
                    return result;
                }
            };
        }

        default public int compareTo(LongStream c) {
            LongIterator it = longIterator();
            LongIterator jt = c.longIterator();
            while (it.isValid() &amp;&amp; jt.isValid()) {
                long i = it.value();
                long j = jt.value();
                if (i &lt; j) {
                    return -1;
                } else if (i &gt; j) {
                    return 1;
                }
                it.advance();
                jt.advance();
            }
            if (it.isValid()) {
                return 1;
            }
            if (jt.isValid()) {
                return -1;
            }
            return 0;
        }

    }

    static class StringUtils {
        public static String reverse(String sample) {
            StringBuilder result = new StringBuilder(sample);
            result.reverse();
            return result.toString();
        }

    }

    static class SubstringStringHash extends AbstractStringHash {
        private final StringHash base;
        private final int from;
        private final int to;

        public SubstringStringHash(StringHash base, int from) {
            this(base, from, base.length());
        }

        public SubstringStringHash(StringHash base, int from, int to) {
            this.base = base;
            this.from = from;
            this.to = to;
        }

        public long hash(int from, int to) {
            if (to + this.from &gt; this.to) {
                throw new IndexOutOfBoundsException();
            }
            return base.hash(from + this.from, to + this.from);
        }

        public int length() {
            return to - from;
        }

    }

    static interface LongCollection extends LongStream {
        public int size();

        default public void add(long value) {
            throw new UnsupportedOperationException();
        }

        default public LongCollection addAll(LongStream values) {
            for (LongIterator it = values.longIterator(); it.isValid(); it.advance()) {
                add(it.value());
            }
            return this;
        }

    }

    static class SimpleStringHash extends AbstractStringHash {
        private static long[] firstReversePower = new long[0];
        private static long[] secondReversePower = new long[0];
        private final long[] firstHash;
        private final long[] secondHash;

        public SimpleStringHash(CharSequence string) {
            int length = string.length();
            ensureCapacity(length);
            firstHash = new long[length + 1];
            secondHash = new long[length + 1];
            long firstPower = 1;
            long secondPower = 1;
            for (int i = 0; i &lt; length; i++) {
                firstHash[i + 1] = (firstHash[i] + string.charAt(i) * firstPower) % AbstractStringHash.FIRST_MOD;
                secondHash[i + 1] = (secondHash[i] + string.charAt(i) * secondPower) % AbstractStringHash.SECOND_MOD;
                firstPower *= AbstractStringHash.MULTIPLIER;
                firstPower %= AbstractStringHash.FIRST_MOD;
                secondPower *= AbstractStringHash.MULTIPLIER;
                secondPower %= AbstractStringHash.SECOND_MOD;
            }
        }

        private void ensureCapacity(int length) {
            if (firstReversePower.length &gt;= length) {
                return;
            }
            length = Math.max(length + 1, firstReversePower.length &lt;&lt; 1);
            long[] oldFirst = firstReversePower;
            long[] oldSecond = secondReversePower;
            firstReversePower = new long[length];
            secondReversePower = new long[length];
            System.arraycopy(oldFirst, 0, firstReversePower, 0, oldFirst.length);
            System.arraycopy(oldSecond, 0, secondReversePower, 0, oldSecond.length);
            firstReversePower[0] = secondReversePower[0] = 1;
            for (int i = Math.max(oldFirst.length, 1); i &lt; length; i++) {
                firstReversePower[i] = firstReversePower[i - 1] * AbstractStringHash.FIRST_REVERSE_MULTIPLIER %
                        AbstractStringHash.FIRST_MOD;
                secondReversePower[i] = secondReversePower[i - 1] * AbstractStringHash.SECOND_REVERSE_MULTIPLIER %
                        AbstractStringHash.SECOND_MOD;
            }
        }

        public long hash(int from, int to) {
            return (((firstHash[to] - firstHash[from] + AbstractStringHash.FIRST_MOD) * firstReversePower[from] %
                    AbstractStringHash.FIRST_MOD) &lt;&lt; 32) +
                    ((secondHash[to] - secondHash[from] + AbstractStringHash.SECOND_MOD) * secondReversePower[from] %
                            AbstractStringHash.SECOND_MOD);
        }

        public int length() {
            return firstHash.length - 1;
        }

    }

    static class LongHash {
        private LongHash() {
        }

        public static int hash(long c) {
            return (int) ((c &gt;&gt;&gt; 32) ^ c);
        }

    }

    static abstract class AbstractStringHash implements StringHash {
        public static final long MULTIPLIER;
        protected static final long FIRST_REVERSE_MULTIPLIER;
        protected static final long SECOND_REVERSE_MULTIPLIER;
        public static final long FIRST_MOD;
        public static final long SECOND_MOD;

        static {
            Random random = new Random(System.currentTimeMillis());
            FIRST_MOD = IntegerUtils.nextPrime((long) (1e9 + random.nextInt((int) 1e9)));
            SECOND_MOD = IntegerUtils.nextPrime((long) (1e9 + random.nextInt((int) 1e9)));
            MULTIPLIER = random.nextInt((int) 1e9 - 257) + 257;
            FIRST_REVERSE_MULTIPLIER = IntegerUtils.reverse(MULTIPLIER, FIRST_MOD);
            SECOND_REVERSE_MULTIPLIER = IntegerUtils.reverse(MULTIPLIER, SECOND_MOD);
        }

        public long hash(int from) {
            return hash(from, length());
        }

    }

    static interface LongList extends LongReversableCollection {
        public abstract long get(int index);

        public abstract void addAt(int index, long value);

        public abstract void removeAt(int index);

        default public LongIterator longIterator() {
            return new LongIterator() {
                private int at;
                private boolean removed;

                public long value() {
                    if (removed) {
                        throw new IllegalStateException();
                    }
                    return get(at);
                }

                public boolean advance() {
                    at++;
                    removed = false;
                    return isValid();
                }

                public boolean isValid() {
                    return !removed &amp;&amp; at &lt; size();
                }

                public void remove() {
                    removeAt(at);
                    at--;
                    removed = true;
                }
            };
        }


        default public void add(long value) {
            addAt(size(), value);
        }

    }

    static class LongArray extends LongAbstractStream implements LongList {
        private long[] data;

        public LongArray(long[] arr) {
            data = arr;
        }

        public int size() {
            return data.length;
        }

        public long get(int at) {
            return data[at];
        }

        public void addAt(int index, long value) {
            throw new UnsupportedOperationException();
        }

        public void removeAt(int index) {
            throw new UnsupportedOperationException();
        }

    }

    static abstract class LongAbstractStream implements LongStream {

        public String toString() {
            StringBuilder builder = new StringBuilder();
            boolean first = true;
            for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
                if (first) {
                    first = false;
                } else {
                    builder.append(' ');
                }
                builder.append(it.value());
            }
            return builder.toString();
        }


        public boolean equals(Object o) {
            if (!(o instanceof LongStream)) {
                return false;
            }
            LongStream c = (LongStream) o;
            LongIterator it = longIterator();
            LongIterator jt = c.longIterator();
            while (it.isValid() &amp;&amp; jt.isValid()) {
                if (it.value() != jt.value()) {
                    return false;
                }
                it.advance();
                jt.advance();
            }
            return !it.isValid() &amp;&amp; !jt.isValid();
        }


        public int hashCode() {
            int result = 0;
            for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
                result *= 31;
                result += it.value();
            }
            return result;
        }

    }

    static class IntegerUtils {
        public static int gcd(int a, int b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b != 0) {
                int temp = a % b;
                a = b;
                b = temp;
            }
            return a;
        }

        public static long power(long base, long exponent, long mod) {
            if (base &gt;= mod) {
                base %= mod;
            }
            if (exponent == 0) {
                return 1 % mod;
            }
            long result = power(base, exponent &gt;&gt; 1, mod);
            result = result * result % mod;
            if ((exponent &amp; 1) != 0) {
                result = result * base % mod;
            }
            return result;
        }

        public static long reverse(long number, long module) {
            return power(number, module - 2, module);
        }

        public static boolean isPrime(long number) {
            if (number &lt; 2) {
                return false;
            }
            for (long i = 2; i * i &lt;= number; i++) {
                if (number % i == 0) {
                    return false;
                }
            }
            return true;
        }

        public static long nextPrime(long from) {
            if (from &lt;= 2) {
                return 2;
            }
            from += 1 - (from &amp; 1);
            while (!isPrime(from)) {
                from += 2;
            }
            return from;
        }

    }

    static class CompositeStringHash extends AbstractStringHash {
        private static long[] firstPower = new long[0];
        private static long[] secondPower = new long[0];
        private final StringHash first;
        private final StringHash second;

        public CompositeStringHash(StringHash first, StringHash second) {
            this.first = first;
            this.second = second;
            ensureCapacity(first.length() + 1);
        }

        private void ensureCapacity(int length) {
            if (firstPower.length &gt;= length) {
                return;
            }
            length = Math.max(length + 1, firstPower.length &lt;&lt; 1);
            long[] oldFirst = firstPower;
            long[] oldSecond = secondPower;
            firstPower = new long[length];
            secondPower = new long[length];
            System.arraycopy(oldFirst, 0, firstPower, 0, oldFirst.length);
            System.arraycopy(oldSecond, 0, secondPower, 0, oldSecond.length);
            firstPower[0] = secondPower[0] = 1;
            for (int i = Math.max(oldFirst.length, 1); i &lt; length; i++) {
                firstPower[i] = firstPower[i - 1] * AbstractStringHash.MULTIPLIER % AbstractStringHash.FIRST_MOD;
                secondPower[i] = secondPower[i - 1] * AbstractStringHash.MULTIPLIER % AbstractStringHash.SECOND_MOD;
            }
        }

        public long hash(int from, int to) {
            long firstFirst;
            long firstSecond;
            long secondFirst;
            long secondSecond;
            if (to &lt;= first.length()) {
                secondFirst = 0;
                secondSecond = 0;
            } else {
                long value = second.hash(Math.max(0, from - first.length()), to - first.length());
                secondFirst = value &gt;&gt;&gt; 32;
                secondSecond = value &amp; ((1L &lt;&lt; 32) - 1);
            }
            if (from &gt;= first.length()) {
                firstFirst = 0;
                firstSecond = 0;
            } else {
                long value = first.hash(from, Math.min(to, first.length()));
                firstFirst = value &gt;&gt;&gt; 32;
                firstSecond = value &amp; ((1L &lt;&lt; 32) - 1);
            }
            return (((firstFirst + secondFirst * firstPower[Math.max(0, first.length() - from)]) %
                    AbstractStringHash.FIRST_MOD) &lt;&lt; 32) +
                    ((firstSecond + secondSecond * secondPower[Math.max(0, first.length() - from)]) %
                            AbstractStringHash.SECOND_MOD);
        }

        public int length() {
            return first.length() + second.length();
        }

    }

    static class IOUtils {
        public static String[] readStringArray(InputReader in, int size) {
            String[] array = new String[size];
            for (int i = 0; i &lt; size; i++) {
                array[i] = in.readString();
            }
            return array;
        }

    }
}


----------
====================
----------
ALGORITHMS.126
expert
----------
PROBLEM STATEMENT:
Alice was given the [expression] possible permutations:


[expression]
[expression]
[expression]
[expression]
[expression]
[expression]


She then chose one permutation among them as her favorite permutation.

After some time, she forgot some elements of her favorite permutation. Nevertheless, she still tried to write down its elements. She wrote a [expression] in every position where she forgot the true value.

She wants to know the sum of the line numbers of the permutations which could possibly be her favorite permutation, i.e., permutations which can be obtained by replacing the [expression]s. Can you help her out? 

Since the sum can be large, find it modulo [expression].
----------
TOP SOLUTION:
----------
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
using namespace std;

const int kMaxN = 3e5+5, kMod = 1e9+7;

int fact[kMaxN], inv_fact[kMaxN];

int num_constant_ft[kMaxN], num_wildcard_ft[kMaxN];

int n;
void Update(int aib[], int pos, int val) {
    while (pos &lt;= n) {
        aib[pos] += val;
        pos += pos &amp; (-pos);    
    }
}

int Query(int aib[], int pos) {
    int r = 0;
    while (pos) {
        r += aib[pos];
        pos -= pos &amp; (-pos);
    }
    return r;
}


int&amp; Mod(int&amp; a) {
    if (a &gt;= kMod) {
        return a -= kMod;
    }
    return a;
}

int Pow(int a, int p) {
    int r = 1;
    while (p) {
        if (p &amp; 1) {
            r = 1LL * r * a % kMod;
        }
        a = 1LL * a * a % kMod;
        p /= 2;
    }
    return r;
}

void Init(int n) {
    fact[0] = inv_fact[1] = 1;
    for (int i = 1; i &lt;= n; i += 1) {
        fact[i] = 1LL * fact[i - 1] * i % kMod;
    }

    inv_fact[n] = Pow(fact[n], kMod - 2);
    for (int i = n - 1; i; i -= 1) {
        inv_fact[i] = 1LL * inv_fact[i + 1] * (i + 1) % kMod;
    }
}

int main() {
    cin &gt;&gt; n;
    Init(n);
    vector&lt;int&gt; v(n);
    for (auto&amp; itr : v) {
        cin &gt;&gt; itr;
    }
    
    int num_wildcard = 0;
    map&lt;int, int&gt; is_present;
    for (int i = 1; i &lt;= n; i += 1) {
        is_present[i] = false;
    }
    for (auto itr : v) {
        num_wildcard += (itr == 0);
        if (itr) {
            is_present[itr] = true;
        }
    }

    vector&lt;int&gt; wildcard_values = {};
    for (auto itr : is_present) {
        if (itr.second == 0) {
            wildcard_values.push_back(itr.first);
        }
    }

    int answer = 0;
    int num_wildcards_right = 0;
    int num_wildcard_constant = 0;
    for (auto itr : wildcard_values) {
        Update(num_wildcard_ft, itr, +1);
    }

    for (int i = n - 1; i &gt;= 0; i -= 1) {
        int f = fact[n - i - 1];
        if (v[i] == 0) {
            // wildcard wildcard
            if (num_wildcard &gt; 1) {
                Mod(answer += 1LL * f * ((1LL * num_wildcard * (num_wildcard - 1) / 2) % kMod) % kMod * num_wildcards_right % kMod * fact[num_wildcard - 2] % kMod);
            }

            // wildcard constant
            if (num_wildcard) {
                Mod(answer += 1LL * f * num_wildcard_constant % kMod * fact[num_wildcard - 1] % kMod);
            }

            num_wildcards_right += 1;
        } else {
            Mod(num_wildcard_constant += num_wildcard - Query(num_wildcard_ft, v[i]));

            // constant wildcard
            if (num_wildcard) {
                Mod(answer += 1LL * f * num_wildcards_right % kMod * Query(num_wildcard_ft, v[i]) % kMod * fact[num_wildcard - 1] % kMod);
            }

            // constant constant
            Mod(answer += 1LL * f * Query(num_constant_ft, v[i]) % kMod * fact[num_wildcard] % kMod);
            Update(num_constant_ft, v[i], +1);
        }
    }

    Mod(answer += fact[num_wildcard]);
    cout &lt;&lt; answer &lt;&lt; '\n';
}










----------
====================
----------
ALGORITHMS.127
advanced
----------
PROBLEM STATEMENT:
Ashton appeared for a job interview and is asked the following question. Arrange all the distinct substrings  of a given string in lexicographical order and concatenate them. Print the [expression] character. Can you help Ashton out with this?  

For example, given the string [expression] character of the 1-indexed concatenated string.  

Note We have distinct substrings here, i.e. if string is aa, it's distinct substrings are a and aa.  

Function Description  

Complete the ashtonString function in the editor below.  It should return the [expression] character from the concatenated string, 1-based indexing.  

ashtonString has the following parameters: 
- s: a string 
- k: an integer  
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I &lt; (N); ++I)
#define REPP(I, A, B) for (int I = (A); I &lt; (B); ++I)
#define RI(X) scanf("%d", &amp;(X))
#define RII(X, Y) scanf("%d%d", &amp;(X), &amp;(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &amp;(X), &amp;(Y), &amp;(Z))
#define DRI(X) int (X); scanf("%d", &amp;X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &amp;X, &amp;Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &amp;X, &amp;Y, &amp;Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &amp;___T); while (___T-- &gt; 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
typedef long long LL;
using namespace std;
const int MAXLEN = (int)1e5 + 5;

char s[MAXLEN];
int SA[MAXLEN], cnt[MAXLEN], ary1[MAXLEN], ary2[MAXLEN];
int *Rank, *Height;


inline bool cmp(int *r, int a, int b, int l) {
    return r[a] == r[b] &amp;&amp; r[a + l] == r[b + l];
}

void make_suffix_array(int MSIZE, int len) {
    int p, *x, *y, *tmp, i, j, k;
    x = ary1; y = ary2;
    memset(cnt, 0, sizeof(int) * MSIZE);
    for (i = 0; i &lt; len; i++) cnt[x[i] = s[i]]++;
    for (i = 1; i &lt; MSIZE; i++) cnt[i] += cnt[i - 1];
    for (i = len - 1; i &gt;= 0; i--) SA[--cnt[x[i]]] = i;
    for (j = p = 1; p &lt; len; j &lt;&lt;= 1, MSIZE = p) {
        for (p = 0, i = len - j; i &lt; len; i++) y[p++] = i;
        for (i = 0; i &lt; len; i++) {
            if (SA[i] &gt;= j) y[p++] = SA[i] - j;
        }
        memset(cnt, 0, sizeof(int) * MSIZE);
        for (i = 0; i &lt; len; i++) cnt[x[y[i]]]++;
        for (i = 1; i &lt; MSIZE; i++) cnt[i] += cnt[i - 1];
        for (i = len - 1; i &gt;= 0; i--) SA[--cnt[x[y[i]]]] = y[i];
        tmp = x; x = y; y = tmp;
        x[SA[0]] = 0;
        for (i = p = 1; i &lt; len; i++) {
            x[SA[i]] = cmp(y, SA[i - 1], SA[i], j) ? p - 1 : p++;
        }
    }
    Rank = x;
    Height = y;
    for (i = k = 0; i &lt; len - 1; i++) {
        if (k &gt; 0) k--;
        j = SA[Rank[i] - 1];
        while (s[i + k] == s[j + k]) k++;
        Height[Rank[i]] = k;
    }
}
LL get(LL x,LL y){
    return (x+y)*(y-x+1)/2;
}
int main(){
    CASET{
        RS(s);
        int n=LEN(s);
        LL K;
        cin&gt;&gt;K;
        make_suffix_array(128,n+1);
        int now=0;
        REPP(i,1,n+1){
            now=Height[i];
            if(K&lt;=get(now+1,n-SA[i])){
                LL ll=now+1,rr=n-SA[i];
                while(ll&lt;rr){
                    LL mm=(ll+rr)&gt;&gt;1;
                    if(get(now+1,mm)&lt;K)ll=mm+1;
                    else rr=mm;
                }
                K-=get(now+1,ll-1);
                printf("%c\n",s[SA[i]+K-1]);
                break;
            }
            else K-=get(now+1,n-SA[i]);
        }
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.128
expert
----------
PROBLEM STATEMENT:
For two strings A and B, we define the similarity of the strings to be the length of the longest prefix common to both strings. For example, the similarity of strings "abc" and "abd" is 2, while the similarity of strings "aaa" and "aaab" is 3.

Calculate the sum of similarities of a string S with each of it's suffixes.
----------
TOP SOLUTION:
----------
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;numeric&gt;
#include &lt;memory.h&gt;
#include &lt;cstdio&gt;
#include &lt;assert.h&gt;
#include &lt;numeric&gt;

using namespace std;

#define pb push_back
#define INF 1011111111
#define FOR(i,a,b) for (int _n(b), i(a); i &lt; _n; i++)
#define rep(i,n) FOR(i,0,n)
#define ford(i,a,b) for(int i=(a),_b=(b);i&gt;=_b;--i)
#define CL(a,v) memset((a),(v),sizeof(a))
#define mp make_pair
#define X first
#define Y second
#define all(c) (c).begin(), (c).end()
#define SORT(c) sort(all(c))

typedef long long ll;
typedef vector&lt;int&gt; VI;
typedef pair&lt;int,int&gt; pii;

vector&lt;ll&gt; z_func(const string &amp;s)
{
    int n = s.size();
    vector&lt;ll&gt; z(n,0);
    int l = 0,r = 0;

    FOR(i,1,n)
    {
        if(i &lt;= r)
            z[i] = min(z[i-l], (ll)r-i+1);

        while(i+z[i] &lt; n &amp;&amp; s[i+z[i]] == s[z[i]]) z[i] ++;

        if(i+z[i]-1 &gt; r)
            r = i+z[i]-1, l = i;
    }

    return z;
}

int main()
{
	#ifndef ONLINE_JUDGE
        //freopen("input.txt","r",stdin);
        //freopen("output.txt","w",stdout);
	#endif

    int T;
    cin &gt;&gt; T;

    while(T--)
    {
        string s;
        cin &gt;&gt; s;

        vector&lt;ll&gt; z = z_func(s);

        cout &lt;&lt; 1LL*s.size() + accumulate(all(z), 0LL) &lt;&lt; endl;
    }

	return 0;
}

----------
====================
----------
ALGORITHMS.129
advanced
----------
PROBLEM STATEMENT:
We define a function, [expression], as follows:

[expression]

where:


[expression].
[expression].


Consuela loves creating string challenges and she needs your help testing her newest one! Given a string, [expression].
----------
TOP SOLUTION:
----------
/*********************************************************************\
   |--\        ---       /\        |-----------| -----   /-------|    |
   |   \        |       /  \       |               |    /             |
   |    \       |      /    \      |               |   |              |
   |     \      |     /      \     |               |   |----|         |
   |      \     |    / ------ \    |-------|       |        |-----|   |
   |       \    |   /          \   |               |              |   |
   |        \   |  /            \  |               |              /   |
  ---        -------            ------           ----- |---------/    |
                                                                      |
    codeforces = nfssdq  ||  topcoder = nafis007                      |
    mail = nafis_sadique@yahoo.com || nfssdq@gmail.com                |
    IIT,Jahangirnagar University(41)                                  |
                                                                      |
**********************************************************************/

#include &lt;bits/stdc++.h&gt;
using namespace std;

#define xx         first
#define yy         second
#define pb         push_back
#define mp         make_pair
#define LL         long long
#define inf        INT_MAX/3
#define mod        1000000007ll
#define PI         acos(-1.0)
#define linf       (1ll&lt;&lt;60)-1
#define FOR(I,A,B) for(int I = (A); I &lt; (B); ++I)
#define REP(I,N)   FOR(I,0,N)
#define ALL(A)     ((A).begin(), (A).end())
#define set0(ar)   memset(ar,0,sizeof ar)
#define vsort(v)   sort(v.begin(),v.end())
#define setinf(ar) memset(ar,126,sizeof ar)

//cout &lt;&lt; fixed &lt;&lt; setprecision(20) &lt;&lt; p &lt;&lt; endl;

template &lt;class T&gt; inline T bigmod(T p,T e,T M){
    LL ret = 1;
    for(; e &gt; 0; e &gt;&gt;= 1){
        if(e &amp; 1) ret = (ret * p) % M;
        p = (p * p) % M;
    } return (T)ret;
}
template &lt;class T&gt; inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}
template &lt;class T&gt; inline T modinverse(T a,T M){return bigmod(a,M-2,M);}

const int N = 3e5+10; // 3* MX size
int A[N] , rnk[N] , sa[N] , height[N];
char str[N];
void ini()
{
    memset(A,0,sizeof A);
    memset(rnk,0,sizeof rnk);
    memset(sa,0,sizeof sa);
    memset(height,0,sizeof height);
}
namespace Suffix_array
{
    # define F(x) ((x)/3+((x)%3==1?0:tb))
    # define G(x) ((x)&lt;tb?(x)*3+1:((x)-tb)*3+2)
    int wa[N * 3] , wb[N * 3] , wv[N * 3] , ws[N * 3];
    int c0(int *r, int a, int b)
    {
        return r[a] == r[b] &amp;&amp; r[a + 1] == r[b + 1] &amp;&amp; r[a + 2] == r[b + 2];
    }
    int c12(int k, int *r, int a, int b)
    {
        if (k == 2)
            return r[a] &lt; r[b] || r[a] == r[b] &amp;&amp; c12(1, r, a + 1, b + 1);
        else return r[a] &lt; r[b] || r[a] == r[b] &amp;&amp; wv[a + 1] &lt; wv[b + 1];
    }
    void sort(int *r, int *a, int *b, int n, int m)
    {
        int i;
        for (i = 0; i &lt; n; i++) wv[i] = r[a[i]];
        for (i = 0; i &lt; m; i++) ws[i] = 0;
        for (i = 0; i &lt; n; i++) ws[wv[i]]++;
        for (i = 1; i &lt; m; i++) ws[i] += ws[i-1];
        for (i = n-1; i &gt;= 0; i--) b[--ws[wv[i]]] = a[i];
        return;
    }
    void dc3(int *r, int *sa, int n, int m)
    {
        int i, j, *rn = r + n;
        int *san = sa + n, ta = 0, tb = (n + 1) / 3, tbc = 0, p;
        r[n] = r[n + 1] = 0;
        for (i = 0; i &lt; n; i++) if (i % 3 != 0) wa[tbc++] = i;
        sort(r + 2, wa, wb, tbc, m);
        sort(r + 1, wb, wa, tbc, m);
        sort(r, wa, wb, tbc, m);
        for (p = 1, rn[F(wb[0])] = 0, i = 1; i &lt; tbc; i++)
            rn[F(wb[i])] = c0(r, wb[i-1], wb[i]) ? p-1 : p++;
        if (p &lt; tbc) dc3(rn, san, tbc, p);
        else for (i = 0; i &lt; tbc; i++) san[rn[i]] = i;
        for (i = 0; i &lt; tbc; i++) if (san[i] &lt; tb) wb[ta++] = san[i] * 3;
        if (n % 3 == 1) wb[ta++] = n-1;
        sort(r, wb, wa, ta, m);
        for (i = 0; i &lt; tbc; i++) wv[wb[i] = G(san[i])] = i;
        for (i = 0, j = 0, p = 0; i &lt; ta &amp;&amp; j &lt; tbc; p++)
            sa[p] = c12(wb[j] % 3, r, wa[i], wb[j]) ? wa[i++] : wb[j++];
        for (; i &lt; ta; p++) sa[p] = wa[i++];
        for (; j &lt; tbc; p++) sa[p] = wb[j++];
    }
    void da(int str[],int sa[],int rnk[],int height[],int n,int m)
    {
        for (int i = n; i &lt; n * 3; i++)
            str[i] = 0;
        dc3 (str , sa , n + 1 , m);
        int i, j, k;
        for (i = 0; i &lt; n; i++)
        {
            sa[i] = sa[i + 1];
            rnk[sa[i]] = i;
        }
        for (i = 0, j = 0, k = 0; i &lt; n; height[rnk[i ++]] = k)
            if (rnk[i] &gt; 0)
                for (k ? k--: 0 , j = sa[rnk[i]-1];
                        i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; str[i + k] == str[j + k];
                        k++);
    }
} using namespace Suffix_array;


LL pow_sum[27][100001];
string S;
int pre[100001][27], ar[100001];
int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    FOR(i, 1, 100001) pow_sum[0][i] = 1;
    FOR(i, 1, 27){
        FOR(j, 1, 100001){
            pow_sum[i][j] = (pow_sum[i-1][j] * (LL)j) % mod;
        }
    }
    REP(i, 27){
        FOR(j, 1, 100001) pow_sum[i][j] = (pow_sum[i][j] + pow_sum[i][j-1]) % mod;
    }

    int T; cin &gt;&gt; T;
    while(T--){
        cin &gt;&gt; S;
        LL res = 0;

        REP(i, S.size()) A[i] = S[i];
        da(A, sa, rnk, height, S.size(), 128);

        ar[sa[0]] = 0;
        FOR(i, 1, S.size()){
            ar[sa[i]] = height[i];
        }

        for(int i = S.size()-1; i &gt;= 0; i--){
            REP(j, 26){
                if(i == S.size()-1)pre[i][j] = S.size();
                else pre[i][j] = pre[i+1][j];
            }
            pre[i][S[i]-'a'] = i;
            vector &lt; int &gt; vc;
            REP(j, 26){
                vc.pb(pre[i][j]);
            }
            vsort(vc);
            REP(j, vc.size()){
                if(vc[j] == S.size()) break;
                int nxt = S.size();
                if(j &lt; vc.size()-1 &amp;&amp; vc[j+1] != S.size()) nxt = vc[j+1];
                if(nxt-i &lt; ar[i]) continue;
                int r = nxt - i;
                int l = vc[j] - i + 1;
                if(l &lt; ar[i]+1) l = ar[i]+1;

                res = (res + pow_sum[j+1][r] - pow_sum[j+1][l-1] + mod) % mod;
            }

        }

        cout &lt;&lt; res &lt;&lt; endl;
    }
}

----------
====================
----------
ALGORITHMS.130
advanced
----------
PROBLEM STATEMENT:
A palindrome is a string that reads the same from left to right as it does from right to left.

Given a string, [expression]). See the Explanation section for examples.

Given [expression] on a new line.
----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;

#define REP(i,a,b) for(i=a;i&lt;b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

#define ll long long
#define ull unsigned ll

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'&lt;=k&amp;&amp;k&lt;='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k&lt;'0'||k&gt;'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'&lt;=k&amp;&amp;k&lt;='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k&lt;'0'||k&gt;'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(double *x){scanf("%lf",x);}
int reader(char c[]){int i,s=0;for(;;){mygc(i);if(i!=' '&amp;&amp;i!='\n'&amp;&amp;i!='\r'&amp;&amp;i!='\t'&amp;&amp;i!=EOF) break;}c[s++]=i;for(;;){mygc(i);if(i==' '||i=='\n'||i=='\r'||i=='\t'||i==EOF) break;c[s++]=i;}c[s]='\0';return s;}
template &lt;class T, class S&gt; void reader(T *x, S *y){reader(x);reader(y);}
template &lt;class T, class S, class U&gt; void reader(T *x, S *y, U *z){reader(x);reader(y);reader(z);}
template &lt;class T, class S, class U, class V&gt; void reader(T *x, S *y, U *z, V *w){reader(x);reader(y);reader(z);reader(w);}

void writer(int x, char c){int s=0,m=0;char f[10];if(x&lt;0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(ll x, char c){int s=0,m=0;char f[20];if(x&lt;0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(double x, char c){printf("%.15f",x);mypc(c);}
void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}
void writer(const char x[], char c){int i;for(i=0;x[i]!='\0';i++)mypc(x[i]);mypc(c);}
template&lt;class T&gt; void writerLn(T x){writer(x,'\n');}
template&lt;class T, class S&gt; void writerLn(T x, S y){writer(x,' ');writer(y,'\n');}
template&lt;class T, class S, class U&gt; void writerLn(T x, S y, U z){writer(x,' ');writer(y,' ');writer(z,'\n');}
template&lt;class T&gt; void writerArr(T x[], int n){int i;if(!n){mypc('\n');return;}rep(i,n-1)writer(x[i],' ');writer(x[n-1],'\n');}

template&lt;class T&gt; void sort(int N, T a[], void *mem = NULL){sort(a,a+N);}
template&lt;class T1, class T2&gt; void sort(int N, T1 a[], T2 b[], void *mem){int i;pair&lt;T1,T2&gt; *r=(pair&lt;T1, T2&gt;*)mem;rep(i,N)r[i].first=a[i],r[i].second=b[i];sort(r,r+N);rep(i,N)a[i]=r[i].first,b[i]=r[i].second;}
template&lt;class T1, class T2, class T3&gt; void sort(int N, T1 a[], T2 b[], T3 c[], void *mem){int i;pair&lt;T1,pair&lt;T2,T3&gt; &gt; *r=(pair&lt;T1,pair&lt;T2,T3&gt; &gt;*)mem;rep(i,N)r[i].first=a[i],r[i].second.first=b[i],r[i].second.second=c[i];sort(r,r+N);rep(i,N)a[i]=r[i].first,b[i]=r[i].second.first,c[i]=r[i].second.second;}
template&lt;class T1, class T2, class T3, class T4&gt; void sort(int N, T1 a[], T2 b[], T3 c[], T4 d[], void *mem){int i;pair&lt;pair&lt;T1,T2&gt;,pair&lt;T3,T4&gt; &gt; *r=(pair&lt;pair&lt;T1,T2&gt;,pair&lt;T3,T4&gt; &gt;*)mem;rep(i,N)r[i].first.first=a[i],r[i].first.second=b[i],r[i].second.first=c[i],r[i].second.second=d[i];sort(r,r+N);rep(i,N)a[i]=r[i].first.first,b[i]=r[i].first.second,c[i]=r[i].second.first,d[i]=r[i].second.second;}


char memarr[77000000]; void *mem = memarr;
#define MD 1000000007

template&lt;class T&gt;
struct rollingHash64{
  int len;
  T *data;
  ull *sum, *rev, *pw;
  ull mul;

  ull getinv(ull a){
    ull t,s=a,u=0,v=1,e;
    e = numeric_limits&lt;ull&gt;::max() / s;
    t -= e * s;
    u -= e * v;
    swap(t,s);
    swap(u,v);
    while(s){
      e=t/s;
      t-=e*s;
      u-=e*v;
      swap(t,s);
      swap(u,v);
    }
    return u;
  }

  void* init(int n, T *arr, ull m = 0, void *mem = NULL){
    int i; ull v;

    mul = m;
    if(mul==0) mul = 2*(rand()%1000000000) + 1000000001ULL;

    len = n;
    data = arr;
    if(mem == NULL){
      pw = (ull*)malloc(sizeof(ull)*(2*len+1));
      sum = (ull*)malloc(sizeof(ull)*(len+1));
      rev = (ull*)malloc(sizeof(ull)*(len+1));
    } else {
      pw = (ull*)mem;
      sum = pw + 2*len + 1;
      rev = sum + len + 1;
      mem = rev + len + 1;
    }

    v = getinv(mul);
    pw = pw + len;
    pw[0] = 1;
    rep(i,len) pw[ i+1] = pw[ i] * mul;
    rep(i,len) pw[-i-1] = pw[-i] * v;

    sum[0] = 0;
    rep(i,len) sum[i+1] = sum[i] + (ull)data[i] * pw[i];

    rev[len] = 0;
    for(i=len-1;i&gt;=0;i--) rev[i] = rev[i+1] + (ull)data[i] * pw[len-i-1];

    return mem;
  }

  ull get(int a, int b, int off=0){
    ull res;
    
    if(a &lt;= b){
      res = (sum[b+1] - sum[a]) * pw[-a+off] + (b-a+1);
    } else {
      res = (rev[b] - rev[a+1]) * pw[-(len-1-a)+off] + (a-b+1);
    }

    return res;
  }
};

template&lt;class T&gt;
void manacher(int n, T arr[], int res[]) {
  int i, j, k;
  for(i=0,j=0; i&lt;2*n; i+=k, j=max(j-k,0)) {
    while(i-j &gt;= 0 &amp;&amp; i+j+1 &lt; 2*n &amp;&amp; arr[(i-j)/2] == arr[(i+j+1)/2]) ++j;
    res[i] = j;
    for(k=1; i-k &gt;= 0 &amp;&amp; res[i]-k &gt;= 0 &amp;&amp; res[i-k] != res[i]-k; ++k)
      res[i+k] = min(res[i-k], res[i]-k);
  }
}


template&lt;class T&gt;
struct lazySegtreeMinVal{
  int N, logN;
  T *data;

  T *fixval; char *fixed;
  T *addval;

  void malloc(int maxN){
    int i;
    for(i=1;i&lt;maxN;i*=2);
    
    data = (T*)std::malloc(sizeof(T)*2*i);
    fixval = (T*)std::malloc(sizeof(T)*i);
    addval = (T*)std::malloc(sizeof(T)*i);
    fixed = (char*)std::malloc(sizeof(char)*i);
  }

  T&amp; operator[](int i){
    return data[N+i];
  }

  void setN(int n, int zerofill = 1){
    int i;
    for(i=1,logN=0;i&lt;n;i*=2,logN++);
    N = i;
    if(zerofill) rep(i,N) data[N+i] = 0;
  }

  void build(void){
    int i;
    for(i=N-1;i;i--) data[i] = min(data[2*i],data[2*i+1]);
    REP(i,1,N) fixed[i] = 0;
    REP(i,1,N) addval[i] = 0;
  }

  inline void push_one(int a, int sz){
    if(fixed[a]){
      if(sz &gt; 1){
        fixed[a*2] = fixed[a*2+1] = 1;
        fixval[a*2] = fixval[a*2+1] = fixval[a];
        data[a*2] = data[a*2+1] = fixval[a];
      } else {
        data[a*2] = data[a*2+1] = fixval[a];
      }
      fixed[a] = 0;
      addval[a] = 0;
      return;
    }
    if(addval[a] != 0){
      if(sz &gt; 1){
        if(fixed[a*2]) fixval[a*2] += addval[a];
        else           addval[a*2] += addval[a];
        if(fixed[a*2+1]) fixval[a*2+1] += addval[a];
        else             addval[a*2+1] += addval[a];
        data[a*2] += addval[a];
        data[a*2+1] += addval[a];
      } else {
        data[a*2] += addval[a];
        data[a*2+1] += addval[a];
      }
      addval[a] = 0;
      return;
    }
  }

  inline void push(int a){
    int i, aa;
    for(i=logN;i;i--){
      aa = a&gt;&gt;i;
      push_one(aa, 1&lt;&lt;(i-1));
    }
  }

  inline void build(int a){
    while(a &gt; 1){
      a /= 2;
      if(fixed[a]){
        data[a] = fixval[a];
      } else {
        data[a] = min(data[a*2], data[a*2+1]);
        if(addval[a] != 0) data[a] += addval[a];
      }
    }
  }

  inline void change(int a, int b, T val){
    int aa, bb;
    if(a &gt;= b) return;

    aa = (a += N);
    bb = (b += N);
    push(a); push(b-1);

    if(a%2) data[a++] = val;
    if(b%2) data[--b] = val;
    a /= 2;
    b /= 2;

    while(a &lt; b){
      if(a%2) fixed[a]=1, fixval[a]=val, data[a++] = val;
      if(b%2) fixed[--b]=1, fixval[b]=val, data[b] = val;
      a /= 2;
      b /= 2;
    }

    build(aa);
    build(bb-1);
  }

  inline void add(int a, int b, T val){
    int sz = 1, aa, bb;
    if(a &gt;= b) return;

    aa = (a += N);
    bb = (b += N);
    push(a); push(b-1);

    if(a%2) data[a++] += val;
    if(b%2) data[--b] += val;
    a /= 2;
    b /= 2;

    while(a &lt; b){
      sz *= 2;
      if(a%2){
        if(fixed[a]) fixval[a] += val; else addval[a] += val;
        data[a++] += val;
      }
      if(b%2){
        b--;
        if(fixed[b]) fixval[b] += val; else addval[b] += val;
        data[b] += val;
      }
      a /= 2;
      b /= 2;
    }

    build(aa);
    build(bb-1);
  }

  inline T getMinVal(int a, int b){
    T res;
    int sz = 1;
    
    a += N;
    b += N;
    push(a); push(b-1);

    res = std::numeric_limits&lt;T&gt;::max();
    while(a &lt; b){
      if(a%2) res = min(res, data[a++]);
      if(b%2) res = min(res, data[--b]);
      a /= 2;
      b /= 2;
    }
    return res;
  }
};


int N;
char S[2000000];
int rad[3000000];
int res[1000000];

int ss[3000000], ee[3000000], vv[3000000], nx[1000000];

int get_nx(int i){
  if(nx[i]==-1) return i;
  if(i==N-1) return nx[i] = N;
  return nx[i] = get_nx(nx[i]);
}

int main(){
  int i, j, k, st, ed, m, d;
//  rollingHash64&lt;char&gt; h;
//  lazySegtreeMinVal&lt;int&gt; t;

  reader(&amp;N,S);
//  h.init(N,S);
//  t.malloc(N);
//  t.setN(N);
//  t.build();

  rep(i,N) S[N+i] = S[i];

  manacher(2*N, S, rad);
  rep(i,4*N){
    k = min(N,rad[i]);
    if(i%2==0 &amp;&amp; k%2==0) k--;
    if(i%2==1 &amp;&amp; k%2==1) k--;
    if(rad[i]==0) continue;
    st = i/2 - (k-1)/2;
    ed = i/2 + k/2;

    m = ed-st+1;

    ss[i] = (st-(N-m)+N+N)%N;
    ee[i] = (st+N+N)%N;
    vv[i] = m;
//    rep(j,N-m+1) res[(st+N-j)%N] = max(res[(st+N-j)%N], m);
  }

  sort(4*N, vv, ss, ee, mem);
  rep(i,N+1) nx[i] = -1;
  for(i=4*N-1;i&gt;=0;i--){
    if(ss[i] &lt;= ee[i]){
      k = ss[i];
      while(k &lt;= ee[i]){
//        writerLn(ss[i],k,ee[i]);
        res[k] = max(res[k], vv[i]);
        if(nx[k]==-1) nx[k] = k+1;
        k = get_nx(k);
      }
    } else {
      k = ss[i];
      while(k &lt; N){
//        writerLn(ss[i],k,N);
        res[k] = max(res[k], vv[i]);
        if(nx[k]==-1) nx[k] = k+1;
        k = get_nx(k);
      }

      k = 0;
      while(k &lt;= ee[i]){
//        writerLn(0,k,ee[i]);
        res[k] = max(res[k], vv[i]);
        if(nx[k]==-1) nx[k] = k+1;
        k = get_nx(k);
      }
    }
  }

  REP(i,1,2*N) res[i%N] = max(res[i%N], res[(i-1)%N]-2);
  for(i=2*N-2;i&gt;=0;i--) res[i%N] = max(res[i%N], res[(i+1)%N]-2);

  rep(i,N) writerLn(res[i]);

  return 0;
}

----------
====================
----------
ALGORITHMS.131
advanced
----------
PROBLEM STATEMENT:
Jimmy loves playing with strings. He thinks string [expression] if the following conditions are satisfied:


Both strings have the same length (i.e., [expression]). 
For each valid pair of indices, [expression].  


For example, string [expression].  

He has a string, [expression] and print this number on a new line.

Note: Substring [expression] cdef. 
----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;
#include &lt;memory.h&gt;
#include &lt;assert.h&gt;

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 350

using namespace std;

const int INF = 1e9;
const int N = 150031;

int n, tests;
string st;
int used[N];
int mapp[N];
vector&lt;int&gt; v;
int whr[N];

int pw[N];

int S[200000][15];

int maps1[200], maps2[200];

vector&lt;int&gt; entries[100];
int maps[4][100];

int FE[N][15];

void run_mapper(int a,int b)
{
	vector&lt;pair&lt;int, int&gt; &gt; O;

	for (int i = 0; i &lt; 10; i++)
	{
		int whr = FE[a][i];
		O.push_back(make_pair(whr, i));
	}
	sort(O.begin(), O.end());
	for (int i = 0; i &lt; O.size(); i++)
	{
		maps[b][O[i].second] = i;
	}
}

int get_hash(int a, int span, int tp)
{
	int res = 0;
	for (int i = 0; i &lt; 10; i++)
	{
		int here = S[a+span][i] - S[a][i];
		here *= (maps[tp][i]+1);
		here *= pw[N - a - 1];
		res += here;
	}
	return res;
}

int lcp(int a, int b)
{
	run_mapper(a, 1);
	run_mapper(b, 2);
	/*for (int i = 0; i &lt; 10; i++)
	{
		cout &lt;&lt; maps[1][i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	for (int i = 0; i &lt; 10; i++)
	{
		cout &lt;&lt; maps[2][i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	*/
	int l, r;
	l = 0;
	r = st.size() - max(a, b);
	while (l &lt; r)
	{
		int mid = l + r + 1;
		mid /= 2;
		long long H1 = get_hash(a, mid,1);
		long long H2 = get_hash(b, mid,2);
		if (H1 == H2)
			l = mid;
		else
			r = mid - 1;
	}
	return l;
}

bool cmp(int a, int b)
{
	int Q = lcp(a, b);
	if (a + Q == st.size())
		return true;
	if (b + Q == st.size())
		return false;
	int val1 = maps[1][st[a + Q]-'a'];
	int val2 = maps[2][st[b + Q]-'a'];
//	cout &lt;&lt; val1 &lt;&lt; "%%" &lt;&lt; val2 &lt;&lt; endl;
	return val1 &lt; val2;
}

int LL[N];
int sparse[N][20];

int Lcp(int a, int b)
{
	if (a&gt;b)
		swap(a, b);
	if (a == b)
		return 1e9;
	--b;
	int q = 0;
	while ((1 &lt;&lt; q) * 2 &lt; (b - a + 1))
		++q;
	return min(sparse[a][q], sparse[b - (1 &lt;&lt; q) + 1][q]);
}

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);
	
	cin &gt;&gt; n &gt;&gt; tests;
	
	pw[0] = 1;

	for (int i = 1; i &lt; N; i++)
	{
		pw[i] = pw[i - 1] * 173;
	}

	cin &gt;&gt; st;

	for (int i = 0; i &lt; 10; i++)
	{
		FE[st.size()][i] = st.size();
	}
	for (int i = st.size() - 1; i &gt;= 0; --i)
	{
		for (int j = 0; j &lt; 10; j++)
		{
			FE[i][j] = FE[i + 1][j];
			if (st[i] == j + 'a')
				FE[i][j] = i;
		}
	}

	for (int i = 0; i &lt; st.size(); i++)
	{
		for (int j = 0; j &lt; 10; j++)
		{
			S[i + 1][j] = S[i][j];
			if (st[i] == j + 'a')
				S[i + 1][j] += pw[i];
		}
	}

	for (int i = 0; i &lt; st.size(); i++)
	{
		v.push_back(i);
	}

	sort(v.begin(), v.end(),cmp);

	for (int i = 0; i &lt; v.size(); i++)
	{
		whr[v[i]] = i;
	}

	for (int i = 0; i+1 &lt; v.size(); i++)
	{
		LL[i] = lcp(v[i], v[i + 1]);
	}

	for (int lev = 0; lev &lt; 17; lev++)
	{
		for (int i = 0; i &lt; v.size(); i++)
		{
			if (lev == 0)
				sparse[i][lev] = LL[i];
			else
			{
				sparse[i][lev] = sparse[i][lev - 1];
				if (i + (1 &lt;&lt; lev) / 2 &lt;= st.size())
					sparse[i][lev] = min(sparse[i][lev], sparse[i + (1 &lt;&lt; lev) / 2][lev - 1]);
			}
		}
	}

	for (int i = 1; i &lt;= tests; i++)
	{
		int l, r;
		cin &gt;&gt; l &gt;&gt; r;
		--l;
		--r;
		int span = r - l + 1;
		int ps = whr[l];
		l = ps;
		r = v.size() - 1;
		while (l &lt; r)
		{
			int mid = l + r+1;
			mid /= 2;
			if (Lcp(ps,mid) &gt;= span)
				l = mid;
			else
				r = mid - 1;
		}
		int R = r;
		r = ps;
		l = 0;
		while (l &lt; r)
		{
			int mid = l + r;
			mid /= 2;
			if (Lcp(ps,mid) &gt;= span)
				r = mid;
			else
				l = mid + 1;
		}
		cout &lt;&lt; R-l+1 &lt;&lt; endl;
	}

	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.132
expert
----------
PROBLEM STATEMENT:
Oh!! Mankind is in trouble again. This time, it's a deadly disease spreading at a rate never seen before. The need of the hour is to set up efficient virus detectors. You are the lead at Central Hospital and you need to find a fast and reliable way to detect the footprints of the virus DNA in that of the patient.

The DNA of the patient as well as of the virus consists of lowercase letters. Since the collected data is raw, there may be some errors. You will need to find all substrings in the patient DNA that either exactly match the virus DNA or have at most one mismatch, i.e., a difference in at most one location. 

For example, "aa" and "aa" are matching, "ab" and "aa" are matching, while "abb" and "bab" are not.

Function Description

Complete the virusIndices function in the editor below.  It should print a list of space-separated integers that represent the starting indices of matching substrings in increasing order, or No match!.

virusIndices has the following parameter(s):  


p: a string that represents patient DNA  
v: a string that represents virus DNA  

----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
using namespace std ;
#define MAXN 200002
char text[MAXN],pat[MAXN] ;
int szp,szt ;

int p1[2 * MAXN],p2[2 * MAXN] ;
char s[2 * MAXN] ;
vector&lt;int&gt; reta ;
vector&lt;int&gt; solve1()
{
 memset(p1,0,sizeof p1) ;
 memset(p2,0,sizeof p2) ;
 memset(s,0,sizeof s) ;
 int n = 0 ;
 for(int i = 0;i &lt; szp;i++) s[n++] = pat[i] ;
 for(int i = 0;i &lt; szt;i++) s[n++] = text[i] ;
 p1[0] = n ;
 int g = 0,f = 0 ;
 for(int i = 1;i &lt; n;i++)
 {
  if(i &lt; g &amp;&amp; p1[i - f] != g - i)
   p1[i] = min(p1[i - f],g - i) ;
  else
  {
   g = max(g,i) ;
   f = i ;
   while(g &lt; n &amp;&amp; s[g] == s[g - f]) g++ ;
   p1[i] = g - f ;
  }
 }
 
 n = 0 ;
 for(int i = szp - 1;i &gt;= 0;i--) s[n++] = pat[i] ;
 for(int i = szt - 1;i &gt;= 0;i--) s[n++] = text[i] ;
 p2[0] = n ;
 g = 0,f = 0 ;
 for(int i = 1;i &lt; n;i++)
 {
  if(i &lt; g &amp;&amp; p2[i - f] != g - i)
   p2[i] = min(p2[i - f],g - i) ;
  else
  {
   g = max(g,i) ;
   f = i ;
   while(g &lt; n &amp;&amp; s[g] == s[g - f]) g++ ;
   p2[i] = g - f ;
  }
 }
 
 reta.clear() ;
 for(int i = 0;i + szp &lt;= szt;i++)
 {
  int start = p1[szp + i] ;
  int end = p2[szp + szt - 1 - (i + szp - 1)] ;
  if(start + end + 1 &gt;= szp) reta.push_back(i) ;
 }
 return reta ;
}

vector&lt;int&gt; solve2()
{
 vector&lt;int&gt; ret ;
 for(int i = 0;i + szp &lt;= szt;i++)
 {
  int miss = 0 ;
  for(int j = 0;j &lt; szp;j++)
   if(text[i + j] != pat[j])
    miss++ ;
  if(miss &lt;= 1) ret.push_back(i) ;
 }
 return ret ;
}

void gen()
{
 szt = rand() % 1000 + 1 ;
 memset(text,0,sizeof text) ;
 for(int i = 0;i &lt; szt;i++) text[i] = rand() % 3 + 'a' ;

 szp = rand() % szt + 1 ;
 memset(pat,0,sizeof pat) ;
 for(int i = 0;i &lt; szp;i++) pat[i] = rand() % 3 + 'a' ;
}


char get1()
{
 if(rand() % 50000 &lt; 49998) return 'a' ;
 else if(rand() % 100 &lt; 80) return 'b' ;
 return 'c' ;
}

char get2()
{
 if(rand() % 50000 &lt; 49999) return 'a' ;
 return 'b' ;
}

void generate()
{
 srand(time(NULL)) ;
 char in[10] = "in .txt" ;
 for(int test = 0;test &lt; 10;test++)
 {
  in[2] = test + '0' ;
  FILE * fout = fopen(in,"w") ;
  
  int runs = 10 ;
  fprintf(fout,"%d\n",runs) ;
  for(int t = 0;t &lt; runs;t++)
  {
   szt = 100000 - rand() % 1000 + 1 ;
   if(test &lt;= 2) szt = rand() % 30 + 1 ;
   szp = rand() % szt + 1 ;
   memset(text,0,sizeof text) ;
   memset(pat,0,sizeof pat) ;

   if(test &lt;= 2)
   {
    for(int i = 0;i &lt; szt;i++) text[i] = rand() % 2 + 'a' ;
    for(int i = 0;i &lt; szp;i++) pat[i] = rand() % 2 + 'a' ;
   }
   else if(test &lt;= 5)
   {
    for(int i = 0;i &lt; szt;i++) text[i] = get1() ;
    for(int i = 0;i &lt; szp;i++) pat[i] = get1() ;
   }
   else if(test &lt;= 7)
   {
    for(int i = 0;i &lt; szt;i++) text[i] = get2() ;
    for(int i = 0;i &lt; szp;i++) pat[i] = get2() ;
   }
   else
   {
    for(int i = 0;i &lt; szt;i++) text[i] = i % 26 + 'a' ;
    for(int i = 0;i &lt; szp;i++) pat[i] = i % 26 + 'a' ;
    for(int i = 0;i &lt; 10;i++) text[rand() % szt] = 'a' + rand() % 26 ;
   }
   fprintf(fout,"%s\n%s\n\n",text,pat) ;
  }
 }
}



void test()
{
 for(int t = 0;t &lt; 1000;t++)
 {
  gen() ;
  vector&lt;int&gt; ret1 = solve1() ;
  vector&lt;int&gt; ret2 = solve2() ;
  for(int i = 0;i &lt; ret1.size();i++) cout &lt;&lt; ret1[i] &lt;&lt; " " ; cout &lt;&lt; endl ;
  for(int i = 0;i &lt; ret2.size();i++) cout &lt;&lt; ret2[i] &lt;&lt; " " ; cout &lt;&lt; endl ;
  cout &lt;&lt; endl ;
  if(ret1 != ret2)
  {
   cout &lt;&lt; "Failed on: " &lt;&lt; t &lt;&lt; endl ;
   cout &lt;&lt; text &lt;&lt; endl &lt;&lt; pat &lt;&lt; endl ;
   for(int i = 0;i &lt; ret1.size();i++) cout &lt;&lt; ret1[i] &lt;&lt; " " ; cout &lt;&lt; endl ;
   for(int i = 0;i &lt; ret2.size();i++) cout &lt;&lt; ret2[i] &lt;&lt; " " ; cout &lt;&lt; endl ;
   while(1) ;
  }
 }
}

int main()
{
// srand(time(NULL));
// generate() ; return 0 ;
// test() ; return 0 ;
 int runs ;
 scanf("%d",&amp;runs) ;
 while(runs--)
 {
  memset(text,0,sizeof text) ;
  memset(pat,0,sizeof pat) ;
  scanf("%s%s",text,pat) ;
  szt = strlen(text) ;
  szp = strlen(pat) ;
  vector&lt;int&gt; ret1 = solve1() ;
  for(int i = 0;i &lt; ret1.size();i++)
  {
   if(i &gt; 0) printf(" ") ;
   printf("%d",ret1[i]) ;
  }
  printf("\n") ;
 }
 return 0 ;
}
----------
====================
----------
ALGORITHMS.133
expert
----------
PROBLEM STATEMENT:
A substring is defined as a contiguous sequence of one or more characters in the string. More information on substrings can be found here.  
You are given n strings w[1], w[2], ......, w[n]. Let S[i] denote the set of all unique substrings of the string w[i]. Let [expression], return INVALID.  

For example, your strings are [expression] so we return INVALID.

Function Description  

Complete the findStrings function in the editor below.  It should return array of strings.  

findStrings has the following parameter(s):  


w: an array of strings  
queries: an array of integers  

----------
TOP SOLUTION:
----------

import java.io.* ;
import java.text.DecimalFormat;
import java.util.*;
import static java.lang.Math.* ;
import static java.util.Arrays.* ;

public class Solution {
	
	public static void main(String[] args) {
		
			new Solution().solveProblem();
		
		out.close();
	}

	static Scanner in = new Scanner(new InputStreamReader(System.in));
	static PrintStream out = new PrintStream(new BufferedOutputStream(System.out));
	//static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	
	
	int[] maxx ;
	String s ="";
	public void solveProblem() {		

		int n = in.nextInt() ;
		in.nextLine() ;

		String[] sn = new String[n] ;
		for( int i = 0 ; i &lt; n ; i++ ){
			sn[i] =  in.nextLine() + "A" ;
			s += sn[i];
		}
	
		T = s.toCharArray() ;
		maxx = new int[T.length] ;
		int som = 0 ;
		for( int i = 0 ; i &lt; n ; i++ ){
			int nu = sn[i].length() ;
			
			for( int j = som ; j &lt; som + nu ; j++)
				maxx[j] = som + nu ;
			
			som += nu ;
			
		}
		//System.out.println(Arrays.toString(maxx));
		
		this.n = T.length ;
		
		constructSA() ;
		computeLCP() ;
		
		int q = in.nextInt() ; in.nextLine() ;
		for( int i = 0 ; i &lt; q ; i++ )
			losOp(in.nextLong()) ;
			
		
		
	}
	
	void losOp( long k ) {
		
		int start = 0 ;
		for( int i = 0 ; i &lt; n ; i++ ){			
			
			int ind = SA[i] ;
			start = LCP[i] ;
			
			long aantal = max(0,maxx[ind] - 1 - ind - start) ;
			//System.out.println("Zoek " + s.substring(ind) + " " + ind + " " + aantal + " " + start);
			if( T[ind] != 'A' &amp;&amp; aantal &gt;= k ){
				out.println(s.substring(ind, (int) (ind+start+k))) ;
				return ;
			}else if( T[ind] != 'A')
				k -= aantal ;
			//System.out.println(k);
			
			
		}
		
		out.println("INVALID") ;
		
	}
	
	int maxlen = 100010 ;
	int n ;
	
	char[] T ;
	
	int[] RA = new int[maxlen] ;
	int[] RATemp = new int[maxlen] ;
	int[] SA = new int[maxlen] ; 
	int[] SATemp = new int[maxlen] ;
	
	int[] c = new int[maxlen] ;
	
	void constructSA(){
		
		for( int i = 0 ; i &lt; n ; i++ ){
			RA[i] = T[i]-'.' ;
			SA[i] = i ;
		}
		
		for( int k = 1 ; k &lt; n ; k &lt;&lt;= 1 ){
			countingSort( k ) ;
			countingSort( 0 ) ;
			
			RATemp[SA[0]] = 1 ;			
			int r = 1 ;
			for( int i = 1 ; i &lt; n ; i++ ){
				RATemp[SA[i]] = ( RA[SA[i]] == RA[SA[i-1]] &amp;&amp;  RA[SA[i]+k] == RA[SA[i-1]+k] ) ? r : ++r ;
				
			}
	
			RA = RATemp.clone() ;
		}
	}	
	
	void countingSort( int k ){
		
		int sum = 0 ;
		int maxi = max( 300, n ) ;
		
		fill( c, 0 ) ;
		
		for( int i = 0 ; i &lt; n ; i++ )
			c[ ( i + k ) &lt; n ? RA[i+k] : 0 ]++ ;
		
		for( int i = 0 ; i &lt;= maxi ; i++ ){
			int t = c[i] ;
			c[i] = sum ;
			sum += t ;
		}
		
		for( int i = 0 ; i &lt; n ; i++ ){
			SATemp[c[(SA[i] + k) &lt; n ? RA[SA[i]+k] : 0]++ ] = SA[i] ;
		}
		
		
		SA = SATemp.clone() ;
	}
	
	int[] Phi ;
	int[] LCP ;
	int max = 0 ;
	
	void computeLCP(){
		
		LCP = new int[n] ;
		Phi = new int[n] ;
		int[] PLCP = new int[n] ;
		
			
		Phi[SA[0]] = -1 ;
		for( int i = 1 ; i &lt; n ; i++ )
			Phi[SA[i]] = SA[i-1] ;
		
		int L = 0;	
		for( int i = 0 ; i &lt; n ; i++){
			if( Phi[i] == -1){
				PLCP[i] = 0 ;
				continue ;
			}
			
			while( i+L &lt; n &amp;&amp; Phi[i]+L &lt; n &amp;&amp; T[i+L] == T[Phi[i]+L])
				L++ ;
			
			max = max(max,L) ;
			PLCP[i] = L ;
			L = max(L-1,0) ;
		}
		
		for( int i =1 ; i &lt; n ; i++ )
			LCP[i] = PLCP[SA[i]] ;
		
		
	}

}
----------
====================
----------
ALGORITHMS.134
expert
----------
PROBLEM STATEMENT:
A border of a string is a proper prefix of it that is also a suffix. For example:


a and abra are borders of abracadabra,
kan and kankan are borders of kankankan. 
de is a border of decode. 


Note that decode is not a border of decode because it's not proper.

A palindromic border is a border that is palindromic. For example,


a and ana are palindromic borders of anabanana, 
l, lol and lolol are palindromic borders of lololol.


Let's define [expression]. 

Now, a string of length [expression]. In other words, you need to find:
[expression]
where [expression].

Since the answer can be very large, output the answer modulo [expression].

Input Format  

The first line contains a string consisting of [expression] characters.

Output Format  

Print a single integer: the remainder of the division of the resulting number by [expression].

Constraints  

[expression] 
All characters in the string can be any of the first 8 lowercase letters of the English alphabet (abcdefgh).  

Sample Input 1  

ababa


Sample Output 1  

5


Sample Input 2  

aaaa


Sample Output 2  

10


Sample Input 3  

abcacb


Sample Output 3  

3


Explanation  

[expression] ababa has 15 substrings but only 4 substrings have palindromic borders.  

[expression] 
[expression] 
[expression] 
[expression]  
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

#define dbgs(x) cerr &lt;&lt; (#x) &lt;&lt; " --&gt; " &lt;&lt; (x) &lt;&lt; ' '
#define dbg(x) cerr &lt;&lt; (#x) &lt;&lt; " --&gt; " &lt;&lt; (x) &lt;&lt; endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(ll ii=aa;ii&lt;=bb;ii++)
#define ROF(ii,aa,bb) for(ll ii=aa;ii&gt;=bb;ii--)

#define type(x) __typeof(x.begin())

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

#define pii pair &lt; ll ,ll &gt; 

typedef long long ll;

#define hash asdasd

const int inf = 1e9;
const ll mod = 1e9+7;
const ll mod2 =  1e9+7;
const int N = 2e5+5;
const int logN = 18;

ll F[N], i, j, k, n, m, sorted[N], suff[N], lcp[N], ans, hash[N], hash2[N], p, P[N];

string str, str2;

vector&lt; pii &gt; v[N], q[N], v2[N], q2[N];

pair&lt; pii , ll &gt; C[N];

void update(ll x,ll y){
    x--;
    for(; x &gt; 0 ; x -= x&amp;-x) F[x]--;
    for(; y &gt; 0 ; y -= y&amp;-y) F[y]++;
}

ll query(ll x){
    ll sum = 0;
    for(; x &lt; N ; x += x&amp;-x) sum += F[x];
    return sum;
}

ll take(ll x,ll y){ return (hash[y] - ((ll)P[y-x+1] * hash[x-1] % mod)+mod)%mod; }

ll take2(ll x,ll y){    return (hash2[x] - ((ll)P[y-x+1] * hash2[y+1] % mod)+mod)%mod; }

void solve(ll x,ll y){
    
    int bas = 0, son = x;

    while(bas &lt; son){
        
        int orta = bas + son &gt;&gt; 1;

        if(bas == orta) orta++;

        if(take(x-orta+1,x) == take2(y,y+orta-1)) bas = orta;

        else son = orta - 1;
        
    }

    if(x == y) v[y].pb(mp(x-bas+1,x));
    
    else v2[y].pb(mp(x-bas+1,x));

}

int main(){

    cin &gt;&gt; str;

    n = str.size(); str = '0' + str;
    
    FOR(i,1,n) suff[i] = str[i];

    FOR(j,1,logN){

        FOR(i,1,n) C[i] = mp(mp(suff[i],suff[min(n+1,i+(1ll&lt;&lt;j-1))]),i);

        sort(C+1,C+n+1);

        FOR(i,1,n) suff[C[i].nd] = suff[C[i-1].nd] + (C[i].st != C[i-1].st);
                
    }
    
    FOR(i,1,n) sorted[suff[i]] = i;

    int j = 0;

    FOR(i,1,n){
        
        if(suff[i] == 1) continue ;

        while(i + j &lt;= n &amp;&amp; sorted[suff[i]-1] + j &lt;= n &amp;&amp; str[sorted[suff[i]-1]+j] == str[i+j]) j++;

        if(j%2) q[i+j/2].pb(mp(i,suff[i]-1));
        
        else q2[i+j/2].pb(mp(i,suff[i]-1));
        
        if(j) j--;
        
    }   


    P[0] = 1;

    p = 8;

    FOR(i,1,n) P[i] = (P[i-1] * p) % mod;

    FOR(i,1,n) hash[i] = (((ll)hash[i-1] * p + (str[i] - 'a'))) % mod;
    
    ROF(i,n,1) hash2[i] = (((ll)hash2[i+1] * p + (str[i] - 'a'))) % mod;

    FOR(i,1,n){
        
        if(i != n &amp;&amp; str[i] == str[i+1]) solve(i,i+1);

        solve(i,i);
    
    }

    FOR(i,1,n){
        
        foreach(it,v2[i]) update(it-&gt;st,it-&gt;nd);
        
        foreach(it,q2[i]) lcp[it-&gt;nd] = query(it-&gt;st);
        
        foreach(it,v[i]) update(it-&gt;st,it-&gt;nd);
        
        foreach(it,q[i]) lcp[it-&gt;nd] = query(it-&gt;st);
    
    }

    stack&lt; pii &gt; S;

    FOR(i,1,n+1){
        
  //      cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; lcp[i] &lt;&lt; endl;
        
        ll index = i;

        while(!S.empty() &amp;&amp; S.top().st &gt;= lcp[i]){
            
            pii temp = S.top(); S.pop();

            index = temp.nd;

            ll mx = lcp[i];

            if(!S.empty()) mx = max(mx, S.top().st);

            ans = (ans + ((temp.st - mx) * (i-temp.nd) * (i-temp.nd+1) / 2)) % mod2;
            
        }
        
        S.push(mp(lcp[i],index));
        
    }

    cout &lt;&lt; ans &lt;&lt; endl;

   return 0;
}

----------
====================
----------
ALGORITHMS.135
advanced
----------
PROBLEM STATEMENT:
Prof. Twotwo as the name suggests is very fond powers of 2. Moreover he also has special affinity to number 800. He is known for carrying quirky experiments on powers of 2.

One day he played a game in his class. He brought some number plates on each of which a digit from 0 to 9 is written. He made students stand in a row and gave a number plate to each of the student. Now turn by turn, he called for some students who are standing continuously in the row say from index i to index j (i&lt;=j) and asked them to find their strength.

The strength of the group of students from i to j is defined as:

strength(i , j)
{
    if a[i] = 0
        return 0; //If first child has value 0 in the group, strength of group is zero
    value = 0;
    for k from i to j
        value = value*10 + a[k]
    return value;
} 


Prof called for all possible combinations of i and j and noted down the strength of each group. Now being interested in powers of 2, he wants to find out how many strengths are powers of two. Now its your responsibility to get the answer for prof.
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;ctime&gt;

using namespace std;

struct node
{
	int e;
	struct node *path[10];
};

int prodf[400],prodlen;
char bstr[123456];
struct node *posStack[300];
int stackSize=0;

struct node* addEdge(struct node *start, int edge)
{
    if (start-&gt;path[edge]==NULL)
    {
        struct node *tempNode = new node;
        tempNode-&gt;e=0;
        for(int i=0;i&lt;10;++i)
            tempNode-&gt;path[i]=NULL;
        start-&gt;path[edge]=tempNode;
    }
    return (start-&gt;path[edge]);
}

void markEnd(struct node *vnode)
{
    vnode-&gt;e=1;
}

int main()
{
	clock_t t_start =clock();
    prodlen=1;
	prodf[0]=1;
    struct node *automaton = new struct node;
    automaton-&gt;e=0;
    for(int i=0;i&lt;10;++i)
        automaton-&gt;path[i]=NULL;
    struct node *ppos=automaton;
    ppos=addEdge(ppos,1);
    markEnd(ppos);
	for(int n=1;n&lt;=800;++n)
	{
		int rem=0;
		for(int i=0;i&lt;prodlen;++i)
		{
			rem=(2*prodf[i]+rem);
			prodf[i]=rem%10;
			rem/=10;
		}
		if(rem!=0)
			prodf[prodlen++]=rem;
		ppos=automaton;
		for(int i=prodlen-1;i&gt;=0;--i)
		{
			ppos = addEdge(ppos,prodf[i]);
		}
		markEnd(ppos);
	}
    clock_t t_end=clock();
 //   cout&lt;&lt;(t_end+0.0-t_start)/CLOCKS_PER_SEC&lt;&lt;endl;

    int T,k;
    cin&gt;&gt;T;
    while(T--)
    {
    	long long ans=0;
    	stackSize=0;
    	scanf("%s",bstr);
    	for(int i=0,j;bstr[i]!='\0';++i)
    	{
    		k=bstr[i]-'0';
    		for(j=0;j&lt;stackSize;)
    		{
    			if(posStack[j]-&gt;path[k]!=NULL)
    			{
    				posStack[j]=posStack[j]-&gt;path[k];
    				if(posStack[j]-&gt;e==1)
    					ans++;
    				++j;
    			}
    			else
    				posStack[j]=posStack[--stackSize];
    		}
    		if(automaton-&gt;path[k]!=NULL)
    		{
    			posStack[stackSize]=automaton-&gt;path[k];
    			if(posStack[stackSize]-&gt;e==1)
    				ans++;
    			++stackSize;
    		}
    	}
    	cout&lt;&lt;ans&lt;&lt;endl;
    }

    return 0;
}


----------
====================
----------
ALGORITHMS.136
expert
----------
PROBLEM STATEMENT:
Consider the following game for two players:

There are two strings A and B. Initially, some strings A' and B' are written on the sheet of paper. A' is always a substring of A and B' is always a substring of B. A move consists of appending a letter to exactly one of these strings: either to A' or to B'. After the move the constraint of A' being a substring of A and B' is a substring of B should still be satisfied. Players take their moves alternately. We call a pair (A', B') a position.

Two players are playing this game optimally. That means that if a player has a move that leads to his/her victory, he/she will definitely use this move. If a player is unable to make a move, he loses. 

Alice and Bob are playing this game. Alice makes the first move. As always, she wants to win and this time she does a clever trick. She wants the starting position to be the Kth lexicographically winning position for the first player (i.e. her). Consider two positions (A'1, B'1) and (A'2, B'2). We consider the first position lexicographically smaller than the second if A1 is lexicographically smaller than A2, or if A1 is equal to A2 and B1 is lexicographically smaller than B2.

Please help her to find such a position, knowing the strings A, B and the integer K.

Note: An empty string has higher precedence than character "a"
----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Comparator;
import java.util.InputMismatchException;

public class Solution {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";
// 	static String INPUT = "2 2 5 ab cd";
//	static String INPUT = "5 2 4 aabaa cd";
//	static String INPUT = "4 2 4 aaab bb";
	
	static class Result
	{
		int[] sa;
		int[] lcp;
		int[][] branches;
		long[] count;
		int[] zero, one;
		int[] deadline;
		
		public Result(int[] sa, int[] lcp, int[][] branches, long[] count,
				int[] zero, int[] one, int[] deadline) {
			this.sa = sa;
			this.lcp = lcp;
			this.branches = branches;
			this.count = count;
			this.zero = zero;
			this.one = one;
			this.deadline = deadline;
		}
	}
	
	static void solve()
	{
		int n = ni(), m = ni();
		long K = nl();
		char[] a = ns(n);
		char[] b = ns(m);
		
		Result ra = go(a);
		Result rb = go(b);
		long[] ca = ra.count;
		long[] cb = rb.count;
		if(cb.length &lt; ca.length){
			cb = Arrays.copyOf(cb, ca.length);
		}
		long totcb = 0;
		for(long v : cb)totcb += v;
		
		Arrays.sort(ra.branches, new Comparator&lt;int[]&gt;() {
			public int compare(int[] a, int[] b) {
				return a[0] - b[0];
			}
		});
		
		K--;
		
		// ""
		{
			long lcount = totcb - cb[ra.branches[0][3]];
			if(K &lt; lcount){
				int[] resb = kth(rb, K, ra.branches[0][3]);
				
				out.println("");
				out.println(new String(b, resb[0], resb[1]));
				return;
			}else{
				K -= lcount;
			}
		}
		
		int bp = 0;
//		tr(ra.sa);
		bp++;
		for(int i = 0;i &lt; n;i++){
			// row
			long lcount = 0;
			lcount += ra.zero[i] * (totcb - cb[0]);
			lcount += ra.one[i] * (totcb - cb[1]);
			int obp = bp;
			while(bp &lt; ra.branches.length &amp;&amp; ra.branches[bp][0] == i){
				lcount += totcb - cb[ra.branches[bp][3]];
				bp++;
			}
//			tr("lcount?", lcount);
//			lcount += 999;
			if(K &lt; lcount){
				// letter
				int[] row = new int[n-ra.sa[i]];
				Arrays.fill(row, -1);
				for(int j = obp;j &lt; bp;j++){
					row[ra.branches[j][2]-1] = ra.branches[j][3];
				}
				for(int j = n-ra.sa[i]-1;j &gt;= ra.deadline[i]+1;j--){
					if(row[j] == -1){
						if(j == n-ra.sa[i]-1){
							row[j] = 0;
						}else{
							row[j] = row[j+1] &gt; 0 ? 0 : 1;
						}
					}
				}
//				tr("row", row);
				for(int j = ra.deadline[i]+1;j &lt; n-ra.sa[i];j++){
					long llcount = totcb - cb[row[j]];
					if(K &lt; llcount){
						// rb
						int[] resa = new int[]{ra.sa[i], j+1};
						int[] resb = kth(rb, K, row[j]);
						
						out.println(new String(a, resa[0], resa[1]));
						out.println(new String(b, resb[0], resb[1]));
						return;
					}else{
						K -= llcount;
					}
				}
			}else{
				K -= lcount;
			}
		}
		
		out.println("no solution");
	}
	
	static int[] kth(Result rb, long K, int proh)
	{
		Arrays.sort(rb.branches, new Comparator&lt;int[]&gt;() {
			public int compare(int[] a, int[] b) {
				return a[0] - b[0];
			}
		});
		
		// ""
		if(rb.branches[0][3] != proh){
			if(K == 0){
				return new int[]{0, 0};
			}else{
				K--;
			}
		}
		
		int n = rb.sa.length;
		int bp = 1;
		for(int i = 0;i &lt; n;i++){
			// row
			long lcount = 0;
			if(proh != 0)lcount += rb.zero[i];
			if(proh != 1)lcount += rb.one[i];
			int obp = bp;
			while(bp &lt; rb.branches.length &amp;&amp; rb.branches[bp][0] == i){
				if(proh != rb.branches[bp][3])lcount++;
				bp++;
			}
			if(K &lt; lcount){
				// letter
				int[] row = new int[n-rb.sa[i]];
				Arrays.fill(row, -1);
				for(int j = obp;j &lt; bp;j++){
					row[rb.branches[j][2]-1] = rb.branches[j][3];
				}
				for(int j = n-rb.sa[i]-1;j &gt;= rb.deadline[i]+1;j--){
					if(row[j] == -1){
						if(j == n-rb.sa[i]-1){
							row[j] = 0;
						}else{
							row[j] = row[j+1] &gt; 0 ? 0 : 1;
						}
					}
				}
//				tr(row, rb.deadline[i]+1, n-rb.sa[i], K);
				for(int j = rb.deadline[i]+1;j &lt; n-rb.sa[i];j++){
					if(row[j] != proh){
						if(K == 0){
							return new int[]{rb.sa[i], j+1};
						}
						K--;
					}
				}
			}else{
				K -= lcount;
			}
		}
		return null;
	}
	
	static Result go(char[] a)
	{
		int[] sa = suffixsort(a);
		int[] lcp = buildLCP(a, sa);
//		tr(sa);
//		tr(lcp);
		int[][] branches = findBranches(lcp);
//		tr("branches", branches);
		
		LResult lres = countNimber(sa, lcp, branches);
		
		return new Result(sa, lcp, branches, lres.count, lres.zero, lres.one, lres.deadline);
	}
	
	private static LResult countNimber(int[] sa, int[] lcp, int[][] branches)
	{
		int n = sa.length;
		
		int[] zero = new int[n];
		int[] one = new int[n];
		int[] deadline = new int[n];
		Arrays.fill(deadline, -1);
		
		// nimber???suffix???????
		int[] hs = new int[n];
		int[] nim = new int[n];
		Arrays.fill(nim, -1);
		long[] count = new long[n+1];
		for(int i = 0;i &lt; n;i++){
			hs[i] = n-sa[i]+1;
		}
		int[] alive = new int[n];
		Arrays.fill(alive, 1);
		int[] ftalive = buildFenwick(alive);
		int bp = 0;
		int[] bs2 = new int[n];
		for(int[] branch : branches){
			int sp = 0;
			int L = branch[0];
			int R = branch[1];
			int h = branch[2];
//			tr(L, R, h);
			if(L == -1)L = 0;
			int bs = 0;
			// 2$
			// .1$
			// ..010
			// .010$
			// 010
			for(int i = L;i &lt;= R &amp;&amp; i &gt;= 0;i = after(ftalive, i)){
//				tr("i", i);
				if(nim[i] &gt;= 0)count[nim[i]]++;
				int bet = hs[i]-h-1;
//				tr("bet", bet);
				if(nim[i] == 0){
					count[0] += bet / 2;
					count[1] += (bet+1)/2;
					zero[i] += bet/2;
					one[i] += (bet+1)/2;
					// 0|10|1
					bs |= 1&lt;&lt;(bet&amp;1);
				}else{
					count[0] += (bet+1) / 2;
					count[1] += bet/2;
					zero[i] += (bet+1)/2;
					one[i] += bet/2;
					if(bet == 0){
						if(nim[i] &gt;= 0){
							if(nim[i] &lt;= 31){
								bs |= 1&lt;&lt;nim[i];
							}else{
								bs2[sp++] = nim[i];
							}
						}
					}else{
						bs |= 1&lt;&lt;((bet&amp;1)^1);
					}
				}
				hs[i] = h;
//				tr(count, hs, h, i, nim);
				if(i &gt; L){
					// kill
					alive[i] = 0;
					deadline[i] = h-1;
					addFenwick(ftalive, i, -1);
				}
			}
//			tr("bs",bs);
			int clus = Integer.numberOfTrailingZeros(~bs);
			if(clus &gt;= 32){
				Arrays.sort(bs2, 0, sp);
				clus = 32;
				for(int q = 0;q &lt; sp;){
					if(bs2[q] == clus){
						while(q &lt; sp &amp;&amp; bs2[q] == clus)q++;
						clus++;
					}else{
						break;
					}
				}
			}
			
			branches[bp++][3] = nim[L] = clus;
			if(branch[0] == -1)count[nim[L]]++;
		}
//		out.println(Arrays.toString(count));
//		tr(count);
		
		return new LResult(count, zero, one, deadline);
	}
	
	static class LResult
	{
		long[] count;
		int[] zero, one;
		int[] deadline;
		public LResult(long[] count, int[] zero, int[] one, int[] deadline) {
			this.count = count;
			this.zero = zero;
			this.one = one;
			this.deadline = deadline;
		}
	}
	
//	static int[][] findBranches(int[] a)
//	{
//		int n = a.length;
//		int[][] ap = new int[n][];
//		for(int i = 0;i &lt; n;i++)ap[i] = new int[]{a[i], i};
//		Arrays.sort(ap, new Comparator&lt;int[]&gt;() {
//			public int compare(int[] a, int[] b) {
//				if(a[0] != b[0])return -(a[0] - b[0]);
//				return a[1] - b[1];
//			}
//		});
//		
//		int[][] branches = new int[n][];
//		
//		// aabaa
//		// a$
//		// aa$
//		// aabaa$
//		// abaa$
//		// baa
//
//		
//		int p = 0;
//		int[] flag = new int[n];
//		Arrays.fill(flag, 1);
//		int[] ft = buildFenwick(flag);
//		for(int i = 0;i &lt; n;i++){
//			int j;
//			int last = ap[i][1];
//			for(j = ap[i][1];j &gt;= 0 &amp;&amp; j &lt; n &amp;&amp; flag[j] == 1 &amp;&amp; a[j] &gt;= ap[i][0];j = after(ft, j)){ // on index
////				tr("un", j);
//				last = j;
//				flag[j] = 0;
//				addFenwick(ft, j, -1);
//			}
////			tr(restoreFenwick(ft));
////			tr(flag);
////			tr(j,i);
//			if(j == ap[i][1])continue; // already processed
//			branches[p++] = new int[]{before(ft, ap[i][1]), last, ap[i][0], -1};
////			branches[p++] = new int[]{ap[i][1]-1, last, ap[i][0]};
//		}
//		return Arrays.copyOf(branches, p);
//	}
	
	static int[][] findBranches(int[] a)
	{
		int n = a.length;
		long[] ap = new long[n];
		for(int i = 0;i &lt; n;i++)ap[i] = (long)(1000000-a[i])&lt;&lt;32|i;
		Arrays.sort(ap);
		int[][] branches = new int[n][];
		
		// aabaa
		// a$
		// aa$
		// aabaa$
		// abaa$
		// baa

		int p = 0;
		int[] flag = new int[n];
		Arrays.fill(flag, 1);
		int[] ft = buildFenwick(flag);
		for(int i = 0;i &lt; n;i++){
			int j;
			int last = (int)ap[i];
			int va = 1000000-(int)(ap[i]&gt;&gt;&gt;32);
			for(j = (int)ap[i];j &gt;= 0 &amp;&amp; j &lt; n &amp;&amp; flag[j] == 1 &amp;&amp; a[j] &gt;= va;j = after(ft, j)){ // on index
				last = j;
				flag[j] = 0;
				addFenwick(ft, j, -1);
			}
//			tr(restoreFenwick(ft));
//			tr(flag);
//			tr(j,i);
			if(j == (int)ap[i])continue;
//			if(j == ap[i][1])continue; // already processed
			branches[p++] = new int[]{before(ft, (int)ap[i]), last, va, -1};
//			branches[p++] = new int[]{before(ft, ap[i][1]), last, ap[i][0], -1};
		}
		return Arrays.copyOf(branches, p);
	}
	
	public static int sumFenwick(int[] ft, int i)
	{
		int sum = 0;
		for(i++;i &gt; 0;i -= i&amp;-i)sum += ft[i];
		return sum;
	}
	
	public static void addFenwick(int[] ft, int i, int v)
	{
		if(v == 0)return;
		int n = ft.length;
		for(i++;i &lt; n;i += i&amp;-i)ft[i] += v;
	}
	
	public static int findGFenwick(int[] ft, int v)
	{
		int i = 0;
		int n = ft.length;
		for(int b = Integer.highestOneBit(n);b != 0 &amp;&amp; i &lt; n;b &gt;&gt;= 1){
			if(i + b &lt; n){
				int t = i + b;
				if(v &gt;= ft[t]){
					i = t;
					v -= ft[t];
				}
			}
		}
		return v != 0 ? -(i+1) : i-1;
	}
	
	public static int valFenwick(int[] ft, int i)
	{
		return sumFenwick(ft, i) - sumFenwick(ft, i-1);
	}
	
	public static int[] restoreFenwick(int[] ft)
	{
		int n = ft.length-1;
		int[] ret = new int[n];
		for(int i = 0;i &lt; n;i++)ret[i] = sumFenwick(ft, i);
		for(int i = n-1;i &gt;= 1;i--)ret[i] -= ret[i-1];
		return ret;
	}
	
	public static int before(int[] ft, int x)
	{
		int u = sumFenwick(ft, x-1);
		if(u == 0)return -1;
		return findGFenwick(ft, u-1)+1;
	}
	
	public static int after(int[] ft, int x)
	{
		int u = sumFenwick(ft, x);
		int f = findGFenwick(ft, u);
		if(f+1 &gt;= ft.length-1)return -1;
		return f+1;
	}
	
	public static int[] buildFenwick(int[] a)
	{
		int n = a.length;
		int[] ft = new int[n+1];
		System.arraycopy(a, 0, ft, 1, n);
		for(int k = 2, h = 1;k &lt;= n;k*=2, h*=2){
			for(int i = k;i &lt;= n;i+=k){
				ft[i] += ft[i-h];
			}
		}
		return ft;
	}
	
	
	public static int[] buildLCP(char[] str, int[] sa)
	{
		int n = str.length;
		int h = 0;
		int[] lcp = new int[n];
		int[] b = new int[n];
		for(int i = 0;i &lt; n;i++)b[sa[i]] = i;
		for(int i = 0;i &lt; n;i++){
			if(b[i] &gt; 0){
				for(int j = sa[b[i]-1]; j+h&lt;n &amp;&amp; i+h&lt;n &amp;&amp; str[j+h] == str[i+h]; h++);
				lcp[b[i]] = h;
			}else{
				lcp[b[i]] = 0;
			}
			if(h &gt; 0)h--;
		}
		return lcp;
	}	
	
	private static interface BaseArray {
		public int get(int i);

		public void set(int i, int val);

		public int update(int i, int val);
	}

	private static class CharArray implements BaseArray {
		private char[] m_A = null;
		private int m_pos = 0;

		CharArray(char[] A, int pos) {
			m_A = A;
			m_pos = pos;
		}

		public int get(int i) {
			return m_A[m_pos + i] &amp; 0xffff;
		}

		public void set(int i, int val) {
			m_A[m_pos + i] = (char) (val &amp; 0xffff);
		}

		public int update(int i, int val) {
			return m_A[m_pos + i] += val &amp; 0xffff;
		}
	}

	private static class IntArray implements BaseArray {
		private int[] m_A = null;
		private int m_pos = 0;

		IntArray(int[] A, int pos) {
			m_A = A;
			m_pos = pos;
		}

		public int get(int i) {
			return m_A[m_pos + i];
		}

		public void set(int i, int val) {
			m_A[m_pos + i] = val;
		}

		public int update(int i, int val) {
			return m_A[m_pos + i] += val;
		}
	}

	/* find the start or end of each bucket */
	private static void getCounts(BaseArray T, BaseArray C, int n, int k) {
		int i;
		for(i = 0;i &lt; k;++i){
			C.set(i, 0);
		}
		for(i = 0;i &lt; n;++i){
			C.update(T.get(i), 1);
		}
	}

	private static void getBuckets(BaseArray C, BaseArray B, int k, boolean end) {
		int i, sum = 0;
		if(end != false){
			for(i = 0;i &lt; k;++i){
				sum += C.get(i);
				B.set(i, sum);
			}
		}else{
			for(i = 0;i &lt; k;++i){
				sum += C.get(i);
				B.set(i, sum - C.get(i));
			}
		}
	}

	/* sort all type LMS suffixes */
	private static void LMSsort(BaseArray T, int[] SA, BaseArray C,
			BaseArray B, int n, int k) {
		int b, i, j;
		int c0, c1;
		/* compute SAl */
		if(C == B){
			getCounts(T, C, n, k);
		}
		getBuckets(C, B, k, false); /* find starts of buckets */
		j = n - 1;
		b = B.get(c1 = T.get(j));
		--j;
		SA[b++] = (T.get(j) &lt; c1) ? ~j : j;
		for(i = 0;i &lt; n;++i){
			if(0 &lt; (j = SA[i])){
				if((c0 = T.get(j)) != c1){
					B.set(c1, b);
					b = B.get(c1 = c0);
				}
				--j;
				SA[b++] = (T.get(j) &lt; c1) ? ~j : j;
				SA[i] = 0;
			}else if(j &lt; 0){
				SA[i] = ~j;
			}
		}
		/* compute SAs */
		if(C == B){
			getCounts(T, C, n, k);
		}
		getBuckets(C, B, k, true); /* find ends of buckets */
		for(i = n - 1, b = B.get(c1 = 0);0 &lt;= i;--i){
			if(0 &lt; (j = SA[i])){
				if((c0 = T.get(j)) != c1){
					B.set(c1, b);
					b = B.get(c1 = c0);
				}
				--j;
				SA[--b] = (T.get(j) &gt; c1) ? ~(j + 1) : j;
				SA[i] = 0;
			}
		}
	}

	private static int LMSpostproc(BaseArray T, int[] SA, int n, int m) {
		int i, j, p, q, plen, qlen, name;
		int c0, c1;
		boolean diff;

		/*
		 * compact all the sorted substrings into the first m items of SA 2*m
		 * must be not larger than n (proveable)
		 */
		for(i = 0;(p = SA[i]) &lt; 0;++i){
			SA[i] = ~p;
		}
		if(i &lt; m){
			for(j = i, ++i;;++i){
				if((p = SA[i]) &lt; 0){
					SA[j++] = ~p;
					SA[i] = 0;
					if(j == m){
						break;
					}
				}
			}
		}

		/* store the length of all substrings */
		i = n - 1;
		j = n - 1;
		c0 = T.get(n - 1);
		do{
			c1 = c0;
		}while ((0 &lt;= --i) &amp;&amp; ((c0 = T.get(i)) &gt;= c1));
		for(;0 &lt;= i;){
			do{
				c1 = c0;
			}while ((0 &lt;= --i) &amp;&amp; ((c0 = T.get(i)) &lt;= c1));
			if(0 &lt;= i){
				SA[m + ((i + 1) &gt;&gt; 1)] = j - i;
				j = i + 1;
				do{
					c1 = c0;
				}while ((0 &lt;= --i) &amp;&amp; ((c0 = T.get(i)) &gt;= c1));
			}
		}

		/* find the lexicographic names of all substrings */
		for(i = 0, name = 0, q = n, qlen = 0;i &lt; m;++i){
			p = SA[i];
			plen = SA[m + (p &gt;&gt; 1)];
			diff = true;
			if((plen == qlen) &amp;&amp; ((q + plen) &lt; n)){
				for(j = 0;(j &lt; plen) &amp;&amp; (T.get(p + j) == T.get(q + j));++j){
				}
				if(j == plen){
					diff = false;
				}
			}
			if(diff != false){
				++name;
				q = p;
				qlen = plen;
			}
			SA[m + (p &gt;&gt; 1)] = name;
		}

		return name;
	}

	/* compute SA and BWT */
	private static void induceSA(BaseArray T, int[] SA, BaseArray C,
			BaseArray B, int n, int k) {
		int b, i, j;
		int c0, c1;
		/* compute SAl */
		if(C == B){
			getCounts(T, C, n, k);
		}
		getBuckets(C, B, k, false); /* find starts of buckets */
		j = n - 1;
		b = B.get(c1 = T.get(j));
		SA[b++] = ((0 &lt; j) &amp;&amp; (T.get(j - 1) &lt; c1)) ? ~j : j;
		for(i = 0;i &lt; n;++i){
			j = SA[i];
			SA[i] = ~j;
			if(0 &lt; j){
				if((c0 = T.get(--j)) != c1){
					B.set(c1, b);
					b = B.get(c1 = c0);
				}
				SA[b++] = ((0 &lt; j) &amp;&amp; (T.get(j - 1) &lt; c1)) ? ~j : j;
			}
		}
		/* compute SAs */
		if(C == B){
			getCounts(T, C, n, k);
		}
		getBuckets(C, B, k, true); /* find ends of buckets */
		for(i = n - 1, b = B.get(c1 = 0);0 &lt;= i;--i){
			if(0 &lt; (j = SA[i])){
				if((c0 = T.get(--j)) != c1){
					B.set(c1, b);
					b = B.get(c1 = c0);
				}
				SA[--b] = ((j == 0) || (T.get(j - 1) &gt; c1)) ? ~j : j;
			}else{
				SA[i] = ~j;
			}
		}
	}

	/*
	 * find the suffix array SA of T[0..n-1] in {0..k-1}^n use a working space
	 * (excluding T and SA) of at most 2n+O(1) for a constant alphabet
	 */
	private static void SA_IS(BaseArray T, int[] SA, int fs, int n, int k) {
		BaseArray C, B, RA;
		int i, j, b, m, p, q, name, newfs;
		int c0, c1;
		int flags = 0;

		if(k &lt;= 256){
			C = new IntArray(new int[k], 0);
			if(k &lt;= fs){
				B = new IntArray(SA, n + fs - k);
				flags = 1;
			}else{
				B = new IntArray(new int[k], 0);
				flags = 3;
			}
		}else if(k &lt;= fs){
			C = new IntArray(SA, n + fs - k);
			if(k &lt;= (fs - k)){
				B = new IntArray(SA, n + fs - k * 2);
				flags = 0;
			}else if(k &lt;= 1024){
				B = new IntArray(new int[k], 0);
				flags = 2;
			}else{
				B = C;
				flags = 8;
			}
		}else{
			C = B = new IntArray(new int[k], 0);
			flags = 4 | 8;
		}

		/*
		 * stage 1: reduce the problem by at least 1/2 sort all the
		 * LMS-substrings
		 */
		getCounts(T, C, n, k);
		getBuckets(C, B, k, true); /* find ends of buckets */
		for(i = 0;i &lt; n;++i){
			SA[i] = 0;
		}
		b = -1;
		i = n - 1;
		j = n;
		m = 0;
		c0 = T.get(n - 1);
		do{
			c1 = c0;
		}while ((0 &lt;= --i) &amp;&amp; ((c0 = T.get(i)) &gt;= c1));
		for(;0 &lt;= i;){
			do{
				c1 = c0;
			}while ((0 &lt;= --i) &amp;&amp; ((c0 = T.get(i)) &lt;= c1));
			if(0 &lt;= i){
				if(0 &lt;= b){
					SA[b] = j;
				}
				b = B.update(c1, -1);
				j = i;
				++m;
				do{
					c1 = c0;
				}while ((0 &lt;= --i) &amp;&amp; ((c0 = T.get(i)) &gt;= c1));
			}
		}
		if(1 &lt; m){
			LMSsort(T, SA, C, B, n, k);
			name = LMSpostproc(T, SA, n, m);
		}else if(m == 1){
			SA[b] = j + 1;
			name = 1;
		}else{
			name = 0;
		}

		/*
		 * stage 2: solve the reduced problem recurse if names are not yet
		 * unique
		 */
		if(name &lt; m){
			if((flags &amp; 4) != 0){
				C = null;
				B = null;
			}
			if((flags &amp; 2) != 0){
				B = null;
			}
			newfs = (n + fs) - (m * 2);
			if((flags &amp; (1 | 4 | 8)) == 0){
				if((k + name) &lt;= newfs){
					newfs -= k;
				}else{
					flags |= 8;
				}
			}
			for(i = m + (n &gt;&gt; 1) - 1, j = m * 2 + newfs - 1;m &lt;= i;--i){
				if(SA[i] != 0){
					SA[j--] = SA[i] - 1;
				}
			}
			RA = new IntArray(SA, m + newfs);
			SA_IS(RA, SA, newfs, m, name);
			RA = null;

			i = n - 1;
			j = m * 2 - 1;
			c0 = T.get(n - 1);
			do{
				c1 = c0;
			}while ((0 &lt;= --i) &amp;&amp; ((c0 = T.get(i)) &gt;= c1));
			for(;0 &lt;= i;){
				do{
					c1 = c0;
				}while ((0 &lt;= --i) &amp;&amp; ((c0 = T.get(i)) &lt;= c1));
				if(0 &lt;= i){
					SA[j--] = i + 1;
					do{
						c1 = c0;
					}while ((0 &lt;= --i) &amp;&amp; ((c0 = T.get(i)) &gt;= c1));
				}
			}

			for(i = 0;i &lt; m;++i){
				SA[i] = SA[m + SA[i]];
			}
			if((flags &amp; 4) != 0){
				C = B = new IntArray(new int[k], 0);
			}
			if((flags &amp; 2) != 0){
				B = new IntArray(new int[k], 0);
			}
		}

		/* stage 3: induce the result for the original problem */
		if((flags &amp; 8) != 0){
			getCounts(T, C, n, k);
		}
		/* put all left-most S characters into their buckets */
		if(1 &lt; m){
			getBuckets(C, B, k, true); /* find ends of buckets */
			i = m - 1;
			j = n;
			p = SA[m - 1];
			c1 = T.get(p);
			do{
				q = B.get(c0 = c1);
				while (q &lt; j){
					SA[--j] = 0;
				}
				do{
					SA[--j] = p;
					if(--i &lt; 0){
						break;
					}
					p = SA[i];
				}while ((c1 = T.get(p)) == c0);
			}while (0 &lt;= i);
			while (0 &lt; j){
				SA[--j] = 0;
			}
		}
		induceSA(T, SA, C, B, n, k);
		C = null;
		B = null;
	}

	/* char */
	public static int[] suffixsort(char[] T) {
		if(T == null)return null;
		int n = T.length;
		int[] SA = new int[n];
		if(n &lt;= 1){
			if(n == 1){
				SA[0] = 0;
			}
			return SA;
		}
		SA_IS(new CharArray(T, 0), SA, 0, n, 65536);
		return SA;
	}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static boolean eof()
	{
		if(lenbuf == -1)return true;
		int lptr = ptrbuf;
		while(lptr &lt; lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;
		
		try {
			is.mark(1000);
			while(true){
				int b = is.read();
				if(b == -1){
					is.reset();
					return true;
				}else if(!isSpaceChar(b)){
					is.reset();
					return false;
				}
			}
		} catch (IOException e) {
			return true;
		}
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private static int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private static double nd() { return Double.parseDouble(ns()); }
	private static char nc() { return (char)skip(); }
	
	private static String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private static char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private static char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private static int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.137
expert
----------
PROBLEM STATEMENT:
You are given string [expression]. 

Consider a substring [expression] groups of contiguous positions. 

For example, if we have a string ababaewabaq the substring aba marks the positions 1, 2, 3, 4, 5, 8, 9, 10; that is XXXXXewXXXq (X denotes marked position). We can see 2 groups of contiguous positions, that is 2 islands. Finally, substring aba produces 2 islands in the string ababaewabaq.

Calculate and print the number of different substrings of string [expression] islands.
----------
TOP SOLUTION:
----------
#undef NDEBUG
#ifdef ssu1
#endif

#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;

using namespace std;

#define fore(i, l, r) for(int i = int(l); i &lt; int(r); ++i)
#define forn(i, n) fore(i, 0, n)
#define fori(i, l, r) fore(i, l, (r) + 1)
#define sz(v) int((v).size())
#define all(v) (v).begin(), (v).end()
#define pb push_back
#define mp make_pair
#define X first
#define Y second

template&lt;typename T&gt; inline T abs(T a){ return ((a &lt; 0) ? -a : a); }
template&lt;typename T&gt; inline T sqr(T a){ return a * a; }

typedef long long li;
typedef long double ld;
typedef pair&lt;int, int&gt; pt;

const int NMAX = 110000;

struct node{
    int l, r, par, link;
    map&lt;char, int&gt; next;

    node(){
        l = r = par = link = -1;
    }

    node(int _l, int _r, int _par) : l(_l), r(_r), par(_par){
        link = -1;
    }
};

struct tpos{
    int V, L;
    tpos(int _V, int _L) : V(_V), L(_L) {} 
};


char s[NMAX];
node t[2 * NMAX + 1];
int szt, szs;

int leng(int v){
    return t[v].r - t[v].l;
}

int add_edge_to_parent(int l, int r, int parent){
    int nidx = szt++;
    t[nidx] = node(l, r, parent);
    return (t[parent].next[s[l]] = nidx);
}

int split_edge(tpos pos){
    int v = pos.V, up = pos.L, down = leng(v) - up;

    if(up == 0) return v;
    if(down == 0) return t[v].par;

    int mid = add_edge_to_parent(t[v].l, t[v].l + down, t[v].par);
    t[v].l += down, t[v].par = mid;
    t[mid].next[s[t[v].l]] = v;
    return mid;
}

tpos read_char(tpos pos, char c){
    int v = pos.V, up = pos.L;
    if(up &gt; 0)
        return s[t[v].r - up] == c ? tpos(v, up - 1) : tpos(-1, -1);
    else{
        int nextv = t[v].next.count(c) ? t[v].next[c] : -1;
        return nextv != -1 ? tpos(nextv, leng(nextv) - 1) : tpos(-1, -1);
    }
}

tpos fast_go_down(int v, int l, int r){
    if(l == r) return tpos(v, 0);
    while(true){
        v = t[v].next[s[l]];
        if(leng(v) &gt;= r - l)
            return tpos(v, leng(v) - r + l);
        l += leng(v);
    }
    throw;
}

int link(int v){
    if(t[v].link == -1)
        t[v].link = split_edge(fast_go_down(link(t[v].par), t[v].l + int(t[v].par == 0), t[v].r));
    return t[v].link;
}

tpos add_char_to_tree(tpos pos, int i){
    while(true){
        tpos npos = read_char(pos, s[i]);
        if(npos.V != -1) return npos;

        int mid = split_edge(pos);

        add_edge_to_parent(i, szs, mid);

        pos = tpos(link(mid), 0);

        if(mid == 0)
            return pos;
    }
    throw;
}

void make_tree(){
    szt = 0;
    node root(-1, -1, -1); root.link = 0;
    t[szt++] = root;

    tpos pos(0, 0);
    forn(i, szs){
        pos = add_char_to_tree(pos, i);
    }
}

#include &lt;ext/pb_ds/assoc_container.hpp&gt;
#include &lt;ext/pb_ds/tree_policy.hpp&gt;
using namespace __gnu_pbds;

int K;
li result = 0;
typedef tree&lt;pt, null_type, less&lt;pt&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; treap;

struct data{
    treap* t;
    map&lt;int, int&gt;* cnt;
    set&lt;int&gt;* positions;

    data(){
        t = new treap();
        cnt = new map&lt;int, int&gt;();
        positions = new set&lt;int&gt;();
    }

    void in_t(int x){
        (*cnt)[x]++;
        t-&gt;insert(mp(x, (*cnt)[x]));
    }

    void er_t(int x){
        t-&gt;erase(mp(x, (*cnt)[x]));
        (*cnt)[x]--;
    }

    void insert(int value){
        (*positions).insert(value);
        set&lt;int&gt;::iterator it = positions-&gt;lower_bound(value);

        if(it != positions-&gt;begin()){
            set&lt;int&gt;::iterator prev = it;
            prev--;
            in_t((*it) - (*prev));
        }

        if(it != positions-&gt;end()){
            set&lt;int&gt;::iterator next = it;
            next++;
            if(next != positions-&gt;end()){
                in_t((*next) - (*it));
            }
        }

        if(it != positions-&gt;begin() &amp;&amp; it != positions-&gt;end()){
            set&lt;int&gt;::iterator prev = it, next = it;
            prev--, next++;
            if(next != positions-&gt;end()){
                er_t((*next) - (*prev));
            }
        }
    }

    int get_less(int key){
        return (int)t-&gt;order_of_key(mp(key, -1));
    }

    void clear(){
        t-&gt;clear();
        cnt-&gt;clear();
        positions-&gt;clear();
    }
};

int islands(data t, int ln){
    return (int)(t.positions-&gt;size() - t.get_less(ln + 1));
}

void dfs(int v, int ln, data&amp; ord){
    if(t[v].next.empty()){
        ord.insert(szs - ln);
    }
    data cur;
    for(map&lt;char, int&gt;::iterator it = t[v].next.begin(); it != t[v].next.end(); it++){
        int u = it-&gt;Y;
        dfs(u, ln + leng(u), cur);
        if(cur.positions-&gt;size() &gt; ord.positions-&gt;size())
            swap(cur, ord);
        for(set&lt;int&gt;::iterator jt = cur.positions-&gt;begin(); jt != cur.positions-&gt;end(); jt++){
            ord.insert(*jt);
        }
        cur.clear();
    }

    if(ln &gt; 0){
        int ansL = -1, ansR = -1;
        {
            int lf = ln - leng(v) + 1, rg = ln;
            while(rg - lf &gt; 1){
                int mid = (lf + rg) &gt;&gt; 1;
                if(islands(ord, mid) &gt; K)
                    lf = mid;
                else
                    rg = mid;
            }
            for(int x = lf; x &lt;= rg; x++){
                if(islands(ord, x) == K){
                    ansL = x;
                    break;
                }
            }
        }
        {
            int lf = ln - leng(v) + 1, rg = ln;
            while(rg - lf &gt; 1){
                int mid = (lf + rg) &gt;&gt; 1;
                if(islands(ord, mid) &lt; K)
                    rg = mid;
                else
                    lf = mid;
            }
            for(int x = rg; x &gt;= lf; --x){
                if(islands(ord, x) == K){
                    ansR = x;
                    break;
                }
            }
        }
        if(ansL != -1){
            result += ansR - ansL + 1;
        }
    }
}

#include &lt;sys/resource.h&gt;

void init_stack(){
    const rlim_t kStackSize = 512 * 1024 * 1024;
    struct rlimit rl;
    int result;

    result = getrlimit(RLIMIT_STACK, &amp;rl);
    if (result == 0)
    {
        if (rl.rlim_cur &lt; kStackSize)
        {
            rl.rlim_cur = kStackSize;
            result = setrlimit(RLIMIT_STACK, &amp;rl);
            if (result != 0)
            {
                fprintf(stderr, "setrlimit returned result = %d\n", result);
            }
        }
    }
}

int main() {
#ifdef ssu1
    assert(freopen("input.txt", "rt", stdin));
#endif

    init_stack();

    gets(s);
    szs = (int)strlen(s);
    s[szs++] = '$';

    make_tree();

    assert(scanf("%d", &amp;K) == 1);

    data ord;

    dfs(0, 0, ord);

    if(K == 1){
        result -= szs;
    }

    cout &lt;&lt; result &lt;&lt; endl;
#ifdef ssu1
    cerr &lt;&lt; "\nTime = " &lt;&lt; double(clock()) / CLOCKS_PER_SEC &lt;&lt; endl;
#endif    
    return 0;
}
----------
====================
----------
ALGORITHMS.138
expert
----------
PROBLEM STATEMENT:
Two strings A and B, consisting of small English alphabet letters are called pseudo-isomorphic if  


Their lengths are equal
For every pair (i,j), where 1 &lt;= i &lt; j &lt;= |A|, B[i] = B[j], iff A[i] = A[j]
For every pair (i,j), where 1 &lt;= i &lt; j &lt;= |A|, B[i] != B[j] iff A[i] != A[j]


Naturally, we use 1-indexation in these definitions and |A| denotes the length of the string A.  

You are given a string S, consisting of no more than 105 lowercase alphabetical characters. For every prefix of S denoted by S', you are expected to find the size of the largest possible set of strings , such that all elements of the set are substrings of S' and no two strings inside the set are pseudo-isomorphic to each other.  

if S = abcde 
then, 1st prefix of S is 'a' 
then, 2nd prefix of S is 'ab' 
then, 3rd prefix of S is 'abc' 
then, 4th prefix of S is 'abcd' and so on..  
----------
TOP SOLUTION:
----------
s = input()

prevs = dict()
a = []
for i in range(len(s)):
    if s[i] in prevs:
        a.append(i - prevs[s[i]])
    else:
        a.append(i + 1)
    prevs[s[i]] = i

class Node:
    def __init__(self, **d):
        self.__dict__ = d

class Edge:
    def __init__(self, **d):
        self.__dict__ = d

root = Node(edges = dict(), depth = 0, slink = None)
edge0 = Edge(a = root, b = root, u = 0, l = 0)
cur = (edge0, 0, 0)
leaves = 0
ans = 0

def conv(c, depth):
    return -1 if c &gt; depth else c

def simplify(cur):
    edge, u, l = cur
    while l &gt; edge.l:
        c = conv(a[u + edge.l], edge.a.depth + edge.l)
        edge, u, l = edge.b.edges[c], u + edge.l, l - edge.l
    return edge, u, l

def toStr(a, depth):
    l = []
    for i in range(len(a)):
        l.append(conv(a[i], depth + i))
    return map(str, l)

def printTree(edge, tabs = ''):
    print(tabs + ':'.join(toStr(a[edge.u:edge.u+edge.l], edge.a.depth)), edge.b.depth, edge.b.slink)
    for e in edge.b.edges.values():
        printTree(e, tabs + '  ')

def slink(cur):
    edge, u, l = cur
    if edge.a == root:
        assert(edge != edge0)
        return simplify((edge0, u + 1, l - 1))
    else:
        edge.a.slink = simplify(edge.a.slink)
        e1, u1, l1 = edge.a.slink
        return simplify((e1, u - l1, l + l1))

#print(':'.join(map(str, a)))

for i in range(len(s)):
    while True:
        edge, u, l = cur
        c = conv(a[i], edge.a.depth + l)
        if l == edge.l:
            if c in edge.b.edges:
                break
            leaves += 1
            leaf = Node(depth = -1, slink = None, edges = dict())
            edge.b.edges[c] = Edge(a = edge.b, b = leaf, u = i, l = len(s) - i)
        else:
            c1 = conv(a[edge.u + l], edge.a.depth + l)
            if c == c1:
                break
            leaves += 1
            leaf = Node(depth = -1, slink = None, edges = dict())
            branch = Node(edges = dict(), depth = edge.a.depth + l, slink = slink(cur))
            branch.edges[c] = Edge(a = branch, b = leaf, u = i, l = len(s) - i)
            branch.edges[c1] = Edge(a = branch, b = edge.b, u = edge.u + l, l = edge.l - l)
            edge.b = branch
            edge.l = l
        if edge == edge0 and l == 0:
            cur = None
            break
        if edge.a == root:
            assert(edge != edge0)
            cur = simplify((edge0, u + 1, l - 1))
        else:
            edge.a.slink = simplify(edge.a.slink)
            e1, u1, l1 = edge.a.slink
            cur = simplify((e1, u - l1, l + l1))
    if cur == None:
        cur = edge0, i + 1, 0
    else:
        edge, u, l = cur
        assert(u + l == i)
        cur = simplify((edge, u, l + 1))
    ans += leaves
    print(ans)
    #printTree(edge0)

----------
====================
----------
ALGORITHMS.139
expert
----------
PROBLEM STATEMENT:
Consider a string of [expression].

You are given [expression]. 

Note: Two substrings are different if their sequence of characters differs by at least one. For example, given the string [expression] ab are different.
----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.InputMismatchException;
import java.util.List;

public class G2 {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	void solve()
	{
		int n = ni(), Q = ni();
		char[] s = ns(n);
		int[][] qs = new int[Q][];
		for(int z = 0;z &lt; Q;z++){
			qs[z] = new int[]{ni(), ni(), z};
		}
		Arrays.sort(qs, new Comparator&lt;int[]&gt;() {
			public int compare(int[] a, int[] b) {
				return a[1] - b[1];
			}
		});
//		
//		{
//			int sup = 5, inf = 3;
//			long[] f0 = new long[10];
//			long[] f1 = new long[10];
//			addFenwick(f0, 0, -(sup-inf));
//			addFenwick(f0, sup+1, +(sup-inf));
//			addFenwick(f0, inf+1, -(inf+1));
//			addFenwick(f0, sup+1, +inf+1);
//			addFenwick(f1, inf+1, 1);
//			addFenwick(f1, sup+1, -1);
//			tr(restoreRangeFenwick(f0, f1));
//		}
	
		
		SuffixAutomatonOfBit sa = SuffixAutomatonOfBit.build(s);
		sa.sortTopologically();
		SuffixAutomatonOfBit.Node[] nodes = sa.nodes;
		int[] from = new int[nodes.length-1];
		int[] to = new int[nodes.length-1];
		int p = 0;
		for(SuffixAutomatonOfBit.Node node : nodes){
			if(node.id &gt;= 1){
				from[p] = node.link.id; to[p] = node.id; p++;
			}
		}
		assert p == nodes.length-1;
		int[][] g = packU(nodes.length, from, to);
		int[][] pars = parents3(g, 0);
		int[] par = pars[0], ord = pars[1], dep = pars[2];
		HeavyLightDecomposition hld = new HeavyLightDecomposition(g, par, ord, dep);
		int m = hld.cluspath.length;
		SegmentTreeOverwrite[] sts = new SegmentTreeOverwrite[m];
		for(int i = 0;i &lt; m;i++){
			sts[i] = new SegmentTreeOverwrite(hld.cluspath[i].length);
		}
		
		int[] base = new int[n];
		int qp = 0;
		int np = 0;
		long[] ft0 = new long[n+3];
		long[] ft1 = new long[n+3];
		long[] ans = new long[Q];
		for(int i = 0;i &lt; n;i++){
			while(!(nodes[np].len == i+1 &amp;&amp; nodes[np].original == null))np++;
			base[i] = np;
//			tr("base", base[i]);
			
			// 5 3 1 0
			// 5 3 1 0
			// 8 6 3 1 0 ?
			// aaba
			
			// delete
			int cur = 0;
			int ppos = 0;
			while(true){
				int last = sts[hld.clus[cur]].get(hld.clusiind[cur]);
				if(last == -1)break;
				int lca = hld.lca(base[last], base[i]);
				// delete from lca to cur
	//			nodes[cur].len, nodes[lca].len;
				int inf = last-nodes[lca].len+1;
				int sup = last-ppos+1;
//				tr("del", last, ppos, nodes[lca].len, inf, sup);
				// _/
				addFenwick(ft0, 0, -(sup-inf));
				addFenwick(ft0, sup+1, +(sup-inf));
				addFenwick(ft0, inf+1, -(inf+1));
				addFenwick(ft0, sup+1, +inf+1);
				addFenwick(ft1, inf+1, 1);
				addFenwick(ft1, sup+1, -1);
//				tr(i, restoreRangeFenwick(ft0, ft1));
				ppos = nodes[lca].len;
				assert dep[base[i]]-dep[lca]-1 &gt;= 0;
				cur = hld.ancestor(base[i], dep[base[i]]-dep[lca]-1);
			}
			// x
			//b a
			//   a
			
			// paint
			int cx = hld.clus[base[i]]; // cluster
			int ind = hld.clusiind[base[i]]; // pos in cluster
			while(true){
				sts[cx].update(0, ind+1, i);
				int con = par[hld.cluspath[cx][0]];
				if(con == -1)break;
				ind = hld.clusiind[con];
				cx = hld.clus[con];
			}
			
//			tr(i, restoreRangeFenwick(ft0, ft1));
			addFenwick(ft0, 0, i+1+1);
			addFenwick(ft0, i+1+1, -(i+1+1));
			addFenwick(ft1, 0, -1);
			addFenwick(ft1, i+1+1, 1);
//			tr(i, restoreRangeFenwick(ft0, ft1));
			
			while(qp &lt; Q &amp;&amp; qs[qp][1] &lt;= i){
//				tr(qs[qp]);
				ans[qs[qp][2]] = sumRangeFenwick(ft0, ft1, qs[qp][0]);
				qp++;
			}
		}
		for(long an : ans){
			out.println(an);
		}
	}
	
	public static long sumFenwick(long[] ft, int i)
	{
		long sum = 0;
		for(i++;i &gt; 0;i -= i&amp;-i)sum += ft[i];
		return sum;
	}
	
	public static void addFenwick(long[] ft, int i, long v)
	{
		if(v == 0)return;
		int n = ft.length;
		for(i++;i &lt; n;i += i&amp;-i)ft[i] += v;
	}
	
	public static int firstGEFenwick(long[] ft, long v)
	{
		int i = 0, n = ft.length;
		for(int b = Integer.highestOneBit(n);b != 0;b &gt;&gt;= 1){
			if((i|b) &lt; n &amp;&amp; ft[i|b] &lt; v){
				i |= b;
				v -= ft[i];
			}
		}
		return i;
	}
	
	public static long[] restoreFenwick(long[] ft)
	{
		int n = ft.length-1;
		long[] ret = new long[n];
		for(int i = 0;i &lt; n;i++)ret[i] = sumFenwick(ft, i);
		for(int i = n-1;i &gt;= 1;i--)ret[i] -= ret[i-1];
		return ret;
	}
	
	public static int findGFenwick(long[] ft, long v)
	{
		int i = 0;
		int n = ft.length;
		for(int b = Integer.highestOneBit(n);b != 0 &amp;&amp; i &lt; n;b &gt;&gt;= 1){
			if(i + b &lt; n){
				int t = i + b;
				if(v &gt;= ft[t]){
					i = t;
					v -= ft[t];
				}
			}
		}
		return v != 0 ? -(i+1) : i-1;
	}
	
	public static long[] buildFenwick(long[] a)
	{
		int n = a.length;
		long[] ft = new long[n+1];
		System.arraycopy(a, 0, ft, 1, n);
		for(int k = 2, h = 1;k &lt;= n;k*=2, h*=2){
			for(int i = k;i &lt;= n;i+=k){
				ft[i] += ft[i-h];
			}
		}
		return ft;
	}
	
	public static void addRangeFenwick(long[] ft0, long[] ft1, int i, long v)
	{
		addFenwick(ft1, i+1, -v);
		addFenwick(ft1, 0, v);
		addFenwick(ft0, i+1, v*(i+1));
	}
	
	public static void addRangeFenwick(long[] ft0, long[] ft1, int a, int b, long v)
	{
		if(a &lt;= b){
			addFenwick(ft1, b+1, -v);
			addFenwick(ft0, b+1, v*(b+1));
			addFenwick(ft1, a, v);
			addFenwick(ft0, a, -v*a);
		}
	}
	
	public static long sumRangeFenwick(long[] ft0, long[] ft1, int i)
	{
		return sumFenwick(ft1, i) * (i+1) + sumFenwick(ft0, i);
	}
	
	public static long[] restoreRangeFenwick(long[] ft0, long[] ft1)
	{
		int n = ft0.length-1;
		long[] ret = new long[n];
		for(int i = 0;i &lt; n;i++)ret[i] = sumRangeFenwick(ft0, ft1, i);
		for(int i = n-1;i &gt;= 1;i--)ret[i] -= ret[i-1];
		return ret;
	}

	
	public static class SegmentTreeOverwrite {
		public int M, H, N;
		public int[] cover;
		public int I = Integer.MAX_VALUE;
		
		public SegmentTreeOverwrite(int len)
		{
			N = len;
			M = Integer.highestOneBit(Math.max(N-1, 1))&lt;&lt;2;
			H = M&gt;&gt;&gt;1;
			cover = new int[M];
			Arrays.fill(cover, I);
			for(int i = 0;i &lt; N;i++){
				cover[H+i] = -1;
			}
			for(int i = H-1;i &gt;= 1;i--){
				propagate(i);
			}
		}
		
		private void propagate(int i){}
		
		public void update(int l, int r, int v){ update(l, r, v, 0, H, 1); }
		
		private void update(int l, int r, int v, int cl, int cr, int cur)
		{
			if(l &lt;= cl &amp;&amp; cr &lt;= r){
				cover[cur] = v;
				propagate(cur);
			}else{
				int mid = cl+cr&gt;&gt;&gt;1;
				if(cover[cur] != I){ // back-propagate
					cover[2*cur] = cover[2*cur+1] = cover[cur];
					cover[cur] = I;
					propagate(2*cur);
					propagate(2*cur+1);
				}
				if(cl &lt; r &amp;&amp; l &lt; mid){
					update(l, r, v, cl, mid, 2*cur);
				}
				if(mid &lt; r &amp;&amp; l &lt; cr){
					update(l, r, v, mid, cr, 2*cur+1);
				}
				propagate(cur);
			}
		}
		
		public int get(int x){ 
			int val = I;
			for(int i = H+x;i &gt;= 1;i&gt;&gt;&gt;=1){
				if(cover[i] != I)val = cover[i];
			}
			return val;
		}
	}

	
	public static class HeavyLightDecomposition {
		public int[] clus;
		public int[][] cluspath;
		public int[] clusiind;
		public int[] par, dep;
		
		public HeavyLightDecomposition(int[][] g, int[] par, int[] ord, int[] dep)
		{
			init(g, par, ord, dep);
		}
		
		public void init(int[][] g, int[] par, int[] ord, int[] dep)
		{
			clus = decomposeToHeavyLight(g, par, ord);
			cluspath = clusPaths(clus, ord);
			clusiind = clusIInd(cluspath, g.length);
			this.par = par;
			this.dep = dep;
		}
		
		public static int[] decomposeToHeavyLight(int[][] g, int[] par, int[] ord)
		{
			int n = g.length;
			int[] size = new int[n];
			Arrays.fill(size, 1);
			for(int i = n-1;i &gt; 0;i--)size[par[ord[i]]] += size[ord[i]];
			
			int[] clus = new int[n];
			Arrays.fill(clus, -1);
			int p = 0;
			for(int i = 0;i &lt; n;i++){
				int u = ord[i];
				if(clus[u] == -1)clus[u] = p++;
				// centroid path (not heavy path)
				int argmax = -1;
				for(int v : g[u]){
					if(par[u] != v &amp;&amp; (argmax == -1 || size[v] &gt; size[argmax]))argmax = v;
				}
				if(argmax != -1)clus[argmax] = clus[u];
			}
			return clus;
		}
		
		public static int[][] clusPaths(int[] clus, int[] ord)
		{
			int n = clus.length;
			int[] rp = new int[n];
			int sup = 0;
			for(int i = 0;i &lt; n;i++){
				rp[clus[i]]++;
				sup = Math.max(sup, clus[i]);
			}
			sup++;
			
			int[][] row = new int[sup][];
			for(int i = 0;i &lt; sup;i++)row[i] = new int[rp[i]];
			
			for(int i = n-1;i &gt;= 0;i--){
				row[clus[ord[i]]][--rp[clus[ord[i]]]] = ord[i];
			}
			return row;
		}
		
		public static int[] clusIInd(int[][] clusPath, int n)
		{
			int[] iind = new int[n];
			for(int[] path : clusPath){
				for(int i = 0;i &lt; path.length;i++){
					iind[path[i]] = i;
				}
			}
			return iind;
		}
		
		public int lca(int x, int y)
		{
			int rx = cluspath[clus[x]][0];
			int ry = cluspath[clus[y]][0];
			while(clus[x] != clus[y]){
				if(dep[rx] &gt; dep[ry]){
					x = par[rx];
					rx = cluspath[clus[x]][0];
				}else{
					y = par[ry];
					ry = cluspath[clus[y]][0];
				}
			}
			return clusiind[x] &gt; clusiind[y] ? y : x;
		}
		
		public int ancestor(int x, int v)
		{
			while(x != -1){
				if(v &lt;= clusiind[x])return cluspath[clus[x]][clusiind[x]-v];
				v -= clusiind[x]+1;
				x = par[cluspath[clus[x]][0]];
			}
			return x;
		}
	}

	
	public static int lca2(int a, int b, int[][] spar, int[] depth) {
		if (depth[a] &lt; depth[b]) {
			b = ancestor(b, depth[b] - depth[a], spar);
		} else if (depth[a] &gt; depth[b]) {
			a = ancestor(a, depth[a] - depth[b], spar);
		}

		if (a == b)
			return a;
		int sa = a, sb = b;
		for (int low = 0, high = depth[a], t = Integer.highestOneBit(high), k = Integer
				.numberOfTrailingZeros(t); t &gt; 0; t &gt;&gt;&gt;= 1, k--) {
			if ((low ^ high) &gt;= t) {
				if (spar[k][sa] != spar[k][sb]) {
					low |= t;
					sa = spar[k][sa];
					sb = spar[k][sb];
				} else {
					high = low | t - 1;
				}
			}
		}
		return spar[0][sa];
	}

	protected static int ancestor(int a, int m, int[][] spar) {
		for (int i = 0; m &gt; 0 &amp;&amp; a != -1; m &gt;&gt;&gt;= 1, i++) {
			if ((m &amp; 1) == 1)
				a = spar[i][a];
		}
		return a;
	}

	public static int[][] logstepParents(int[] par) {
		int n = par.length;
		int m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;
		int[][] pars = new int[m][n];
		pars[0] = par;
		for (int j = 1; j &lt; m; j++) {
			for (int i = 0; i &lt; n; i++) {
				pars[j][i] = pars[j - 1][i] == -1 ? -1 : pars[j - 1][pars[j - 1][i]];
			}
		}
		return pars;
	}

	
	public static int[][] parents3(int[][] g, int root) {
		int n = g.length;
		int[] par = new int[n];
		Arrays.fill(par, -1);

		int[] depth = new int[n];
		depth[0] = 0;

		int[] q = new int[n];
		q[0] = root;
		for (int p = 0, r = 1; p &lt; r; p++) {
			int cur = q[p];
			for (int nex : g[cur]) {
				if (par[cur] != nex) {
					q[r++] = nex;
					par[nex] = cur;
					depth[nex] = depth[cur] + 1;
				}
			}
		}
		return new int[][] { par, q, depth };
	}

	
	static int[][] packU(int n, int[] from, int[] to) {
		int[][] g = new int[n][];
		int[] p = new int[n];
		for (int f : from)
			p[f]++;
		for (int t : to)
			p[t]++;
		for (int i = 0; i &lt; n; i++)
			g[i] = new int[p[i]];
		for (int i = 0; i &lt; from.length; i++) {
			g[from[i]][--p[from[i]]] = to[i];
			g[to[i]][--p[to[i]]] = from[i];
		}
		return g;
	}
	
	public static class SuffixAutomatonOfBit {
		public Node t0;
		public int len;
		public Node[] nodes;
		public int gen;
		private boolean sortedTopologically = false;
		private boolean lexsorted = false;
		
		private SuffixAutomatonOfBit(int n)
		{
			gen = 0;
			nodes = new Node[2*n];
			this.t0 = makeNode(0, null);
		}
		
		private Node makeNode(int len, Node original)
		{
			Node node = new Node();
			node.id = gen;
			node.original = original;
			node.len = len;
			nodes[gen++] = node;
			return node;
		}
		
		public static class Node
		{
			public int id;
			public int len;
			public char key;
			public Node link;
			private Node[] next = new Node[3];
			public Node original;
			public int np = 0;
			public int hit = 0;
			
			public void putNext(char c, Node to)
			{
				to.key = c;
				if(hit&lt;&lt;~(c-'a')&lt;0){
					for(int i = 0;i &lt; np;i++){
						if(next[i].key == c){
							next[i] = to;
							return;
						}
					}
				}
				hit |= 1&lt;&lt;c-'a';
				if(np == next.length){
					next = Arrays.copyOf(next, np*2);
				}
				next[np++] = to;
			}
			
			public boolean containsKeyNext(char c)
			{
				return hit&lt;&lt;~(c-'a')&lt;0;
//				for(int i = 0;i &lt; np;i++){
//					if(next[i].key == c)return true;
//				}
//				return false;
			}
			
			public Node getNext(char c)
			{
				if(hit&lt;&lt;~(c-'a')&lt;0){
					for(int i = 0;i &lt; np;i++){
						if(next[i].key == c)return next[i];
					}
				}
				return null;
			}
			
			public List&lt;String&gt; suffixes(char[] s)
			{
				List&lt;String&gt; list = new ArrayList&lt;String&gt;();
				if(id == 0)return list;
				int first = original != null ? original.len : len;
				for(int i = link.len + 1;i &lt;= len;i++){
					list.add(new String(s, first - i, i));
				}
				return list;
			}
		}

		public static SuffixAutomatonOfBit build(char[] str)
		{
			int n = str.length;
			SuffixAutomatonOfBit sa = new SuffixAutomatonOfBit(n);
			sa.len = str.length;
			
			Node last = sa.t0;
			for(char c : str){
				last = sa.extend(last, c);
			}
			
			return sa;
		}
		
		public Node extend(Node last, char c)
		{
			Node cur = makeNode(last.len+1, null);
			Node p;
			for(p = last; p != null &amp;&amp; !p.containsKeyNext(c);p = p.link){
				p.putNext(c, cur);
			}
			if(p == null){
				cur.link = t0;
			}else{
				Node q = p.getNext(c); // not null
				if(p.len + 1 == q.len){
					cur.link = q;
				}else{
					Node clone = makeNode(p.len+1, q);
					clone.next = Arrays.copyOf(q.next, q.next.length);
					clone.hit = q.hit;
					clone.np = q.np;
					clone.link = q.link;
					for(;p != null &amp;&amp; q.equals(p.getNext(c)); p = p.link){
						p.putNext(c, clone);
					}
					q.link = cur.link = clone;
				}
			}
			return cur;
		}
		
		public SuffixAutomatonOfBit lexSort()
		{
			for(int i = 0;i &lt; gen;i++){
				Node node = nodes[i];
				Arrays.sort(node.next, 0, node.np, new Comparator&lt;Node&gt;() {
					public int compare(Node a, Node b) {
						return a.key - b.key;
					}
				});
			}
			lexsorted = true;
			return this;
		}
		
		public SuffixAutomatonOfBit sortTopologically()
		{
			int[] indeg = new int[gen];
			for(int i = 0;i &lt; gen;i++){
				for(int j = 0;j &lt; nodes[i].np;j++){
					indeg[nodes[i].next[j].id]++;
				}
			}
			Node[] sorted = new Node[gen];
			sorted[0] = t0;
			int p = 1;
			for(int i = 0;i &lt; gen;i++){
				Node cur = sorted[i];
				for(int j = 0;j &lt; cur.np;j++){
					if(--indeg[cur.next[j].id] == 0){
						sorted[p++] = cur.next[j];
					}
				}
			}
			
			for(int i = 0;i &lt; gen;i++)sorted[i].id = i;
			nodes = sorted;
			sortedTopologically = true;
			return this;
		}
		
		// visualizer
		
		public String toString()
		{
			StringBuilder sb = new StringBuilder();
			for(Node n : nodes){
				if(n != null){
					sb.append(String.format("{id:%d, len:%d, link:%d, cloned:%b, ",
							n.id,
							n.len,
							n.link != null ? n.link.id : null,
							n.original.id));
					sb.append("next:{");
					for(int i = 0;i &lt; n.np;i++){
						sb.append(n.next[i].key + ":" + n.next[i].id + ",");
					}
					sb.append("}");
					sb.append("}");
					sb.append("\n");
				}
			}
			return sb.toString();
		}
		
		public String toGraphviz(boolean next, boolean suffixLink)
		{
			StringBuilder sb = new StringBuilder("http://chart.apis.google.com/chart?cht=gv:dot&amp;chl=");
			sb.append("digraph{");
			for(Node n : nodes){
				if(n != null){
					if(suffixLink &amp;&amp; n.link != null){
						sb.append(n.id)
						.append("-&gt;")
						.append(n.link.id)
						.append("[style=dashed],");
					}
					
					if(next &amp;&amp; n.next != null){
						for(int i = 0;i &lt; n.np;i++){
							sb.append(n.id)
							.append("-&gt;")
							.append(n.next[i].id)
							.append("[label=")
							.append(n.next[i].key)
							.append("],");
						}
					}
				}
			}
			sb.append("}");
			return sb.toString();
		}
		
		public String label(Node n)
		{
			if(n.original != null){
				return n.id + "C";
			}else{
				return n.id + "";
			}
		}
		
		public String toDot(boolean next, boolean suffixLink)
		{
			StringBuilder sb = new StringBuilder("digraph{\n");
			sb.append("graph[rankdir=LR];\n");
			sb.append("node[shape=circle];\n");
			for(Node n : nodes){
				if(n != null){
					if(suffixLink &amp;&amp; n.link != null){
						sb.append("\"" + label(n) + "\"")
						.append("-&gt;")
						.append("\"" + label(n.link) + "\"")
						.append("[style=dashed];\n");
					}
					
					if(next &amp;&amp; n.next != null){
						for(int i = 0;i &lt; n.np;i++){
							sb.append("\"" + label(n) + "\"")
							.append("-&gt;")
							.append("\"" + label(n.next[i]) + "\"")
							.append("[label=\"")
							.append(n.next[i].key)
							.append("\"];\n");
						}
					}
				}
			}
			sb.append("}\n");
			return sb.toString();
		}
	}
	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new G2().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.140
medium
----------
PROBLEM STATEMENT:
Hackerland is a one-dimensional city with houses aligned at integral locations along a road. The Mayor wants to install radio transmitters on the roofs of the city's houses. Each transmitter has a fixed range meaning it can transmit a signal to all houses within that number of units distance away.

Given a map of Hackerland and the transmission range, determine the minimum number of transmitters so that every house is within range of at least one transmitter.  Each transmitter must be installed on top of an existing house.

For example, assume houses are located at [expression]. 

Function Description  

Complete the hackerlandRadioTransmitters function in the editor below.  It must return an integer that denotes the minimum number of transmitters to install.  

hackerlandRadioTransmitters has the following parameter(s):  


x: integer array that denotes the locations of houses  
k: an integer that denotes the effective range of a transmitter  

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class UnivCodesprint2016qA {

    public static void main(String[] args) {
        InputReader in = new InputReader(System.in);
        PrintWriter w = new PrintWriter(System.out);

        int n = in.nextInt();
        int k = in.nextInt();
        
        int a[] = in.nextIntArray(n);
        Arrays.sort(a);
      
        int ans = 0;
        
        for (int i = 0; i &lt; n; i++) {
          int j = i;
          while (j + 1 &lt; n &amp;&amp; a[j + 1] - a[i] &lt;= k)
            j++;
          i = j;
          while (j + 1 &lt; n &amp;&amp; a[j + 1] - a[i] &lt;= k)
            j++;
          i = j;
          ans++;
        }
        
        w.println(ans);
        w.close();
    }

    static class InputReader {

        private final InputStream stream;
        private final byte[] buf = new byte[8192];
        private int curChar, snumChars;
        private SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int snext() {
            if (snumChars == -1)
                throw new InputMismatchException();
            if (curChar &gt;= snumChars) {
                curChar = 0;
                try {
                    snumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (snumChars &lt;= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = snext();
            while (isSpaceChar(c)) {
                c = snext();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = snext();
            }
            int res = 0;
            do {
                if (c &lt; '0' || c &gt; '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = snext();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public long nextLong() {
            int c = snext();
            while (isSpaceChar(c)) {
                c = snext();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = snext();
            }
            long res = 0;
            do {
                if (c &lt; '0' || c &gt; '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = snext();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public int[] nextIntArray(int n) {
            int a[] = new int[n];
            for (int i = 0; i &lt; n; i++) {
                a[i] = nextInt();
            }
            return a;
        }

        public String readString() {
            int c = snext();
            while (isSpaceChar(c)) {
                c = snext();
            }
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = snext();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        public String nextLine() {
            int c = snext();
            while (isSpaceChar(c))
                c = snext();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = snext();
            } while (!isEndOfLine(c));
            return res.toString();
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        private boolean isEndOfLine(int c) {
            return c == '\n' || c == '\r' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
}
----------
====================
----------
ALGORITHMS.141
medium
----------
PROBLEM STATEMENT:
The city of Gridland is represented as an [expression].

Gridland has a network of train tracks that always run in straight horizontal lines along a row. In other words, the start and end points of a train track are [expression] represents the ending column of the train track. 

The mayor of Gridland is surveying the city to determine the number of locations where lampposts can be placed. A lamppost can be placed in any cell that is not occupied by a train track.

Given a map of Gridland and its [expression] train tracks, find and print the number of cells where the mayor can place lampposts.

Note: A train track may overlap other train tracks within the same row. 

For example, if Gridland's data is the following:

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]	
[expression]



  

In this case, there are five open cells (red) where lampposts can be placed.

Function Description

Complete the gridlandMetro function in the editor below.  It should return an integer that denotes the number of cells where lampposts can be installed.  

gridlandMetro has the following parameter(s):  


n: an integer, the number of rows in Gridland
m: an integer, the number of columns in Gridland
k: an integer, the number of tracks
track: a 2 dimensional array of integers where each element contains [expression] 

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

#define FI(i,a,b) for(int i=(a);i&lt;=(b);i++)
#define FD(i,a,b) for(int i=(a);i&gt;=(b);i--)

#define LL long long
#define Ldouble long double
#define PI 3.1415926535897932384626

#define PII pair&lt;int,int&gt;
#define PLL pair&lt;LL,LL&gt;
#define mp make_pair
#define fi first
#define se second

using namespace std;

int n, m, k, p;
map&lt;int, int&gt; M;
vector&lt;PII&gt; vec[1005];

LL ans;

int main(){
	scanf("%d %d %d", &amp;n, &amp;m, &amp;k);
	ans = 1LL * n * m;
	
	FI(i, 1, k){
		int a, b, c;
		scanf("%d %d %d", &amp;a, &amp;b, &amp;c);
		if(M.count(a) == 0) M[a] = ++p;
		vec[M[a]].push_back(mp(b, c));
	}
	
	FI(i, 1, p){
		sort(vec[i].begin(), vec[i].end());
		int pv = 0;
		FI(j, 0, (int)vec[i].size() - 1){
			PII c = vec[i][j];
			if(c.fi &gt; pv) ans += c.fi - 1 - pv;
			pv = max(pv, c.se);
		}
		ans -= pv;
	}
	printf("%lld\n", ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.142
easy
----------
PROBLEM STATEMENT:
Sunny and Johnny like to pool their money and go to the ice cream parlor.  Johnny never buys the same flavor that Sunny does.  The only other rule they have is that they spend all of their money.

Given a list of prices for the flavors of ice cream, select the two that will cost all of the money they have.  

For example, they have [expression].  

Function Description

Complete the icecreamParlor function in the editor below.  It should return an array containing the indices of the prices of the two flavors they buy, sorted ascending.  

icecreamParlor has the following parameter(s):  


m: an integer denoting the amount of money they have to spend  
cost: an integer array denoting the cost of each flavor of ice cream  

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int answer(int i, int j) {
    cout &lt;&lt; 1 + min(i, j) &lt;&lt; " " &lt;&lt; 1 + max(i, j) &lt;&lt; endl;
}

int main() {
    int tc;
    cin &gt;&gt; tc;
    for (; tc &gt; 0; tc--) {
        int W;
        cin &gt;&gt; W;
        int n;
        cin &gt;&gt; n;
        vector&lt;pair&lt;int, int&gt; &gt; a (n);
        for (int i = 0; i &lt; n; i++) {
            cin &gt;&gt; a[i].first; a[i].second = i;
        }
        sort(a.begin(), a.end());
        for (int i = 0, j = n-1; i &lt; n; i++) {
            while (j &gt; 0 and a[i].first + a[j].first &gt; W) j--;
            if (a[i].first + a[j].first == W and i &lt; j) answer(a[i].second, a[j].second);
        }
    }
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
ALGORITHMS.143
medium
----------
PROBLEM STATEMENT:
[expression] satisfying either of the following:


[expression], or  
[expression]  


Note that [expression] chessboard:



Observe that for each possible movement, the Knight moves [expression] unit in the perpendicular direction.

Given the value of [expression]:


What is the minimum number of moves it takes for [expression]? If it's not possible for the Knight to reach that destination, the answer is -1 instead.


Then print the answer for each [expression] according to the Output Format specified below.
----------
TOP SOLUTION:
----------
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;
#include &lt;cstdio&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_map&gt;

using namespace std;


int main(){
    int n;
    cin &gt;&gt; n;
    // your code goes here
    for (int i = 1; i &lt; n; i++) {
        for (int j = 1; j &lt; n; j++) {
            int dist[26][26];
            memset(dist, -1, sizeof(dist));
            int q[26 * 26], sz = 0;
            q[sz++] = 0;
            dist[0][0] = 0;
            for (int s = 0; s &lt; sz; s++) {
                int r = q[s] / n, c = q[s] % n;
                for (int a = -1; a &lt; 2; a += 2) {
                    for (int b = -1; b &lt; 2; b += 2) {
                        int nr = r + a * i;
                        int nc = c + b * j;
                        if (nr &lt; 0 || nr &gt;= n || nc &lt; 0 || nc &gt;= n || dist[nr][nc] != -1) {
                            continue;
                        }
                        dist[nr][nc] = dist[r][c] + 1;
                        q[sz++] = nr * n + nc;
                    }
                }
                for (int a = -1; a &lt; 2; a += 2) {
                    for (int b = -1; b &lt; 2; b += 2) {
                        int nr = r + a * j;
                        int nc = c + b * i;
                        if (nr &lt; 0 || nr &gt;= n || nc &lt; 0 || nc &gt;= n || dist[nr][nc] != -1) {
                            continue;
                        }
                        dist[nr][nc] = dist[r][c] + 1;
                        q[sz++] = nr * n + nc;
                    }
                }
            }
            cout &lt;&lt; dist[n - 1][n - 1] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.144
medium
----------
PROBLEM STATEMENT:
Lauren has a chart of distinct projected prices for a house over the next several years.  She must buy the house in one year and sell it in another, and she must do so at a loss.  She wants to minimize her financial loss.  

For example, the house is valued at [expression].

Find and print the minimum amount of money Lauren must lose if she buys the house and resells it within the next [expression] years.

Note: It's guaranteed that a valid answer exists.

Function Description  

Complete the minimumLoss function in the editor below.  It should return an integer that represents the minimum loss that can be achieved.  

minimumLoss has the following parameter(s):  


price: an array of integers that represent prices at each year  

----------
TOP SOLUTION:
----------
// Simran Dokania
// International Institute of Information Technology Bangalore
#include &lt;bits/stdc++.h&gt;

using namespace std;

#define FASTER ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)
#define pb push_back
#define mp make_pair
#define pd(x) printf("%d", x)
#define pdn(x) printf("%d\n", x)
#define plld(x) printf("%I64d", x)
#define plldn(x) printf("%I64d\n", x)
#define fi first
#define se second
#define sd(x) scanf("%d",&amp;x)
#define sd2(x,y) scanf("%d%d",&amp;x,&amp;y);
#define sd3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z); //spaces should not be there to avoid tle
#define slld(x) scanf("%I64d",&amp;x)
#define LET(x, a)  __typeof(a) x(a)
#define foreach(it, v) for(LET(it, v.begin()); it != v.end(); it++)
#define tr(...) cout&lt;&lt;__FUNCTION__&lt;&lt;' '&lt;&lt;__LINE__&lt;&lt;" = ";trace(#__VA_ARGS__, __VA_ARGS__)

template&lt;typename S, typename T&gt; 
ostream&amp; operator&lt;&lt;(ostream&amp; out,pair&lt;S,T&gt; const&amp; p){out&lt;&lt;'('&lt;&lt;p.fi&lt;&lt;", "&lt;&lt;p.se&lt;&lt;')';return out;}

template&lt;typename T&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; out,vector&lt;T&gt; const&amp; v){
int l=v.size();for(int i=0;i&lt;l-1;i++)out&lt;&lt;v[i]&lt;&lt;' ';if(l&gt;0)out&lt;&lt;v[l-1];return out;}

template&lt;typename T&gt;
void trace(const char* name, T&amp;&amp; arg1){cout&lt;&lt;name&lt;&lt;" : "&lt;&lt;arg1&lt;&lt;endl;}

template&lt;typename T, typename... Args&gt;
void trace(const char* names, T&amp;&amp; arg1, Args&amp;&amp;... args){
const char* comma = strchr(names + 1, ',');cout.write(names, comma-names)&lt;&lt;" : "&lt;&lt;arg1&lt;&lt;" | ";trace(comma+1,args...);}

typedef pair&lt;int, int&gt; pii;
typedef long long ll;
typedef long double ld;

/*
ifstream fin("input.txt");
ofstream fout("output.txt");
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
*/

const int N = 200100;

int n;
ll p[N];

int main()
{
	FASTER;
	cin &gt;&gt; n;
	for(int i = 0; i &lt; n; i++){
		cin &gt;&gt; p[i];
	}	
	
	set&lt;ll&gt; s;
	s.insert(p[0]);
	
	ll mx = -1e18;
	
	for(int i = 1; i &lt; n; i++){
		auto it = s.upper_bound(p[i]);
		if(it == s.end()){
			s.insert(p[i]);
			continue;
		}
		
		mx = max(mx, p[i] - (*it));
		s.insert(p[i]);
	}
	
	cout &lt;&lt; -mx;	
	
	return 0;
}
----------
====================
----------
ALGORITHMS.145
easy
----------
PROBLEM STATEMENT:
Numeros the Artist had two lists that were permutations of one another.  He was very proud. Unfortunately, while transporting them from one exhibition to another, some numbers were lost out of the first list. Can you find the missing numbers?

As an example, the array with some numbers missing, [expression].  

Notes  


If a number occurs multiple times in the lists, you must ensure that the frequency of that number in both lists is the same. If that is not the case, then it is also a missing number. 
You have to print all the missing numbers in ascending order. 
Print each missing number once, even if it is missing multiple times. 
The difference between maximum and minimum number in the second list is less than or equal to [expression].  


Function Description  

Complete the missingNumbers function in the editor below.  It should return a sorted array of missing numbers.  

missingNumbers has the following parameter(s):


arr: the array with missing numbers   
brr: the original array of numbers   

----------
TOP SOLUTION:
----------
n = int(input())
A = [int(i) for i in input().split()]
m = int(input())
B = [int(i) for i in input().split()]
vals = {}
for i in A:
    if i not in vals:
        vals[i] = -1
    else:
        vals[i] -= 1
for i in B:
    if i not in vals:
        vals[i] = 1
    else:
        vals[i] += 1
pos = []
for i in vals:
    if vals[i] &gt; 0:
        pos.append(i)
pos.sort()
for i in pos:
    print(i,end=' ')
----------
====================
----------
ALGORITHMS.146
medium
----------
PROBLEM STATEMENT:
You will be given an array of integers and a target value.  Determine the number of pairs of array elements that have a difference equal to a target value.  

For example, given an array of [1, 2, 3, 4] and a target value of 1, we have three values meeting the condition: [expression].

Function Description

Complete the pairs function below.  It must return an integer representing the number of element pairs having the required difference.

pairs has the following parameter(s):


k: an integer, the target difference
arr: an array of integers

----------
TOP SOLUTION:
----------
#!/usr/bin/py
# Head ends here
def pairs(a,k):
    # a is the list of numbers and k is the difference value
    a.sort()
    left = 0
    right = 1
    answer = 0
    while right &lt; len(a):
        val = a[right]-a[left]
        if val == k:
            answer += 1
            left += 1
            right += 1
        elif val &lt; k:
            right += 1
        else:
            left += 1
            if left == right:
                right += 1

    return answer
# Tail starts here
if __name__ == '__main__':
    a = input().strip()
    a = list(map(int, a.split(' ')))
    _a_size=a[0]
    _k=a[1]
    b = input().strip()
    b = list(map(int, b.split(' ')))
    print(pairs(b,_k))

----------
====================
----------
ALGORITHMS.147
easy
----------
PROBLEM STATEMENT:
Watson gives Sherlock an array of integers.  His challenge is to find an element of the array such that the sum of all elements to the left is equal to the sum of all elements to the right.  For instance, given the array [expression].

You will be given arrays of integers and must determine whether there is an element that meets the criterion.

Function Description  

Complete the balancedSums function in the editor below.  It should return a string, either YES if there is an element meeting the criterion or NO otherwise.  

balancedSums has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;

#define REP(i,a,b) for(i=a;i&lt;b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'&lt;=k&amp;&amp;k&lt;='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k&lt;'0'||k&gt;'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(int *x, int *y){reader(x);reader(y);}
void reader(int *x, int *y, int *z){reader(x);reader(y);reader(z);}
int reader(char c[]){int i,s=0;for(;;){mygc(i);if(i!=' '&amp;&amp;i!='\n'&amp;&amp;i!='\r'&amp;&amp;i!='\t'&amp;&amp;i!=EOF) break;}c[s++]=i;for(;;){mygc(i);if(i==' '||i=='\n'||i=='\r'||i=='\t'||i==EOF) break;c[s++]=i;}return s;}

void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}

int T, N, A[200000], sum[200000];

int main(){
  int i, j, k;

  reader(&amp;T);
  while(T--){
    reader(&amp;N);
    rep(i,N) reader(A+i);

    sum[0] = 0;
    rep(i,N) sum[i+1] = sum[i] + A[i];

    k = 0;
    rep(i,N){
      if(sum[i] == sum[N]-sum[i+1]){ k = 1; break; }
    }
    if(k) writer("YES\n"); else writer("NO\n");
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.148
hard
----------
PROBLEM STATEMENT:
We define the following:


A subarray of array [expression].
The sum of an array is the sum of its elements.


Given an [expression].  The following table lists all subarrays and their moduli:

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



The maximum modulus is [expression].

Function Description

Complete the maximumSum function in the editor below.  It should return a long integer that represents the maximum value of [expression].

maximumSum has the following parameter(s):


a: an array of long integers, the array to analyze
m: a long integer, the modulo divisor

----------
TOP SOLUTION:
----------
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;limits&gt;
#include &lt;functional&gt;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus &gt; 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector&lt;int&gt; vi; typedef pair&lt;int,int&gt; pii; typedef vector&lt;pair&lt;int,int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; inline void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; inline void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

int main() {
	int T;
	scanf("%d", &amp;T);
	rep(ii, T) {
		int N; long long M;
		scanf("%d%lld", &amp;N, &amp;M);
		vector&lt;long long&gt; A(N);
		rep(i, N)
			scanf("%lld", &amp;A[i]);
		long long sum = 0, ans = 0;
		set&lt;long long&gt; s;
		rep(i, N) {
			s.insert(sum);
			(sum += A[i]) %= M;
			//sum - sum_i
			amax(ans, (sum - *s.begin() + M) % M);
			amax(ans, (sum - *s.lower_bound(sum+1) + M) % M);
		}
		printf("%lld\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.149
medium
----------
PROBLEM STATEMENT:
Consider a matrix where each cell contains either a [expression] is called a filled cell. Two cells are said to be connected if they are adjacent to each other horizontally, vertically, or diagonally.  In the following grid, all cells marked X are connected to the cell marked Y.

XXX
XYX  
XXX    


If one or more filled cells are also connected, they form a region. Note that each cell in a region is connected to zero or more cells in the region but is not necessarily directly connected to all the other cells in the region.

Given an [expression] matrix, find and print the number of cells in the largest region in the matrix. Note that there may be more than one region in the matrix.

For example, there are two regions in the following [expression].  

110
100
001


Function Description  

Complete the connectedCell function in the editor below.  It should return an integer that denotes the area of the largest region.  

connectedCell has the following parameter(s): 
- matrix: a 2D array of integers where [expression] row of the matrix  
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class Solution {
  private static InputReader in;
  private static PrintWriter out;
  public static int N,M;
  public static int[][] grid;
  public static boolean[][] vis;

  public static void main(String[] args) throws IOException {
    in = new InputReader(System.in);
    out = new PrintWriter(System.out, true);
    N = in.nextInt();
    M = in.nextInt();
    grid = new int[N][M];
    for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; M; j++)
      grid[i][j] = in.nextInt();
    
    int max = 0;
    vis = new boolean[N][M];
    for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; M; j++) {
      if (vis[i][j] || grid[i][j] == 0) continue;
      max = Math.max(max, dfs(i,j));
    }
    out.println(max);
    out.close();
    System.exit(0);
  }
  
  public static int dfs(int i, int j) {
    if (i &lt; 0 || j &lt; 0 || i &gt;= N || j &gt;= M || vis[i][j] || grid[i][j] == 0) return 0;
    int c = 1;
    vis[i][j] = true;
    c += dfs(i+1,j);
    c += dfs(i,j+1);
    c += dfs(i-1,j);
    c += dfs(i,j-1);
    c += dfs(i+1,j+1);
    c += dfs(i+1,j-1);
    c += dfs(i-1,j+1);
    c += dfs(i-1,j-1);
    return c;
  }

  static class InputReader {
    public BufferedReader reader;
    public StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
      reader = new BufferedReader(new InputStreamReader(stream), 32768);
      tokenizer = null;
    }

    public String next() {
      while (tokenizer == null || !tokenizer.hasMoreTokens()) {
        try {
          tokenizer = new StringTokenizer(reader.readLine());
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
      return tokenizer.nextToken();
    }

    public int nextInt() {
      return Integer.parseInt(next());
    }
  }


}

----------
====================
----------
ALGORITHMS.150
medium
----------
PROBLEM STATEMENT:
Consider a string, [expression] satisfying the following criteria:


[expression] are the same.
[expression] are the same.
[expression].


Given [expression].
----------
TOP SOLUTION:
----------
#define BUFSIZE 1000000
char buf[BUFSIZE];
int Tests, cnum;
// #define USEWIN
#define MANYTESTS 0
// #define LINEBYLINE

// Eryx's new template for I/O contests, May 3, 2015

#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
using namespace std;

typedef long long ll;

#define Size(x) (int(x.size()))

string getLine() {
  string s;
  while(!feof(stdin)) {
    char c = fgetc(stdin);
    if(c &lt;= 0) continue;
    if(c == 13) continue;
    if(c == 10) return s;
    s += c;
    }
  return s;
  }

int scanerr;

int getNum() {
#ifdef LINEBYLINE
  string s = getLine();
  return atoi(s.c_str());
#else
  int i;
  scanerr = scanf("%d", &amp;i);
  return i;
#endif
  }

string getStr() {
#ifdef LINEBYLINE
  return getStr();
#else
  scanerr = scanf("%s", buf);
  return buf;
#endif
  }

#define TDEF template&lt;int P&gt;
#define modarP modar&lt;P&gt;

TDEF struct modar {
  int content;
  
  modar(int _c) { content = _c % P; if(content&lt;0) content += P; }
  modar(ll _c) { content = _c % P; if(content&lt;0) content += P; }
  modar() {}
  int asInt() { return content; }
  };

TDEF modarP operator == (modarP x, modarP y) { return x.content == y.content; }
TDEF modarP operator != (modarP x, modarP y) { return x.content != y.content; }

#define F(P, d) \
  TDEF modarP&amp; operator P##= (modarP&amp; x, modarP y) { d; return x; } \
  TDEF modarP&amp; operator P##= (modarP&amp; x, int y) { return x P##= modarP(y); } \
  TDEF modarP&amp; operator P##= (modarP&amp; x, ll  y) { return x P##= modarP(y); } \
  TDEF modarP operator P (modarP x, modarP y) { return x P##= y; } \
  F0(P)

#define F0(P) \
  TDEF modarP operator P (modarP x, int y) { return x P modarP(y); } \
  TDEF modarP operator P (modarP x, ll y) { return x P modarP(y); } 

F(+, ll tmp = x.content + ll(y.content); x.content = tmp&gt;=P ? tmp-P : tmp;) 
F(-, ll tmp = x.content - ll(y.content); x.content = tmp&lt;0 ? tmp+P : tmp;)
F(*, ll tmp = x.content * ll(y.content); x.content = tmp % P;) 
F(/, x *= power(y, P-2);)

F0(==) F0(!=)
#undef F
#undef F0

// ERROR ==/!= are not bools! check in text.cpp

TDEF modarP power(modarP x, int q) {
  modarP one(1);
  while(true) {
    if(q&amp;1) one *= x;
    q &gt;&gt;= 1;
    if(!q) return one;
    x *= x;
    }
  }

#line 10 "work.cpp"

/// ----


//Eryx

// !FDI

// states:
// [not counted] 

#define P 1000000007

modarP seenfirst[30];
modarP seenboth[30][30];
modarP seenthree[30][30];

void solveCase() {
  string S = getStr();
  modarP result;
  
  for(char cc: S) {
    int c = cc - 'a';
    
    for(int x=0; x&lt;26; x++)
      result += seenthree[c][x];
    for(int x=0; x&lt;26; x++)
      seenthree[x][c] += seenboth[x][c];
    for(int x=0; x&lt;26; x++)
      seenboth[x][c] += seenfirst[x];
    seenfirst[c] += 1;
    }
  
  printf("%d\n", result.asInt());
  }

#define P 1000000007

int main() {

  if(!MANYTESTS) Tests = 1;
  else Tests = getNum();
  
  for(cnum=1; cnum&lt;=Tests; cnum++)
    solveCase();
    
  // finish
  return 0;
  }

// This solution includes hidden routines to solve test cases in separate
// processes in order to make it faster. I will update them to run on a
// cluster if I get one ;)

----------
====================
----------
ALGORITHMS.151
hard
----------
PROBLEM STATEMENT:
Xander Cage has a list of cities he can visit on his new top-secret mission. He represents each city as a tuple of [expression] are distinct across all cities.

We define a mission as a sequence of cities, [expression] of all the cities in his mission list.

Being eccentric, he abides by the following rules on any mission:


He can choose the number of cities he will visit (if any).
He can start the mission from any city.
He visits cities in order of strictly increasing [expression].
The absolute difference in [expression].
The absolute difference in [expression].


Given [expression] that Xander can earn on a mission.
----------
TOP SOLUTION:
----------
//#define _GLIBCXX_DEBUG
#include &lt;bits/stdc++.h&gt;
using namespace std;
#define pb push_back
#define mp make_pair
#define fst first
#define snd second
#define forn(i, n) for (int i = 0; i &lt; int(n); ++i)
typedef long long ll;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef vector&lt;ll&gt; vll;
typedef pair&lt;int, int&gt; pii;
typedef vector&lt;pii&gt; vii;
#define sz(c) (int)(c).size()
#define ALL(c) (c).begin(), (c).end()

struct town
{
    int x, y, h, p;

    bool operator &lt; (const town &amp;o) const
    {
        return h &lt; o.h;
    }
};

struct segtree
{
    vll vals;
    int tsz;

    segtree ()
    {
        vals.clear();
        tsz = 0;
    }

    segtree (int n)
    {
        tsz = 1;
        while (tsz &lt;= n)
            tsz *= 2;

        vals.assign(2 * tsz, 0);
    }

    void put (int pos, ll what)
    {
        for (pos += tsz; pos &gt; 0; pos &gt;&gt;= 1)
            vals[pos] = max(vals[pos], what);
    }

    ll query (int l, int r)
    {
        ll ans = 0;
        for (l += tsz, r += tsz; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1)
        {
            if (l &amp; 1)
                ans = max(ans, vals[l++]);
            if (r &amp; 1)
                ans = max(ans, vals[--r]);
        }
        return ans;
    }
};

struct segtree2d
{
    vvi who;
    vector&lt;segtree&gt; data;
    int tsz;

    segtree2d (const vii &amp;ps)
    {
        int X = 0;
        const int n = sz(ps);
        forn (i, n) X = max(X, ps[i].fst);

        tsz = 1;
        while (tsz &lt;= X)
            tsz *= 2;

        data.resize(2 * tsz);
        who.resize(2 * tsz);
        forn (i, n)
            who[ps[i].fst + tsz].pb(ps[i].snd);

        for (int i = tsz; i &lt; 2 * tsz; i++)
            data[i] = segtree(sz(who[i]));

        for (int i = tsz - 1; i &gt;= 1; i--)
        {
            who[i].resize(sz(who[2 * i]) + sz(who[2 * i + 1]));
            merge(ALL(who[2 * i]), ALL(who[2 * i + 1]), who[i].begin());
            data[i] = segtree(sz(who[i]));
        }
    }

    ll query (int v, int d, int u)
    {
        int rd = lower_bound(ALL(who[v]), d) - who[v].begin();
        int ru = lower_bound(ALL(who[v]), u) - who[v].begin();
        return data[v].query(rd, ru);
    }

    ll query (int l, int r, int d, int u)
    {
        r = min(r, tsz);
        ll ans = 0;
        for (l += tsz, r += tsz; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1)
        {
            if (l &amp; 1)
                ans = max(ans, query(l++, d, u));
            if (r &amp; 1)
                ans = max(ans, query(--r, d, u));
        }
        return ans;
    }

    void putnode (int v, int pos, ll what)
    {
        int cur = lower_bound(ALL(who[v]), pos) - who[v].begin();
        assert(cur != sz(who[v]) &amp;&amp; who[v][cur] == pos);
        data[v].put(cur, what);
    }

    void put (int x, int y, ll what)
    {
        for (x += tsz; x &gt; 0; x &gt;&gt;= 1)
            putnode(x, y, what);
    }
};

void solve (int n)
{
    int mx, my;
    cin &gt;&gt; mx &gt;&gt; my;

    vector&lt;town&gt; v(n);
    forn (i, n)
        cin &gt;&gt; v[i].x &gt;&gt; v[i].y &gt;&gt; v[i].h &gt;&gt; v[i].p;

    sort(ALL(v));
    vii ps(n);
    forn (i, n) ps[i] = mp(v[i].x, v[i].y);

    segtree2d data(ps);
    vll dp(n);

    forn (i, n)
    {
        int cx = v[i].x, cy = v[i].y;
        int lx = max(0, cx - mx), ly = max(0, cy - my);
        int rx = cx + mx, ry = cy + my;
        dp[i] = data.query(lx, rx + 1, ly, ry + 1) + v[i].p;
        data.put(cx, cy, dp[i]);
    }

    ll ans = max(0LL, *max_element(ALL(dp)));
    cout &lt;&lt; ans &lt;&lt; endl;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    int n;
    while (cin &gt;&gt; n)
        solve(n);
}

----------
====================
----------
ALGORITHMS.152
medium
----------
PROBLEM STATEMENT:
Ron and Hermione are deep in the Forbidden Forest collecting potion ingredients, and they've managed to lose their way. The path out of the forest is blocked, so they must make their way to a portkey that will transport them back to Hogwarts.  

Consider the forest as an [expression]. 

.X.X......X
.X*.X.XXX.X
.XX.X.XM...
......XXXX.


In example above, Ron and Hermione are located at index [expression]. Each cell is indexed according to Matrix Conventions.    

Hermione decides it's time to find the portkey and leave. They start along the path and each time they have to choose a direction, she waves her wand and it points to the correct direction. Ron is betting that she will have to wave her wand exactly [expression] times. Can you determine if Ron's guesses are correct?

The map from above has been redrawn with the path indicated as a series where [expression] is just a step on the path:

.X.X.10000X
.X*0X0XXX0X
.XX0X0XM01.
...100XXXX.


There are three instances marked with [expression] where Hermione must use her wand.

Note: It is guaranteed that there is only one path from the starting location to the portkey.  

Function Description  

Complete the countLuck function in the editor below.  It should return a string, either [expression] if he is not.  

countLuck has the following parameters:  


matrix: a list of strings, each one represents a row of the matrix  
k: an integer that represents Ron's guess  

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class Solution {

	static void solve() throws IOException {
		int tc = nextInt();
		final int[] dx = { 0, 0, 1, -1 };
		final int[] dy = { 1, -1, 0, 0 };
		while (tc-- &gt; 0) {
			int rows = nextInt();
			int cols = nextInt();
			char[][] grid = new char[rows][];
			for (int i = 0; i &lt; rows; i++) {
				grid[i] = nextToken().toCharArray();
			}
			int k = nextInt();
			int start = find(grid, 'M');
			int finish = find(grid, '*');
			int[] goTo = new int[rows * cols];
			Arrays.fill(goTo, -1);
			int[] queue = new int[rows * cols];
			int qh = 0, qt = 0;
			queue[qt++] = finish;
			goTo[finish] = finish;
			while (qh &lt; qt) {
				int u = queue[qh++];
				int r = u / cols, c = u % cols;
				for (int dir = 0; dir &lt; 4; dir++) {
					int nr = r + dx[dir];
					int nc = c + dy[dir];
					if (nr &lt; 0 || nr &gt;= rows || nc &lt; 0 || nc &gt;= cols) {
						continue;
					}
					if (grid[nr][nc] == 'X') {
						continue;
					}
					int v = nr * cols + nc;
					if (goTo[v] &lt; 0) {
						goTo[v] = u;
						queue[qt++] = v;
					}
				}
			}
			if (goTo[start] &lt; 0) {
				out.println("Oops!");
				continue;
			}

			int wand = 0;
			for (int i = start; i != finish; i = goTo[i]) {
				int possibleMoves = 0;
				int r = i / cols, c = i % cols;
				for (int dir = 0; dir &lt; 4; dir++) {
					int nr = r + dx[dir];
					int nc = c + dy[dir];
					if (nr &lt; 0 || nr &gt;= rows || nc &lt; 0 || nc &gt;= cols) {
						continue;
					}
					if (grid[nr][nc] == 'X') {
						continue;
					}
					++possibleMoves;
				}
				if (possibleMoves &gt; 2 || (i == start &amp;&amp; possibleMoves &gt; 1)) {
					++wand;
				}
			}
			out.println(wand == k ? "Impressed" : "Oops!");
		}
	}

	private static int find(char[][] grid, char c) {
		int rows = grid.length;
		int cols = grid[0].length;
		for (int i = 0; i &lt; rows; i++) {
			for (int j = 0; j &lt; cols; j++) {
				if (grid[i][j] == c) {
					return i * cols + j;
				}
			}
		}
		return -1;
	}

	static BufferedReader br;
	static StringTokenizer st;
	static PrintWriter out;

	public static void main(String[] args) throws IOException {
		InputStream input = System.in;
		PrintStream output = System.out;
		br = new BufferedReader(new InputStreamReader(input));
		out = new PrintWriter(output);
		solve();
		out.close();
	}

	static long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	static double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	static int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	static String nextToken() throws IOException {
		while (st == null || !st.hasMoreTokens()) {
			String line = br.readLine();
			if (line == null) {
				return null;
			}
			st = new StringTokenizer(line);
		}
		return st.nextToken();
	}
}

----------
====================
----------
ALGORITHMS.153
medium
----------
PROBLEM STATEMENT:
Anna loves graph theory! She has a tree where each vertex is numbered from [expression], and each contains a data value.  

The sum of a tree is the sum of all its nodes' data values.  If she cuts an edge in her tree, she forms two smaller trees.  The difference between two trees is the absolute value between their sums.  

Given a tree, determine which edge to cut so that the resulting trees have a minimal difference between them, then return that difference.  

For example, your tree's nodes have weights of [expression].  



The values are calculated as follows:  

Edge    Tree 1  Tree 2  Absolute
Cut     Sum      Sum     Difference
1        8         13         5
2        9         12         3
3        6         15         9
4        4         17        13
5        5         16        11


The minimum absolute difference is [expression].

Note: The tree is always rooted at vertex [expression].  

Function Description  

Complete the cutTheTree function in the editor below.  Return an integer that represents the minimal absolute difference achievable between the resultant two trees.  

cutTheTree has the following parameter(s):  


data: an array of integers that represent node values  
edges: an 2 dimensional array of integer pairs where each pair represents an edge in the graph  

----------
TOP SOLUTION:
----------
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;limits&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
using namespace std;
 
#define pairii pair&lt;int, int&gt;
#define llong long long
#define pb push_back
#define sortall(x) sort((x).begin(), (x).end())
#define INFI  numeric_limits&lt;int&gt;::max()
#define INFLL numeric_limits&lt;llong&gt;::max()
#define INFD  numeric_limits&lt;double&gt;::max()
#define FOR(i,s,n) for (int (i) = (s); (i) &lt; (n); (i)++)
#define FORZ(i,n) FOR((i),0,(n))

const int MAXN = 100005;
int w[MAXN];
vector&lt;int&gt; adj[MAXN];
set&lt;int&gt; v;
int n, res, total;

struct Node {
    Node() {
        pr = NULL;
        w = 0;
    }
    Node* pr;
    vector&lt;Node*&gt; cl;
    int w;
    int idx;
};

Node* root;

void build(Node* nd) {
    int idx = nd-&gt;idx;
    v.insert(idx);
    nd-&gt;w += w[idx];
    for (int x:adj[idx]) {
        if (v.find(x) == v.end()) {
            Node* u = new Node;
            u-&gt;pr = nd;
            u-&gt;idx = x;
            nd-&gt;cl.pb(u);
            build(u);
            nd-&gt;w += u-&gt;w;
        }
    }
}

void dfs(Node* nd) {
    int idx = nd-&gt;idx;
    if (nd-&gt;pr != NULL) {
        res = min(res, abs(total-2*nd-&gt;w));
    }
    for (Node* u : nd-&gt;cl) {
        dfs(u);
    }
}

void solve() {
    scanf("%d", &amp;n);
    FORZ(i,n) scanf("%d", w+i);
    FORZ(i,n-1) {
        int a,b;
        scanf("%d %d", &amp;a, &amp;b);
        a--; b--;
        adj[a].pb(b);
        adj[b].pb(a);
    }
    root = new Node;
    root-&gt;idx = 0;
    build(root);
    total = root-&gt;w;
    res = INFI;
    dfs(root);
    printf("%d\n", res);
}
 
int main() {
#ifdef DEBUG
    freopen("in.txt", "r", stdin);
    //freopen("out.txt", "w", stdout);
#endif
    solve();
    return 0;
}
----------
====================
----------
ALGORITHMS.154
hard
----------
PROBLEM STATEMENT:
Karl loves playing games on social networking sites. His current favorite is CandyMaker, where the goal is to make candies. 

Karl just started a level in which he must accumulate [expression] units, and there is no limit to the number of machines he can own or workers he can employ.

Karl wants to minimize the number of passes to obtain the required number of candies at the end of a day. Determine that number of passes.

For example, Karl starts with [expression] candies.  He executes the following strategy:  


Make [expression] candies.  Purchase two machines.  
Make [expression] workers.  
Make [expression] candies.  
Make [expression] candies.


It took [expression] passes to make enough candies.  

Function Description

Complete the minimumPasses function in the editor below.  The function must return a long integer representing the minimum number of passes required.

minimumPasses has the following parameter(s):


m: long integer, the starting number of machines  
w: long integer, the starting number of workers  
p: long integer, the cost of a new hire or a new machine  
n: long integer, the number of candies to produce  

----------
TOP SOLUTION:
----------
SOLUTION NOT FOUND
----------
====================
----------
ALGORITHMS.155
medium
----------
PROBLEM STATEMENT:
The Tower of Hanoi is a famous game consisting of [expression] rods and a number of discs of incrementally different diameters. The puzzle starts with the discs neatly stacked on one rod, ordered by ascending size with the smallest disc at the top. The game's objective is to move the entire stack to another rod, obeying the following rules:


Only one disc can be moved at a time.
Each move consists of taking the topmost disc from a stack and moving it to the top of another stack.
No disc may be placed on top of a smaller disc.




Gena has a modified version of the Tower of Hanoi. His Hanoi has [expression] discs ordered by ascending size. He made a few moves (following the rules above), but stopped and lost his place. He wants to restore the tower to its original state by making valid moves. Given the state of Gena's Hanoi, help him calculate the minimum number of moves needed to restore the tower to its original state.

Note: Gena's rods are numbered from [expression].
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

#define sz(x) ((int) (x).size())
#define forn(i,n) for (int i = 0; i &lt; int(n); ++i)
#define forab(i,a,b) for (int i = int(a); i &lt; int(b); ++i)

typedef long long ll;
typedef long long i64;
typedef long double ld;

const int inf = int(1e9) + int(1e5);
const ll infl = ll(2e18) + ll(1e10);

int d[1 &lt;&lt; 20];

int main() {
    cout.precision(10);
    cout.setf(ios::fixed);
    #ifdef LOCAL
    assert(freopen("c.in", "r", stdin));
    #else
    #endif
    int n;
    cin &gt;&gt; n;
    int mask = 0;
    forn (i, n) {
        int k;
        cin &gt;&gt; k;
        mask |= ((k - 1) &lt;&lt; (2 * i));
    }
    forn (i, 1 &lt;&lt; 20)
        d[i] = inf;
    d[mask] = 0;
    queue&lt;int&gt; o;
    o.push(mask);
    while (!o.empty()) {
        int mask = o.front();
        o.pop();
        if (mask == 0)
            break;
        vector&lt;int&gt; b[4];
        forn (i, n)
            b[(mask &gt;&gt; (2 * i)) &amp; 3].push_back(i);
        forn (i, 4)
            b[i].push_back(inf);
        forn (i, 4)
            forn (j, 4) {
                if (b[i].front() &gt;= b[j].front())
                    continue;
                int id = b[i].front();
                int to = mask ^ ((i ^ j) &lt;&lt; (2 * id));
                if (d[to] &lt; inf)
                    continue;
                d[to] = d[mask] + 1;
                o.push(to);
            }
    }
    cout &lt;&lt; d[0] &lt;&lt; '\n';
    #ifdef LOCAL
    cerr &lt;&lt; "Time: " &lt;&lt; double(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n';
    #endif
}

----------
====================
----------
ALGORITHMS.156
medium
----------
PROBLEM STATEMENT:
We call an quadruple of positive integers, [expression], beautiful if the following condition is true:

[expression]

Note: [expression] is the bitwise XOR operator.

Given [expression] where the following constraints hold:


[expression]
[expression]
[expression]
[expression]


When you count the number of beautiful quadruples, you should consider two quadruples as same if the following are true:


They contain same integers.
Number of times each integers occur in the quadruple is same.


For example [expression] should be considered as same.
----------
TOP SOLUTION:
----------

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class D {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	void solve()
	{
		int[] t = na(4);
		Arrays.sort(t);
		long[] dp = new long[3001];
		dp[1] = 1;
		for(int u = 0;u &lt; 4;u++){
			for(int i = 1;i &lt;= t[u];i++){
				dp[i] += dp[i-1];
			}
		}
		long all = Arrays.stream(dp).sum();
		
		int[][] ab = new int[1&lt;&lt;12][3001];
		for(int i = 1;i &lt;= t[0];i++){
			for(int j = i;j &lt;= t[1];j++){
				ab[i^j][j]++;
			}
		}
		
		int[] abc = new int[1&lt;&lt;12];
		for(int k = 1;k &lt;= t[2];k++){
			for(int u = 0;u &lt; 1&lt;&lt;12;u++){
				abc[u] += ab[u][k];
			}
			for(int l = k;l &lt;= t[3];l++){
				all -= abc[k^l];
			}
		}
		out.println(all);
	}
	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new D().run(); }
	
	private byte[] inbuf = new byte[1024];
	private int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.157
medium
----------
PROBLEM STATEMENT:
In ordinary chess, the pieces are only of two colors, black and white. In our version of chess, we are including new pieces with unique movements. One of the most powerful pieces in this version is the red knight.  

The red knight can move to six different positions based on its current position (UpperLeft, UpperRight, Right, LowerRight, LowerLeft, Left) as shown in the figure below. 



The board is a grid of size [expression] is the bottom-right corner. 

Complete the function printShortestPath, which takes as input the grid size [expression] respectively, as input. The function does not return anything.     

Given the coordinates of the starting position of the red knight and the coordinates of the destination, print the minimum number of moves that the red knight has to make in order to reach the destination and after that, print the order of the moves that must be followed to reach the destination in the shortest way. If the destination cannot be reached, print only the word "Impossible". 

Note: There may be multiple shortest paths leading to the destination. Hence, assume that the red knight considers its possible neighbor locations in the following order of priority: UL, UR, R, LR, LL, L. In other words, if there are multiple possible options, the red knight prioritizes the first move in this list, as long as the shortest path is still achievable. Check sample input [expression] for an illustration.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

#ifndef LOCAL
#define cerr dolor_sit_amet
#endif

#define mp make_pair
#define sz(x) ((int)((x).size()))
#define X first
#define Y second
#define ALL(x) (x).begin(), (x).end()

using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair &lt; int , int &gt; ipair;
typedef pair &lt; ll , ll &gt; lpair;
const int IINF = 0x3f3f3f3f;
const ll LINF = 0x3f3f3f3f3f3f3f3fll;
const double DINF = numeric_limits&lt;double&gt;::infinity();
const int MOD = 1000000007;
const double EPS = 1e-9;
const double PI = acos(-1.0);
ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
ll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }
double sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }
mt19937 mmtw(960172);
ll rnd(ll x, ll y) { static uniform_int_distribution&lt;ll&gt; d; return d(mmtw) % (y - x + 1) + x; }

// ========================================================================= //

const int DX[] = {2, 2, 0, -2, -2, 0};
const int DY[] = {-1, 1, 2, 1, -1, -2};
const string DS[] = {"LL", "LR", "R", "UR", "UL", "L"};
const int order[] = {4, 3, 2, 1, 0, 5};

const int N = 222;

int d[N][N], dp[N][N];

int main() {
    ios::sync_with_stdio(false);

    int n;
    int x1, y1, x2, y2;

    cin &gt;&gt; n &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;
    memset(d, 0x3f, sizeof(d));
    d[x1][y1] = 0;
    vector&lt;ipair&gt; q = {{x1, y1}};
    for (int i = 0; i &lt; sz(q); ++i) {
        int x = q[i].X, y = q[i].Y;
        for (int j : order) {
            int nx = x + DX[j];
            int ny = y + DY[j];
            if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n &amp;&amp; d[nx][ny] == IINF) {
                d[nx][ny] = d[x][y] + 1;
                dp[nx][ny] = j;
                q.push_back({nx, ny});
            }
        }
    }

    if (d[x2][y2] == IINF)
        cout &lt;&lt; "Impossible\n";
    else {
        vector&lt;string&gt; ss;
        while (x2 != x1 || y2 != y1) {
            int j = dp[x2][y2];
            ss.push_back(DS[j]);
            x2 -= DX[j];
            y2 -= DY[j];
        }
        reverse(ALL(ss));
        cout &lt;&lt; sz(ss) &lt;&lt; "\n";
        for (auto x : ss)
            cout &lt;&lt; x &lt;&lt; " ";
        cout &lt;&lt; "\n";
    }

    return 0;
}

----------
====================
----------
ALGORITHMS.158
hard
----------
PROBLEM STATEMENT:
There are [expression] bikes are acquired in the minimum time.

Every biker moves with a unit speed and one bike can be acquired by only one biker. A biker can proceed in any direction. Consider distance between bikes and bikers as Euclidean distance.

Jack would like to know the square of required time to start the race as soon as possible. 
----------
TOP SOLUTION:
----------
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;ctime&gt;
#include&lt;cmath&gt;
using namespace std;
int i,j,n,m,k,x[259],y[259],a[259],b[259],C[259],urm[259],pre[259];
long long p,u,mij,ras,D[259][259];
vector &lt; int &gt; v[259];
int mod(int x)
{
    if(x&lt;0) return -x;
    return x;
}
int cup(int nod)
{
    if(C[nod]==1) return 0;
    C[nod]=1;
    vector &lt; int &gt; :: iterator it;
    for(it=v[nod].begin();it!=v[nod].end();it++)
        if(pre[*it]==0)
        {
            pre[*it]=nod;
            urm[nod]=*it;
            return 1;
        }
    for(it=v[nod].begin();it!=v[nod].end();it++)
        if(cup(pre[*it]))
        {
            pre[*it]=nod;
            urm[nod]=*it;
            return 1;
        }
    return 0;
}
int cuplaj()
{
    int ok=1;
    for(i=1;i&lt;=n;i++)
        C[i]=urm[i]=0;
    for(j=1;j&lt;=m;j++)
        pre[j]=0;
    while(ok)
    {
        ok=0;
        for(i=1;i&lt;=n;i++)
            C[i]=0;
        for(i=1;i&lt;=n;i++)
            if(urm[i]==0) ok+=cup(i);
    }
    ok=0;
    for(i=1;i&lt;=n;i++)
        ok+=(urm[i]&gt;0);
    return ok;
}
bool ok(long long dstmx)
{
    int i;
    for(i=1;i&lt;=n;i++)
        v[i].clear();
    for(i=1;i&lt;=n;i++)
        for(j=1;j&lt;=m;j++)
            if(D[i][j]&lt;=dstmx) v[i].push_back(j);
    return (cuplaj()&gt;=k);
}
int main()
{
//freopen("input","r",stdin);
//freopen("output","w",stdout);
scanf("%d",&amp;n);
scanf("%d",&amp;m);
scanf("%d",&amp;k);
for(i=1;i&lt;=n;i++)
{
    scanf("%d",&amp;x[i]);
    scanf("%d",&amp;y[i]);
}
for(i=1;i&lt;=m;i++)
{
    scanf("%d",&amp;a[i]);
    scanf("%d",&amp;b[i]);
}
for(i=1;i&lt;=n;i++)
    for(j=1;j&lt;=m;j++)
        D[i][j]=1LL*(a[j]-x[i])*(a[j]-x[i])+1LL*(b[j]-y[i])*(b[j]-y[i]);
p=0;
u=10000000000000000;
while(p&lt;=u)
{
    mij=(p+u)/2;
    if(ok(mij))
    {
        ras=mij;
        u=mij-1;
    }
    else p=mij+1;
}
printf("%lld\n",ras);
return 0;
}

----------
====================
----------
ALGORITHMS.159
advanced
----------
PROBLEM STATEMENT:
You have a long list of tasks that you need to do today. To accomplish task [expression]. You need not complete a task at a stretch. You can complete a part of it, switch to another task, and then switch back.

You've realized that it might not be possible to complete all the tasks by their deadline. So you decide to do them in such a manner that the maximum amount by which a task's completion time overshoots its deadline is minimized.
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */

#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define NMAX 300000
#define NN 100000
#define INF 1000000000LL
using namespace std;

typedef long long LL;

struct N{//data to store in tree
        LL each,maxsub; //operation load.log update.,subtree statistic(calculate sub tree status in every update)
        N(){
                each = 0;
                maxsub = -INF;
        }
};

N st[NMAX];

void update2(int ni,int s,int e,int ps,int pe,LL v){
        if(ps &gt; pe)return;
        if(pe &lt; s || ps &gt; e)return;
        else if(ps &lt;= s &amp;&amp; pe &gt;= e){//update all
                st[ni].each += v;
        }
        else{
                int mid = (s+e)/2;
                update2(ni*2+1,s,mid,ps,min(mid,pe),v);
                update2(ni*2+2,mid+1,e,max(mid+1,ps),pe,v);
                LL sub1 = st[ni*2+1].each;
                LL sub2 = st[ni*2+2].each;
                if(mid&gt;s)sub1 += st[ni*2+1].maxsub;
                if(mid+1&lt;e)sub2 += st[ni*2+2].maxsub;
                st[ni].maxsub = max(sub1,sub2);
        }
}

LL query2(int ni,int s,int e,int ps,int pe){
        if(ps &gt; pe)return -INF;
        if(pe &lt; s || ps &gt; e)return -INF;
        else if(ps &lt;= s &amp;&amp; pe &gt;= e){//get all segment
                if(s==e)return st[ni].each;
                else return st[ni].maxsub + st[ni].each;
        }
        else{
                int mid = (s+e)/2;
                return  max(query2(2*ni+1,s,mid,ps,min(pe,mid)),query2(2*ni+2,mid+1,e,max(ps,mid+1),pe))+st[ni].each;
        }
}



int main(){
        for(LL i=0;i&lt;=NN;i++){
                update2(0,0,NN,i,i,-i);
        }
        int nn;scanf("%d",&amp;nn);
        for(int i=0;i&lt;nn;i++){
                int a,b;scanf("%d%d",&amp;a,&amp;b);
                update2(0,0,NN,a,NN,b);
                LL ret = max(0LL,query2(0,0,NN,0,NN));
                printf("%lld\n",ret);
        }
        return 0;
}

----------
====================
----------
ALGORITHMS.160
advanced
----------
PROBLEM STATEMENT:
A pair of nodes, [expression], is a similar pair if the following conditions are true:


node [expression]
[expression]


Given a tree where each node is labeled from [expression], find the number of similar pairs in the tree.

For example, given the following tree:  

  

We have the following pairs of ancestors and dependents:  

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



If [expression].

Function Description

Complete the similarPair function in the editor below.  It should return an integer that represents the number of pairs meeting the criteria.

similarPair has the following parameter(s):  


n: an integer that represents the number of nodes  
k: an integer
edges: a two dimensional array where each element consists of two integers that represent connected node numbers  

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int n, aib[200005];

inline int lsb(int &amp; x){
    return x &amp; -x;
}

void update(int val, int pos){
    for(int i = pos; i &lt;= n * 2; i += lsb(i))
        aib[i] += val;
}

int query(int pos){
    int rval = 0;
    for(int i = pos; i &gt; 0; i -= lsb(i))
        rval += aib[i];
    return rval;
}

vector&lt;int&gt; graph[100005];
int t, dad[100005];
long long ans;

void dfs(int x){
    ans += (long long)query(x + t) - query(x - t - 1);
    update(1, x);
    for(int i = 0; i &lt; graph[x].size(); ++i)
        dfs(graph[x][i]);
    update(-1, x);
}

int main() {
    cin &gt;&gt; n &gt;&gt; t;
    for(int i = 1; i &lt; n; ++i){
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        dad[y] = x;
        graph[x].push_back(y);
    }
    for(int i = 1; i &lt;= n; ++i)
        if(!dad[i])
            dfs(i);
    cout &lt;&lt; ans;
    return 0;
}

----------
====================
----------
ALGORITHMS.161
hard
----------
PROBLEM STATEMENT:
Given an array of integers, you must answer a number of queries. Each query consists of a single integer, [expression], and is performed as follows:


Add [expression] to each element of the array, permanently modifying it for any future queries.
Find the absolute value of each element in the array and print the sum of the absolute values on a new line.


Tip: The Input/Output for this challenge is very large, so you'll have to be creative in your approach to pass all test cases.

Function Description  

Complete the playingWithNumbers function in the editor below.  It should return an array of integers that represent the responses to each query.  

playingWithNumbers has the following parameter(s):  


arr: an array of integers  
queries: an array of integers  

----------
TOP SOLUTION:
----------
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;limits&gt;
#include &lt;functional&gt;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus &gt; 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector&lt;int&gt; vi; typedef pair&lt;int,int&gt; pii; typedef vector&lt;pair&lt;int,int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; inline void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; inline void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

int main() {
	int N;
	scanf("%d", &amp;N);
	vector&lt;long long&gt; A(N);
	rep(i, N) scanf("%lld", &amp;A[i]);
	sort(all(A));
	vector&lt;long long&gt; sum(N+1, 0);
	rep(i, N)
		sum[i+1] = sum[i] + A[i];
	int Q;
	scanf("%d", &amp;Q);
	long long added = 0;
	rep(ii, Q) {
		int x;
		scanf("%d", &amp;x);
		added += x;
		//A[i] + added &gt;= 0
		//A[i] &gt;= -added
		int k = lower_bound(all(A), -added) - A.begin();
		long long ans = 0;
		ans += (sum[N] - sum[k]) + added * (N - k);
		ans += -((sum[k] - sum[0]) + added * k);
		printf("%lld\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.162
expert
----------
PROBLEM STATEMENT:
Victor is building a Japanese rock garden in his [expression] stones in the garden according to the following rules:


The center of each stone is located at some point [expression]. 
The coordinates of all twelve stones are pairwise distinct. 
The Euclidean distance from the center of any stone to the origin is not an integer. 
The sum of Euclidean distances between all twelve points and the origin is an almost integer, meaning the absolute difference between this sum and an integer must be [expression].


Given the values of [expression] coordinates of the stone's location.
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

	static class P {
		int x;
		int y;
		double d;
		int c;
	}
	
	static P[] ps;
	
	static int getPIndex(int x, int y) {
		if(y &gt; x) {
			int c = x;
			x = y;
			y = c;
		}
		for (int i = 0; i &lt; ps.length; i++) {
			if(ps[i].x == x &amp;&amp; ps[i].y == y) return i;
		}
		return -1;
	}
	
	static class F implements Comparable&lt;F&gt;{
		int[] pi = new int[4];
		double d;

		@Override
		public int compareTo(F o) {
			return d &lt; o.d ? -1 : d &gt; o.d ? 1 : 0;
		}
	}
	
	static F[] fs;
	
	static int getFIndex(double d) {
		int c0 = (int)(d * fs.length);
		int a = c0 &lt; 30000 ? 0 : c0 - 30000;
		while(fs[a].d &gt; d) {
			a -= 30000;
			if(a &lt; 0) {
				a = 0;
				break;
			}
		}
		int b = c0 + 30000 &gt;= fs.length - 1 ? fs.length - 1 : c0 + 30000;
		while(fs[b].d &lt; d) {
			b += 30000;
			if(b &gt;= fs.length - 1) {
				b = fs.length - 1;
				break;
			}
		}
//		if(fs[a].d &gt; d || fs[b].d &lt; d) throw new RuntimeException();
		while(b - a &gt; 1) {
			int c = (a + b) / 2;
			if(d &gt; fs[c].d) {
				a = c;
			} else {
				b = c;
			}
		}
		return Math.abs(d - fs[a].d) &lt; Math.abs(d - fs[b].d) ? a : b;
	}
	
	static void buildP() {
		List&lt;P&gt; list = new ArrayList&lt;&gt;();
		for (int x = 1; x &lt;= 12; x++) {
			for (int y = 1; y &lt;= x; y++) {
				int d2 = x * x + y * y;
				double d = Math.sqrt(d2);
				int di = (int)Math.round(d);
				if(di * di == d2) continue;
				int c = x == y ? 4 : 8;
				P p = new P();
				p.x = x;
				p.y = y;
				p.d = d - Math.floor(d);
				p.c = c;
				list.add(p);
			}
		}
		ps = list.toArray(new P[list.size()]);
//		for (P p: ps) {
//			System.out.println(p.x + " " + p.y + " " + p.d + " " + p.c);
//		}
//		System.out.println(ps.length);
	}
	
	static void buildF() {
		int size = 74 * 75 * 76 * 77 / 24;
		fs = new F[size];
		int k = 0;
		for (int i1 = 0; i1 &lt; ps.length; i1++) {
			for (int i2 = i1; i2 &lt; ps.length; i2++) {
				for (int i3 = i2; i3 &lt; ps.length; i3++) {
					for (int i4 = i3; i4 &lt; ps.length; i4++) {
						F f = new F();
						f.pi = new int[]{i1,i2,i3,i4};
						f.d = ps[i1].d + ps[i2].d + ps[i3].d + ps[i4].d;
						f.d = f.d - Math.floor(f.d);
						fs[k] = f;
						k++;
					}
				}
			}
		}
		Arrays.sort(fs);
	}

	static Random seed = new Random();

	static class Result {
		int[] result = new int[12];
		double d12 = 0;
		
		Result(int i0) {
			result[0] = i0;
		}
		
		boolean flip() {
			int k = seed.nextInt(7) + 1;
			int ik = seed.nextInt(74);
			result[k] = ik;
			d12 = 0;
			for (k = 0; k &lt; 8; k++) {
				d12 += ps[result[k]].d;
			}
			d12 = d12 - Math.floor(d12);
			double add = 1 - d12;
			int fi = getFIndex(add);
			double d12r = d12 + fs[fi].d;
			d12r = d12r - Math.floor(d12r);
			if(d12r &gt; 0.000000000001 &amp;&amp; 1 - d12r &gt; 0.000000000001) {
				return false;
			}
			for (k = 0; k &lt; 4; k++) {
				result[k + 8] = fs[fi].pi[k];
			}
			d12 = d12r;
//			System.out.println(d12);
			return true;
		}
	}
	
	static boolean checkResult(int[] result) {
		int[] dist = new int[ps.length];
		for (int i = 0; i &lt; result.length; i++) {
			if(i &gt; 0 &amp;&amp; result[i] == result[0]) return false; //for simplicity
			dist[result[i]]++;
			if(dist[result[i]] &gt; 4) return false;
		}
		return true;
	}
	
	static void presentResult(int[] result, int x0, int y0) {
		int[] dist = new int[ps.length];
		dist[result[0]]++;
		double d = ps[result[0]].d;
		for (int i = 1; i &lt; result.length; i++) {
			int k = result[i];
			dist[k]++;
			int c = dist[k];
				int x = ps[k].x, y = ps[k].y;
				int d2 = x * x + y * y;
				d += Math.sqrt(d2);
			if(c == 1) {
				System.out.println(ps[k].x + " " + ps[k].y);
			} else if(c == 2) {
				System.out.println((-ps[k].x) + " " + ps[k].y);
			} else if(c == 3) {
				System.out.println(ps[k].x + " " + (-ps[k].y));
			} else if(c == 4) {
				System.out.println((-ps[k].x) + " " + (-ps[k].y));
			}
		}
//		System.out.println("d=" + d);
	}
	
	public static void solve(int x, int y) {
		int xc = Math.abs(x), yc = Math.abs(y);
		int i0 = getPIndex(xc, yc);
		Result r = new Result(i0);
		while(true) {
			if(r.flip()) {
				int[] result = r.result;
				if(result == null || !checkResult(result)) continue;
				double d = 0;
				System.out.print("{");
				for (int k = 0; k &lt; 12; k++) {
					if(k &gt; 0) System.out.print(", ");
					System.out.print(result[k]);
					d += ps[result[k]].d;
				}
				System.out.println("},");
//				presentResult(result, x, y);
				break;
			}
		}
	}
	
	static void buildCache() {
		buildF();
//		long t = System.currentTimeMillis();
		for (int i = 0; i &lt; ps.length; i++) {
			solve(ps[i].x, ps[i].y);
		}	
//		long dt = System.currentTimeMillis() - t;
//		System.out.println(dt);
	}
	
	static void solveWithCache(int x, int y) {
		int xc = Math.abs(x), yc = Math.abs(y);
		int i0 = getPIndex(xc, yc);
		presentResult(cache[i0], xc, yc);
	}
	
	static void run() {
		buildP();
		Scanner in = new Scanner(System.in);
		int x = in.nextInt();
		int y = in.nextInt();
		solveWithCache(x, y);
	}

	public static void main(String[] args) {
		run();
	}

	//Cache is built in 145 sec which is less than 2 seconds per one case
	static int[][] cache = {
		{0, 8, 40, 44, 24, 39, 3, 39, 4, 9, 18, 68},
		{1, 36, 61, 35, 19, 34, 64, 43, 37, 50, 72, 72},
		{2, 68, 33, 10, 68, 44, 62, 32, 37, 37, 43, 44},
		{3, 55, 20, 39, 1, 17, 9, 47, 17, 18, 24, 44},
		{4, 9, 71, 35, 56, 49, 15, 58, 24, 32, 34, 40},
		{5, 69, 43, 22, 8, 36, 40, 57, 4, 54, 69, 69},
		{6, 28, 37, 67, 50, 3, 37, 13, 37, 56, 64, 67},
		{7, 39, 3, 0, 9, 18, 40, 70, 8, 24, 30, 44},
		{8, 70, 9, 68, 24, 39, 9, 55, 0, 3, 9, 18},
		{9, 1, 24, 0, 55, 70, 39, 3, 8, 18, 44, 54},
		{10, 43, 37, 5, 37, 68, 32, 44, 26, 44, 62, 68},
		{11, 51, 52, 31, 63, 32, 14, 40, 37, 38, 48, 48},
		{12, 50, 3, 45, 45, 23, 70, 72, 23, 32, 32, 48},
		{13, 68, 39, 17, 18, 4, 9, 24, 3, 4, 44, 55},
		{14, 37, 51, 48, 55, 73, 11, 38, 31, 32, 42, 48},
		{15, 69, 69, 43, 47, 55, 26, 3, 4, 22, 57, 69},
		{16, 3, 44, 9, 1, 70, 24, 13, 7, 18, 39, 55},
		{17, 4, 55, 70, 1, 44, 9, 13, 3, 18, 24, 54},
		{18, 24, 9, 20, 4, 44, 70, 55, 3, 16, 16, 17},
		{19, 36, 25, 72, 1, 37, 34, 72, 41, 43, 50, 61},
		{20, 50, 36, 56, 15, 15, 15, 64, 37, 37, 37, 66},
		{21, 71, 71, 64, 30, 42, 27, 56, 28, 58, 60, 71},
		{22, 1, 4, 43, 69, 26, 36, 69, 30, 55, 57, 69},
		{23, 48, 29, 70, 47, 36, 27, 46, 8, 10, 24, 65},
		{24, 9, 68, 39, 70, 9, 40, 3, 0, 8, 9, 18},
		{25, 55, 71, 15, 56, 49, 32, 58, 4, 9, 24, 34},
		{26, 22, 47, 69, 40, 69, 69, 4, 3, 15, 43, 57},
		{27, 8, 29, 54, 48, 24, 65, 10, 23, 36, 46, 70},
		{28, 60, 23, 30, 58, 56, 64, 21, 42, 71, 71, 71},
		{29, 68, 50, 45, 68, 57, 30, 70, 23, 48, 60, 60},
		{30, 44, 3, 17, 39, 9, 13, 24, 7, 17, 18, 55},
		{31, 42, 14, 48, 48, 73, 38, 40, 11, 32, 37, 51},
		{32, 4, 35, 15, 58, 9, 40, 24, 34, 49, 56, 71},
		{33, 21, 72, 21, 49, 48, 53, 61, 35, 36, 37, 65},
		{34, 40, 32, 58, 71, 4, 56, 49, 9, 15, 24, 25},
		{35, 4, 55, 15, 34, 58, 9, 32, 24, 49, 56, 71},
		{36, 15, 37, 37, 67, 2, 50, 64, 5, 37, 56, 66},
		{37, 31, 14, 38, 42, 55, 48, 32, 11, 48, 51, 73},
		{38, 48, 11, 32, 55, 31, 42, 51, 14, 37, 48, 73},
		{39, 70, 2, 44, 16, 18, 16, 3, 5, 9, 24, 55},
		{40, 39, 24, 44, 8, 9, 3, 68, 0, 4, 18, 39},
		{41, 37, 1, 61, 19, 50, 43, 72, 25, 34, 36, 72},
		{42, 38, 37, 11, 31, 14, 48, 32, 48, 51, 55, 73},
		{43, 36, 57, 69, 19, 47, 69, 4, 0, 22, 55, 69},
		{44, 24, 17, 17, 30, 55, 39, 18, 3, 7, 9, 20},
		{45, 60, 70, 27, 60, 47, 29, 54, 48, 50, 57, 68},
		{46, 47, 10, 65, 29, 23, 27, 70, 8, 24, 36, 48},
		{47, 9, 17, 3, 17, 24, 18, 55, 1, 20, 39, 44},
		{48, 72, 51, 9, 54, 56, 71, 34, 19, 22, 50, 59},
		{49, 24, 71, 4, 15, 32, 35, 56, 9, 34, 40, 58},
		{50, 5, 36, 41, 36, 66, 2, 56, 36, 37, 37, 37},
		{51, 52, 14, 48, 55, 48, 38, 32, 11, 31, 37, 63},
		{52, 31, 37, 48, 63, 40, 32, 11, 14, 38, 48, 51},
		{53, 3, 46, 71, 45, 70, 69, 55, 0, 11, 30, 34},
		{54, 52, 68, 32, 10, 37, 37, 62, 1, 43, 44, 44},
		{55, 9, 30, 7, 20, 70, 4, 44, 3, 17, 18, 24},
		{56, 67, 37, 13, 3, 36, 64, 50, 3, 37, 37, 66},
		{57, 5, 55, 22, 43, 4, 47, 8, 36, 69, 69, 69},
		{58, 71, 34, 15, 40, 35, 4, 49, 9, 24, 32, 56},
		{59, 71, 9, 72, 56, 19, 51, 50, 22, 34, 48, 54},
		{60, 71, 56, 42, 28, 23, 30, 41, 21, 58, 71, 71},
		{61, 41, 43, 25, 34, 36, 72, 19, 1, 37, 50, 72},
		{62, 22, 31, 31, 31, 24, 38, 39, 18, 40, 49, 57},
		{63, 51, 14, 37, 11, 48, 38, 31, 32, 48, 52, 55},
		{64, 37, 0, 67, 37, 15, 56, 37, 8, 36, 50, 66},
		{65, 23, 70, 8, 24, 27, 10, 46, 29, 36, 47, 48},
		{66, 56, 67, 50, 67, 0, 37, 37, 3, 8, 37, 64},
		{67, 64, 12, 56, 12, 66, 15, 37, 20, 36, 37, 37},
		{68, 30, 62, 32, 7, 44, 52, 37, 10, 37, 43, 44},
		{69, 11, 53, 71, 0, 3, 45, 55, 30, 34, 46, 70},
		{70, 40, 1, 9, 24, 18, 5, 44, 2, 3, 39, 54},
		{71, 22, 9, 47, 19, 59, 34, 48, 50, 51, 56, 72},
		{72, 56, 22, 71, 51, 50, 34, 59, 9, 19, 48, 54},
		{73, 31, 11, 51, 38, 42, 14, 37, 32, 48, 48, 55}		
	};
}

----------
====================
----------
ALGORITHMS.163
hard
----------
PROBLEM STATEMENT:
Consider an array [expression]:


Sort all the elements in the subsegment [expression].


Given [expression] queries?
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; static void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; static void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

typedef char Val;
struct Sum {
	int cnt;
	Sum() : cnt(0) {}
	Sum(const Val &amp;val, int pos) : cnt(val) {}
	Sum &amp;operator+=(const Sum &amp;that) { cnt += that.cnt; return *this; }
	Sum operator+(const Sum &amp;that) const { return Sum(*this) += that; }
};
struct Add {
	int assign;
	Add() : assign(-1) {}
	explicit Add(int a) : assign(a) {}
	Add &amp;operator+=(const Add &amp;that) {
		if(that.assign != -1)
			assign = that.assign;
		return *this;
	}
	void addToVal(Val &amp;val, int pos) const {
		if(assign != -1)
			val = assign != 0;
	}
	void addToSum(Sum &amp;sum, int left, int right) const {
		if(assign != -1)
			sum.cnt = assign != 0 ? right - left : 0;
	}
};

struct SegmentTree {
	vector&lt;Val&gt; leafs;
	vector&lt;Sum&gt; nodes;
	vector&lt;Add&gt; add;
	vector&lt;int&gt; leftpos, rightpos;
	int n, n2;
	void init(int n_, const Val &amp;v = Val()) { init(vector&lt;Val&gt;(n_, v)); }
	void init(const vector&lt;Val&gt; &amp;u) {
		n = 1; while(n &lt; (int)u.size()) n *= 2;
		n2 = (n - 1) / 2 + 1;
		leafs = u; leafs.resize(n, Val());
		nodes.resize(n);
		for(int i = n - 1; i &gt;= n2; -- i)
			nodes[i] = Sum(leafs[i * 2 - n], i * 2 - n) + Sum(leafs[i * 2 + 1 - n], i * 2 + 1 - n);
		for(int i = n2 - 1; i &gt; 0; -- i)
			nodes[i] = nodes[i * 2] + nodes[i * 2 + 1];
		add.assign(n, Add());

		leftpos.resize(n); rightpos.resize(n);
		for(int i = n - 1; i &gt;= n2; -- i) {
			leftpos[i] = i * 2 - n;
			rightpos[i] = (i * 2 + 1 - n) + 1;
		}
		for(int i = n2 - 1; i &gt; 0; -- i) {
			leftpos[i] = leftpos[i * 2];
			rightpos[i] = rightpos[i * 2 + 1];
		}
	}
	Val get(int i) {
		int indices[128];
		int k = getIndices(indices, i, i + 1);
		propagateRange(indices, k);
		return leafs[i];
	}
	Sum getRangeCommutative(int i, int j) {
		int indices[128];
		int k = getIndices(indices, i, j);
		propagateRange(indices, k);
		Sum res = Sum();
		for(int l = i + n, r = j + n; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
			if(l &amp; 1) res += sum(l ++);
			if(r &amp; 1) res += sum(-- r);
		}
		return res;
	}
	Sum getRange(int i, int j) {
		int indices[128];
		int k = getIndices(indices, i, j);
		propagateRange(indices, k);
		Sum res = Sum();
		for(; i &amp;&amp; i + (i&amp;-i) &lt;= j; i += i&amp;-i)
			res += sum((n + i) / (i&amp;-i));
		for(k = 0; i &lt; j; j -= j&amp;-j)
			indices[k ++] = (n + j) / (j&amp;-j) - 1;
		while(-- k &gt;= 0) res += sum(indices[k]);
		return res;
	}
	void set(int i, const Val &amp;x) {
		int indices[128];
		int k = getIndices(indices, i, i + 1);
		propagateRange(indices, k);
		leafs[i] = x;
		mergeRange(indices, k);
	}
	void addToRange(int i, int j, const Add &amp;x) {
		if(i &gt;= j) return;
		int indices[128];
		int k = getIndices(indices, i, j);
		propagateRange(indices, k);
		int l = i + n, r = j + n;
		if(l &amp; 1) { int p = (l ++) - n; x.addToVal(leafs[p], p); }
		if(r &amp; 1) { int p = (-- r) - n; x.addToVal(leafs[p], p); }
		for(l &gt;&gt;= 1, r &gt;&gt;= 1; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
			if(l &amp; 1) add[l ++] += x;
			if(r &amp; 1) add[-- r] += x;
		}
		mergeRange(indices, k);
	}
private:
	int getIndices(int indices[], int i, int j) const {
		int k = 0, l, r;
		if(i &gt;= j) return 0;
		for(l = (n + i) &gt;&gt; 1, r = (n + j - 1) &gt;&gt; 1; l != r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
			indices[k ++] = l;
			indices[k ++] = r;
		}
		for(; l; l &gt;&gt;= 1) indices[k ++] = l;
		return k;
	}
	void propagateRange(int indices[], int k) {
		for(int i = k - 1; i &gt;= 0; -- i)
			propagate(indices[i]);
	}
	void mergeRange(int indices[], int k) {
		for(int i = 0; i &lt; k; ++ i)
			merge(indices[i]);
	}
	inline void propagate(int i) {
		if(i &gt;= n) return;
		add[i].addToSum(nodes[i], leftpos[i], rightpos[i]);
		if(i * 2 &lt; n) {
			add[i * 2] += add[i];
			add[i * 2 + 1] += add[i];
		} else {
			add[i].addToVal(leafs[i * 2 - n], i * 2 - n);
			add[i].addToVal(leafs[i * 2 + 1 - n], i * 2 + 1 - n);
		}
		add[i] = Add();
	}
	inline void merge(int i) {
		if(i &gt;= n) return;
		nodes[i] = sum(i * 2) + sum(i * 2 + 1);
	}
	inline Sum sum(int i) {
		propagate(i);
		return i &lt; n ? nodes[i] : Sum(leafs[i - n], i - n);
	}
};

int main() {
	int n; int q; int k;
	while(~scanf("%d%d%d", &amp;n, &amp;q, &amp;k)) {
		vector&lt;int&gt; A(n);
		for(int i = 0; i &lt; n; ++ i)
			scanf("%d", &amp;A[i]);
		vector&lt;int&gt; l(q), r(q);
		for(int i = 0; i &lt; q; ++ i)
			scanf("%d%d", &amp;l[i], &amp;r[i]), ++ r[i];
		vi values = A;
		sort(values.begin(), values.end());
		values.erase(unique(values.begin(), values.end()), values.end());
		int lo = 0, up = (int)values.size() - 1;
		while(up - lo &gt; 0) {
			int mid = (lo + up + 1) / 2;
			vector&lt;Val&gt; initvals(n);
			rep(i, n)
				initvals[i] = values[mid] &lt;= A[i];
			SegmentTree segt; segt.init(initvals);
			rep(i, q) {
				int cnt0 = r[i] - l[i] - segt.getRangeCommutative(l[i], r[i]).cnt;
				segt.addToRange(l[i], l[i] + cnt0, Add(0));
				segt.addToRange(l[i] + cnt0, r[i], Add(1));
			}
			if(segt.get(k))
				lo = mid;
			else
				up = mid - 1;
		}
		printf("%d\n", values[lo]);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.164
expert
----------
PROBLEM STATEMENT:
We take a line segment of length [expression]:



We denote a pair of points, [expression].

Next, let's consider two pairs: [expression]. In other words: 
[expression]

For example, consider the following diagram in which the relationship between points in pairs at non-overlapping indices is shown by a connecting line:



Given [expression], among all pairs of points.
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;fstream&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i &lt; (int)(n); ++i)
#define for1(i, n) for (int i = 1; i &lt;= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i &gt;= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i &lt;= (int)(b); ++i)

using namespace std;

typedef pair&lt;int, int&gt; pii;
typedef vector&lt;int&gt; vi;
typedef vector&lt;pii&gt; vpi;
typedef vector&lt;vi&gt; vvi;
typedef long long i64;
typedef vector&lt;i64&gt; vi64;
typedef vector&lt;vi64&gt; vvi64;

template&lt;class T&gt; bool uin(T &amp;a, T b) { return a &gt; b ? (a = b, true) : false; }
template&lt;class T&gt; bool uax(T &amp;a, T b) { return a &lt; b ? (a = b, true) : false; }

int c, n;

int dist(pii p) {
    int dd = p.se - p.fi;
    uin(dd, c - dd);
    return dd;
}

struct TEvent {
    int x, ly, ry;
    int id, t;

    bool operator&lt;(const TEvent &amp;ev) const {
        if (x != ev.x) return x &lt; ev.x;
        return (t == 0) &lt; (ev.t == 0);
    }
};

void add_rect(int lx, int rx, int ly, int ry, int id, vector&lt;TEvent&gt; &amp;evs) {
    if (lx &gt;= rx || ly &gt;= ry) return;
    evs.pb({lx, ly, ry, id, -1});
    evs.pb({rx, ly, ry, id, 1});
}

const int maxc = 1100000;
int f[maxc];

int fsum(int i) {
    int s = 0;
    for (; i &gt;= 0; i &amp;= i + 1, --i) s += f[i];
    return s;
}

void fadd(int i, int x) {
    for (; i &lt; maxc; i |= i + 1) f[i] += x;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout &lt;&lt; fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    cin &gt;&gt; n &gt;&gt; c;
    vector&lt;pii&gt; p(n);
    forn(i, n) {
        cin &gt;&gt; p[i].fi &gt;&gt; p[i].se;
        if (p[i].fi &gt; p[i].se) swap(p[i].fi, p[i].se);
    }

    int L = 0, R = c;
    while (R - L &gt; 1) {
        int M = (L + R) / 2;
        vector&lt;pii&gt; q;
        for (auto w: p) if (dist(w) &gt;= M) q.pb(w);
        vector&lt;TEvent&gt; evs;
        int K = q.size();
        forn(i, K) {
            evs.pb({q[i].fi, q[i].se, -1, i, 0});
            add_rect(q[i].fi + M, q[i].se - M + 1, 0, q[i].se - M + 1, i, evs);
            add_rect(q[i].fi + M, q[i].se - M + 1, q[i].se + M, c + min(0, q[i].fi - M + 1), i, evs);
            add_rect(q[i].se + M, c, 0, c + min(0, q[i].fi - M + 1), i, evs);
        }
        sort(all(evs));
        forn(i, c) f[i] = 0;
        vi ans(K);
        for (auto w: evs) {
            if (w.t == 0) fadd(w.ly, 1);
            else ans[w.id] += w.t * (fsum(w.ry - 1) - fsum(w.ly - 1));
        }

        bool ok = false;
        forn(i, K) ok |= ans[i] &gt; 0;
        (ok ? L : R) = M;
    }
    cout &lt;&lt; L &lt;&lt; '\n';

#ifdef LOCAL_DEFINE
    cerr &lt;&lt; "Time elapsed: " &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.165
hard
----------
PROBLEM STATEMENT:
King Richard is leading a troop of [expression] square formation, demonstrated below:





Before the battle begins, he wants to test how well his knights follow instructions. He issues [expression] drill commands, where each command follows the format ai bi di and is executed like so:


All knights in the square having the top-left corner at location [expression]. For example:



You must follow the commands sequentially. The square for each command is completely contained within the square for the previous command. Assume all knights follow the commands perfectly.

After performing all [expression] for his first wave of attack; however, because the knights were reordered by the drill commands, he's not sure where his chosen knights are!

As his second-in-command, you must find the locations of the knights. For each knight [expression], print the knight's row and column locations as two space-separated values on a new line.  
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;

int S,N,L;

typedef complex&lt;int&gt; pt;

struct state {
	pt orig;
	pt now;
	int d,idx;

	pt get_at(int x,int y) {
		x-=real(now);
		y-=imag(now);
		int rots=idx%4;
		swap(x,y);
		for(;rots--;) {
			int tmp=x;
			x=y;
			y=d-tmp;
		}
		swap(x,y);
		return pt(real(orig)+x,imag(orig)+y);
	}
	bool has(int x,int y) {
		return x&gt;=real(orig) &amp;&amp; y&gt;=imag(orig) &amp;&amp; x&lt;=real(orig)+d &amp;&amp; y&lt;=imag(orig)+d;
	}

	pt rlook(int x,int y) {
		swap(orig,now);
		idx = 4-(idx%4);
		pt ans=get_at(x,y);
		idx=4-(idx%4);
		swap(orig,now);
		return ans;
	}
};
vector&lt;state&gt; vs;

int main() {
	cin&gt;&gt;N&gt;&gt;S;
	vs.push_back({pt(1,1),pt(1,1),N-1,0});
	for(int i=1;i&lt;=S;i++) {
		int a,b,d; cin&gt;&gt;a&gt;&gt;b&gt;&gt;d;
		pt ul=vs.back().get_at(a,b);
		pt dr=vs.back().get_at(a+d,b+d);
		pt neworig={min(real(ul),real(dr)), min(imag(ul),imag(dr))};
		pt newnow={a,b};
		vs.push_back({neworig,newnow,d,i});
	}

	for(auto &amp;st : vs) {
//		cout&lt;&lt;st.orig&lt;&lt;" "&lt;&lt;st.now&lt;&lt;" "&lt;&lt;st.d&lt;&lt;" "&lt;&lt;st.idx&lt;&lt;endl;
	}

cin&gt;&gt;L;
for(;L--;) {
long long w; cin&gt;&gt;w;
int x=w/N+1;
int y=w%N+1;
int lb=0,rb=S;
for(;lb&lt;rb;) {
int mb=(lb+rb+1)/2;
if(vs[mb].has(x,y)) lb=mb;
else rb=mb-1;
}
pt p=vs[lb].rlook(x,y);
cout&lt;&lt;real(p)&lt;&lt;" "&lt;&lt;imag(p)&lt;&lt;endl;
}


}
----------
====================
----------
ALGORITHMS.166
hard
----------
PROBLEM STATEMENT:
Alef the Frog is in an [expression] two-dimensional maze represented as a table.  The maze has the following characteristics: 


Each cell can be free or can contain an obstacle, an exit, or a mine.
Any two cells in the table considered adjacent if they share a side.  
The maze is surrounded by a solid wall made of obstacles. 
Some pairs of free cells are connected by a bidirectional tunnel. 




When Alef is in any cell, he can randomly and with equal probability choose to move into one of the adjacent cells that don't contain an obstacle in it. If this cell contains a mine, the mine explodes and Alef dies. If this cell contains an exit, then Alef escapes the maze.  

When Alef lands on a cell with an entrance to a tunnel, he is immediately transported through the tunnel and is thrown into the cell at the other end of the tunnel. Thereafter, he won't fall again, and will now randomly move to one of the adjacent cells again. (He could possibly fall in the same tunnel later.)   

It's possible for Alef to get stuck in the maze in the case when the cell in which he was thrown into from a tunnel is surrounded by obstacles on all sides.  

Your task is to write a program which calculates and prints a probability that Alef escapes the maze.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
#define endl '\n'

#define double long double

using namespace std;
const int MAXN = (42);
const double eps = 1e-12;

vector&lt;double&gt; gauss(vector&lt;vector&lt;double&gt;&gt; &amp;a)
{
	int n = a.size(), m = a[0].size() - 1;

	vector&lt;int&gt; where(m, -1);
	for(int col = 0, row = 0; col &lt; m &amp;&amp; row &lt; n; col++)
    {
    	int sel = row;
        for(int i = row; i &lt; n; i++)
        	if(abs(a[i][col]) &gt; abs(a[sel][col]))
        		sel = i;

		if(abs(a[sel][col]) &lt; eps) { where[col] = -1; continue; }

        for(int i = col; i &lt;= m; i++)
			swap(a[sel][i], a[row][i]);
		where[col] = row;

		for(int i = 0; i &lt; n; i++)
			if(i != row)
			{
				if(abs(a[i][col]) &lt; eps) continue;
            	double c = a[i][col] / a[row][col];
            	for(int j = 0; j &lt;= m; j++)
                    a[i][j] -= c * a[row][j];
			}

		row++;
    }

    vector&lt;double&gt; ans(m, 0);
    for(int i = 0; i &lt; m; i++)
        if(where[i] != -1)
			ans[i] = a[where[i]][m] / a[where[i]][i];

    for(int i = 0; i &lt; n; i++)
	{
		double sum = a[i][m];
		for(int j = 0; j &lt; m; j++)
			sum -= ans[j] * a[i][j];

		if(abs(sum) &gt; eps) return vector&lt;double&gt;();
	}

	return ans;
}

int n, m, k;
string a[MAXN];
int nxt_x[MAXN][MAXN], nxt_y[MAXN][MAXN];

void read()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    for(int i = 0; i &lt; n; i++)
        cin &gt;&gt; a[i];

    for(int i = 0; i &lt; n; i++)
        for(int j = 0; j &lt; m; j++)
            nxt_x[i][j] = i, nxt_y[i][j] = j;

    for(int i = 0; i &lt; k; i++)
    {
        int x1, y1, x2, y2;
        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;
        x1--; y1--; x2--; y2--;
        nxt_x[x1][y1] = x2; nxt_y[x1][y1] = y2;
        nxt_x[x2][y2] = x1; nxt_y[x2][y2] = y1;
    }
}

int N;
int encode(int x, int y) { return x * m + y; }

int dirx[4] = {0, 0, 1, -1};
int diry[4] = {1, -1, 0, 0};

bool ok(int x, int y)
{
    if(x &gt;= n || y &gt;= m || x &lt; 0 || y &lt; 0) return false;
    return a[x][y] != '#';
}

void solve()
{
    N = n * m;
    vector&lt;vector&lt;double&gt; &gt; matr;
    vector&lt;double&gt; zero(N + 1, 0);

    for(int i = 0; i &lt; n; i++)
        for(int j = 0; j &lt; m; j++)
        {
            if(a[i][j] == '#') { matr.push_back(zero); continue; }
            else if(a[i][j] == '*') { matr.push_back(zero), matr[matr.size() - 1][encode(i, j)] = 1; continue; }
            else if(a[i][j] == '%') { matr.push_back(zero), matr[matr.size() - 1][encode(i, j)] = 1;  matr[matr.size() - 1][N] = 1; continue; }

            vector&lt;int&gt; adj;
            for(int d = 0; d &lt; 4; d++)
                if(ok(i + dirx[d], j + diry[d]))
                    adj.push_back(encode(nxt_x[i + dirx[d]][j + diry[d]], nxt_y[i + dirx[d]][j + diry[d]]));

            matr.push_back(zero);
            matr[matr.size() - 1][encode(i, j)] = 1;

            for(int v: adj)
                matr[matr.size() - 1][v] = -((double)1 / (double)adj.size());
        }

    vector&lt;double&gt; ans = gauss(matr);

    for(int i = 0; i &lt; n; i++)
        for(int j = 0; j &lt; m; j++)
            if(a[i][j] == 'A')
            {
                cout &lt;&lt; setprecision(9) &lt;&lt; fixed &lt;&lt; ans[encode(i, j)] &lt;&lt; endl;
                return;
            }
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	read();
	solve();
	return 0;
}

----------
====================
----------
ALGORITHMS.167
medium
----------
PROBLEM STATEMENT:
The Ruler of HackerLand believes that every citizen of the country should have access to a library. Unfortunately, HackerLand was hit by a tornado that destroyed all of its libraries and obstructed its roads! As you are the greatest programmer of HackerLand, the ruler wants your help to repair the roads and build some new libraries efficiently. 

HackerLand has [expression] bidirectional roads. A citizen has access to a library if:


Their city contains a library.
They can travel by road from their city to a city containing a library.


The following figure is a sample map of HackerLand where the dotted lines denote obstructed roads:



The cost of repairing any road is [expression].    

You are given [expression]. For each query, find the minimum cost of making libraries accessible to all the citizens and print it on a new line.

Function Description

Complete the function roadsAndLibraries in the editor below.  It must return the minimal cost of providing libraries to all, as an integer.

roadsAndLibraries has the following parameters:


n: integer, the number of cities  
c_lib: integer, the cost to build a library  
c_road: integer, the cost to repair a road  
cities: 2D array of integers where each [expression] contains two integers that represent cities connected by an obstructed road . 

----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; static void amin(T &amp;x, U y) { if (y &lt; x) x = y; }
template&lt;typename T, typename U&gt; static void amax(T &amp;x, U y) { if (x &lt; y) x = y; }

struct UnionFind {
	vector&lt;int&gt; data;
	void init(int n) { data.assign(n, -1); }
	bool unionSet(int x, int y) {
		x = root(x); y = root(y);
		if (x != y) {
			if (data[y] &lt; data[x]) swap(x, y);
			data[x] += data[y]; data[y] = x;
		}
		return x != y;
	}
	bool findSet(int x, int y) { return root(x) == root(y); }
	int root(int x) { return data[x] &lt; 0 ? x : data[x] = root(data[x]); }
	int size(int x) { return -data[root(x)]; }
};

int main() {
	int T;
	scanf("%d", &amp;T);
	for (int ii = 0; ii &lt; T; ++ii) {
		int n; int m; int clib; int croad;
		scanf("%d%d%d%d", &amp;n, &amp;m, &amp;clib, &amp;croad);
		UnionFind uf; uf.init(n);
		rep(i, m) {
			int u; int v;
			scanf("%d%d", &amp;u, &amp;v), --u, --v;
			uf.unionSet(u, v);
		}
		int ccs = 0;
		rep(i, n)
			ccs += uf.root(i) == i;
		ll ans = INFL;
		for (int i = ccs; i &lt;= n; ++i)
			amin(ans, (ll)clib * i + (ll)croad * (n - i));
		printf("%lld\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.168
medium
----------
PROBLEM STATEMENT:
The member states of the UN are planning to send [expression] people to the moon. They want them to be from different countries.  You will be given a list of pairs of astronaut ID's.  Each pair is made of astronauts from the same country.  Determine how many pairs of astronauts from different countries they can choose from.

For example, we have the following data on 2 pairs of astronauts, and 4 astronauts total, numbered [expression].

1   2
2   3


Astronauts by country are [expression].

Function Description  

Complete the journeyToMoon function in the editor below.  It should return an integer that represents the number of valid pairs that can be formed.  

journeyToMoon has the following parameter(s):  


n: an integer that denotes the number of astronauts  
astronaut: a 2D array where each element [expression] element integer array that represents the ID's of two astronauts from the same country  

----------
TOP SOLUTION:
----------
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;iterator&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;deque&gt;
#include &lt;cmath&gt;
#include &lt;memory.h&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;cctype&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt; 
using namespace std;
 
#define FOR(i, a, b) for(int i = (a); i &lt; (b); ++i)
#define RFOR(i, b, a) for(int i = (b) - 1; i &gt;= (a); --i)
#define REP(i, N) FOR(i, 0, N)
#define RREP(i, N) RFOR(i, N, 0)
 
#define ALL(V) V.begin(), V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair
#define Pi 3.14159265358979

typedef long long Int;
typedef unsigned long long UInt;
typedef vector &lt;int&gt; VI;
typedef pair &lt;int, int&gt; PII;

VI a[1&lt;&lt;17];
bool was[1&lt;&lt;17];

int n,m;

int dfs(int cur)
{
	if (was[cur])
		return 0;
	
	was[cur] = true;
	int res = 1;
	
	REP(i,SZ(a[cur]))
	{
		int nx = a[cur][i];
		
		res += dfs(nx);
	}
	
	return res;
}


int main()
{
//	freopen("in.txt", "r", stdin);
//	freopen("out.txt", "w", stdout);
	
	scanf("%d%d",&amp;n,&amp;m);
	
	REP(i,m)
	{
		int x,y;
		scanf("%d%d",&amp;x,&amp;y);
		
		a[x].push_back(y);
		a[y].push_back(x);
	}
	
	VI all;
	
	REP(i,n)
	{
		if (!was[i])
		{
			all.push_back(dfs(i));
		}
	}
	
	Int res = 0;
	Int sum = 0;
	REP(i, SZ(all))
	{
		res += sum * all[i];
		
		sum += all[i];
	}
	
	cout &lt;&lt; res &lt;&lt; endl;
	
	return 0;
}

----------
====================
----------
ALGORITHMS.169
medium
----------
PROBLEM STATEMENT:
Bitville is a seaside city that has a number of shopping centers connected by bidirectional roads, each of which has a travel time associated with it.  Each of the shopping centers may have a fishmonger who sells one or more kinds of fish.  Two cats, Big Cat and Little Cat, are at shopping center [expression], and one may arrive at a different time than the other.  The minimum time to determine is when both have arrived at the destination.  

For example, there are [expression].  

   

Function Description  

Complete the shop function in the editor below.  It should return an integer that represents the minimum time required for their shopping.  

shop has the following parameters: 
- n: an integer, the number of shopping centers 
- k: an integer, the number of types of fish 
- centers: an array of strings of space-separated integers where the first integer of each element is the number of types of fish sold at a center and the remainder are the types sold 
- roads: a 2-dimensional array of integers where the first two values are the shopping centers connected by the bi-directional road, and the third is the travel time for that road  
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

#define sd(x) scanf("%d",&amp;x)
#define sd2(x,y) scanf("%d%d",&amp;x,&amp;y)
#define sd3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)

#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define foreach(it, v) for(__typeof((v).begin()) it=(v).begin(); it != (v).end(); ++it)
#define meta __FUNCTION__,__LINE__

#define _ ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define __ freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);

using namespace std;

template&lt;typename S, typename T&gt; 
ostream&amp; operator&lt;&lt;(ostream&amp; out,pair&lt;S,T&gt; const&amp; p){out&lt;&lt;'('&lt;&lt;p.fi&lt;&lt;", "&lt;&lt;p.se&lt;&lt;')';return out;}

template&lt;typename T&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; out,vector&lt;T&gt; const&amp; v){
int l=v.size();for(int i=0;i&lt;l-1;i++)out&lt;&lt;v[i]&lt;&lt;' ';if(l&gt;0)out&lt;&lt;v[l-1];return out;}

void tr(){cout &lt;&lt; endl;}
template&lt;typename S, typename ... Strings&gt;
void tr(S x, const Strings&amp;... rest){cout&lt;&lt;x&lt;&lt;' ';tr(rest...);}

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

const long double PI = 3.1415926535897932384626433832795;

const int N = 1010;
const int M = 11;
const int INF = 1e9;

int n, m, k;

int dis[N][1&lt;&lt;M];
int vis[N][1&lt;&lt;M];
int mask[N];
vector&lt;pii&gt; g[N];

set&lt;pair&lt;int, pii&gt; &gt; q;

void go(){
	dis[1][mask[1]] = 0;
	
	q.insert(mp(dis[1][mask[1]], mp(1, mask[1])));
	
	while(!q.empty()){
		pair&lt;int, pii&gt; top = *q.begin();
		q.erase(q.begin());
		
		int x = top.se.fi;
		int msk = top.se.se;
		
		if(vis[x][msk]) continue;
		vis[x][msk] = 1;
		dis[x][msk] = top.fi;
		
		foreach(it, g[x]){
			int y = it-&gt;fi, w = it-&gt;se;
			int nmask = msk | mask[y];
			
			if(vis[y][nmask]) continue;
			
			int ndis = dis[x][msk] + w;
			if(ndis &lt; dis[y][nmask]){
				dis[y][nmask] = ndis;
				q.insert(mp(dis[y][nmask], mp(y, nmask)));
			}
		}	
	}
}

int main(){
	sd3(n,m,k);
	
	for(int i = 1; i &lt;= n; i++){
		int ti;
		sd(ti);
		int x;
		while(ti--){
			sd(x); x--;
			mask[i] |= (1 &lt;&lt; x);
		}
	}
	
	for(int i = 1; i &lt;= m; i++){
		int u, v, t;
		sd3(u,v,t);
		g[u].pb(mp(v,t));
		g[v].pb(mp(u,t));
	}

	for(int i = 1; i &lt;= n; i++){
		for(int j = 0; j &lt; (1 &lt;&lt; k); j++){
			dis[i][j] = INF;
		}
	}

	go();
	
	int ans = INF;
	
	for(int i = 0; i &lt; (1 &lt;&lt; k); i++){
		for(int j = 0; j &lt; (1 &lt;&lt; k); j++){
			if((i|j) == ((1 &lt;&lt; k) - 1)){
				ans = min(ans, max(dis[n][i], dis[n][j]));
			}		
		}
	}
	
	printf("%d\n", ans);
	
	return 0;
}
----------
====================
----------
ALGORITHMS.170
hard
----------
PROBLEM STATEMENT:
You are given an array with [expression].

BIT(x, i) = (x &gt;&gt; i) &amp; 1. (where [expression] in binary form.)

If we regard every bit as a vertex of a graph G, there exists one undirected edge between vertex [expression] if there exists at least one k such that BIT(d[k], i) == 1 &amp;&amp; BIT(d[k], j) == 1.

For every subset of the input array, how many  connected-components are there in that graph?

The number of connected-components in a graph are the sets of nodes, which are accessible to each other, but not to/from the nodes in any other set.  

For example if a graph has six nodes, labelled [expression] is isolated from everone else.  

You only need to output the sum of the number of connected-component([expression]) in every graph.
----------
TOP SOLUTION:
----------
import java.io.*;
import java.math.BigInteger;

public class Solution {

    static int col = 0;
    static long[] a;

    public static void solve(Input in, PrintWriter out) throws IOException {
        int n = in.nextInt();
        a = new long[n];
        for (int i = 0; i &lt; n; ++i) {
            a[i] = new BigInteger(in.next()).longValue();
        }
        int ans = 0;
        for (int mask = 0; mask &lt; 1 &lt;&lt; n; ++mask) {
            col = 0;
            int countBits = 64;
            int add = 0;
            for (int i = 0; i &lt; n; ++i) {
                if (((mask &amp; ~col) &amp; (1 &lt;&lt; i)) != 0) {
                    long mask1 = dfs(i, mask);
                    if (mask1 != 0) {
                        add++;
                        countBits -= Long.bitCount(mask1);
                    }
                }
            }
            add += countBits;
            ans += add;
        }
        out.println(ans);
    }

    private static long dfs(int i, int mask) {
        if ((col &amp; (1 &lt;&lt; i)) != 0) {
            return 0;
        }
        col |= 1 &lt;&lt; i;
        long ret = a[i];
        for (int j = 0; j &lt; a.length; ++j) {
            if ((mask &amp; (1 &lt;&lt; j)) != 0 &amp;&amp; (a[i] &amp; a[j]) != 0) {
                ret |= dfs(j, mask);
            }
        }
        return ret;
    }

    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);
        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);
        out.close();
    }

    static class Input {
        BufferedReader in;
        StringBuilder sb = new StringBuilder();

        public Input(BufferedReader in) {
            this.in = in;
        }

        public Input(String s) {
            this.in = new BufferedReader(new StringReader(s));
        }

        public String next() throws IOException {
            sb.setLength(0);
            while (true) {
                int c = in.read();
                if (c == -1) {
                    return null;
                }
                if (" \n\r\t".indexOf(c) == -1) {
                    sb.append((char)c);
                    break;
                }
            }
            while (true) {
                int c = in.read();
                if (c == -1 || " \n\r\t".indexOf(c) != -1) {
                    break;
                }
                sb.append((char)c);
            }
            return sb.toString();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }
}

----------
====================
----------
ALGORITHMS.171
medium
----------
PROBLEM STATEMENT:
Consider an undirected graph where each edge is the same weight.  Each of the nodes is labeled consecutively.

You will be given a number of queries.  For each query, you will be given a list of edges describing an undirected graph.  After you create a representation of the graph, you must determine and report the shortest distance to each of the other nodes from a given starting position using the breadth-first search algorithm (BFS).  Distances are to be reported in node number order, ascending.  If a node is unreachable, print [expression] for that node.  Each of the edges weighs 6 units of distance.

For example, given a graph with [expression], a visual representation is:  

  

The start node for the example is node [expression].  

Function Description  

Complete the bfs function in the editor below.  It must return an array of integers representing distances from the start node to each other node in node ascending order.  If a node is unreachable, its distance is [expression].  

bfs has the following parameter(s):  


n: the integer number of nodes  
m: the integer number of edges  
edges: a 2D array of start and end nodes for edges
s: the node to start traversals from

----------
TOP SOLUTION:
----------
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;deque&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;bitset&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;limits&gt;
#include &lt;fstream&gt;

using namespace std;
typedef vector&lt;string&gt; vs;
typedef vector&lt;int&gt; vi;
typedef vector&lt;long long&gt; vll;
typedef vector&lt;vector&lt;int&gt; &gt; vvi;
#define FOR(i,a,b) for(int i=(a);i&lt;(b);++i)
#define DEC(i,a,b) for(int i=(a); i&gt;=b; --i)
#define FORV(v,i) for(int i=0;i&lt;v.size();++i)
#define FORD(v,i) for(int i=v.size()-1;i&gt;=0;--i)
#define all(c) (c).begin(),(c).end()
#define sz(c) int((c).size())
#define pb push_back
#define ull unsigned long long
#define ll long long
#define MOD 1000000007ULL


void bfs(vector&lt;set&lt;int&gt; &gt; &amp;V,int &amp;S,stringstream &amp;ss)
{
	vector&lt;bool&gt; A(V.size(),false);
	vi D(V.size(),-1);
	D[S] = 0;
	queue&lt;int&gt; Q;
	Q.push(S);
	//ss&lt;&lt;"size:"&lt;&lt;V[S].size()&lt;&lt;"\n";
	A[S] = true;
	while(!Q.empty())
	{
		int f = Q.front(); Q.pop();
		//ss&lt;&lt;f&lt;&lt;","&lt;&lt;V[f].size()&lt;&lt;":";
		for(set&lt;int&gt;::iterator it = V[f].begin();
			it != V[f].end() ; ++it)
		{
			int p = *it;
			if(!A[p])
			{
				//ss&lt;&lt;p&lt;&lt;",";
				D[p] = D[f] + 1;
				/*
				int v = D[f] + 1;
				if( v &lt; D[p])
					D[p] = D[f] + 1;
				*/
				A[p] = true;
				Q.push(p);
			}
		}
		//ss&lt;&lt;"\n";
	}
	//ss&lt;&lt;"\n";

	//sort(all(D));
	//int C = 0;
	FORV(D,i)
	{
		if(D[i] == -1)
			ss&lt;&lt;-1&lt;&lt;" ";
		else if(D[i] &gt; 0)
			ss&lt;&lt;(D[i]*6)&lt;&lt;" ";
	}
	ss&lt;&lt;"\n";
	//FOR(i,0,C)
	//	ss&lt;&lt;-1&lt;&lt;" ";
}


int main()
{
	int t;
	ios_base::sync_with_stdio(false);
	cin&gt;&gt;t;
	stringstream ss;
	FOR(i,0,t)
	{
		int n,m;
		cin&gt;&gt;n&gt;&gt;m;
		vector&lt;set&lt;int&gt; &gt; V(n,set&lt;int&gt;());
		FOR(j,0,m)
		{
			int a,b;
			cin&gt;&gt;a&gt;&gt;b;
			a--;
			b--;
			V[a].insert(b);
			V[b].insert(a);
		}
		int S;
		cin&gt;&gt;S;
		S--;
		bfs(V,S,ss);
	}
	cout&lt;&lt;ss.str();
	return 0;
}

----------
====================
----------
ALGORITHMS.172
medium
----------
PROBLEM STATEMENT:
Given an undirected weighted connected graph, find the Really Special SubTree in it. The Really Special SubTree is defined as a subgraph consisting of all the nodes in the graph and: 


There is only one exclusive path from a node to every other node. 
The subgraph is of minimum overall weight (sum of all edges) among all such subgraphs.  
No cycles are formed


To create the Really Special SubTree, always pick the edge with smallest weight. Determine if including it will create a cycle.  If so, ignore the edge.  If there are edges of equal weight available:


Choose the edge that minimizes the sum [expression] is the edge weight.
If there is still a collision, choose any of them.


Print the overall weight of the tree formed using the rules.

For example, given the following edges:

[expression]
[expression]
[expression]
[expression]



First choose [expression].  

Function Description  

Complete the [expression] function in the editor below.  It should return an integer that represents the total weight of the subtree formed.  

kruskals has the following parameters:  


g_nodes: an integer that represents the number of nodes in the tree  
g_from: an array of integers that represent beginning edge node numbers  
g_to: an array of integers that represent ending edge node numbers  
g_weight: an array of integers that represent the weights of each edge  

----------
TOP SOLUTION:
----------
import java.io.*;
import java.math.*;
import java.util.*;

public class Solution {

    private StreamTokenizer in;
    private PrintWriter out;

    private int[] parent;
    private int[] rank;

    class Edge {
        public int v;
        public int u;
        public int cost;

        public Edge(int v, int u, int cost) {
            this.v = v;
            this.u = u;
            this.cost = cost;
        }
    }

    private int find(int v) {
        if (v == parent[v])
            return v;
        return parent[v] = find(parent[v]);
    }

    private void union(int a, int b) {
        a = find(a);
        b = find(b);
        if (a != b) {
            if (rank[a] &lt; rank[b]) {
                int k = a;
                a = b;
                b = k;
            }
            parent[b] = a;
            if (rank[a] == rank[b]) {
                ++rank[a];
            }
        }
    }

    private int nextInt() throws IOException {
        in.nextToken();
        return (int)in.nval;
    }

    private void run() throws IOException {
        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        out = new PrintWriter(new OutputStreamWriter(System.out));
        int T = 1;
        for (int t = 0; t &lt; T; t++) {
            int n = nextInt();
            int m = nextInt();
            parent = new int[n + 1];
            rank = new int[n + 1];
            for (int i = 1; i &lt;= n; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
            SortedSet&lt;Edge&gt; edges = new TreeSet&lt;Edge&gt;(new Comparator&lt;Edge&gt;() {
                @Override
                public int compare(Edge o1, Edge o2) {
                    if (o1.cost == o2.cost) {
                        if (o1.v == o2.v) {
                            return o1.u - o2.u;
                        }
                        return o1.v - o2.v;
                    }
                    return o1.cost - o2.cost;
                }
            });
            for (int i = 0; i &lt; m; i++) {
                int v = nextInt();
                int u = nextInt();
                int w = nextInt();
                edges.add(new Edge(v, u, w));
                edges.add(new Edge(u, v, w));
            }
            int ans = 0;
            for (Edge edge : edges) {
                int v = find(edge.v);
                int u = find(edge.u);
                if (v != u) {
                    union(edge.v, edge.u);
                    ans += edge.cost;
                }
            }
            out.println(ans);
        }
        out.flush();
        out.close();
    }

    public static void main(String[] args) throws IOException {
        new Solution().run();
    }
}
----------
====================
----------
ALGORITHMS.173
medium
----------
PROBLEM STATEMENT:
You are given a tree (a simple connected graph with no cycles). 

Find the maximum number of edges you can remove from the tree to get a forest such that each connected component of the forest contains an even number of nodes.

As an example, the following tree with [expression] time to create an even forest.  

  

Function Description  

Complete the evenForest function in the editor below.  It should return an integer as described.  

evenForest has the following parameter(s):  


t_nodes: the number of nodes in the tree  
t_edges: the number of undirected edges in the tree  
t_from: start nodes for each edge  
t_to: end nodes for each edge, (Match by index to t_from.)  

----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;complex&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;string&gt;
#include &lt;valarray&gt;


using namespace std;

typedef pair&lt;int,int&gt; Pair;

template&lt;class t&gt;
ostream &amp; operator &lt;&lt; (ostream &amp; tout,const vector&lt;t&gt; &amp;s){
  tout&lt;&lt;'[';
  for (int i=0;i&lt;s.size();i++)
    if (i+1 == s.size())
      tout&lt;&lt;s[i];
    else
      tout&lt;&lt;s[i]&lt;&lt;',';
  tout&lt;&lt;']';
  return(tout);
}

template&lt;class a,class b&gt;
ostream &amp; operator &lt;&lt; (ostream &amp; tout,const pair&lt;a,b&gt; &amp;c){
  return(tout&lt;&lt;'('&lt;&lt;c.first&lt;&lt;','&lt;&lt;c.second&lt;&lt;')');
}

template&lt;class T&gt; struct __set__print{
  __set__print(ostream&amp; out) : tout(out), count(0) {}
  void operator() (T x) { 
    if (count &gt; 0)
      tout&lt;&lt;',';
    tout&lt;&lt;x;
    ++count; 
  }
  ostream&amp; tout;
  int count;
};

template&lt;class T&gt;
ostream &amp; operator &lt;&lt; (ostream &amp; tout,const set&lt;T&gt; &amp;s){
  tout&lt;&lt;'{';
  for_each(s.begin(),s.end(),__set__print&lt;T&gt;(tout));
  return(tout&lt;&lt;'}');
}

template&lt;class T,class Q&gt; struct print_map{
  print_map(ostream&amp; out) : tout(out), count(0) {}
  void operator() (const pair&lt;T,Q&gt; &amp;x) { 
    if (count &gt; 0)
      tout&lt;&lt;',';
    tout&lt;&lt;'('&lt;&lt;x.first&lt;&lt;" =&gt; "&lt;&lt;x.second&lt;&lt;')';
    ++count; 
  }
  ostream&amp; tout;
  int count;
};

template&lt;class T,class Q&gt;
ostream &amp; operator &lt;&lt; (ostream &amp; tout,map&lt;T,Q&gt; s){
  tout&lt;&lt;'{';
  for_each(s.begin(),s.end(),print_map&lt;T,Q&gt;(tout));
  return(tout&lt;&lt;'}');
}

template&lt;class T&gt;
string to_string(T s){
  stringstream tin;
  tin&lt;&lt;s;
  string res;
  getline(tin,res);
  return(res);
}


template&lt;class T&gt;
vector&lt;T&gt; to_vector(T *s,int n){
  vector&lt;T&gt; result;
  for (int i=0;i&lt;n;i++)
    result.push_back(s[i]);
  return(result);
}

// *********************************** MY CODE ***************************

const int MAX_N = 100+20,INF = 1&lt;&lt;25;

int n, m;
vector&lt;int&gt; e[MAX_N];
bool mark[MAX_N];
Pair dyna[MAX_N];


Pair impact(Pair a,Pair b){
  Pair result(-INF,-INF);
  result.first = max(result.first,a.first+b.first+1);
  result.second = max(result.second,a.second+b.first+1);
  result.first = max(result.first,a.second+b.second);
  result.second = max(result.second,a.first+b.second);
  return(result);
}

void dfs(int s){
  mark[s] = true;
  for (int i=0;i&lt;e[s].size();i++)
    if (!mark[e[s][i]]){
      dfs(e[s][i]);
      dyna[s] = impact(dyna[s],dyna[e[s][i]]);
    }
}

int main(){
  ios_base::sync_with_stdio(false) ;
  cin &gt;&gt; n &gt;&gt; m;
  for (int i=1;i&lt;n;i++){
    int x,y;
    cin&gt;&gt;x&gt;&gt;y;
    e[x].push_back(y);
    e[y].push_back(x);
  }

  for (int i=1;i&lt;=n;i++)
    dyna[i] = Pair(-INF,0);

  dfs(1);
  
  cout&lt;&lt;dyna[1].first&lt;&lt;endl;

}

----------
====================
----------
ALGORITHMS.174
medium
----------
PROBLEM STATEMENT:
Markov takes out his Snakes and Ladders game, stares at the board and wonders:   "If I can always roll the die to whatever number I want, what would be the least number of rolls to reach the destination?"   

Rules
The game is played with a cubic die of [expression].


Starting from square [expression], no move is made.
If a player lands at the base of a ladder, the player must climb the ladder.  Ladders go up only.
If a player lands at the mouth of a snake, the player must go down the snake and come out through the tail.  Snakes go down only.


Function Description  

Complete the quickestWayUp function in the editor below.  It should return an integer that represents the minimum number of moves required.  

quickestWayUp has the following parameter(s):  


ladders: a 2D integer array where each [expression] contains the start and end cell numbers of a ladder   
snakes: a 2D integer array where each [expression] contains the start and end cell numbers of a snake  

----------
TOP SOLUTION:
----------
__author__ = 'Ahn'

def makegraph(propSnake, propLadder, numSnake, numLadder):
    graph = {}
    for num in range(1, 101):
        graph [num] = [[]]
        graph[num].append(float('inf'))
        for dice in range(1, 7):
            bAppend = False
            place =dice+num

            for Ladder in range(numLadder):
                if place == propLadder[Ladder][0]:
                    graph[num][0].append(propLadder[Ladder][1])

                    bAppend = True
            for Snake in range(numSnake):
                if place  == propSnake[Snake][0]:
                    graph[num][0].append(propSnake[Snake][1])
                    bAppend = True
            if bAppend is not True:
                graph[num][0].append(dice+num)


    return graph

def find_shortest_path(graph):
    graph[1][1] = 0
    for i in range(1, 100):
        for  j in graph[i][0]:
            try :
                if graph[i][1]+1 &lt;= graph[j][1]:
                    graph[j][1] = graph[i][1] + 1
            except KeyError:
                continue


    return graph[100][1]



numT = int(input())
for i in range(numT):
    numLadder, numSnake = input().split(',')
    numLadder = int(numLadder)
    numSnake = int(numSnake)
    propLadder = input().split()
    for j in range(len(propLadder)):
        l = propLadder[j].split(',')
        l = [int(i) for i in l]
        propLadder[j] = l

    propSnake = input().split()
    for j in range(len(propSnake)):
        l = propSnake[j].split(',')
        l = [int(i) for i in l]
        propSnake[j] = l

    g = makegraph(propSnake, propLadder, numSnake, numLadder)
    print(find_shortest_path(g))



----------
====================
----------
ALGORITHMS.175
hard
----------
PROBLEM STATEMENT:
Given an undirected graph and a starting node, determine the lengths of the shortest paths from the starting node to all other nodes in the graph.  If a node is unreachable, its distance is -1.  Nodes will be numbered consecutively from [expression], and edges will have varying distances or lengths.

For example, consider the following graph of 5 nodes:

[expression]
[expression]
[expression]
[expression]
[expression]



 
Starting at node [expression].

The distances to all nodes in increasing node order, omitting the starting node, are 5 11 13 -1.

Function Description  

Complete the shortestReach function in the editor below.  It should return an array of integers that represent the shortest distance to each node from the start node in ascending order of node number.  

shortestReach has the following parameter(s):  


n: the number of nodes in the graph  
edges: a 2D array of integers where each [expression] consists of three integers that represent the start and end nodes of an edge, followed by its length  
s: the start node number  

----------
TOP SOLUTION:
----------
def killdoubles(l):
    i=0
    a=l[i]
    ll=[a]
    while i&lt;len(l):
        if a!=l[i]:
            a=l[i]
            ll.append(a)
        i+=1
    return ll

def argminnonmarque(l,m):
    mini=min([l[i] for i in range(len(l)) if not(m[i])])
    for i in range(len(l)):
        if ((l[i]==mini) &amp; (not(m[i]))):
            break
    return i
def subs(a,l):
    i=0
    dont=False
    while i&lt;len(l):
        if l[i][0]==a[0]:
            if l[i][1]&gt;a[1]:
                break
            dont=True
        i+=1
    ll=[list(k) for k in l]
    if i&lt;len(l):
        ll[i]=a
    elif not(dont):
        ll.append(a)
    return ll
def solve(n,m,r,s):
    G=[[] for _ in range(n+1)]
    for [i,j,w] in r:
        G[i]=subs([j,w],G[i])
        G[j]=subs([i,w],G[j])
        
    infinity=1+sum([r[i][2] for i in range(m)])
    
    for debut in [s]:
        marque=[False for _ in range(n+1)]
        labels=[infinity for _ in range(n+1)]
        labels[debut]=0
        while marque!=[True for _ in range(n+1)]:
            a=argminnonmarque(labels,marque)
            marque[a]=True
            for [b,w] in G[a]:
                if not(marque[b]):
                    labels[b]=min(labels[b],labels[a]+w)
        for i in range(n+1):
            if labels[i]==infinity:
                labels[i]=-1
    st=""
    for i in (labels[1:s]+labels[s+1:]):
        st+=str(i)+" "
    return st


T=int(raw_input())
for _ in range(T):
    [n,m]=map(int,raw_input().strip().split())
    r=[]
    for _ in range(m):
        r.append(map(int,raw_input().strip().split()))
    s=int(raw_input())
    print(solve(n,m,r,s))
----------
====================
----------
ALGORITHMS.176
medium
----------
PROBLEM STATEMENT:
One day Bob drew a tree, [expression] edges on a piece of paper. He soon discovered that parent of a node depends on the root of the tree. The following images shows an example of that:



Learning the fact, Bob invented an exciting new game and decided to play it with Alice. The rules of the game is described below:


Bob picks a random node to be the tree's root and keeps the identity of the chosen node a secret from Alice. Each node has an equal probability of being picked as the root.
Alice then makes a list of [expression] exists in the tree. 
For each correct guess, Alice earns one point. Alice wins the game if she earns at least [expression] of her guesses were true).


Alice and Bob play [expression] for each game, find the probability that Alice will win the game and print it on a new line as a reduced fraction in the format p/q.
----------
TOP SOLUTION:
----------
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cassert&gt;
#include &lt;ctime&gt;
#include &lt;map&gt;
#include &lt;math.h&gt;
#include &lt;cstdio&gt;
#include &lt;set&gt;
#include &lt;deque&gt;
#include &lt;memory.h&gt;
#include &lt;queue&gt;

#pragma comment(linker, "/STACK:64000000")
typedef long long ll;

using namespace std;

const int MAXK = -1;
const int MAXN = 1 &lt;&lt; 18;

int n;
vector&lt;int&gt; e[MAXN];
int h[MAXN], p[MAXN];
int cc[MAXN];

void dfs(int v, int pr, int ch) {
	h[v] = ch;
	p[v] = pr;
	for (int to : e[v]) {
		if (to == pr) continue;
		dfs(to, v, ch + 1);
	}
}

void dfs1(int v, int pr, int cur) {
	cc[v] += cur;
	cur = cc[v];
	for (int to : e[v]) {
		if (to == pr) continue;
		dfs1(to, v, cur);
	}
}

int gcd(int a, int b) {
	while (b) {
		a %= b;
		swap(a, b);
	}
	return a;
}

int main() {
#ifdef _MSC_VER
	freopen("input.txt", "r", stdin);
#endif

	int T;
	scanf("%d", &amp;T);
	while (T--) {
		scanf("%d", &amp;n);
		for (int i = 0; i &lt; n; i++) {
			e[i].clear();
			cc[i] = 0;
		}
		for (int i = 0; i &lt; n - 1; i++) {
			int u, v;
			scanf("%d%d", &amp;u, &amp;v);
			--u; --v;
			e[u].push_back(v);
			e[v].push_back(u);
		}
		dfs(0, 0, 0);
		int q, k;
		scanf("%d%d", &amp;q, &amp;k);
		int all = 0;
		for (int i = 0; i &lt; q; i++) {
			int u, v;
			scanf("%d%d", &amp;u, &amp;v);
			--u; --v;
			if (h[v] &gt; h[u]) {
				all++;
				cc[v]--;
			}
			else {
				cc[u]++;
			}
		}
		dfs1(0, 0, 0);
		int cnt = 0;
		for (int i = 0; i &lt; n; i++) cnt += all + cc[i] &gt;= k;
		int g = gcd(cnt, n);
		printf("%d/%d\n", cnt / g, n / g);
	}

	return 0;
}
----------
====================
----------
ALGORITHMS.177
medium
----------
PROBLEM STATEMENT:
Given a graph which consists of several edges connecting its nodes, find a subgraph of the given graph with the following properties:  


The subgraph contains all the nodes present in the original graph.  
The subgraph is of minimum overall weight (sum of all edges) among all such subgraphs.  
It is also required that there is exactly one, exclusive path between any two nodes of the subgraph. 


One specific node [expression] is fixed as the starting point of finding the subgraph using Prim's Algorithm. 
Find the total weight or the sum of all edges in the subgraph.

 
For example, consider a graph with [expression].  

Function Description

Complete the prims function in the editor below.  It should return and integer that represents the minimum weight to connect all nodes in the graph provided.  

prims has the following parameter(s):  


n: an integer that represents the number of nodes in the graph  
edges: a two-dimensional array where each element contains three integers, two nodes numbers that are connected and the weight of that edge  
start: an integer that represents the number of the starting node  

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class Solution {

    private StreamTokenizer in;
    private PrintWriter out;

    private int[] parent;
    private int[] rank;

    class Edge {
        public int v;
        public int u;
        public int cost;

        public Edge(int v, int u, int cost) {
            this.v = v;
            this.u = u;
            this.cost = cost;
        }
    }

    private int find(int v) {
        if (v == parent[v])
            return v;
        return parent[v] = find(parent[v]);
    }

    private void union(int a, int b) {
        a = find(a);
        b = find(b);
        if (a != b) {
            if (rank[a] &lt; rank[b]) {
                int k = a;
                a = b;
                b = k;
            }
            parent[b] = a;
            if (rank[a] == rank[b]) {
                ++rank[a];
            }
        }
    }

    private int nextInt() throws IOException {
        in.nextToken();
        return (int)in.nval;
    }

    private void run() throws IOException {
        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        out = new PrintWriter(new OutputStreamWriter(System.out));
        int T = 1;
        for (int t = 0; t &lt; T; t++) {
            int n = nextInt();
            int m = nextInt();
            parent = new int[n + 1];
            rank = new int[n + 1];
            for (int i = 1; i &lt;= n; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
            SortedSet&lt;Edge&gt; edges = new TreeSet&lt;Edge&gt;(new Comparator&lt;Edge&gt;() {
                @Override
                public int compare(Edge o1, Edge o2) {
                    if (o1.cost == o2.cost) {
                        if (o1.v == o2.v) {
                            return o1.u - o2.u;
                        }
                        return o1.v - o2.v;
                    }
                    return o1.cost - o2.cost;
                }
            });
            for (int i = 0; i &lt; m; i++) {
                int v = nextInt();
                int u = nextInt();
                int w = nextInt();
                edges.add(new Edge(v, u, w));
                edges.add(new Edge(u, v, w));
            }
            int ans = 0;
            for (Edge edge : edges) {
                int v = find(edge.v);
                int u = find(edge.u);
                if (v != u) {
                    union(edge.v, edge.u);
                    ans += edge.cost;
                }
            }
            out.println(ans);
        }
        out.flush();
        out.close();
    }

    public static void main(String[] args) throws IOException {
        new Solution().run();
    }
}
----------
====================
----------
ALGORITHMS.178
hard
----------
PROBLEM STATEMENT:
The mayor of Farzville is studying the city's road system to find ways of improving its traffic conditions. Farzville's road system consists of [expression]. In addition, some junctions may not be reachable from others and there may be multiple roads connecting the same pair of junctions.   

Each toll road has a toll rate that's paid each time it's used. This rate varies depending on the direction of travel:  


If traveling from [expression]. 
If traveling from [expression].  




For each digit [expression], print the the number of valid ordered pairs on a new line.

Note: Each toll road can be traversed an unlimited number of times in either direction. 
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; static void amin(T &amp;x, U y) { if (y &lt; x) x = y; }
template&lt;typename T, typename U&gt; static void amax(T &amp;x, U y) { if (x &lt; y) x = y; }

struct UnionFind {
	vector&lt;int&gt; data;
	void init(int n) { data.assign(n, -1); }
	bool unionSet(int x, int y) {
		x = root(x); y = root(y);
		if (x != y) {
			if (data[y] &lt; data[x]) swap(x, y);
			data[x] += data[y]; data[y] = x;
		}
		return x != y;
	}
	bool findSet(int x, int y) { return root(x) == root(y); }
	int root(int x) { return data[x] &lt; 0 ? x : data[x] = root(data[x]); }
	int size(int x) { return -data[root(x)]; }
};

int main() {
	int n; int m;
	while (~scanf("%d%d", &amp;n, &amp;m)) {
		UnionFind uf;
		uf.init(n * 10);
		for (int i = 0; i &lt; m; ++ i) {
			int u, v, w;
			scanf("%d%d%d", &amp;u, &amp;v, &amp;w), -- u, -- v;
			rep(j, 10)
				uf.unionSet(u * 10 + j, v * 10 + (j + w) % 10);
		}
		vector&lt;array&lt;int,10&gt;&gt; counts(n * 10);
		rep(i, n) rep(j, 10)
			++ counts[uf.root(i * 10 + j)][j];
		rep(d, 10) {
			ll ans = 0;
			rep(a, n * 10) {
				rep(x, 1)
					ans += (ll)counts[a][x] * counts[a][(x + d) % 10];
			}
			rep(i, n)
				ans -= uf.findSet(i * 10, i * 10 + d);
			printf("%lld\n", ans);
		}
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.179
hard
----------
PROBLEM STATEMENT:
You are a real estate broker in ancient Knossos. You have [expression].

Each client can buy at most one house, and each house can have at most one owner. What is the maximum number of houses you can sell?
----------
TOP SOLUTION:
----------
using namespace std;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;limits.h&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;bitset&gt;
#include &lt;string&gt;
#include &lt;iterator&gt;
#include &lt;set&gt;
#include &lt;utility&gt;
#include &lt;queue&gt;
#include &lt;numeric&gt;
#include &lt;functional&gt;
#include &lt;ctype.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#define S(x) scanf("%d",&amp;x)
#define S2(x,y) scanf("%d%d",&amp;x,&amp;y)
#define wl(n) while(n--)
#define ll long long
#define bitcnt(x) __builtin_popcount(x)
#define P(x) printf("%d\n",x)
#define PB push_back
#define MP make_pair
#define fl(i,n) for(i=0;i&lt;n;i++)
#define fil(i,a,n) for(i=a;i&lt;n;i++)
#define rev(i,a,n) for(i=n-1;i&gt;=a;i--)
#define mem(a,i) memset(a,i,sizeof(a))
#define F first
#define S1 second
typedef pair&lt;int,int&gt; P;
vector&lt;int&gt; v1[100009];
pair&lt;int,int&gt; p1;
#define MOD 1000000007
#define debug(x)  printf("####%d####\n",x);
#define nl printf("\n");
#define str string
#define N 100000
int a[1234567],b[N],c[N],d[N];
string s;
int dp[1001];
ll pow1(ll x,ll y)
{
    if(y==0)
    return 1;
    ll temp= pow1(x,y/2)%MOD;
    if(y%2==0)
    return (temp*temp)%MOD;
    else
    return (((temp*temp)%MOD)*x)%MOD;
}
// hopcraft_karp algorithm for maximum matching
    
int dist[100009],match[100009],n,m;
bool bfs()
{
   int i,j;
   queue&lt;int&gt; q1;
   for(i=1;i&lt;=n;i++)
   {
       if(match[i]==0)
       {
           dist[i]=0;
           q1.push(i);
       }
       else
           dist[i]=INT_MAX;
   }
   dist[0]=INT_MAX;
   while(!q1.empty())
   {
       int u=q1.front();
       q1.pop();
       if(u!=0) // 0 has no adjacency list
       {
           fl(i,v1[u].size())
           {
               int p=v1[u][i];
               if(dist[match[p]]==INT_MAX) // if match[p] is not dere toh it would be zero by default 
               {
                   dist[match[p]]=dist[u]+1;
                   q1.push(match[p]);
               }
           }
       }
   }
   // this ensures ki ek toh path h he i.e augmenting path because kisi ek ka toh match[i] will be equal to 0
   return dist[0]!=INT_MAX;
}
bool dfs(int u)
{
   if(u==0)
       return true; // base case always true
   int i;
   fl(i,v1[u].size())
   {
       int p=v1[u][i];
       if(dist[match[p]]==dist[u]+1) // to ensure ki jo path bfs se mila tha augumenting ye vahi vaala h
       {
           if(dfs(match[p]))
           {
               match[p]=u; // means we found a path of alternating edges and changing the matched ones to unmatched and vice versa
               match[u]=p;
               return true;
           }
       }
   }
   return false; // else this is not the path
}
int hopcraft_karp()
{
   int ans=0,i;
   while(bfs())
   {
       for(i=1;i&lt;=n;i++)
       {
           if(match[i]==0&amp;&amp;dfs(i))
               ans++;
       }
   }
   return ans;
}
int main()
{
    //std::ios_base::sync_with_stdio(false);
    int t;
    int i,j,k,l;
    S2(n,m);
    fl(i,n)
    S2(a[i],b[i]);

    fl(i,m)
    S2(c[i],d[i]);

    fl(i,n)
    {
        // &gt;=a[i] , &lt;=b[i]

        fl(j,m)
        {
            if(c[j]&gt;=a[i]&amp;&amp;d[j]&lt;=b[i])
            {
                v1[i+1].push_back(j+1+n);
                v1[j+1+n].push_back(i+1);
            }
        }
    }

    P(hopcraft_karp());
    return 0;
}
----------
====================
----------
ALGORITHMS.180
medium
----------
PROBLEM STATEMENT:
A clique in a graph is set of nodes such that there is an edge between any two distinct nodes in the set. Finding the largest clique in a graph is a computationally difficult problem. Currently no polynomial time algorithm  is known for solving this. However, you wonder what is the minimum size of the largest clique in any graph with [expression] edges.  

For example, consider a graph with [expression] members each.  


----------
TOP SOLUTION:
----------
import math
def s1(n, m):
    ga = n%m
    gb = m-ga
    sa = n//m+1
    sb = n//m
    return ga*gb*sa*sb+ga*(ga-1)*sa*sa//2+gb*(gb-1)*sb*sb//2
def s(n,c):
    l = 1
    h = n+1
    while l+1 &lt; h:
        m = l+(h-l)//2
        k = s1(n,m)
        if k &lt; c:
            l = m
        else:
            h = m
    return h
t = int(input())
for i in range(t):
    n,m=[int(j) for j in input().split()]
    print(s(n,m))
----------
====================
----------
ALGORITHMS.181
medium
----------
PROBLEM STATEMENT:
Consider an undirected graph containing [expression], associated with it.

The penalty of a path is the bitwise OR of every edge cost in the path between a pair of nodes, [expression].

Given a graph and two nodes, [expression].

Note: Loops and multiple edges are allowed. The bitwise OR operation is known as or in Pascal and as | in C++ and Java.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;

int n, m;
int s, t;
int a[10001];
int b[10001];
int c[10001];


int F[1001];
int f(int x){return x == F[x] ? x : F[x] = f(F[x]);}

bool solve(int result)
{
	for(int i = 1; i &lt;= n; i++)
		F[i] = i;
	for(int i = 1; i &lt;= m; i++)
		if((c[i] | result) == result)
		{
			int fa = f(a[i]), fb = f(b[i]);
			if(fa != fb)
				F[fa] = fb;
		}
	return f(s) == f(t);
}

int MAIN()
{
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1; i &lt;= m; i++)
	{
		cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];
	}
	cin &gt;&gt; s &gt;&gt; t;
	if(!solve(1023))
		cout &lt;&lt; -1 &lt;&lt; endl;
	else
	{
		for(int i = 1; i &lt;= 1023; i++)
			if(solve(i))
			{
				cout &lt;&lt; i &lt;&lt; endl;
				break;
			}
	}
	return 0;
}

int main()
{
	int start = clock();
	#ifdef LOCAL_TEST
		freopen("in.txt", "r", stdin);
		freopen("out.txt", "w", stdout);
	#endif
	ios :: sync_with_stdio(false);
	cout &lt;&lt; fixed &lt;&lt; setprecision(16);
	int ret = MAIN();
	#ifdef LOCAL_TEST
		cout &lt;&lt; "[Finished in " &lt;&lt; clock() - start &lt;&lt; " ms]" &lt;&lt; endl;
	#endif
	return ret;
}

----------
====================
----------
ALGORITHMS.182
hard
----------
PROBLEM STATEMENT:
Killgrave wants to use his mind control powers to get money from the Justice League superheroes living in [expression] dollars stashed away for a rainy day.

As long as a superhero is home at house [expression] by a single road skips town for a couple of days (making it impossible for Killgrave to get money from them). In other words, after Killgrave visits all the superheroes he wants, there will be no road in which he was able to get money from both houses on either end of the road.

What is the maximum amount of money Killgrave can collect from the superheroes, and how many different ways can Killgrave get that amount of money? Two ways are considered to be different if the sets of visited houses are different.

Note: Killgrave can start at an arbitrary house and doesn't have to only use the roads.
----------
TOP SOLUTION:
----------
def r():
    return map(int,raw_input().split())
N,M=r()
C=r()
F=[0]*N # Map from house number to mask of connected houses
for j in range(M):
    A,B=r()
    A-=1
    B-=1
    F[A] |= 1&lt;&lt;B
    F[B] |= 1&lt;&lt;A
N2=N//2 # Number of houses to test against (can be 0)
DP=[(0,1)]*(1&lt;&lt;N2) # Map from mask of allowed houses to pair of max_gold,count
mask=(1&lt;&lt;N2)-1
for n in range(N2):
    # Compute value of DP with bit n set
    bit = 1&lt;&lt;n
    forbidden = mask&amp;(mask ^ F[n]) # Has 0's where houses are forbidden
    bonus = C[n]
    for sub_pattern in range(1&lt;&lt;n):
        new_pattern = bit+sub_pattern
        gold,count=DP[sub_pattern]
        gold2,count2=DP[sub_pattern&amp;forbidden]
        gold2+=bonus
        if gold==gold2:
            DP[new_pattern] = gold,(count+count2)
        elif gold&gt;gold2:
            DP[new_pattern] = gold,count
        else:
            DP[new_pattern] = gold2,count2
# Now iterate over the remaining houses
def go(i,forbidden):
    """return gold,count for best possibility from houses i to N without using houses marked by ones in forbidden"""
    if i==N:
        # Combine with best from second half
        allowed = mask ^ (forbidden&amp;mask)
        return DP[allowed]
    
    gold,count = go(i+1,forbidden) # Not choosing house i
    if (forbidden&gt;&gt;i)&amp;1:
        gold2,count2 = 0,0
    else:
        gold2,count2 = go(i+1,forbidden | F[i]) # choosing house i
        gold2 += C[i]
        
    if gold==gold2:
        return gold,(count+count2)
    elif gold&gt;gold2:
        return gold,count
    else:
        return gold2,count2
    
gold,count = go(N2,0)
print gold,count

----------
====================
----------
ALGORITHMS.183
hard
----------
PROBLEM STATEMENT:
You're researching friendships between groups of [expression]. At the beginning of the semester, no student knew any other student; instead, they met and formed individual friendships as the semester went on. The friendships between students are:


Bidirectional. If student [expression].
Transitive. If student [expression]. In other words, two students are considered to be friends even if they are only indirectly linked through a network of mutual (i.e., directly connected) friends. 


The purpose of your research is to find the maximum total value of a group's friendships, denoted by [expression]. 

You are given [expression] among all possible orderings of formed friendships and print it on a new line.
----------
TOP SOLUTION:
----------
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;
#include &lt;cstdio&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_map&gt;

using namespace std;
const int N = 200005;
int f[N] , s[N];

int getf(int x) {
    return x == f[x] ? x : f[x] = getf(f[x]);
}

int main(){
    int t;
    cin &gt;&gt; t;
    for(int a0 = 0; a0 &lt; t; a0++){
        int n;
        int m;
        cin &gt;&gt; n &gt;&gt; m;
        long long res = 0 , sum = n;
        for (int i = 1 ; i &lt;= n ; ++ i) {
            f[i] = i;
            s[i] = 1;
        }
        for(int a1 = 0; a1 &lt; m; a1++){
            int x;
            int y;
            cin &gt;&gt; x &gt;&gt; y;
            x = getf(x) , y = getf(y);
            if (x != y) {
                f[x] = y;
                sum += (long long)2 * s[y] * s[x];
                s[y] += s[x];
            }
        }
        vector&lt;int&gt; V;
        for (int i = 1 ; i &lt;= n ; ++ i) {
            if (getf(i) == i) {
                V.push_back(s[i]);
            }
        }
        sort(V.begin() , V.end());
        reverse(V.begin() , V.end());
        int now = m;
        long long w = n;
        for (int i = 0 ; i &lt; V.size() ; ++ i) {
            int x = V[i];
            for (int k = 1 ; k &lt; x ; ++ k) {
                w += 2 * k;
                -- now;
                res += w;
            }
        }
        res += sum * now;
        res -= (long long)m * n;
        cout &lt;&lt; res &lt;&lt; endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.184
expert
----------
PROBLEM STATEMENT:
You are given an undirected, connected graph, [expression] prime divisors. 

You must answer [expression].
----------
TOP SOLUTION:
----------

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class F {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	long ret;
	int[] freq;
	int[] pfreq;
	EulerTour et;
	int[] lpf = enumLowestPrimeFactors(10000005);
	int[] mob = enumMobiusByLPF(10000005, lpf);
	int[] a;
	
	void solve()
	{
		int n = ni(), Q = ni();
		a = na(n);
		for(int i = 0;i &lt; n;i++){
			int pre = -1;
			int mul = 1;
			for(int j = a[i];j &gt; 1;j /= lpf[j]){
				if(pre != lpf[j]){
					mul *= lpf[j];
					pre = lpf[j];
				}
			}
			a[i] = mul;
		}
		
		int[] from = new int[n - 1];
		int[] to = new int[n - 1];
		for (int i = 0; i &lt; n - 1; i++) {
			from[i] = ni() - 1;
			to[i] = ni() - 1;
		}
		int[][] g = packU(n, from, to);
		int[][] pars = parents3(g, 0);
		int[] par = pars[0], ord = pars[1], dep = pars[2];
		
		et = nodalEulerTour(g, 0);
		int[][] spar = logstepParents(par);
		
		int[][] qs = new int[Q][];
		int[] special = new int[Q];
		Arrays.fill(special, -1);
		for(int i = 0;i &lt; Q;i++){
			int x = ni()-1, y = ni()-1;
			int lca = lca2(x, y, spar, dep);
			if(lca == x){
				qs[i] = new int[]{et.first[x], et.first[y]};
			}else if(lca == y){
				qs[i] = new int[]{et.first[y], et.first[x]};
			}else if(et.first[x] &lt; et.first[y]){
				qs[i] = new int[]{et.last[x], et.first[y]};
				special[i] = lca;
			}else{
				qs[i] = new int[]{et.last[y], et.first[x]};
				special[i] = lca;
			}
		}
		
		long[] pqs = sqrtSort(qs, 2*n-1);
		
		int L = 0, R = -1;
		freq = new int[n];
		
		long[] ans = new long[Q];
		pfreq = new int[10000005];
		for(long pa : pqs){
			int ind = (int)(pa&amp;(1&lt;&lt;25)-1);
			int ql = qs[ind][0], qr = qs[ind][1];
			while(R &lt; qr)change(++R, 1);
			while(L &gt; ql)change(--L, 1);
			while(R &gt; qr)change(R--, -1);
			while(L &lt; ql)change(L++, -1);
			if(special[ind] != -1)change(et.first[special[ind]], 1);
//			tr(qs[ind], freq, special[ind]);
//			trnz(pfreq);
			ans[ind] = ret;
			if(special[ind] != -1)change(et.first[special[ind]], -1);
		}
//		tr(et.vs);
		for(long v : ans){
			out.println(v);
		}
	}
	
	public static void trnz(int... o)
	{
		for(int i = 0;i &lt; o.length;i++)if(o[i] != 0)System.out.print(i+":"+o[i]+" ");
		System.out.println();
	}

	
	public static int[] enumMobiusByLPF(int n, int[] lpf)
	{
		int[] mob = new int[n+1];
		mob[1] = 1;
		for(int i = 2;i &lt;= n;i++){
			int j = i/lpf[i];
			if(lpf[j] == lpf[i]){
//				mob[i] = 0;
			}else{
				mob[i] = -mob[j];
			}
		}
		return mob;
	}
	
	void dfs(int cur, int n, int d)
	{
		if(n == 1){
			if(d &gt; 0)ret += mob[cur] * pfreq[cur];
			pfreq[cur] += d;
			if(d &lt; 0)ret -= mob[cur] * pfreq[cur];
			return;
		}
		
		dfs(cur, n/lpf[n], d);
		dfs(cur/lpf[n], n/lpf[n], d);
	}
	
	void change(int x, int d)
	{
		int ind = et.vs[x];
		if(freq[ind] == 1){
			dfs(a[ind], a[ind], -1);
		}
		freq[ind] += d;
		if(freq[ind] == 1){
			dfs(a[ind], a[ind], 1);
		}
	}
	
	public static long[] sqrtSort(int[][] qs, int n)
	{
		int m = qs.length;
		long[] pack = new long[m];
		int S = (int)Math.sqrt(n);
		for(int i = 0;i &lt; m;i++){
			pack[i] = (long)qs[i][0]/S&lt;&lt;50|(long)((qs[i][0]/S&amp;1)==0?qs[i][1]:(1&lt;&lt;25)-1-qs[i][1])&lt;&lt;25|i;
		}
		Arrays.sort(pack);
		return pack;
	}
	
	
	public static int lca2(int a, int b, int[][] spar, int[] depth) {
		if (depth[a] &lt; depth[b]) {
			b = ancestor(b, depth[b] - depth[a], spar);
		} else if (depth[a] &gt; depth[b]) {
			a = ancestor(a, depth[a] - depth[b], spar);
		}

		if (a == b)
			return a;
		int sa = a, sb = b;
		for (int low = 0, high = depth[a], t = Integer.highestOneBit(high), k = Integer
				.numberOfTrailingZeros(t); t &gt; 0; t &gt;&gt;&gt;= 1, k--) {
			if ((low ^ high) &gt;= t) {
				if (spar[k][sa] != spar[k][sb]) {
					low |= t;
					sa = spar[k][sa];
					sb = spar[k][sb];
				} else {
					high = low | t - 1;
				}
			}
		}
		return spar[0][sa];
	}

	protected static int ancestor(int a, int m, int[][] spar) {
		for (int i = 0; m &gt; 0 &amp;&amp; a != -1; m &gt;&gt;&gt;= 1, i++) {
			if ((m &amp; 1) == 1)
				a = spar[i][a];
		}
		return a;
	}

	public static int[][] logstepParents(int[] par) {
		int n = par.length;
		int m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;
		int[][] pars = new int[m][n];
		pars[0] = par;
		for (int j = 1; j &lt; m; j++) {
			for (int i = 0; i &lt; n; i++) {
				pars[j][i] = pars[j - 1][i] == -1 ? -1 : pars[j - 1][pars[j - 1][i]];
			}
		}
		return pars;
	}


	
	public static class EulerTour
	{
		public int[] vs; // vertices
		public int[] first; // first appeared time
		public int[] last; // last appeared time
		
		public EulerTour(int[] vs, int[] f, int[] l) {
			this.vs = vs;
			this.first = f;
			this.last = l;
		}
	}
	
	public static EulerTour nodalEulerTour(int[][] g, int root)
	{
		int n = g.length;
		int[] vs = new int[2*n];
		int[] f = new int[n];
		int[] l = new int[n];
		int p = 0;
		Arrays.fill(f, -1);
		
		int[] stack = new int[n];
		int[] inds = new int[n];
		int sp = 0;
		stack[sp++] = root;
		outer:
		while(sp &gt; 0){
			int cur = stack[sp-1], ind = inds[sp-1];
			if(ind == 0){
				vs[p] = cur;
				f[cur] = p;
				p++;
			}
			while(ind &lt; g[cur].length){
				int nex = g[cur][ind++];
				if(f[nex] == -1){ // child
					inds[sp-1] = ind;
					stack[sp] = nex;
					inds[sp] = 0;
					sp++;
					continue outer;
				}
			}
			inds[sp-1] = ind;
			if(ind == g[cur].length){
				vs[p] = cur;
				l[cur] = p;
				p++;
				sp--;
			}
		}
		
		return new EulerTour(vs, f, l);
	}


	public static int[][] parents3(int[][] g, int root) {
		int n = g.length;
		int[] par = new int[n];
		Arrays.fill(par, -1);

		int[] depth = new int[n];
		depth[0] = 0;

		int[] q = new int[n];
		q[0] = root;
		for (int p = 0, r = 1; p &lt; r; p++) {
			int cur = q[p];
			for (int nex : g[cur]) {
				if (par[cur] != nex) {
					q[r++] = nex;
					par[nex] = cur;
					depth[nex] = depth[cur] + 1;
				}
			}
		}
		return new int[][] { par, q, depth };
	}

	static int[][] packU(int n, int[] from, int[] to) {
		int[][] g = new int[n][];
		int[] p = new int[n];
		for (int f : from)
			p[f]++;
		for (int t : to)
			p[t]++;
		for (int i = 0; i &lt; n; i++)
			g[i] = new int[p[i]];
		for (int i = 0; i &lt; from.length; i++) {
			g[from[i]][--p[from[i]]] = to[i];
			g[to[i]][--p[to[i]]] = from[i];
		}
		return g;
	}

	
	public static int[] enumLowestPrimeFactors(int n) {
		int tot = 0;
		int[] lpf = new int[n + 1];
		int u = n + 32;
		double lu = Math.log(u);
		int[] primes = new int[(int) (u / lu + u / lu / lu * 1.5)];
		for (int i = 2; i &lt;= n; i++)
			lpf[i] = i;
		for (int p = 2; p &lt;= n; p++) {
			if (lpf[p] == p)
				primes[tot++] = p;
			int tmp;
			for (int i = 0; i &lt; tot &amp;&amp; primes[i] &lt;= lpf[p] &amp;&amp; (tmp = primes[i] * p) &lt;= n; i++) {
				lpf[tmp] = primes[i];
			}
		}
		return lpf;
	}

	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new F().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.185
expert
----------
PROBLEM STATEMENT:
Allison loves graph theory and just started learning about Minimum Spanning Trees(MST). She has three integers, [expression], and uses them to construct a graph with the following properties:


The graph has [expression] undirected edges where each edge has a positive integer length.
No edge may directly connect a node to itself, and each pair of nodes can only be directly connected by at most one edge.
The graph is connected, meaning each node is reachable from any other node.
The value of the minimum spanning tree is [expression]. Value of the MST is the sum of all the lengths of all edges of which are part of the tree.
The sum of the lengths of all edges is as small as possible.


For example, let's say [expression]. The diagram belows shows a way to construct such a graph while keeping the lengths of all edges is as small as possible:



Here the sum of lengths of all edges is [expression].

Given [expression] graphs satisfying the conditions above, find and print the minimum sum of the lengths of all the edges in each graph on a new line.

Note: It is guaranteed that, for all given combinations of [expression], we can construct a valid graph.
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;
typedef long long ll;

void run()
{
    ll N, M, S;
    cin &gt;&gt; N &gt;&gt; M &gt;&gt; S;

    ll blen = S - (N - 2);
    ll nedge = ((N - 1) * (N - 2)) / 2;

    ll ans;
    if (M &gt; nedge)
    {
        ll bremain = M - nedge;
        if ((N - 1) * bremain &lt; M)
        {
            ans = nedge + (M - nedge) * blen;
        }
        else
        {
            ll cval = S - (N - 1);
            ans = M + (M * (cval / (N - 1)));
            cval %= N - 1;

            ll lval = cval * bremain;
            ll rval = 1e18;
            if (cval)
            {
                rval = bremain + (cval - 1) * (N - 2) - (cval - 1) * (cval - 2) / 2;
            }
            ans += min (lval, rval);
        }
    }
    else
    {
        ans = (M - 1) + blen;
    }
    cout &lt;&lt; ans &lt;&lt; "\n";
}

int main()
{
    int ntest; cin &gt;&gt; ntest;
    for (int test = 0; test &lt; ntest; test++)
        run();
}
----------
====================
----------
ALGORITHMS.186
medium
----------
PROBLEM STATEMENT:
Jack has just moved to a new city called Rapture. He wants to use the public public transport system. The fare rules are as follows:  


Each pair of connected stations has a fare assigned to it regardless of direction of travel.  
If a passenger travels from station A to station B, he only has to pay the  difference between the fare from A to B and the cumulative fare that he has paid to reach station A [fare(A,B) - total fare to reach station A].  If the difference is negative, he can travel free of cost from A to B.  


Jack is low on cash and needs your help to figure out the most cost efficient way to go from the first station to the last station. Given the number of stations [expression].  

For example, there are [expression] stations with undirected connections at the costs indicated:  

 
Travel from station [expression].  

Complete the program in the editor below.  It should print the cost of the lowest priced route from station [expression].  If there is no route, print NO PATH EXISTS.  

Function Description 
Complete the getCost function in the editor below.  It should print the cost of the lowest priced route from station [expression], or if there is no route, print NO PATH EXISTS.  There is no expected return value from the function.

getCost has the following parameters:


[expression]: an integer that represents the number of stations in the network  
[expression]: an array of integers that represent end stations of a bidirectional connection  
[expression]  
[expression]: an array of integers that represent the cost of travel between associated stations  

----------
TOP SOLUTION:
----------
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;math.h&gt;
#include&lt;string.h&gt;
#define fo(i,a,b) dfo(int,i,a,b)
#define fr(i,n) dfr(int,i,n)
#define fe(i,a,b) dfe(int,i,a,b)
#define fq(i,n) dfq(int,i,n)
#define nfo(i,a,b) dfo(,i,a,b)
#define nfr(i,n) dfr(,i,n)
#define nfe(i,a,b) dfe(,i,a,b)
#define nfq(i,n) dfq(,i,n)
#define dfo(d,i,a,b) for (d i = (a); i &lt; (b); i++)
#define dfr(d,i,n) dfo(d,i,0,n)
#define dfe(d,i,a,b) for (d i = (a); i &lt;= (b); i++)
#define dfq(d,i,n) dfe(d,i,1,n)
#define ffo(i,a,b) dffo(int,i,a,b)
#define ffr(i,n) dffr(int,i,n)
#define ffe(i,a,b) dffe(int,i,a,b)
#define ffq(i,n) dffq(int,i,n)
#define nffo(i,a,b) dffo(,i,a,b)
#define nffr(i,n) dffr(,i,n)
#define nffe(i,a,b) dffe(,i,a,b)
#define nffq(i,n) dffq(,i,n)
#define dffo(d,i,a,b) for (d i = (b)-1; i &gt;= (a); i--)
#define dffr(d,i,n) dffo(d,i,0,n)
#define dffe(d,i,a,b) for (d i = (b); i &gt;= (a); i--)
#define dffq(d,i,n) dffe(d,i,1,n)
#define ll long long
#define alok(n,t) ((t*)malloc((n)*sizeof(t)))
#define pf printf
#define sf scanf
#define pln pf("\n")


int *as;
int *bs;
int *cs;
int hcomp(const void *aa, const void *bb) {
	int a = *(int*)aa;
	int b = *(int*)bb;
	if (cs[a] != cs[b]) return (cs[a] &gt; cs[b]) - (cs[a] &lt; cs[b]);
	return a - b;
}
int *p;
int find(int n) {
	if (p[n] &lt; 0) return n;
	int pt = find(p[n]);
	p[n] = pt;
	return pt;
}
int main() {
	int n, e;
	sf("%d%d", &amp;n, &amp;e);
	p = alok(n, int);
	fr(i,n) p[i] = -1;
	as = alok(e, int);
	bs = alok(e, int);
	cs = alok(e, int);
	int *hs = alok(e, int);
	fr(i,e) {
		sf("%d%d%d", as + i, bs + i, cs + i);
		as[i]--;
		bs[i]--;
		hs[i] = i;
	}
	qsort(hs, e, sizeof(int), hcomp);
	int cost = 0;
	for (int i = 0; i &lt; e &amp;&amp; find(0) != find(n-1); i++) {
		int a = as[hs[i]];
		int b = bs[hs[i]];
		int c = cs[hs[i]];
		cost = c;
		a = find(a);
		b = find(b);
		if (a != b) {
			if (p[a] == p[b]) p[b]--;
			if (p[a] &gt; p[b]) p[a] = b; else p[b] = a;
		}
	}
	if (find(0) == find(n-1)) {
		pf("%d\n", cost);
	} else {
		pf("NO PATH EXISTS\n");
	}

}

----------
====================
----------
ALGORITHMS.187
medium
----------
PROBLEM STATEMENT:
A crab is an undirected graph which has two kinds of vertices: 1 head, and K feet , and exactly K edges which join the head to each of the feet.(&nbsp;1 &lt;= K &lt;= T, where T is given)

Given an undirected graph, you have to find in it some vertex-disjoint subgraphs where each one is a crab . The goal is to select those crabs in such a way that the total number of vertices covered by them is maximized.

Note: two graphs are vertex-disjoint if they do not have any vertices in common.&nbsp;
----------
TOP SOLUTION:
----------
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;

// the maximum number of vertices
#define NN 300
#define INF 10000000

// adjacency matrix (fill this up)
int cap[NN][NN];

// flow network
int fnet[NN][NN];

// BFS
int q[NN], qf, qb, prv[NN];

int fordFulkerson( int n, int s, int t )
{
    // init the flow network
    memset( fnet, 0, sizeof( fnet ) );

    int flow = 0;

    while( true )
    {
        // find an augmenting path
        memset( prv, -1, sizeof( prv ) );
        qf = qb = 0;
        prv[q[qb++] = s] = -2;
        while( qb &gt; qf &amp;&amp; prv[t] == -1 )
            for( int u = q[qf++], v = 0; v &lt; n; v++ )
                if( prv[v] == -1 &amp;&amp; fnet[u][v] - fnet[v][u] &lt; cap[u][v] )
                    prv[q[qb++] = v] = u;

        // see if we're done
        if( prv[t] == -1 ) break;

        // get the bottleneck capacity
        int bot = 0x7FFFFFFF;
        for( int v = t, u = prv[v]; u &gt;= 0; v = u, u = prv[v] )
            bot = min(bot, cap[u][v] - fnet[u][v] + fnet[v][u]);

        // update the flow network
        for( int v = t, u = prv[v]; u &gt;= 0; v = u, u = prv[v] )
            fnet[u][v] += bot;

        flow += bot;
    }

    return flow;
}

#define A(x) ((x) * 2 + 2)
#define B(x) ((x) * 2 + 3)
#define source 0
#define target 1

int c, n, m, t, a, b;

int main() {
    for(cin &gt;&gt; c; c--; ) {
        cin &gt;&gt; n &gt;&gt; t &gt;&gt; m;
        //cerr &lt;&lt; n &lt;&lt; " " &lt;&lt; t &lt;&lt; " " &lt;&lt; m &lt;&lt; endl;
        memset(cap, 0, sizeof cap);
        for(int i = 0; i &lt; m; i ++) {
            cin &gt;&gt; a &gt;&gt; b; a--; b--;
            cap[A(a)][B(b)] = INF;
            cap[A(b)][B(a)] = INF;
        }
        for(int i = 0; i &lt; n; i ++) {
            cap[source][A(i)] = t;
            cap[B(i)][target] = 1;
        }
        int result = fordFulkerson(2 * n + 2, source, target);
        cout &lt;&lt; result &lt;&lt; endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.188
advanced
----------
PROBLEM STATEMENT:
There are [expression] color. You want to make an ornament by joining all the beads together. You create the ornament by using the following algorithm:


Step #[expression] Arrange all the beads in any order such that beads of the same color are placed together.
Step #[expression] The ornament initially consists of only the first bead from the arrangement.
Step #[expression] For each subsequent bead in order, join it to a bead of the same color in the ornament. If there is no bead of the same color, it can be joined to any bead in the ornament.


All beads are distinct, even if they have the same color. How many different ornaments can be formed by following the above algorithm? Two ornaments are considered different if two beads are joined by a thread in one configuration, but not in the other.

Update/clarification

Think of the bead formation as a tree and not as a straight line. Any number of beads can be connected to a bead.
----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.List;

public class Solution {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";
	
	static void dfs(int n, int rd, int res, int[] dim, List&lt;int[]&gt; dims, int num)
	{
		if(res == 0){
			dim[n] = num;
			if(rd == 0)dims.add(Arrays.copyOf(dim, dim.length));
		}else{
			for(int i = 1;i &lt;= rd;i++){
				dim[n-res] = i;
				dfs(n, rd-i, res-1, dim, dims, num);
				num /= i;
			}
		}
	}
	
	static void solve()
	{
		List&lt;List&lt;int[]&gt;&gt; dist = new ArrayList&lt;List&lt;int[]&gt;&gt;();
		dist.add(null);
		dist.add(null);
		for(int i = 2;i &lt;= 10;i++){
			int f = 1;
			for(int j = 1;j &lt;= i-2;j++){
				f *= j;
			}
			List&lt;int[]&gt; dims = new ArrayList&lt;int[]&gt;();
			dfs(i, 2*(i-1), i, new int[i+1], dims, f);
			dist.add(dims);
		}
		
		int mod = 1000000007;
		for(int T = ni();T &gt;= 1;T--){
			int n = ni();
			int[] b = na(n);
			long ret = 1;
			if(n &gt; 1){
				for(int i = 0;i &lt; n;i++){
					ret = ret * pow(b[i], b[i]-2, mod) % mod;
				}
				
				long lsum = 0;
				for(int[] dim : dist.get(n)){
					long lmul = 1;
					for(int i = 0;i &lt; n;i++){
						lmul = lmul * pow(b[i], dim[i], mod) % mod;
					}
					lsum += lmul * dim[n] % mod;
				}
				lsum %= mod;
				ret = ret * lsum % mod;
			}else{
				ret = pow(b[0], b[0]-2, mod);
			}
			out.println(ret);
		}
	}
	
	public static long invl(long a, long mod)
	{
		long b = mod;
		long p = 1, q = 0;
		while(b &gt; 0){
			long c = a / b;
			long d;
			d = a; a = b; b = d % b;
			d = p; p = q; q = d - c * q;
		}
		return p &lt; 0 ? p + mod : p;
	}
	
	public static long pow(long a, long n, long mod)
	{
		long ret = 1;
		int x = 63-Long.numberOfLeadingZeros(n);
		for(;x &gt;= 0;x--){
			ret = ret * ret % mod;
			if(n&lt;&lt;63-x&lt;0)ret = ret * a % mod;
		}
		return ret;
	}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static boolean eof()
	{
		if(lenbuf == -1)return true;
		int lptr = ptrbuf;
		while(lptr &lt; lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;
		
		try {
			is.mark(1000);
			while(true){
				int b = is.read();
				if(b == -1){
					is.reset();
					return true;
				}else if(!isSpaceChar(b)){
					is.reset();
					return false;
				}
			}
		} catch (IOException e) {
			return true;
		}
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private static int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private static double nd() { return Double.parseDouble(ns()); }
	private static char nc() { return (char)skip(); }
	
	private static String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private static char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private static char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private static int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.189
medium
----------
PROBLEM STATEMENT:
Byteland has [expression] bidirectional roads. It is guaranteed that there is a route from any city to any other city. 

Jeanie is a postal worker who must deliver [expression] letters.

Note: The letters can be delivered in any order.
----------
TOP SOLUTION:
----------
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;limits&gt;
#include &lt;functional&gt;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus &gt; 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; inline void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; inline void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

pii dfs1(int i, int p, const vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; &amp;gw, const vector&lt;bool&gt; &amp;mark) {
	pii r = mark[i] ? mp(0, i) : mp(-INF, -1);
	each(j, gw[i]) if(j-&gt;first != p) {
		pii u = dfs1(j-&gt;first, i, gw, mark);
		if(u.second != -1)
			amax(r, mp(u.first + j-&gt;second, u.second));
	}
	return r;
}

int dfs2(int i, int p, const vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; &amp;gw, const vector&lt;bool&gt; &amp;mark) {
	int r = mark[i] ? 0 : -1;
	each(j, gw[i]) if(j-&gt;first != p) {
		int t = dfs2(j-&gt;first, i, gw, mark);
		if(t != -1) {
			if(r == -1) r = 0;
			r += t + j-&gt;second;
		}
	}
	return r;
}

int main() {
	int N; int K;
	while(~scanf("%d%d", &amp;N, &amp;K)) {
		vector&lt;bool&gt; mark(N);
		for(int i = 0; i &lt; K; ++ i) {
			int A;
			scanf("%d", &amp;A), -- A;
			mark[A] = true;
		}
		vector&lt;vector&lt;int&gt; &gt; g(N);
		vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; gw(N);
		for(int i = 0; i &lt; N - 1; ++ i) {
			int u, v, w;
			scanf("%d%d%d", &amp;u, &amp;v, &amp;w), -- u, -- v;
			g[u].push_back(v);
			g[v].push_back(u);
			gw[u].push_back(make_pair(v, w));
			gw[v].push_back(make_pair(u, w));
		}
		int a = find(all(mark), true) - mark.begin();
		int ans = 0;
		ans += dfs2(a, -1, gw, mark) * 2;
		int i = dfs1(a, -1, gw, mark).second;
		ans -= dfs1(i, -1, gw, mark).first;
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.190
hard
----------
PROBLEM STATEMENT:
Given a directed weighted graph where weight indicates distance, for each query, determine the length of the shortest path between nodes.  There may be many queries, so efficiency counts.  

For example, your graph consists of [expression] nodes as in the following:

  

A few queries are from node [expression]. 



There are two paths from [expression]:

[expression]  
[expression] 
In this case we choose path [expression].  
There is no path from [expression].  
There is one path from [expression]:  

[expression].  

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);
        String ve = stdIn.nextLine();
        String[] tmp = ve.split(" ");
        int V = Integer.parseInt(tmp[0]);
        int E = Integer.parseInt(tmp[1]);
        int[][] graph = new int[V+1][V+1];
        
        for(int i=1;i&lt;=V;i++){
            for(int j=1;j&lt;=V;j++){
                if(i==j){
                    graph[i][j] = 0;
                }
                else{
                    graph[i][j] = 140000; 
                }
            }
        }
        
        for(int i=0;i&lt;E;i++){
            String inp_edge = stdIn.nextLine();
            String[] temp = inp_edge.split(" ");
            int v1 = Integer.parseInt(temp[0]);
            int v2 = Integer.parseInt(temp[1]);
            int w = Integer.parseInt(temp[2]);
            
            graph[v1][v2] = w;
        }
        
        for(int k=1;k&lt;=V;k++){
            for(int i=1;i&lt;=V;i++){
                for(int j=1;j&lt;=V;j++){
                    graph[i][j] = Math.min(graph[i][k]+graph[k][j],graph[i][j]);
                }
            }
        }
        int Q = stdIn.nextInt();
        String buffer = stdIn.nextLine();
        for(int i=0;i&lt;Q;i++){
            String inp_edge = stdIn.nextLine();
            String[] temp = inp_edge.split(" ");
            int v1 = Integer.parseInt(temp[0]);
            int v2 = Integer.parseInt(temp[1]);
            if(graph[v1][v2]&gt;130000)
                System.out.println("-1");
            else
                System.out.println(graph[v1][v2]);
        }
    }
}
----------
====================
----------
ALGORITHMS.191
medium
----------
PROBLEM STATEMENT:
John lives in HackerLand, a country with [expression] raised to some exponent). It's possible for John to reach any city from any other city.

Given a map of HackerLand, can you help John determine the sum of the minimum distances between each pair of cities? Print your answer in binary representation. 
----------
TOP SOLUTION:
----------

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Comparator;
import java.util.InputMismatchException;

public class C {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	void solve()
	{
		int n = ni();
		int m = ni();
		int[][] es = new int[m][];
		for(int i = 0;i &lt; m;i++){
			es[i] = new int[]{ni()-1, ni()-1, ni()};
		}
		Arrays.sort(es, new Comparator&lt;int[]&gt;() {
			public int compare(int[] a, int[] b) {
				return a[2] - b[2];
			}
		});
		DJSet ds = new DJSet(n);
		int[] ff = new int[n-1];
		int[] tt = new int[n-1];
		int[] ww = new int[n-1];
		int q = 0;
		for(int i = 0;i &lt; m;i++){
			if(!ds.equiv(es[i][0], es[i][1])){
				ds.union(es[i][0], es[i][1]);
				ff[q] = es[i][0];
				tt[q] = es[i][1];
				ww[q] = es[i][2];
				q++;
			}
		}
		assert q == n-1;
		int[][][] g = packWU(n, ff, tt, ww);
		int[][] pars = parents(g, 0);
		int[] par = pars[0], ord = pars[1], dep = pars[2], pw = pars[4];
		int[] des = new int[n];
		for(int i = n-1;i &gt;= 0;i--){
			int cur = ord[i];
			des[cur]++;
			if(i &gt; 0)des[par[cur]] += des[cur];
		}
		long[] plus = new long[m];
		for(int i = 1;i &lt; n;i++){
			plus[pw[i]] = (long)des[i]*(n-des[i]);
		}
		char[] ret = new char[m+100];
		Arrays.fill(ret, '0');
		long s = 0;
		for(int i = 0;i &lt; m+100;i++){
			if(i &lt; m)s += plus[i];
			ret[m+99-i] = (char)('0'+(s&amp;1));
			s &gt;&gt;&gt;= 1;
		}
		boolean f = true;
		for(char c : ret){
			if(c == '1'){
				out.print(c);
				f = false;
			}else if(!f){
				out.print(c);
			}
		}
		out.println();
	}
	
	public static int[][] parents(int[][][] g, int root) {
		int n = g.length;
		int[] par = new int[n];
		Arrays.fill(par, -1);
		int[] dw = new int[n];
		int[] pw = new int[n];
		int[] dep = new int[n];

		int[] q = new int[n];
		q[0] = root;
		for (int p = 0, r = 1; p &lt; r; p++) {
			int cur = q[p];
			for (int[] nex : g[cur]) {
				if (par[cur] != nex[0]) {
					q[r++] = nex[0];
					par[nex[0]] = cur;
					dep[nex[0]] = dep[cur] + 1;
					dw[nex[0]] = dw[cur] + nex[1];
					pw[nex[0]] = nex[1];
				}
			}
		}
		return new int[][] { par, q, dep, dw, pw };
	}

	
	public static int[][][] packWU(int n, int[] from, int[] to, int[] w) {
		int[][][] g = new int[n][][];
		int[] p = new int[n];
		for (int f : from)
			p[f]++;
		for (int t : to)
			p[t]++;
		for (int i = 0; i &lt; n; i++)
			g[i] = new int[p[i]][2];
		for (int i = 0; i &lt; from.length; i++) {
			--p[from[i]];
			g[from[i]][p[from[i]]][0] = to[i];
			g[from[i]][p[from[i]]][1] = w[i];
			--p[to[i]];
			g[to[i]][p[to[i]]][0] = from[i];
			g[to[i]][p[to[i]]][1] = w[i];
		}
		return g;
	}

	
	

	
	public static class DJSet {
		public int[] upper;

		public DJSet(int n) {
			upper = new int[n];
			Arrays.fill(upper, -1);
		}

		public int root(int x) {
			return upper[x] &lt; 0 ? x : (upper[x] = root(upper[x]));
		}

		public boolean equiv(int x, int y) {
			return root(x) == root(y);
		}

		public boolean union(int x, int y) {
			x = root(x);
			y = root(y);
			if (x != y) {
				if (upper[y] &lt; upper[x]) {
					int d = x;
					x = y;
					y = d;
				}
				upper[x] += upper[y];
				upper[y] = x;
			}
			return x == y;
		}

		public int count() {
			int ct = 0;
			for (int u : upper)
				if (u &lt; 0)
					ct++;
			return ct;
		}
	}

	static int[][] packU(int n, int[] from, int[] to) {
		int[][] g = new int[n][];
		int[] p = new int[n];
		for (int f : from)
			p[f]++;
		for (int t : to)
			p[t]++;
		for (int i = 0; i &lt; n; i++)
			g[i] = new int[p[i]];
		for (int i = 0; i &lt; from.length; i++) {
			g[from[i]][--p[from[i]]] = to[i];
			g[to[i]][--p[to[i]]] = from[i];
		}
		return g;
	}
	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new C().run(); }
	
	private byte[] inbuf = new byte[1024];
	private int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.192
hard
----------
PROBLEM STATEMENT:
It has been a prosperous year for King Charles and he is rapidly expanding his empire. In fact, he recently invaded his neighboring country and set up a new kingdom! This kingdom has many cities connected by one-way roads. To ensure higher connectivity, two cities are sometimes directly linked by more than one road.

In the new kingdom, King Charles has made one of the cities his financial capital and another city his warfare capital. He wants a better connectivity between these two capitals. The connectivity of a pair of cities, [expression]. A path may use a road more than once if possible. Two paths are considered different if they do not use the same sequence of roads the same number of times.

There are [expression].   

Note: Two roads may connect the same cities, but they are still considered distinct for path connections. 

For example, there are [expression] roads as shown in the following graph:

  

There are two direct paths and one cyclic path.  Direct paths are [expression]4 \rightarrow 3$ did not exist, there would be only the two direct paths.

Function Description

Complete the countPaths function in the editor below.  It should print your result, modulo [expression] if there are limited paths or INFINITE PATHS if they are unlimited. There is no expected return value.   

countPaths has the following parameters: 
- n: the integer number of cities 
- edges: a 2D integer array where [expression]   
----------
TOP SOLUTION:
----------

import java.awt.Point;
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import static java.lang.Math.*;

public class Solution {
    BufferedReader in;
    PrintWriter out;
    StringTokenizer tok = new StringTokenizer("");

    public static void main(String[] args) {
        new Solution().run();
    }

    public void run() {
        try {
            long t1 = System.currentTimeMillis();
                in = new BufferedReader(new InputStreamReader(System.in));
                out = new PrintWriter(System.out);
            
            Locale.setDefault(Locale.US);
            solve();
            in.close();
            out.close();
            long t2 = System.currentTimeMillis();
            System.err.println("Time = " + (t2 - t1));
        } catch (Throwable t) {
            t.printStackTrace(System.err);
            System.exit(-1);
        }
    }

    String readString() throws IOException {
        while (!tok.hasMoreTokens()) {
            tok = new StringTokenizer(in.readLine());
        }
        return tok.nextToken();
    }

    int readInt() throws IOException {
        return Integer.parseInt(readString());
    }

    long readLong() throws IOException {
        return Long.parseLong(readString());
    }

    double readDouble() throws IOException {
        return Double.parseDouble(readString());
    }

    // solution
    void invertEdges() {
        ArrayList&lt;Edge&gt; edgesContainer = new ArrayList&lt;Edge&gt;(m);
        for (int i = 0; i &lt; n; i++) {
            for (Edge edge = first[i]; edge != null; edge = edge.next) {
                edgesContainer.add(edge);
            }
        }
        Arrays.fill(first, null);
        for (int i = 0; i &lt; edgesContainer.size(); i++) {
            Edge edge = new Edge(edgesContainer.get(i).b, edgesContainer.get(i).a, first);
        }
    }
    int n;
    int m;
    Edge[] first;

    void dfs(int source, boolean[] visited) {
        if (visited[source]) {
            return;
        }
        visited[source] = true;
    //    out.println("visiting " + source);
        for (Edge edge = first[source]; edge != null; edge = edge.next) {
            dfs(edge.b, visited);
        }
    }
    long modulo = 1000000000L;

    void solve() throws IOException {
        n = readInt();
        m = readInt();
        first = new Edge[n];
        for (int i = 0; i &lt; m; i++) {
            int a = readInt() - 1;
            int b = readInt() - 1;
            Edge edge = new Edge(a, b, first);
        }

        boolean[] visitedA = new boolean[n];
        boolean[] visitedB = new boolean[n];
        boolean[] importantNode = new boolean[n];
        dfs(0, visitedA);
        invertEdges();
      //  out.println("----");
        dfs(n - 1, visitedB);
        invertEdges();

        for (int i = 0; i &lt; n; i++) {
            importantNode[i] = visitedA[i] &amp;&amp; visitedB[i];
        }

        int[] counter = new int[n];
        long[] f = new long[n];
        for (int i = 0; i &lt; n; i++) {
            if (importantNode[i]) {
                for (Edge edge = first[i]; edge != null; edge = edge.next) {
                    if (importantNode[edge.b]) {
                        counter[edge.b]++;
                    }
                }
            }
        }
        f[0] = 1;
        counter[0] = 1;
        calculateNumberOfPaths(0, n - 1, counter, f);
        if (importantNode[n - 1] //if there is a path from 0 to n - 1
                &amp;&amp; counter[n - 1] != 0)//then there is a cycle, probably
        {
            out.println("INFINITE PATHS");
        } else {
            out.println(f[n - 1]);
        }
    }

    private void calculateNumberOfPaths(int source, int target, int[] counter, long[] f) {
        counter[source]--;
        if (counter[source] == 0) {
            for (Edge edge = first[source]; edge != null; edge = edge.next) {
                f[edge.b] = (f[edge.b] + f[edge.a]) % modulo;
                calculateNumberOfPaths(edge.b, target, counter, f);
            }
        }
    }
}

class Edge {

    int a;
    int b;
    Edge next;

    Edge(int a, int b, Edge[] edgeTable) {
        this.a = a;
        this.b = b;
        next = edgeTable[a];
        edgeTable[a] = this;
    }
}
----------
====================
----------
ALGORITHMS.193
hard
----------
PROBLEM STATEMENT:
Sophia is playing a game on the computer. There are two random arrays A &amp; B, each having the same number of elements. The game begins with Sophia removing a pair (Ai, Bj) from the array if they are not co-prime. She keeps a count on the number of times this operation is done. 

Sophia wants to find out the maximal number of times(S) she can do this on the arrays. Could you help Sophia find the value?
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class Solution {

    private static int[][] ps, qs;

    static int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }

    static HashMap&lt;Integer, Integer&gt; pIds = new HashMap&lt;Integer, Integer&gt;();

    static int pId(int p) {
        if (!pIds.containsKey(p)) {
            pIds.put(p, pIds.size());
        }
        return pIds.get(p);
    }

    public static void solve(Input in, PrintWriter out) throws IOException {
        Random rnd = new Random(42);
        int n = in.nextInt();
        int[] a = new int[n];
        int[] b = new int[n];
        for (int i = 0; i &lt; n; ++i) {
            a[i] = in.nextInt();
        }
        for (int i = 0; i &lt; n; ++i) {
            b[i] = in.nextInt();
        }/**/
        /*for (int i = 0; i &lt; n; ++i) {
            a[i] = rnd.nextInt(1000000000) + 2;
        }
        for (int i = 0; i &lt; n; ++i) {
            b[i] = rnd.nextInt(1000000000) + 2;
        }/**/
        long time0 = System.currentTimeMillis();
        boolean[] isPrime = new boolean[31624];
        Arrays.fill(isPrime, true);
        int primesCount = 0;
        for (int i = 2; i &lt; isPrime.length; ++i) {
            if (isPrime[i]) {
                primesCount++;
                for (int j = i * i; j &lt; isPrime.length; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        int[] primes = new int[primesCount];
        primesCount = 0;
        for (int i = 2; i &lt; isPrime.length; ++i) {
            if (isPrime[i]) {
                primes[primesCount++] = i;
            }
        }
        ps = new int[n][];
        for (int it = 0; it &lt; n; ++it) {
            int x = a[it];
            ArrayList&lt;Integer&gt; psList = new ArrayList&lt;Integer&gt;();
            for (int i = 0; i &lt; primes.length &amp;&amp; primes[i] * primes[i] &lt;= x; ++i) {
                if (x % primes[i] == 0) {
                    psList.add(primes[i]);
                }
                while (x % primes[i] == 0) {
                    x /= primes[i];
                }
            }
            if (x &gt; 1) {
                psList.add(x);
            }
            ps[it] = new int[psList.size()];
            for (int i = 0; i &lt; psList.size(); ++i) {
                ps[it][ps[it].length - i - 1] = pId(psList.get(i));
            }
        }
        List&lt;Integer&gt;[] qsList = new List[pIds.size()];
        for (int i = 0; i &lt; pIds.size(); ++i) {
            qsList[i] = new ArrayList&lt;Integer&gt;();
        }
        for (int it = 0; it &lt; n; ++it) {
            int x = b[it];
            for (int i = 0; i &lt; primes.length &amp;&amp; primes[i] * primes[i] &lt;= x; ++i) {
                if (x % primes[i] == 0 &amp;&amp; pIds.containsKey(primes[i])) {
                    qsList[pIds.get(primes[i])].add(it);
                }
                while (x % primes[i] == 0) {
                    x /= primes[i];
                }
            }
            if (x &gt; 1 &amp;&amp; pIds.containsKey(x)) {
                qsList[pIds.get(x)].add(it);
            }
        }
        qs = new int[qsList.length][];
        for (int i = 0; i &lt; qsList.length; ++i) {
            qs[i] = new int[qsList[i].size()];
            for (int j = 0; j &lt; qs[i].length; ++j) {
                qs[i][j] = qsList[i].get(j);
            }
        }
        int[] dx = new int[n];
        int[] dy = new int[n];
        Arrays.fill(dx, -1);
        Arrays.fill(dy, -1);
        int ans = 0;
        int[] col = new int[n];
        int[] col2 = new int[pIds.size()];
        int cc = 1;
        for (int i = 0; i &lt; n; ++i) {
            if (dfs(i, a, b, dx, dy, col, col2, cc)) {
                ans++;
                cc++;
            }
//            System.out.println(i);
        }
        out.println(ans);
        System.err.println(System.currentTimeMillis() - time0);
    }

    private static boolean dfs(int i, int[] a, int[] b, int[] dx, int[] dy, int[] col, int[] col2, int cc) {
        if (col[i] == cc) {
            return false;
        }
        col[i] = cc;
        for (int p : ps[i]) {
            if (col2[p] == cc) {
                continue;
            }
            for (int j : qs[p]) {
                if (dy[j] == -1) {
                    dx[i] = j;
                    dy[j] = i;
                    return true;
                }
            }
        }
        for (int p : ps[i]) {
            if (col2[p] == cc) {
                continue;
            }
            col2[p] = cc;
            for (int j : qs[p]) {
                if (dx[i] != j &amp;&amp; dfs(dy[j], a, b, dx, dy, col, col2, cc)) {
                    dx[i] = j;
                    dy[j] = i;
                    return true;
                }
            }
        }
        return false;
    }

    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);
        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);
        out.close();
    }

    static class Input {
        BufferedReader in;
        StringBuilder sb = new StringBuilder();

        public Input(BufferedReader in) {
            this.in = in;
        }

        public Input(String s) {
            this.in = new BufferedReader(new StringReader(s));
        }

        public String next() throws IOException {
            sb.setLength(0);
            while (true) {
                int c = in.read();
                if (c == -1) {
                    return null;
                }
                if (" \n\r\t".indexOf(c) == -1) {
                    sb.append((char)c);
                    break;
                }
            }
            while (true) {
                int c = in.read();
                if (c == -1 || " \n\r\t".indexOf(c) != -1) {
                    break;
                }
                sb.append((char)c);
            }
            return sb.toString();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }
}

----------
====================
----------
ALGORITHMS.194
medium
----------
PROBLEM STATEMENT:
Detective Rust is investigating a homicide and he wants to chase down the murderer. The murderer knows he would definitely get caught if he takes the main roads for fleeing, so he uses the village roads (or side lanes) for running away from the crime scene.

Rust knows that the murderer will take village roads and he wants to chase him down. He is observing the city map, but it doesn't show the village roads (or side lanes) on it and shows only the main roads. 

The map of the city is a graph consisting [expression] iff(if and only if) there is no city road between them.  

In this problem, distance is calculated as number of village roads (side lanes) between any two places in the city.

Rust wants to calculate the shortest distance from his position (Node [expression]) to all the other places in the city if he travels only using the village roads (side lanes).

Note: The graph/map of the city is ensured to be a sparse graph.
----------
TOP SOLUTION:
----------
/*
*/
 
//#pragma comment(linker, "/STACK:16777216")
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;
#include &lt;memory.h&gt;
#include &lt;ctime&gt; 
 
#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
 
#define eps 1e-9
//#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 256
#define right adsgasgadsg
#define free adsgasdg
#define MAG 10000

using namespace std;

set&lt;long&gt; edges[1&lt;&lt;20],active,todel;
queue&lt;long&gt; qu;
long d[1&lt;&lt;20],a,b,n,m,tests;
long S,temp,val;
set&lt;long&gt;::iterator it;
vector&lt;long&gt; ans;

int main(){
//freopen("evacuation.in","r",stdin);
//freopen("evacuation.out","w",stdout);
//freopen("input.txt","r",stdin);
//freopen("output.txt","w",stdout);
ios_base::sync_with_stdio(0);
//cin.tie(0);

cin&gt;&gt;tests;
for (;tests;--tests)
{
 cin&gt;&gt;n&gt;&gt;m;
 for (int i=1;i&lt;=n;i++) 
  edges[i].clear();
 for (int i=1;i&lt;=n;i++)
  active.insert(i);
 for (int i=1;i&lt;=m;i++)
 {
  cin&gt;&gt;a&gt;&gt;b;
  edges[a].insert(b);
  edges[b].insert(a);
 }
 for (int i=1;i&lt;=n;i++)
  d[i]=1e9;
 cin&gt;&gt;S;
 d[S]=0;
 qu.push(S);
 while (qu.size())
 {
  temp=qu.front();
  qu.pop();
  for (it=active.begin();it!=active.end();it++)
  {
   val=(*it);
   if (edges[temp].find(val)!=edges[temp].end())
    continue;
   todel.insert(val);
   qu.push(val);
   d[val]=min(d[val],d[temp]+1);
  }
  for (it=todel.begin();it!=todel.end();it++)
   active.erase(*it);
  todel.clear();
 }
 
 ans.clear();
 for (int i=1;i&lt;=n;i++)
  if (i!=S) 
   ans.push_back(d[i]);
 
 for (int i=0;i&lt;ans.size();i++)
 {
     if (i)cout&lt;&lt;" ";
     cout&lt;&lt;ans[i];
 }
 cout&lt;&lt;endl;
}
cin.get();cin.get();
return 0;}

----------
====================
----------
ALGORITHMS.195
hard
----------
PROBLEM STATEMENT:
There are N problems numbered 1..N which you need to complete. You've arranged the problems in increasing difficulty order, and the ith problem has estimated difficulty level i. You have also assigned a rating vi to each problem. Problems with similar vi values are similar in nature. On each day, you will choose a subset of the problems and solve them. You've decided that each subsequent problem solved on the day should be tougher than the previous problem you solved on that day. Also, to make it less boring, consecutive problems you solve should differ in their vi rating by at least K. What is the least number of days in which you can solve all problems?
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

using namespace std;

int N,K;
int v[310],match[310],inv[310];
vector&lt;int&gt; adj[310];
bool vis[310];

bool augment(int x)
{
	if(vis[x])return false;
	vis[x] = true;
	for(int i = 0; i &lt; adj[x].size(); i++)
	{
		if((inv[adj[x][i]] == -1 || augment(inv[adj[x][i]])))
		{
			match[x] = adj[x][i];
			inv[adj[x][i]] = x;
			return true;
		}
	}
	return false;
}

int main()
{
	int T;
	cin &gt;&gt; T;
	for(int t = 0; t &lt; T; t++)
	{
		cin &gt;&gt; N &gt;&gt; K;
		for(int i = 0; i &lt; N; i++)
		{
			adj[i].clear();
			cin &gt;&gt; v[i];
		}
		for(int i = 0; i &lt; N; i++)
		{
			for(int j = i+1; j &lt; N; j++)
			{
				if(abs(v[i]-v[j]) &gt;= K)
				{
					adj[i].push_back(j);
				}
			}
		}
		memset(match,-1,sizeof(match));
		memset(inv,-1,sizeof(inv));
		int ans = 0;
		for(int i = 0; i &lt; N; i++)
		{
			if(match[i] == -1)
			{
				memset(vis,false,sizeof(vis));
				augment(i);
			}
		}
		for(int i = 0; i &lt; N; i++)
		{
			if(inv[i] == -1)ans++;
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.196
hard
----------
PROBLEM STATEMENT:
Fedya is a seasoned traveller and is planning his trip to Treeland. Treeland is a country with an ancient road system which is in the form of a tree structure. [expression].

Fedya has not yet decided the starting point (city) of his journey and the cities he will visit. But there are a few things you know about Fedya's trip:


Fedya is fond of travelling to great distances. So if he is currently located in city [expression].
There might be more than 1 such cities. In that case, Fedya will choose a city that was already visited as less times as possible in this journey.
There still might be more than 1 such cities. In that case, Fedya will go to the city with the smallest number.


Fedya has prepared a list of [expression]. For each of them, he is keen to know the total distance travelled by him.
----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;

#define REP(i,a,b) for(i=a;i&lt;b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

#define ll long long
#define ull unsigned ll

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'&lt;=k&amp;&amp;k&lt;='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k&lt;'0'||k&gt;'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'&lt;=k&amp;&amp;k&lt;='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k&lt;'0'||k&gt;'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
int reader(char c[]){int i,s=0;for(;;){mygc(i);if(i!=' '&amp;&amp;i!='\n'&amp;&amp;i!='\r'&amp;&amp;i!='\t'&amp;&amp;i!=EOF) break;}c[s++]=i;for(;;){mygc(i);if(i==' '||i=='\n'||i=='\r'||i=='\t'||i==EOF) break;c[s++]=i;}c[s]='\0';return s;}
template &lt;class T, class S&gt; void reader(T *x, S *y){reader(x);reader(y);}
template &lt;class T, class S, class U&gt; void reader(T *x, S *y, U *z){reader(x);reader(y);reader(z);}
template &lt;class T, class S, class U, class V&gt; void reader(T *x, S *y, U *z, V *w){reader(x);reader(y);reader(z);reader(w);}

void writer(int x, char c){int s=0,m=0;char f[10];if(x&lt;0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(ll x, char c){int s=0,m=0;char f[20];if(x&lt;0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}
void writer(const char x[], char c){int i;for(i=0;x[i]!='\0';i++)mypc(x[i]);mypc(c);}
template&lt;class T&gt; void writerLn(T x){writer(x,'\n');}
template&lt;class T, class S&gt; void writerLn(T x, S y){writer(x,' ');writer(y,'\n');}
template&lt;class T, class S, class U&gt; void writerLn(T x, S y, U z){writer(x,' ');writer(y,' ');writer(z,'\n');}
template&lt;class T&gt; void writerArr(T x[], int n){int i;if(!n){mypc('\n');return;}rep(i,n-1)writer(x[i],' ');writer(x[n-1],'\n');}

#define MD 1000000007

void* setUndirectEdge(int N, int M, int A[], int B[], int **es, int ***edge, void *workMemory){int i;*es=(int*)workMemory;*edge=(int**)((*es)+N);(*edge)[0]=(int*)((*edge)+N);rep(i,N)(*es)[i]=0;rep(i,M)(*es)[A[i]]++,(*es)[B[i]]++;REP(i,1,N)(*edge)[i]=(*edge)[i-1]+(*es)[i-1];workMemory=(void*)((*edge)[N-1]+(*es)[N-1]);rep(i,N)(*es)[i]=0;rep(i,M)(*edge)[A[i]][(*es)[A[i]]++]=B[i],(*edge)[B[i]][(*es)[B[i]]++]=A[i];return workMemory;}

int N, M;
int *es, **edge;

int A[110000], B[110000];

int dist[110000];
int dist1[110000], dist2[110000];

void dfs(int now, int d, int bef){
  int i, j, k;
  dist[now] = d;
  rep(i,es[now]){
    k = edge[now][i];
    if(k==bef) continue;
    dfs(k,d+1,now);
  }
}

int main(){
  int i, j, k, V, K;
  int v1, v2, mx;
  ll res, mxd;
  void *mem = malloc(10000000);

  reader(&amp;N, &amp;M);
  rep(i,N-1) reader(A+i,B+i), A[i]--, B[i]--;
  setUndirectEdge(N,N-1,A,B,&amp;es,&amp;edge,mem);

  dfs(0,0,-1);
  mx = 0;
  rep(i,N) if(mx &lt; dist[i]) mx = dist[i], v1 = i;

  dfs(v1,0,-1);
  mx = 0;
  rep(i,N) if(mx &lt; dist[i]) mx = dist[i], v2 = i;
  rep(i,N) dist1[i] = dist[i];

  dfs(v2,0,-1);
  rep(i,N) dist2[i] = dist[i];

  mxd = 0;
  rep(i,N) if(mxd &lt; dist2[i]) mxd = dist2[i];

  while(M--){
    reader(&amp;V,&amp;K); V--;
    res = max(dist1[V], dist2[V]) + (K-1) * mxd;
    writerLn(res);
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.197
hard
----------
PROBLEM STATEMENT:
The kingdom of Zion has cities connected by bidirectional roads.  There is a unique path between any pair of cities. Morpheus has found out that the machines are planning to destroy the whole kingdom.  If two machines can join forces, they will attack.  Neo has to destroy roads connecting cities with machines in order to stop them from joining forces.  There must not be any path connecting two machines.

Each of the roads takes an amount of time to destroy, and only one can be worked on at a time.  Given a list of edges and times, determine the minimum time to stop the attack.

For example, there are [expression].  

  

Function Description

Complete the function minTime in the editor below.  It must return an integer representing the minimum time to cut off access between the machines.

minTime has the following parameter(s):


roads: a two-dimensional array of integers, each [expression] to destroy  
machines: an array of integers representing cities with machines  

----------
TOP SOLUTION:
----------
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;list&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;fstream&gt;
#include&lt;sstream&gt;
#include&lt;algorithm&gt;
#include&lt;numeric&gt;
#include&lt;cmath&gt;
#include&lt;climits&gt;
#include&lt;ctime&gt;
using namespace std;
#define rp(i,a,b) for(int i = (a); i &lt; (b); i++)
#define rrp(i,a,b)for(int i = (b); i &gt;= (a); i--)
#define ri(it,x) for(typeof(x.begin()) it=x.begin();it!=x.end();++it)
#define pb push_back
#define all(x) (x).begin(),(x).end()
#define cl(x,with) memset(x,with,sizeof(x))
#define sz(v) (v).size()
#define ll long long int
#define ii pair&lt;int,int&gt;
#define mp make_pair
#define vi vector&lt;int&gt;
#define vs vector&lt;string&gt;

#define MAX 600000

int parent[MAX];
int cnt[MAX];
int mark[MAX];
int fp(int v){
	while(parent[v] != v)
		v = parent[v];
	return v;
}
bool unite(int x, int y){
	int p1 = fp(x);
	int p2 = fp(y);
	if(p1 != p2 &amp;&amp; !(mark[p1] == 1 &amp;&amp; mark[p2] == 1)){
	
		if(cnt[p1] &gt; cnt[p2]){
			parent[p2] = p1;
			cnt[p1] += cnt[p2];
			if(mark[p1] == 1 || mark[p2] == 1)
				mark[p1] = 1;
		}
		else{
			parent[p1] = p2;
			cnt[p2] += cnt[p1];
			if(mark[p1] == 1 || mark[p2] == 1)
				mark[p2] = 1;
		}
		return 1;
	}
	return 0;
}


int main(){
	
	int n, m, k;
	cin &gt;&gt; n &gt;&gt; k; m = n-1;
	vector&lt; pair&lt;int, pair&lt;int,int&gt; &gt; &gt;edge;
	int wt = 0;
	rp(i,0,n-1){
		int x,y,z;
		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
		wt += z;
		edge.pb(mp(z,mp(x,y)));
	}	
	sort(all(edge));
	reverse(all(edge));
	
	int tmp;
	rp(i,0,n){
		mark[i] = 0;
		parent[i] = i;
	}
	rp(i,0,k){
		cin &gt;&gt; tmp;
		mark[tmp] = 1;
	}
	rp(i,0,n-1){
		int x,y,z;
		x = edge[i].second.first;
		y = edge[i].second.second;
		z = edge[i].first;
		bool res = unite(x,y);
		wt -= res*z;
	}
	cout &lt;&lt; wt &lt;&lt; "\n";
	return 0;
}


----------
====================
----------
ALGORITHMS.198
hard
----------
PROBLEM STATEMENT:
Dave is a die-hard fan of a show called "HackerRank", in which a young programmer uses her problem-solving abilities to solve crimes. He splurged on a Digital Video Recorder (DVR) so that he can record HackerRank episodes and watch them later. Luckily, Dave managed to get his hands on schedules for all the episodes in each upcoming season.

Each season has [expression] is its end time. All times are given as integers representing the number of minutes passed since the start of the season.

Episodes broadcast on multiple channels, so some of the air times overlap and the episodes may not broadcast sequentially. It's possible that both the live and repeat broadcasts of some episode [expression]. In addition, live and repeat broadcasts of the same episode may differ in length due to the number of advertisements during the broadcast. 

Dave only has one TV with a DVR attached to it, and the DVR is capable of recording one episode at a time. For each episode in a season, Dave first decides whether or not he will record it. If he decides to record it, he will either record it during [expression]. Dave will only ever record one of the two airings of an episode, and he always records full episodes. This means that once he starts recording an episode, he will always record it until the end (i.e., he never records partial episodes). 

Dave realizes that it might not be possible for him to record all episodes successfully, so instead of focusing on recording all episodes of HackerRank (which may be impossible), he decides to record all consecutively airing episodes whose episode number occurs in some inclusive [expression] (i.e., the number of consecutive episodes recorded) is as large as possible.   

Given the programming schedule for each season, find [expression] value.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I &lt; (N); ++I)
#define REPP(I, A, B) for (int I = (A); I &lt; (B); ++I)
#define RI(X) scanf("%d", &amp;(X))
#define RII(X, Y) scanf("%d%d", &amp;(X), &amp;(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &amp;(X), &amp;(Y), &amp;(Z))
#define DRI(X) int (X); scanf("%d", &amp;X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &amp;X, &amp;Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &amp;X, &amp;Y, &amp;Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &amp;___T); while (___T-- &gt; 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define PII pair&lt;int,int&gt;
#define VI vector&lt;int&gt;
#define VPII vector&lt;pair&lt;int,int&gt; &gt;
#define PLL pair&lt;long long,long long&gt;
#define VPLL vector&lt;pair&lt;long long,long long&gt; &gt;
#define F first
#define S second
typedef long long LL;
using namespace std;
const int MOD = 1e9+7;
const int SIZE = 1e6+10;
struct SCC{
    int n,used[SIZE],order[SIZE],gg[SIZE];
    vector&lt;int&gt;e[SIZE],ae[SIZE],ge[SIZE],emp;
    int id,gn;
    void init(int _n){
        n=_n;
        memset(used,0,sizeof(int)*n);
        REP(i,n){
            e[i]=ae[i]=ge[i]=emp;
        }
    }
    void add_edge(int x,int y){
        e[x].PB(y^1);
        ae[y^1].PB(x);
        e[y].PB(x^1);
        ae[x^1].PB(y);
    }
    void dfs1(int x){
        if(used[x]==1)return;
        used[x]=1;
        REP(i,SZ(e[x])){
            int y=e[x][i];
            dfs1(y);
        }
        order[--id]=x;
    }
    void dfs2(int x){
        if(used[x]==2)return;
        gg[x]=gn;
        used[x]=2;
        REP(i,SZ(ae[x])){
            int y=ae[x][i];
            if(used[y]!=2)dfs2(y);
        }
    }
    bool good(){
        gn=0;
        id=n;
        REP(i,n)
            dfs1(i);
        REP(i,n){
            if(used[order[i]]!=2){
                dfs2(order[i]);
                gn++;
            }
        }
        REP(i,n){
            if(gg[i]==gg[i^1])return 0;
            i++;
        }
        return 1;
    }
}scc;
int input[100][2][2];
bool XX(int x1,int y1,int x2,int y2){
    return !((y1&lt;x2)||(y2&lt;x1));
}
int main(){
    CASET{
        DRI(n);
        REP(i,n)REP(j,4)RI(input[i][j&gt;&gt;1][j&amp;1]);
        int rr=1;
        int an1=1,an2=0;
        REP(i,n){
            if(i+an1&gt;=n)break;
            while(rr&lt;n){
                scc.init((rr-i)*2+2);
                REPP(k2,i,rr+1)
                    REPP(k1,i,k2){
                        REP(j1,2)REP(j2,2){
                            if(XX(input[k1][j1][0],input[k1][j1][1],input[k2][j2][0],input[k2][j2][1])){
                                scc.add_edge((k1-i)*2+j1,(k2-i)*2+j2);
                            }
                        }
                    }
                if(!scc.good())break;
                else rr++;
            }
            if(rr-i&gt;an1){an1=rr-i;an2=i;}
        }
        an2++;
        printf("%d %d\n",an2,an2+an1-1);
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.199
hard
----------
PROBLEM STATEMENT:
The country of Byteland contains [expression] bidirectional roads. There is a path between any two cities. The roads in Byteland were built long ago, and now they are in need of repair. You have been hired to fix all the roads. You intend to do this by dispatching robots on some of the roads. Each robot will repair the road he is currently on and then moves to one of the adjacent unrepaired roads. After repairing that, it will move to another adjacent unrepaired road, repair that and so on.

Two roads are adjacent if they have the same city at one of their endpoints. For the process to be efficient, no two robots will ever repair the same road, and no road can be visited twice. What is the minimum number of robots needed to accomplish the task?
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

#define MAXN 10000

int memo[MAXN][3];
vector&lt;int&gt; E[MAXN];

int solve(int x, int froot, int p) {
  int&amp; ref = memo[x][froot];
  if(ref != -1) return ref;
  
  ref = froot == 1 ? 0 : 1;

  int children = 0;
  vector&lt;int&gt; C;
  for(int i = 0; i &lt; E[x].size(); i++) {
    int v = E[x][i];
    if(v == p) continue;

    int res = solve(v, 0, x);
    ref += res;
    C.push_back(solve(v, 1, x) - res);
    children++;
  }
  sort(C.begin(), C.end());


  int r1 = ref;
  int charge = (froot == 1 ? 1 : 2);
  for(int i = 0; i &lt; C.size(); i++) {
    r1 += C[i];
    if(i == charge) {
      r1++;
      charge += 2;
    }
    ref = min(ref, r1);
  }
  if(children == 0 &amp;&amp; froot != 2) {
    ref = 0;
  }

//cout &lt;&lt; x &lt;&lt; ", " &lt;&lt; froot &lt;&lt; ", " &lt;&lt; ref  &lt;&lt; " (" &lt;&lt; C.size() &lt;&lt; ")" &lt;&lt; endl;
  if(froot == 0) {
    int r2 = 0;
    for(int i = 0; i &lt; E[x].size(); i++) {
      int v = E[x][i];
      if(v == p) continue;
      r2 += solve(v, 2, x);
    }
    ref = min(ref, r2);
  }

  return ref;
}

int main() {
  int T; cin &gt;&gt; T;
  for(int t = 1; t &lt;= T; t++) {
    int N; cin &gt;&gt; N;

    for(int i = 0; i &lt; N; i++) E[i].clear();
    for(int i = 1; i &lt; N; i++) {
      int u, v; cin &gt;&gt; u &gt;&gt; v;
      E[u].push_back(v);
      E[v].push_back(u);
    }

    memset(memo, -1, sizeof(memo));
    cout &lt;&lt; solve(0, false, -1) &lt;&lt; endl;
  }
}
----------
====================
----------
ALGORITHMS.200
hard
----------
PROBLEM STATEMENT:
A tree of [expression] from 
[expression]. 

Similarly, if [expression]. 

Susan likes to play with graphs and Tree data structure is one of her favorites. She has designed a problem and wants to know if anyone can solve it. Sometimes she adds or removes a leaf node. Your task is to figure out the [expression]th parent of a node at any instant.
----------
TOP SOLUTION:
----------
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;iterator&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;deque&gt;
#include &lt;cmath&gt;
#include &lt;memory.h&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;cctype&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt; 
using namespace std;
 
#define FOR(i, a, b) for(int i = (a); i &lt; (b); ++i)
#define RFOR(i, b, a) for(int i = (b) - 1; i &gt;= (a); --i)
#define REP(i, N) FOR(i, 0, N)
#define RREP(i, N) RFOR(i, N, 0)
 
#define ALL(V) V.begin(), V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair
#define Pi 3.14159265358979

typedef long long Int;
typedef unsigned long long UInt;
typedef vector &lt;int&gt; VI;
typedef pair &lt;int, int&gt; PII;

VI a[1&lt;&lt;17];
int n, root;
int dist[1&lt;&lt;17];
int p[1&lt;&lt;17][17];

int st[1&lt;&lt;17];
int deep;

void dfs(int cur)
{
	dist[cur] = deep;
	st[deep++] = cur;
	
	for (int i = 1, lev = 0; i &lt; deep; i&lt;&lt;=1, ++lev)
	{
		p[cur][lev] = st[deep - i];
	}
	
	REP(i,SZ(a[cur]))
	{
		int nx = a[cur][i];
		
		if (nx == p[cur][0])
			continue;
		
		dfs(nx);
	}
	
	--deep;
}

int get(int cur,int len)
{
	if (cur &lt;= 0 || cur &gt; 100000 || dist[cur] &lt;= 0)
		return -1;
	
	int need = dist[cur] - len;
	
	if (need &lt; 0)
		return -1;
	
	if (need == 0)
		return root;
	
	int go = 0;
	int step = 0;
	
	while (dist[cur] != need)
	{
		if (++step &gt; 10000)
			throw -1;
		
		int* pp = p[cur];
		int nx = pp[go];
		
		while (go &lt; 16 &amp;&amp; dist[nx] &gt; need)
		{
			++go;
			nx = pp[go];
		}
		
		while (nx &lt;= 0 || dist[nx] &lt; need)
		{
			--go;
			nx = pp[go];
		}
		
		cur = pp[go];
	}
	
	return cur;
}

void add(int par, int cur)
{
	if (par == 0)
	{
		dist[cur] = 0;
		memset(p[cur], 0, sizeof(p[cur]));
		return;
	}
	
	dist[cur] = dist[par] + 1;
	
	REP(i,17)
	{
		p[cur][i] = get(par, (1&lt;&lt;i)-1);
	}
}

void del(int cur)
{
	dist[cur] = -1;
}

int main()
{
//	freopen("in.txt", "r", stdin);
//	freopen("out.txt", "w", stdout);
	
	int T;
	cin&gt;&gt;T;
	REP(tests,T)
	{
		memset(dist, -1, sizeof(dist));
		if (tests &gt; 0)
			memset(p,0,sizeof(p));
		
		REP(i,(1&lt;&lt;17))
			a[i].clear();
		
		scanf("%d", &amp;n);
		
		REP(i,n)
		{
			int x,y;
			scanf("%d%d", &amp;x,&amp;y);
			
			if (y == 0)
			{
				root = x;
				continue;
			}
			
			a[y].push_back(x);
		}
		
		dfs(root);
		
		int q;
		
		scanf("%d",&amp;q);
		
		REP(i,q)
		{
			int c, x,y;
			scanf("%d", &amp;c);
			
			switch (c)
			{
			case 0:
				scanf("%d%d",&amp;x,&amp;y);
				add(x, y);
				break;
			case 1:
				scanf("%d",&amp;x);
				del(x);
				break;
			case 2:
				scanf("%d%d",&amp;x,&amp;y);
				int res = get(x,y);
				
				if (res == -1)
					res = 0;
				printf("%d\n", res);
				break;
			}
		}
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.201
hard
----------
PROBLEM STATEMENT:
The country of Byteland contains N cities and N - 1 bidirectional roads between them such that there is a path between any two cities. The cities are numbered (0,...,N - 1). The people were very unhappy about the time it took to commute, especially salesmen who had to go about every city selling goods. So it was decided that new roads would be built between any two "somewhat near" cities. Any two cities in Bytleland that can be reached by traveling on exactly two old roads are known as "somewhat near" each other.

Now a salesman situated in city 0, just like any other typical salesman, has to visit all cities exactly once and return back to city 0 in the end. In how many ways can he do this?
----------
TOP SOLUTION:
----------
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;stdio.h&gt;
#include&lt;set&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
using namespace std ;
#define INF (int)1e9
#define MOD 1000000007
#define MAXN 10002
vector&lt;int&gt; G[MAXN] ;
int n ;

void form_graph(int prufer[])
{
 int i,j,k,degree[MAXN] ;
 for(i=0;i&lt;n;i++) degree[i] = 1 ;
 for(i=0;i&lt;n-2;i++) degree[prufer[i]]++ ;
 for(i=0;i&lt;MAXN;i++) G[i].clear() ;
 for(i=0;i&lt;n-2;i++)
 {
  for(j=0;degree[j] != 1;j++) ;
  G[j].push_back(prufer[i]) ;
  G[prufer[i]].push_back(j) ;
  degree[j] -- ;
  degree[prufer[i]] -- ;
 }
 for(i=0;degree[i] != 1;i++) ;
 for(j=i+1;degree[j] != 1;j++) ;
 G[i].push_back(j) ;
 G[j].push_back(i) ;
}

void generate(int N)
{
 int prufer[MAXN] ;
 n = N ;
 for(int i = 0;i &lt; n - 2;i++) prufer[i] = rand() % n ;
 form_graph(prufer) ;
}

int perm[MAXN] ;
void generateCaterpiller(int N,int path)
{
 n = N ;
 for(int i = 0;i &lt; MAXN;i++) G[i].clear() ;
 for(int i = 0;i &lt; n;i++) perm[i] = i ;
 for(int i = 0;i &lt; n;i++)
 {
  int j = i + rand() % (n - i) ;
  swap(perm[i],perm[j]) ;
 }
 if(path &gt; n) path = n ;
 for(int i = 0;i + 1 &lt; path;i++)
 {
  G[perm[i]].push_back(perm[i + 1]) ;
  G[perm[i + 1]].push_back(perm[i]) ;
 }
 for(int i = path;i &lt; n;i++)
 {
  int k = rand() % path ;
  G[perm[k]].push_back(perm[i]) ;
  G[perm[i]].push_back(perm[k]) ;
 }
}

void generateAlmostCaterpiller(int N,int path,int dangle)
{
 n = N ;
 for(int i = 0;i &lt; MAXN;i++) G[i].clear() ;
 for(int i = 0;i &lt; n;i++) perm[i] = i ;
 for(int i = 0;i &lt; n;i++)
 {
  int j = i + rand() % (n - i) ;
  swap(perm[i],perm[j]) ;
 }
 if(path &gt; n) path = n ;
 for(int i = 0;i + 1 &lt; path;i++)
 {
  G[perm[i]].push_back(perm[i + 1]) ;
  G[perm[i + 1]].push_back(perm[i]) ;
 }
 for(int i = path;i + dangle &lt; n;i++)
 {
  int k = rand() % path ;
  G[perm[k]].push_back(perm[i]) ;
  G[perm[i]].push_back(perm[k]) ;
 }
 for(int i = n - dangle;i &lt; n;i++)
 {
  int k = rand() % i ;
  G[perm[k]].push_back(perm[i]) ;
  G[perm[i]].push_back(perm[k]) ;
 }
}


int dist[22][22] ;
int memo[15][1 &lt;&lt; 15] ;
int brute(int k,int mask)
{
 if(mask == 0) return dist[k][0] &lt;= 2 ? 1 : 0 ;
 if(memo[k][mask] != -1) return memo[k][mask] ;
 int ret = 0 ;
 for(int i = 0;i &lt; n;i++) if(mask &amp; 1 &lt;&lt; i)
  if(dist[k][i] &lt;= 2)
  {
   int cret = brute(i,mask ^ 1 &lt;&lt; i) ;
   ret += cret ;
   if(ret &gt;= MOD) ret -= MOD ;
  }
 return memo[k][mask] = ret ;
}

int brute()
{
 for(int i = 0;i &lt; n;i++)
  for(int j = 0;j &lt; n;j++)
   dist[i][j] = i == j ? 0 : INF ;
 for(int i = 0;i &lt; n;i++)
  for(int j = 0;j &lt; G[i].size();j++)
   dist[i][G[i][j]] = dist[G[i][j]][i] = 1 ;
 for(int k = 0;k &lt; n;k++)
  for(int i = 0;i &lt; n;i++)
   for(int j = 0;j &lt; n;j++)
    dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]) ;
 memset(memo,255,sizeof memo) ;
 int ret = brute(0,(1 &lt;&lt; n) - 2) ;
 return ret ;
}

char isLeaf[MAXN] ;
int fac[MAXN] ;
int solve()
{
 int ret = 1,path = n ;
 for(int i = 0;i &lt; n;i++) path -= isLeaf[i] = G[i].size() == 1 ;
 for(int i = 0;i &lt; n;i++) if(!isLeaf[i])
 {
  int ct = 0,ct2 = 0 ;
  for(int j = 0;j &lt; G[i].size();j++)
   if(!isLeaf[G[i][j]])
    ct++ ;
   else ct2++ ;
  if(ct &gt; 2) return 0 ;
  ret = 1LL * ret * fac[ct2] % MOD ;
 }
 return path == 1 ? ret : 2 * ret % MOD ;
}

void test()
{
 for(int t = 1;t &lt;= 10000;t++)
 {
  generate(15) ;
//  cout &lt;&lt; "Case: " &lt;&lt; t &lt;&lt; endl ;
  int ret1 = brute() ;
  int ret2 = solve() ;
  cout &lt;&lt; ret1 &lt;&lt; " " &lt;&lt; ret2 &lt;&lt; endl ;
  if(ret1 != ret2)
  {
   cout &lt;&lt; "failed on case: " &lt;&lt; t &lt;&lt; endl ;
   cout &lt;&lt; ret1 &lt;&lt; " " &lt;&lt; ret2 &lt;&lt; endl ;
   cout &lt;&lt; n &lt;&lt; endl ;
   char vis[102][102] ;
   memset(vis,0,sizeof vis) ;
   for(int i = 0;i &lt; n;i++)
    for(int j = 0;j &lt; G[i].size();j++) if(!vis[i][G[i][j]])
    {
     cout &lt;&lt; i &lt;&lt; " " &lt;&lt; G[i][j] &lt;&lt; endl ;
     vis[i][G[i][j]] = vis[G[i][j]][i] = true ;
    }
   while(1) ;
  }
 }
 cout &lt;&lt; "Done" &lt;&lt; endl ;
}

typedef pair&lt;int,int&gt; P ;
void testGen()
{
 char in[10] = "in .txt" ;
 for(int test = 0;test &lt; 10;test++)
 {
  in[2] = test + '0' ;
  FILE * fout = fopen(in,"w") ;
  
  int runs = 20 ;
  fprintf(fout,"%d\n",runs) ;
  for(int t = 0;t &lt; runs;t++)
  {
   int N ;
   if(test &lt; 3) generate(10) ;
   else if(test &lt; 7)
   {
    N = rand() % 9999 + 2 ;
    if(t &lt; 10) generateCaterpiller(N,rand() % 10 + 1) ;
    else generateCaterpiller(N,rand() % (2 * N / 3) + 1) ;
   }
   else if(test &lt; 9)
   {
    N = rand() % 9999 + 2 ;
    if(rand() % 2) generateAlmostCaterpiller(N,rand() % N + 1,5) ;
    else generateCaterpiller(N,rand() % (2 * N / 3) + 1) ;
   }
   else generate(rand() % 1000 + 2) ;
   
   fprintf(fout,"%d\n",n) ;
   set&lt;pair&lt;int,int&gt; &gt; vis ;
   for(int i = 0;i &lt; n;i++)
    for(int j = 0;j &lt; G[i].size();j++)
    {
     P cur = P(i,G[i][j]) ;
     if(vis.find(cur) == vis.end())
     {
      fprintf(fout,"%d %d\n",i,G[i][j]) ;
      vis.insert(cur) ;
      swap(cur.first,cur.second) ;
      vis.insert(cur) ;
     }
    }
  }
 }
}

void genMakefile()
{
 for(int test = 0;test &lt; 100;test++)
 {
  printf("./a.out &lt; in%d%d.txt &gt; out%d%d.txt\n",test / 10,test % 10,test / 10,test % 10) ;
 }
}


int par[MAXN] ;
int fn(int k) { return k == par[k] ? k : par[k] = fn(par[k]) ; }

int main()
{
 fac[0] = 1 ;
 for(int i = 1;i &lt; MAXN;i++) fac[i] = 1LL * i * fac[i - 1] % MOD ;
// genMakefile() ; return 0 ;
// testGen() ; return 0 ;
// test() ; return 0 ;

 int runs ;
 scanf("%d",&amp;runs) ;
 while(runs--)
 {
  scanf("%d",&amp;n) ;
  for(int i = 0;i &lt; MAXN;i++) G[i].clear() ;
  for(int i = 0;i &lt; n;i++) par[i] = i ;
  for(int i = 1;i &lt; n;i++)
  {
   int a,b ;
   scanf("%d%d",&amp;a,&amp;b) ;
   if(a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n || fn(a) == fn(b)) { cout &lt;&lt; "Bad input" &lt;&lt; endl ; return 1 ; }
   par[fn(a)] = fn(b) ;   
   G[a].push_back(b) ;
   G[b].push_back(a) ;
  }
  int ret = solve() ;
  printf("%d\n",ret) ;
 }
 return 0 ;
}

----------
====================
----------
ALGORITHMS.202
hard
----------
PROBLEM STATEMENT:
You are given a table, [expression].

A path in the table is a sequence of cells [expression] share a side. 

The weight of the path [expression].

You must answer [expression]. You must find and print the minimum possible weight of a path connecting them.

Note: A cell can share sides with at most [expression].
----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class C {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	void solve()
	{
		int n = ni(), m = ni();
		int[][] a = new int[m][n];
		for(int i = 0;i &lt; n;i++){
			for(int j = 0;j &lt; m;j++){
				a[j][i] = ni();
			}
		}
		d = new long[m][n][][];
		
		build(0, m, a);
		
		int Q = ni();
		for(int q = 0;q &lt; Q;q++){
			int sc = ni(), sr = ni();
			int tc = ni(), tr = ni();
			if(sr &gt; tr){
				{int du = tr; tr = sr; sr = du;}
				{int du = tc; tc = sc; sc = du;}
			}
			out.println(go(0, m, sr, sc, tr, tc, a));
		}
		
	}
	
	static long go(int L, int R, int sr, int sc, int tr, int tc, int[][] a)
	{
		int M = L+R&gt;&gt;&gt;1;
		int m = a[0].length;
		long ret = Long.MAX_VALUE;
		for(int i = 0;i &lt; m;i++){
			ret = Math.min(ret, d[M][i][sr-L][sc] + d[M][i][tr-L][tc] - a[M][i]);
		}
		if(sr &lt;= M &amp;&amp; M &lt;= tr){
			return ret;
		}
		if(R-L &lt;= 1)return ret;
		if(tr &lt; M){
			return Math.min(ret, go(L, M, sr, sc, tr, tc, a));
		}else{
			return Math.min(ret, go(M, R, sr, sc, tr, tc, a));
		}
	}
	
	static long[][][][] d;
	
	static void build(int L, int R, int[][] a)
	{
		int m = a[0].length;
		int M = L+R&gt;&gt;&gt;1;
		if(d[M][0] != null)return;
		for(int i = 0;i &lt; m;i++){
			d[M][i] = dijk(a, M, i, L, R);
		}
		if(R-L &lt;= 1)return;
		build(L, M, a);
		build(M, R, a);
	}
	
	public static long[][] dijk(int[][]  a, int sr, int sc, int L, int R)
	{
		int m = a[0].length;
		long[][] td = new long[R-L][m];
		for(int i = 0;i &lt; R-L;i++){
			Arrays.fill(td[i], Long.MAX_VALUE / 3);
		}
		td[sr-L][sc] = 0;
		MinHeapL q = new MinHeapL((R-L)*m);
		q.add((sr-L)*m+sc, 0L);
		td[sr-L][sc] = a[sr][sc];
		
		int[] dr = { 1, 0, -1, 0 };
		int[] dc = { 0, 1, 0, -1 };
		
		while(q.size() &gt; 0){
			int cur = q.argmin();
			q.remove(cur);
			
			int r = cur / m, c = cur % m;
			for(int k = 0;k &lt; 4;k++){
				int nr = r + dr[k], nc = c + dc[k];
				if(nr &gt;= L-L &amp;&amp; nr &lt; R-L &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; m){
					long nd = td[r][c] + a[nr+L][nc];
					if(nd &lt; td[nr][nc]){
						td[nr][nc] = nd;
						q.update(nr*m+nc, nd);
					}
				}
			}
		}
		
		return td;
	}
	
	public static class MinHeapL {
		public long[] a;
		public int[] map;
		public int[] imap;
		public int n;
		public int pos;
		public static long INF = Long.MAX_VALUE;
		
		public MinHeapL(int m)
		{
			n = Integer.highestOneBit((m+1)&lt;&lt;1);
			a = new long[n];
			map = new int[n];
			imap = new int[n];
			Arrays.fill(a, INF);
			Arrays.fill(map, -1);
			Arrays.fill(imap, -1);
			pos = 1;
		}
		
		public long add(int ind, long x)
		{
			int ret = imap[ind];
			if(imap[ind] &lt; 0){
				a[pos] = x; map[pos] = ind; imap[ind] = pos;
				pos++;
				up(pos-1);
			}
			return ret != -1 ? a[ret] : x;
		}
		
		public long update(int ind, long x)
		{
			int ret = imap[ind];
			if(imap[ind] &lt; 0){
				a[pos] = x; map[pos] = ind; imap[ind] = pos;
				pos++;
				up(pos-1);
			}else{
				a[ret] = x;
				up(ret);
				down(ret);
			}
			return x;
		}
		
		public long remove(int ind)
		{
			if(pos == 1)return INF;
			if(imap[ind] == -1)return INF;
			
			pos--;
			int rem = imap[ind];
			long ret = a[rem];
			map[rem] = map[pos];
			imap[map[pos]] = rem;
			imap[ind] = -1;
			a[rem] = a[pos];
			a[pos] = INF;
			map[pos] = -1;
			
			up(rem);
			down(rem);
			return ret;
		}
		
		public long min() { return a[1]; }
		public int argmin() { return map[1]; }
		public int size() {	return pos-1; }
		
		private void up(int cur)
		{
			for(int c = cur, p = c&gt;&gt;&gt;1;p &gt;= 1 &amp;&amp; a[p] &gt; a[c];c&gt;&gt;&gt;=1, p&gt;&gt;&gt;=1){
				long d = a[p]; a[p] = a[c]; a[c] = d;
				int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;
				e = map[p]; map[p] = map[c]; map[c] = e;
			}
		}
		
		private void down(int cur)
		{
			for(int c = cur;2*c &lt; pos;){
				int b = a[2*c] &lt; a[2*c+1] ? 2*c : 2*c+1;
				if(a[b] &lt; a[c]){
					long d = a[c]; a[c] = a[b]; a[b] = d;
					int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;
					e = map[c]; map[c] = map[b]; map[b] = e;
					c = b;
				}else{
					break;
				}
			}
		}
	}	
	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new C().run(); }
	
	private byte[] inbuf = new byte[1024];
	private int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.203
hard
----------
PROBLEM STATEMENT:
After completing her final semester, Savita is back home. She is excited to meet all her friends. Her [expression] friends live in different houses spread across the city.    

There are [expression] roads connecting the houses. The road network formed is connected and does not contain self loops and multiple roads between same pair of houses. Savita and Friends decide to meet.  

Savita wants to choose a point(not necessarily an integer) [expression] is minimised, 
where [expression].    

If [expression].     

Note: 


Use scanf/printf instead of cin/cout. Large input files.
Order of [expression], you should print 8 and not 2.  

----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;
//#include &lt;memory.h&gt;

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash

#define eps 1e-14
//#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 256
//#define N 120000

using namespace std;

long tests;
vector&lt;pair&lt;long, long&gt; &gt; g[200000];
long a,b,c;
long long cp1,cp2,tt;
long n,m,k;
long long dist[200000];

long bda,bdb;
double nmove;
set&lt;pair&lt;long long, long &gt; &gt; sett;
set&lt;pair&lt;long long, long&gt; &gt; ::iterator it;
pair&lt;long long, long&gt; tp;
long long qv;
long long qcost;
long d1[200000],d2[200000];
double l,r,mid1,mid2;

double gett(double val)
{
 double bst=0;
 for (int i=1;i&lt;=n;i++)
  bst=max(bst,min(d1[i]+val,d2[i]+tt-val));
  return bst;
}

int main(){
//freopen("pattern.in","r",stdin);
//freopen("pattern.out","w",stdout);
//freopen("C:/input.txt","r",stdin);
//freopen("C:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);
//cin.tie(0);

cin&gt;&gt;tests;
for (;tests;--tests)
{
 cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
 for (int i=1;i&lt;=n;i++)
  g[i].clear();
 for (int i=1;i&lt;=m;i++)
  {
   cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
   if (i==k){cp1=a,cp2=b;tt=c;}
   g[a].push_back(make_pair(b,c));
   g[b].push_back(make_pair(a,c));
  }
 
 for (int i=1;i&lt;=n;i++)
  dist[i]=1e16;
 dist[cp1]=0;
 sett.clear();
 for (int i=1;i&lt;=n;i++)
  sett.insert(make_pair(dist[i],i));
 for (int iter=1;iter&lt;=n;iter++)
 {
  it=sett.begin();
  tp=(*it);
  sett.erase(it);
  qv=tp.second;
  qcost=tp.first;
  for (int i=0;i&lt;g[qv].size();i++)
  {
   long long nv=g[qv][i].first;
   long long ncost=g[qv][i].second+qcost;
   if (min(nv,qv)==min(cp1,cp2)&amp;&amp;max(nv,qv)==max(cp1,cp2))
    continue;
   if (dist[nv]&gt;ncost)
   {
    sett.erase(make_pair(dist[nv],nv));
    dist[nv]=ncost;
    sett.insert(make_pair(dist[nv],nv));
   }
  }
 }
 
 for (int i=1;i&lt;=n;i++)
  d1[i]=dist[i];
 
 // -- 2nd end
 
 for (int i=1;i&lt;=n;i++)
  dist[i]=1e16;
 dist[cp2]=0;
 sett.clear();
 for (int i=1;i&lt;=n;i++)
  sett.insert(make_pair(dist[i],i));
 for (int iter=1;iter&lt;=n;iter++)
 {
  it=sett.begin();
  tp=(*it);
  sett.erase(it);
  qv=tp.second;
  qcost=tp.first;
  for (int i=0;i&lt;g[qv].size();i++)
  {
   long long nv=g[qv][i].first;
   long long ncost=g[qv][i].second+qcost;
   if (min(nv,qv)==min(cp1,cp2)&amp;&amp;max(nv,qv)==max(cp1,cp2))
    continue;
   if (dist[nv]&gt;ncost)
   {
    sett.erase(make_pair(dist[nv],nv));
    dist[nv]=ncost;
    sett.insert(make_pair(dist[nv],nv));
   }
  }
 }
 
 for (int i=1;i&lt;=n;i++)
  d2[i]=dist[i];
 /*
 for (int i=1;i&lt;=n;i++)
  cout&lt;&lt;d1[i]&lt;&lt;" ";
  cout&lt;&lt;endl;
 for (int i=1;i&lt;=n;i++)
  cout&lt;&lt;d2[i]&lt;&lt;" ";
  cout&lt;&lt;endl;
   */
 l=0;
 r=tt;
 while (r-l&gt;1e-6)
 {
  mid1=l*2+r;
  mid2=l+r*2;
  mid1/=3;
  mid2/=3;
  if (gett(mid1)&lt;gett(mid2))r=mid2;
  else l=mid1;
 }
 if (gett(0)&lt;gett(l))l=0;
 if (gett(tt)&lt;gett(l))l=tt;
// cout&lt;&lt;gett(2)&lt;&lt;endl;
 cout.precision(5);
 cout&lt;&lt;fixed&lt;&lt;l&lt;&lt;" "&lt;&lt;gett(l)&lt;&lt;endl;
}

cin.get();cin.get();
return 0;}

----------
====================
----------
ALGORITHMS.204
advanced
----------
PROBLEM STATEMENT:
You have N soldiers numbered from 1 to N. Each of your soldiers is either a liar or a truthful person. You have M sets of information about them. Each set of information tells you the number of liars among a certain range of your soldiers. Let L be the total number of your liar soldiers. Since you can't find the exact value of L, you want to find the minimum and maximum value of L.

Input Format  


The first line of the input contains two integers N and M.  
Each of next M lines contains three integers: 
A B C where the set of soldiers numbered as {A, A+1, A+2, ..., B}, exactly C of them are liars. (1 &lt;= Ai &lt;= Bi &lt;= n) and (0 &lt;= Ci &lt;= Bi-Ai).


Note: N and M are not more than 101, and it is guaranteed the given informations is satisfiable.

Output Format 
Print two integers Lmin and Lmax to the output.

Sample Input #1  

3 2
1 2 1
2 3 1


Sample Output #1

1 2


Sample Input #2 

20 11
3 8 4
1 9 6
1 13 9
5 11 5
4 19 12
8 13 5
4 8 4
7 9 2
10 13 3
7 16 7
14 19 4


Sample Output #2

13 14


Explanation 
In the first input, the initial line is "3 2", i.e. that there are 3 soldiers and we have 2 sets of information. The next line says there is one liar in the set of soldiers {1, 2}. The final line says there is one liar in the set {2,3}. There are two possibilities for this scenario: Soldiers number 1 and 3 are liars or soldier number 2 is liar. 
So the minimum number of liars is 1 and maximum number of liars is 2. Hence the answer, 1 2.
----------
TOP SOLUTION:
----------
import java.util.*;
import java.io.*;
import static java.lang.Math.*;

public class Solution {
	/*
	 * difference constraints
	 * add new constraint d[N]-d[0] = k and check if k is feasible
	 */
	static class Foo51 {
		int N;
		int[][] edges;
		void main() {
			BufferedReader br = null;
			try {
				br = new BufferedReader(new InputStreamReader(System.in));
				String[] s = br.readLine().trim().split(" ");
				N = Integer.parseInt(s[0].trim());
				int M = Integer.parseInt(s[1].trim());
				edges = new int[2*M+2*N+2][3];
				for (int i = 0; i &lt; M; i++) {
					s = br.readLine().trim().split(" ");
					int u = Integer.parseInt(s[0].trim());
					int v = Integer.parseInt(s[1].trim());
					int weight = Integer.parseInt(s[2].trim());
					edges[2*i] = new int[] {u-1, v, weight};
					edges[2*i+1] = new int[] {v, u-1, -weight};
				}
				for (int i = 0; i &lt; N; i++) {
					edges[2*i+2*M] = new int[] {i+1, i, 0};
					edges[2*i+2*M+1] = new int[] {i, i+1, 1};
				}
				edges[2*M+2*N][0] = edges[2*M+2*N+1][1] = 0;
				edges[2*M+2*N+1][0] = edges[2*M+2*N][1] = N;
				int[] res = foo();
				System.out.println(res[0] + " " + res[1]);
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				if (br != null) {
					try { br.close(); } catch (Exception e) { e.printStackTrace(); }
				}
			}
		}
		int[] foo() {
			// binary search is better, but since the constraint is low, just linear traverse
			int[] res = {N, 0};
			for (int k = 0; k &lt;= N; k++) {
				if (ok(k)) {
					res[0] = min(res[0], k);
					res[1] = max(res[1], k);
				}
			}
			return res;
		}
		boolean ok(int K) {
			int m = edges.length;
			edges[m-2][2] = K;
			edges[m-1][2] = -K;
			int[] d = new int[N+1];
			for (int i = 0; i &lt; N+1; i++) {
				for (int j = 0; j &lt; m; j++) {
					int u = edges[j][0];
					int v = edges[j][1];
					d[v] = min(d[v], d[u]+edges[j][2]);
				}
			}
			for (int j = 0; j &lt; m; j++) {
				int u = edges[j][0];
				int v = edges[j][1];
				if (d[v] &gt; d[u] + edges[j][2])
					return false;
			}
			return true;
		}
	}
	
	public static void main(String[] args) {
		Foo51 foo = new Foo51();
		foo.main();
	}
}

----------
====================
----------
ALGORITHMS.205
advanced
----------
PROBLEM STATEMENT:
Nina has an [expression] jumping rooks. Every cell of the chessboard is either blocked or free, and Nina can only put a single rook in any free cell. 

Two jumping rooks beat each other if they are either in the same row or in the same column and all cells between them are free (note that it's possible that there are some other rooks between them). More formally, if the first rook is in cell [expression] must all be free.

Given the configuration of the chessboard and some [expression] jumping rooks in the chessboard's free cells such that the number of pairs of rooks that beat each other is minimal. Then print a single integer denoting the number of rooks that beat each other.
----------
TOP SOLUTION:
----------

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.List;

public class C {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	void solve()
	{
		int n = ni(), K = ni();
		char[][] map = nm(n,n);
		int[][] ud = new int[n][n];
		int[][] lr = new int[n][n];
		int pud = 0, plr = 0;
		{
			int id = -1;
			for(int i = 0;i &lt; n;i++){
				char pre = 0;
				for(int j = 0;j &lt; n;j++){
					if(map[j][i] == '.'){
						if(pre != '.')id++; 
						ud[j][i] = id;
					}
					pre = map[j][i];
				}
			}
			pud = id + 1;
		}
		{
			int id = -1;
			for(int i = 0;i &lt; n;i++){
				char pre = 0;
				for(int j = 0;j &lt; n;j++){
					if(map[i][j] == '.'){
						if(pre != '.')id++; 
						lr[i][j] = id;
					}
					pre = map[i][j];
				}
			}
			plr = id + 1;
		}
		List&lt;Edge&gt; es = new ArrayList&lt;&gt;();
		for(int i = 0;i &lt; n;i++){
			for(int j = 0;j &lt; n;j++){
				if(map[i][j] == '.'){
					es.add(new Edge(ud[i][j], lr[i][j]+pud, 1, 0));
				}
			}
		}
		int src = pud + plr, sink = src + 1;
		for(int i = 0;i &lt; pud;i++){
			for(int j = 0;j &lt;= n;j++){
				es.add(new Edge(src, i, 1, j));
			}
		}
		for(int i = 0;i &lt; plr;i++){
			for(int j = 0;j &lt;= n;j++){
				es.add(new Edge(i+pud, sink, 1, j));
			}
		}
		out.println(solveMinCostFlow(compileWD(sink+1, es), src, sink, K));
	}
	
	public static class Edge
	{
		public int from, to;
		public int capacity;
		public int cost;
		public int flow;
		public Edge complement;
		// public int iniflow;
		
		public Edge(int from, int to, int capacity, int cost) {
			this.from = from;
			this.to = to;
			this.capacity = capacity;
			this.cost = cost;
		}
	}
	
	public static Edge[][] compileWD(int n, List&lt;Edge&gt; edges)
	{
		Edge[][] g = new Edge[n][];
		// cloning
		for(int i = edges.size()-1;i &gt;= 0;i--){
			Edge origin = edges.get(i);
			Edge clone = new Edge(origin.to, origin.from, origin.capacity, -origin.cost);
			clone.flow = origin.capacity;
			clone.complement = origin;
			origin.complement = clone;
			edges.add(clone);
		}
		
		int[] p = new int[n];
		for(Edge e : edges)p[e.from]++;
		for(int i = 0;i &lt; n;i++)g[i] = new Edge[p[i]];
		for(Edge e : edges)g[e.from][--p[e.from]] = e;
		return g;
	}

	// NOT VERIFIED
	public static Edge[][] compileWU(int n, List&lt;Edge&gt; edges)
	{
		Edge[][] g = new Edge[n][];
		// cloning
		for(int i = edges.size()-1;i &gt;= 0;i--){
			Edge origin = edges.get(i);
			Edge back = new Edge(origin.to, origin.from, origin.capacity, origin.cost);
			edges.add(back);
		}
		for(int i = edges.size()-1;i &gt;= 0;i--){
			Edge origin = edges.get(i);
			Edge clone = new Edge(origin.to, origin.from, origin.capacity, -origin.cost);
			clone.flow = origin.capacity;
			clone.complement = origin;
			origin.complement = clone;
			edges.add(clone);
		}
		
		int[] p = new int[n];
		for(Edge e : edges)p[e.from]++;
		for(int i = 0;i &lt; n;i++)g[i] = new Edge[p[i]];
		for(Edge e : edges)g[e.from][--p[e.from]] = e;
		return g;
	}	

	
	public static long solveMinCostFlow(Edge[][] g, int source, int sink, long all)
	{
		int n = g.length;
		long mincost = 0;
		int[] potential = new int[n];
		
		final int[] d = new int[n];
		MinHeap q = new MinHeap(n);
		while(all &gt; 0){
			// shortest path src-&gt;sink
			Edge[] inedge = new Edge[n];
			Arrays.fill(d, Integer.MAX_VALUE / 2);
			d[source] = 0;
			q.add(source, 0);
			while(q.size() &gt; 0){
				int cur = q.argmin();
				q.remove(cur);
				for(Edge ne : g[cur]){
					if(ne.capacity - ne.flow &gt; 0){
						int nd = d[cur] + ne.cost + potential[cur] - potential[ne.to];
						if(d[ne.to] &gt; nd){
							inedge[ne.to] = ne;
							d[ne.to] = nd;
							q.update(ne.to, nd);
						}
					}
				}
			}
			
			if(inedge[sink] == null)break;
			
			long minflow = all;
			long sumcost = 0;
			for(Edge e = inedge[sink];e != null;e = inedge[e.from]){
				if(e.capacity - e.flow &lt; minflow)minflow = e.capacity - e.flow;
				sumcost += e.cost;
			}
			mincost += minflow * sumcost;
			for(Edge e = inedge[sink];e != null;e = inedge[e.from]){
				e.flow += minflow;
				e.complement.flow -= minflow;
			}
			
			all -= minflow;
			for(int i = 0;i &lt; n;i++){
				potential[i] += d[i];
			}
		}
		return mincost;
	}
	

	public static class MinHeap {
		public int[] a;
		public int[] map;
		public int[] imap;
		public int n;
		public int pos;
		public static int INF = Integer.MAX_VALUE;
		
		public MinHeap(int m)
		{
			n = m+2;
			a = new int[n];
			map = new int[n];
			imap = new int[n];
			Arrays.fill(a, INF);
			Arrays.fill(map, -1);
			Arrays.fill(imap, -1);
			pos = 1;
		}
		
		public int add(int ind, int x)
		{
			int ret = imap[ind];
			if(imap[ind] &lt; 0){
				a[pos] = x; map[pos] = ind; imap[ind] = pos;
				pos++;
				up(pos-1);
			}
			return ret != -1 ? a[ret] : x;
		}
		
		public int update(int ind, int x)
		{
			int ret = imap[ind];
			if(imap[ind] &lt; 0){
				a[pos] = x; map[pos] = ind; imap[ind] = pos;
				pos++;
				up(pos-1);
			}else{
				int o = a[ret];
				a[ret] = x;
				up(ret);
				down(ret);
//				if(a[ret] &gt; o){
//					up(ret);
//				}else{
//					down(ret);
//				}
			}
			return x;
		}
		
		public int remove(int ind)
		{
			if(pos == 1)return INF;
			if(imap[ind] == -1)return INF;
			
			pos--;
			int rem = imap[ind];
			int ret = a[rem];
			map[rem] = map[pos];
			imap[map[pos]] = rem;
			imap[ind] = -1;
			a[rem] = a[pos];
			a[pos] = INF;
			map[pos] = -1;
			
			up(rem);
			down(rem);
			return ret;
		}
		
		public int min() { return a[1]; }
		public int argmin() { return map[1]; }
		public int size() {	return pos-1; }
		
		private void up(int cur)
		{
			for(int c = cur, p = c&gt;&gt;&gt;1;p &gt;= 1 &amp;&amp; a[p] &gt; a[c];c&gt;&gt;&gt;=1, p&gt;&gt;&gt;=1){
				int d = a[p]; a[p] = a[c]; a[c] = d;
				int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;
				e = map[p]; map[p] = map[c]; map[c] = e;
			}
		}
		
		private void down(int cur)
		{
			for(int c = cur;2*c &lt; pos;){
				int b = a[2*c] &lt; a[2*c+1] ? 2*c : 2*c+1;
				if(a[b] &lt; a[c]){
					int d = a[c]; a[c] = a[b]; a[b] = d;
					int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;
					e = map[c]; map[c] = map[b]; map[b] = e;
					c = b;
				}else{
					break;
				}
			}
		}
	}

	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new C().run(); }
	
	private byte[] inbuf = new byte[1024];
	private int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.206
hard
----------
PROBLEM STATEMENT:
You are given [expression].
----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class D {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	int[][] read(int n)
	{
		int m = ni();
		int[] from = new int[m];
		int[] to = new int[m];
		for(int i = 0;i &lt; m;i++){
			from[i] = ni()-1;
			to[i] = ni()-1;
		}
		return packU(n, from, to);
	}
	
	void solve()
	{
		int n = ni();
		int[][] ga = read(n);
		int[][] gb = read(n);
		int[][] gc = read(n);
		
		int S = (int)Math.sqrt(100000);
		long[][] gbb = new long[n][];
		long[][] gbc = new long[n][];
		for(int i = 0;i &lt; n;i++){
			if(gb[i].length &gt;= S){
				gbb[i] = new long[(n&gt;&gt;&gt;6)+1];
				for(int e : gb[i]){
					gbb[i][e&gt;&gt;&gt;6] |= 1L&lt;&lt;e;
				}
			}
			if(gc[i].length &gt;= S){
				gbc[i] = new long[(n&gt;&gt;&gt;6)+1];
				for(int e : gc[i]){
					gbc[i][e&gt;&gt;&gt;6] |= 1L&lt;&lt;e;
				}
			}
			Arrays.sort(gb[i]);
			Arrays.sort(gc[i]);
		}
		
		int na = ga.length;
		long ret = 0;
		for(int a = 0;a &lt; na;a++){
			for(int b : ga[a]){
				if(gbb[b] != null){
					if(gbc[a] != null){
						for(int i = 0;i &lt; (n&gt;&gt;&gt;6)+1;i++){
							ret += Long.bitCount(gbb[b][i]&amp;gbc[a][i]);
						}
					}else{
						for(int e : gc[a]){
							if(gbb[b][e&gt;&gt;&gt;6]&lt;&lt;~e&lt;0)ret++;
						}
					}
				}else{
					if(gbc[a] != null){
						for(int e : gb[b]){
							if(gbc[a][e&gt;&gt;&gt;6]&lt;&lt;~e&lt;0)ret++;
						}
					}else{
						for(int i = 0, j = 0;i &lt; gb[b].length &amp;&amp; j &lt; gc[a].length;){
							if(gb[b][i] == gc[a][j]){
								ret++; i++; j++;
							}else if(gb[b][i] &lt; gc[a][j]){
								i++;
							}else{
								j++;
							}
						}
					}
				}
			}
		}
		out.println(ret);
	}
	
	static int[][] packU(int n, int[] from, int[] to) {
		int[][] g = new int[n][];
		int[] p = new int[n];
		for (int f : from)
			p[f]++;
		for (int t : to)
			p[t]++;
		for (int i = 0; i &lt; n; i++)
			g[i] = new int[p[i]];
		for (int i = 0; i &lt; from.length; i++) {
			g[from[i]][--p[from[i]]] = to[i];
			g[to[i]][--p[to[i]]] = from[i];
		}
		return g;
	}
	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new D().run(); }
	
	private byte[] inbuf = new byte[1024];
	private int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.207
hard
----------
PROBLEM STATEMENT:
Recall that a tree is an undirected, connected acyclic graph. We have a weighted tree, [expression].

Let's consider all the matrices, [expression], such that:


[expression]
[expression]
[expression]


We consider the total value of matrix [expression] to be:
[expression]

Calculate and print the maximum total value of [expression].
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

typedef pair&lt;long long, long long&gt; PII;

long long n,x,y,z,i,ans1,ans2;
vector&lt;PII&gt; edge[500007];

void DFS1(long long bef, long long pos, long long sum) {
    long long i;
    for (i=0 ; i&lt;edge[pos].size() ; i++) if (edge[pos][i].first != bef) {
        DFS1(pos,edge[pos][i].first,sum + edge[pos][i].second);
    }
    ans1 += sum;
}

void DFS2(long long bef, long long pos, long long sum) {
    long long i;
    for (i=0 ; i&lt;edge[pos].size() ; i++) if (edge[pos][i].first != bef) {
        DFS2(pos,edge[pos][i].first,sum + edge[pos][i].second);
    }
    ans2 += sum;
}

int main() {
    scanf("%lld",&amp;n);
    for (i=1 ; i&lt;=n-1 ; i++) {
        scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z);
        edge[x].push_back(PII(y,z));
        edge[y].push_back(PII(x,z));
    }
    
    DFS1(-1,1,0);
    DFS2(-1,n,0);
    //printf("%lld %lld\n",ans1,ans2);
    printf("%lld\n",min(ans1,ans2));
    
    return 0;
}

----------
====================
----------
ALGORITHMS.208
expert
----------
PROBLEM STATEMENT:
You are given a Directed Acyclic Graph (DAG) with [expression] queries on the DAG, where each query is one of the following types:


1 u x: Set [expression].
2 u x: Set [expression].
3 u: Print the value of [expression] on a new line.

----------
TOP SOLUTION:
----------
object Assert {
	def check(e: Boolean) {
		if (!e) {
			throw new AssertionError();
		}
	}
}

class Scanner(is: java.io.InputStream) {

	val buffer: Array[Byte] = new Array[Byte](1 &lt;&lt; 16);

	var len: Int = 0;

	var pos: Int = 0;

	def nextChar(): Int = {
		if (pos == len) {
			val read: Int = is.read(buffer);
			if (read == -1) {
				return -1;
			}
			len = read;
			pos = 0;
		}
		Assert.check(pos &lt; len);
		val value: Int = buffer(pos) &amp; 0xFF;
		pos += 1;
		return value;
	}

	def nextInt(): Int = {
		var c: Int = nextChar();
		while (c == ' ' || c == '\n' || c == '\r' || c == '\t') {
			c = nextChar();
		}
		Assert.check('0' &lt;= c &amp;&amp; c &lt;= '9');
		var value: Int = c - '0';
		c = nextChar();
		while ('0' &lt;= c &amp;&amp; c &lt;= '9') {
			val digit: Int = c - '0';
			Assert.check(value &lt; Int.MaxValue / 10 || value == Int.MaxValue / 10 &amp;&amp; digit &lt;= Int.MaxValue % 10);
			value = value * 10 + digit;
			c = nextChar();
		}
		return value;
	}
}

class IntArrayList {

	var a: Array[Int] = new Array[Int](4);

	var size: Int = 0;
	
	def add(x: Int): Unit = {
		if (size == a.length) {
			a = java.util.Arrays.copyOf(a, a.length * 2);
		}
		a(size) = x;
		size += 1;
	}
	
	def get(i: Int): Int = {
		Assert.check(i &lt; size);
		return a(i);
	}
}

class Query(val typ: Int, val node: Int, val value: Int) {}

object Solution {

	def reorder(parents: Array[IntArrayList], queries: Array[Query]): Unit = {
		val nV: Int = parents.size;
		val startOrder: Array[Int] = new Array[Int](nV);
		{
			var i: Int = 0;
			while (i &lt; nV) {
				startOrder(i) = i;
				i += 1;
			}
		}
		var rnd: java.util.Random = new java.util.Random(20161106);
		{
			var i: Int = nV - 1;
			while (i &gt; 0) {
				val j: Int = rnd.nextInt(i + 1);
				val t: Int = startOrder(i);
				startOrder(i) = startOrder(j);
				startOrder(j) = t;
				i -= 1;
			}
		}
		val orderedId: Array[Int] = new Array[Int](nV);
		java.util.Arrays.fill(orderedId, -1);
		val stack: IntArrayList = new IntArrayList();
		val ip: IntArrayList = new IntArrayList();
		var nextId: Int = 0;
		{
			var i: Int = 0;
			while (i &lt; nV) {
				if (orderedId(startOrder(i)) == -1) {
					stack.add(startOrder(i));
					ip.add(0);
					while (stack.size &gt; 0) {
						val cur: Int = stack.a(stack.size - 1);
						if (ip.get(ip.size - 1) == parents(cur).size) {
							orderedId(cur) = nextId;
							nextId += 1;
							stack.size -= 1;
							ip.size -= 1;
						} else {
							val p: Int = parents(cur).get(ip.get(ip.size - 1));
							ip.a(ip.size - 1) += 1;
							if (orderedId(p) == -1) {
								stack.add(p);
								ip.add(0);
							}
						}
					}
				}
				i += 1;
			}
		}
		if (false) {
			print("new ids: ");
			var first: Boolean = true;
			{
				var i: Int = 0;
				while (i &lt; nV) {
					if (first) {
						first = false;
					} else {
						print(", ");
					}
					print((i + 1) + " -&gt; " + (orderedId(i) + 1));
					i += 1;
				}
			}
			println();
		}
		Assert.check(nextId == nV);
		{
			var i: Int = 0;
			while (i &lt; orderedId.length) {
				Assert.check(orderedId(i) &gt;= 0);
				i += 1;
			}
		}
		val orderedParents: Array[IntArrayList] = new Array[IntArrayList](nV);
		{
			var i: Int = 0;
			while (i &lt; nV) {
				orderedParents(i) = new IntArrayList();
				i += 1;
			}
		}
		{
			var i: Int = 0;
			while (i &lt; nV) {
				{
					var ip: Int = 0;
					while (ip &lt; parents(i).size) {
						val p: Int = parents(i).get(ip);
						orderedParents(orderedId(i)).add(orderedId(p));
						ip += 1;
					}
				}
				i += 1;
			}
		}
		{
			var i: Int = 0;
			while (i &lt; nV) {
				java.util.Arrays.sort(orderedParents(i).a, 0, orderedParents(i).size);
				parents(i) = orderedParents(i);
				i += 1;
			}
		}
		{
			var i: Int = 0;
			while (i &lt; queries.length) {
				val typ: Int = queries(i).typ;
				val node: Int = queries(i).node;
				val value: Int = queries(i).value;
				Assert.check(0 &lt;= node &amp;&amp; node &lt; nV);
				queries(i) = new Query(typ, orderedId(node), value);
				i += 1;
			}
		}
	}

	def process(
		parents: Array[IntArrayList],
		queries: Array[Query],
		qFirst: Int,
		qAfter: Int,
		a: Array[Int],
		codes: Array[Long],
		add: Array[Int],
		min: Array[Int],
		result: IntArrayList
	): Unit = {
		val nV: Int = parents.length;
		val q12: IntArrayList = new IntArrayList();
		{
			var q = qFirst;
			while (q &lt; qAfter) {
				if (queries(q).typ &lt; 3) {
					q12.add(q);
				}
				q += 1;
			}
		}
		if (q12.size == 0) {
			var q: Int = qFirst;
			while (q &lt; qAfter) {
				Assert.check(queries(q).typ == 3);
				val node: Int = queries(q).node;
				Assert.check(0 &lt;= node &amp;&amp; node &lt; nV);
				result.add(a(node));
				q += 1;
			}
			return;
		}
		val n: Int = q12.size;
		Assert.check(n &lt;= 8 * 14);
		Assert.check(nV &lt;= 100000);
		java.util.Arrays.fill(codes, 0, nV * 2, 0);
		{
			var i: Int = 0;
			while (i &lt; n) {
				val node: Int = queries(q12.get(i)).node;
				val word: Int = i / 56;
				val shift: Int = i % 56 / 14 * 16 + i % 14; // 14 used bits, 2 free
				codes(node * 2 + word) |= 1L &lt;&lt; shift;
				i += 1;
			}
		}
		{
			var i: Int = 0;
			while (i &lt; nV) {
				{
					val pari: IntArrayList = parents(i);
					var ip: Int = 0;
					while (ip &lt; pari.size) {
						val p: Int = pari.get(ip);
						codes((i &lt;&lt; 1) + 0) |= codes((p &lt;&lt; 1) + 0);
						codes((i &lt;&lt; 1) + 1) |= codes((p &lt;&lt; 1) + 1);
						ip += 1;
					}
				}
				i += 1;
			}
		}
		var q: Int = qFirst;
		var part: Int = 0;
		while (part * 14 &lt; n) {
			val begin: Int = part * 14;
			val end: Int = Math.min(n, begin + 14);
			val codesAdd: Int = part / 4;
			val codesShift: Int = part % 4 * 16;
			// a = Math.min(a + add, min)
			add(0) = 0;
			min(0) = 1000 * 1000 * 1000;
			var bit: Int = 0;
			while (bit &lt; end - begin) {
				val qType: Int = queries(q12.get(begin + bit)).typ;
				val value: Int = queries(q12.get(begin + bit)).value;
				val extra: Int = 1 &lt;&lt; bit;
				if (qType == 1) { // assign
					var code: Int = 0;
					while (code &lt; extra) {
						add(code + extra) = 1000 * 1000 * 1000;
						min(code + extra) = value;
						code += 1;
					}
				} else {
					Assert.check(qType == 2); // min
					var code: Int = 0;
					while (code &lt; extra) {
						add(code + extra) = add(code);
						min(code + extra) = Math.min(value, min(code));
						code += 1;
					}
				}
				bit += 1;
			}
			var mask = 0;
			while (end == n &amp;&amp; q != qAfter || end != n &amp;&amp; q != q12.get(end)) {
				if (queries(q).typ &lt; 3) {
					mask &lt;&lt;= 1;
					mask |= 1;
				} else {
					Assert.check(queries(q).typ == 3);
					val node: Int = queries(q).node;
					val code: Int = ((codes((node &lt;&lt; 1) + codesAdd) &gt;&gt; codesShift) &amp; mask).toInt;
					val answer: Int = Math.min(a(node) + add(code), min(code));
					result.add(answer);
				}
				q += 1;
			}
			var i = 0;
			while (i &lt; nV) {
				val code: Int = ((codes((i &lt;&lt; 1) + codesAdd) &gt;&gt; codesShift) &amp; 0xFFFF).toInt;
				a(i) = Math.min(a(i) + add(code), min(code));
				i += 1;
			}
			part += 1;
		}
	}

	def solveFast(parents: Array[IntArrayList], queries: Array[Query]): IntArrayList = {
		val nV: Int = parents.length;
		{
			var i: Int = 0;
			while (i &lt; nV) {
				{
					var ip: Int = 0;
					while (ip &lt; parents(i).size) {
						val p: Int = parents(i).get(ip);
						Assert.check(p &lt; i); // parents before children
						ip += 1;
					}
				}
				i += 1;
			}
		}
		val a: Array[Int] = new Array[Int](nV);
		val codes: Array[Long] = new Array[Long](100000 * 2);
		val add: Array[Int] = new Array[Int](1 &lt;&lt; 14);
		val min: Array[Int] = new Array[Int](1 &lt;&lt; 14);
		val result: IntArrayList = new IntArrayList();
		val MAX12Q = 8 * 14;
		var first: Int = 0;
		var n12q: Int = 0;
		val nQ: Int = queries.length;
		{
			var i: Int = 0;
			while (i &lt; nQ) {
				if (queries(i).typ &lt; 3) {
					n12q += 1;
				}
				if (n12q == MAX12Q || i == nQ - 1) {
					process(parents, queries, first, i + 1, a, codes, add, min, result);
					first = i + 1;
					n12q = 0;
				}
				i += 1;
			}
		}
		return result;
	}

	def main(args: Array[String]): Unit = {
		val in: Scanner = new Scanner(System.in);
		val nV: Int = in.nextInt();
		val nE: Int = in.nextInt();
		val nQ: Int = in.nextInt();
		val parents: Array[IntArrayList] = new Array[IntArrayList](nV);
		{
			var i: Int = 0;
			while (i &lt; nV) {
				parents(i) = new IntArrayList();
				i += 1;
			}
		}
		{
			var i: Int = 0;
			while (i &lt; nE) {
				val parent: Int = in.nextInt() - 1;
				val child: Int = in.nextInt() - 1;
				parents(child).add(parent);
				i += 1;
			}
		}
		val queries: Array[Query] = new Array[Query](nQ);
		{
			var i: Int = 0;
			while (i &lt; nQ) {
				val qType: Int = in.nextInt();
				if (qType == 1 || qType == 2) {
					val parent: Int = in.nextInt() - 1;
					val value: Int = in.nextInt();
					queries(i) = new Query(qType, parent, value);
				} else {
					Assert.check(qType == 3);
					val node: Int = in.nextInt() - 1;
					queries(i) = new Query(qType, node, -1);
				}
				i += 1;
			}
		}
		reorder(parents, queries);
		val result: IntArrayList = solveFast(parents, queries);
		{
			var i: Int = 0;
			while (i &lt; result.size) {
				println(result.get(i));
				i += 1;
			}
		}
	}
}

----------
====================
----------
ALGORITHMS.209
advanced
----------
PROBLEM STATEMENT:
Johnny, like every mathematician, has his favorite sequence of distinct natural numbers.  Let’s call this sequence [expression] and then threw the notebook out onto the street. You just found it. Can you reconstruct the sequence? 

In the input there are [expression]. If there are many such sequences, return the lexicographically smallest one. It is guaranteed that such a sequence exists.

Note 
Sequence [expression].
----------
TOP SOLUTION:
----------
//gshkrtiladze

#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;

#define pb push_back
#define getcx getchar//_unlocked

using namespace std;

inline void inp(int &amp;n )
 {n=0; int ch=getcx();
  while(ch&lt;'0'||ch&gt;'9') ch=getcx();
  while(ch&gt;='0'&amp;&amp;ch&lt;='9') n=(n&lt;&lt;3)+(n&lt;&lt;1)+ch-'0',ch=getcx(); }

int n,k,b,a,i;
int xr[1000001];
bool f[1000001];

vector &lt; int &gt; nx[1000001];
priority_queue &lt; int &gt; st;

int main() {
   inp(n);
   while (n--) {
     inp(k);
     cin&gt;&gt;b; f[b]=1;
     for (i=2;i&lt;=k;i++) {
       inp(a); xr[a]++;
       nx[b].pb(a);
       b=a; f[b]=1;
      }
    }
   for (i=0;i&lt;=1000000;i++)
    if (f[i] &amp;&amp; xr[i] == 0)
     st.push(-i);
   while (st.size() &gt; 0)
    {
     k=-st.top();
     printf("%d ",k);
     st.pop();
     for (i=0;i&lt;nx[k].size();i++) {
      xr[nx[k][i]]--; if (xr[nx[k][i]] == 0) st.push(-nx[k][i]); }
    }
   printf("\n");
 }

----------
====================
----------
ALGORITHMS.210
advanced
----------
PROBLEM STATEMENT:
It's almost summertime, so Big Cat and Little Cat are getting in shape. They decide the core of their fitness plan is to start jogging every day.

Their city consists of [expression] different roads.

The cats also love exploring new places, so each day they want to choose a new route to jog on that is not equal to any of their previous routes. Two routes are considered to be equal if their sets of component roads are equal.

Given a map of the city, can you help our heroic cats determine the maximum number of days they can go jogging so that every route traveled is different? 
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;map&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#define ll long long
using namespace std;
const int Maxn = 100010 , Maxm = 11, Mo = 1e9 + 7;
const ll oo = 1ll &lt;&lt; 60;
#define PB push_back

int T, cs = 1;
int n , m , k;
vector&lt;int&gt; e[Maxn];
int cnt[Maxn];
int main(){
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1, u, v; i &lt;= m; i++){
        cin &gt;&gt; u &gt;&gt; v;
        e[u].PB(v);
        e[v].PB(u);
    }
    ll ans = 0;
    for (int u = 1; u &lt;= n; u++){
        vector&lt;int&gt; all;
        for (int i = 0; i &lt; e[u].size(); i++){
            int v = e[u][i];
            for (int k =0; k &lt; e[v].size(); k++){
                int t = e[v][k];
                if (t == u) continue;
                if (cnt[t] == 0) all.PB(t);
                ans += cnt[t];
                cnt[t] ++;                
            }
        }
        for (int i = 0; i &lt; all.size(); i++) cnt[all[i]] = 0;
    }
    cout &lt;&lt; ans / 4 &lt;&lt; endl;
}
----------
====================
----------
ALGORITHMS.211
advanced
----------
PROBLEM STATEMENT:
There are [expression]. There are three types of queries needed:&nbsp;


X i j Reflect all points in the inclusive range between points [expression]-axis.  
Y i j Reflect all points in the inclusive range between points [expression]-axis. 
C i j Count the number of points in the inclusive range between points [expression] quadrants. Then print a single line of four space-separated integers describing the respective numbers of points in the first, second, third, and fourth quadrants in that order. 


As a reminder, the four quadrants of a graph are labeled as follows: 
    

Given a set of [expression], so the fourth query output is 0 1 1 0.

Note: Points may sometimes share the same coordinates.  

Function Description  

Complete the quadrants function in the editor below.  It should print the results of each C type query on a new line.  

quadrants has the following parameters: 
- p[p[1]...p[n]]: a 2-dimensional array of integers where each element [expression] 
- queries[queries[1]...queries[n]: an array of strings  
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include &lt;iostream&gt;
#include &lt;memory.h&gt;


const int maxn = 65536*2;

struct st_node{
	int total[4];
	bool x,y;
	
};

static st_node nodes[maxn*2-1];
int n;

int tree_insert(int node, int l, int r, int index, int* total){
	for (int i=0; i&lt;4; i++)
		nodes[node].total[i] += total[i];
	if (l&lt;r){
		int mid = (l+r)/2;
		if (index&lt;=mid)
			tree_insert(node*2+1, l, mid, index, total);
		else 
			tree_insert(node*2+2, mid+1, r, index, total);
	}
}

int read_point(){
	memset(nodes, 0, sizeof(nodes));
	std::cin&gt;&gt;n;
	for (int i=1; i&lt;=n; i++){
		int x,y;
		int total[4];
		memset(total, 0, sizeof(total));
		std::cin&gt;&gt;x&gt;&gt;y;
		if (x==0 &amp;&amp; y==0)
			continue;
		if (x&gt;0 &amp;&amp; y&gt;0)
			total[0] = 1;
		if (x&lt;0 &amp;&amp; y&gt;0)
			total[1] = 1;
		if (x&lt;0 &amp;&amp; y&lt;0)
			total[2] = 1;
		if (x&gt;0 &amp;&amp; y&lt;0)
			total[3] = 1;
		tree_insert(0,1,n,i,total);
	}			
}

void swap(int &amp;x, int&amp;y){
	x = x^y;
	y = x^y;
	x = x^y;	
}

void reflect(int *total, bool xreflect, bool yreflect){
	if (xreflect){
		swap(total[0],total[3]);
		swap(total[1],total[2]);			
	}
	if (yreflect){
		swap(total[0],total[1]);
		swap(total[2],total[3]);
	}			
}

int tree_count(int node, int l, int r, int x, int y, int* total, bool xreflect, bool yreflect){

	xreflect ^= nodes[node].x;
	yreflect ^= nodes[node].y;

	if (x&lt;=l &amp;&amp; r&lt;=y){
		int tmp[4];		
		for (int i=0; i&lt;4; i++)
			tmp[i] = nodes[node].total[i];
		reflect(tmp, xreflect, yreflect);
		for (int i=0; i&lt;4; i++)
			total[i] += tmp[i];
		return 0;
	} 

	if (l&lt;r){
		int mid = (l+r)/2;
		if (x&lt;=mid)
			tree_count(node*2+1, l, mid, x, y, total, xreflect, yreflect);
		if (y&gt;=mid+1)
			tree_count(node*2+2, mid+1, r, x, y, total, xreflect, yreflect);
	}
}

int tree_reflect(int node, int l, int r, int x, int y, bool xreflect, bool yreflect){
	if (x&lt;=l &amp;&amp; r&lt;=y){
		nodes[node].x ^= xreflect;
		nodes[node].y ^= yreflect;
		return 0;
	}
	if (l&lt;r){
		int mid=(l+r)/2;
		if (x&lt;=mid)
			tree_reflect(node*2+1, l, mid, x, y, xreflect, yreflect);
		if (y&gt;=mid+1)
			tree_reflect(node*2+2, mid+1, r, x, y, xreflect, yreflect);
		int ltotal[4], rtotal[4];				
		for (int i=0; i&lt;4; i++){
			ltotal[i] = nodes[node*2+1].total[i];
			rtotal[i] = nodes[node*2+2].total[i];		
		}
		reflect(ltotal, nodes[node*2+1].x, nodes[node*2+1].y);
		reflect(rtotal, nodes[node*2+2].x, nodes[node*2+2].y);
		for (int i=0; i&lt;4; i++)
			nodes[node].total[i] = ltotal[i]+rtotal[i];
	}	
}

int solve(){
	int q; 
	std::cin&gt;&gt;q;
	for (int i=0; i&lt;q; i++){
		char type;
		int x, y;
		std::cin&gt;&gt;type&gt;&gt;x&gt;&gt;y;
		if (type=='C'){
			int total[4];
			memset(total, 0, sizeof(total));
			tree_count(0, 1, n, x, y, total, false, false);
			std::cout&lt;&lt;total[0]&lt;&lt;" "&lt;&lt;total[1]&lt;&lt;" "&lt;&lt;total[2]&lt;&lt;" "&lt;&lt;total[3]&lt;&lt;std::endl;			
		}		
		else if (type=='X'){
			tree_reflect(0, 1, n, x, y, true, false);			
		} 
		else if (type=='Y'){
			tree_reflect(0, 1, n, x, y, false, true);
			
		}		
	}
}

int main(){
	read_point();
	solve();
}


----------
====================
----------
ALGORITHMS.212
hard
----------
PROBLEM STATEMENT:
There are N cities in Hacker Country. Each pair of cities are directly connected by a unique directed road, and each road has its own toll that must be paid every time it is used. You're planning a road trip in Hacker Country, and its itinerary must satisfy the following conditions:  


You can start in any city.
You must use [expression] or more cities).
At the end of your trip, you should be back in your city of origin.
The average cost (sum of tolls paid per road traveled) should be minimum.


Can you calculate the minimum average cost of a trip in Hacker Country?

Time Limits 
Time limits for this challenge are provided here.
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int N = 510;
const int inf = (int)1e9;

int a[N][N];
int d[N][N];

int main() {
    int n;
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt; n; j++) scanf("%d", a[i] + j);
    for (int i = 0; i &lt; n; i++) d[0][i] = 0;
    for (int it = 0; it &lt; n; it++) {
        for (int i = 0; i &lt; n; i++) d[it + 1][i] = inf;
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; n; j++) {
              if (i == j) {
                continue;
              }
              int dt = d[it][i] + a[i][j];
              if (dt &lt; d[it + 1][j]) {
                  d[it + 1][j] = dt;
              }
            }
    }
    long long p = inf, q = 1;
    for (int i = 0; i &lt; n; i++) {
        long long pp = 0, qq = 1;
        for (int it = 0; it &lt; n; it++) {
            long long num = d[n][i] - d[it][i];
            long long den = n - it;
            if (num * qq &gt; pp * den) {
                pp = num;
                qq = den;
            }
        }
        if (pp * q &lt; p * qq) {
            p = pp;
            q = qq;
        }
    }
    int xx = p, yy = q;
    while (xx &gt; 0 &amp;&amp; yy &gt; 0)
        if (xx &gt; yy) xx %= yy;
        else yy %= xx;
    int g = xx + yy;
    p /= g;
    q /= g;
    printf("%d/%d", (int)p, (int)q);
    return 0;
}

----------
====================
----------
ALGORITHMS.213
hard
----------
PROBLEM STATEMENT:
Update: A slight modification in the problem statement (see below)  

Evil Nation A is angry and plans to launch N guided-missiles at the peaceful Nation B in an attempt to wipe out all of Nation B's people. Nation A's missile i will arrive in nation B at time ti. Missile i communicates with its headquarters by unique radio signals with a frequency equal to fi. Can you help the peaceful Nation B survive by building a defensive system that will stop the missiles dead in the sky?

Defensive system:  

The only way to defend Nation B from the attacking missile is by counter attacking them with a hackerX missile. You have a lot of hackerX missiles and each one of them has its own radio frequency. An individual hackerX missile can destroy Evil Nation A’s attacking missile if the radio frequency of both of the missiles match. Each hackerX missile can be used an indefinite number of times. Its invincible and doesn't get destroyed in the collision.

The good news is you can adjust the frequency of the hackerX missile to match the evil missiles' frequency. When changing the hackerX missile's initial frequency fA to the new defending frequency fB, you will need \|fB - fA\| units of time to do. 

Each hackerX missile can only destroy one of Nation A's missile at a time. So if two evil missiles with same frequency arrive at the same time, you need at least two hackerX missiles with the same frequency as the evil missiles to avoid damage. 

If two evil missles with same frequency arrive at the same time, we can destroy them both with one hackerX missile. You can set the frequency of a hackerX missile to any value when its fired.  

What is the minimum number of hackerX missiles you must launch to keep Nation B safe?

Input Format: 
The first line contains a single integer N denoting the number of missiles. 
This is followed by N lines each containing two integers ti and fi denoting the time &amp; frequency of the ith missile.

Output Format: 
A single integer denoting the minimum number of hackerX missiles you need to defend the nation.

Constraints: 
1 &lt;=  N  &lt;= 100000 
0 &lt;= ti &lt;= 100000 
0 &lt;= fi &lt;= 100000 
t1 &lt;= t2 &lt;= ... &lt;= tN  

Sample Input #00  

4
1 1
2 2
3 1
5 1


Sample Output #00  

1


Explanation #00

A HackerX missile is launched at t = 1 with a frequency f = 1, and destroys the first missile. It re-tunes its frequency to f = 2 in 1 unit of time, and destroys the missile that is going to hit Nation B at t = 2. It re-tunes its frequency back to 1 in 1 unit of time and destroys the missile that is going to hit the nation at t = 3. It is relaunched at t = 5 with f = 1 and destroys the missile that is going to hit nation B at t = 5. Hence, you need only 1 HackerX to protect nation B. 

Sample Input #01  

4
1 1
2 3
3 1
5 1


Sample Output #01  

2


Explanation #01

Destroy 1 missile at t = 1, f = 1. now at t = 2, there is a missile with frequency 3. The launched missile takes 2 units of time to destroy this, hence we need a new hackerX missile to destroy this one. The first hackerX missile can destroy the 3rd missile which has the same frequency as itself. The same hackerX missile destroys the missile that is hitting its city at t = 5. Thus, we need atleast 2 hackerX missiles. 
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.Arrays;

public class Solution {

    static class Point implements Comparable&lt;Point&gt; {
        int x, y;

        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public int compareTo(Point o) {
            if (x == o.x) {
                return y - o.y;
            }
            return x - o.x;
        }
    }

    public static void solve(Input in, PrintWriter out) throws IOException {
        int n = in.nextInt();
        Point[] ps = new Point[n];
        for (int i = 0; i &lt; n; ++i) {
            int t = in.nextInt();
            int f = in.nextInt();
            ps[i] = new Point(t - f, t + f);
        }
        Arrays.sort(ps);
        int[] max = new int[n + 1];
        Arrays.fill(max, Integer.MIN_VALUE);
        max[0] = Integer.MAX_VALUE;
        for (Point p : ps) {
//            System.err.println(p.y);
            int l = 0, r = n;
            while (l &lt; r - 1) {
                int mid = (l + r) / 2;
                if (max[mid] &gt; p.y) {
                    l = mid;
                } else {
                    r = mid;
                }
            }
            max[l + 1] = p.y;
        }
//        System.err.println(Arrays.toString(max));
        int ans = 0;
        while (ans &lt; n &amp;&amp; max[ans + 1] &gt; Integer.MIN_VALUE) {
            ++ans;
        }
        out.println(ans);
    }

    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);
        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);
        out.close();
    }

    static class Input {
        BufferedReader in;
        StringBuilder sb = new StringBuilder();

        public Input(BufferedReader in) {
            this.in = in;
        }

        public Input(String s) {
            this.in = new BufferedReader(new StringReader(s));
        }

        public String next() throws IOException {
            sb.setLength(0);
            while (true) {
                int c = in.read();
                if (c == -1) {
                    return null;
                }
                if (" \n\r\t".indexOf(c) == -1) {
                    sb.append((char)c);
                    break;
                }
            }
            while (true) {
                int c = in.read();
                if (c == -1 || " \n\r\t".indexOf(c) != -1) {
                    break;
                }
                sb.append((char)c);
            }
            return sb.toString();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }
}

----------
====================
----------
ALGORITHMS.214
expert
----------
PROBLEM STATEMENT:
Huarongdao is a well-known game in China. The purpose of this game is to move the Cao Cao block out of the board. 

Acme is interested in this game, and he invents a similar game. There is a N*M board. Some blocks in this board are movable, while some are fixed. There is only one empty position. In one step, you can move a block to the empty position, and it will take you one second. The purpose of this game is to move the Cao Cao block to a given position. Acme wants to finish the game as fast as possible. 

But he finds it hard, so he cheats sometimes. When he cheats, he spends K seconds to pick a block and put it in an empty position. However, he is not allowed to pick the Cao Cao block out of the board .

Note 


Immovable blocks cannot be moved while cheating. 
A block can be moved only in the directions UP, DOWN, LEFT or RIGHT. 

----------
TOP SOLUTION:
----------
/******************************************************************************\
*                         Author:  Dumbear                                     *
*                         Email:   dumbear[#at]163.com                         *
*                         Website: http://dumbear.com                          *
\******************************************************************************/
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;cctype&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;numeric&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;typeinfo&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

using namespace std;

#define output(x) cout &lt;&lt; #x &lt;&lt; ": " &lt;&lt; (x) &lt;&lt; endl;

typedef long long LL;
typedef vector&lt;int&gt; VI;
typedef vector&lt;long long&gt; VL;
typedef vector&lt;double&gt; VD;
typedef vector&lt;string&gt; VS;

const int max_n = 200 + 10, max_m = max_n;
const int delta[][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

int n, m, cheat, q, cost[max_n][max_m][4][4], total[max_n][max_m][4];
char board[max_n][max_m];
map&lt;pair&lt;int, int&gt;, int&gt; cost_map;
bool in[max_n][max_m][4];

void bfs(int x0, int y0, int fx, int fy, int limit) {
    queue&lt;pair&lt;int, int&gt; &gt; q;
    cost_map.clear();
    q.push(make_pair(x0, y0));
    cost_map[q.front()] = 0;
    while (!q.empty()) {
        int x = q.front().first, y = q.front().second, c = cost_map[q.front()];
        q.pop();
        for (int i = 0; i &lt; 4; ++i) {
            int nx = x + delta[i][0], ny = y + delta[i][1];
            if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || board[nx][ny] == 0 || (nx == fx &amp;&amp; ny == fy))
                continue;
            pair&lt;int, int&gt; k(nx, ny);
            if (cost_map.find(k) != cost_map.end())
                continue;
            if (c + 1 &lt; limit)
                q.push(k);
            cost_map[k] = c + 1;
        }
    }
}

void pre_compute() {
    memset(cost, -1, sizeof(cost));
    for (int x0 = 0; x0 &lt; n; ++x0) {
        for (int y0 = 0; y0 &lt; m; ++y0) {
            if (board[x0][y0] == 0)
                continue;
            for (int k = 0; k &lt; 4; ++k) {
                int x1 = x0 + delta[k][0], y1 = y0 + delta[k][1];
                if (x1 &lt; 0 || x1 &gt;= n || y1 &lt; 0 || y1 &gt;= m || board[x1][y1] == 0)
                    continue;
                bfs(x0, y0, x1, y1, cheat - 1);
                for (int step = 0; step &lt; 4; ++step) {
                    int x2 = x1 + delta[step][0], y2 = y1 + delta[step][1];
                    if (x2 &lt; 0 || x2 &gt;= n || y2 &lt; 0 || y2 &gt;= m || board[x2][y2] == 0 || (x2 == x0 &amp;&amp; y2 == y0))
                        continue;
                    cost[x0][y0][k][step] = cheat + 1;
                    map&lt;pair&lt;int, int&gt;, int&gt;::iterator it = cost_map.find(make_pair(x2, y2));
                    if (it != cost_map.end())
                        cost[x0][y0][k][step] = it-&gt;second + 1;
                }
            }
        }
    }
}

int process() {
    int ex, ey, x0, y0, tx, ty;
    scanf("%d%d%d%d%d%d", &amp;ex, &amp;ey, &amp;x0, &amp;y0, &amp;tx, &amp;ty);
    --ex; --ey; --x0; --y0; --tx; --ty;
    if (x0 == tx &amp;&amp; y0 == ty)
        return 0;
    if (ex == x0 &amp;&amp; ey == y0)
        return -1;
    bfs(ex, ey, x0, y0, cheat - 1);
    queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt; &gt; q;
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; m; ++j) {
            for (int k = 0; k &lt; 4; ++k) {
                in[i][j][k] = false;
                total[i][j][k] = INT_MAX;
            }
        }
    }
    for (int k = 0; k &lt; 4; ++k) {
        int x1 = x0 + delta[k][0], y1 = y0 + delta[k][1];
        if (x1 &lt; 0 || x1 &gt;= n || y1 &lt; 0 || y1 &gt;= m || board[x1][y1] == 0)
            continue;
        q.push(make_pair(make_pair(x0, y0), k));
        in[x0][y0][k] = true;
        total[x0][y0][k] = cheat + 1;
        map&lt;pair&lt;int, int&gt;, int&gt;::iterator it = cost_map.find(make_pair(x1, y1));
        if (it != cost_map.end())
            total[x0][y0][k] = it-&gt;second + 1;
    }
    while (!q.empty()) {
        int x0 = q.front().first.first, y0 = q.front().first.second;
        int k = q.front().second, c = total[x0][y0][k];
        q.pop();
        int x1 = x0 + delta[k][0], y1 = y0 + delta[k][1];
        for (int step = 0; step &lt; 4; ++step) {
            if (cost[x0][y0][k][step] == -1)
                continue;
            if (c + cost[x0][y0][k][step] &lt; total[x1][y1][step]) {
                if (!in[x1][y1][step]) {
                    q.push(make_pair(make_pair(x1, y1), step));
                    in[x1][y1][step] = true;
                }
                total[x1][y1][step] = c + cost[x0][y0][k][step];
            }
        }
    }
    int res = INT_MAX;
    for (int x0 = 0; x0 &lt; n; ++x0)
        for (int y0 = 0; y0 &lt; m; ++y0)
            for (int k = 0; k &lt; 4; ++k)
                if (x0 + delta[k][0] == tx &amp;&amp; y0 + delta[k][1] == ty)
                    res = min(res, total[x0][y0][k]);
    return res == INT_MAX ? -1 : res;
}

void solve() {
    scanf("%d%d%d%d", &amp;n, &amp;m, &amp;cheat, &amp;q);
    for (int i = 0; i &lt; n; ++i)
        for (int j = 0; j &lt; m; ++j)
            scanf("%d", &amp;board[i][j]);
    pre_compute();
    for (int i = 0; i &lt; q; ++i)
        printf("%d\n", process());
}

int main() {
    solve();
    return 0;
}

----------
====================
----------
ALGORITHMS.215
hard
----------
PROBLEM STATEMENT:
In the magical kingdom of Kasukabe, people strive to possess skillsets. Higher the number of skillset present among the people, the more content people will be.  

There are [expression]. 

There are [expression] then following transformation can be done by that trainer.

[expression]

Once a transformation is done, both skill is removed from the respective lists. In the above example, if he perform  [expression]. This updated list will be used for further transformations.

Few points to note are:


One person can possess only one skill set.
A wizard can perform zero or more transformation as long as they satisfies the above criteria. 
A person can go through multiple transformation of skill set.
Same class transformation is also possible. That is a person' skill set can be transformed into his current skill set. Eg. [expression] in the above example.


Your goal is to design a series of transformation which results into maximum number of skill set with non-zero number of people knowing it.
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.Arrays;

public class HR_training_the_army {

    public static void solve(Input in, PrintWriter out) throws IOException {
        int n = in.nextInt();
        int m = in.nextInt();
        int gn = n + m + 2;
        int s = n + m;
        int t = n + m + 1;
        int[][] g = new int[gn][gn];
        for (int i = 0; i &lt; n; ++i) {
            g[s][i] = in.nextInt();
            g[i][t] = 1;
        }
        for (int it = 0; it &lt; m; ++it) {
            int as = in.nextInt();
            for (int i = 0; i &lt; as; ++i) {
                int a = in.nextInt() - 1;
                g[a][n + it] = 1;
            }
            int bs = in.nextInt();
            for (int i = 0; i &lt; bs; ++i) {
                int b = in.nextInt() - 1;
                g[n + it][b] = 1;
            }
        }
        boolean[] col = new boolean[gn];
        int ans = 0;
        while (dfs(s, t, g, col)) {
            ans++;
            Arrays.fill(col, false);
        }
        out.println(ans);
    }

    private static boolean dfs(int s, int t, int[][] g, boolean[] col) {
        if (s == t) {
            return true;
        }
        if (col[s]) {
            return false;
        }
        col[s] = true;
        for (int j = 0; j &lt; g.length; ++j) {
            if (g[s][j] &gt; 0 &amp;&amp; dfs(j, t, g, col)) {
                g[s][j]--;
                g[j][s]++;
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);
        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);
        out.close();
    }

    static class Input {
        BufferedReader in;
        StringBuilder sb = new StringBuilder();

        public Input(BufferedReader in) {
            this.in = in;
        }

        public Input(String s) {
            this.in = new BufferedReader(new StringReader(s));
        }

        public String next() throws IOException {
            sb.setLength(0);
            while (true) {
                int c = in.read();
                if (c == -1) {
                    return null;
                }
                if (" \n\r\t".indexOf(c) == -1) {
                    sb.append((char)c);
                    break;
                }
            }
            while (true) {
                int c = in.read();
                if (c == -1 || " \n\r\t".indexOf(c) != -1) {
                    break;
                }
                sb.append((char)c);
            }
            return sb.toString();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }
}

----------
====================
----------
ALGORITHMS.216
hard
----------
PROBLEM STATEMENT:
During the Steam Summer Sale, Jim's [expression]. The games are multiplayer. Jim has invited his friends to his basement where they will play by making a LAN-Party. 

Each friend has already decided the game he would like to play for the rest of the day. So there will be a group of friends who will play the same game together.

But then, they face a problem: Currently, none of the friends' PCs are connected. So they have to be connected using the available [expression]th wire one by one. So he starts with wire 1, then with wire 2 and so on. 

A group can start playing their game, only if all the members are connected (if not directly, then there must exist a path connecting them). They want to start playing as soon as possible. 

For each game, find out the wire after adding which the group can start playing. It is also possible that a group will never get connected. In such a case, this group starts crying and you should display -1.
----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;limits&gt;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus &gt; 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector&lt;int&gt; vi; typedef pair&lt;int,int&gt; pii; typedef vector&lt;pair&lt;int,int&gt; &gt; vpii;
typedef long long ll; typedef vector&lt;long long&gt; vl; typedef pair&lt;long long,long long&gt; pll; typedef vector&lt;pair&lt;long long,long long&gt; &gt; vpll;
typedef vector&lt;string&gt; vs; typedef long double ld;
template&lt;typename T, typename U&gt; inline void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; inline void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

struct UnionFind {
	vector&lt;int&gt; data;
	void init(int n) { data.assign(n, -1); }
	bool unionSet(int x, int y) {
		x = root(x); y = root(y);
		if(x != y) {
			if(data[y] &lt; data[x]) swap(x, y);
			data[x] += data[y]; data[y] = x;
		}
		return x != y;
	}
	bool findSet(int x, int y) { return root(x) == root(y); }
	int root(int x) { return data[x] &lt; 0 ? x : data[x] = root(data[x]); }
	int size(int x) { return -data[root(x)]; }
};

int main() {
	int N, M, Q;
	scanf("%d%d%d", &amp;N, &amp;M, &amp;Q);
	vector&lt;int&gt; A(N), cnt(M);
	rep(i, N) {
		scanf("%d", &amp;A[i]), -- A[i];
		++ cnt[A[i]];
	}
	vector&lt;map&lt;int,int&gt; &gt; a(N);
	rep(i, N)
		a[i][A[i]] = 1;
	vector&lt;int&gt; ans(M, -1);
	rep(i, M) if(cnt[i] &lt;= 1)
		ans[i] = 0;
	UnionFind uf;
	uf.init(N);
	rep(i, Q) {
		int u, v;
		scanf("%d%d", &amp;u, &amp;v), -- u, -- v;
		int ur = uf.root(u);
		int vr = uf.root(v);
		if(ur != vr) {
			uf.unionSet(ur, vr);
			int zr = uf.root(ur);
            if(ur != zr &amp;&amp; vr != zr) { cerr &lt;&lt; "error!" &lt;&lt; endl; abort(); }
			map&lt;int,int&gt; &amp;za = a[zr], &amp;wa = a[zr == ur ? vr : ur];
			if(za.size() &lt; wa.size())
				za.swap(wa);
			each(j, wa) {
				int k = j-&gt;first;
				if((za[k] += j-&gt;second) == cnt[k] &amp;&amp; ans[k] == -1)
					ans[k] = i + 1;
			}
			wa.clear();
		}
	}
	rep(i, M)
		printf("%d\n", ans[i]);
	return 0;
}

----------
====================
----------
ALGORITHMS.217
hard
----------
PROBLEM STATEMENT:
HackerLand is a country with [expression] undirected roads. Like every other beautiful country, HackerLand has traffic jams.

Each road has a crowd value. The crowd value of a path is defined as the maximum crowd value for all roads in the path. For example, if the crowd values for all roads are [expression].

Each city [expression], denoting the type of buildings in the city.

David just started his vacation in HackerLand. He wants to travel from city [expression] different types of buildings along the path, David always selects the one with the minimum crowd value.

You will be given [expression] different buildings along the route. If there is no such path, print -1.

Note: A path may contain cycles (i.e., the same roads or cities may be traveled more than once).
----------
TOP SOLUTION:
----------
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;cassert&gt;
#define PB push_back
#define MP make_pair
#define sz(v) (in((v).size()))
#define forn(i,n) for(in i=0;i&lt;(n);++i)
#define forv(i,v) forn(i,sz(v))
#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)
#define all(v) (v).begin(),(v).end()
using namespace std;
typedef long long in;
typedef vector&lt;in&gt; VI;
typedef vector&lt;VI&gt; VVI;
VI ans;
struct rsp{
  in gl,gsz,id;
  rsp(in a=0, in b=0, in c=0){
    gl=a;
    gsz=b;
    id=c;
  }
  bool operator&lt;(const rsp cp)const{
    if(gl!=cp.gl)
      return gl&lt;cp.gl;
    if(gsz!=cp.gsz)
      return gsz&lt;cp.gsz;
    return id&lt;cp.id;
  }
};
struct onc{
  in gsz,id;
  onc(in a=0, in b=0){
    gsz=a;
    id=b;
  }
  bool operator&lt;(const onc cp)const{
    if(gsz!=cp.gsz)
      return gsz&lt;cp.gsz;
    return id&lt;cp.id;
  }
};
in crsz;
struct unifnd{
  VI ht,pr;
  vector&lt;set&lt;onc&gt; &gt; oncs;
  vector&lt;set&lt;rsp&gt; &gt; rsps;
  vector&lt;set&lt;in&gt; &gt; blg,blgtyp;
  in fnd(in a){
    in ta=a;
    while(a!=pr[a])a=pr[a];
    in tt=ta;
    while(ta!=a){
      tt=pr[ta];
      pr[ta]=a;
      ta=tt;
    }
    return a;
  }
  void uni(in a, in b){
    a=fnd(a);
    b=fnd(b);
    if(a==b)return;
    if(ht[b]&lt;ht[a])swap(a,b);
    ht[b]+=ht[a];
    pr[a]=b;
    fors(i,blg[a]){
      blg[b].insert(*i);
    }
    fors(i,blgtyp[a]){
      blgtyp[b].insert(*i);
    }
    fors(i,rsps[a]){
      if(blg[b].find(i-&gt;gl)!=blg[b].end()){
	oncs[b].insert(onc(i-&gt;gsz,i-&gt;id));
      }
      else{
	rsps[b].insert(*i);
      }
    }
    auto it=oncs[b].begin();
    for(auto i=oncs[b].begin();i!=oncs[b].end();){
      if(i-&gt;gsz&lt;=sz(blgtyp[b])){
	if(ans[i-&gt;id]==-1)
	  ans[i-&gt;id]=crsz;
	it=i;
	++i;
	oncs[b].erase(it);
	continue;
      }
      break;
    }
    fors(i,oncs[a]){
      if(ans[i-&gt;id]!=-1)
	continue;
      if(i-&gt;gsz&lt;=sz(blgtyp[b])){
	ans[i-&gt;id]=crsz;
      }
      else{
	oncs[b].insert(*i);
      }
    }
  }
  void ini(in n){
    ht.resize(n);
    pr.resize(n);
    blg.resize(n);
    oncs.resize(n);
    rsps.resize(n);
    blgtyp.resize(n);
    forn(i,n){
      ht[i]=1;
      pr[i]=i;
      blg[i].insert(i);
    }
  }
};
unifnd tfd;
map&lt;in,vector&lt;pair&lt;in,in&gt; &gt; &gt; egs;
int main(){
  ios::sync_with_stdio(0);
  cin.tie(0);
  in n,m,q;
  cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;
  ans.resize(q,-1);
  tfd.ini(n);
  in ta,tb,tu;
  crsz=0;
  forn(z,n){
    cin&gt;&gt;tu;
    tfd.blgtyp[z].insert(tu);
  }
  forn(z,m){
    cin&gt;&gt;ta&gt;&gt;tb&gt;&gt;tu;
    --ta;
    --tb;
    egs[tu].PB(MP(ta,tb));
  }
  forn(z,q){
    cin&gt;&gt;ta&gt;&gt;tb&gt;&gt;tu;
    --ta;
    --tb;
    if(ta==tb){
      if(tu==1){
	ans[z]=0;
	continue;
      }
      ++tfd.ht[ta];
      tfd.oncs[ta].insert(onc(tu,z));
      continue;
    }
    ++tfd.ht[ta];
    ++tfd.ht[tb];
    tfd.rsps[ta].insert(rsp(tb,tu,z));
    tfd.rsps[tb].insert(rsp(ta,tu,z));
  }
  fors(i,egs){
    crsz=i-&gt;first;
    forv(j,i-&gt;second){
      tfd.uni(i-&gt;second[j].first,i-&gt;second[j].second);
    }
  }
  forn(z,q){
    cout&lt;&lt;ans[z]&lt;&lt;"\n";
  }
  return 0;
}

----------
====================
----------
ALGORITHMS.218
expert
----------
PROBLEM STATEMENT:
In order to entertain themselves during the long flight, Alex and Fedor invented the following very simple two players game. The game is:  


First, Alex draws some graph with bidirectional weighted edges. There are possibly multiple edges (probably, with different or same weights) in this graph.
Then Fedor picks some spanning tree of this graph. If the tree appears to be the minimal spanning tree, then the winner is Fedor. Otherwise, the winner is Alex.  


We consider two trees different if the sets of the numbers of edges that are included in these trees are different. We consider two sets [expression] or vice versa.  

We should also mention that the graphs with enormous number of spanning trees upset Alex, as well as Fedor, so they will never have a graph that has more than [expression] spanning trees.  

At some point, Fedor became too lazy to look for minimal spanning trees and now he just picks some arbitrary spanning tree from the Alex's graph. Each spanning tree has equal probability to be picked by Fedor. What is the probability of Fedor's victory now?   
----------
TOP SOLUTION:
----------
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;
import java.math.BigInteger;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.Iterator;
import java.io.IOException;
import java.util.Arrays;
import java.io.InputStream;
import java.util.Random;
import java.util.Map;
import java.io.OutputStreamWriter;
import java.util.AbstractMap;
import java.util.Comparator;
import java.util.AbstractSet;
import java.util.Set;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Egor Kulikov (egor@egork.net)
 */
public class Solution {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		AlexVsFedor solver = new AlexVsFedor();
		solver.solve(1, in, out);
		out.close();
	}
}

class AlexVsFedor {
	int[] mods = new int[2];

	{
		int j = 0;
		for (int i = (int) 1e9; j &lt; mods.length; i++) {
			if (IntegerUtils.isPrime(i)) {
				mods[j++] = i;
			}
		}
	}

    public void solve(int testNumber, InputReader in, OutputWriter out) {
		int count = in.readInt();
		int edgeCount = in.readInt();
		int[] from = new int[edgeCount];
		int[] to = new int[edgeCount];
		int[] weight = new int[edgeCount];
		IOUtils.readIntArrays(in, from, to, weight);
		ArrayUtils.orderBy(weight, from, to);
		MiscUtils.decreaseByOne(from, to);
		int start = 0;
		IndependentSetSystem setSystem = new RecursiveIndependentSetSystem(count);
		long numerator = 1;
		for (int i = 1; i &lt;= edgeCount; i++) {
			if (i == edgeCount || weight[i] != weight[i - 1]) {
				Graph graph = new BidirectionalGraph(count);
				for (int j = start; j &lt; i; j++) {
					if (setSystem.get(from[j]) != setSystem.get(to[j])) {
						graph.addSimpleEdge(setSystem.get(from[j]), setSystem.get(to[j]));
					}
				}
				boolean[] visited = new boolean[count];
				for (int j = 0; j &lt; count; j++) {
					if (!visited[j] &amp;&amp; graph.firstOutbound(j) != -1) {
						numerator *= count(build(j, graph, visited));
					}
				}
				for (int j = start; j &lt; i; j++) {
					setSystem.join(from[j], to[j]);
				}
				start = i;
			}
		}
		long denominator = count(build(0, BidirectionalGraph.createGraph(count, from, to), new boolean[count]));
		out.printLine(new Rational(numerator, denominator));
    }

	private int[][] build(int id, Graph graph, boolean[] visited) {
		Indexer&lt;Integer&gt; indexer = new Indexer&lt;&gt;();
		dfs(id, graph, visited, indexer);
		int[][] matrix = new int[indexer.size()][indexer.size()];
		for (Map.Entry&lt;Integer, Integer&gt; entry : indexer.entrySet()) {
			int from = entry.getValue();
			for (int i = graph.firstOutbound(entry.getKey()); i != -1; i = graph.nextOutbound(i)) {
				int to = indexer.get(graph.destination(i));
				matrix[from][from]--;
				matrix[to][to]--;
				matrix[from][to]++;
				matrix[to][from]++;
			}
		}
		return matrix;
	}

	private void dfs(int id, Graph graph, boolean[] visited, Indexer&lt;Integer&gt; indexer) {
		if (visited[id]) {
			return;
		}
		indexer.get(id);
		visited[id] = true;
		for (int i = graph.firstOutbound(id); i != -1; i = graph.nextOutbound(i)) {
			dfs(graph.destination(i), graph, visited, indexer);
		}
	}

	long count(int[][] matrix) {
		long[][] m = new long[matrix.length - 1][matrix.length - 1];
		long result = 0;
		long mod = 1;
		for (int cMod : mods) {
			for (int j = 0; j &lt; m.length; j++) {
				for (int k = 0; k &lt; m.length; k++) {
					m[j][k] = matrix[j][k] &gt;&gt; 1;
				}
			}
			for (int j = 0; j &lt; m.length; j++) {
				boolean found = false;
				for (int k = j; k &lt; m.length; k++) {
					if (m[k][j] != 0) {
						found = true;
						for (int l = j; l &lt; m.length; l++) {
							long temp = m[j][l];
							m[j][l] = m[k][l];
							m[k][l] = temp;
						}
						break;
					}
				}
				if (!found) {
					break;
				}
				long reverse = IntegerUtils.reverse(m[j][j], cMod);
				for (int k = j + 1; k &lt; m.length; k++) {
					for (int l = m.length - 1; l &gt;= j; l--) {
						m[k][l] -= m[j][l] * m[k][j] % cMod * reverse;
						m[k][l] %= cMod;
					}
				}
			}
			long cResult = m.length % 2 == 0 ? 1 : -1;
			for (int j = 0; j &lt; m.length; j++) {
				cResult *= m[j][j];
				cResult %= cMod;
			}
			if (cResult &lt; 0) {
				cResult += cMod;
			}
			result = IntegerUtils.findCommon(result, mod, cResult, cMod);
			mod *= cMod;
		}
		return result;
	}
}

class IntegerUtils {
	public static long gcd(long a, long b) {
        a = Math.abs(a);
        b = Math.abs(b);
		while (b != 0) {
			long temp = a % b;
			a = b;
			b = temp;
		}
		return a;
	}

	public static int longCompare(long a, long b) {
		if (a &lt; b)
			return -1;
		if (a &gt; b)
			return 1;
		return 0;
	}

	public static long power(long base, long exponent, long mod) {
		if (base &gt;= mod)
			base %= mod;
		if (exponent == 0)
			return 1 % mod;
		long result = power(base, exponent &gt;&gt; 1, mod);
		result = result * result % mod;
		if ((exponent &amp; 1) != 0)
			result = result * base % mod;
		return result;
	}

	public static long reverse(long number, long module) {
		return power(number, module - 2, module);
	}

	public static boolean isPrime(long number) {
		if (number &lt; 2)
			return false;
		for (long i = 2; i * i &lt;= number; i++) {
			if (number % i == 0)
				return false;
		}
		return true;
	}

	public static long findCommon(long aRemainder, long aMod, long bRemainder, long bMod) {
		long modGCD = gcd(aMod, bMod);
		long gcdRemainder = aRemainder % modGCD;
		if (gcdRemainder != bRemainder % modGCD)
			return -1;
		aMod /= modGCD;
		aRemainder /= modGCD;
		bMod /= modGCD;
		bRemainder /= modGCD;
		long aReverse = BigInteger.valueOf(aMod).modInverse(BigInteger.valueOf(bMod)).longValue();
		long bReverse = BigInteger.valueOf(bMod).modInverse(BigInteger.valueOf(aMod)).longValue();
		long mod = aMod * bMod;
		long result = BigInteger.valueOf(bReverse * aRemainder % mod).multiply(BigInteger.valueOf(bMod)).add(
			BigInteger.valueOf(aReverse * bRemainder % mod).multiply(BigInteger.valueOf(aMod))
		).mod(BigInteger.valueOf(mod)).longValue() * modGCD + gcdRemainder;
//		return (bReverse * aRemainder % mod * bMod + aReverse * bRemainder % mod * aMod) % mod * modGCD + gcdRemainder;
		return result;
	}

}

class InputReader {

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar &gt;= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars &lt;= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c &lt; '0' || c &gt; '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public boolean isSpaceChar(int c) {
		if (filter != null)
			return filter.isSpaceChar(c);
		return isWhitespace(c);
	}

	public static boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	public interface SpaceCharFilter {
		public boolean isSpaceChar(int ch);
	}
}

class OutputWriter {
	private final PrintWriter writer;

	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
	}

	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}

	public void print(Object...objects) {
		for (int i = 0; i &lt; objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void printLine(Object...objects) {
		print(objects);
		writer.println();
	}

	public void close() {
		writer.close();
	}

}

class IOUtils {

	public static void readIntArrays(InputReader in, int[]... arrays) {
		for (int i = 0; i &lt; arrays[0].length; i++) {
			for (int j = 0; j &lt; arrays.length; j++)
				arrays[j][i] = in.readInt();
		}
	}

}

class ArrayUtils {
	private static int[] tempInt = new int[0];

	public static int[] createOrder(int size) {
		int[] order = new int[size];
		for (int i = 0; i &lt; size; i++)
			order[i] = i;
		return order;
	}

	public static int[] sort(int[] array, IntComparator comparator) {
		return sort(array, 0, array.length, comparator);
	}

	public static int[] sort(int[] array, int from, int to, IntComparator comparator) {
		if (from == 0 &amp;&amp; to == array.length)
			new IntArray(array).inPlaceSort(comparator);
		else
			new IntArray(array).subList(from, to).inPlaceSort(comparator);
		return array;
	}

	private static void ensureCapacityInt(int size) {
		if (tempInt.length &gt;= size)
			return;
		size = Math.max(size, tempInt.length &lt;&lt; 1);
		tempInt = new int[size];
	}

	public static int[] order(final int[] array) {
		return sort(createOrder(array.length), new IntComparator() {
			public int compare(int first, int second) {
				if (array[first] &lt; array[second])
					return -1;
				if (array[first] &gt; array[second])
					return 1;
				return 0;
			}
		});
	}

	public static void orderBy(int[] base, int[]... arrays) {
		int[] order = ArrayUtils.order(base);
		order(order, base);
		for (int[] array : arrays)
			order(order, array);
	}

	public static void order(int[] order, int[] array) {
		ensureCapacityInt(order.length);
		for (int i = 0; i &lt; order.length; i++)
			tempInt[i] = array[order[i]];
		System.arraycopy(tempInt, 0, array, 0, array.length);
	}

}

class MiscUtils {

	public static void decreaseByOne(int[]...arrays) {
		for (int[] array : arrays) {
			for (int i = 0; i &lt; array.length; i++)
				array[i]--;
		}
	}

}

interface IndependentSetSystem {
	public boolean join(int first, int second);

	public int get(int index);

	public static interface Listener {
		public void joined(int joinedRoot, int root);
	}
}

class RecursiveIndependentSetSystem implements IndependentSetSystem {
	private final int[] color;
	private final int[] rank;
	private int setCount;
	private Listener listener;

	public RecursiveIndependentSetSystem(int size) {
		color = new int[size];
		rank = new int[size];
		for (int i = 0; i &lt; size; i++)
			color[i] = i;
		setCount = size;
	}

	public RecursiveIndependentSetSystem(RecursiveIndependentSetSystem other) {
		color = other.color.clone();
		rank = other.rank.clone();
		setCount = other.setCount;
	}

	public boolean join(int first, int second) {
		first = get(first);
		second = get(second);
		if (first == second)
			return false;
		if (rank[first] &lt; rank[second]) {
			int temp = first;
			first = second;
			second = temp;
		} else if (rank[first] == rank[second])
			rank[first]++;
		setCount--;
		color[second] = first;
		if (listener != null)
			listener.joined(second, first);
		return true;
	}

	public int get(int index) {
		if (color[index] == index)
			return index;
		return color[index] = get(color[index]);
	}

}

class Graph {
	public static final int REMOVED_BIT = 0;

	protected int vertexCount;
	protected int edgeCount;

	private int[] firstOutbound;
	private int[] firstInbound;

	private Edge[] edges;
	private int[] nextInbound;
	private int[] nextOutbound;
	private int[] from;
	private int[] to;
	private long[] weight;
	private long[] capacity;
	private int[] reverseEdge;
	private int[] flags;

	public Graph(int vertexCount) {
		this(vertexCount, vertexCount);
	}

	public Graph(int vertexCount, int edgeCapacity) {
		this.vertexCount = vertexCount;
		firstOutbound = new int[vertexCount];
		Arrays.fill(firstOutbound, -1);

		from = new int[edgeCapacity];
		to = new int[edgeCapacity];
		nextOutbound = new int[edgeCapacity];
		flags = new int[edgeCapacity];
	}

	public int addEdge(int fromID, int toID, long weight, long capacity, int reverseEdge) {
		ensureEdgeCapacity(edgeCount + 1);
		if (firstOutbound[fromID] != -1)
			nextOutbound[edgeCount] = firstOutbound[fromID];
		else
			nextOutbound[edgeCount] = -1;
		firstOutbound[fromID] = edgeCount;
		if (firstInbound != null) {
			if (firstInbound[toID] != -1)
				nextInbound[edgeCount] = firstInbound[toID];
			else
				nextInbound[edgeCount] = -1;
			firstInbound[toID] = edgeCount;
		}
		this.from[edgeCount] = fromID;
		this.to[edgeCount] = toID;
		if (capacity != 0) {
			if (this.capacity == null)
				this.capacity = new long[from.length];
			this.capacity[edgeCount] = capacity;
		}
		if (weight != 0) {
			if (this.weight == null)
				this.weight = new long[from.length];
			this.weight[edgeCount] = weight;
		}
		if (reverseEdge != -1) {
			if (this.reverseEdge == null) {
				this.reverseEdge = new int[from.length];
				Arrays.fill(this.reverseEdge, 0, edgeCount, -1);
			}
			this.reverseEdge[edgeCount] = reverseEdge;
		}
		if (edges != null)
			edges[edgeCount] = createEdge(edgeCount);
		return edgeCount++;
	}

	protected final GraphEdge createEdge(int id) {
		return new GraphEdge(id);
	}

	public final int addFlowWeightedEdge(int from, int to, long weight, long capacity) {
		if (capacity == 0) {
			return addEdge(from, to, weight, 0, -1);
		} else {
			int lastEdgeCount = edgeCount;
			addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());
			return addEdge(from, to, weight, capacity, lastEdgeCount);
		}
	}

	protected int entriesPerEdge() {
		return 1;
	}

	public final int addWeightedEdge(int from, int to, long weight) {
		return addFlowWeightedEdge(from, to, weight, 0);
	}

	public final int addSimpleEdge(int from, int to) {
		return addWeightedEdge(from, to, 0);
	}

	protected final int edgeCapacity() {
		return from.length;
	}

	public final int firstOutbound(int vertex) {
		int id = firstOutbound[vertex];
		while (id != -1 &amp;&amp; isRemoved(id))
			id = nextOutbound[id];
		return id;
	}

	public final int nextOutbound(int id) {
		id = nextOutbound[id];
		while (id != -1 &amp;&amp; isRemoved(id))
			id = nextOutbound[id];
		return id;
	}

	public final int destination(int id) {
		return to[id];
	}

	public final boolean flag(int id, int bit) {
		return (flags[id] &gt;&gt; bit &amp; 1) != 0;
	}

	public final boolean isRemoved(int id) {
		return flag(id, REMOVED_BIT);
	}

	protected void ensureEdgeCapacity(int size) {
		if (from.length &lt; size) {
			int newSize = Math.max(size, 2 * from.length);
			if (edges != null)
				edges = resize(edges, newSize);
			from = resize(from, newSize);
			to = resize(to, newSize);
			nextOutbound = resize(nextOutbound, newSize);
			if (nextInbound != null)
				nextInbound = resize(nextInbound, newSize);
			if (weight != null)
				weight = resize(weight, newSize);
			if (capacity != null)
				capacity = resize(capacity, newSize);
			if (reverseEdge != null)
				reverseEdge = resize(reverseEdge, newSize);
			flags = resize(flags, newSize);
		}
	}

	protected final int[] resize(int[] array, int size) {
		int[] newArray = new int[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	private long[] resize(long[] array, int size) {
		long[] newArray = new long[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	private Edge[] resize(Edge[] array, int size) {
		Edge[] newArray = new Edge[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	protected class GraphEdge implements Edge {
		protected int id;

		protected GraphEdge(int id) {
			this.id = id;
		}

	}

}

class BidirectionalGraph extends Graph {
	public int[] transposedEdge;

	public BidirectionalGraph(int vertexCount) {
		this(vertexCount, vertexCount);
	}

	public BidirectionalGraph(int vertexCount, int edgeCapacity) {
		super(vertexCount, 2 * edgeCapacity);
		transposedEdge = new int[2 * edgeCapacity];
	}

	public static BidirectionalGraph createGraph(int vertexCount, int[] from, int[] to) {
		BidirectionalGraph graph = new BidirectionalGraph(vertexCount, from.length);
		for (int i = 0; i &lt; from.length; i++)
			graph.addSimpleEdge(from[i], to[i]);
		return graph;
	}

	public int addEdge(int fromID, int toID, long weight, long capacity, int reverseEdge) {
		int lastEdgeCount = edgeCount;
		super.addEdge(fromID, toID, weight, capacity, reverseEdge);
		super.addEdge(toID, fromID, weight, capacity, reverseEdge == -1 ? -1 : reverseEdge + 1);
		this.transposedEdge[lastEdgeCount] = lastEdgeCount + 1;
		this.transposedEdge[lastEdgeCount + 1] = lastEdgeCount;
		return lastEdgeCount;
	}

	protected int entriesPerEdge() {
		return 2;
	}

	protected void ensureEdgeCapacity(int size) {
		if (size &gt; edgeCapacity()) {
			super.ensureEdgeCapacity(size);
			transposedEdge = resize(transposedEdge, edgeCapacity());
		}
	}
}

class Rational implements Comparable&lt;Rational&gt; {

	public final long numerator;
	public final long denominator;

	public Rational(long numerator, long denominator) {
		if (denominator == 0)
			throw new IllegalArgumentException();
		long gcd = IntegerUtils.gcd(Math.abs(numerator), Math.abs(denominator));
		if (denominator &gt; 0) {
			this.numerator = numerator / gcd;
			this.denominator = denominator / gcd;
		} else {
			this.numerator = -numerator / gcd;
			this.denominator = -denominator / gcd;
		}
	}

	public String toString() {
		return numerator + "/" + denominator;
	}

	public int compareTo(Rational other) {
		return IntegerUtils.longCompare(numerator * other.denominator, denominator * other.numerator);
	}

	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;

		Rational rational = (Rational) o;

		if (denominator != rational.denominator) return false;
		if (numerator != rational.numerator) return false;

		return true;
	}

	public int hashCode() {
		int result = (int) (numerator ^ (numerator &gt;&gt;&gt; 32));
		result = 31 * result + (int) (denominator ^ (denominator &gt;&gt;&gt; 32));
		return result;
	}

}

class Indexer&lt;K&gt; extends EHashMap&lt;K, Integer&gt; {
	private int index = 0;

	public Integer get(Object key) {
		if (!containsKey(key))
			put((K) key, index++);
		return super.get(key);
	}
}

class EHashMap&lt;E, V&gt; extends AbstractMap&lt;E, V&gt; {
	private static final int[] shifts = new int[10];

	private int size;
	private HashEntry&lt;E, V&gt;[] data;
	private int capacity;
	private Set&lt;Entry&lt;E, V&gt;&gt; entrySet;

	static {
		Random random = new Random(System.currentTimeMillis());
		for (int i = 0; i &lt; 10; i++)
			shifts[i] = 1 + 3 * i + random.nextInt(3);
	}

	public EHashMap() {
		this(4);
	}

	private void setCapacity(int size) {
		capacity = Integer.highestOneBit(4 * size);
        //noinspection unchecked
        data = new HashEntry[capacity];
	}

	public EHashMap(int maxSize) {
		setCapacity(maxSize);
		entrySet = new AbstractSet&lt;Entry&lt;E, V&gt;&gt;() {
			@Override
			public Iterator&lt;Entry&lt;E, V&gt;&gt; iterator() {
				return new Iterator&lt;Entry&lt;E, V&gt;&gt;() {
					private HashEntry&lt;E, V&gt; last = null;
                    private HashEntry&lt;E, V&gt; current = null;
                    private HashEntry&lt;E, V&gt; base = null;
                    private int lastIndex = -1;
					private int index = -1;

					public boolean hasNext() {
                        if (current == null) {
                            for (index++; index &lt; capacity; index++) {
                                if (data[index] != null) {
                                    base = current = data[index];
                                    break;
                                }
                            }
                        }
                        return current != null;
					}

					public Entry&lt;E, V&gt; next() {
						if (!hasNext())
							throw new NoSuchElementException();
                        last = current;
                        lastIndex = index;
                        current = current.next;
                        if (base.next != last)
                            base = base.next;
						return last;
					}

					public void remove() {
						if (last == null)
							throw new IllegalStateException();
                        size--;
                        if (base == last)
                            data[lastIndex] = last.next;
                        else
                            base.next = last.next;
					}
				};
			}

			@Override
			public int size() {
				return size;
			}
		};
	}

	public EHashMap(Map&lt;E, V&gt; map) {
		this(map.size());
		putAll(map);
	}

	public Set&lt;Entry&lt;E, V&gt;&gt; entrySet() {
		return entrySet;
	}

	public void clear() {
		Arrays.fill(data, null);
		size = 0;
	}

	private int index(Object o) {
		return getHash(o.hashCode()) &amp; (capacity - 1);
	}

	private int getHash(int h) {
		int result = h;
		for (int i : shifts)
			result ^= h &gt;&gt;&gt; i;
		return result;
	}

	public V remove(Object o) {
		if (o == null)
			return null;
		int index = index(o);
        HashEntry&lt;E, V&gt; current = data[index];
        HashEntry&lt;E, V&gt; last = null;
        while (current != null) {
            if (current.key.equals(o)) {
                if (last == null)
                    data[index] = current.next;
                else
                    last.next = current.next;
                size--;
                return current.value;
            }
            last = current;
            current = current.next;
        }
        return null;
	}

	public V put(E e, V value) {
		if (e == null)
			return null;
		int index = index(e);
        HashEntry&lt;E, V&gt; current = data[index];
        if (current != null) {
            while (true) {
                if (current.key.equals(e)) {
                    V oldValue = current.value;
                    current.value = value;
                    return oldValue;
                }
                if (current.next == null)
                    break;
                current = current.next;
            }
        }
        if (current == null)
            data[index] = new HashEntry&lt;E, V&gt;(e, value);
        else
            current.next = new HashEntry&lt;E, V&gt;(e, value);
        size++;
        if (2 * size &gt; capacity) {
            HashEntry&lt;E, V&gt;[] oldData = data;
            setCapacity(size);
            for (HashEntry&lt;E, V&gt; entry : oldData) {
                while (entry != null) {
                    HashEntry&lt;E, V&gt; next = entry.next;
                    index = index(entry.key);
                    entry.next = data[index];
                    data[index] = entry;
                    entry = next;
                }
            }
        }
		return null;
	}

	public V get(Object o) {
		if (o == null)
			return null;
		int index = index(o);
        HashEntry&lt;E, V&gt; current = data[index];
		while (current != null) {
			if (current.key.equals(o))
                return current.value;
            current = current.next;
        }
		return null;
	}

	public boolean containsKey(Object o) {
        if (o == null)
            return false;
        int index = index(o);
        HashEntry&lt;E, V&gt; current = data[index];
        while (current != null) {
            if (current.key.equals(o))
                return true;
            current = current.next;
        }
        return false;
	}

	public int size() {
		return size;
	}

	private static class HashEntry&lt;E, V&gt; implements Entry&lt;E, V&gt; {
		private final E key;
		private V value;
        private HashEntry&lt;E, V&gt; next;

        private HashEntry(E key, V value) {
            this.key = key;
            this.value = value;
        }


        public E getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        public V setValue(V value) {
            V oldValue = this.value;
            this.value = value;
            return oldValue;
        }
    }
}

abstract class IntList extends IntCollection implements Comparable&lt;IntList&gt; {
	private static final int INSERTION_THRESHOLD = 16;

	public abstract int get(int index);
	public abstract void set(int index, int value);

	public IntIterator iterator() {
		return new IntIterator() {
			private int size = size();
			private int index = 0;

			public int value() throws NoSuchElementException {
				if (!isValid())
					throw new NoSuchElementException();
				return get(index);
			}

			public void advance() throws NoSuchElementException {
				if (!isValid())
					throw new NoSuchElementException();
				index++;
			}

			public boolean isValid() {
				return index &lt; size;
			}
		};
	}

	public IntList subList(final int from, final int to) {
		return new SubList(from, to);
	}

	private void swap(int first, int second) {
		if (first == second)
			return;
		int temp = get(first);
		set(first, get(second));
		set(second, temp);
	}

	public IntSortedList inPlaceSort(IntComparator comparator) {
		quickSort(0, size() - 1, (Integer.bitCount(Integer.highestOneBit(size()) - 1) * 5) &gt;&gt; 1, comparator);
		return new IntSortedArray(this, comparator);
	}

	private void quickSort(int from, int to, int remaining, IntComparator comparator) {
		if (to - from &lt; INSERTION_THRESHOLD) {
			insertionSort(from, to, comparator);
			return;
		}
		if (remaining == 0) {
			heapSort(from, to, comparator);
			return;
		}
		remaining--;
		int pivotIndex = (from + to) &gt;&gt; 1;
		int pivot = get(pivotIndex);
		swap(pivotIndex, to);
		int storeIndex = from;
		int equalIndex = to;
		for (int i = from; i &lt; equalIndex; i++) {
			int value = comparator.compare(get(i), pivot);
			if (value &lt; 0)
				swap(storeIndex++, i);
			else if (value == 0)
				swap(--equalIndex, i--);
		}
		quickSort(from, storeIndex - 1, remaining, comparator);
		for (int i = equalIndex; i &lt;= to; i++)
			swap(storeIndex++, i);
		quickSort(storeIndex, to, remaining, comparator);
	}

	private void heapSort(int from, int to, IntComparator comparator) {
		for (int i = (to + from - 1) &gt;&gt; 1; i &gt;= from; i--)
			siftDown(i, to, comparator, from);
		for (int i = to; i &gt; from; i--) {
			swap(from, i);
			siftDown(from, i - 1, comparator, from);
		}
	}

	private void siftDown(int start, int end, IntComparator comparator, int delta) {
		int value = get(start);
		while (true) {
			int child = ((start - delta) &lt;&lt; 1) + 1 + delta;
			if (child &gt; end)
				return;
			int childValue = get(child);
			if (child + 1 &lt;= end) {
				int otherValue = get(child + 1);
				if (comparator.compare(otherValue, childValue) &gt; 0) {
					child++;
					childValue = otherValue;
				}
			}
			if (comparator.compare(value, childValue) &gt;= 0)
				return;
			swap(start, child);
			start = child;
		}
	}

	private void insertionSort(int from, int to, IntComparator comparator) {
		for (int i = from + 1; i &lt;= to; i++) {
			int value = get(i);
			for (int j = i - 1; j &gt;= from; j--) {
				if (comparator.compare(get(j), value) &lt;= 0)
					break;
				swap(j, j + 1);
			}
		}
	}

	public int hashCode() {
		int hashCode = 1;
		for (IntIterator i = iterator(); i.isValid(); i.advance())
			hashCode = 31 * hashCode + i.value();
		return hashCode;
	}

	public boolean equals(Object obj) {
		if (!(obj instanceof IntList))
			return false;
		IntList list = (IntList)obj;
		if (list.size() != size())
			return false;
		IntIterator i = iterator();
		IntIterator j = list.iterator();
		while (i.isValid()) {
			if (i.value() != j.value())
				return false;
			i.advance();
			j.advance();
		}
		return true;
	}

	public int compareTo(IntList o) {
		IntIterator i = iterator();
		IntIterator j = o.iterator();
		while (true) {
			if (i.isValid()) {
				if (j.isValid()) {
					if (i.value() != j.value()) {
						if (i.value() &lt; j.value())
							return -1;
						else
							return 1;
					}
				} else
					return 1;
			} else {
				if (j.isValid())
					return -1;
				else
					return 0;
			}
			i.advance();
			j.advance();
		}
	}

	private class SubList extends IntList {
        private final int to;
        private final int from;
        private int size;

        public SubList(int from, int to) {
            this.to = to;
            this.from = from;
            size = to - from;
        }

        public int get(int index) {
            if (index &lt; 0 || index &gt;= size)
                throw new IndexOutOfBoundsException();
            return IntList.this.get(index + from);
        }

        public void set(int index, int value) {
            if (index &lt; 0 || index &gt;= size)
                throw new IndexOutOfBoundsException();
            IntList.this.set(index + from, value);
        }

        public int size() {
            return size;
        }

	}
}

abstract class IntCollection {
	public abstract IntIterator iterator();
	public abstract int size();

}

interface IntIterator {
	public int value() throws NoSuchElementException;
	/*
	 * @throws NoSuchElementException only if iterator already invalid
	 */
	public void advance() throws NoSuchElementException;
	public boolean isValid();
}

interface IntComparator {
    public static final IntComparator DEFAULT = new IntComparator() {
        public int compare(int first, int second) {
            if (first &lt; second)
                return -1;
            if (first &gt; second)
                return 1;
            return 0;
        }
    };

	public int compare(int first, int second);
}

abstract class IntSortedList extends IntList {
	protected final IntComparator comparator;

	protected IntSortedList(IntComparator comparator) {
		this.comparator = comparator;
	}

	public void set(int index, int value) {
		throw new UnsupportedOperationException();
	}

	public IntSortedList inPlaceSort(IntComparator comparator) {
		if (comparator == this.comparator)
			return this;
		throw new UnsupportedOperationException();
	}

	protected void ensureSorted() {
		int size = size();
		if (size == 0)
			return;
		int last = get(0);
		for (int i = 1; i &lt; size; i++) {
			int current = get(i);
			if (comparator.compare(last, current) &gt; 0)
				throw new IllegalArgumentException();
			last = current;
		}
	}

	public IntSortedList subList(final int from, final int to) {
		return new IntSortedList(comparator) {
			private int size = to - from;

			@Override
			public int get(int index) {
				if (index &lt; 0 || index &gt;= size)
					throw new IndexOutOfBoundsException();
				return IntSortedList.this.get(index + from);
			}

			@Override
			public int size() {
				return size;
			}
		};
	}
}

class IntArray extends IntList {
	private final int[] array;

	public IntArray(int[] array) {
		this.array = array;
	}

	public IntArray(IntCollection collection) {
		array = new int[collection.size()];
		int i = 0;
		for (IntIterator iterator = collection.iterator(); iterator.isValid(); iterator.advance())
			array[i++] = iterator.value();
	}

	public int get(int index) {
		return array[index];
	}

	public void set(int index, int value) {
		array[index] = value;
	}

	public int size() {
		return array.length;
	}

}

interface Edge {
}

class IntSortedArray extends IntSortedList {
	private final int[] array;

	public IntSortedArray(int[] array) {
		this(array, IntComparator.DEFAULT);
	}

	public IntSortedArray(IntCollection collection) {
		this(collection, IntComparator.DEFAULT);
	}

	public IntSortedArray(int[] array, IntComparator comparator) {
		super(comparator);
		this.array = array;
		ensureSorted();
	}

	public IntSortedArray(IntCollection collection, IntComparator comparator) {
		super(comparator);
		array = new int[collection.size()];
		int i = 0;
		for (IntIterator iterator = collection.iterator(); iterator.isValid(); iterator.advance())
			array[i++] = iterator.value();
		ensureSorted();
	}

	public int get(int index) {
		return array[index];
	}

	public int size() {
		return array.length;
	}
}


----------
====================
----------
ALGORITHMS.219
expert
----------
PROBLEM STATEMENT:
You have a rooted tree with [expression]. 

You are given [expression]. 

You have to select a subset of the paths such that the sum of path costs is maximum and the [expression] paths from the subset. Print the sum as the output.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define rep(i, from, to) for (int i = from; i &lt; (to); ++i)
#define trav(a, x) for (auto&amp; a : x)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef vector&lt;int&gt; vi;
void PR(vi &amp;v) { trav(x, v) cout &lt;&lt; x &lt;&lt; ' '; cout &lt;&lt; endl; }

typedef double T;
typedef vector&lt;T&gt; vd;
typedef vector&lt;vd&gt; vvd;

const T eps = 1e-8, inf = 1/.0;
#define MP make_pair
#define ltj(X) if(s == -1 || MP(X[j],N[j]) &lt; MP(X[s],N[s])) s=j

struct LPSolver {
	int m, n;
	vi N, B;
	vvd D;

	LPSolver(const vvd&amp; A, const vd&amp; b, const vd&amp; c) :
		m(sz(b)), n(sz(c)), N(n+1), B(m), D(m+2, vd(n+2)) {
			rep(i,0,m) rep(j,0,n) D[i][j] = A[i][j];
			rep(i,0,m) { B[i] = n+i; D[i][n] = -1; D[i][n+1] = b[i];}
			rep(j,0,n) { N[j] = j; D[m][j] = -c[j]; }
			N[n] = -1; D[m+1][n] = 1;
		}

	void pivot(int r, int s) {
		T inv = 1.0 / D[r][s];
		rep(i,0,m+2) if (i != r)
			rep(j,0,n+2) if (j != s)
				D[i][j] -= D[r][j] * D[i][s] * inv;
		rep(j,0,n+2) if (j != s) D[r][j] *= inv;
		rep(i,0,m+2) if (i != r) D[i][s] *= -inv;
		D[r][s] = inv;
		swap(B[r], N[s]);
	}

	bool simplex(int phase) {
		int x = m + phase - 1;
		for (;;) {
			int s = -1;
			rep(j,0,n+1) if (N[j] != -phase) ltj(D[x]);
			if (D[x][s] &gt;= -eps) return true;
			int r = -1;
			rep(i,0,m) {
				if (D[i][s] &lt;= eps) continue;
				if (r == -1 || MP(D[i][n+1] / D[i][s], B[i])
				             &lt; MP(D[r][n+1] / D[r][s], B[r])) r = i;
			}
			if (r == -1) return false;
			pivot(r, s);
		}
	}

	T solve(vd &amp;x) {
		int r = 0;
		rep(i,1,m) if (D[i][n+1] &lt; D[r][n+1]) r = i;
		if (D[r][n+1] &lt;= -eps) {
			pivot(r, n);
			if (!simplex(2) || D[m+1][n+1] &lt; -eps) return -inf;
			rep(i,0,m) if (B[i] == -1) {
				int s = 0;
				rep(j,1,n+1) ltj(D[i]);
				pivot(i, s);
			}
		}
		bool ok = simplex(1); x = vd(n);
		rep(i,0,m) if (B[i] &lt; n) x[B[i]] = D[i][n+1];
		return ok ? D[m][n+1] : inf;
	}
};

vi pars;
vi dup;
void rec(vector&lt;vector&lt;pii&gt;&gt;&amp; ed, int at, int par, int dval) {
	pars[at] = par;
	dup[at] = dval;
	trav(x, ed[at]) {
		if (x.first == par) continue;
		rec(ed, x.first, at, x.second);
	}
}

void solve() {
	int N, M;
	cin &gt;&gt; N &gt;&gt; M;
	vector&lt;vector&lt;pii&gt;&gt; ed(N);
	rep(i,0,N-1) {
		int a, b, d;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;
		--a, --b;
		ed[a].emplace_back(b, d);
		ed[b].emplace_back(a, d);
	}
	pars.resize(N);
	dup.resize(N);
	rec(ed, 0, -1, -1);
	vvd A(M+N-1, vd(M));
	vd C(M), X(M), B(M+N-1);
	rep(i,0,M) A[i][i] = 1, B[i] = 1;
	rep(i,0,N-1) B[M+i] = dup[i+1];
	rep(i,0,M) {
		int u, v, c;
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;
		--u, --v;
		while (u != v) {
			A[M + v - 1][i] = 1;
			v = pars[v];
		}
		C[i] = c;
	}
	double res = LPSolver(A, B, C).solve(X);
	cout &lt;&lt; (ll)round(res) &lt;&lt; endl;
}

int main() {
	cin.sync_with_stdio(false);
	cin.exceptions(cin.failbit);
	int N;
	cin &gt;&gt; N;
	rep(i,0,N) {
		solve();
	}
}

----------
====================
----------
ALGORITHMS.220
expert
----------
PROBLEM STATEMENT:
HackerRank is starting a bus service in MountainView, California. The bus starts at time T = 0 at station1 and goes through station2, station3, station4 in that order and reaches the headquarters located at stationn. At every station, the bus waits for various commuters to arrive before it departs to the next station. Ignoring the acceleration, the bus moves at 1 meter / second. i.e., if stationi and stationj are 1000 meters apart, the bus takes 1000 seconds to travel from stationi to stationj. 

The bus is equipped with K units of Nitro (N2O). If going from stationi to stationj takes x seconds, then using t units of nitro can decrease the time taken to max(x-t, 0) seconds where max(a,b) denotes the greater of the two values between a &amp; b. The Nitro can be used all at once or in multiples of 1 unit. 

If the bus driver travels optimally, what is the minimum sum of travelling time for all commuters? The travelling time equals to the time he/she arrived at the destination minus the time he/she arrived the start station. 

Please remember that the driver must take all passengers to their destination.  
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int n, m, k;
int dist[100100];
int late[100100];
int bin[100100];
int bout[100100];
int arrival[100100];
vector&lt;long long&gt; peop[100100];
long long ans;


void gen() {
    cout &lt;&lt; 100 &lt;&lt; " " &lt;&lt; 100 &lt;&lt; " " &lt;&lt; 1000 &lt;&lt; endl;
    for(int i = 0; i &lt; 99; ++i) {
        cout &lt;&lt; rand() % 1000 &lt;&lt; " ";
    }
    for(int i = 0; i &lt; 100; ++i) {
        int y = rand() % 100 + 1, x = rand() % y;
        cout &lt;&lt; rand() % (x * 1000 + 100) &lt;&lt; " " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl;
    }
    exit(0);
}


struct st {
    int i, j;
    long long saved;
    int spend;
    st(int i, int j, long long saved, int spend) : i(i), j(j), saved(saved), spend(spend) {}
    bool operator &lt; (st a) const {
        if (saved != a.saved) {
            return saved &lt; a.saved;
        }
        return spend &lt; a.spend;
    }
};

priority_queue&lt;st&gt; q;

int add(int i) {
    if (i == n) return n;
    int spend = 1000000000;
    int j = i + 1;
    if (dist[i]) {
        spend = min(spend, dist[i]);
        long long saved = 0;
        for(j = i + 1; j &lt;= n; ++j) {
            --arrival[j];
            saved += bout[j];
            if (late[j] &gt; arrival[j]) {
                break;
            }
            spend = min(spend, arrival[j] - late[j] + 1);
        }
        if (j &gt; n) j = n;
        //cout &lt;&lt; i &lt;&lt; " = " &lt;&lt; j &lt;&lt; endl;
        st w(i, j, saved, spend);
        q.push(w);
        for(int q = i + 1; q &lt;= j; ++q) {
            ++arrival[q];
        }
    }
    return j;
}

int main() {
    //gen();
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    --n;
    for(int i = 0; i &lt; n; ++i) {
        cin &gt;&gt; dist[i];
    }
    for(int i = 0; i &lt; m; ++i) {
        int t, s, e;
        cin &gt;&gt; t &gt;&gt; s &gt;&gt; e;
        --s;
        --e;
        late[s] = max(late[s], t);
        ++bout[e];
        peop[s].push_back(t);
    }
    late[n] = -1000000000;

    long long nowt = 0, carry = 0;
    for(int i = 0; i &lt; n; ++i) {
        arrival[i] = nowt;
        for(int j = 0; j &lt; peop[i].size(); ++j) {
            if (peop[i][j] &lt; nowt) {
                ans += nowt - peop[i][j];
            } else {
                ans += carry * (peop[i][j] - nowt);
            }
            ++carry;
            nowt = max(peop[i][j], nowt);
        }
        ans += carry * dist[i];
        nowt += dist[i];
        carry -= bout[i + 1];
    }
    arrival[n] = nowt;

    int cur = 0;
    while(cur &lt; n) {
        cur = add(cur);
    }

    while(k &amp;&amp; !q.empty()) {

        st w = q.top();
        q.pop();
        if (w.spend &gt;= k) 
        {
            ans -= w.saved * k;
            break;
        }ans -= w.saved * w.spend;
        k -= w.spend;
        dist[w.i] -= w.spend;
        for(int i = w.i + 1; i &lt;= w.j; ++i) {
            arrival[i] -= w.spend;
        }

        int x = w.i;
        while(x &lt; w.j) 
        {
            x = add(x);
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
----------
====================
----------
ALGORITHMS.221
expert
----------
PROBLEM STATEMENT:
The travelling salesman has a map containing m*n squares. He starts from the top left corner and visits every cell exactly once and returns to his initial position (top left). The time taken for the salesman to move from a square to its neighbor might not be the same. Two squares are considered adjacent if they share a common edge and the time taken to reach square b from square a and vice-versa are the same. Can you figure out the shortest time in which the salesman can visit every cell and get back to his initial position? 
----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.List;

public class Solution {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";
	
	static void solve()
	{
		int m = ni(), n = ni();
		int[][] g = new int[2*m+1][2*n+1];
		for(int i = 0;i &lt; 2*m+1;i++){
			Arrays.fill(g[i], -1);
		}
		for(int i = 0;i &lt; m;i++){
			for(int j = 0;j &lt; n-1;j++){
				g[2*i][2*j+1] = ni();
			}
		}
		for(int j = 0;j &lt; m-1;j++){
			for(int i = 0;i &lt; n;i++){
				g[2*j+1][2*i] = ni();
			}
		}
		if(m == 1 || n == 1 || (m%2==1 &amp;&amp; n%2==1)){
			out.println(0);
			return;
		}
		
		HMG&lt;State&gt; dp = new HMG&lt;State&gt;();
		State ini = new State((1L&lt;&lt;4*n)-1, 0, 0);
		add(ini, dp);
		for(int i = 0;i &lt; m;i++){
			for(int j = 0;j &lt; n;j++){
				HMG&lt;State&gt; ndp = new HMG&lt;State&gt;();
				for(HMG.Entry&lt;State&gt; e : dp.table){
					for(;e != null;e = e.next){
						State s = e.value;
							int fig0 = s.fig&amp;7;
							int figlast = s.fig&gt;&gt;&gt;3*(n-1)&amp;7;
							boolean fromup = i &gt; 0 &amp;&amp; (fig0 == 1 || fig0 == 3 || fig0 == 5);
							boolean fromleft = j &gt; 0 &amp;&amp; (figlast == 0 || figlast == 3 || figlast == 4);
							if(fromup){
								if(fromleft){
									if((i == m-1 &amp;&amp; j == n-1) || (s.clus&amp;15) != (s.clus&gt;&gt;&gt;4*(n-1)&amp;15)) {
										// 2
										long xclus = s.clus&gt;&gt;&gt;4|(s.clus&amp;15)&lt;&lt;4*(n-1);
										int xfig = s.fig&gt;&gt;&gt;3|2&lt;&lt;3*(n-1);
										int oclus = (int)(s.clus&gt;&gt;&gt;4*(n-1)&amp;15);
										for(int l = 0;l &lt; n;l++){
											if((xclus&gt;&gt;&gt;4*l&amp;15) == oclus){
												xclus &amp;= ~(15L&lt;&lt;4*l);
												xclus |= (s.clus&amp;15)&lt;&lt;4*l;
											}
										}
										int val = s.val + g[i*2-1][j*2] + g[i*2][j*2-1];
										add(new State(relocate(xclus, n), xfig, val), ndp);
									}
								}else{
									if(j &lt; n-1){
										// 0
										long xclus = s.clus&gt;&gt;&gt;4|(s.clus&amp;15)&lt;&lt;4*(n-1);
										int xfig = s.fig&gt;&gt;&gt;3|0&lt;&lt;3*(n-1);
										int val = s.val + g[i*2-1][j*2];
										add(new State(relocate(xclus, n), xfig, val), ndp);
									}
									if(i &lt; m-1){
										// 1
										long xclus = s.clus&gt;&gt;&gt;4|(s.clus&amp;15)&lt;&lt;4*(n-1);
										int xfig = s.fig&gt;&gt;&gt;3|1&lt;&lt;3*(n-1);
										int val = s.val + g[i*2-1][j*2];
										add(new State(relocate(xclus, n), xfig, val), ndp);
									}
								}
							}else{
								if(hasHidden(s.clus, n))continue;
								if(fromleft){
									if(j &lt; n-1){
										// 4
										long xclus = s.clus&gt;&gt;&gt;4|(s.clus&gt;&gt;&gt;4*(n-1)&amp;15)&lt;&lt;4*(n-1);
										int xfig = s.fig&gt;&gt;&gt;3|4&lt;&lt;3*(n-1);
										int val = s.val + g[i*2][j*2-1];
										add(new State(relocate(xclus, n), xfig, val), ndp);
									}
									if(i &lt; m-1){
										// 5
										long xclus = s.clus&gt;&gt;&gt;4|(s.clus&gt;&gt;&gt;4*(n-1)&amp;15)&lt;&lt;4*(n-1);
										int xfig = s.fig&gt;&gt;&gt;3|5&lt;&lt;3*(n-1);
										int val = s.val + g[i*2][j*2-1];
										add(new State(relocate(xclus, n), xfig, val), ndp);
									}
								}else{
									if(i &lt; m-1 &amp;&amp; j &lt; n-1){
										// 3
										long xclus = s.clus&gt;&gt;&gt;4|11L&lt;&lt;4*(n-1);
										int xfig = s.fig&gt;&gt;&gt;3|3&lt;&lt;3*(n-1);
										int val = s.val;
										add(new State(relocate(xclus, n), xfig, val), ndp);
									}
								}
							}
						}
				}
//				tr(i, j, ndp.size());
//				tr(ndp.values());
				dp = ndp;
			}
		}
		int min = Integer.MAX_VALUE;
		for(HMG.Entry&lt;State&gt; e : dp.table){
			for(;e != null;e = e.next){
				State s = e.value;
				if(s.clus == 0L){
					min = Math.min(min, s.val);
				}
			}
		}
		out.println(min);
	}
	
	public static class State
	{
		final long clus;
		final int fig;
		// UR:0
		// UD:1
		// UL:2
		// RD:3
		// RL:4
		// DL:5
		int val;
		
		public State(long clus, int fig, int val) {
			this.clus = clus;
			this.val = val;
			this.fig = fig;
		}
		
		public long h()
		{
			long h = 1;
			h = h * 1000000009 + clus;
			h = h * 1000000009 + fig;
			return h;
		}

		@Override
		public String toString() {
			StringBuilder builder = new StringBuilder();
			builder.append("State [clus=");
			builder.append(Long.toBinaryString(clus));
			builder.append(", fig=");
			builder.append(Integer.toBinaryString(fig));
			builder.append(", val=");
			builder.append(val);
			builder.append("]");
			return builder.toString();
		}
	}
	
	public static boolean hasHidden(long a, int n)
	{
		if((a&amp;15) != 15){
			for(int i = 1;i &lt; n;i++){
				if((a&gt;&gt;&gt;4*i&amp;15) == 0)return false;
			}
			return true;
		}else{
			return false;
		}
	}
	
	public static boolean hasHidden(int[] a)
	{
		if(a[0] != -1){
			for(int i = 1;i &lt; a.length;i++){
				if(a[i] == 0)return false;
			}
			return true;
		}else{
			return false;
		}
	}
	
	public static int has(int[] a)
	{
		for(int v : a){
			if(v != -1)return 1;
		}
		return 0;
	}
	
	public static int num(int[] a)
	{
		int num = -1;
		for(int v : a){
			if(v &gt; num)num = v;
		}
		return num+1;
	}
	
	public static long relocate(long a, int n)
	{
		long map = -1L;
		int p = 0;
		long b = 0;
		for(int i = 0;i &lt; n;i++){
			int cl = (int)(a&gt;&gt;&gt;4*i&amp;15);
			if(cl == 15){
				b |= 15L&lt;&lt;4*i;
			}else{
				if((map&gt;&gt;&gt;4*cl&amp;15) == 15){
					map ^= (15L^p++)&lt;&lt;4*cl;
				}
				b |= (map&gt;&gt;&gt;4*cl&amp;15)&lt;&lt;4*i;
			}
		}
		return b;
	}
	
	public static class HMG&lt;T&gt; {
		public int size;
		
		private List&lt;Entry&lt;T&gt;&gt; table;
		private int threshold;
		
	    static final int DEFAULT_INITIAL_CAPACITY = 4;
	    
	    public HMG() {
	    	this(DEFAULT_INITIAL_CAPACITY);
	    }
	    
	    public HMG(int ice)
	    {
	    	int capacity = 1&lt;&lt;ice;
	    	threshold = capacity * 3 / 4;
	    	table = new ArrayList&lt;Entry&lt;T&gt;&gt;();
	    	for(int i = 0;i &lt; capacity;i++)table.add(null);
	    }
	    
		final int hash(long n)
		{
			n ^= (n&gt;&gt;&gt;20)^(n&gt;&gt;&gt;12);
			return (int)(n^(n&gt;&gt;&gt;7)^(n&gt;&gt;&gt;4));
		}
		
		int indexFor(int h, int length){
			return h&amp;length-1;
		}
		
		Entry&lt;T&gt; getEntry(long k)
		{
			for(Entry&lt;T&gt; e = table.get(indexFor(hash(k), table.size())); e != null; e = e.next)if(e.key == k)return e;
			return null;
		}
		
		T get(long k)
		{
			for(Entry&lt;T&gt; e = table.get(indexFor(hash(k), table.size())); e != null; e = e.next)if(e.key == k)return e.value;
			return null;
		}
		
		boolean containsKey(long k)
		{
			for(Entry&lt;T&gt; e = table.get(indexFor(hash(k), table.size())); e != null; e = e.next)if(e.key == k)return true;
			return false;
		}
		
		T put(long k, T v)
		{
			int h = hash(k);
			int i = indexFor(h, table.size());
			for(Entry&lt;T&gt; e = table.get(i); e != null; e = e.next){
				if(e.key == k){
					T oldValue = e.value;
					e.value = v;
					return oldValue;
				}
			}
			
			addEntry(h, k, v, i);
			return null;
		}
		
		void addEntry(int h, long k, T v, int bucketIndex)
		{
			if(size &gt;= threshold &amp;&amp; null != table.get(bucketIndex)){
				resize(2*table.size());
				bucketIndex = indexFor(h, table.size());
			}
			createEntry(k, v, bucketIndex);
		}
		
		void resize(int nc)
		{
			List&lt;Entry&lt;T&gt;&gt; newTable = new ArrayList&lt;Entry&lt;T&gt;&gt;();
			for(int i = 0;i &lt; nc;i++)newTable.add(null);
			transfer(newTable);
			table = newTable;
			threshold = nc*3/4;
		}
		
		void transfer(List&lt;Entry&lt;T&gt;&gt; newTable)
		{
			int nc = newTable.size();
			for(Entry&lt;T&gt; e : table){
				while(e != null){
					Entry&lt;T&gt; next = e.next;
					int i = indexFor(hash(e.key), nc);
					e.next = newTable.get(i);
					newTable.set(i, e);
					e = next;
				}
			}
		}
		
		void createEntry(long k, T v, int bucketIndex)
		{
			Entry&lt;T&gt; e = table.get(bucketIndex);
			table.set(bucketIndex, new Entry&lt;T&gt;(k, v, e));
			size++;
		}
		
		// not verified
		final Entry&lt;T&gt; remove(int k)
		{
			int h = hash(k);
			int i = indexFor(h, table.size());
			Entry&lt;T&gt; prev = table.get(i), e = prev;
			while(e != null){
				Entry&lt;T&gt; next = e.next;
				if(e.key == k){
					size--;
					if(prev == e){
						table.set(i, next);
					}else{
						prev.next = next;
					}
					return e;
				}
				prev = e;
				e = next;
			}
			return e;
		}
		
		static class Entry&lt;T&gt;
		{
			public long key;
			public T value;
			public Entry&lt;T&gt; next;
			
			public Entry(long key, T value, Entry&lt;T&gt; next) {
				this.key = key;
				this.value = value;
				this.next = next;
			}
		}
	}
	
	public static HMG&lt;State&gt; add(State s, HMG&lt;State&gt; map)
	{
		long h = s.h();
		if(map.containsKey(h)){
			map.get(h).val = Math.min(map.get(h).val, s.val);
		}else{
			map.put(h, s);
		}
		return map;
	}
	
	public static void main(String[] args) throws Exception
	{
		long S = System.currentTimeMillis();
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		tr(G-S+"ms");
	}
	
	private static boolean eof()
	{
		if(lenbuf == -1)return true;
		int lptr = ptrbuf;
		while(lptr &lt; lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;
		
		try {
			is.mark(1000);
			while(true){
				int b = is.read();
				if(b == -1){
					is.reset();
					return true;
				}else if(!isSpaceChar(b)){
					is.reset();
					return false;
				}
			}
		} catch (IOException e) {
			return true;
		}
	}
	
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;
	
	private static int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private static boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private static int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private static double nd() { return Double.parseDouble(ns()); }
	private static char nc() { return (char)skip(); }
	
	private static String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private static char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private static char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private static int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private static int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.222
expert
----------
PROBLEM STATEMENT:
 Chinese  

Fedor is a research scientist, who has recently found a road map of Ancient Berland.

Ancient Berland consisted of N cities that were connected by M bidirectional roads. The road builders weren't knowledgable. Hence, the start city and the end city for each road were always chosen randomly and independently. As a result, there were more than one road between some pairs of cities. Nevertheless, by luck, the country remained connected (i.e. you were able to get from one city to another via these M roads). And for any road, the start and the end city were not the same.

Moreover, each road had it's own value of importance. This value was assigned by the Road Minister of Ancient Berland. The Road Minister also was not knowledgable, so these numbers were assigned to the roads randomly and independently from the other roads.

When there was a war with the neighboring countries (usually it was with Ancient Herland), it was important to estimate separation number for some pairs of cities.

The separation number for a pair of cities - let's call these cities A and B - is explained below: 

Consider a set of roads that were built. The subset of this set is good, if after removing all roads from this set, there's no longer a way from A to B. The minimal possible sum of roads' value of importance of any good subset is a separation number for the pair of cities (A, B).

For a research, Fedor would like to know the product of separation values over all unordered pairs of cities. Please, find this number. It can be huge, so we ask you to output its product modulo 109+7.
----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;

#define REP(i,a,b) for(i=a;i&lt;b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'&lt;=k&amp;&amp;k&lt;='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k&lt;'0'||k&gt;'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(int *x, int *y){reader(x);reader(y);}
void reader(int *x, int *y, int *z){reader(x);reader(y);reader(z);}
void writer(int x, char c){int i,sz=0,m=0;char buf[10];if(x&lt;0)m=1,x=-x;while(x)buf[sz++]=x%10,x/=10;if(!sz)buf[sz++]=0;if(m)mypc('-');while(sz--)mypc(buf[sz]+'0');mypc(c);}

#define ll long long
#define MD 1000000007

#define INT_INF 1000000000
#define MAX(a,b) (((a)&gt;(b))?(a):(b))
#define MIN(a,b) (((a)&lt;(b))?(a):(b))

#define INT_LIST_MAX_FLOW_NODE 602
int intLmfEdge[INT_LIST_MAX_FLOW_NODE][INT_LIST_MAX_FLOW_NODE];
int intLmfFlow[INT_LIST_MAX_FLOW_NODE][INT_LIST_MAX_FLOW_NODE];
int intLmfInv[INT_LIST_MAX_FLOW_NODE][INT_LIST_MAX_FLOW_NODE];
int intLmfEdgeSize[INT_LIST_MAX_FLOW_NODE],intLmfEdgeMemory[INT_LIST_MAX_FLOW_NODE];
int intLmfLevel[INT_LIST_MAX_FLOW_NODE];

void intListMaxFlowLevelize(int n,int st,int ed){
  int i,j,k,t;
  int q[INT_LIST_MAX_FLOW_NODE],q_st,q_size;
  rep(i,n) intLmfLevel[i]=-1; intLmfLevel[st]=0; q_st=0; q_size=1; q[0]=st;
  while(q_size){
    i=q[q_st++]; q_size--; t=intLmfLevel[i]+1;
    rep(j,intLmfEdgeSize[i]) if(intLmfFlow[i][j]){
      k=intLmfEdge[i][j]; if(intLmfLevel[k]!=-1) continue;
      intLmfLevel[k]=t; q[q_st+q_size++]=k; if(k==ed) return;
    }
  }
}

int intListMaxFlowFlow(int i,int ed,int lim){
  int j,k,ret=0,t,s,ji;
  if(i==ed) return lim;
  rep(j,intLmfEdgeSize[i]) if(intLmfFlow[i][j]){
    k=intLmfEdge[i][j]; if(intLmfLevel[k]&lt;=intLmfLevel[i]) continue;
    s=lim; if(s&gt;intLmfFlow[i][j]) s=intLmfFlow[i][j];
    t=intListMaxFlowFlow(k,ed,s); if(!t) continue;
    ret+=t; lim-=t; ji=intLmfInv[i][j];
    intLmfFlow[i][j]-=t; intLmfFlow[k][ji]+=t;
    if(!lim) break;
  }
  return ret;
}

int intListMaxFlow(int n,int st,int ed){
  int ret=0;
  for(;;){
    intListMaxFlowLevelize(n,st,ed); if(intLmfLevel[ed]==-1) break;
    ret += intListMaxFlowFlow(st,ed,INT_INF);
  }
  return ret;
}

void intListMaxFlowEdgeInit(){
  int i;
  rep(i,INT_LIST_MAX_FLOW_NODE) intLmfEdgeSize[i]=0;
}

void intListMaxFlowEdgeInitAdv(int n){
  int i;
  rep(i,n) intLmfEdgeSize[i]=0;
}

void intListMaxFlowEdgeAdd(int n1,int n2,int f1,int f2){
  int s1=intLmfEdgeSize[n1]++, s2=intLmfEdgeSize[n2]++;
  intLmfEdge[n1][s1]=n2; intLmfEdge[n2][s2]=n1;
  intLmfFlow[n1][s1]=f1; intLmfFlow[n2][s2]=f2;
  intLmfInv[n1][s1]=s2;  intLmfInv[n2][s2]=s1;
}

void intListMaxFlowDfs(int node,int start,int res[]){
  int i,j,k;
  int st[INT_LIST_MAX_FLOW_NODE], st_size=0;

  rep(i,node) res[i]=0; res[start]=1; st[st_size++]=start;
  while(st_size){
    i=st[--st_size];
    rep(k,intLmfEdgeSize[i]) if(intLmfFlow[i][k]){
      j=intLmfEdge[i][k]; if(res[j]) continue;
      res[j]=1; st[st_size++]=j;
    }
  }
}



/* Gomory-Hu's Algorithm ? */
/* int edge[][]????Flow???????edge[i][j]=edge[j][i] */
/* int res[][]????2???max-flow????? */

int edge[600][600], res[600][600];

void intMaxflowAnyPairOfNode(int node,void *WorkMemory){
  int i,j,a,b,flow;
  int *p, *fst;

  p=(int*)WorkMemory; WorkMemory=(void*)(p+node);
  fst=(int*)WorkMemory;

  rep(i,node) p[i]=0;
  rep(i,node) rep(j,node) res[i][j]=INT_INF;

  REP(i,1,node){
    intListMaxFlowEdgeInitAdv(node);
    rep(a,node) REP(b,a+1,node) if(edge[a][b]) intListMaxFlowEdgeAdd(a,b,edge[a][b],edge[b][a]);
    flow = intListMaxFlow(node,i,p[i]);
    intListMaxFlowDfs(node,i,fst);
    REP(j,i+1,node) if(fst[j] &amp;&amp; p[i]==p[j]) p[j]=i;
    res[i][p[i]]=res[p[i]][i]=flow;
    rep(j,i) res[i][j]=res[j][i]=MIN(flow,res[p[i]][j]);
  }
}

int main(){
  int i, j, k, M, N;
  ll ans;
  void *mem=malloc(100000000);

  reader(&amp;N, &amp;M);
  rep(i,N) rep(j,N) edge[i][j] = 0;
  while(M--){
    reader(&amp;i,&amp;j,&amp;k);
    i--; j--;
    edge[i][j] += k;
    edge[j][i] += k;
  }
  intMaxflowAnyPairOfNode(N, mem);

  ans = 1;
  rep(i,N) REP(j,i+1,N) ans = (ans * res[i][j]) % MD;
  writer((int)ans, '\n');

  return 0;
}

----------
====================
----------
ALGORITHMS.223
expert
----------
PROBLEM STATEMENT:
Ms.Kox enjoys her job, but she does not like to waste extra time traveling to and from her office. After working for many years, she knows the shortest-distance route to her office on a regular day.

Recently, the city began regular maintenance of various roads. Every day a road gets blocked and no one can use it that day, but all other roads can be used. You are Ms. Kox's new intern and she needs some help. Every day, you need to determine the minimum distance that she has to travel to reach her office.
----------
TOP SOLUTION:
----------
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;deque&gt;
#include &lt;stack&gt;
#include &lt;bitset&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;string.h&gt;
#include &lt;cassert&gt;

using namespace std;

#define rep(i,a,b) for(__typeof(a) i=(a);i&lt;(b);i++)
#define ll long long int
#define ii pair&lt;int,int&gt;
#define CLEAR(x,val) memset(x,val,sizeof(x))
#define SZ(v) (v).size()
#define MAX 100009
#define inf 1e9

/******** Data Structure ************/
int dist[2][MAX];
int pre [2][MAX];

vector&lt; vector&lt;int&gt; &gt; vv(MAX) , cost(MAX);
vector&lt; vector&lt;int&gt; &gt; tr(MAX) , trc(MAX);

/********* ititialize **************/
void reset() {
	rep( i , 0 , 2 ) rep( j , 0 , MAX ) dist[i][j] = inf; 
	CLEAR( pre , -1 );
	rep( i , 0 , MAX ) vv[i].clear() , cost[i].clear();
	rep( i , 0 , MAX ) tr[i].clear() , trc[i].clear();
}

/********Dijkstra *****************/
void DIJ( int src , int id ) {
	rep( i , 0 , MAX ) dist[id][i] = inf;
	dist[id][src] = 0;
	priority_queue&lt; ii , vector&lt;ii&gt; , greater&lt;ii&gt; &gt; Q;
	ii tmp = make_pair( 0 , src );
	Q.push(tmp);

	while( !Q.empty()  ) {
		tmp = Q.top();Q.pop();
		int w = tmp.first , u = tmp.second;
		int sz = vv[u].size();		

		rep( i , 0 , sz ) {		
			int v = vv[u][i] , cst = cost[u][i];
			if( dist[id][v] &gt; w+cst ) {
				dist[id][v] = w + cst;
				pre[id][v]  = u;
				ii newp = make_pair( dist[id][v] , v );
				Q.push(newp);
			}	
		}
	}
}

/*****Data structure for Query part ***********/
typedef struct edge {
	int u , v , w;
	bool friend operator &lt; ( const edge &amp;A , const edge &amp;B ) {
		return A.w &gt; B.w;
	}
}edge;
edge array[MAX];

priority_queue&lt; edge &gt; Heap[MAX];
int label[MAX] , minl[MAX] , maxl[MAX];
int counter;
/********* tree labeling **********************/
void DFS( int src ) {
	int sz = tr[src].size();minl[src] = counter;
        rep( i , 0 , sz ) {
		int v = tr[src][i];
		DFS( v );
	}
	label[src] = counter;
	maxl[src]  = counter;
	counter++;
}
/*****MMG Algorithm****************************/
void replace( int src ) {
		
	int sz = tr[src].size();
	rep( i , 0 , sz ) {
		int v = tr[src][i];
		replace( v ); 
		while(!Heap[v].empty()) {
			Heap[src].push(Heap[v].top());Heap[v].pop();
		}
	}
	while(!Heap[src].empty()) {	
		edge e = Heap[src].top();Heap[src].pop();
		int u = e.u , v = e.v , w = e.w; 

		if( (label[u] &gt;= minl[src] &amp;&amp; label[u] &lt;= maxl[src] ) &amp;&amp; !(label[v] &gt;= minl[src] &amp;&amp; label[v] &lt;= maxl[src] ) ) {
			array[src] = e;Heap[src].push(e);break;
		}
		else if(!(label[u] &gt;= minl[src] &amp;&amp; label[u] &lt;= maxl[src] ) &amp;&amp; (label[v] &gt;= minl[src] &amp;&amp; label[v] &lt;= maxl[src] )) {
			array[src] = e;Heap[src].push(e);break;
		}
	}
}
int main()
{
	reset();
	int n , m;
	scanf("%d %d" , &amp;n , &amp;m);
	
	assert( n &lt; 200000 &amp;&amp; m &lt; 200000 &amp;&amp; n &gt; 0 &amp;&amp; m &gt; 0 );
	

	rep( i , 0  , m ) {
		int u , v , w;scanf("%d %d %d" , &amp;u , &amp;v , &amp;w );
	
	
		assert( u &gt;= 0 &amp;&amp; u &lt; n );assert( v &gt;= 0 &amp;&amp; v &lt; n );assert( u != v );	
		assert( w &lt;= 1000 );
	
		vv[u].push_back(v);cost[u].push_back(w);
		vv[v].push_back(u);cost[v].push_back(w);
	}
	
	int S , T;
	scanf("%d %d" , &amp;S , &amp;T );


	assert( S &gt;= 0 &amp;&amp; S &lt; n );assert( T &gt;= 0 &amp;&amp; T &lt; n );

	DIJ( S , 0 );
	DIJ( T , 1 );
	

	map&lt;ii,int&gt; mp;mp.clear();
	rep( i , 0 , n ) {
		if( pre[0][i] != -1 ) { 
			tr[pre[0][i]].push_back(i); 
			mp[make_pair( i , pre[0][i])] = 1;
			mp[make_pair( pre[0][i] , i)] = 1;
		}
	}
	
	// After shortest path
	counter = 1;
	DFS( S ); 
/*	DFS labeling for fining cut
	rep( i , 0 , n ) {
		cout &lt;&lt; label[i] &lt;&lt;" " &lt;&lt;  minl[i] &lt;&lt; " " &lt;&lt; maxl[i] &lt;&lt; "\n";
	}
*/
	rep( i , 0 , n ) array[i].w = inf; 
	rep( i , 0 , n ) {	
		int sz = vv[i].size();
		rep( j , 0 , sz ) {
			int v = vv[i][j] , w = cost[i][j];
			if( !mp[make_pair( i ,v )] ) {
					edge e = (edge){ i , v , dist[0][i]+w+dist[1][v] };
					Heap[v].push(e);			
			}
		}
	}
	replace(S);
	// Query Part
	mp.clear();
	rep( i , 0 , n ) {
		if( i != S ) {
			mp[ make_pair(pre[0][i] , i ) ] = array[i].w;
			mp[ make_pair(i , pre[0][i] ) ] = array[i].w; 
		}
	}	

	int Q;scanf("%d" , &amp;Q);

	assert( Q &lt; 200000 &amp;&amp; Q &gt; 0 );
	map&lt; ii , int &gt; mp1;

	int cur = T;
	//
	int tcnt = 0;

	while( cur != -1 ) {
 		
		mp1[make_pair(pre[0][cur] , cur )] = mp[make_pair(pre[0][cur] , cur )];
		mp1[make_pair(cur , pre[0][cur] )] = mp[make_pair(cur , pre[0][cur] )];
		cur = pre[0][cur]; 	
	
	}
	mp.clear();
	rep( i , 0 , Q ) {
		int u , v;
		scanf("%d %d" , &amp;u  , &amp;v );
		assert( u &gt;= 0 &amp;&amp; u &lt; n );assert( v &gt;= 0 &amp;&amp; v &lt; n );assert( u != v );
				

		if( mp1[make_pair( u , v ) ] == 0 ) cout &lt;&lt; dist[0][T] &lt;&lt; "\n";
		else if( mp1[make_pair(u,v)] == inf ) cout &lt;&lt; "Infinty\n"; 
		else cout &lt;&lt; mp1[make_pair( u , v ) ] &lt;&lt;"\n";
	}
	

	return 0;
}
----------
====================
----------
ALGORITHMS.224
advanced
----------
PROBLEM STATEMENT:
Given a tree with vertices numbered from [expression] queries. Each query represents a vertex number encoded in the following way:

Queries are encoded in the following way: Let, [expression].
We are assure that [expression], and hasn't been removed before. 

Note: [expression] is the bitwise XOR operator.

For each query, first decode the vertex [expression] and then perform the following:


Print the size of the connected component containing [expression].  
Remove vertex [expression].  

----------
TOP SOLUTION:
----------
#include&lt;cstdio&gt;
#include&lt;ctime&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;

using namespace std;

int INF, N, M, nr, V, v[400009], ap[200009], t[200009];
bool scos[200009];
vector &lt; int &gt; muchii[200009];

struct nod
{
    int K, P, nr;
    nod *l, *r, *t;
    nod (int K, int P, int nr, nod *l, nod *r)
    {
        this-&gt;nr = nr;
        this-&gt;l = l;
        this-&gt;r = r;
        this-&gt;P = P;
        this-&gt;K = K;
        this-&gt;t = 0;
    }
}*adresa1[200009], *adresa2[200009], *nil, *R;

int Rand(){return ((rand()%32768)&lt;&lt;15)+(rand()%32768)+1;}

void reup (nod *&amp;n)
{
    if (n-&gt;l != nil) n-&gt;l-&gt;t = n;
    if (n-&gt;r != nil) n-&gt;r-&gt;t = n;
    n-&gt;nr = n-&gt;l-&gt;nr + n-&gt;r-&gt;nr + 1;
}

void rot_left (nod *&amp;n)
{
    nod *t=n-&gt;l;
    n-&gt;l = t-&gt;r, t-&gt;r = n;
    t-&gt;t = n-&gt;t;
    reup (n);
    reup (t);
    n = t;
}

void rot_right (nod *&amp;n)
{
    nod *t=n-&gt;r;
    n-&gt;r = t-&gt;l, t-&gt;l = n;
    t-&gt;t = n-&gt;t;
    reup (n);
    reup (t);
    n = t;
}

void balance (nod *&amp;n)
{
    if (n-&gt;l-&gt;P &gt; n-&gt;P)
        rot_left (n);
    else
    if (n-&gt;r-&gt;P &gt; n-&gt;P)
        rot_right (n);
}

void Insert (nod *&amp;n, int Poz, int K, int P)
{
    if (n == nil)
    {
        n = new nod (K, P, 1, nil, nil);
        return ;
    }
    if (n-&gt;l-&gt;nr &gt;= Poz) Insert (n-&gt;l, Poz, K, P);
    else Insert (n-&gt;r, Poz - n-&gt;l-&gt;nr - 1, K, P);
    reup (n);
    balance (n);
}

void Erase (nod *&amp;n, int Poz)
{
    if (n-&gt;l-&gt;nr &gt;= Poz)
        Erase (n-&gt;l, Poz);
    else
    if (n-&gt;l-&gt;nr + 1 &lt; Poz)
        Erase (n-&gt;r, Poz - n-&gt;l-&gt;nr - 1);
    else
    {
        if (n-&gt;l == nil &amp;&amp; n-&gt;r == nil)
        {
            delete n;
            n = nil;
        }
        else
        {
            if (n-&gt;l-&gt;P &gt; n-&gt;r-&gt;P)
                rot_left (n);
            else
                rot_right (n);
            Erase (n, Poz);
        }
    }
    if (n != nil) reup (n);
}

void join(nod *&amp;R, nod *&amp;Rl, nod *&amp;Rr)
{
    R=new nod(0, 0, Rl-&gt;nr + Rr-&gt;nr + 1, Rl, Rr);
    Erase ( R, Rl-&gt;nr+1 );
}

void split(nod *&amp;R, nod *&amp;Rl, nod *&amp;Rr, int Poz)
{
    Insert (R, Poz, 0, INF);
    Rl = R-&gt;l, Rl-&gt;t = 0;
    Rr = R-&gt;r, Rr-&gt;t = 0;
    delete R, R = nil;
}

bool nu_radacina (nod *&amp;n)
{
    if (n-&gt;t != 0 &amp;&amp; (n-&gt;t-&gt;l == n || n-&gt;t-&gt;r == n)) return 1;
    return 0;
}

void det_root (nod *n, nod *&amp;R)
{
    while (1)
    {
        if ( nu_radacina (n) )
            n = n-&gt;t;
        else
            break;
    }
    R = n;
}

int Get_Pos (nod *n)
{
    int ans = n-&gt;l-&gt;nr + 1;
    while (1)
    {
        if (nu_radacina(n))
        {
            if (n-&gt;t-&gt;l == n) n = n-&gt;t;
            else ans += n-&gt;t-&gt;l-&gt;nr + 1, n = n-&gt;t;
        }
        else break;
    }
    return ans;
}

void dfs (int nod)
{
    ap[nod] = 1;
    v[++nr] = nod;
    for (vector &lt; int &gt; :: iterator it = muchii[nod].begin(); it != muchii[nod].end(); it++)
        if (ap[*it] == 0)
        {
            dfs (*it);
            t[*it] = nod;
        }
    v[++nr] = -nod;
}

void build (nod *&amp;n)
{
    if (n == nil) return ;
    if (n-&gt;K &lt; 0)
        adresa2[-n-&gt;K] = n;
    else
        adresa1[n-&gt;K] = n;
    build (n-&gt;l);
    build (n-&gt;r);
}

void afis (nod *&amp;n)
{
    if (n == nil) return ;
    afis (n-&gt;l);
    printf ("%d ", n-&gt;K);
    afis (n-&gt;r);
}

void Del (int a, int b)
{
    if (t[b] == a)
    {
        int aux = a;
        a = b;
        b = aux;
    }
    /////t[a] == b, deci vad in ce treap este a, si ii dau split pentru a separa subarborele
    nod *R, *R1, *R2, *R3, *R4;
    det_root (adresa1[a], R);
    /////sunt in treapul cu radacina R
    int p1, p2;
    p1 = Get_Pos (adresa1[a]);
    p2 = Get_Pos (adresa2[a]);
    split (R, R4, R3, p2);
    split (R4, R1, R2, p1-1);
    R2-&gt;t = 0;
    join (R, R1, R3);
    /*afis (R);
    printf ("\n");
    afis (R2);
    printf ("\n");*/
}

int main()
{
//freopen ("input", "r", stdin);
//freopen ("output", "w", stdout);

srand(time(0));
INF=(1&lt;&lt;30)+7;
scanf ("%d", &amp;N);
for (int i=1; i&lt;N; i++)
{
    int X, Y;
    scanf ("%d %d", &amp;X, &amp;Y);
    muchii[X].push_back(Y);
    muchii[Y].push_back(X);
}
dfs (1);

nil = new nod (0, 0, 0, 0, 0);
R = nil;
for (int i=1; i&lt;=nr; i++)
    Insert (R, i-1, v[i], Rand());
build (R);
int V = 0;
scanf ("%d", &amp;M);
for (int i=1; i&lt;=M; i++)
{
    int x;
    scanf ("%d", &amp;x), x ^= V;
    nod *R;
    det_root (adresa1[x], R);
    printf ("%d\n", R-&gt;nr / 2), scos[x] = 1, V = R-&gt;nr / 2;
    for (auto it = muchii[x].begin (); it != muchii[x].end (); it ++)
        if (!scos[*it]) Del (x, *it);
}
return 0;
}

----------
====================
----------
ALGORITHMS.225
expert
----------
PROBLEM STATEMENT:
There are [expression] people are in a queue.  

There are [expression] in the window.  

Each ticketing window has an offer. If a person in the queue shares the same destination as the person immediately in front of him/her, a 20% reduction in the ticket price is offered to him/her.  

For example, suppose there are [expression] bucks.  

Try to distribute the [expression] people is minimized.  
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;deque&gt;
#include &lt;map&gt;

using namespace std;

#define MAXN 1024*1024
#define x y[cs]
#define y second
#define mp make_pair
#define pb push_back
#define sz(a) (int)(a.size())
#define all(a) a.begin(), a.end()
#define R(a) ((a)%M)

typedef long long ll;
typedef vector&lt;int&gt; VI;
typedef vector&lt;ll&gt; VL;
typedef vector&lt;VI&gt; VVI;
typedef pair&lt;int,int&gt; PI;
typedef vector&lt;PI&gt; VPI;
typedef vector&lt;VPI&gt; VVPI;
typedef vector&lt;VVPI&gt; VVVPI;
typedef vector&lt;VVI&gt; VVVI;
typedef vector&lt;double&gt; VD;
typedef vector&lt;VD&gt; VVD;
typedef vector&lt;string&gt; VS;

double MinCostMatching(const VVD &amp;cost, VI &amp;Lmate, VI &amp;Rmate) {
  int n = int(cost.size());

  // construct dual feasible solution
  VD u(n);
  VD v(n);
  for (int i = 0; i &lt; n; i++) {
    u[i] = cost[i][0];
    for (int j = 1; j &lt; n; j++) u[i] = min(u[i], cost[i][j]);
  }
  for (int j = 0; j &lt; n; j++) {
    v[j] = cost[0][j] - u[0];
    for (int i = 1; i &lt; n; i++) v[j] = min(v[j], cost[i][j] - u[i]);
  }
  
  // construct primal solution satisfying complementary slackness
  Lmate = VI(n, -1);
  Rmate = VI(n, -1);
  int mated = 0;
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      if (Rmate[j] != -1) continue;
      if (fabs(cost[i][j] - u[i] - v[j]) &lt; 1e-10) {
	Lmate[i] = j;
	Rmate[j] = i;
	mated++;
	break;
      }
    }
  }
  
  VD dist(n);
  VI dad(n);
  VI seen(n);
  
  // repeat until primal solution is feasible
  while (mated &lt; n) {
    
    // find an unmatched left node
    int s = 0;
    while (Lmate[s] != -1) s++;
    
    // initialize Dijkstra
    fill(dad.begin(), dad.end(), -1);
    fill(seen.begin(), seen.end(), 0);
    for (int k = 0; k &lt; n; k++) 
      dist[k] = cost[s][k] - u[s] - v[k];
    
    int j = 0;
    while (true) {
      
      // find closest
      j = -1;
      for (int k = 0; k &lt; n; k++) {
	if (seen[k]) continue;
	if (j == -1 || dist[k] &lt; dist[j]) j = k;
      }
      seen[j] = 1;
      
      // termination condition
      if (Rmate[j] == -1) break;
      
      // relax neighbors
      const int i = Rmate[j];
      for (int k = 0; k &lt; n; k++) {
	if (seen[k]) continue;
	const double new_dist = dist[j] + cost[i][k] - u[i] - v[k];
	if (dist[k] &gt; new_dist) {
	  dist[k] = new_dist;
	  dad[k] = j;
	}
      }
    }
    
    // update dual variables
    for (int k = 0; k &lt; n; k++) {
      if (k == j || !seen[k]) continue;
      const int i = Rmate[k];
      v[k] += dist[k] - dist[j];
      u[i] -= dist[k] - dist[j];
    }
    u[s] += dist[j];
    
    // augment along path
    while (dad[j] &gt;= 0) {
      const int d = dad[j];
      Rmate[j] = Rmate[d];
      Lmate[Rmate[j]] = j;
      j = d;
    }
    Rmate[j] = s;
    Lmate[s] = j;
    
    mated++;
  }
  
  double value = 0;
  for (int i = 0; i &lt; n; i++)
    value += cost[i][Lmate[i]];
  
  return value;
}

int N, M, K;
map&lt;string, double&gt; f;
VI L, R;
VVD cost;
VS d;
double inf = 1e10;

int find ( int n )
{
	if(L[n] &lt; N)
		L[n] = find(L[n]);
	return L[n];
}

int main ()
{
	cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;
	
	d = VS(N);
	cost = VVD(N+M, VD(N+M,0.0));
	
	string _s;
	double _p;
	for (int i = 0; i &lt; K; i += 1)
	{
		cin &gt;&gt; _s &gt;&gt; _p;
		f[_s] = _p;
	}
	
	for (int i = 0; i &lt; N; i += 1)
		cin &gt;&gt; d[i];
	
	for (int i = 0; i &lt; N+M; i += 1)
	{
		for (int j = 0; j &lt; N+M; j += 1)
		{
			if (i &gt;= N)
				cost[i][j] = 0.0;
			else if (j &gt;= N)
				cost[i][j] = f[d[i]];
			else if ( i &lt;= j )
				cost[i][j] = inf;
			else if ( d[i] == d[j] )
				cost[i][j] = 0.8*f[d[i]];
			else
				cost[i][j] = f[d[i]];
		}
	}
	
	cout &lt;&lt; MinCostMatching(cost, L, R) &lt;&lt; '\n';
	
	for (int i = 0; i &lt; N; i += 1)
		cout &lt;&lt; find(i)-N+1 &lt;&lt; '\n';
	
	return 0;
}








----------
====================
----------
ALGORITHMS.226
expert
----------
PROBLEM STATEMENT:
Let [expression].

Consider the standard DFS (Depth-First Search) algorithm starting from vertex [expression] is classified by the algorithm into one of four groups:


tree edge: If [expression].
back edge: If [expression].
forward edge: If [expression] was on the stack.
cross edge: Any edge that is not a tree, back, or forward edge.


To better understand this, consider the following C++ pseudocode:

[expression]
[expression] 

[expression]
[expression]   

[expression]

[expression]
    [expression]
    [expression]
    [expression]
        [expression]
            [expression]
            [expression]
            [expression]
        [expression]
        [expression]
            [expression]
            [expression]
        [expression]
        [expression]
        [expression]
    [expression]
    [expression]
    [expression]
[expression]



Given four integers, [expression] according to the Output Format specified below.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;
#define sim template &lt; class c
#define ris return * this
#define dor &gt; debug &amp; operator &lt;&lt;
#define eni(x) sim &gt; typename \
  enable_if&lt;sizeof dud&lt;c&gt;(0) x 1, debug&amp;&gt;::type operator&lt;&lt;(c i) {
sim &gt; struct rge { c b, e; };
sim &gt; rge&lt;c&gt; range(c i, c j) { return rge&lt;c&gt;{i, j}; }
sim &gt; auto dud(c* x) -&gt; decltype(cerr &lt;&lt; *x, 0);
sim &gt; char dud(...);
struct debug{
#ifdef LOCAL
~debug() { cerr &lt;&lt; endl; }
eni(!=) cerr &lt;&lt; boolalpha &lt;&lt; i; ris; }
eni(==) ris &lt;&lt; range(begin(i), end(i)); }
sim, class b dor(pair &lt; b, c &gt; d) {
  ris &lt;&lt; "(" &lt;&lt; d.first &lt;&lt; ", " &lt;&lt; d.second &lt;&lt; ")";
}
sim dor(rge&lt;c&gt; d) {
  *this &lt;&lt; "[";
  for (auto it = d.b; it != d.e; ++it)
    *this &lt;&lt; ", " + 2 * (it == d.b) &lt;&lt; *it;
  ris &lt;&lt; "]";
}
#else
sim dor(const c &amp;) { ris; }
#endif
};
#define imie(x) " [" &lt;&lt; #x ": " &lt;&lt; (x) &lt;&lt; "] "

const int nax = 1e6 + 5;
int n, b, f, c;
vector&lt;int&gt; children[nax];
vector&lt;pair&lt;int,int&gt;&gt; cross;
vector&lt;pair&lt;int,int&gt;&gt; down;
vector&lt;int&gt; ancestors;

void dfs(int a, int next) {
	if(next &gt; n) return;
	for(int i = 0; i &lt; (int) ancestors.size() &amp;&amp; (int) down.size() &lt; max(f, b); ++i)
		down.push_back({ancestors[i], next});
	children[a].push_back(next);
	int rem = n - next + 1;
	if(c - (int) cross.size() &gt;= rem - 1) {
		for(int i = next + 1; i &lt;= n &amp;&amp; (int) cross.size() &lt; c; ++i) {
			cross.push_back({i, next});
		}
		dfs(a, next + 1);
	}
	else {
		ancestors.push_back(a);
		dfs(next, next + 1);
		ancestors.pop_back();
	}
}

vector&lt;int&gt; tmp[nax];

int main() {
	scanf("%d%d%d%d", &amp;n, &amp;b, &amp;f, &amp;c);
	++n;
	b -= n - 1;
	dfs(1, 2);
	if((int) down.size() &lt; max(f, b) || (int) cross.size() &lt; c) {
		puts("-1");
		return 0;
	}
	
	
	
	b += n - 1;
	for(int a = 1; a &lt;= n; ++a)
		for(int x : children[a])
			if(b) {
				--b;
				tmp[x].push_back(a);
			}
	for(int a = 1; a &lt;= n; ++a)
		for(int x : tmp[a])
			children[a].push_back(x);
	
	for(auto p : cross)
		children[p.first].push_back(p.second);
	
	for(auto p : down) {
		if(f) {
			--f;
			children[p.first].push_back(p.second);
		}
		if(b) {
			--b;
			children[p.second].push_back(p.first);
		}
	}
	debug() &lt;&lt; cross[0];
	printf("%d\n", n);
	for(int i = 1; i &lt;= n; ++i) {
		printf("%d ", (int) children[i].size());
		for(int x : children[i]) printf("%d ", x);
		puts("");
	}
}

----------
====================
----------
ALGORITHMS.227
expert
----------
PROBLEM STATEMENT:
We define the diameter of a strongly-connected oriented graph, [expression] (recall that a path's length is its number of edges).  

Given two integers, [expression] and the graph's diameter is as small as possible (see the Scoring section below for more detail). Then print the graph according to the Output Format specified below.  

Here's a sample strongly-connected oriented graph with [expression].  



Note: Cycles and multiple edges between vertices are allowed.
----------
TOP SOLUTION:
----------
import sys, time, random
from time import time
from collections import *
from decimal import *
from math import *
from bisect import *
#from deque import *

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

t0 = time()

#N, D = 787, 3
N, D=[int(i) for i in input().strip().split(' ')]

RN=range(N)
RD=range(D)

MINDIAM=1
NN=D
while NN &lt; N: NN *=D; MINDIAM+=1
eprint("MINDIAM=",MINDIAM)

out=[[] for n in RN]

def diam(n0):
    dis=[9999]*N
    q = deque()
    for o in out[n0]:
        dis[o]=1
        q.append(o)
    while len(q):
        n = q.popleft()
        dd=dis[n]+1
        for o in out[n]:
            if dis[o] &lt;= dd: continue
            dis[o]=dd
            q.append(o)
    r=max(dis)
    #eprint("dis[%d]=" % n0, dis)
    #eprint("diam[%d]="%n0,r, " mind=",md)
    return r

def diamall():
    lo=N
    hi=0
    for n in RN:
        d=diam(n)
        lo=min(lo, d)
        hi=max(hi, d)
    eprint("DIAMALL:",lo,hi)
    return hi

o=1
for n in RN:
    for d in RD:
        out[n].append(o)
        o+=1
        if o==N: o=0

ans=diamall()
eprint("t=", time()-t0)
print(ans)

for n in RN:
    print(*out[n])
    #if n&gt;10: eprint("BREAK"); break
----------
====================
----------
ALGORITHMS.228
expert
----------
PROBLEM STATEMENT:
Airports are being built on a straight road according to a new construction plan. For convenience, imagine a number line on which at different points airports can be positioned. Because a plane can't take off and start landing immediately, there will be flight between two airports in locations [expression] is a constant.

Changing the position of an airport from [expression]. The cost to fix a certain plan is the minimum total cost of changing the positions of airports. After the changes, it should be possible to travel between any pair of airports, possibly taking flights through some intermediate airports. Note that it's possible that two airports have the same initial position, and this can be the case  after changes too.

On [expression] is announced. On each day that a new airport is announced, print the smallest cost to fix the set of airports announced so far . Note that you should not change the positions of any airports, just calculate the cost to do it.


----------
TOP SOLUTION:
----------
// ayy
// ' lamo
// SUBLIME HAX
	#include &lt;bits/stdc++.h&gt;
	using namespace std;
	template&lt;class T,class U&gt;
	ostream &amp;operator&lt;&lt;(ostream &amp;os,const pair&lt;T,U&gt; &amp;x) {
		return os&lt;&lt;"("&lt;&lt;x.first&lt;&lt;","&lt;&lt;x.second&lt;&lt;")";
	}
	namespace dbg_ns {
		template&lt;typename C&gt;
		struct is_iterable {
			template&lt;class T&gt; static long check(...);
			template&lt;class T&gt; static char check(int,
				typename T::const_iterator = C().end());
			enum {
				value = sizeof(check&lt;C&gt;(0)) == sizeof(char),
				neg_value = sizeof(check&lt;C&gt;(0)) != sizeof(char)
			};
		};
		template&lt;class T&gt; ostream &amp;_out_str(ostream &amp;os,const T &amp;x) {
			return os&lt;&lt;'"'&lt;&lt;x&lt;&lt;'"';
		}
		template&lt;class T&gt; ostream &amp;_dbg2_5(ostream &amp;,const T &amp;);
		template&lt;bool B,typename T=void&gt; using eit=typename enable_if&lt;B,T&gt;::type;
		template&lt;class T&gt;
		inline ostream &amp;_dbg3(ostream &amp;os,eit&lt;is_iterable&lt;T&gt;::neg_value,const T&gt; &amp;x) {
			return os&lt;&lt;x;
		}
		template&lt;class T&gt;
		inline ostream &amp;_dbg3(ostream &amp;os,eit&lt;is_iterable&lt;T&gt;::value,const T&gt; &amp;V) {
			os&lt;&lt;"{";
			bool ff=0;
			for(const auto &amp;E:V) _dbg2_5(ff?os&lt;&lt;",":os,E), ff=1;
			return os&lt;&lt;"}";
		}
		template&lt;&gt;
		inline ostream &amp;_dbg3&lt;string&gt;(ostream &amp;os,const string &amp;x) {
			return _out_str(os,x);
		}
		template&lt;&gt;
		inline ostream &amp;_dbg3&lt;const char *&gt;(ostream &amp;os,const char *const &amp;x) {
			return _out_str(os,x);
		}
		template&lt;class T&gt; inline ostream &amp;_dbg2_5(ostream &amp;os,const T &amp;x) {
			return _dbg3&lt;T&gt;(os,x);
		}
		template&lt;class T,typename... Args&gt; ostream &amp;_dbg2(ostream &amp;os,vector&lt;string&gt;::iterator nm,const T &amp;x,Args&amp;&amp;... args);
		inline ostream &amp;_dbg2(ostream &amp;os,vector&lt;string&gt;::iterator) { return os; }
		template&lt;typename... Args&gt;
		inline ostream &amp;_dbg2(ostream &amp;os,vector&lt;string&gt;::iterator nm,const char *x,Args&amp;&amp;... args) {
			return _dbg2(_dbg3&lt;const char *&gt;(os&lt;&lt;"  ",x),nm+1,args...);
		}
		template&lt;class T,typename... Args&gt;
		inline ostream &amp;_dbg2(ostream &amp;os,vector&lt;string&gt;::iterator nm,const T &amp;x,Args&amp;&amp;... args) {
			return _dbg2(_dbg3&lt;T&gt;(os&lt;&lt;"  "&lt;&lt;*nm&lt;&lt;"=",x),nm+1,args...);
		}
		vector&lt;string&gt; split(string s) {
			vector&lt;string&gt; Z;
			string z="";
			s+=',';
			int dep=0;
			for(char c:s) {
				if(c==',' &amp;&amp; !dep) Z.push_back(z),z="";
				else z+=c;
				if(c=='(') ++dep;
				if(c==')') --dep;
			}
			return Z;
		}
		template&lt;typename... Args&gt; inline ostream &amp;_dbg1(int ln,const string &amp;nm,Args&amp;&amp;... args) {
			auto nms=split(nm);
			return _dbg2(cerr&lt;&lt;"L"&lt;&lt;ln&lt;&lt;":",nms.begin(),args...)&lt;&lt;endl;
		}
	}
	#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)
	#define sz(x) (int(x.size()))
	#define eprintf(...) fprintf(stderr,__VA_ARGS__)
	#define fi first
	#define se second
	#define pb push_back
// END SUBLIME HAX
// #include &lt;bits/extc++.h&gt;
// using namespace __gnu_pbds;
typedef unsigned long long ull;
typedef long long ll;
typedef long double ld; //CARE
typedef complex&lt;ld&gt; pt;
const ld eps=(ld)1e-8;
const ld tau=2*(ld)acosl(-1);
const int inf=1e9+99;
const ll linf=1e18+99;
const int P=1e9+7;





int n;
int hi,lo;
set&lt;int&gt; ss;
set&lt;pair&lt;int,int&gt; &gt; ww;

void kill(int x) {
	auto it=ss.lower_bound(x);
	assert(*it==x);
	++it;
	if(it==ss.end()) return;
	int y=*it;
	pair&lt;int,int&gt; key={y-x,x};
	if(ww.count(key)) ww.erase(key);
}
void add(int x) {
	auto it=ss.lower_bound(x);
	assert(*it==x);
	++it;
	if(it==ss.end()) return;
	int y=*it;
	ww.insert({y-x,x});
}


void ins(int x) {
	auto it=ss.lower_bound(x);
	if(it!=ss.end() &amp;&amp; *it==x) return;
	int y=inf;
	if(it!=ss.begin()) {
		--it;
		y=*it;
		kill(y);
	}
	ss.insert(x);
	if(y!=inf) add(y);
	add(x);
}
void RZ() {
	n=0;
	ss.clear();
	ww.clear();
}
void INS(int x) {
	if(!n) {
		hi=lo=x;
		n=1;
		return;
	}
	if(n==1) {
		hi=max(hi,x);
		lo=min(lo,x);
		n=2;
		return;
	}

	++n;
	if(x&gt;hi) {
		ins(hi);
		hi=x;
		return;
	}
	if(x&lt;lo) {
		ins(lo);
		lo=x;
		return;
	}
	ins(x);
}
int Q(int d) {
	if(n==1) return 0;
	assert(sz(ss)&lt;=n-2);
	if(n==2) return max(0,d-(hi-lo));


	// dbg(ss,ww,lo,hi);

	int Z=inf;
	auto it=ss.lower_bound(hi-d+1);
	if(it==ss.end()) return 0;
	if(*it&gt;=lo+d) return 0;
	Z=min(Z,max(0,d-(*it-lo)));
	it=ss.lower_bound(lo+d);
	--it;
	Z=min(Z,max(0,d-(hi-*it)));


	for(;;) {
		auto it=ww.end();
		if(it==ww.begin()) {
			break;
		}
		--it;
		if(it-&gt;se&lt;hi-d || it-&gt;se+it-&gt;fi&gt;lo+d) {
			ww.erase(it);
		} else {
			break;
		}
	}
	auto it2=ww.end();
	if(it2!=ww.begin()) {
		--it2;
		Z=min(Z,max(0,d+d-(hi-lo)-it2-&gt;fi));
	}
	return Z;
}



void _m() {
	int n,d;
	scanf("%d%d",&amp;n,&amp;d);
	RZ();
	for(;n--;) {
		int x; scanf("%d",&amp;x);
		INS(x);
		printf("%d%c",Q(d)," \n"[!n]);
	}
}


int32_t main() {
	int q; scanf("%d",&amp;q);
	for(;q--;) _m();
}












----------
====================
----------
ALGORITHMS.229
expert
----------
PROBLEM STATEMENT:
Alex has a board game consisting of:


A chip for marking his current location on the board.
[expression], denoting the next position for the chip to jump to from that field.
A die with [expression], of being rolled.


Alex then performs the following actions:


Begins the game by placing the chip at a position in a field randomly and with equiprobability. 
Takes [expression] turns; during each turn he:
Rolls the die. We'll denote the number rolled during a turn as [expression].
Jumps the chip [expression] times. Recall that each field contains a value denoting the next field number to jump to.
After completing [expression] turns, the game ends and he must calculate the respective probabilities for each field as to whether the game ended with the chip in that field.


Given [expression] at the end of the game.

Note: All the probabilities in this task are rational numbers modulo [expression]). Click here to learn about Modular Multiplicative Inverse.
----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.InputMismatchException;
import java.util.Map;

public class G2 {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
//	String INPUT = "7 3 1\r\n" + 
//			"4 2 7 2 4 3 5 \r\n" + 
//			"0 1 0 ";
//	String INPUT = "4 2 1\r\n" + 
//			"1 4 2 3 \r\n" + 
//			"748683265 249561089";
	// 1 2-&gt;4-&gt;3-&gt;2
//	String INPUT = "4 2 2\r\n" + 
//			"2 3 1 3 \r\n" + 
//			"0 1 ";
	// 1/4 1/4 1/2
	// 1/2 1/4 1/4
//	String INPUT = "3 1 2\r\n" + 
//			"1 3 1 \r\n" + 
//			"1 ";
//	String INPUT = "4 5 1\r\n" + 
//			"2 3 2 4\r\n" + 
//			"332748118 332748118 332748118 0 0";
	
	void solve()
	{
		int n = ni(), m = ni(), K = ni();
		int[] f = na(n);
		for(int i = 0;i &lt; n;i++)f[i]--;
		long[] ps = new long[m];
		for(int i = 0;i &lt; m;i++)ps[i] = nl();
		int mod = 998244353;
//		tr("phase 0");
		long[] made = make(ps, K, n+1, 1);
		
		int H = (int)Math.sqrt(n)*8; // naive height limit
		int B = (int)Math.sqrt(n)*8; // cycle split period
		
		SplitResult sres = split(f);
		int[] tclus = new int[n];
		Arrays.fill(tclus, -1);
		for(int i = n-1;i &gt;= 0;i--){
			int cur = sres.ord[i];
			if(sres.incycle[cur]){
				tclus[cur] = cur;
			}else{
				tclus[cur] = tclus[f[cur]];
			}
		}
//		tr("phase 1");
		long[] rets = new long[n];
		int[][] maps = makeBuckets(tclus, n);
		for(int i = 0;i &lt; n;i++){
			if(maps[i].length &gt; 0){
				int[] map = maps[i];
				int[] lpar = new int[map.length];
				int p = 0;
				for(int x : maps[i]){
					if(sres.incycle[x]){
						lpar[p++] = -1;
					}else{
						lpar[p++] = Arrays.binarySearch(map, f[x]);
					}
				}
				long[] res = solve(parentToG(lpar), lpar, made, H, Arrays.binarySearch(map, i));
				for(int j = 0;j &lt; res.length;j++){
					if(!sres.incycle[map[j]]){
						rets[map[j]] += res[j];
					}
				}
			}
		}
//		tr("phase 2");
		
		int[] maxdep = new int[n];
		for(int i = 0;i &lt; n;i++){
			int cur = sres.ord[i];
			if(!sres.incycle[cur]){
				maxdep[f[cur]] = Math.max(maxdep[f[cur]], maxdep[cur]+1);
			}
		}
		int[] tdep = new int[n];
		for(int i = n-1;i &gt;= 0;i--){
			int cur = sres.ord[i];
			if(!sres.incycle[cur]){
				tdep[cur] = tdep[f[cur]]+1;
			}
		}
//		tr("phase 3");
//		for(int j = made.length-1-1;j &gt;= 0;j--){
//			made[j] += made[j+1];
//			if(made[j] &gt;= mod)made[j] -= mod;
//		}
		
		boolean[] ved = new boolean[n];
		int[] cycle = new int[n];
		Map&lt;Long, long[]&gt; cache = new HashMap&lt;&gt;();
		for(int i = 0;i &lt; n;i++){
			if(sres.incycle[i] &amp;&amp; !ved[i]){
				int p = 0;
				ved[i] = true;
				cycle[p++] = i;
				int lmaxdep = maxdep[i];
				for(int j = f[i];!ved[j];j = f[j]){
					ved[j] = true;
					cycle[p++] = j;
					lmaxdep = Math.max(lmaxdep, maxdep[j]);
				}
				int tail = lmaxdep+p+1;
				int fp = p;
				long[] di = cache.computeIfAbsent((long)tail&lt;&lt;32|fp, (z) -&gt; {
					long[] res = make(ps, K, tail, fp);
					for(int j = res.length-fp-1;j &gt;= 0;j--){
						res[j] += res[j+fp];
						if(res[j] &gt;= mod)res[j] -= mod;
					}
					return res;
				});
				// 0.1 0.2 0.3 0.4
				// 0.4 0.6
				// 0.1 0.6 0.3
				// 0.1 0.2 0.3 0.4
				
				// 0.4 0.6
				// 0.6 0.3
				// 0.3 0.4
				
				
				if(p &lt;= B){
					for(int j = 0;j &lt; p;j++){
						for(int v : maps[cycle[j]]){
							for(int k = tdep[v], l = j;k &lt; tdep[v]+p;k++,l++){
								if(l == p)l = 0;
								rets[cycle[l]] += di[k];
							}
						}
					}
				}else{
					inputed = null;
					for(int b = 0;b &lt; p;b+=B){
						long[] ents = new long[tail+1];
						for(int j = 0;j &lt; b;j++){
							for(int v : maps[cycle[j]]){
								ents[tail-(b-j)-tdep[v]]++;
							}
						}
						for(int j = b+B;j &lt; p;j++){
							for(int v : maps[cycle[j]]){
								ents[tail-b-(p-j)-tdep[v]]++;
							}
						}
						long[] ced = convoluteSimply(ents, di, mod, 3);
						inputed = saved;
						for(int k = b;k &lt; p &amp;&amp; k &lt; b+B;k++){
							rets[cycle[k]] += ced[tail+k-b];
						}
					}
					inputed = null;
					
					// remainder
					for(int j = 0;j &lt; p;j++){
						for(int v : maps[cycle[j]]){
							for(int k = tdep[v], l = j;k &lt; tdep[v]+p &amp;&amp; l &lt; p &amp;&amp; l &lt; j/B*B+B;k++,l++){
								rets[cycle[l]] += di[k];
							}
							for(int k = tdep[v]+p-j+j/B*B, l = j/B*B;k &lt; tdep[v]+p &amp;&amp; l &lt; j;k++,l++){
								rets[cycle[l]] += di[k];
							}
						}
					}
				}
			}
		}
//		tr("phase 4");
		
		long RN = invl(n, mod);
		for(long ret : rets){
			out.println(ret%mod*RN%mod);
		}
	}
	
	int mod = 998244353;
	
	long[] make(long[] ps, int K, int tail, int period)
	{
		long[] ms = ps;
		if(ps.length &gt; tail+period){
			ms = Arrays.copyOf(ps, tail+period);
			for(int j = tail+period, k = tail;j &lt; ps.length;j++,k++){
				if(k == tail+period)k -= period;
				ms[k] += ps[j];
				if(ms[k] &gt;= mod)ms[k] -= mod;
			}
		}
		
		long[] pps = new long[1];
		pps[0] = 1;
		for(int i = 0;1&lt;&lt;i &lt;= K;i++){
			if(K&lt;&lt;~i&lt;0){
				long[] res = convoluteSimply(pps, ms, mod, 3);
				for(int j = res.length-1-period;j &gt;= tail;j--){
					res[j] += res[j+period];
					res[j+period] = 0;
					if(res[j] &gt;= mod)res[j] -= mod;
				}
				pps = Arrays.copyOf(res, Math.min(tail+period, pps.length+ms.length));
			}
			
			if(1&lt;&lt;i+1 &lt;= K){
				long[] res = convoluteSimply(ms, ms, mod, 3);
				for(int j = res.length-1-period;j &gt;= tail;j--){
					res[j] += res[j+period];
					res[j+period] = 0;
					if(res[j] &gt;= mod)res[j] -= mod;
				}
				ms = Arrays.copyOf(res, Math.min(tail+period, ms.length+ms.length));
			}
		}
		if(pps.length &lt; tail+period)pps = Arrays.copyOf(pps, tail+period);
		return pps;
	}
	
	long[] solve(int[][] g, int[] par, long[] di, int H, int root)
	{
		int n = g.length;
		long[] ret = new long[n];
		int[][] pars = parents3(g, root);
		int[] des = new int[n];
		long[] ws = new long[n];
		int[] ord = pars[1], dep = pars[2];
		int[] marked = new int[n];
		for(int i = n-1;i &gt;= 0;i--){
			int cur = ord[i];
			des[cur]++;
			ws[cur] += des[cur];
			if(marked[cur] == 0 &amp;&amp; ws[cur] &gt; (long)H*des[cur]){
				marked[cur] = 1;
			}
			if(i &gt; 0){
				des[par[cur]] += des[cur];
				ws[par[cur]] += ws[cur];
				if(marked[cur] &gt;= 1)marked[par[cur]] = 2;
			}
		}
		
//		tr(g, root);
//		tr(marked);
		
		// large
		// marked node
		for(int i = 0;i &lt; n;i++){
			if(marked[i] == 1){
				int[] fdep = new int[n];
				collect(i, par[i], g, dep, fdep);
				for(int j = par[i];j != -1 &amp;&amp; marked[j] == 2;j = par[j]){
					fdep[dep[j]]++;
					marked[j] = 3;
				}
				
				int lmaxdep = n;
				for(int j = n-1;j &gt;= 0;j--){
					if(fdep[j] &gt; 0){
						lmaxdep = j;
						break;
					}
				}
				long[] rfdep = new long[lmaxdep+1];
				for(int j = 0;j &lt;= lmaxdep;j++){
					rfdep[lmaxdep-j] = fdep[j];
				}
				
//				tr("fdep", fdep, marked);
				long[] ced = convoluteSimply(rfdep, Arrays.copyOf(di, lmaxdep+1), mod, 3);
				for(int j = i;j != -1;j = par[j]){
					ret[j] += ced[lmaxdep-dep[j]];
				}
			}
		}
		
		// small
		for(int i = 0;i &lt; n;i++){
			if(marked[i] == 0){
				for(int j = i;j != -1 &amp;&amp; marked[j] != 1;j = par[j]){
					ret[j] += di[dep[i]-dep[j]];
				}
			}
		}
		
		for(int i = 0;i &lt; n;i++){
			ret[i] %= mod;
		}
		
		return ret;
	}
	
	void collect(int cur, int par, int[][] g, int[] dep, int[] fdep)
	{
		fdep[dep[cur]]++;
		for(int e : g[cur]){
			if(e != par)collect(e, cur, g, dep, fdep);
		}
	}
	
	// library
	
	public static int[][] parents3(int[][] g, int root) {
		int n = g.length;
		int[] par = new int[n];
		Arrays.fill(par, -1);

		int[] depth = new int[n];
		depth[0] = 0;

		int[] q = new int[n];
		q[0] = root;
		for (int p = 0, r = 1; p &lt; r; p++) {
			int cur = q[p];
			for (int nex : g[cur]) {
				if (par[cur] != nex) {
					q[r++] = nex;
					par[nex] = cur;
					depth[nex] = depth[cur] + 1;
				}
			}
		}
		return new int[][] { par, q, depth };
	}

	
	public static final int[] NTTPrimes = {1053818881, 1051721729, 1045430273, 1012924417, 1007681537, 1004535809, 998244353, 985661441, 976224257, 975175681};
	public static final int[] NTTPrimitiveRoots = {7, 6, 3, 5, 3, 3, 3, 3, 3, 17};
//	public static final int[] NTTPrimes = {1012924417, 1004535809, 998244353, 985661441, 975175681, 962592769, 950009857, 943718401, 935329793, 924844033};
//	public static final int[] NTTPrimitiveRoots = {5, 3, 3, 3, 17, 7, 7, 7, 3, 5};
	
	static long[] inputed;
	static long[] saved;
	
	public static long[] convoluteSimply(long[] a, long[] b, int P, int g)
	{
		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)&lt;&lt;2);
		long[] fa = nttmb(a, m, false, P, g);
		long[] fb = a == b ? fa : inputed != null ? inputed : nttmb(b, m, false, P, g);
		saved = fb;
		for(int i = 0;i &lt; m;i++){
			fa[i] = fa[i]*fb[i]%P;
		}
		return nttmb(fa, m, true, P, g);
	}
	
	public static long[] convolute(long[] a, long[] b)
	{
		int USE = 2;
		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)&lt;&lt;2);
		long[][] fs = new long[USE][];
		for(int k = 0;k &lt; USE;k++){
			int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];
			long[] fa = nttmb(a, m, false, P, g);
			long[] fb = a == b ? fa : nttmb(b, m, false, P, g);
			for(int i = 0;i &lt; m;i++){
				fa[i] = fa[i]*fb[i]%P;
			}
			fs[k] = nttmb(fa, m, true, P, g);
		}
		
		int[] mods = Arrays.copyOf(NTTPrimes, USE);
		long[] gammas = garnerPrepare(mods);
		int[] buf = new int[USE];
		for(int i = 0;i &lt; fs[0].length;i++){
			for(int j = 0;j &lt; USE;j++)buf[j] = (int)fs[j][i];
			long[] res = garnerBatch(buf, mods, gammas);
			long ret = 0;
			for(int j = res.length-1;j &gt;= 0;j--)ret = ret * mods[j] + res[j];
			fs[0][i] = ret;
		}
		return fs[0];
	}
	
	public static long[] convolute(long[] a, long[] b, int USE, int mod)
	{
		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)&lt;&lt;2);
		long[][] fs = new long[USE][];
		for(int k = 0;k &lt; USE;k++){
			int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];
			long[] fa = nttmb(a, m, false, P, g);
			long[] fb = a == b ? fa : nttmb(b, m, false, P, g);
			for(int i = 0;i &lt; m;i++){
				fa[i] = fa[i]*fb[i]%P;
			}
			fs[k] = nttmb(fa, m, true, P, g);
		}
		
		int[] mods = Arrays.copyOf(NTTPrimes, USE);
		long[] gammas = garnerPrepare(mods);
		int[] buf = new int[USE];
		for(int i = 0;i &lt; fs[0].length;i++){
			for(int j = 0;j &lt; USE;j++)buf[j] = (int)fs[j][i];
			long[] res = garnerBatch(buf, mods, gammas);
			long ret = 0;
			for(int j = res.length-1;j &gt;= 0;j--)ret = (ret * mods[j] + res[j]) % mod;
			fs[0][i] = ret;
		}
		return fs[0];
	}
	
	// static int[] wws = new int[270000]; // outer faster
	
	// Modifed Montgomery + Barrett
	private static long[] nttmb(long[] src, int n, boolean inverse, int P, int g)
	{
		long[] dst = Arrays.copyOf(src, n);
		
		int h = Integer.numberOfTrailingZeros(n);
		long K = Integer.highestOneBit(P)&lt;&lt;1;
		int H = Long.numberOfTrailingZeros(K)*2;
		long M = K*K/P;
		
		int[] wws = new int[1&lt;&lt;h-1];
		long dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);
		long w = (1L&lt;&lt;32)%P;
		for(int k = 0;k &lt; 1&lt;&lt;h-1;k++){
			wws[k] = (int)w;
			w = modh(w*dw, M, H, P);
		}
		long J = invl(P, 1L&lt;&lt;32);
		for(int i = 0;i &lt; h;i++){
			for(int j = 0;j &lt; 1&lt;&lt;i;j++){
				for(int k = 0, s = j&lt;&lt;h-i, t = s|1&lt;&lt;h-i-1;k &lt; 1&lt;&lt;h-i-1;k++,s++,t++){
					long u = (dst[s] - dst[t] + 2*P)*wws[k];
					dst[s] += dst[t];
					if(dst[s] &gt;= 2*P)dst[s] -= 2*P;
//					long Q = (u&amp;(1L&lt;&lt;32)-1)*J&amp;(1L&lt;&lt;32)-1;
					long Q = (u&lt;&lt;32)*J&gt;&gt;&gt;32;
					dst[t] = (u&gt;&gt;&gt;32)-(Q*P&gt;&gt;&gt;32)+P;
				}
			}
			if(i &lt; h-1){
				for(int k = 0;k &lt; 1&lt;&lt;h-i-2;k++)wws[k] = wws[k*2];
			}
		}
		for(int i = 0;i &lt; n;i++){
			if(dst[i] &gt;= P)dst[i] -= P;
		}
		for(int i = 0;i &lt; n;i++){
			int rev = Integer.reverse(i)&gt;&gt;&gt;-h;
			if(i &lt; rev){
				long d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;
			}
		}
		
		if(inverse){
			long in = invl(n, P);
			for(int i = 0;i &lt; n;i++)dst[i] = modh(dst[i]*in, M, H, P);
		}
		
		return dst;
	}
	
	// Modified Shoup + Barrett
	private static long[] nttsb(long[] src, int n, boolean inverse, int P, int g)
	{
		long[] dst = Arrays.copyOf(src, n);
		
		int h = Integer.numberOfTrailingZeros(n);
		long K = Integer.highestOneBit(P)&lt;&lt;1;
		int H = Long.numberOfTrailingZeros(K)*2;
		long M = K*K/P;
		
		long dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);
		long[] wws = new long[1&lt;&lt;h-1];
		long[] ws = new long[1&lt;&lt;h-1];
		long w = 1;
		for(int k = 0;k &lt; 1&lt;&lt;h-1;k++){
			wws[k] = (w&lt;&lt;32)/P;
			ws[k] = w;
			w = modh(w*dw, M, H, P);
		}
		for(int i = 0;i &lt; h;i++){
			for(int j = 0;j &lt; 1&lt;&lt;i;j++){
				for(int k = 0, s = j&lt;&lt;h-i, t = s|1&lt;&lt;h-i-1;k &lt; 1&lt;&lt;h-i-1;k++,s++,t++){
					long ndsts = dst[s] + dst[t];
					if(ndsts &gt;= 2*P)ndsts -= 2*P;
					long T = dst[s] - dst[t] + 2*P;
					long Q = wws[k]*T&gt;&gt;&gt;32;
					dst[s] = ndsts;
					dst[t] = ws[k]*T-Q*P&amp;(1L&lt;&lt;32)-1;
				}
			}
//			dw = dw * dw % P;
			if(i &lt; h-1){
				for(int k = 0;k &lt; 1&lt;&lt;h-i-2;k++){
					wws[k] = wws[k*2];
					ws[k] = ws[k*2];
				}
			}
		}
		for(int i = 0;i &lt; n;i++){
			if(dst[i] &gt;= P)dst[i] -= P;
		}
		for(int i = 0;i &lt; n;i++){
			int rev = Integer.reverse(i)&gt;&gt;&gt;-h;
			if(i &lt; rev){
				long d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;
			}
		}
		
		if(inverse){
			long in = invl(n, P);
			for(int i = 0;i &lt; n;i++){
				dst[i] = modh(dst[i] * in, M, H, P);
			}
		}
		
		return dst;
	}
	
	static final long mask = (1L&lt;&lt;31)-1;
	
	public static long modh(long a, long M, int h, int mod)
	{
		long r = a-((M*(a&amp;mask)&gt;&gt;&gt;31)+M*(a&gt;&gt;&gt;31)&gt;&gt;&gt;h-31)*mod;
		return r &lt; mod ? r : r-mod;
	}
	
	private static long[] garnerPrepare(int[] m)
	{
		int n = m.length;
		assert n == m.length;
		if(n == 0)return new long[0];
		long[] gamma = new long[n];
		for(int k = 1;k &lt; n;k++){
			long prod = 1;
			for(int i = 0;i &lt; k;i++){
				prod = prod * m[i] % m[k];
			}
			gamma[k] = invl(prod, m[k]);
		}
		return gamma;
	}
	
	private static long[] garnerBatch(int[] u, int[] m, long[] gamma)
	{
		int n = u.length;
		assert n == m.length;
		long[] v = new long[n];
		v[0] = u[0];
		for(int k = 1;k &lt; n;k++){
			long temp = v[k-1];
			for(int j = k-2;j &gt;= 0;j--){
				temp = (temp * m[j] + v[j]) % m[k];
			}
			v[k] = (u[k] - temp) * gamma[k] % m[k];
			if(v[k] &lt; 0)v[k] += m[k];
		}
		return v;
	}
	
	private static long pow(long a, long n, long mod) {
		//		a %= mod;
		long ret = 1;
		int x = 63 - Long.numberOfLeadingZeros(n);
		for (; x &gt;= 0; x--) {
			ret = ret * ret % mod;
			if (n &lt;&lt; 63 - x &lt; 0)
				ret = ret * a % mod;
		}
		return ret;
	}
	
	private static long invl(long a, long mod) {
		long b = mod;
		long p = 1, q = 0;
		while (b &gt; 0) {
			long c = a / b;
			long d;
			d = a;
			a = b;
			b = d % b;
			d = p;
			p = q;
			q = d - c * q;
		}
		return p &lt; 0 ? p + mod : p;
	}
	
	public static int[][] parentToG(int[] par)
	{
		int n = par.length;
		int[] ct = new int[n];
		for(int i = 0;i &lt; n;i++){
			if(par[i] &gt;= 0){
				ct[i]++;
				ct[par[i]]++;
			}
		}
		int[][] g = new int[n][];
		for(int i = 0;i &lt; n;i++){
			g[i] = new int[ct[i]];
		}
		for(int i = 0;i &lt; n;i++){
			if(par[i] &gt;= 0){
				g[par[i]][--ct[par[i]]] = i;
				g[i][--ct[i]] = par[i];
			}
		}
		return g;
	}

	
	public static int[][] makeBuckets(int[] a, int sup)
	{
		int n = a.length;
		int[][] bucket = new int[sup+1][];
		int[] bp = new int[sup+1];
		for(int i = 0;i &lt; n;i++)bp[a[i]]++;
		for(int i = 0;i &lt;= sup;i++)bucket[i] = new int[bp[i]];
		for(int i = n-1;i &gt;= 0;i--)bucket[a[i]][--bp[a[i]]] = i;
		return bucket;
	}

	
	public static class SplitResult
	{
		public boolean[] incycle;
		public int[] ord;
	}
	
	public static SplitResult split(int[] f)
	{
		int n = f.length;
		boolean[] incycle = new boolean[n];
		Arrays.fill(incycle, true);
		int[] indeg = new int[n];
		for(int i = 0;i &lt; n;i++)indeg[f[i]]++;
		int[] q = new int[n];
		int qp = 0;
		for(int i = 0;i &lt; n;i++){
			if(indeg[i] == 0)q[qp++] = i;
		}
		for(int r = 0;r &lt; qp;r++){
			int cur = q[r];
			indeg[cur] = -9999999;
			incycle[cur] = false;
			int e = f[cur];
			indeg[e]--;
			if(indeg[e] == 0)q[qp++] = e;
		}
		for(int i = 0;i &lt; n;i++){
			if(indeg[i] == 1){
				q[qp++] = i;
			}
		}
		assert qp == n;
		SplitResult ret = new SplitResult();
		ret.incycle = incycle;
		ret.ord = q;
		return ret;
	}

	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new G2().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.230
easy
----------
PROBLEM STATEMENT:
Consider an array of integers, [expression].

Given an array of integers, find and print the minimum absolute difference between any two elements in the array.  For example, given the array [expression].

Function Description  

Complete the minimumAbsoluteDifference function in the editor below.  It should return an integer that represents the minimum absolute difference between any pair of elements.  

minimumAbsoluteDifference has the following parameter(s):  


n: an integer that represents the length of arr    
arr: an array of integers  

----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;

using namespace std;

int main(){
    int n;
    cin &gt;&gt; n;
    int a[n];
    for(int i = 0; i &lt; n; i++){
        cin &gt;&gt; a[i];
    }
    sort(a, a + n);
    int ans = 2000000001;
    for(int i = 1; i &lt; n; i++){
        if(a[i] - a[i - 1] &lt; ans){
            ans = a[i] - a[i - 1];
        }
    }
    cout &lt;&lt; ans;
}

----------
====================
----------
ALGORITHMS.231
easy
----------
PROBLEM STATEMENT:
Marc loves cupcakes, but he also likes to stay fit. Each cupcake has a calorie count, and Marc can walk a distance to expend those calories.  If Marc has eaten [expression]  miles to maintain his weight.

For example, if he eats [expression].

Given the individual calorie counts for each of the cupcakes, determine the minimum number of miles Marc must walk to maintain his weight. Note that he can eat the cupcakes in any order.  

Function Description  

Complete the marcsCakewalk function in the editor below.  It should return a long integer that represents the minimum miles necessary.  

marcsCakewalk has the following parameter(s):  


calorie: an integer array that represents calorie count for each cupcake  

----------
TOP SOLUTION:
----------

#pragma GCC optimize("O3")
#define _CRT_SECURE_NO_WARNINGS
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;

#include &lt;memory.h&gt;
#include &lt;assert.h&gt;

#define y0 sdkfaslhagaklsldk

#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd
#define have adsgagshdshfhds
#define ends asdgahhfdsfshdshfd
#define right asdashgasrhsdf

#define eps 1e-14
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 64

#define ldouble long double

using namespace std;

long long INF = 1e9;
const int N = 600031;

int n;
long long ar[N],ans;

int main(){
	//freopen("tree.in","r",stdin);
	//freopen("tree.out","w",stdout);
	//freopen("in.txt", "r", stdin);
	//freopen("out.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);

	cin&gt;&gt;n;
	for (int i=0;i&lt;n;i++)
	{
		cin&gt;&gt;ar[i];
	}
	sort(ar,ar+n);
	reverse(ar,ar+n);
	for (int i=0;i&lt;n;i++)
	{
		ans+=(1ll&lt;&lt;i)*ar[i];
	}
	cout&lt;&lt;ans&lt;&lt;endl;

	cin.get(); cin.get();
	return 0;
}

----------
====================
----------
ALGORITHMS.232
easy
----------
PROBLEM STATEMENT:
Given a square grid of characters in the range ascii[a-z], rearrange elements of each row alphabetically, ascending.  Determine if the columns are also in ascending alphabetical order, top to bottom.  Return YES if they are or NO if they are not.

For example, given:

a b c
a d e
e f g


The rows are already in alphabetical order.  The columns a a e, b d f and c e g are also in alphabetical order, so the answer would be YES.  Only elements within the same row can be rearranged.  They cannot be moved to a different row.

Function Description  

Complete the gridChallenge function in the editor below.  It should return a string, either YES or NO.  

gridChallenge has the following parameter(s):  


grid: an array of strings  

----------
TOP SOLUTION:
----------
#define _USE_MATH_DEFINES
#define _CRT_SECURE_NO_DEPRECATE

#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
#include &lt;cfloat&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;map&gt;
#include &lt;utility&gt;
#include &lt;set&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;sstream&gt;
#include &lt;complex&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;numeric&gt;
#include &lt;list&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;
#include &lt;bitset&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; Pii;
typedef pair&lt;ll, ll&gt; Pll;

#define FOR(i,n) for(int i = 0; i &lt; (n); i++)
#define sz(c) ((int)(c).size())
#define ten(x) ((int)1e##x)
#define tenll(x) ((ll)1e##x)
template&lt;class T&gt; T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }

void solve(){
	int n; cin &gt;&gt; n;
	vector&lt;string&gt; v(n);
	FOR(i, n) cin &gt;&gt; v[i];
	FOR(i, n) sort(v[i].begin(), v[i].end());
	bool b = true;
	FOR(i, n){
		string x;
		FOR(j, n) x.push_back(v[j][i]);
		string y = x;
		sort(y.begin(), y.end());
		if (x != y) {
			b = false;
		}
	}
	puts(b ? "YES" : "NO");
}

int main(){
	int t; cin &gt;&gt; t;
	while (t--) {
		solve();
	}
	return 0;
}
----------
====================
----------
ALGORITHMS.233
easy
----------
PROBLEM STATEMENT:
Lena is preparing for an important coding competition that is preceded by a number of sequential preliminary contests. Initially, her luck balance is 0. She believes in "saving luck", and wants to check her theory. Each contest is described by two integers, [expression]:


[expression].
[expression] if it's unimportant.


If Lena loses no more than [expression] important contests, what is the maximum amount of luck she can have after competing in all the preliminary contests? This value may be negative.

For example, [expression] and:

[expression]
[expression]
[expression]
[expression]



If Lena loses all of the contests, her will be [expression].  

Function Description  

Complete the luckBalance function in the editor below.  It should return an integer that represents the maximum luck balance achievable.  

luckBalance has the following parameter(s):  


k: the number of important contests Lena can lose  
contests: a 2D array of integers where each [expression] contest.  

----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define FOR(i,a,b) for(int i = (a); i &lt;= (b); ++i)
#define FORD(i,a,b) for(int i = (a); i &gt;= (b); --i)
#define RI(i,n) FOR(i,1,(n))
#define REP(i,n) FOR(i,0,(n)-1)
#define mini(a,b) a=min(a,b)
#define maxi(a,b) a=max(a,b)
#define mp make_pair
#define pb push_back
#define st first
#define nd second
#define sz(w) (int) w.size()
typedef vector&lt;int&gt; vi;
typedef long long ll;
typedef long double ld;
typedef pair&lt;int,int&gt; pii;
const int inf = 1e9 + 5;
const int nax = 1e6 + 5;



int main() {
	int n, k;
	scanf("%d%d", &amp;n, &amp;k);
	int ans = 0;
	vi w;
	REP(i, n) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		if(b == 0) ans += a;
		else w.pb(a);
	}
	sort(w.rbegin(), w.rend());
	REP(i, (int) w.size()) {
		if(i &lt; k) ans += w[i];
		else ans -= w[i];
	}
	printf("%d\n", ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.234
easy
----------
PROBLEM STATEMENT:
Given an array of stick lengths, use [expression] space-separated integers in non-decreasing order.

If there are several valid triangles having the maximum perimeter: 


Choose the one with the longest maximum side. 
If more than one has that maximum, choose from them the one with the longest minimum side. 
If more than one has that maximum as well, print any one them.


If no non-degenerate triangle exists, print -1.

For example, assume there are stick lengths [expression].  

Function Description  

Complete the maximumPerimeterTriangle function in the editor below.  It should return an array of [expression] integers that represent the side lengths of the chosen triangle in non-decreasing order.  

maximumPerimeterTriangle has the following parameter(s):  


sticks: an integer array that represents the lengths of sticks available  

----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class B {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	void solve()
	{
		int n = ni();
		int[] a = na(n);
		Arrays.sort(a);
		for(int i = n-3;i &gt;= 0;i--){
			if(a[i]+a[i+1] &gt; a[i+2]){
				out.println(a[i] + " " + a[i+1] + " " + a[i+2]);
				return;
			}
		}
		out.println(-1);
	}
	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new B().run(); }
	
	private byte[] inbuf = new byte[1024];
	private int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.235
easy
----------
PROBLEM STATEMENT:
You are given two  arrays, [expression] integers.

A pair of indices [expression]. A set containing beautiful pairs is called a beautiful set.

A beautiful set is called pairwise disjoint if for every pair [expression]. 

Your task is to change exactly [expression] so that the size of the pairwise disjoint beautiful set is maximum.

Function Description  

Complete the beautifulPairs function in the editor below.  It should return an integer that represents the maximum number of pairwise disjoint beautiful pairs that can be formed.  

beautifulPairs has the following parameters:  


A: an array of integers  
B: an array of integers  

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class Solution {
  private static InputReader in;
  private static PrintWriter out;

  public static void main(String[] args) throws IOException {
    in = new InputReader(System.in);
    out = new PrintWriter(System.out, true);

    int n = in.nextInt();
    int[] arr = new int[n];
    int[] brr = new int[n];
    int[] fa = new int[1001];
    int[] fb = new int[1001];
    for (int i = 0; i &lt; n; i++) {
      arr[i] = in.nextInt();
      fa[arr[i]]++;
    }
    for (int i = 0; i &lt; n; i++) {
      brr[i] = in.nextInt();
      fb[brr[i]]++;
    }
    int curans = 0;
    for (int i = 0; i &lt;= 1000; i++) {
      curans += Math.min(fa[i], fb[i]);
    }
    out.println(curans == n ? n-1 : (curans + 1));
    out.close();
    System.exit(0);
  }

  static class InputReader {
    public BufferedReader reader;
    public StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
      reader = new BufferedReader(new InputStreamReader(stream), 32768);
      tokenizer = null;
    }

    public String next() {
      while (tokenizer == null || !tokenizer.hasMoreTokens()) {
        try {
          tokenizer = new StringTokenizer(reader.readLine());
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
      return tokenizer.nextToken();
    }

    public int nextInt() {
      return Integer.parseInt(next());
    }
  }


}

----------
====================
----------
ALGORITHMS.236
medium
----------
PROBLEM STATEMENT:
Alice is a kindergarten teacher. She wants to give some candies to the children in her class. &nbsp;All the children sit in a line and each&nbsp;of them&nbsp;has a rating score according to his or her performance in the class. &nbsp;Alice wants to give at least 1 candy to each child. If two children sit next to each other, then the one with the higher rating must get more candies. Alice wants to minimize the total number of candies she must buy.

For example, assume her students' ratings are [4, 6, 4, 5, 6, 2].  She gives the students candy in the following minimal amounts: [1, 2, 1, 2, 3, 1].  She must buy a minimum of 10 candies.  

Function Description

Complete the candies function in the editor below.  It must return the minimum number of candies Alice must buy.  

candies has the following parameter(s):  


n: an integer, the number of children in the class  
arr: an array of integers representing the ratings of each student  

----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;string&gt;
using namespace std;

typedef long long ll;

int a[100005],b[100005];

inline int maxi(int x,int y) {
	return (x&gt;y)?x:y;
}

int main() {
int i,j,n;
ll ans;

	scanf("%d",&amp;n);
	for (i=1;i&lt;=n;++i) {
		scanf("%d",&amp;a[i]);
	}
	a[0]=a[1];
	a[n+1]=a[n];
	for (i=1;i&lt;=n;++i) {
		if ((a[i]&lt;=a[i+1]) &amp;&amp; (a[i]&lt;=a[i-1])) {
			b[i]=1;
			for (j=i-1;j &amp;&amp; (a[j]&gt;a[j+1]);--j) {
				b[j]=b[j+1]+1;
			}
			for (;i&lt;n &amp;&amp; (a[i+1]&gt;a[i]);++i) {
				b[i+1]=b[i]+1;
			}
		}
	}
	ans=0;
	for (i=1;i&lt;=n;++i) {
		if ((a[i]&gt;a[i-1]) &amp;&amp; (a[i]&gt;a[i+1])) {
			b[i]=maxi(b[i-1],b[i+1])+1;
		}
		ans+=b[i];
	}
	printf("%Ld\n",ans);
	return 0;

}
----------
====================
----------
ALGORITHMS.237
easy
----------
PROBLEM STATEMENT:
Sherlock Holmes suspects his archenemy Professor Moriarty is once again plotting something diabolical. Sherlock's companion, Dr. Watson, suggests Moriarty may be responsible for MI6's recent issues with their supercomputer, The Beast. 

Shortly after resolving to investigate, Sherlock receives a note from Moriarty boasting about infecting The Beast with a virus.  He also gives him a clue:  an integer. Sherlock determines the key to removing the virus is to find the largest Decent Number having that number of digits.

A Decent Number has the following properties:


Its digits can only be 3's and/or 5's.
The number of 3's it contains is divisible by 5.
The number of 5's it contains is divisible by 3.
It is the largest such number for its length. 


Moriarty's virus shows a clock counting down to The Beast's destruction, and time is running out fast. Your task is to help Sherlock find the key before The Beast is destroyed!

For example, the numbers [expression]'s in the second.  They are the largest values for those length numbers that have proper divisibility of digit occurrences.  

Function Description

Complete the decentNumber function in the editor below.  It should print the decent number for the given length, or [expression] if a decent number of that length cannot be formed.  

decentNumber has the following parameter(s):  


n: the integer length of the decent number to create

----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;memory.h&gt;

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash

#define  INF 100000000
#define eps 1e-8
//#define M_PI 3.141592653589793
//#define mx 1000000000000ll
#define bs 1000000007

//#define free asdfasdfsdadsg
//#define szz 400
//#define pb push_back
#define MAXN 10000
#define free afdshjioey
//#define SIZE 60
//#define bsize 250
#define clone agsdahfaassdg

using namespace std;

long tests,l,n,r;

int main(){
//freopen("line3.in","r",stdin);
//freopen("line3.out","w",stdout);
//freopen("C:/input.txt","r",stdin);
//freopen("C:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);

cin&gt;&gt;tests;
for (;tests;--tests)
{
 cin&gt;&gt;n;
 l=n;r=0;
 while ((l%3&gt;0||r%5&gt;0)&amp;&amp;l&gt;=0){--l;++r;}
 if (l&lt;0)cout&lt;&lt;-1&lt;&lt;endl;
 else
 {
     for (int i=0;i&lt;l;i++)
     cout&lt;&lt;5;
     for (int i=0;i&lt;r;i++)
     cout&lt;&lt;3;
     cout&lt;&lt;endl;
 }
}

cin.get();cin.get();
return 0;}

----------
====================
----------
ALGORITHMS.238
easy
----------
PROBLEM STATEMENT:
Priyanka works for an international toy company that ships by container.  Her task is to the determine the lowest cost way to combine her orders for shipping.  She has a list of item weights.  The shipping company has a requirement that all items loaded in a container must weigh less than or equal to 4 units plus the weight of the minimum weight item.  All items meeting that requirement will be shipped in one container.

What is the smallest number of containers that can be contracted to ship the items based on the given list of weights?

For example, there are items with weights [expression] units of the minimum weight item.  

Function Description  

Complete the toys function in the editor below.  It should return the minimum number of containers required to ship.  

toys has the following parameter(s):  


w: an array of integers that represent the weights of each order to ship  

----------
TOP SOLUTION:
----------
//priyanka-and-toys.cpp
//Priyanka and Toys
//Weekly Challenges - Week 12
//Author: derekhh

#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

int w[100000];

int main()
{
	int n;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++)
		cin &gt;&gt; w[i];
	sort(w, w + n);
	int ans = 1, prev = w[0];
	for (int i = 1; i &lt; n; i++)
		if (w[i] - prev &gt; 4)
			prev = w[i], ans++;
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
----------
====================
----------
ALGORITHMS.239
easy
----------
PROBLEM STATEMENT:
You are given an unordered array of unique integers incrementing from [expression].  You can swap any two elements a limited number of times.  Determine the largest lexicographical value array that can be created by executing no more than the limited number of swaps.  

For example, if [expression] with the other elements:  

[expression]
[expression]
[expression]



The highest value of the four (including the original) is [expression].

Function Description  

Complete the largestPermutation function in the editor below.  It must return an array that represents the highest value permutation that can be formed.  

largestPermutation has the following parameter(s):  


k: an integer that represents the limit of swaps  
arr: an array of integers  

----------
TOP SOLUTION:
----------
#!/usr/bin/env python
import sys


line = sys.stdin.readline()
tokens = line.split(" ")
N = int(tokens[0])
K = int(tokens[1])

line = sys.stdin.readline()
tokens = line.split(" ")


original = [int(elem) for elem in tokens]


sorted = list(original)

sorted.sort(reverse =True)

def permute(list,i1,i2):
		tmp = list[i1]
		list[i1] = list[i2]
		list[i2] = tmp


current = 0
while (K &gt; 0 and current&lt; (len(sorted)-1)):
	if(original[current] &lt;&gt; sorted[current]):
		permute(original,current,original.index(sorted[current]))
		K-=1
	current+=1
		

print ' '.join(map(str,original))




----------
====================
----------
ALGORITHMS.240
easy
----------
PROBLEM STATEMENT:
Mark and Jane are very happy after having their first child. Their son loves toys, so Mark wants to buy some. There are a number of different toys lying in front of him, tagged with their prices.  Mark has only a certain amount to spend, and he wants to maximize the number of toys he buys with this money.

Given a list of prices and an amount to spend, what is the maximum number of toys Mark can buy?  For example, if [expression] items.

Function Description

Complete the function maximumToys in the editor below.  It should return an integer representing the maximum number of toys Mark can purchase.  

maximumToys has the following parameter(s):  


prices:  an array of integers representing toy prices  
k:  an integer, Mark's budget

----------
TOP SOLUTION:
----------
//#pragma comment(linker,"/STACK:16777216") /*16Mb*/
//#pragma comment(linker,"/STACK:33554432") /*32Mb*/
#define _CRT_SECURE_NO_DEPRECATE
#include&lt;sstream&gt;
#include&lt;iostream&gt;
#include&lt;numeric&gt;
#include&lt;sstream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;memory&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cctype&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;deque&gt;
#include&lt;stack&gt;
#include&lt;map&gt;
#include&lt;complex&gt;
#include&lt;set&gt;
#include&lt;algorithm&gt;

using namespace std;

typedef unsigned long long      ui64;
typedef long long               i64;
typedef	vector&lt;int&gt;             VI;
typedef	vector&lt;bool&gt;            VB;
typedef	vector&lt;VI&gt;              VVI;
typedef	vector&lt;string&gt;          VS;
typedef	pair&lt;int,int&gt;           PII;
typedef map&lt;string,int&gt;         MSI;
typedef set&lt;int&gt;                SI;
typedef set&lt;string&gt;             SS;
typedef complex&lt;double&gt;         CD;
typedef vector&lt; CD &gt;            VCD;
typedef map&lt;int,int&gt;            MII;
typedef	pair&lt;double,double&gt;     PDD;

#define PB                      push_back
#define MP                      make_pair
#define X                       first
#define Y                       second
#define FOR(i, a, b)            for(int i = (a); i &lt; (b); ++i)
#define RFOR(i, a, b)           for(int i = (a) - 1; i &gt;= (b); --i)
#define CLEAR(a, b)             memset(a, b, sizeof(a))
#define SZ(a)                   int((a).size())
#define ALL(a)                  (a).begin(), (a).end()
#define RALL(a)                 (a).rbegin(), (a).rend()
#define INF                     (2000000000)

#ifdef _DEBUG
#define eprintf(...) fprintf (stderr, __VA_ARGS__)
#else
#define eprintf(...) assert (true)
#endif

const double PI = acos(-1.0);

int main() {
	int n,k;
	scanf("%d%d",&amp;n,&amp;k);
	VI a(n);
	FOR(i,0,n) {
		scanf("%d",&amp;a[i]);
	}
	
	sort(ALL(a));
	FOR(i,0,n) {
		k -= a[i];
		if(k&lt;0) {
			cout &lt;&lt; i &lt;&lt; endl;
			return 0;
		}
	}
	cout &lt;&lt; n &lt;&lt; endl;
	return 0;
}
----------
====================
----------
ALGORITHMS.241
medium
----------
PROBLEM STATEMENT:
A group of friends want to buy a bouquet of flowers.  The florist wants to maximize his number of new customers and the money he makes.  To do this, he decides he'll multiply the price of each flower by the number of that customer's previously purchased flowers plus [expression] and so on.  

Given the size of the group of friends, the number of flowers they want to purchase and the original prices of the flowers, determine the minimum cost to purchase all of the flowers.

For example, if there are [expression].  

Function Description

Complete the getMinimumCost function in the editor below.  It should return the minimum cost to purchase all of the flowers.  

getMinimumCost has the following parameter(s):


c: an array of integers representing the original price of each flower
k: an integer, the number of friends

----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;

int a[102];

int main() {
int i,j,m,n;
long long c,ans=0;
	scanf("%d%d",&amp;n,&amp;m);
	for (i=0;i&lt;n;++i) {
		scanf("%d",&amp;a[i]);
	}
	sort(a,a+n);
	for (i=n-1,c=0,j=0;i&gt;=0;--i) {
		if (j==0) {
			++c;
		}
		ans+=c*a[i];
		if (++j==m) {
			j=0;
		}
	}
	printf("%Ld\n",ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.242
medium
----------
PROBLEM STATEMENT:
You will be given a list of integers, [expression].  Unfairness of an array is calculated as

[expression]  

Where: 
- max denotes the largest integer in [expression] 
- min denotes the smallest integer in [expression]  

As an example, consider the array [expression]. 
[expression] 
Testing for all pairs, the solution [expression] provides the minimum unfairness.

Note: Integers in [expression] may not be unique. 

Function Description

Complete the maxMin function in the editor below.  It must return an integer that denotes the minimum possible value of unfairness.  

maxMin has the following parameter(s):


k:  an integer, the number of elements in the array to create
arr:  an array of integers . 

----------
TOP SOLUTION:
----------
/*
Author:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%   LALIT KUNDU      %%%%%%%% 
%%%%%%%%   IIIT HYDERABAD   %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 */
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cassert&gt;
#include&lt;sstream&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
#define pb push_back
#define mp make_pair
#define clr(x) x.clear()
#define sz(x) ((int)(x).size())
#define F first
#define S second
#define REP(i,a,b) for(i=a;i&lt;b;i++)
#define rep(i,b) for(i=0;i&lt;b;i++)
#define rep1(i,b) for(i=1;i&lt;=b;i++)
#define pdn(n) printf("%d\n",n)
#define sl(n) scanf("%lld",&amp;n)
#define sd(n) scanf("%d",&amp;n)
#define pn printf("\n")
typedef pair&lt;int,int&gt; PII;
typedef vector&lt;PII&gt; VPII;
typedef vector&lt;int&gt; VI;
typedef vector&lt;VI&gt; VVI;
typedef long long LL;
int main()
{
    vector &lt; long long  int &gt; arr;
    long long int n,i,ans=1000000000000000000LL,k;
    sl(n),sl(k);
    arr.resize(n);
    for(i=0; i&lt;n; i++)
        sl(arr[i]);
    sort(arr.begin(),arr.end());
    for(i=0; i&lt;=n-k; i++)
        if( (arr[i+k-1]-arr[i]) &lt; ans)ans=arr[i+k-1]-arr[i];
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}


----------
====================
----------
ALGORITHMS.243
easy
----------
PROBLEM STATEMENT:
Jim's Burgers has a line of hungry customers.  Orders vary in the time it takes to prepare them.  Determine the order the customers receive their orders.  Start by numbering each of the customers from [expression], front of the line to the back.  You will then be given an order number and a preparation time for each customer.   

The time of delivery is calculated as the sum of the order number and the preparation time.  If two orders are delivered at the same time, assume they are delivered in ascending customer number order.

For example, there are [expression].:

[expression]
[expression]
[expression]
[expression]
[expression]



We see that the orders are delivered to customers in the following order:

[expression]
[expression]
[expression]



Function Description  

Complete the jimOrders function in the editor below.  It should return an array of integers that represent the order that customers' orders are delivered.  

jimOrders has the following parameter(s):  


orders: a 2D integer array where each [expression].  

----------
TOP SOLUTION:
----------
n = input()
v = []

for i in range(0, n):
    a, b = map(int, raw_input().split())
    v.append((a+b, i+1))
    
print ' '.join([str(x[1]) for x in sorted(v)])
----------
====================
----------
ALGORITHMS.244
easy
----------
PROBLEM STATEMENT:
Consider two [expression].

You are given [expression] satisfying the relation above exists.  Otherwise, print NO.  

Function Description  

Complete the twoArrays function in the editor below.  It should return a string, either YES or NO.  

twoArrays has the following parameter(s):  


k: an integer  
A: an array of integers  
B: an array of integers  

----------
TOP SOLUTION:
----------
/*
 * File:      main.cpp
 * Author:    Hrayr [HarHro94]
 * Problem:
 * IDE:       Visual C++ 2012
 */
#pragma comment(linker, "/STACK:66777216")
#define _CRT_SECURE_NO_WARNINGS
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;cassert&gt;
#include &lt;iomanip&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;cmath&gt;
#include &lt;set&gt;
#include &lt;map&gt;
using namespace std;

typedef long long LL;
typedef long double LD;
#define pb push_back
#define mp make_pair
#define all(v) (v).begin(), (v).end()
#define sz(v) (int)(v).size()

const int N = 157;

int main()
{
#ifdef harhro94
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif

    int T;
    cin &gt;&gt; T;
    while (T--)
    {
        int n, x;
        cin &gt;&gt; n &gt;&gt; x;
        vector&lt;int&gt; a(n), b(n);
        for (int i = 0; i &lt; n; ++i)
            cin &gt;&gt; a[i];
        for (int i = 0; i &lt; n; ++i)
            cin &gt;&gt; b[i];
        sort(all(a));
        sort(all(b));
        reverse(all(a));
        bool f = true;
        for (int i = 0; i &lt; n; ++i)
            f &amp;= (a[i] + b[i] &gt;= x);
        puts(f ? "YES" : "NO");
    }

#ifdef harhro94
    cerr &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; "\nExecution time = " &lt;&lt; clock() / 1000.0 &lt;&lt; "s\n";
#endif
    return 0;
}
----------
====================
----------
ALGORITHMS.245
hard
----------
PROBLEM STATEMENT:
Alice gives Bob a board composed of [expression] wooden squares and asks him to find the minimum cost of breaking the board back down into its individual squares. To break the board down, Bob must make cuts along its horizontal and vertical lines. 

To reduce the board to squares, Bob makes horizontal and vertical cuts across the entire board.  Each cut has a given cost, [expression] squares is the sum of the costs of each successive cut.   

Can you help Bob find the minimum cost?  The number may be large, so print the value modulo [expression].

For example, you start with a [expression].

Function Description  

Complete the boardCutting function in the editor below.  It should return an integer.  

boardCutting has the following parameter(s):  


cost_x: an array of integers, the costs of vertical cuts  
cost_y: an array of integers, the costs of horizontal cuts  

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool compare(pair&lt;char,unsigned long long&gt; A,pair&lt;char,unsigned long long&gt; B)
{
	return A.second &gt; B.second;
}

int main()
{
	int T;
	cin&gt;&gt;T;
	for(;T--;)
	{
		int M,N,cost;
		cin&gt;&gt;M&gt;&gt;N;
		vector&lt;pair&lt;char,unsigned long long&gt; &gt; cutCost;
		for (int i = 0; i &lt; M-1; ++i)
		{
			cin&gt;&gt;cost;
			cutCost.push_back(make_pair('y',cost));
		}
		for (int i = 0; i &lt; N-1; ++i)
		{
			cin&gt;&gt;cost;
			cutCost.push_back(make_pair('x',cost));
		}
		sort(cutCost.begin(),cutCost.end(),compare);

		unsigned long long vcut = 1, hcut = 1, totalcost = 0;

		for (int i = 0; i &lt; cutCost.size(); ++i)
		{
			if(cutCost[i].first == 'y')
			{
				totalcost = (totalcost + ((vcut*cutCost[i].second)%1000000007))%1000000007;
				++hcut;
			}
			else if(cutCost[i].first == 'x')
			{
				totalcost = (totalcost + ((hcut*cutCost[i].second)%1000000007))%1000000007;
				++vcut;
			}
		}
		cout&lt;&lt;totalcost&lt;&lt;"\n";
	}   
    return 0;
}
----------
====================
----------
ALGORITHMS.246
advanced
----------
PROBLEM STATEMENT:
Given a string, [expression], we define some operations on the string as follows:


  a. [expression] 
  
  
  b. [expression] 
  
  
  c. [expression] and so on.  


Given a string [expression].

For example, [expression].  

Function Description

Complete the reverseShuffleMerge function in the editor below.  It must return the lexicographically smallest string fitting the criteria.  

reverseShuffleMerge has the following parameter(s):


s: a string

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;

char in[10005];
int L[128];
int need[128];
char ans[10005];
int ansPos;

using namespace std;

int main()
{
	scanf("%s", in);
    for(int i=0; in[i]; ++i){
        ++L[in[i]];
    }
    int len=strlen(in);
    for(int j=0; j &lt; 128; ++j)
        need[j]=L[j]/2;
    int pos=len-1;
    while(ansPos &lt; len/2){
        bool init=0;
        char best;
        int ind, i;
        for(i=pos; i &gt;= 0; --i){
            if((!init || in[i] &lt; best) &amp;&amp; need[in[i]]){
                init=1;
                best=in[i];
                ind=i;
            }
            L[in[i]]--;
            if(L[in[i]] &lt; need[in[i]])
                break;
        }
        for(; i &lt; ind; ++i){
            ++L[in[i]];
        }
        --need[best];
        ans[ansPos++]=best;
		pos=ind-1;
    }
    printf("%s", ans);
	return 0;
}


----------
====================
----------
ALGORITHMS.247
medium
----------
PROBLEM STATEMENT:
Goodland is a country with a number of evenly spaced cities along a line.  The distance between adjacent cities is [expression].

You are given a list of city data.  Cities that may contain a power plant have been labeled [expression], find the lowest number of plants that must be built such that all cities are served.  The distribution range limits supply to cities where distance is less than k.

For example, you are given [expression].  It cannot be done using the current distribution constraint.

Function Description  

Complete the pylons function in the editor below.  It should return an integer that represents the minimum number of plants required or -1 if it is not possible.  

pylons has the following parameter(s):  


k: an integer that represents distribution range  
arr: an array of integers that represent suitability as a building site  

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class B {

	BufferedReader br;
	PrintWriter out;
	StringTokenizer st;
	boolean eof;

	void solve() throws IOException {
		int n = nextInt();
		int k = nextInt();

		int[] a = new int[n];
		for (int i = 0; i &lt; n; i++) {
			a[i] = nextInt();
		}
		
		int ret = 0;
		int ptr = 0;
		while (ptr &lt; n) {
			ret++;
			int where = -1;
			for (int i = Math.max(ptr - k + 1, 0); i &lt; ptr + k &amp;&amp; i &lt; n; i++) {
				if (a[i] == 1) {
					where = i;
				}
			}
			
			if (where == -1) {
				out.println(-1);
				return;
			}
			
			ptr = where + k;
		}
		
		out.println(ret);
	}

	B() throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		solve();
		out.close();
	}

	public static void main(String[] args) throws IOException {
		new B();
	}

	String nextToken() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception e) {
				eof = true;
				return null;
			}
		}
		return st.nextToken();
	}

	String nextString() {
		try {
			return br.readLine();
		} catch (IOException e) {
			eof = true;
			return null;
		}
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
}
----------
====================
----------
ALGORITHMS.248
medium
----------
PROBLEM STATEMENT:
Quibdó in Colombia is one among the cities that receive maximum rainfall in the world.



All year round, the city is covered in clouds. The city has many towns, located on a one-dimensional line. The positions and populations of each town on the number line are known to you. 
Every cloud covers all towns located at a certain distance from it. A town is said to be in darkness if there exists at least one cloud such that the town is within the cloud's range. Otherwise, it is said to be sunny.



The city council has determined that they have enough money to remove exactly one cloud using their latest technology. Thus they want to remove the cloud such that the fewest number of people are left in darkness after the cloud is removed. What is the maximum number of people that will be in a sunny town after removing exactly one cloud?

Note: If a town is not covered by any clouds, then it is already considered to be sunny, and the population of this town must also be included in the final answer.

Complete the function maximumPeople which takes four arrays representing the populations of each town, locations of the towns, locations of the clouds, and the extents of coverage of the clouds respectively, and returns the maximum number of people that will be in a sunny town after removing exactly one cloud.
----------
TOP SOLUTION:
----------
/*
*/

//#pragma GCC optimize("O3")
#define _CRT_SECURE_NO_WARNINGS
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;

#include &lt;memory.h&gt;
#include &lt;assert.h&gt;

#define y0 sdkfaslhagaklsldk

#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd
#define have adsgagshdshfhds
#define ends asdgahhfdsfshdshfd

#define eps 1e-8
#define M_PI 3.141592653589793
#define bsize 512

#define ldouble long double
using namespace std;

#define bs 1000000007

const int N = 600031;

int tests;

int n,P[N],X[N];
vector&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt; events;
set&lt;int&gt; S;
long long m,y[N],r[N];
long long ans;

map&lt;long long, long long&gt; will_add;
map&lt;long long, long long&gt; ::iterator it;

int main(){
//	freopen("apache.in","r",stdin);
//	freopen("apache.out","w",stdout);
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
//	cin.tie(0);

	cin&gt;&gt;n;
	for (int i=1;i&lt;=n;i++){
		cin&gt;&gt;P[i];
	}

	for (int i=1;i&lt;=n;i++){
		cin&gt;&gt;X[i];
		events.push_back(make_pair(X[i],make_pair(0,i)));
	}

	cin&gt;&gt;m;
	for (int i=1;i&lt;=m;i++){
		cin&gt;&gt;y[i];
	}
	for (int i=1;i&lt;=m;i++){
		cin&gt;&gt;r[i];
		events.push_back(make_pair(y[i]-r[i],make_pair(-i,0)));
		events.push_back(make_pair(y[i]+r[i],make_pair(i,0)));
	}
	sort(events.begin(),events.end());
	for (int i=0;i&lt;events.size();i++){
		if (events[i].second.first&gt;0)// remove
		{
			int id=events[i].second.first;
			S.erase(id);
		}
		if (events[i].second.first&lt;0){ // add
			int id=-events[i].second.first;
			S.insert(id);
		}
		if (events[i].second.first==0){ // query
			int id=events[i].second.second;
			if (S.size()==0){
				ans+=P[id];
			}
			if (S.size()==1){
				int onl=(*S.begin());
				will_add[onl]+=P[id];
			}
		}
	}

	long long max_add=0;
	for (it=will_add.begin();it!=will_add.end();it++){
		max_add=max(max_add,(*it).second);
	}
	cout&lt;&lt;ans+max_add&lt;&lt;endl;

//	cin.get(); cin.get();
	return 0;
}

----------
====================
----------
ALGORITHMS.249
hard
----------
PROBLEM STATEMENT:
Chief's bot is playing an old DOS based game.  There is a row of buildings of different heights arranged at each index along a number line.  The bot starts at building [expression].  You must determine the minimum energy his bot needs at the start so that he can jump to the top of each building without his energy going below zero.  

Units of height relate directly to units of energy.  The bot's energy level is calculated as follows:  


If the bot's [expression]  
If the bot's [expression]  


For example, building heights are given as [expression], we get the following table:

botEnergy   height  delta
4               2       +2
6               3       +3
9               4       +5
14              3       +11
25              2       +23
48


That allows the bot to complete the course, but may not be the minimum starting value.  The minimum starting [expression].  

Function Description  

Complete the chiefHopper function in the editor below.  It should return an integer that represents the minimum starting [expression] that will allow completion of the course.  

chiefHopper has the following parameter(s):  


arr: an array of integers that represent building heights  

----------
TOP SOLUTION:
----------
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;limits&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
using namespace std;

#define pairii pair&lt;int, int&gt;
#define llong long long
#define pb push_back
#define sortall(x) sort((x).begin(), (x).end())
#define INFI  numeric_limits&lt;int&gt;::max()
#define INFLL numeric_limits&lt;llong&gt;::max()
#define INFD  numeric_limits&lt;double&gt;::max()
#define FOR(i,s,n) for (int (i) = (s); (i) &lt; (n); (i)++)
#define FORZ(i,n) FOR((i),0,(n))

const int MAXN = 100005;
int ar[MAXN];

void solve() {
  int n;
  scanf("%d",&amp;n);
  FORZ(i,n) scanf("%d",ar+i);
  int res = 0;
  for (int i = n-1; i &gt;= 0; i--) {
    int x = res + ar[i];
    res = x/2 + x%2;
  }
  printf("%d",res);
}

int main() {
#ifdef DEBUG
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  solve();
  return 0;
}

----------
====================
----------
ALGORITHMS.250
hard
----------
PROBLEM STATEMENT:
Watson gives Sherlock an array of integers.  Given the endpoints of an integer range, for all [expression]'s that result in that value, return the lowest one.  

For example, your array [expression] inclusive.

[expression]
[expression]
[expression]
[expression]



We look at the Min column and see the maximum of those three values is [expression].

Function Description  

Complete the sherlockAndMinimax function in the editor below.  It should return an integer as described.  

sherlockAndMinimax has the following parameters: 
- arr: an array of integers 
- p: an integer that represents the lowest value of the range for [expression] 
- q: an integer that represents the highest value of the range for [expression]  
----------
TOP SOLUTION:
----------
import java.util.Arrays;
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.InputStream;
import java.util.NoSuchElementException;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.io.IOException;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Egor Kulikov (egor@egork.net)
 */
public class Solution {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		SherlockAndMiniMax solver = new SherlockAndMiniMax();
		solver.solve(1, in, out);
		out.close();
	}
}

class SherlockAndMiniMax {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
		int count = in.readInt();
		int[] array = IOUtils.readIntArray(in, count);
		int min = in.readInt();
		int max = in.readInt();
		int best = -1;
		int at = -1;
		Arrays.sort(array);
		int candidate = Integer.MAX_VALUE;
		for (int i : array)
			candidate = Math.min(candidate, Math.abs(min - i));
		if (candidate &gt; best || candidate == best &amp;&amp; at &gt; min) {
			at = min;
			best = candidate;
		}
		candidate = Integer.MAX_VALUE;
		for (int i : array)
			candidate = Math.min(candidate, Math.abs(max - i));
		if (candidate &gt; best || candidate == best &amp;&amp; at &gt; max) {
			at = max;
			best = candidate;
		}
		for (int i = 1; i &lt; count; i++) {
			int current = (array[i] + array[i - 1]) / 2;
			if (current &lt; min || current &gt; max) {
				continue;
			}
			candidate = current - array[i - 1];
			if (candidate &gt; best || candidate == best &amp;&amp; at &gt; current) {
				at = current;
				best = candidate;
			}
		}
		out.printLine(at);
	}
}

class InputReader {

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar &gt;= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars &lt;= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c &lt; '0' || c &gt; '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public boolean isSpaceChar(int c) {
		if (filter != null)
			return filter.isSpaceChar(c);
		return isWhitespace(c);
	}

	public static boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	public interface SpaceCharFilter {
		public boolean isSpaceChar(int ch);
	}
}

class OutputWriter {
	private final PrintWriter writer;

	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
	}

	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}

	public void close() {
		writer.close();
	}

	public void printLine(int i) {
		writer.println(i);
	}
}

class IOUtils {

	public static int[] readIntArray(InputReader in, int size) {
		int[] array = new int[size];
		for (int i = 0; i &lt; size; i++)
			array[i] = in.readInt();
		return array;
	}

}


----------
====================
----------
ALGORITHMS.251
hard
----------
PROBLEM STATEMENT:
Victoria is splurging on expensive accessories at her favorite stores. Each store stocks [expression]). Assume that an item's type identifier is the same as its cost, and the store has an unlimited supply of each accessory.

Victoria wants to purchase a total of [expression] accessories according to the following rule:


  Any [expression] different types of accessories. 


For example, if [expression] distinct types of items. 

Given [expression] shopping trips, find and print the maximum amount of money that Victoria can spend during each trip; if it's not possible for Victoria to make a purchase during a certain trip, print SAD instead. You must print your answer for each trip on a new line.
----------
TOP SOLUTION:
----------
#include&lt;stdio.h&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;bitset&gt;
#include&lt;utility&gt;
#include&lt;functional&gt;
#include&lt;iomanip&gt;
#include&lt;sstream&gt;
#include&lt;ctime&gt;
#include&lt;cassert&gt;
using namespace std;
#define y0 y0z
#define y1 y1z
#define yn ynz
#define j0 j0z
#define j1 j1z
#define jn jnz
#define tm tmz
#define buli(x) (__builtin_popcountll(x))
#define bur0(x) (__builtin_ctzll(x))
#define bul2(x) (63-__builtin_clzll(x))
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define fil(a,b) memset((a),(b),sizeof(a))
#define cl(a) fil(a,0)
#define siz(x) ((int)(x).size())
#define all(x) (x).begin(),(x).end()
#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)
#define rep(i,a,b) for (int i=(a),_ed=(b);i&lt;_ed;i++)
#define per(i,a,b) for (int i=(b)-1,_ed=(a);i&gt;=_ed;i--)
#define pw(x) ((ll(1))&lt;&lt;(x))
#define upmo(a,b) (((a)=((a)+(b))%mo)&lt;0?(a)+=mo:(a))
#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)&lt;0?(a)+=mo:(a))
void getre(){int x=0;printf("%d\n",1/x);}
void gettle(){int res=1;while(1)res&lt;&lt;=1;printf("%d\n",res);}
typedef pair&lt;int,int&gt; pii;
typedef vector&lt;int&gt; vi;
typedef vector&lt;pii&gt; vpii;
template&lt;typename T,typename S&gt;inline bool upmin(T&amp;a,const S&amp;b){return a&gt;b?a=b,1:0;}
template&lt;typename T,typename S&gt;inline bool upmax(T&amp;a,const S&amp;b){return a&lt;b?a=b,1:0;}
template&lt;typename N,typename PN&gt;inline N flo(N a,PN b){return a&gt;=0?a/b:-((-a-1)/b)-1;}
template&lt;typename N,typename PN&gt;inline N cei(N a,PN b){return a&gt;0?(a-1)/b+1:-(-a/b);}
template&lt;typename N&gt;N gcd(N a,N b){return b?gcd(b,a%b):a;}
template&lt;typename N&gt;inline int sgn(N a){return a&gt;0?1:(a&lt;0?-1:0);}
#if ( ( _WIN32 || __WIN32__ ) &amp;&amp; __cplusplus &lt; 201103L)
    #define lld "%I64d"
#else
    #define lld "%lld"
#endif
inline void gn(long long&amp;x){
	int sg=1;char c;while(((c=getchar())&lt;'0'||c&gt;'9')&amp;&amp;c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');
	while((c=getchar())&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0';x*=sg;
}
inline void gn(int&amp;x){long long t;gn(t);x=t;}
inline void gn(unsigned long long&amp;x){long long t;gn(t);x=t;}
inline void gn(double&amp;x){double t;scanf("%lf",&amp;t);x=t;}
inline void gn(long double&amp;x){double t;scanf("%lf",&amp;t);x=t;}
inline void gs(char *s){scanf("%s",s);}
inline void gc(char &amp;c){while((c=getchar())&gt;126 || c&lt;33);}
inline void pc(char c){putchar(c);}
#ifdef JCVB
#define debug(...) fprintf(stderr, __VA_ARGS__)
#else
#define debug(...) 
#endif
typedef long long ll;
typedef double db;
inline ll sqr(ll a){return a*a;}
inline db sqrf(db a){return a*a;}
const int inf=0x3f3f3f3f;
const db pi=3.14159265358979323846264338327950288L;
const db eps=1e-6;
//const int mo=0;
//int qp(int a,ll b){int n=1;do{if(b&amp;1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b&gt;&gt;=1);return n;}

int d,n,l,a;


ll sum(int l,int r){
	return 1ll*(l+r)*(r-l+1)/2;
}
inline ll val(int x){
	int lef=l-(n-1);
	int num=lef/x;
	int res=lef%x;
	ll ans=sum(a-d+1-num+1,a-d+1)*x;
	ans+=(a-d+1ll-num)*res;

	ans+=sum(a-d+2,a-1)*x;
	res=n-1-x*(d-2);
	ans+=1ll*res*a;
	return ans;
}
int main()
{
#ifdef JCVB
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);
	int _time_jc=clock();
#endif
	int te;gn(te);
	while(te--){
		gn(l);gn(a);gn(n);gn(d);

		if(d==1){
			printf(lld"\n",1ll*a*l);
			continue;
		}
		if(a&lt;d){
			printf("SAD\n");
			continue;
		}
		int lef=l-(n-1);

		int l1=cei(lef,a-d+1);
		int r1=flo(n-1,d-1);
		ll ma=0;
		if(l1&gt;r1){
			printf("SAD\n");
			continue;
		}
		for (int x=l1;x&lt;=r1;x++)upmax(ma,val(x));
		//printf(lld"\n",max(val(l1),val(r1)));
		printf(lld"\n",ma);
	}
#ifdef JCVB
	debug("time: %d\n",int(clock()-_time_jc));
#endif
	return 0;
}



----------
====================
----------
ALGORITHMS.252
advanced
----------
PROBLEM STATEMENT:
For an upcoming programming contest, Roy is forming some teams from the students of his university. A team can have any number of contestants. 

Roy knows the skill level of each contestant. To make the teams work as a unit, he forms the teams based on some rules. Each of the team members must have a unique skill level for the team.  If a member's skill level is [expression]. Note that a contestant can write buggy code and thus can have a negative skill level.

The more contestants on the team, the more problems they can attempt at a time so Roy wants to form teams such that the smallest team is as large as possible.

For example, there are [expression].

Note: There is an edge case where [expression] members.
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
using namespace std;

const int NMAX = 100010;

int T, N, V[NMAX], Ans;
multiset&lt;pair&lt;int,int&gt; &gt; S;

int main()
{
   // freopen("c.in", "r", stdin);
  //  freopen("c.out", "w", stdout);

    scanf("%i", &amp;T);
    for(; T; T --)
    {
        scanf("%i", &amp;N);
        for(int i = 1; i &lt;= N; ++ i)
            scanf("%i", &amp;V[i]);

        sort(V + 1, V + N + 1);

        S.clear();
        S.insert(make_pair(V[1] - 1, 0));
        Ans = 0x3f3f3f3f;

        for(int i = 1; i &lt;= N; ++ i)
        {
            while(!S.empty() &amp;&amp; S.begin() -&gt; first &lt; V[i] - 1)
            {
                Ans = min(Ans, S.begin() -&gt; second);
                S.erase(S.begin());
            }

            if(S.empty())
                S.insert(make_pair(V[i], 1));
            else
            {
                if(S.begin() -&gt; first == V[i])
                    S.insert(make_pair(V[i], 1));
                else
                {
                    int Nr = S.begin() -&gt; second;
                    S.erase(S.begin());
                    S.insert(make_pair(V[i], Nr + 1));
                }
            }
        }

        while(!S.empty())
        {
            Ans = min(Ans, S.begin() -&gt; second);
            S.erase(S.begin());
        }

        printf("%i\n", Ans);
    }
}

----------
====================
----------
ALGORITHMS.253
hard
----------
PROBLEM STATEMENT:
Meereen is famous for its fighting pits where fighters fight each other to the death.

Initially, there are [expression] always launching the first attack. The fight ends when all the fighters on one of the teams are dead.

Assume each team always attacks optimally. Each attack is performed as follows:


The attacking team chooses a fighter from their team with strength [expression].
The chosen fighter chooses at most [expression] fighters from other team and kills all of them. 


The Great Masters don't want to see their favorite fighters fall in battle, so they want to build their teams carefully and know who will win different team matchups. They want you to perform two type of queries:


1 p x Add a new fighter with strength [expression].
2 x y Print the name of the team that would win a matchup between teams [expression]. 


Given the initial configuration of the teams and [expression] queries, perform each query so the Great Masters can plan the next fight.

Note: You are determining the team that would be the winner if the two teams fought. No fighters are actually dying in these matchups so, once added to a team, a fighter is available for all future potential matchups.
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;fstream&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i &lt; (int)(n); ++i)
#define for1(i, n) for (int i = 1; i &lt;= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i &gt;= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i &lt;= (int)(b); ++i)

using namespace std;

typedef pair&lt;int, int&gt; pii;
typedef vector&lt;int&gt; vi;
typedef vector&lt;pii&gt; vpi;
typedef vector&lt;vi&gt; vvi;
typedef long long i64;
typedef vector&lt;i64&gt; vi64;
typedef vector&lt;vi64&gt; vvi64;

template&lt;class T&gt; bool uin(T &amp;a, T b) { return a &gt; b ? (a = b, true) : false; }
template&lt;class T&gt; bool uax(T &amp;a, T b) { return a &lt; b ? (a = b, true) : false; }

const int maxn = 210000;
vi teams[maxn], same[maxn];

bool emulate(int x, int y) {
    int xi = teams[x].size() - 1, yi = teams[y].size() - 1;
    while (xi &gt;= 0 &amp;&amp; yi &gt;= 0) {
        int skip = min((same[x][xi] - 1) / teams[y][yi], (same[y][yi] - 1) / teams[x][xi]);
        uax(skip, 0);
        xi -= skip * teams[y][yi];
        yi -= skip * teams[x][xi];
        
        yi -= teams[x][xi];
        if (yi &lt; 0) break;
        xi -= teams[y][yi];
    }
    return xi &gt;= 0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout &lt;&lt; fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int n, k, q;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;
    forn(i, n) {
        int s, t;
        cin &gt;&gt; s &gt;&gt; t;
        teams[--t].pb(s);
    }
    forn(i, k) {
        sort(all(teams[i]));
        same[i].pb(0);
        for1(j, teams[i].size() - 1) {
            if (teams[i][j] != teams[i][j - 1]) same[i].pb(1);
            else same[i].pb(same[i][j - 1] + 1);
        }
    }
    forn(i, q) {
        int t;
        cin &gt;&gt; t;
        if (t == 1) {
            int p, id;
            cin &gt;&gt; p &gt;&gt; id;
            --id;
            if (!teams[id].empty() &amp;&amp; p == teams[id].back()) same[id].pb(same[id][same[id].size() - 1] + 1);
            else same[id].pb(1);
            teams[id].pb(p);
        } else {
            int x, y;
            cin &gt;&gt; x &gt;&gt; y;
            --x; --y;
            cout &lt;&lt; (emulate(x, y) ? x : y) + 1 &lt;&lt; '\n';
        }
    }

#ifdef LOCAL_DEFINE
    cerr &lt;&lt; "Time elapsed: " &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.254
medium
----------
PROBLEM STATEMENT:
Lena developed a sorting algorithm described by the following pseudocode:

[expression]
    [expression]
        [expression]
    [expression]
    [expression]
    [expression]
    [expression]
    [expression]
    	[expression]
        [expression]
            [expression]
        [expression]
        [expression]
            [expression]
        [expression]
    [expression]
    [expression]
    [expression]
    [expression]
    
    [expression]
[expression]



We consider a comparison to be any time some [expression]. 

You must solve [expression] space-separated integers; if no such array exists, print -1 instead.
----------
TOP SOLUTION:
----------
//start of jonathanirvings' template v3.0.3 (BETA)

#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long LL;
typedef pair&lt;int,int&gt; pii;
typedef pair&lt;LL,LL&gt; pll;
typedef pair&lt;string,string&gt; pss;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef vector&lt;pii&gt; vii;
typedef vector&lt;LL&gt; vl;
typedef vector&lt;vl&gt; vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,"====TESTING====\n")
  #define VALUE(x) cerr &lt;&lt; "The value of " &lt;&lt; #x &lt;&lt; " is " &lt;&lt; x &lt;&lt; endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)&lt;(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)&lt;=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)&gt;=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)&lt;=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)&lt;=(c);++(a))
#define FOREACH(a,b) for (auto &amp;(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,"%lld",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,"%lld",&amp;res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf("%s",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + ".in").c_str (), "r", stdin);
  freopen ((s + ".out").c_str (), "w", stdout);
  #endif
}

//end of jonathanirvings' template v3.0.3 (BETA)

int q;
pair&lt;LL,LL&gt; batas[100005];
int l;
LL c;

bool valid(LL x, int k)
{
  return batas[k].fi &lt;= x &amp;&amp; x &lt;= batas[k].se;
}

void solve(int st, int sz, LL rem)
{
  rem -= (sz - 1);
  // debug("\n&gt;&gt;&gt;&gt;%d %d %lld\n",st,sz,rem);
  if (sz == 0) return;
  FORN(i,1,sz)
  {
    int a = i - 1;
    int b = sz - 1 - a;
    // debug("%d %d %d %lld\n",i,a,b,rem-batas[a].fi);
    if (valid(rem - batas[a].fi, b))
    {
      printf("%d ", st + i - 1);
      solve(st, a, batas[a].fi);
      solve(st + a + 1, b, rem - batas[a].fi);
      return;
    } else if (valid(rem - batas[a].se, b))
    {
      printf("%d ", st + i - 1);
      solve(st, a, batas[a].se);
      solve(st + a + 1, b, rem - batas[a].se);
      return;
    }
  }
}

int main()
{
  batas[0] = mp(0,0);
  batas[1] = mp(0,0);
  FORN(i,2,100000)
  {
    int a = (i - 1) / 2;
    int b = (i - 1) - a;
    batas[i].se = (i - 1) + batas[i-1].se;
    batas[i].fi = (i - 1) + batas[a].fi + batas[b].fi;
  }
  // FORN(i,1,10) debug("%d %d\n",batas[i].fi,batas[i].se);
  scanf("%d",&amp;q);
  TC(q)
  {
    scanf("%d %lld",&amp;l,&amp;c);
    if (c &lt; batas[l].fi || c &gt; batas[l].se)
    {
      puts("-1");
      continue;
    }
    solve(1, l,c);
    puts("");
  }
  return 0;
}










----------
====================
----------
ALGORITHMS.255
medium
----------
PROBLEM STATEMENT:
You are working at the cash counter at a fun-fair, and you have different types of coins available to you in infinite quantities. The value of each coin is already given. Can you determine the number of ways of making change for a particular number of units using the given types of coins? 

For example, if you have [expression] units in three ways: 
[expression].

Function Description  

Complete the getWays function in the editor below.  It must return an integer denoting the number of ways to make change.  

getWays has the following parameter(s):


n: an integer, the amount to make change for  
c: an array of integers representing available denominations  

----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String tmp = br.readLine();
        tmp = tmp.replace(" ","");
        String[] coinsArr = tmp.split(",");
        int[] coins = new int[coinsArr.length];
        for (int i = 0; i &lt; coins.length;i++){
            coins[i] = Integer.parseInt(coinsArr[i]);
        }
        Arrays.sort(coins);
        int n = Integer.parseInt(br.readLine().replace(" ",""));
        System.out.println(maxCoins(n, coins));
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
    }
    private static int maxCoins(int n, int[]coins){
        int[] results = new int[n+1];
        results[0] = 1;
        for(int i=0; i&lt;coins.length; i++)
    {
       for(int j=coins[i]; j&lt;=n; j++)
       {
           results[j] += results[j - coins[i]];
       }
   }
  
    return results[n];
    }
}
----------
====================
----------
ALGORITHMS.256
medium
----------
PROBLEM STATEMENT:
Christy is interning at HackerRank. One day she has to distribute some chocolates to her colleagues. She is biased towards her friends and plans to give them more than the others. One of the program managers hears of this and tells her to make sure everyone gets the same number.

To make things difficult, she must equalize the number of chocolates in a series of operations. For each operation, she can give [expression] chocolates to all but one colleague.  Everyone who gets chocolate in a round receives the same number of pieces.  

For example, assume the starting distribution is [expression].

Given a starting distribution, calculate the minimum number of operations needed so that every colleague has the same number of chocolates. 

Function Description  

Complete the equal function in the editor below.  It should return an integer that reperesents the minimum number of operations required.  

equal has the following parameter(s):  


arr: an array of integers to equalize  

----------
TOP SOLUTION:
----------
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

int main() {
	int T;
	scanf("%d\n", &amp;T);
	
	for(int t=0; t&lt;T; t++) {
		int N;
		scanf("%d\n", &amp;N);
		int a[20000];
		
		int min = 0x7fffffff;
		for (int i=0; i&lt;N; i++) {
			scanf("%d", &amp;a[i]);
			if (a[i] &lt; min) min = a[i];
		}
		
		int min_r = 0x7fffffff;
		for( int t=-5; t &lt;= 0; t++) {
			int r = 0;
			for(int i=0; i&lt;N; i++) {
				int diff = a[i] - (min+t);
				r += diff / 5;
				diff = diff % 5;
				r += diff / 2;
				diff = diff % 2;
				r += diff;
			}
			if (r &lt; min_r) min_r = r;
		}
		printf("%d\n", min_r);
	}


    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    
    return 0;
}

----------
====================
----------
ALGORITHMS.257
medium
----------
PROBLEM STATEMENT:
Sean invented a game involving a [expression] submatrix located in the upper-left quadrant of the matrix.

Given the initial configurations for [expression] matrices, help Sean reverse the rows and columns of each matrix in the best possible way so that the sum of the elements in the matrix's upper-left quadrant is maximal.  

For example, given the matrix:

[expression]
[expression]



It is [expression]:

[expression]
[expression]



And now reverse column [expression]:

[expression]
[expression]



The maximal sum is [expression].

Function Description  

Complete the flippingMatrix function in the editor below.  It should return an integer that represents the maximum sum possible for the top [expression] matrix.  

flippingMatrix has the following parameters: 
- matrix: a [expression] array of integers  
----------
TOP SOLUTION:
----------
q = int(input())
while q &gt; 0:
    q -= 1
    
    n = int(input())
    A = []
    for i in range(2 * n):
        A += [list(map(int, input().split()))]
    
    ans = 0
    for i in range(n):
        for j in range(n):
            ans += max(A[i][j], A[2 * n - 1 - i][j], A[i][2 * n - 1 - j], A[2 * n - 1 - i][2 * n - 1 - j])
    
    print(ans)
----------
====================
----------
ALGORITHMS.258
medium
----------
PROBLEM STATEMENT:
In this challenge, you will be given an array [expression] below. 

The equation can be written:

[expression]

For example, if the array [expression].  Arrays meeting those guidelines are:

[expression]
[expression]



Our calculations for the arrays are as follows:

[expression]
[expression]



The maximum value obtained is [expression].

Function Description

Complete the cost function in the editor below.  It should return the maximum value that can be obtained.  

cost has the following parameter(s):  


B: an array of integers  

----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

#define REP(i,n) for(int i=0,_n=(n);i&lt;_n;++i)
#define FOR(i,a,b) for(int i=(a),_b=(b);i&lt;=_b;++i)
#define FORD(i,a,b) for(int i=(a),_b=(b);i&gt;=_b;--i)
#define FOREACH(it,arr) for (__typeof((arr).begin()) it=(arr).begin(); it!=(arr).end(); it++)


int n;
int b[100005];
int dp[100005][105];

int f(int x, int a) {
	if ( x == n ) return 0;
	if ( dp[x][a] != -1 ) return dp[x][a];
	int &amp;ret = dp[x][a] = 0;
	
	if ( x == 0 ) ret = max(f(x+1,1),f(x+1,b[x]));
	else ret = max(f(x+1,1)+abs(a-1),f(x+1,b[x])+abs(a-b[x]));
	
	return ret;
}

int main()
{
	int T;
	scanf( "%d", &amp;T );
	
	while ( T-- ) {
		scanf( "%d", &amp;n );
		REP(i,n) scanf( "%d", &amp;b[i] );
		

		memset(dp,-1,sizeof(dp));
		printf( "%d\n", f(0,0) );
	}

	return 0;
}

----------
====================
----------
ALGORITHMS.259
medium
----------
PROBLEM STATEMENT:
Andy wants to play a game with his little brother, Bob.  The game starts with an array of distinct integers and the rules are as follows:


Bob always plays first and the two players move in alternating turns. 
In a single move, a player chooses the maximum element currently present in the array and removes it as well as all the other elements to its right. For example, if the starting array [expression]).
The modifications made to the array during each turn are permanent, so the next player continues the game with the remaining array. The first player who is unable to make a move loses the game.


Andy and Bob play [expression] games. Given the initial array for each game, find and print the name of the winner on a new line. If Andy wins, print ANDY; if Bob wins, print BOB.

To continue the example above, in the next move Andy will remove [expression] and win because there are no more integers to remove.  

Function Description  

Complete the gamingArray function in the editor below.  It should return a string that represents the winner, either ANDY or BOB.  

gamingArray has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

int main()
{
    int Q;
    scanf("%d", &amp;Q);
    while(Q--)
    {
        int N;
        scanf("%d", &amp;N);
        int last=0, ans=0;
        for(int i=0; i&lt;N; i++)
        {
            int x;
            scanf("%d", &amp;x);
            if(x&gt;last)
                last=x, ans^=1;
        }
        if(ans==0)
            printf("ANDY\n");
        else
            printf("BOB\n");
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.260
medium
----------
PROBLEM STATEMENT:
It's New Year's Day and everyone's in line for the Wonderland rollercoaster ride! There are a number of people queued up, and each person wears a sticker indicating their initial position in the queue.  Initial positions increment by [expression] at the back.

Any person in the queue can bribe the person directly in front of them to swap positions. If two people swap positions, they still wear the same sticker denoting their original places in line. One person can bribe at most two others.  For example, if [expression].

Fascinated by this chaotic queue, you decide you must know the minimum number of bribes that took place to get the queue into its current state!

Function Description

Complete the function minimumBribes in the editor below.  It must print an integer representing the minimum number of bribes necessary, or Too chaotic if the line configuration is not possible.  

minimumBribes has the following parameter(s):


q: an array of integers  

----------
TOP SOLUTION:
----------
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.io.*;
import java.math.*;
import java.security.*;
import java.text.*; 
import java.util.*;
import java.util.regex.*;
/*
	  br = new BufferedReader(new FileReader("input.txt"));
	  pw = new PrintWriter(new BufferedWriter(new FileWriter("output.txt")));
	  br = new BufferedReader(new InputStreamReader(System.in));
	  pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
 */


public class Solution {
	private static BufferedReader br;
	private static StringTokenizer st;
	private static PrintWriter pw;

	public static void main(String[] args) throws Exception {
		br = new BufferedReader(new InputStreamReader(System.in));
		pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
		//int qq = 1;
		//int qq = Integer.MAX_VALUE;
		int qq = readInt();
		for(int casenum = 1; casenum &lt;= qq; casenum++)	{
			int n = readInt();
			ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
			for(int i = n; i &gt;= 1; i--) {
				list.add(i);
			}
			int[] want = new int[n];
			for(int i = 0; i &lt; n; i++) {
				want[i] = readInt();
			}
			int ret = 0;
			for(int curr: want) {
				if(list.get(list.size()-1) == curr) {
					list.remove(list.size()-1);
				}
				else if(list.get(list.size()-2) == curr) {
					ret++;
					list.remove(list.size()-2);
				}
				else if(list.get(list.size()-3) == curr) {
					ret+=2;
					list.remove(list.size()-3);
				}
				else {
					ret = -1000000000;
				}
			}
			if(ret &lt; 0) {
				pw.println("Too chaotic");
				continue;
			}
			pw.println(ret);
		}
		exitImmediately();
	}

	private static void exitImmediately() {
		pw.close();
		System.exit(0);
	}

	private static long readLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	private static double readDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	private static int readInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	private static String nextLine() throws IOException  {
		if(!br.ready()) {
			exitImmediately();
		}
		st = null;
		return br.readLine();
	}

	private static String nextToken() throws IOException  {
		while(st == null || !st.hasMoreTokens())  {
			if(!br.ready()) {
				exitImmediately();
			}
			st = new StringTokenizer(br.readLine().trim());
		}
		return st.nextToken();
	}
}
----------
====================
----------
ALGORITHMS.261
medium
----------
PROBLEM STATEMENT:
Your goal is to find the number of ways to construct an array such that consecutive positions contain different values.

Specifically, we want to construct an array with [expression].  

Given [expression]. 

For example, for [expression] ways, as shown here:



Complete the function countArray which takes input [expression]. Return the number of ways to construct the array such that consecutive elements are distinct. 
----------
TOP SOLUTION:
----------
/*
*/

//#pragma GCC optimize("O3")
#define _CRT_SECURE_NO_WARNINGS
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;

#include &lt;memory.h&gt;
#include &lt;assert.h&gt;

#define y0 sdkfaslhagaklsldk

#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd
#define have adsgagshdshfhds
#define ends asdgahhfdsfshdshfd

#define eps 1e-8
#define M_PI 3.141592653589793
#define bsize 512

#define ldouble long double
using namespace std;

#define bs 1000000007

const int N = 510031;

long long n,k,x;
long long dp[N][3];

int main(){
//	freopen("apache.in","r",stdin);
//	freopen("apache.out","w",stdout);
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
//	cin.tie(0);

	cin&gt;&gt;n&gt;&gt;k&gt;&gt;x;

	dp[1][(x==1)]=1;
	for (int i=2;i&lt;=n;i++){
		for (int j=0;j&lt;=1;j++){
			for (int nw=0;nw&lt;=1;nw++){
				long long ways;
				if (j==1&amp;&amp;nw==1)
					ways=0;
				if (j==1&amp;&amp;nw==0)
					ways=k-1;
				if (j==0&amp;&amp;nw==1)
					ways=1;
				if (j==0&amp;&amp;nw==0)
					ways=max(0ll,k-2);
				dp[i][nw]=(dp[i][nw]+dp[i-1][j]*ways)%bs;
			}
		}
	}

	cout&lt;&lt;dp[n][1]&lt;&lt;endl;

//	cin.get(); cin.get();
	return 0;
}

----------
====================
----------
ALGORITHMS.262
medium
----------
PROBLEM STATEMENT:
Here's a humerus joke:


  Why did Papyrus the skeleton go to the store by himself? Because he had no body to go with him!


Did you like it? Don't worry, I've got a ton more. A skele-ton.

Once upon a time, Papyrus the skeleton went to buy some pasta from the store. The store's inventory is bare-bones and they only sell one thing — boxes of uncooked spaghetti! The store always stocks exactly [expression] sticks. Because they only stock one box of each kind, the store has a tendon-cy to sell out of spaghetti.

During each trip to the store, Papyrus likes to buy exactly [expression] boxes (no more, no less). Not sure which boxes to purchase, Papyrus calls Sherlock Bones for help but he's also stumped! Do you have the guts to solve this puzzle?

Given the values of [expression] boxes, print -1 instead.

For example, Papyrus wants to purchase [expression] and other combinations.  Any of the combinations will work. 

Function Description  

Complete the bonetrousle function in the editor below.  It should return an array of integers.  

bonetrousle has the following parameter(s):  


n: the integer number of sticks to buy  
k: the integer number of box sizes the store carries    
b: the integer number of boxes to buy  

----------
TOP SOLUTION:
----------

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class E {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	void solve()
	{
		for(int T = ni();T &gt; 0;T--){
			long n = nl(), K = nl(), b = nl();
			long I = 5000000000000000000L;
			long inf = b*(b+1)/2;
			long sup = 0;
			for(int i = 0;i &lt; b;i++){
				sup += K-i;
				if(sup &gt;= I)sup = I;
			}
			if(n &lt; inf || n &gt; sup){
				out.println(-1);
			}else{
				for(int i = 0;i &lt; b;i++){
					long linf = (b-i-1)*(b-i)/2;
					long can = Math.min(K-i, n-linf);
					n -= can;
					if(i &gt; 0)out.print(" ");
					out.print(can);
				}
				out.println();
			}
		}
	}
	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new E().run(); }
	
	private byte[] inbuf = new byte[1024];
	private int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.263
medium
----------
PROBLEM STATEMENT:
King Arthur has a large kingdom that can be represented as a tree, where nodes correspond to cities and edges correspond to the roads between cities. The kingdom has a total of [expression]. 

The King wants to divide his kingdom between his two children, Reggie and Betty, by giving each of them [expression] or more cities; however, they don't get along so he must divide the kingdom in such a way that they will not invade each other's cities. The first sibling will invade the second sibling's city if the second sibling has no other cities directly connected to it. For example, consider the kingdom configurations below:



Given a map of the kingdom's [expression].
----------
TOP SOLUTION:
----------
#ifndef __clang__
#pragma GCC optimize "-O3"
#pragma GCC target "tune=native"
#endif
#ifdef ONLINE_JUDGE
#define NDEBUG 1
#endif
#include &lt;stdio.h&gt;
#include &lt;bits/stdc++.h&gt;

#define DESTRUCT2(p, a, b)                      \
  auto a = get&lt;0&gt;(p);                           \
  auto b = get&lt;1&gt;(p);

#define DESTRUCT3(p, a, b, c)                   \
  auto a = get&lt;0&gt;(p);                           \
  auto b = get&lt;1&gt;(p);                           \
  auto c = get&lt;2&gt;(p);

#define DESTRUCT4(p, a, b, c, d)                \
  auto a = get&lt;0&gt;(p);                           \
  auto b = get&lt;1&gt;(p);                           \
  auto c = get&lt;2&gt;(p);                           \
  auto d = get&lt;3&gt;(p);

#define FOR(i, n)     for(lli i = 0; i &lt; (lli)(n); ++i)
#define FORU(i, j, k) for(lli i = (j); i &lt;= (lli)(k); ++i)
#define FORD(i, j, k) for(lli i = (j); i &gt;= (lli)(k); --i)

#define SQ(x) ((x)*(x))

#define all(x) begin(x), end(x)
#define rall(x) rbegin(x), rend(x)
#define mp make_pair
#define mt make_tuple
#define pb push_back
#define eb emplace_back

using namespace std;

template&lt;typename... As&gt;
struct tpl : public std::tuple&lt;As...&gt; {
  using std::tuple&lt;As...&gt;::tuple;

  template&lt;typename T = tuple&lt;As...&gt; &gt;
  typename tuple_element&lt;0, T&gt;::type const&amp;
  x() const { return get&lt;0&gt;(*this); }
  template&lt;typename T = tuple&lt;As...&gt; &gt;
  typename tuple_element&lt;0, T&gt;::type&amp;
  x() { return get&lt;0&gt;(*this); }

  template&lt;typename T = tuple&lt;As...&gt; &gt;
  typename tuple_element&lt;1, T&gt;::type const&amp;
  y() const { return get&lt;1&gt;(*this); }
  template&lt;typename T = tuple&lt;As...&gt; &gt;
  typename tuple_element&lt;1, T&gt;::type&amp;
  y() { return get&lt;1&gt;(*this); }

  template&lt;typename T = tuple&lt;As...&gt; &gt;
  typename tuple_element&lt;2, T&gt;::type const&amp;
  z() const { return get&lt;2&gt;(*this); }
  template&lt;typename T = tuple&lt;As...&gt; &gt;
  typename tuple_element&lt;2, T&gt;::type&amp;
  z() { return get&lt;2&gt;(*this); }

  template&lt;typename T = tuple&lt;As...&gt; &gt;
  typename tuple_element&lt;3, T&gt;::type const&amp;
  w() const { return get&lt;3&gt;(*this); }
  template&lt;typename T = tuple&lt;As...&gt; &gt;
  typename tuple_element&lt;3, T&gt;::type&amp;
  w() { return get&lt;3&gt;(*this); }
};

using lli   = long long int;
using llu   = long long unsigned;

using pii   = tpl&lt;lli, lli&gt;;
using piii  = tpl&lt;lli, lli, lli&gt;;
using piiii = tpl&lt;lli, lli, lli, lli&gt;;
using vi    = vector&lt;lli&gt;;
using vii   = vector&lt;pii&gt;;
using viii  = vector&lt;piii&gt;;
using vvi   = vector&lt;vi&gt;;
using vvii  = vector&lt;vii&gt;;
using vviii = vector&lt;viii&gt;;

template&lt;class T&gt;
using min_queue = priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt; &gt;;
template&lt;class T&gt;
using max_queue = priority_queue&lt;T&gt;;

template&lt;size_t... I&gt;
struct my_index_sequence {
  using type = my_index_sequence;
  static constexpr array&lt;size_t, sizeof...(I)&gt; value = { {I...} };
};

namespace my_index_sequence_detail {
  template&lt;typename I, typename J&gt; struct concat;
  template&lt;size_t... I, size_t... J&gt;
  struct concat&lt;my_index_sequence&lt;I...&gt;, my_index_sequence&lt;J...&gt; &gt; :
    my_index_sequence&lt;I..., (sizeof...(I)+J)...&gt; { };
  template&lt;size_t N&gt; struct make_index_sequence :
    concat&lt;typename make_index_sequence&lt;N/2&gt;::type, typename make_index_sequence&lt;N-N/2&gt;::type&gt;::type { };
  template &lt;&gt; struct make_index_sequence&lt;0&gt; : my_index_sequence&lt;&gt;{};
  template &lt;&gt; struct make_index_sequence&lt;1&gt; : my_index_sequence&lt;0&gt;{};
}

template&lt;class... A&gt;
using my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence&lt;sizeof...(A)&gt;::type;

template&lt;class T, size_t... I&gt;
void print_tuple(ostream&amp; s, T const&amp; a, my_index_sequence&lt;I...&gt;){
  using swallow = int[];
  (void)swallow{0, (void(s &lt;&lt; (I == 0? "" : ", ") &lt;&lt; get&lt;I&gt;(a)), 0)...};
}

template&lt;class T&gt;
ostream&amp; print_collection(ostream&amp; s, T const&amp; a);
template&lt;class... A&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; s, tpl&lt;A...&gt; const&amp; a);
template&lt;class... A&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; s, tuple&lt;A...&gt; const&amp; a);
template&lt;class A, class B&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; s, pair&lt;A, B&gt; const&amp; a);

template&lt;class T, size_t I&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; s, array&lt;T, I&gt; const&amp; a) { return print_collection(s, a); }
template&lt;class T&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; s, vector&lt;T&gt; const&amp; a) { return print_collection(s, a); }
template&lt;class T, class U&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; s, multimap&lt;T, U&gt; const&amp; a) { return print_collection(s, a); }
template&lt;class T&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; s, multiset&lt;T&gt; const&amp; a) { return print_collection(s, a); }
template&lt;class T, class U&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; s, map&lt;T, U&gt; const&amp; a) { return print_collection(s, a); }
template&lt;class T&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; s, set&lt;T&gt; const&amp; a) { return print_collection(s, a); }

template&lt;class T&gt;
ostream&amp; print_collection(ostream&amp; s, T const&amp; a){
  s &lt;&lt; '[';
  for(auto it = begin(a); it != end(a); ++it){
    s &lt;&lt; *it;
    if(it != prev(end(a))) s &lt;&lt; " ";
  }
  return s &lt;&lt; ']';
}

template&lt;class... A&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; s, tpl&lt;A...&gt; const&amp; a){
  s &lt;&lt; '(';
  print_tuple(s, a, my_index_sequence_for&lt;A...&gt;{});
  return s &lt;&lt; ')';
}

template&lt;class... A&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; s, tuple&lt;A...&gt; const&amp; a){
  s &lt;&lt; '(';
  print_tuple(s, a, my_index_sequence_for&lt;A...&gt;{});
  return s &lt;&lt; ')';
}

template&lt;class A, class B&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; s, pair&lt;A, B&gt; const&amp; a){
  return s &lt;&lt; "(" &lt;&lt; get&lt;0&gt;(a) &lt;&lt; ", " &lt;&lt; get&lt;1&gt;(a) &lt;&lt; ")";
}

namespace std {
  namespace {
    template &lt;class T&gt;
    inline void hash_combine(size_t&amp; seed, T const&amp; v) {
      seed ^= hash&lt;T&gt;()(v) + 0x9e3779b9 + (seed&lt;&lt;6) + (seed&gt;&gt;2);
    }
    template &lt;class Tuple, size_t Index = tuple_size&lt;Tuple&gt;::value - 1&gt;
    struct HashValueImpl {
      static void apply(size_t&amp; seed, Tuple const&amp; tuple) {
        HashValueImpl&lt;Tuple, Index-1&gt;::apply(seed, tuple);
        hash_combine(seed, get&lt;Index&gt;(tuple));
      }
    };
    template &lt;class Tuple&gt;
    struct HashValueImpl&lt;Tuple, 0&gt; {
      static void apply(size_t&amp; seed, Tuple const&amp; tuple) {
        hash_combine(seed, get&lt;0&gt;(tuple));
      }
    };
  }
  template &lt;typename ... TT&gt;
  struct hash&lt;tuple&lt;TT...&gt;&gt; {
    size_t operator()(tuple&lt;TT...&gt; const&amp; tt) const {
      size_t seed = 0;
      HashValueImpl&lt;tuple&lt;TT...&gt; &gt;::apply(seed, tt);
      return seed;
    }
  };
  template &lt;typename ... TT&gt;
  struct hash&lt;tpl&lt;TT...&gt;&gt; {
    size_t operator()(tpl&lt;TT...&gt; const&amp; tt) const {
      size_t seed = 0;
      HashValueImpl&lt;tuple&lt;TT...&gt; &gt;::apply(seed, tt);
      return seed;
    }
  };
}

lli read_positive(){
  char c; lli x=0;
  do { c = getchar(); } while(c&lt;'0' || c&gt;'9');
  while(c&gt;='0'&amp;&amp;c&lt;='9') {
    x=10*x+(c-'0');
    c = getchar();
  }
  return x;
}

//------------------------------------------------------------------------------

// --- BEGIN SNIPPET MODULAR ---

const lli MOD = 1e9+7;

inline lli fexp(lli a, lli b) {
  lli r = 1;
  while(b){
    if(b&amp;1) r = (r*a)%MOD;
    a = (a*a)%MOD;
    b /= 2;
  }
  return r;
}

inline lli invmod(lli a) {
  return fexp(a, MOD-2);
}

// --- END SNIPPET MODULAR ---

const int N=1e5;
lli ans0[N], ans1[N];

int main(){
  ios::sync_with_stdio(0); cin.tie(0);
  int n; cin &gt;&gt; n;
  vvi G(n);
  FOR(i,n-1) {
    int u,v; cin&gt;&gt;u&gt;&gt;v;
    --u; --v;
    G[u].pb(v);
    G[v].pb(u);
  }
  function&lt;void(int,int)&gt; dfs = [&amp;](int i, int p) {
    for(auto j : G[i]) if(j!=p) dfs(j,i);
    ans0[i]=1;
    ans1[i]=1;
    for(auto j : G[i]) if(j!=p) {
        (ans0[i] *= (ans0[j]+ans1[j])) %= MOD;
        (ans1[i] *= (ans1[j])) %= MOD;
      }
    ans1[i] = (ans0[i]+MOD-ans1[i])%MOD;
  };
  dfs(0,-1);
  cout &lt;&lt; (2*ans1[0])%MOD &lt;&lt; endl;
  return 0;
}

----------
====================
----------
ALGORITHMS.264
hard
----------
PROBLEM STATEMENT:
This challenge uses the famous KMP algorithm. It isn't really important to understand how KMP works, but you should understand what it calculates.

A KMP algorithm takes a string, [expression].

Here is an implementation example of KMP:

[expression]
[expression]
    [expression]
    [expression]
        [expression]
    [expression]
    [expression]
        [expression]
    [expression]
    [expression]
        [expression]
    [expression]
[expression]



Given a sequence [expression], that meets the following conditions:


The frequency of letter '[expression], and so on.
Let's assume characters of [expression] is minimal.


If there are multiple strings which fulfill the above conditions, print the lexicographically smallest one.
----------
TOP SOLUTION:
----------
#include &lt;stdexcept&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;cassert&gt;
#include &lt;cstring&gt;
#include &lt;cstdarg&gt;
#include &lt;cstdio&gt;
#include &lt;memory&gt;
#include &lt;random&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;complex&gt;
#include &lt;numeric&gt;
#include &lt;limits&gt;
#include &lt;bitset&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;deque&gt;
#include &lt;array&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using namespace std;

#define all(a) (a).begin(), (a).end()
#define sz(a) static_cast&lt;int&gt;((a).size())
#define FOR(i, a, b) for (int i(a), b_(b); i &lt; b_; ++i)
#define REP(i, n) FOR (i, 0, n)
#define FORD(i, a, b) for (int i(a), b_(b); i &gt;= b_; --i)
#define UNIQUE(a) sort(all(a)), (a).erase(unique(all(a)), (a).end())
#define CL(a, v) memset(a, v, sizeof a)
#define eb emplace_back
#define pb push_back
#define X first
#define Y second

typedef long long ll;
typedef long double ld;
typedef vector&lt;int&gt; vi;
typedef pair&lt;int, int&gt; pii;
template &lt;class T&gt; using min_queue = priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt;;

const int INF = static_cast&lt;int&gt;(1e9);
const long long INF_LL = static_cast&lt;long long&gt;(4e18);
const double pi = acos(-1.0);

template &lt;class T&gt; T&amp; smin(T&amp; x, const T&amp; y) { if (x &gt; y) x = y; return x; }
template &lt;class T&gt; T&amp; smax(T&amp; x, const T&amp; y) { if (x &lt; y) x = y; return x; }
template &lt;class T&gt; T sqr(const T&amp; x) { return x * x; }

template &lt;class T&gt; T gcd(T a, T b) {
  for (a = abs(a), b = abs(b); a &amp;&amp; b; a &gt;= b ? a %= b : b %= a);
  return a + b;
}

template &lt;typename Iterator&gt;
void print(const char* format, Iterator first, Iterator last,
           const char* delimiter = " ", const char* closing = "\n") {
  for (; first != last; ++first != last ? printf("%s", delimiter) : 0)
    printf(format, *first);
  printf("%s", closing);
}

const int A = 26;
int x[A];
string ans;

int main() {
  cin.tie(NULL);
  //ios_base::sync_with_stdio(false);
#ifdef LocalHost
  freopen("input.txt", "r", stdin);
  //freopen("output.txt", "w", stdout);
#endif

  int n = 0;
  REP(i, A) scanf("%d", x+i), n += x[i];
  ans.reserve(n);
  int a = 0;
  while (x[a] == 0) ++a;
  int u = a;
  REP(i, A) if (x[i] &gt; 0 &amp;&amp; x[i] &lt; x[u]) u = i;
  ans += 'a' + u;
  --x[u];
  --n;
  if (a == u &amp;&amp; x[u] &gt; 0 &amp;&amp; x[u] &lt;= n - x[u] + 1) {
    ans += u + 'a';
    --x[u];
    ++a;
    while (x[u] &gt; 0) {
      while (x[a] == 0) ++a;
      ans += a + 'a';
      ans += u + 'a';
      --x[a];
      --x[u];
    }
  }
  REP(i, A) ans += string(x[i], i + 'a');

  printf("%s\n", ans.c_str());

#ifdef LocalHost
  cerr &lt;&lt; endl &lt;&lt; endl &lt;&lt; static_cast&lt;double&gt;(clock()) / CLOCKS_PER_SEC &lt;&lt; endl;
#endif
  return 0;
}

----------
====================
----------
ALGORITHMS.265
medium
----------
PROBLEM STATEMENT:
Samantha and Sam are playing a numbers game.  Given a number as a string, no leading zeros, determine the sum of all integer values of substrings of the string.  For example, if the string is [expression].

Given an integer as a string, sum all of its substrings cast as integers.  As the number may become large, return the value modulo [expression].  

Function Description

Complete the substrings function in the editor below.  It should return the sum of the integer values of all substrings in a string representation of a number, modulo [expression].  

substrings has the following parameter(s):  


n: the string representation of an integer  

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;

#define MOD 1000000007

int main() {
	char num[200005];
	gets(num);
	int len = strlen(num);
	long long factor = 1, ans = 0;

	for (int i = len-1; i &gt;= 0; --i) {
		long long tmp = (num[i]-'0') * (i+1) * factor % MOD;
		ans += tmp;
		ans %= MOD;
		factor = (factor * 10 + 1) % MOD;
	}
	printf("%d\n", ans);

	return 0;
}
----------
====================
----------
ALGORITHMS.266
hard
----------
PROBLEM STATEMENT:
You are given an integer [expression] is beautiful if and only if:


[expression]
[expression]
Let [expression].


The third condition means that all [expression].

Given [expression].
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; static void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; static void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

int main() {
	int N;
	while(~scanf("%d", &amp;N)) {
		int K = 2 * N / 3;
		while((K + 1) + (K + 1) / 2 &lt;= N + 1) ++ K;
		//i0..N-i
		int P = K + (K % 2 == 0);
		vector&lt;int&gt; pos(P);
		int t = P / 2;
		rep(i, P)
			pos[i] = i % 2 == 0 ? P - 1 - i / 2 : t - 1 - i / 2;
		if(K % 2 == 0) {
			rep(i, P) {
				if(pos[i] &gt; N - i) {
					pos.erase(pos.begin() + i);
					break;
				}
			}
		}
		vector&lt;bool&gt; vis(N * 2 + 1, false);
		bool ok = true;
		rep(i, K) {
			ok &amp;= 0 &lt;= pos[i] &amp;&amp; pos[i] &lt;= N - i;
			ok &amp;= !vis[i + pos[i]];
			vis[i + pos[i]] = true;
		}
		if(!ok) { cerr &lt;&lt; "not ok" &lt;&lt; endl; return 1; }
		printf("%d\n", K);
		rep(i, K)
			printf("%d %d %d\n", i, pos[i], N - i - pos[i]);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.267
medium
----------
PROBLEM STATEMENT:
We define a modified Fibonacci sequence using the following definition:


  Given terms [expression] is computed using the following relation:
  [expression]      


For example, if [expression],  


[expression],  
[expression],  
[expression],  
and so on.  


Given three integers, [expression] term of a modified Fibonacci sequence.

Function Description  

Complete the fibonacciModified function in the editor below.  It must return the [expression] number in the sequence.  

fibonacciModified has the following parameter(s):  


t1: an integer  
t2: an integer  
n: an integer  


Note: The value of [expression]-bit integer. Many submission languages have libraries that can handle such large results but, for those that don't (e.g., C++), you will need to compensate for the size of the result.
----------
TOP SOLUTION:
----------
# Enter your code here. Read input from STDIN. Print output to STDOUT
a,b,n = map(int,raw_input().split())
for i in range(3,n+1):
    c = b*b + a
    a,b = b,c
print c
----------
====================
----------
ALGORITHMS.268
hard
----------
PROBLEM STATEMENT:
Range Minimum Query is a well-known problem: given an array of distinct integers with size [expression].

One of the most efficient and famous solutions to this problem is a segment tree. A segment tree is a full binary tree with [expression] nodes where the leaves contain the values of the original array and each non-leaf node contains the minimum value of its entire subtree.

Usually, a segment tree is represented as an array of integers with [expression] (which corresponds to the minimum value in that node's subtree):



You've just used [expression] space-separated integers denoting the array's original values. If there are several possible original arrays, print the lexicographically smallest one.
----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;

#define int long long
typedef vector&lt;int&gt;vint;
typedef pair&lt;int,int&gt;pint;
typedef vector&lt;pint&gt;vpint;
#define rep(i,n) for(int i=0;i&lt;(n);i++)
#define reps(i,f,n) for(int i=(f);i&lt;(n);i++)
#define all(v) (v).begin(),(v).end()
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define pb push_back
#define fi first
#define se second
template&lt;typename A,typename B&gt;inline void chmin(A &amp;a,B b){if(a&gt;b)a=b;}
template&lt;typename A,typename B&gt;inline void chmax(A &amp;a,B b){if(a&lt;b)a=b;}

const int INF=1001001001001001001ll;
int N;
priority_queue&lt;int,vint,greater&lt;int&gt;&gt;cand[20];
int A[1&lt;&lt;19];
signed main(){
    scanf("%lld",&amp;N);
    map&lt;int,int&gt;mp;
    rep(i,2*N-1){
        int a;
        scanf("%lld",&amp;a);
        mp[a]++;
    }

    vpint vec;
    each(it,mp)vec.pb(*it);
    fill_n(A,1&lt;&lt;19,INF);
    if(vec.size()!=N||vec[0].se&gt;=20||(1&lt;&lt;vec[0].se)!=N*2){
        puts("NO");
        return 0;
    }
    cand[vec[0].se].push(0);

    rep(i,N){
        int t=vec[i].se;
        if(t&gt;=20){
            puts("NO");
            return 0;
        }
        while(cand[t].size()&amp;&amp;A[cand[t].top()]!=INF)cand[t].pop();
        if(cand[t].size()==0){
            puts("NO");
            return 0;
        }
        int k=cand[t].top();cand[t].pop();
        while(true){
            A[k]=vec[i].fi;
            if(k&gt;=N-1)break;
            t--;
            cand[t].push(k*2+2);
            k=k*2+1;
        }
    }

    puts("YES");
    rep(i,2*N-1){
        if(i)printf(" ");
        printf("%lld",A[i]);
    }
    puts("");
    return 0;
}

----------
====================
----------
ALGORITHMS.269
medium
----------
PROBLEM STATEMENT:
You can perform the following operations on the string, [expression]:  


Capitalize zero or more of [expression]'s lowercase letters.
Delete all of the remaining lowercase letters in [expression].


Given two strings, [expression] as described. If so, print YES on a new line.  Otherwise, print NO.

For example, given [expression], matching is not possible because letters may only be capitalized or discarded, not changed.

Function Description

Complete the function [expression].

abbreviation has the following parameter(s):


a: the string to modify  
b: the string to match  

----------
TOP SOLUTION:
----------
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cassert&gt;
#include &lt;ctime&gt;
#include &lt;map&gt;
#include &lt;math.h&gt;
#include &lt;cstdio&gt;
#include &lt;set&gt;
#include &lt;deque&gt;
#include &lt;memory.h&gt;
#include &lt;queue&gt;

#pragma comment(linker, "/STACK:64000000")
typedef long long ll;

using namespace std;

const int MAXN = -1;
const int MOD = 1; // 1000 * 1000 * 1000 + 7;
const int INF = (int)(1e9);

int main() {
#ifdef _MSC_VER
	freopen("input.txt", "r", stdin);
#endif

	int T;
	cin &gt;&gt; T;
	while (T--) {
		string a, b;
		cin &gt;&gt; a &gt;&gt; b;
		int n = a.length();
		int m = b.length();
		
		vector&lt;vector&lt;char&gt; &gt; dp(n + 1, vector&lt;char&gt;(m + 1));
		dp[0][0] = 1;
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt;= m; j++) {
				if (!dp[i][j]) continue;

				if (a[i] &gt;= 'a' &amp;&amp; a[i] &lt;= 'z') dp[i + 1][j] = 1;
				if (a[i] &gt;= 'A' &amp;&amp; a[i] &lt;= 'Z' &amp;&amp; j &lt; m &amp;&amp; a[i] == b[j]) {
					dp[i + 1][j + 1] = 1;
				}

				if (a[i] &gt;= 'a' &amp;&amp; a[i] &lt;= 'z' &amp;&amp; j &lt; m &amp;&amp; a[i] - 'a' == b[j] - 'A') {
					dp[i + 1][j + 1] = 1;
				}
			}
		}
		cout &lt;&lt; (dp[n][m] ? "YES" : "NO") &lt;&lt; endl;
	}

	return 0;
}
----------
====================
----------
ALGORITHMS.270
expert
----------
PROBLEM STATEMENT:
Consider an array, [expression] integers. We define the following terms:


Subsequence 
A subsequence of [expression] without changing the order of the remaining elements. Note that a subsequence may have zero elements, and this is called the empty subsequence.
Strictly Increasing Subsequence 
A non-empty subsequence is strictly increasing if every element of the subsequence is larger than the previous element. 
Subarray 
A subarray of [expression].


The diagram below shows all possible subsequences and subarrays of [expression]: 



We define the following functions:


[expression]
[expression]
[expression]


We define the goodness, [expression] to be:

[expression]

In other words, [expression]. 

Let [expression], then print these respective answers as space-separated integers on a single line.
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cassert&gt;
#include &lt;numeric&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
using namespace std;

#ifdef LOCAL
	#define eprintf(...) fprintf(stderr, __VA_ARGS__)
#else
	#define eprintf(...) 42
#endif

typedef long long int int64;


const int N = (int) 2e5 + 100;
int a[N];
int sum[N];

int stPos[N];
int stSz = 0;

const int VAL = 41;
int sm[N][VAL];
bool skip[N];

int nxt[N][VAL];

int lst[N][VAL];
int lstSz[N];

int mxSum[N];
int mxBef[N];
int X = 100;

int n;

void updateBef(int v, int val)
{
	while (mxBef[v] &lt; val)
	{
		mxBef[v] = val;
		v++;
	}
}

void update(int v, int ssum)
{
	if (a[v] &lt;= 0) return;

	mxSum[v] = ssum + a[v] ;

	for (int i = 0; i &lt; lstSz[v]; i++)
	{
		int nx = lst[v][i];
		int nxpos = nxt[v][nx];
		if (mxSum[nxpos] &lt; nx + mxSum[v] )	
			update(nxpos, mxSum[v] );
	}
	updateBef(v, mxSum[v] );
}


int T = 0;


int alt()
{
	mxSum[n] = X;
	mxBef[n] = X;
	for (int i = 0; i &lt; VAL; i++)
		nxt[n][i] = n;
	for (int i = n - 1; i &gt;= 0; i--)
	{
		for (int j = 0; j &lt; VAL; j++)
			nxt[i][j] = nxt[i + 1][j];
		if (a[i] &lt;= 0) continue;
		nxt[i][a[i] ] = i;

		int mn = n;
		for (int j = a[i] + 1; j &lt; VAL; j++)
		{
			if (nxt[i][j] &lt; mn)
			{
				mn = nxt[i][j];
				lst[i][lstSz[i]++] = j;
			}
			reverse(lst[i], lst[i] + lstSz[i] );
		}
	}

	int ans = 0;
	int len = 1;
	int cnt = n;
	for (int i = n; i &gt; 0; i--)
	{
		while (stSz &gt; 0 &amp;&amp; sum[stPos[stSz - 1] ] &lt;= sum[i] )
			stSz--;
		if (stSz == 0 || sum[i] &gt;= sum[stPos[stSz - 1] ] - X)
		{
			stPos[stSz] = i;
			stSz++;
		}

		update(i - 1, 0);

		for (int j = 0; j &lt; stSz; j++)
		{
			int pos = stPos[j];
			int cur = sum[pos] - sum[i - 1] - mxBef[pos - 1];
			int curLen = pos - (i - 1) + 1;
			if (cur == 0) continue;
			if (cur &gt; ans || (cur == ans &amp;&amp; curLen &lt; len) )
			{
				ans = cur;
				len = curLen;
				cnt = 0;
			}
			if (cur == ans &amp;&amp; curLen == len)
				cnt++;
		}
	}
	printf("%d %d\n", ans, cnt);




	return 0;
}

int main(int,  char **)
{
#ifdef LOCAL
	freopen("input.txt", "r", stdin);
//	freopen("output.txt", "w", stdout);
#endif

	int H = 0;

	scanf("%d", &amp;n);
	for (int i = 0; i &lt; n; i++)
	{
		scanf("%d", &amp;a[i] );
		H ^= a[i];

		if (a[i] &gt; 0)
			X = max(X, a[i] * (a[i] + 1) / 2 + a[i] + 1);
		sum[i + 1] = sum[i] + a[i];
	}

	if (n &lt; 1e4) T = 1;
	if (H % 4 == 2) T = 1;

	if (T == 0)
	{
		H ^= n;
		if (H % 3 != 0)
		{
			alt();
			return 0;
		}
	}


	int ans = 0;
	int len = 1;
	int cnt = n;
	for (int i = n; i &gt; 0; i--)
	{
		while (stSz &gt; 0 &amp;&amp; sum[stPos[stSz - 1] ] &lt;= sum[i] )
			stSz--;
		if ( (stSz == 0 || sum[i] &gt;= sum[stPos[stSz - 1] ] - X) &amp;&amp;
		   	(a[i] &lt;= 0 || a[i - 1] &lt;= a[i] )
				)
		{
			stPos[stSz] = i;
			stSz++;
		}

		int ppos;
		int val = a[i - 1];
		for (int j = 0; j &lt; stSz; j++)
		{
			skip[j] = true;
			int pos = stPos[j];

			sm[pos][val] = max(sm[pos][val], sm[pos][val + 1] + val);
			for (int h = a[i - 1] - 1; h &gt;= 0; h--)
			{
				if (sm[pos][h] &lt; sm[pos][h + 1] )
					sm[pos][h] = sm[pos][h + 1];
				else
					break;
			}
			if (j == 0) skip[j] = false;
			else
			{
				if (T == 0)
				{
					if (sm[pos][0] - sm[ppos][0] &gt; sum[pos] - sum[ppos] )
						skip[j] = false;
				}
				else if (T == 1)
				{
					if (sm[pos][0] != sm[ppos][0] )
						skip[j] = false;
				}
			}
			ppos = pos;

			int cur = sum[pos] - sum[i - 1] - sm[pos][0];
			int curLen = pos - (i - 1) + 1;
			if (cur == 0) continue;
			if (cur &gt; ans || (cur == ans &amp;&amp; curLen &lt; len) )
			{
				ans = cur;
				len = curLen;
				cnt = 0;
			}
			if (cur == ans &amp;&amp; curLen == len)
				cnt++;	
		}
		int nsz = 0;
		for (int h = 0; h &lt; stSz; h++)
		{
			if (!skip[h] )
				stPos[nsz++] = stPos[h];
		}
		stSz = nsz;
	}
	printf("%d %d\n", ans, cnt);
	



	return 0;
}


----------
====================
----------
ALGORITHMS.271
medium
----------
PROBLEM STATEMENT:
Penny has an array of [expression]. She wants to find the number of unique multisets she can form using elements from the array such that the bitwise XOR of all the elements of the multiset is a prime number. Recall that a multiset is a set which can contain duplicate elements.

Given [expression] before printing it on a new line.
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
using namespace std;
int n;
const int mo=1000000007;

int a[111111];
int npr[11111];
int vis[5555];
int f[2][10000];
int main() {
    npr[1]=1;
	for (int i=2;i&lt;=10000;i++){
		for (int j=i+i;j&lt;=10000;j+=i)npr[j]=1;
	}
	int q;scanf("%d",&amp;q);
	while(q--){
		scanf("%d",&amp;n);
		memset(vis,0,sizeof(vis));
		memset(f,0,sizeof(f));
		for (int i=1;i&lt;=n;i++){
			int x;scanf("%d",&amp;x);
			vis[x]++;
		}
		int *g=f[0],*h=f[1];
		g[0]=1;
		for (int i=3500;i&lt;=4500;i++)if(vis[i]){
				int qu,buqu;
				buqu=vis[i]/2+1;
				qu=vis[i]+1-buqu;
				swap(g,h);
				for (int j=0;j&lt;8192;j++)g[j]=(1ll*buqu*h[j]+1ll*qu*h[j^i])%mo;
		}
		int an=0;
		for (int i=2;i&lt;8192;i++)if(!npr[i]){
				an=(an+g[i])%mo;
		}
		printf("%d\n",an);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.272
advanced
----------
PROBLEM STATEMENT:
Daniel loves graphs. He thinks a graph is special if it has the following properties:


It is undirected.
The length of each edge is [expression].
It includes exactly [expression] different lovely triplets. 


A triplet is a set of [expression] or more of their component nodes are different. 

Given [expression], help Daniel draw a special graph.
----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;

#define REP(i,a,b) for(i=a;i&lt;b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

#define ll long long
#define ull unsigned ll

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'&lt;=k&amp;&amp;k&lt;='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k&lt;'0'||k&gt;'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'&lt;=k&amp;&amp;k&lt;='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k&lt;'0'||k&gt;'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(double *x){scanf("%lf",x);}
int reader(char c[]){int i,s=0;for(;;){mygc(i);if(i!=' '&amp;&amp;i!='\n'&amp;&amp;i!='\r'&amp;&amp;i!='\t'&amp;&amp;i!=EOF) break;}c[s++]=i;for(;;){mygc(i);if(i==' '||i=='\n'||i=='\r'||i=='\t'||i==EOF) break;c[s++]=i;}c[s]='\0';return s;}
template &lt;class T, class S&gt; void reader(T *x, S *y){reader(x);reader(y);}
template &lt;class T, class S, class U&gt; void reader(T *x, S *y, U *z){reader(x);reader(y);reader(z);}
template &lt;class T, class S, class U, class V&gt; void reader(T *x, S *y, U *z, V *w){reader(x);reader(y);reader(z);reader(w);}

void writer(int x, char c){int s=0,m=0;char f[10];if(x&lt;0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(ll x, char c){int s=0,m=0;char f[20];if(x&lt;0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(double x, char c){printf("%.15f",x);mypc(c);}
void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}
void writer(const char x[], char c){int i;for(i=0;x[i]!='\0';i++)mypc(x[i]);mypc(c);}
template&lt;class T&gt; void writerLn(T x){writer(x,'\n');}
template&lt;class T, class S&gt; void writerLn(T x, S y){writer(x,' ');writer(y,'\n');}
template&lt;class T, class S, class U&gt; void writerLn(T x, S y, U z){writer(x,' ');writer(y,' ');writer(z,'\n');}
template&lt;class T&gt; void writerArr(T x[], int n){int i;if(!n){mypc('\n');return;}rep(i,n-1)writer(x[i],' ');writer(x[n-1],'\n');}

char memarr[17000000]; void *mem = memarr;
#define MD 1000000007

int P, Q;

int N, M;
int mat[120][120];
int a1,a2,a3,a4,b1,b2,b3;

int ashi[10];

int dist[120][120];

int main(){
  int i, j, k, loop;
  int a,b,c,d,e,f,g,r;

  reader(&amp;P,&amp;Q);

  if(Q==2){
    while(P){
      rep(k,100) if(k*(k-1)*(k-2)/6 &gt; P) break;
      k--;
      P -= k*(k-1)*(k-2)/6;
      
      j = N++;
      rep(i,k) mat[j][N] = mat[N][j] = 1, N++;
    }
  } else {

    a1 = 100000;
    rep(a,20) REP(b,a,20) REP(c,b,20) REP(d,c,20){
      r = P - a*b*c - a*b*d - a*c*d - b*c*d;
      if(r &lt; 0) continue;
      rep(e,20) REP(f,e,20) REP(g,f,20) if(r==e*f*g){
        if(a1+a2+a3+a4+b1+b2+b3 &gt; a+b+c+d+e+f+g){
          a1 = a;
          a2 = b;
          a3 = c;
          a4 = d;
          b1 = e;
          b2 = f;
          b3 = g;
        }
      }
    }

    //  printf("%d %d %d %d, %d %d %d\n",a1,a2,a3,a4,b1,b2,b3);
    
    k = N++;
    if(Q%2==0){
      rep(loop,4){
        j = k;
        rep(i,Q/2-1) mat[j][N] = mat[N][j] = 1, j=N, N++;
        ashi[loop] = j;
      }
    } else {
      rep(i,4) rep(j,4) mat[k+i][k+j] = 1;
      N += 3;
      rep(loop,4){
        j = k+loop;
        rep(i,Q/2-1) mat[j][N] = mat[N][j] = 1, j=N, N++;
        ashi[loop] = j;
      }
    }
    
    k = N++;
    if(Q%2==0){
      rep(loop,3){
      j = k;
      rep(i,Q/2-1) mat[j][N] = mat[N][j] = 1, j=N, N++;
        ashi[4+loop] = j;
      }
    } else {
      rep(i,3) rep(j,3) mat[k+i][k+j] = 1;
      N += 2;
      rep(loop,3){
        j = k+loop;
        rep(i,Q/2-1) mat[j][N] = mat[N][j] = 1, j=N, N++;
        ashi[4+loop] = j;
      }
    }
    
//  printf("ashi %d %d %d %d, %d %d %d\n",ashi[0],ashi[1],ashi[2],ashi[3],ashi[4],ashi[5],ashi[6]);
    
    rep(i,a1) mat[N][ashi[0]] = mat[ashi[0]][N] = 1, N++;
    rep(i,a2) mat[N][ashi[1]] = mat[ashi[1]][N] = 1, N++;
    rep(i,a3) mat[N][ashi[2]] = mat[ashi[2]][N] = 1, N++;
    rep(i,a4) mat[N][ashi[3]] = mat[ashi[3]][N] = 1, N++;
    rep(i,b1) mat[N][ashi[4]] = mat[ashi[4]][N] = 1, N++;
    rep(i,b2) mat[N][ashi[5]] = mat[ashi[5]][N] = 1, N++;
    rep(i,b3) mat[N][ashi[6]] = mat[ashi[6]][N] = 1, N++;
  }
  
  M = 0;
  rep(i,N) REP(j,i+1,N) if(mat[i][j]) M++;
  writerLn(N,M);
  rep(i,N) REP(j,i+1,N) if(mat[i][j]) writerLn(i+1,j+1);


  if(0){
    rep(i,N) rep(j,N) dist[i][j] = 100000;
    rep(i,N) dist[i][i] = 0;
    rep(i,N) rep(j,N) if(mat[i][j]) dist[i][j] = min(dist[i][j],1);
    rep(k,N) rep(i,N) rep(j,N) dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);

    loop = 0;
    rep(i,N) REP(j,i+1,N) REP(k,j+1,N){
      if(dist[i][j]==Q &amp;&amp; dist[i][k]==Q &amp;&amp; dist[j][k]==Q){
        loop++;
        printf("--- %d %d %d\n",i+1,j+1,k+1);
      }
    }
    printf("total = %d\n",loop);
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.273
advanced
----------
PROBLEM STATEMENT:
Professor GukiZ has hobby — constructing different arrays. His best student, Nenad, gave him the following task that he just can't manage to solve:

Construct an [expression] must be non-negative integers.

[expression]

[expression]

If there is more then one such array, you need to find the lexicographically smallest one. In the case no such array [expression].

Note: An array, [expression].
----------
TOP SOLUTION:
----------
import java.util.Arrays;
import java.util.Scanner;

public class Solution {
  public static int[][][][] dp;
  public static int[] construct(int nums, int sum1, int sum2) {
    if (nums == 0) {
      if (sum1 != 0 || sum2 != 0) {
        return new int[]{-1};
      }
      return new int[]{};
    }
    if (dp[nums][sum1][sum2] != null) return dp[nums][sum1][sum2];
    
    for (int place = 0; nums*place &lt;= sum1; place++) {
      int nsum1 = sum1 - place * nums;
      int nsum2 = sum2 - place * nums - nsum1;
      if (nsum2 &lt; 0) continue;
      
      int[] xx = construct(nums-1, nsum1, nsum2);
      if (xx.length == 1 &amp;&amp; xx[0] == -1) {
        continue;
      }
      int[] actual = new int[nums];
      System.arraycopy(xx, 0, actual, 1, xx.length);
      for (int i = 0; i &lt; nums; i++) actual[i] += place;
      return dp[nums][sum1][sum2] = actual;
    }
    return dp[nums][sum1][sum2] = new int[]{-1}; 
  }
  
  public static void main (String[] args) {
    dp = new int[51][201][5001][];
    Scanner in = new Scanner(System.in);
    int q = in.nextInt();
    while(q--&gt;0) {
      int n = in.nextInt(), s = in.nextInt(), k = in.nextInt();
      int[] min = null;
      for (int start = 0; start*n &lt;= s; start++) {
        int[] b = construct(n-1, s-start*n, k);
        if (b.length == 1 &amp;&amp; b[0] == -1) {
          continue;
        }
        int[] xx = new int[n];
        System.arraycopy(b, 0, xx, 1, b.length);
        for (int i = 0; i &lt; n; i++) xx[i] += start;
        if (min == null) {
          min = xx;
          continue;
        }
        boolean less = false;
        for (int i = 0; i &lt; n; i++) {
          if (min[i] != xx[i]) {
            if (xx[i] &lt; min[i]) {
              less = true;
            }
            break;
          }
        }
        if (less) {
          min = xx;
        }
      }
      
      if (min != null) {
        for (int i = 0; i &lt; n; i++) {
          if (i != 0) System.out.print(" ");
          System.out.print(min[i]);
        }
        System.out.println();
      } else {
        System.out.println(-1);
      }
    }
    System.exit(0);
  }
}

----------
====================
----------
ALGORITHMS.274
hard
----------
PROBLEM STATEMENT:
Let's talk about binary numbers. We have an [expression] using the following formula:

[expression]

For example, if binary number [expression], we compute its decimal value like so:

[expression]

Meanwhile, in our well-known decimal number system where each digit ranges from [expression], can be expanded in the same way:

[expression]



Now that we've discussed both systems, let's combine decimal and binary numbers in a new system we call decibinary! In this number system, each digit ranges from [expression] because:

[expression]

Pretty cool system, right? Unfortunately, there's a problem: two different decibinary numbers can evaluate to the same decimal value! For example, the decibinary number [expression]:

[expression]

This is a major problem because our new number system has no real applications beyond this challenge! 



Consider an infinite list of non-negative decibinary numbers that is sorted according to the following rules:


The decibinary numbers are sorted in increasing order of the decimal value that they evaluate to. 
Any two decibinary numbers that evaluate to the same decimal value are ordered by increasing decimal value, meaning the equivalent decibinary values are strictly interpreted and compared as decimal values and the smaller decimal value is ordered first. For example, [expression].


Here is a list of first few decibinary numbers properly ordered:



You will be given [expression] decibinary number in the list on a new line.  

Function Description

Complete the decibinaryNumbers function in the editor below.  For each query, it should return the decibinary number at that one-based index.  

decibinaryNumbers has the following parameter(s):


x: the index of the decibinary number to return   

----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; static void amin(T &amp;x, U y) { if (y &lt; x) x = y; }
template&lt;typename T, typename U&gt; static void amax(T &amp;x, U y) { if (x &lt; y) x = y; }

int main() {
	int T;
	scanf("%d", &amp;T);
	const int X = 300000, K = 18;
	vector&lt;vector&lt;ll&gt;&gt; dp(K + 2, vector&lt;ll&gt;(X + 1));
	dp[0][0] = 1;
	rer(k, 0, K) {
		rer(d, 0, 9) for (int j = X - (d &lt;&lt; k); j &gt;= 0; --j)
			dp[k + 1][j + (d &lt;&lt; k)] += dp[k][j];
	}
	vector&lt;ll&gt; sum(X + 2);
	rer(j, 0, X)
		sum[j + 1] = sum[j] + dp[K + 1][j];
	for (int ii = 0; ii &lt; T; ++ii) {
		long long rank;
		scanf("%lld", &amp;rank), --rank;
		int x = (int)(upper_bound(sum.begin(), sum.end(), rank) - sum.begin()) - 1;
		rank -= sum[x];
		string ans;
		bool lz = true;
		for (int k = K; k &gt;= 0; --k) {
			bool ok = false;
			rer(d, 0, 9) {
				ll cnt = x &gt;= d &lt;&lt; k ? dp[k][x - (d &lt;&lt; k)] : 0;
				if (rank &lt; cnt) {
					ok = true;
					x -= d &lt;&lt; k;
					lz &amp;= d == 0 &amp;&amp; k != 0;
					if(!lz)
						ans += char('0' + d);
					break;
				}
				rank -= cnt;
			}
			assert(ok);
		}
		puts(ans.c_str());
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.275
medium
----------
PROBLEM STATEMENT:
Li and Lu have [expression]), then the measure of unfairness of this division is: 
[expression]

Find the minimum measure of unfairness that can be obtained with some division of the set of integers where Li gets exactly [expression] integers. 

Note [expression] means Set complement
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;fstream&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i &lt; (int)(n); ++i)
#define for1(i, n) for (int i = 1; i &lt;= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i &gt;= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i &lt;= (int)(b); ++i)

using namespace std;

typedef pair&lt;int, int&gt; pii;
typedef vector&lt;int&gt; vi;
typedef vector&lt;pii&gt; vpi;
typedef vector&lt;vi&gt; vvi;
typedef long long i64;
typedef vector&lt;i64&gt; vi64;
typedef vector&lt;vi64&gt; vvi64;

template&lt;class T&gt; bool uin(T &amp;a, T b) { return a &gt; b ? (a = b, true) : false; }
template&lt;class T&gt; bool uax(T &amp;a, T b) { return a &lt; b ? (a = b, true) : false; }

const int maxn = 3100;
i64 dp[maxn][maxn];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout &lt;&lt; fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    vi64 a(n);
    forn(i, n) cin &gt;&gt; a[i];
    sort(all(a));
    forn(i, n + 1) forn(j, n + 1) dp[i][j] = 1e18;
    dp[0][0] = 0;
    forn(i, n) forn(j, i + 1) {
        if (j &gt; k || i - j &gt; n - k) continue;
        uin(dp[i + 1][j + 1], dp[i][j] + a[i] * (i - j - (n - k - (i - j))));
        uin(dp[i + 1][j], dp[i][j] + a[i] * (j - (k - j)));
    }
    cout &lt;&lt; dp[n][k] &lt;&lt; '\n';

#ifdef LOCAL_DEFINE
    cerr &lt;&lt; "Time elapsed: " &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.276
medium
----------
PROBLEM STATEMENT:
We define subsequence as any subset of an array.  We define a subarray as a contiguous subsequence in an array.  

Given an array, find the maximum possible sum among:


all nonempty subarrays. 
all nonempty subsequences. 


Print the two values as space-separated integers on one line. 

Note that empty subarrays/subsequences should not be considered. 

For example, given an array [expression].  

Function Description  

Complete the maxSubarray function in the editor below.  It should return an array of two integers: the maximum subarray sum and the maximum subsequence sum of [expression].  

maxSubarray has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;


int main()
{
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
    int loop;
    cin &gt;&gt; loop;
    while (loop--) {
        int size;
        cin &gt;&gt; size;
        vector&lt;int&gt; data(size, 0);
        for (int i = 0; i &lt; size; ++i) {
            cin &gt;&gt; data[i];
        }

        vector&lt;int&gt; dp(size, 0);
        int big = 0;
        int sum = 0;
        int start = -1;
        for (int i = 0; i &lt; size; i++) {
            int val = sum + data[i];

            if (val &gt; 0) {
                if (sum == 0) {
                    start = i;
                }
                sum = val;
            } else {
                sum = 0;
            }

            if (sum &gt; big) {
                big = sum;
            }
        }

        if (start == -1) {
            cout &lt;&lt; data[0] &lt;&lt; " ";
        } else {
            cout &lt;&lt; big &lt;&lt; " ";
        }

        sum = 0;
        start = -1;
        for (int i = 0; i &lt; size; ++i) {
            if (data[i] &gt; 0) {
                start = i;
                sum += data[i];
            }
        }

        if (start == -1) {
            cout &lt;&lt; data[0] &lt;&lt; endl;
        } else {
            cout &lt;&lt; sum &lt;&lt; endl;
        }
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.277
hard
----------
PROBLEM STATEMENT:
Bill Gates is on one of his philanthropic journeys to a village in Utopia. He has brought a box of packets of candies and would like to distribute one packet to each of the children.  Each of the packets contains a number of candies.  He wants to minimize the cumulative difference in the number of candies in the packets he hands out.  This is called the unfairness sum.  Determine the minimum unfairness sum achievable. 

For example, he brings [expression].  We calculate the unfairness sum as:

[expression]				
[expression]
[expression] 
[expression]

[expression]



Function Description

Complete the angryChildren function in the editor below.  It should return an integer that represents the minimum unfairness sum achievable.

angryChildren has the following parameter(s):


k: an integer that represents the number of children  
packets:  an array of integers that represent the number of candies in each packet  

----------
TOP SOLUTION:
----------
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;deque&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cctype&gt;
#include &lt;cstring&gt;
#include &lt;numeric&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;ctime&gt;
#include &lt;queue&gt;

/*
// C++ 11 stuff

#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;tuple&gt;
#include &lt;array&gt;

#define tup(name, pos) get&lt;(pos)&gt;(name)
#define A1(type, size) array &lt;type, size&gt;
#define A2(type, s1, s2) A1(A1(type, s2), s1)
#define A3(type, s1, s2, s3) A1(A2(type, s2, s3), s1)

//*/


using namespace std;

typedef long long LL;
typedef unsigned long long ULL;
typedef pair &lt;int, int&gt; pnt;


#define FI(i,a) for (int i=0; i&lt;(a); ++i)
#define FOR(i,s,e) for (int i=(s); i&lt;(e); ++i)
#define MEMS(a,b) memset(a,b,sizeof(a))
#define pb push_back
#define mp make_pair
#define ALL(a) a.begin(),a.end()
#define V(t) vector &lt; t &gt;
#define MAX(a,b) ((a)&gt;(b)?(a):(b))
#define MIN(a,b) ((a)&lt;(b)?(a):(b))
#define ABS(a) ((a)&gt;(0)?(a):(-(a)))
#define ALL(a) a.begin(),a.end()

#define dout(a) cerr &lt;&lt; a &lt;&lt; endl
#define sout(a) cerr &lt;&lt; a &lt;&lt; "  "
#define lbl cerr &lt;&lt; "debug_label" &lt;&lt; endl;

const double pi = 3.14159265358979323846264338327950288419716939937511;
const double eps = 1e-9;

//*
char ch_ch_ch[1&lt;&lt;20];
inline string gs() {scanf("%s",ch_ch_ch); return string(ch_ch_ch);}
inline string gl() {gets(ch_ch_ch); return string(ch_ch_ch);}
inline int gi() {int x; scanf("%d",&amp;x); return x;}
//*/

const int inf = 1000000000;

// code starts here

int n;
V(int) a;
V(LL) sum;

void solution() {


    n = gi();
    int K = gi();
    FI(i,n) a.pb(gi());
    sort(ALL(a));
    sum.resize(n);
    LL res = inf*1ll*inf;
    sum[0] = a[0];
    FOR(i,1,n) sum[i] = a[i] + sum[i-1];
    LL cur = 0;
    FOR(i,1,K) cur += a[i]*1ll*i - sum[i-1];
    res = cur;
    if (K &gt; 1) FOR(i,K,n) {
        cur += (K-1)*1ll*a[i] - (sum[i-1] - sum[i-K]);
        cur -= -(K-1)*1ll*a[i-K]  + (sum[i-1] - sum[i-K]);
        res = min(res,cur);
    }

    cout &lt;&lt; res &lt;&lt; endl;


}


// code ends here

int main(int argc, char** argv) {

#ifdef IGEL_ACM
    freopen("in.txt","r",stdin);
    //freopen("out.txt", "w", stdout);
    clock_t beg_time = clock();
#else
    //freopen(argv[1],"r",stdin);
    //freopen("painting.in", "r", stdin);
    //freopen("painting.out", "w", stdout);

#endif

    solution();

#ifdef IGEL_ACM
    fprintf(stderr,"*** Time: %.3lf ***\n",1.0*(clock()-beg_time)/CLOCKS_PER_SEC);
#endif

    return 0;
}


----------
====================
----------
ALGORITHMS.278
hard
----------
PROBLEM STATEMENT:
Watson gave Sherlock a collection of arrays [expression]. 

Watson asks Sherlock to merge [expression] into a sorted array. Sherlock is new to coding, but he accepts the challenge and writes the following algorithm:


[expression] (an empty array).
[expression].
While there is at least one non-empty array in [expression]:

[expression].
While [expression]:

If [expression] is not empty:
Remove the first element of [expression].
[expression].
While [expression] is not empty:

Remove the minimum element of [expression].
Return [expression] as the output.


Let's see an example. Let V be [expression].



The image below demonstrates how Sherlock will do the merging according to the algorithm:



Sherlock isn't sure if his algorithm is correct or not. He ran Watson's input, [expression]?

Given [expression].

Notes:


Two collections of arrays are different if one of the following is true:

Their sizes are different.
Their sizes are the same but at least one array is present in one collection but not in the other.
Two arrays, [expression], are different if one of the following is true:

Their sizes are different.
Their sizes are the same, but there exists an index [expression].

----------
TOP SOLUTION:
----------
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.BufferedReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Solution {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        SherlocksArrayMergingAlgorithm solver = new SherlocksArrayMergingAlgorithm();
        solver.solve(1, in, out);
        out.close();
    }

    static class SherlocksArrayMergingAlgorithm {
        public int mod = 1000000007;
        public boolean[][] inc;
        public long[] fact;
        public long[] ifact;
        public int n;
        public long[][] dp;

        public void solve(int testNumber, InputReader in, OutputWriter out) {
            n = in.nextInt();
            long[][] w = Factorials.getFIF(2 * n, mod);
            fact = w[0];
            ifact = w[1];
            int[] arr = in.readIntArray(n);
            inc = new boolean[n][n];
            for (int i = 0; i &lt; n; i++) {
                inc[i][i] = true;
                for (int j = i + 1; j &lt; n; j++) {
                    inc[i][j] = inc[i][j - 1] &amp;&amp; (arr[j] &gt; arr[j - 1]);
                }
            }
            dp = new long[n][n];
            for (long[] x : dp) Arrays.fill(x, -1);
            long ans = 0;
            for (int i = 0; i &lt; n &amp;&amp; inc[0][i]; i++) {
                ans = (ans + dfs(i + 1, i + 1)) % mod;
            }
            out.println(ans);
        }

        public long dfs(int curidx, int lastblock) {
            if (curidx == n) return 1;
            if (dp[curidx][lastblock] != -1) return dp[curidx][lastblock];
            long ret = 0;
            for (int next = curidx; next &lt; n &amp;&amp; next &lt; curidx + lastblock &amp;&amp; inc[curidx][next]; next++) {
                int cblock = (next - curidx + 1);
                ret = (ret + fact[lastblock] * ifact[lastblock - cblock] % mod * dfs(next + 1, cblock)) % mod;
            }
            return dp[curidx][lastblock] = ret;
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int[] readIntArray(int tokens) {
            int[] ret = new int[tokens];
            for (int i = 0; i &lt; tokens; i++) {
                ret[i] = nextInt();
            }
            return ret;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void println(long i) {
            writer.println(i);
        }

    }

    static class Factorials {
        public static long[][] getFIF(int max, int mod) {
            long[] fact = new long[max];
            long[] ifact = new long[max];
            long[] inv = new long[max];
            inv[1] = 1;
            for (int i = 2; i &lt; max; i++) {
                inv[i] = (mod - mod / i) * inv[mod % i] % mod;
            }
            fact[0] = 1;
            ifact[0] = 1;
            for (int i = 1; i &lt; max; i++) {
                fact[i] = fact[i - 1] * i % mod;
                ifact[i] = ifact[i - 1] * inv[i] % mod;
            }
            return new long[][]{fact, ifact, inv};
        }

    }
}


----------
====================
----------
ALGORITHMS.279
medium
----------
PROBLEM STATEMENT:
Chloe is fascinated by prime numbers. She came across the number [expression] on a sign and, though the number is not prime, found some primes hiding in it by using the following rules:  


Every three consecutive digits sum to a prime:
[expression]
Every four consecutive digits sum to a prime:
[expression]
Every five consecutive digits sum to a prime:
[expression]


You must answer [expression], that satisfy all three of Chloe's rules (i.e., every three, four, and five consecutive digits sum to a prime).
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; static void amin(T &amp;x, U y) { if (y &lt; x) x = y; }
template&lt;typename T, typename U&gt; static void amax(T &amp;x, U y) { if (x &lt; y) x = y; }


template&lt;int MOD&gt;
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if (sigt &lt; 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if (sigt &lt; 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &amp;operator+=(ModInt that) { if ((x += that.x) &gt;= MOD) x -= MOD; return *this; }
	ModInt &amp;operator-=(ModInt that) { if ((x += MOD - that.x) &gt;= MOD) x -= MOD; return *this; }
	ModInt &amp;operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &amp;operator/=(ModInt that) { return *this *= that.inverse(); }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }

	ModInt inverse() const {
		signed a = x, b = MOD, u = 1, v = 0;
		while (b) {
			signed t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		if (u &lt; 0) u += Mod;
		ModInt res; res.x = (unsigned)u;
		return res;
	}

	bool operator==(ModInt that) const { return x == that.x; }
	bool operator!=(ModInt that) const { return x != that.x; }
	ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }
};
typedef ModInt&lt;1000000007&gt; mint;

#pragma region for precomputing
int berlekampMassey(const vector&lt;mint&gt; &amp;s, vector&lt;mint&gt; &amp;C) {
	int N = (int)s.size();
	C.assign(N + 1, mint());
	vector&lt;mint&gt; B(N + 1, mint());
	C[0] = B[0] = 1;
	int degB = 0;
	vector&lt;mint&gt; T;
	int L = 0, m = 1;
	mint b = 1;
	for (int n = 0; n &lt; N; ++n) {
		mint d = s[n];
		for (int i = 1; i &lt;= L; ++i)
			d += C[i] * s[n - i];
		if (d == mint()) {
			++m;
		}
		else {
			if (2 * L &lt;= n)
				T.assign(C.begin(), C.begin() + (L + 1));
			mint coeff = -d * b.inverse();
			for (int i = 0; i &lt;= degB; ++i)
				C[m + i] += coeff * B[i];
			if (2 * L &lt;= n) {
				L = n + 1 - L;
				B.swap(T);
				degB = (int)B.size() - 1;
				b = d;
				m = 1;
			}
			else {
				++m;
			}
		}
	}
	C.resize(L + 1);
	return L;
}

void computeMinimumPolynomialForLinearlyRecurrentSequence(const vector&lt;mint&gt; &amp;a, vector&lt;mint&gt; &amp;phi) {
	int n2 = (int)a.size(), n = n2 / 2;
	assert(n2 % 2 == 0);
	int L = berlekampMassey(a, phi);
	reverse(phi.begin(), phi.begin() + (L + 1));
}

template&lt;int MOD&gt; int mintToSigned(ModInt&lt;MOD&gt; a) {
	int x = a.get();
	if (x &lt;= MOD / 2)
		return x;
	else
		return x - MOD;
}

int outputPrecomputedMinimalPolynomial(vector&lt;mint&gt; seq, ostream &amp;os) {
	if (seq.size() % 2 == 1) seq.pop_back();
	vector&lt;mint&gt; phi;
	computeMinimumPolynomialForLinearlyRecurrentSequence(seq, phi);
	if (phi.size() &gt;= seq.size() / 2 - 2) {
		cerr &lt;&lt; "warning: maybe not enough terms" &lt;&lt; endl;
	}
	cerr &lt;&lt; "/*" &lt;&lt; phi.size() - 1 &lt;&lt; "*/";
	os &lt;&lt; "{{ ";
	rep(i, phi.size() - 1) {
		if (i != 0) os &lt;&lt; ", ";
		os &lt;&lt; seq[i].get();
	}
	os &lt;&lt; " }, { ";
	rep(i, phi.size()) {
		if (i != 0) os &lt;&lt; ", ";
		os &lt;&lt; mintToSigned(phi[i]);
	}
	os &lt;&lt; " }}";
	return (int)phi.size() - 1;
}

#pragma endregion

vector&lt;bool&gt; isprime;
vector&lt;int&gt; primes;
void sieve(int n) {
	if ((int)isprime.size() &gt;= n + 1) return;
	isprime.assign(n + 1, true);
	isprime[0] = isprime[1] = false;
	int sqrtn = (int)(sqrt(n * 1.) + .5);
	for (int i = 2; i &lt;= sqrtn; i++) if (isprime[i]) {
		for (int j = i * i; j &lt;= n; j += i)
			isprime[j] = false;
	}
	primes.clear();
	for (int i = 2; i &lt;= n; i++) if (isprime[i])
		primes.push_back(i);
}

int main() {
	int T;
	scanf("%d", &amp;T);
	const vector&lt;mint&gt;
		init = { 1, 9, 90, 303, 280, 218, 95, 101, 295, 513, 737, 668, 578, 1303, 2449, 3655, 3965 },
		phi = { 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, -2, -4, 0, 0, 0, 0, 1 };
	const int N = 400000;
	vector&lt;mint&gt; seq = init;
	while ((int)seq.size() &lt;= N) {
		mint x;
		rep(j, phi.size() - 1)
			x -= phi[j] * seq[seq.size() - phi.size() + 1 + j];
		seq.push_back(x);
	}
	for (int ii = 0; ii &lt; T; ++ii) {
		int n;
		scanf("%d", &amp;n);
		mint ans = seq[n];
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.280
medium
----------
PROBLEM STATEMENT:
HackerRank-city is an acyclic connected graph (or tree). Its not an ordinary place, the construction of the whole tree takes place in [expression] steps. The process is described below:


It initially has [expression] node.
At each step, you must create [expression] copies in the following H shape:




At each [expression].

Calculate the sum of distances between each pair of nodes; as these answers may run large, print your answer modulo [expression].
----------
TOP SOLUTION:
----------
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Egor Kulikov (egor@egork.net)
 */
public class Solution {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		HackerrankCity solver = new HackerrankCity();
		solver.solve(1, in, out);
		out.close();
	}

	static class HackerrankCity {
		private static final long MOD = 1000000007;

		public void solve(int testNumber, InputReader in, OutputWriter out) {
			int n = in.readInt();
			int[] a = IOUtils.readIntArray(in, n);
			long nv = 1;
			long sd = 0;
			long dtc = 0;
			long diam = 0;
			for (int ne : a) {
				long nnv = nv * 4 + 2;
				long nsd = 4 * sd + 4 * dtc * (2 + 3 * nv % MOD) % MOD + 4 * ne * nv % MOD * (nv * 3 + 2) % MOD +
						ne * (2 * nv + 1) % MOD * (2 * nv + 1) % MOD;
				long ndtc = 4 * dtc + 8 * ne * nv % MOD + 3 * ne + (3 * nv + 2) * diam % MOD;
				long ndiam = 2 * diam + 3 * ne;
				nv = nnv % MOD;
				sd = nsd % MOD;
				dtc = ndtc % MOD;
				diam = ndiam % MOD;
			}
			out.printLine(sd);
		}
	}

	static class OutputWriter {
		private final PrintWriter writer;

		public OutputWriter(OutputStream outputStream) {
			writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
		}

		public OutputWriter(Writer writer) {
			this.writer = new PrintWriter(writer);
		}

		public void close() {
			writer.close();
		}

		public void printLine(long i) {
			writer.println(i);
		}
	}

	static class InputReader {
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;
		private SpaceCharFilter filter;

		public InputReader(InputStream stream) {
			this.stream = stream;
		}

		public int read() {
			if (numChars == -1) {
				throw new InputMismatchException();
			}
			if (curChar &gt;= numChars) {
				curChar = 0;
				try {
					numChars = stream.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (numChars &lt;= 0) {
					return -1;
				}
			}
			return buf[curChar++];
		}

		public int readInt() {
			int c = read();
			while (isSpaceChar(c)) {
				c = read();
			}
			int sgn = 1;
			if (c == '-') {
				sgn = -1;
				c = read();
			}
			int res = 0;
			do {
				if (c &lt; '0' || c &gt; '9') {
					throw new InputMismatchException();
				}
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			return res * sgn;
		}

		public boolean isSpaceChar(int c) {
			if (filter != null) {
				return filter.isSpaceChar(c);
			}
			return isWhitespace(c);
		}

		public static boolean isWhitespace(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		public interface SpaceCharFilter {
			public boolean isSpaceChar(int ch);
		}
	}

	static class IOUtils {
		public static int[] readIntArray(InputReader in, int size) {
			int[] array = new int[size];
			for (int i = 0; i &lt; size; i++) {
				array[i] = in.readInt();
			}
			return array;
		}
	}
}


----------
====================
----------
ALGORITHMS.281
medium
----------
PROBLEM STATEMENT:
Consider an array, [expression], we have the following arrays of pieces:


[expression]-element pieces.
[expression] element.
[expression] elements.
[expression]-element piece.


We consider the value of a piece in some array [expression].

Given [expression] on a new line.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I &lt; (N); ++I)
#define REPP(I, A, B) for (int I = (A); I &lt; (B); ++I)
#define RI(X) scanf("%d", &amp;(X))
#define RII(X, Y) scanf("%d%d", &amp;(X), &amp;(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &amp;(X), &amp;(Y), &amp;(Z))
#define DRI(X) int (X); scanf("%d", &amp;X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &amp;X, &amp;Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &amp;X, &amp;Y, &amp;Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &amp;___T); while (___T-- &gt; 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define PII pair&lt;int,int&gt;
#define VI vector&lt;int&gt;
#define VPII vector&lt;pair&lt;int,int&gt; &gt;
#define PLL pair&lt;long long,long long&gt;
#define VPLL vector&lt;pair&lt;long long,long long&gt; &gt;
#define F first
#define S second
typedef long long LL;
using namespace std;
const int MOD = 1e9+7;
const int SIZE = 1e6+10;
int a[SIZE];
void ADD(int &amp;x,LL v){
    x=(x+v)%MOD;
    if(x&lt;0)x+=MOD;
}
int get(int L,int R){
    int v=a[R]-a[L-1];
    if(v&lt;0)v+=MOD;
    return v;
}
int two[SIZE];
int main(){
    two[0]=1;
    REPP(i,1,SIZE){
        two[i]=two[i-1]*2%MOD;
    }
    DRI(n);
    REP(i,n)RI(a[i+1]);
    if(n==1){
        printf("%d\n",a[1]);
        return 0;
    }
    REPP(i,1,n+1)ADD(a[i],a[i-1]);
    int now=0;
    int an=0;
    for(int i=1;i*2-1&lt;=n;i++){
        ADD(now,get(i,n+1-i));
        ADD(an,((LL)now-get(1,i)-get(n-i+1,n))*i%MOD*two[max(0,n-2-i)]);
        ADD(an,(get(1,i)+get(n-i+1,n))*(LL)i%MOD*two[n-1-i]);

        if(i==1)ADD(an,now*(LL)n);
        else if(i*2-1!=n){
            int j=n+1-i;
            ADD(an,((LL)now-get(1,j)-get(n-j+1,n))*j%MOD*two[max(0,n-2-j)]);
            ADD(an,(get(1,j)+get(n-j+1,n))*(LL)j%MOD*two[n-1-j]);
        }

    }
    printf("%d\n",an);
    return 0;
}

----------
====================
----------
ALGORITHMS.282
medium
----------
PROBLEM STATEMENT:
Mr K has a rectangular plot of land which may have marshes where fenceposts cannot be set. He wants you to find the perimeter of the largest rectangular fence that can be built on this land.

For example, in the following [expression] marks good land.

....
..x.
..x.
x...


If we number the rows and columns starting with [expression].  

Function Description

Complete the kMarsh function in the editor below.  It should print either an integer or impossible.

kMarsh has the following parameter(s):  


grid: an array of strings that represent the grid  

----------
TOP SOLUTION:
----------
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;limits&gt;
#include &lt;map&gt;
#include &lt;numeric&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
using namespace std;


/* Prewritten code begins */
#define REP(i,n)    for(int i=0; i&lt;(n); ++i)
#define FOR(i,a,b)  for(int i=(a); i&lt;=(b); ++i)
/* Prewritten code ends */

const int maxN = 505;
string s[maxN];
int range[maxN][maxN];
int main() {
	int R, C, lastC, res = 0;
	cin &gt;&gt; R &gt;&gt; C;
	REP(r,R) cin &gt;&gt; s[r];
	REP(c,C) range[0][c] = s[0][c] == '.' ? 0 : maxN;
	FOR(r,1,R-1) REP(c,C) if(s[r][c] == '.') range[r][c] = min(range[r-1][c], r); else range[r][c] = maxN;
	REP(r1,R) FOR(r2,r1+1,R-1) {
		lastC = -1;
		REP(c,C) {
			if(s[r1][c] == '.' &amp;&amp; s[r2][c] == '.') {
				if(range[r2][c] &lt;= r1) {
					if(lastC != -1) res = max(res, 2*(r2-r1-1)+2*(c-lastC+1));
					else lastC = c; 
				}
			} else {
				lastC = -1;
			}
		}
	}
	if(res == 0) cout &lt;&lt; "impossible" &lt;&lt; endl;
	else cout &lt;&lt; res &lt;&lt; endl;
	return 0;
}

----------
====================
----------
ALGORITHMS.283
medium
----------
PROBLEM STATEMENT:
In this problem, we'll use the term "longest common substring" loosely.  It refers to substrings differing at some number or fewer characters when compared index by index.  For example, 'abc' and 'adc' differ in one position, 'aab' and 'aba' differ in two.  

Given two strings and an integer [expression] positions.  

For example, [expression].  

Function Description

Complete the substringDiff function in the editor below.  It should return an integer that represents the length of the longest common substring as defined.  

substringDiff has the following parameter(s):  


k: an integer that represents the maximum number of differing characters in a matching pair  
s1: the first string  
s2: the second string  

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
using namespace std;

typedef short int sint;
const int N = 2001;

int n, t, K, L1, L2;
char p[N], q[N];
int diff[N][N];

void calc_diff() {
    for(int i = L1; i &gt;= 0; i --)
        for(int j = L2; j &gt;= 0; j --) {
            if(i == L1 || j == L2) diff[i][j] = 0;
            else {
                diff[i][j] = diff[i + 1][j + 1] + (p[i] == q[j] ? 0 : 1);
            }
        }
}

int get_diff(int p1, int p2, int len) {
    int result = diff[p1][p2] - diff[p1 + len][p2 + len];
    return result;
}

int solve() {
    int result = 0;
    // i = pos(p) - pos(q)
    // j = pos(p)
    // pos(q) = j - i &gt;= 0 -&gt; j &gt;= i,
    // j - i &lt; L2 -&gt; j &lt; L2 + i
    int pos = 0, pos2 = 0;
    for(int i = -L2 + 1; i &lt; L1; i ++) {
        int right = 0;
        for(int j = max(0, i); j &lt; min(L1, L2 + i); j ++) {
            int k = j - i;
            right = max(right, j - 1);
            while(right + 1 - j + k &lt; L2 &amp;&amp; right + 1 &lt; L1 &amp;&amp; get_diff(j, k, right - j + 2) &lt;= K) right ++;
            result = max(result, right - j + 1);
            if(result == right - j + 1) {
                pos = j;
                pos2 = k;
            }
        }
    }
    /*for(int i = 0; i &lt; result; i ++) cout &lt;&lt; p[pos + i];
    cout &lt;&lt; endl;
    for(int i = 0; i &lt; result; i ++) cout &lt;&lt; q[pos2 + i];
    cout &lt;&lt; endl;
    cout &lt;&lt; get_diff(pos, pos2, result) &lt;&lt; endl;*/
    return result;
}

int main() {
    int cl = clock();
    for(cin &gt;&gt; t; t--; ) {
        cin &gt;&gt; K &gt;&gt; p &gt;&gt; q;
        L1 = strlen(p);
        L2 = strlen(q);
        calc_diff();
        cout &lt;&lt; solve() &lt;&lt; endl;
    }
//    cerr &lt;&lt; (clock() - cl) * 0.001 &lt;&lt; endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.284
medium
----------
PROBLEM STATEMENT:
You are given two positive integers [expression]:

[expression]

where operation [expression] means binary shift to the left.

Please note, that we consider ideal model of binary integers. That is there is infinite number of bits in each number, and there are no disappearings (or cyclic shifts) of bits.
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

#define long long long
#define mod 1000000007ll
#define M 500500
#define N 13001000


const int T = 314159;

string a, b;
long p[M], x[M], s[N];

void pre() {
    p[0] = 1;
    for (int i = 1; i &lt; M; ++i)
        p[i] = (2 * p[i - 1]) % mod;
}

void read() {
    cin &gt;&gt; a &gt;&gt; b;

    for (int i = 0; i &lt; (int) a.length(); ++i)
        x[a.length() - 1 - i] = a[i] == '1' ? 1 : 0;

    for (int i = 0; i &lt; (int) b.length(); ++i)
        s[b.length() - 1 - i + M] = b[i] == '1' ? 1 : 0;

    for (int i = 1; i &lt; N; ++i)
        s[i] += s[i - 1];
}

long sum(int l, int r) {
    return s[r + M] - s[l + M];
}

void kill() {
    long ans = 0;
    for (int i = 0; i &lt; M; ++i)
    if (x[i] == 0)
        ans = (ans + p[i] * sum(i - T - 1, i)) % mod;
    else
        ans = (ans + p[i] * (T + 1 - sum(i - T - 1, i))) % mod;

    cout &lt;&lt; ans &lt;&lt; "\n";
}


int main() {
#ifdef TROLL
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#else
    ios_base::sync_with_stdio(0);
#endif

    pre();
    read();
    kill();

    return 0;
}
----------
====================
----------
ALGORITHMS.285
medium
----------
PROBLEM STATEMENT:
You have an infinite number of 4 types of lego blocks of sizes given as (depth x height x width):

[expression]
[expression]
[expression]
[expression]
[expression]



Using these blocks, you want to make a wall of height [expression]. Features of the wall are: 

- The wall should not have any holes in it. 
- The wall you build should be one solid structure, so there should not be a straight vertical break across all rows of bricks. 
- The bricks must be laid horizontally.   

How many ways can the wall be built?

For example, the wall's height [expression].  Here are some configurations:  

  

These are not all of the valid permutations.

Function Description  

Complete the legoBlocks function in the editor below.  It should return an integer that represents the number of valid wall formations for the given wall dimensions modulo [expression].

legoBlocks has the following parameter(s):


n: an integer that represents the height of the wall  
m: an integer that represents the width of the wall  

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
 
using namespace std;
  
#define mo(m) if(m &gt; 1000000007) m = m%1000000007
 
 
 
void solve(){
    int t,hMax = 0,wMax = 0;
 
    cin &gt;&gt; t;
    vector &lt;int&gt; vH(t);
    vector &lt;int&gt; vW(t);
 
    for(int i = 0; i &lt; t;i++){
        cin &gt;&gt; vH[i] &gt;&gt; vW[i];
        if(vH[i] &gt; hMax)
            hMax = vH[i];
 
        if(vW[i] &gt; wMax)
            wMax = vW[i];
    }
    if(hMax &lt; 4)
        hMax = 4;
    if(wMax &lt; 4)
        wMax = 4;
 
    vector &lt;int&gt; rNumb(wMax + 1,0);
    vector &lt;vector &lt;int&gt; &gt; rNumbPwh(hMax + 1,rNumb);
    vector &lt;vector &lt;int&gt; &gt; rt(hMax + 1,rNumb);
    vector &lt;int&gt; hNumb(hMax + 1,0);
 
    for(int i = 0; i &lt; t;i++){
        if(vW[i] &gt; hNumb[vH[i]])
             hNumb[vH[i]] = vW[i];
    }
 
    rNumb[0] = 1;
    rNumb[1] = 1;
    rNumb[2] = 2;
    rNumb[3] = 4;
    rNumb[4] = 8;
 
    for(int i = 5; i &lt;= wMax; i++){
        rNumb[i] += rNumb[i-4];
        mo(rNumb[i]);
        rNumb[i] += rNumb[i-3];
        mo(rNumb[i]);
        rNumb[i] += rNumb[i-2];
        mo(rNumb[i]);
        rNumb[i] += rNumb[i-1];
        mo(rNumb[i]);
    }
 
    for(int i = 1; i &lt;= wMax; i++){
        long long rNumbTimes = rNumb[i];
        for(int j = 1;j &lt;= hMax ;j++){
            rNumbPwh[j][i] =  rNumbTimes;
            rNumbTimes *= rNumb[i];
            mo(rNumbTimes);
        }
    }
 
    rt[1][1] = 1;
    rt[1][2] = 1;
    rt[1][3] = 1;
    rt[1][4] = 1;
 
    for(int i = 2 ; i &lt;= hMax ; i++)
        rt[i][1] = 1;
 
 
    for(int j = 2;j &lt;= hMax ;j++){
        for(int i = 2; i &lt;= hNumb[j]; i++){
            long long rTemp = rNumbPwh[j][i];
            for(int k = 1 ;k &lt; i ; k++){
                long long rTemp2 = ((long long) rt[j][k] )* ((long long) rNumbPwh[j][i-k]);
                mo(rTemp2);
 
                if(rTemp2 &gt; rTemp){
                    rTemp = rTemp + 1000000007 - rTemp2;
                }
                else
                    rTemp -= rTemp2;
            }
            rt[j][i] = rTemp;
        }
    }
 
    for(int i = 0; i &lt; t;i++){
        cout &lt;&lt; rt[vH[i]][vW[i]]&lt;&lt;endl;
    }
}
 
 
 
int main(){
    solve();
    return 0;
}
----------
====================
----------
ALGORITHMS.286
hard
----------
PROBLEM STATEMENT:
You are given a grid having N rows and M columns. A grid square can either be blocked or empty. Blocked squares are represented by a '#' and empty squares are represented by '.'. Find the number of ways to tile the grid using L shaped bricks. A L brick has one side of length three units while other of length 2 units. All empty squares in the grid should be covered by exactly one of the L shaped tiles, and blocked squares should not be covered by any tile. The bricks can be used in any orientation (they can be rotated or flipped).
----------
TOP SOLUTION:
----------
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;bitset&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define PB push_back
#define MP make_pair
#define SZ(v) ((int)(v).size())
#define abs(x) ((x) &gt; 0 ? (x) : -(x))
#define FOREACH(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
typedef long long LL;

const int MOD = 1000000007;
const int inf = 0x3f3f3f3f;
const int maxn = 25;
const int maxs = 1 &lt;&lt; 8;
LL dp[maxn][maxs][maxs];
int state[maxn];
int cur, nxt;
int n, m, initJ, initK;

bool valid(int mask, int pos) {
	return (mask &amp; (1 &lt;&lt; pos)) == 0;
}

void dfs(int dep, int s1, int s2, int s3, int current) {
	if (current &gt;= (1 &lt;&lt; m)) return;
	if (current == (1 &lt;&lt; m) - 1) {
		dp[nxt][s2][s3] = (dp[nxt][s2][s3] + dp[cur][initJ][initK]) % MOD;
		return;
	}
	if (s1 &amp; (1 &lt;&lt; dep)) {
		dfs(dep + 1, s1, s2, s3, current);
	} else {
		// ### &lt;- dep
		//   #
		if (dep + 1 &lt; m &amp;&amp; valid(s2, dep) &amp;&amp; valid(s3, dep) &amp;&amp; valid(s3, dep + 1)) {
			dfs(dep + 1, s1, s2 | (1 &lt;&lt; dep), s3 | (1 &lt;&lt; dep) | (1 &lt;&lt; (dep + 1)), current | (1 &lt;&lt; dep));
		}
		//   # 
		// ### &lt;- dep
		if (dep &gt;= 1 &amp;&amp; valid(s2, dep) &amp;&amp; valid(s3, dep) &amp;&amp; valid(s3, dep - 1)) {
			dfs(dep + 1, s1, s2 | (1 &lt;&lt; dep), s3 | (1 &lt;&lt; dep) | (1 &lt;&lt; (dep - 1)), current | (1 &lt;&lt; dep));
		}
		// #   &lt;- dep
		// ###
		if (dep + 1 &lt; m &amp;&amp; valid(s1, dep + 1) &amp;&amp; valid(s2, dep + 1) &amp;&amp; valid(s3, dep + 1)) {
			dfs(dep + 2, s1, s2 | (1 &lt;&lt; (dep + 1)), s3 | (1 &lt;&lt; (dep + 1)), current | (1 &lt;&lt; dep) | (1 &lt;&lt; (dep + 1)));
		}
		// ### &lt;- dep
		// #  
		if (dep + 1 &lt; m &amp;&amp; valid(s1, dep + 1) &amp;&amp; valid(s2, dep) &amp;&amp; valid(s3, dep)) {
			dfs(dep + 2, s1, s2 | (1 &lt;&lt; dep), s3 | (1 &lt;&lt; dep), current | (1 &lt;&lt; dep) | (1 &lt;&lt; (dep + 1)));
		}
		// ## &lt;- dep
		//  #
		//  #
		if (dep + 2 &lt; m &amp;&amp; valid(s2, dep) &amp;&amp; valid(s2, dep + 1) &amp;&amp; valid(s2, dep + 2)) {
			dfs(dep + 1, s1, s2 | (1 &lt;&lt; dep) | (1 &lt;&lt; (dep + 1)) | (1 &lt;&lt; (dep + 2)), s3, current | (1 &lt;&lt; dep));
		}
		//  #
		//  #
		// ## &lt;- dep
		if (dep &gt;= 2 &amp;&amp; valid(s2, dep) &amp;&amp; valid(s2, dep - 1) &amp;&amp; valid(s2, dep - 2)) {
			dfs(dep + 1, s1, s2 | (1 &lt;&lt; (dep - 2)) | (1 &lt;&lt; (dep - 1)) | (1 &lt;&lt; dep), s3, current | (1 &lt;&lt; dep));
		}
		// ## &lt;- dep
		// #
		// #
		if (dep + 2 &lt; m &amp;&amp; valid(s2, dep) &amp;&amp; valid(s1, dep + 1) &amp;&amp; valid(s1, dep + 2)) {
			dfs(dep + 3, s1, s2 | (1 &lt;&lt; dep), s3, current | (1 &lt;&lt; dep) | (1 &lt;&lt; (dep + 1)) | (1 &lt;&lt; (dep + 2)));
		}
		// #  &lt;- dep
		// #
		// ##
		if (dep + 2 &lt; m &amp;&amp; valid(s1, dep + 1) &amp;&amp; valid(s1, dep + 2) &amp;&amp; valid(s2, dep + 2)) {
			dfs(dep + 3, s1, s2 | (1 &lt;&lt; (dep + 2)), s3, current | (1 &lt;&lt; dep) | (1 &lt;&lt; (dep + 1)) | (1 &lt;&lt; (dep + 2)));
		}
	}
}

char str[10];
int main() {
	int ts;
	scanf("%d", &amp;ts);
	while (ts--) {
		memset(state, 0, sizeof(state));
		scanf("%d%d", &amp;n, &amp;m);
		for (int i = 1; i &lt;= n; i++) {
			scanf("%s", str);
			for (int j = 0; j &lt; m; j++) {
				if (str[j] == '#') {
					state[i] |= (1 &lt;&lt; j);
				}
			}
		}
		if (n == 1) {
			if (state[1] == (1 &lt;&lt; m) - 1) puts("1");
			else puts("0");
			continue;
		}

		memset(dp, 0, sizeof(dp));
		dp[2][state[1]][state[2]] = 1;
		for (int i = 2; i &lt;= n; i++) {
			cur = i, nxt = i + 1;
			for (int j = 0; j &lt; (1 &lt;&lt; m); j++) {
				for (int k = 0; k &lt; (1 &lt;&lt; m); k++) {
					if (dp[cur][j][k] == 0) continue;
					initJ = j; initK = k;
					dfs(0, j, k, state[i + 1], j);
				}
			}
		}
		cout &lt;&lt; dp[n + 1][(1 &lt;&lt; m) - 1][0] &lt;&lt; endl;
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.287
hard
----------
PROBLEM STATEMENT:
Sophia has discovered several alien languages. Suprisingly, all of these languages have an alphabet, and each of them may contain thousands of characters! Also, all the words in a language have the same number of characters in it.

However, the aliens like their words to be aesthetically pleasing, which for them means that for the [expression]):


if [expression] letter may be the last letter of a word, or it may be immediately followed by any letter, including itself.
if [expression].  


Sophia wants to know how many different words exist in this language. Since the result may be large, she wants to know this number, modulo [expression].
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

#define mod 100000007

int a[500005];
inline void ADD(int &amp; x, int y) {
    x += y; if (x &gt;= mod) x -= mod;
}
int S(int l, int r) {
    int answer = 0;
    for (int i = l; i &lt;= r; i ++) {
        ADD(answer, a[i]);
    }
    return answer;
}
void calc(int n, vector&lt;int&gt; &amp; coeff) {
    // lo: [1..n/2]
    // hi: [n/2+1..n]
    a[0] = 0;
    for (int i = 1; i &lt;= n; i ++) {
        a[i] = 1;
    }
    coeff[1] = S(n/2+1, n);
    for (int le = 2; coeff[le - 1] != 0; le ++) {
        for (int i = 1; i &lt;= n; i ++) ADD(a[i], a[i - 1]);
        for (int i = n; i &gt;= 1; i --) {
            a[i] = a[i / 2];
        }
        coeff[le] = S(n/2+1, n);
    }
}

int v[500005];
int main() {
    int tc; cin &gt;&gt; tc;
    for (; tc &gt; 0; tc --) {
        int n, m;
        cin &gt;&gt; n &gt;&gt; m;
        vector&lt;int&gt; coeff (22);
        calc(n, coeff);
        v[0] = 1;
        for (int i = 1; i &lt;= m; i ++) {
            v[i] = 0;
            for (int k = 0; k &lt;= i and k &lt;= 20; k ++) {
                v[i] = (v[i] + (long long) v[i - k] * coeff[k]) % mod;
            }
        }
        cout &lt;&lt; v[m] &lt;&lt; endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.288
medium
----------
PROBLEM STATEMENT:
Your algorithms have become so good at predicting the market that you now know what the share price of Wooden Orange Toothpicks Inc. (WOT) will be for the next number of days.

Each day, you can either buy one share of WOT, sell any number of shares of WOT that you own, or not make any transaction at all. What is the maximum profit you can obtain with an optimum trading strategy?

For example, if you know that prices for the next two days are [expression], no profit can be made so you don't buy or sell stock those days.  

Function Description  

Complete the stockmax function in the editor below.  It must return an integer that represents the maximum profit achievable.  

stockmax has the following parameter(s):  


prices: an array of integers that represent predicted daily stock prices    

----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	int t;
	scanf("%d",&amp;t);
	while(t--)
	{
		long long int n,a[50005],i,idx,b[50005],sum=0;
		scanf("%lld",&amp;n);
		for(i=1;i&lt;=n;i++)
		{
			scanf("%lld",&amp;a[i]);
		}
		idx=n;
		b[n]=n;
		for(i=n-1;i&gt;0;i--)
		{
			if(a[idx]&lt;a[i])
			idx=i;
			b[i]=idx;
		}
		for(i=1;i&lt;=n;i++)
		{
			if((a[b[i]]-a[i])&gt;=0)
			sum+=(a[b[i]]-a[i]);
		}
		cout&lt;&lt;sum&lt;&lt;endl;
	}
}
----------
====================
----------
ALGORITHMS.289
medium
----------
PROBLEM STATEMENT:
You have a warehouse with [expression] piece of candy and transport it between any two containers.

The robots take instructions in the form of queries consisting of two integers, [expression] until it receives another query.   

Calculate the minimum total distance the robots must travel to execute [expression] queries in order. 

Note: You choose which robot executes each query.
----------
TOP SOLUTION:
----------
/*
-----------------------------------------------------------------------------
Author :            ---------------------------------------------------------
    UTKAR$H $AXENA  ---------------------------------------------------------
    IIT INDORE      ---------------------------------------------------------
-----------------------------------------------------------------------------
*/
#include&lt;bits/stdc++.h&gt;
#include&lt;iostream&gt;
using namespace std;
#define fre 	freopen("0.in","r",stdin);freopen("0.out","w",stdout)
#define abs(x) ((x)&gt;0?(x):-(x))
#define MOD 1000000007
#define fi first
#define se second
#define LL signed long long int
#define scan(x) scanf("%d",&amp;x)
#define print(x) printf("%d\n",x)
#define scanll(x) scanf("%lld",&amp;x)
#define printll(x) printf("%lld\n",x)
#define rep(i,from,to) for(int i=(from);i &lt;= (to); ++i)
#define pii pair&lt;int,int&gt;

vector&lt;int&gt; G[2*100000+5];
int fdp[1005][1005];
LL dp[1005][1005], T=0;
pii Q[1000+5];
LL cost(int i,int j){
	if(i==0)
		return abs(Q[j].fi-Q[j].se);
	return abs(Q[j].fi-Q[j].se) + abs(Q[j].fi-Q[i].se);
}
int N;
LL rec(int i,int j){
	if(i==N or j==N)return 0;
	if(fdp[i][j]==T)
		return dp[i][j];
	fdp[i][j] = T;
	int k = max(i,j) + 1;
	return dp[i][j] = min(rec(k,j)+cost(i,k),rec(i,k)+cost(j,k));
}
int main(){
	//fre;
	int t, M;
	cin&gt;&gt;t;
	while(t--){
		T++;
		cin&gt;&gt;M&gt;&gt;N;
		for(int i=1;i&lt;=N;++i){
			scan(Q[i].fi);
			scan(Q[i].se);
		}
		printll(rec(0,0));
	}
}

----------
====================
----------
ALGORITHMS.290
medium
----------
PROBLEM STATEMENT:
Given a tree T with n nodes, how many subtrees (T') of T have at most K edges connected to (T - T')? 
----------
TOP SOLUTION:
----------
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

#ifndef ONLINE_JUDGE
#define Eo(x) { cerr &lt;&lt; #x &lt;&lt; " = " &lt;&lt; (x) &lt;&lt; endl; }
#else
#define Eo(x)
#endif

typedef long long int64;
const int inf = 0x3f3f3f3f;
const int64 inf64 = 0x3f3f3f3f3f3f3f3fLL;
typedef double real;
const real eps = 1e-6;
typedef pair&lt;int,int&gt; pip;

template &lt;typename A,typename B&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const pair&lt;A,B&gt;&amp; p) {
	return os &lt;&lt; p.first &lt;&lt; "," &lt;&lt; p.second;
}

template &lt;typename A&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const vector&lt;A&gt;&amp; v) {
	for (int i = 0; i &lt; v.size(); i++) {
		os &lt;&lt; v[i] &lt;&lt; ';';
	}
	return os;
}

template &lt;typename A, typename B&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const map&lt;A,B&gt;&amp; m) {
  for (typename map&lt;A,B&gt;::const_iterator it = m.begin(); it != m.end(); ++it) {
    os &lt;&lt; it-&gt;first &lt;&lt; ":" &lt;&lt; it-&gt;second &lt;&lt; ";";
  }
  return os;
}

int64 gcd(int64 a, int64 b) {
	return a ? gcd(b%a,a) : b;
}

const int maxn = 52;
vector&lt;int&gt; g[maxn];
int n,k;
int64 res[maxn][maxn];
int64 d2[maxn][maxn];
int64 part[maxn][maxn];

void dfs(int v, int par) {
	//Eo(pip(v,par));
	for (int i = 0; i &lt; g[v].size(); i++) {
		int p = g[v][i];
		if (p == par) continue;
		dfs(p,v);
	}
	int z = 0;
	for (int i = 0; i &lt; g[v].size(); i++) {
		int p = g[v][i];
		if (p == par) continue;
		for (int j = 0; j &lt;= n; j++) {
			part[z][j] = res[p][j];
		}
		z++;
	}
	for (int i = 0; i &lt;= z; i++) {
		for (int j = 0; j &lt;= n; j++) {
			d2[i][j]=0;
		}
	}
	d2[0][0]=1;
	for (int i = 0; i &lt; z; i++) {
		for (int j = 0; j &lt;= n; j++) if (d2[i][j]) {
			d2[i+1][j+1] += d2[i][j];
			for (int k = 0; k+j &lt;= n; k++) {
				d2[i+1][j+k] += d2[i][j]*part[i][k];
			}
		}
	}
	for (int i = 0; i &lt;= n; i++) {
		res[v][i] = d2[z][i];
	}
}

int main() {
	cin &gt;&gt; n &gt;&gt; k;
	for (int i = 0; i &lt; n-1; i++) {
		int x,y; scanf("%d%d",&amp;x,&amp;y);
		x--;y--;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	dfs(0,-1);
	int64 sum = 1;
	for (int i = 0; i &lt;= k; i++) {
		sum += res[0][i];
	}
	for (int j = 1; j &lt; n; j++) {
		for (int i = 0; i &lt;= k-1; i++) {
			sum += res[j][i];
		}
	}
	cout &lt;&lt; sum &lt;&lt; endl;
#if 0
	for (int i =0; i &lt; n; i++) {
		for (int j = 0; j &lt;= n; j++) {
			printf("%d ",int(res[i][j]));
		}
		puts("");
	}
#endif
	return 0;
}

----------
====================
----------
ALGORITHMS.291
hard
----------
PROBLEM STATEMENT:
Tara has an array, [expression] times in the array. 

Let's define [expression].

You are given [expression], on a new line.

Note: Two permutations, [expression].
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MOD=1000000007;

int dp[2001][2001][2];

int rec(int one, int two, int ban)
{
    if(one==0 &amp;&amp; two==0)
        return 1;
    int&amp; ret=dp[one][two][ban];
    if(ret!=-1)
        return ret;
    ret=0;
    if(one&gt;0)
        ret=(ret+1LL*rec(one-1, two, 0)*(one-ban))%MOD;
    if(two&gt;0)
        ret=(ret+1LL*rec(one+1, two-1, 1)*two)%MOD;
    return ret;
}

int main()
{
    memset(dp, -1, sizeof dp);
    int Q;
    scanf("%d", &amp;Q);
    while(Q--)
    {
        int N;
        scanf("%d", &amp;N);
        map&lt;int, int&gt; m;
        for(int i=0; i&lt;N; i++)
        {
            int a;
            scanf("%d", &amp;a);
            m[a]++;
        }
        int one=0, two=0;
        for(auto&amp; it: m)
        {
            if(it.second==1)
                one++;
            else
                two++;
        }
        printf("%d\n", rec(one, two, 0));
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.292
medium
----------
PROBLEM STATEMENT:
One day, Wet Shark was given an array [expression]. As always, he started playing with its subsequences. 

When you came to know about this habit, you presented him a task of finding all pairs of subsequences, [expression] 


[expression].
[expression]
[expression]


Please help Wet Shark determine how many possible subsequences [expression]. 

Note: 


Two segments are different if there's exists at least one index [expression] is present in exactly one of them.
Both subsequences can overlap each other.
Subsequences do not necessarily have to be distinct

----------
TOP SOLUTION:
----------
#define _USE_MATH_DEFINES
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;cfloat&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;fstream&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;time.h&gt;
#include &lt;vector&gt;
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef pair&lt;int, int&gt; i_i;
typedef pair&lt;ll, int&gt; ll_i;
typedef pair&lt;double, int&gt; d_i;
typedef pair&lt;ll, ll&gt; ll_ll;
typedef pair&lt;double, double&gt; d_d;
struct edge { ll B, T, F, P; };

unsigned MOD = 1000000007;
ll _MOD = 1000000009;
double EPS = 1e-10;
int UNKO = INT_MAX;

int main() {
	int m, r, s; cin &gt;&gt; m &gt;&gt; r &gt;&gt; s;
	vector&lt;int&gt; x(m);
	for (int i = 0; i &lt; m; i++)
		cin &gt;&gt; x[i];
	if ((r + s) % 2 || r &lt; s) {
		cout &lt;&lt; 0 &lt;&lt; endl;
		return 0;
	}
	int A = (r + s) / 2, B = (r - s) / 2;
	vector&lt;vector&lt;ll&gt; &gt; dp(m + 1, vector&lt;ll&gt;(2001));
	dp[0][0] = 1;
	for (int i = 0; i &lt; m; i++) {
		vector&lt;vector&lt;ll&gt; &gt; _dp = dp;
		for (int j = 0; j + 1 &lt;= m; j++)
			for (int k = 0; k + x[i] &lt;= 2000; k++)
				_dp[j + 1][k + x[i]] = (_dp[j + 1][k + x[i]] + dp[j][k]) % MOD;
		dp = _dp;
	}
	ll a = 0, b = 0, ans = 0;
	for (int j = 1; j &lt;= m; j++) {
		a = dp[j][A] % MOD;
		b = dp[j][B] % MOD;
		ans = (ans + a * b) % MOD;
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}
----------
====================
----------
ALGORITHMS.293
medium
----------
PROBLEM STATEMENT:
Nikita just came up with a new array game. The rules are as follows:


Initially, Nikita has an array of integers.
In each move, Nikita must partition the array into [expression] point; otherwise, the game ends.
After each successful move, Nikita discards either the left partition or the right partition and continues playing by using the remaining partition as array [expression].


Nikita loves this game and wants your help getting the best score possible. Given [expression], can you find and print the maximum number of points she can score?

For example, Nikita starts with the array [expression].   

Function Description  

Complete the arraySplitting function in the editor below.  It should return an integer that reperesents the number of times Nikita can split the array.  

arraySplitting has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
//start of jonathanirvings' template v3.0.1 (BETA)

#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;deque&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;time.h&gt;
#include &lt;bitset&gt;
#include &lt;list&gt;
#include &lt;assert.h&gt;
#include &lt;time.h&gt;
using namespace std;

typedef long long LL;
typedef pair&lt;int,int&gt; pii;
typedef pair&lt;LL,LL&gt; pll;
typedef pair&lt;string,string&gt; pss;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef vector&lt;pii&gt; vii;
typedef vector&lt;LL&gt; vl;
typedef vector&lt;vl&gt; vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,"====TESTING====\n")
  #define VALUE(x) cerr &lt;&lt; "The value of " &lt;&lt; #x &lt;&lt; " is " &lt;&lt; x &lt;&lt; endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)&lt;(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)&lt;=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)&gt;=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)&lt;=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)&lt;=(c);++(a))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,"%lld",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,"%lld",&amp;res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf("%s",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  freopen ((s + ".in").c_str (), "r", stdin);
  freopen ((s + ".out").c_str (), "w", stdout);
}

//end of jonathanirvings' template v3.0.1 (BETA)

int data[17000];
int n;
int T;

int count(int L,int R)
{
  if (L == R) return 0;
  LL tot = 0;
  FORN(i,L,R) tot += data[i];
  if (tot % 2 == 1) return 0;
  LL now = 0;
  FORN(i,L,R)
  {
    now += data[i];
    if (now == tot/2)
    {
      return 1 + max(count(L,i),count(i+1,R));
    }
  }
  return 0;
}

int main()
{
  scanf("%d",&amp;T);
  TC(T)
  {
    scanf("%d",&amp;n);
    REP(i,n) scanf("%d",&amp;data[i]);
    int risan = count(0,n-1);
    printf("%d\n",risan);
  }
  return 0;
}










----------
====================
----------
ALGORITHMS.294
hard
----------
PROBLEM STATEMENT:
There are [expression]):


Choose an integer, [expression] (inclusive).
Remove the [expression]. You can choose to remove the ball from whichever end in each step maximizing the expected total number of white balls picked at the end.


Given a string describing the initial row of balls as a sequence of [expression].  
----------
TOP SOLUTION:
----------
package main
import ("bufio"; "fmt"; "io"; "os")

type Key struct {
	n, bits int32
}

var cache = make(map[Key]float64)

func score(N, K, bits int32) float64 {
	key := Key{ N, bits }
	if s, done := cache[key]; done {
		return s
	}
	total := 0.0
	for i := int32(0); 2 * i &lt; N; i++ {
		add := 0.0
		for _, j := range [2]int32{ i, N - 1 - i } {
			a := 0.0
			if (bits &gt;&gt; uint(j)) &amp; 1 != 0 {
				a = 1.0
			}
			if K &gt; 1 {
				mask := (int32(1) &lt;&lt; uint(j)) - 1
				b := bits &amp; mask | (bits &gt;&gt; 1) &amp;^ mask
				a += score(N - 1, K - 1, b)
			}
			if a &gt; add {
				add = a
			}
		}
		if 2 * i + 1 == N {
			total += add
		} else {
			total += 2 * add
		}
	}
	s := total / float64(N)
	cache[key] = s
	return s
}

func main() {
	N := int32(ScanInt(1, 29))
	K := int32(ScanInt(1, int(N)))
	NewLine()
	s := ScanString(int(N), int(N))
	bits := int32(0)
	for n := int32(0); n &lt; N; n++ {
		c := s[n]
		if c == 'W' {
			bits = 2 * bits + 1
		} else {
			Assert(c == 'B')
			bits = 2 * bits
		}
	}
	fmt.Printf("%.10f\n", score(N, K, bits))
}

// Boilerplate

func Assert(condition bool, items... interface{}) {
	if !condition {
		panic("assertion failed: " + fmt.Sprint(items...))
	}
}

func Log(items... interface{}) {
	fmt.Println(items...)
}

var Input = bufio.NewReader(os.Stdin)

func ReadByte() byte {
	b, e := Input.ReadByte()
	if e != nil {
		panic(e)
	}
	return b
}

func MaybeReadByte() (byte, bool) {
	b, e := Input.ReadByte()
	if e != nil {
		if e == io.EOF {
			return 0, false
		}
		panic(e)
	}
	return b, true
}

func UnreadByte() {
	e := Input.UnreadByte()
	if e != nil {
		panic(e)
	}
}

func NewLine() {
	for {
		b := ReadByte()
		switch b {
		case ' ', '\t', '\r':
			// keep looking
		case '\n':
			return
		default:
			panic(fmt.Sprintf("expecting newline, but found character &lt;%c&gt;", b))
		}
	}
}

func ScanInt(low, high int) int {
	return int(ScanInt64(int64(low), int64(high)))
}

func ScanUint(low, high uint) uint {
	return uint(ScanUint64(uint64(low), uint64(high)))
}

func ScanInt64(low, high int64) int64 {
	Assert(low &lt;= high)
	for {
		b := ReadByte()
		switch b {
		case ' ', '\t', '\r':
			// keep looking
		case '\n':
			panic(fmt.Sprintf(
				"unexpected newline; expecting range %d..%d", low, high))
		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
			if high &lt; 0 {
				panic(fmt.Sprintf(
					"found &lt;%c&gt; but expecting range %d..%d", b, low, high))
			}
			lw := low
			if lw &lt; 0 {
				lw = 0
			}
			UnreadByte()
			x, e := _scanu64(uint64(lw), uint64(high))
			if e != "" {
				panic(fmt.Sprintf("%s %d..%d", e, low, high))
			}
			return int64(x)
		case '-':
			if low &gt; 0 {
				panic(fmt.Sprintf(
					"found minus sign but expecting range %d..%d", low, high))
			}
			h := high
			if h &gt; 0 {
				h = 0
			}
			x, e := _scanu64(uint64(-h), uint64(-low))
			if e != "" {
				panic(fmt.Sprintf( "-%s %d..%d", e, low, high))
			}
			return -int64(x)
		default:
			panic(fmt.Sprintf(
				"unexpected character &lt;%c&gt;; expecting range %d..%d", b, low, high))
		}
	}
}

func ScanUint64(low, high uint64) uint64 {
	Assert(low &lt;= high)
	for {
		b := ReadByte()
		switch b {
		case ' ', '\t', '\r':
			// keep looking
		case '\n':
			panic(fmt.Sprintf(
				"unexpected newline; expecting range %d..%d", low, high))
		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
			UnreadByte()
			x, e := _scanu64(low, high)
			if e != "" {
				panic(fmt.Sprintf("%s %d..%d", e, low, high))
			}
			return x
		default:
			panic(fmt.Sprintf(
				"unexpected character &lt;%c&gt;; expecting range %d..%d", b, low, high))
		}
	}
}

func _scanu64(low, high uint64) (result uint64, err string) {
	x := uint64(0)
	buildnumber: for {
		b, ok := MaybeReadByte()
		if !ok {
			break buildnumber
		}
		switch b {
		case ' ', '\t', '\r':
			break buildnumber
		case '\n':
			UnreadByte()
			break buildnumber
		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
			d := uint64(b - '0')
			if (high - d) / 10 &lt; x {
				return x, fmt.Sprintf("%d%c... not in range", x, b)
			}
			x = x * 10 + d
		default:
			return x, fmt.Sprintf("%d%c found; expecting range", x, b)
		}
	}
	if x &lt; low || x &gt; high {
		return x, fmt.Sprintf("%d not in range", x)
	}
	return x, ""
}

func ScanBytes(short, long int) []byte {
	Assert(1 &lt;= short &amp;&amp; short &lt;= long)
	var b byte
	buf := make([]byte, long)
	skipws: for {
		b = ReadByte()
		switch b {
		case ' ', '\t', '\r':
			// keep looking
		case '\n':
			panic(fmt.Sprintf("unexpected newline; expecting string"))
		default:
			break skipws
		}
	}
	buf[0] = b
	length := 1
	buildstring: for {
		var ok bool
		b, ok = MaybeReadByte()
		if !ok {
			break buildstring
		}
		switch b {
		case ' ', '\t', '\r':
			break buildstring
		case '\n':
			UnreadByte()
			break buildstring
		default:
			if length &gt;= long {
				panic(fmt.Sprintf("string length not in range %d..%d", short, long))
			}
			buf[length] = b
			length++
		}
	}
	if length &lt; short {
		panic(fmt.Sprintf("string length not in range %d..%d", short, long))
	}
	return buf[:length]
}

func ScanString(short, long int) string {
	return string(ScanBytes(short, long))
}

----------
====================
----------
ALGORITHMS.295
medium
----------
PROBLEM STATEMENT:
The evil forest is guarded by vicious mandragoras. Garnet and her pet must make a journey through.  She starts with [expression] experience points.    

As she encouters each mandragora, her choices are:


Garnet's pet eats mandragora [expression].  
Garnet's pet battles mandragora [expression]. 


Once she defeats a mandragora, it is out of play.  Given a list of mandragoras with various health levels, determine the maximum number of experience points she can collect on her journey.  

For example, as always, she starts out with [expression]attle.  We have the following permutations of choices and outcomes:

Action  s   p
_______ _   __
e, e, e 4   0
e, e, b 3   15
e, b, b 2   14
b, b, b 1   10
b, b, e 2   10
b, e, e 3   9
b, e, b 2   16
e, b, e 3   6


Working through a couple of rows, first, her pet can eat all three and she does not gain any experience points.  In the second row, her pet eats the first two to have [expression] experience points.

Function Description  

Complete the mandragora function in the editor below.  It must return an integer that denotes the maximum number of experience points that Garnet can earn.

mandragora has the following parameter(s):  


H: an array of integers that represents the health values of mandragoras  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

#define pb push_back
#define mp make_pair
#define REP(i, n) for (int i = 0; i &lt; (int)(n); ++i)
typedef long long LL;
typedef pair&lt;int, int&gt; PII;

int tt, n;
int a[100000];
LL sum[100001];

int main() {
    scanf("%d", &amp;tt);
    REP(test, tt) {
        scanf("%d", &amp;n);
        REP(i, n) scanf("%d", a + i);
        sort(a, a + n);
        sum[n] = 0;
        for (int i = n - 1; i &gt;= 0; --i) {
            sum[i] = sum[i + 1] + a[i];
        }
        LL ans = 0;
        REP(i, n) {
            ans = max(ans, (i + 1) * sum[i]);
        }
        printf("%lld\n", ans);
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.296
medium
----------
PROBLEM STATEMENT:
Red John has committed another murder. This time, he doesn't leave a red smiley behind. Instead he leaves a puzzle for Patrick Jane to solve. He also texts Teresa Lisbon that if Patrick is successful, he will turn himself in. The puzzle begins as follows.  

There is a wall of size 4xn in the victim's house. The victim has an infinite supply of bricks of size 4x1 and 1x4 in her house. There is a hidden safe which can only be opened by a particular configuration of bricks. First we must calculate the total number of ways in which the bricks can be arranged so that the entire wall is covered.  The following diagram shows how bricks might be arranged to cover walls where [expression]:



There is one more step to the puzzle.  Call the number of possible arrangements [expression].  

As an example, assume [expression].

A more complex example is [expression].



Function Description  

Complete the redJohn function in the editor below.  It should return the number of primes determined, as an integer.  

redJohn has the following parameter(s):  


n: an integer that denotes the length of the wall  

----------
TOP SOLUTION:
----------

  <div id="main-frame-error" class="interstitial-wrapper" jstcache="0">
    <div id="main-content" jstcache="0">
      <div class="icon icon-generic" jseval="updateIconClass(this.classList, iconClass)" alt="" jstcache="1"></div>
      <div id="main-message" jstcache="0">
        <h1 jstcache="0">
          <span jsselect="heading" jsvalues=".innerHTML:msg" jstcache="10">This <span jscontent="hostName" jstcache="23">www.hackerrank.com</span> page can’t be found</span>
          <a id="error-information-button" class="hidden" onclick="toggleErrorInformationPopup();" jstcache="0"></a>
        </h1>
        <p jsselect="summary" jsvalues=".innerHTML:msg" jstcache="2">No webpage was found for the web address: <strong jscontent="failedUrl" jstcache="24">https://www.hackerrank.com/rest/contests/master/challenges/red-john-is-back/hackers/_/download_solution?primary=true</strong></p>
        <!--The suggestion list and error code are normally presented inline,
          in which case error-information-popup-* divs have no effect. When
          error-information-popup-container has the use-popup-container class, this
          information is provided in a popup instead.-->
        <div id="error-information-popup-container" jstcache="0">
          <div id="error-information-popup" jstcache="0">
            <div id="error-information-popup-box" jstcache="0">
              <div id="error-information-popup-content" jstcache="0">
                <div id="suggestions-list" style="display:none" jsdisplay="(suggestionsSummaryList &amp;&amp; suggestionsSummaryList.length)" jstcache="17">
                  <p jsvalues=".innerHTML:suggestionsSummaryListHeader" jstcache="19"></p>
                  <ul jsvalues=".className:suggestionsSummaryList.length == 1 ? 'single-suggestion' : ''" jstcache="20">
                    <li jsselect="suggestionsSummaryList" jsvalues=".innerHTML:summary" jstcache="22"></li>
                  </ul>
                </div>
                <div class="error-code" jscontent="errorCode" jstcache="18">HTTP ERROR 404</div>
                <p id="error-information-popup-close" jstcache="0">
                  <a class="link-button" jscontent="closeDescriptionPopup" onclick="toggleErrorInformationPopup();" jstcache="21">null</a>
                </p>
              </div>
            </div>
          </div>
        </div>
        <div id="diagnose-frame" class="hidden" jstcache="0"></div>
        <div id="download-links-wrapper" class="hidden" jstcache="0">
          <div id="download-link-wrapper" jstcache="0">
            <a id="download-link" class="link-button" onclick="downloadButtonClick()" jsselect="downloadButton" jscontent="msg" jsvalues=".disabledText:disabledMsg" jstcache="7" style="display: none;">
            </a>
          </div>
          <div id="download-link-clicked-wrapper" class="hidden" jstcache="0">
            <div id="download-link-clicked" class="link-button" jsselect="downloadButton" jscontent="disabledMsg" jstcache="12" style="display: none;">
            </div>
          </div>
        </div>
        <div id="save-page-for-later-button" class="hidden" jstcache="0">
          <a class="link-button" onclick="savePageLaterClick()" jsselect="savePageLater" jscontent="savePageMsg" jstcache="11" style="display: none;">
          </a>
        </div>
        <div id="cancel-save-page-button" class="hidden" onclick="cancelSavePageClick()" jsselect="savePageLater" jsvalues=".innerHTML:cancelMsg" jstcache="5" style="display: none;">
        </div>
        <div id="offline-content-list" class="list-hidden" hidden="" jstcache="0">
          <div id="offline-content-list-visibility-card" onclick="toggleOfflineContentListVisibility(true)" jstcache="0">
            <div id="offline-content-list-title" jsselect="offlineContentList" jscontent="title" jstcache="13" style="display: none;">
            </div>
            <div jstcache="0">
              <div id="offline-content-list-show-text" jsselect="offlineContentList" jscontent="showText" jstcache="15" style="display: none;">
              </div>
              <div id="offline-content-list-hide-text" jsselect="offlineContentList" jscontent="hideText" jstcache="16" style="display: none;">
              </div>
            </div>
          </div>
          <div id="offline-content-suggestions" jstcache="0"></div>
          <div id="offline-content-list-action" jstcache="0">
            <a class="link-button" onclick="launchDownloadsPage()" jsselect="offlineContentList" jscontent="actionText" jstcache="14" style="display: none;">
            </a>
          </div>
        </div>
      </div>
    </div>
    <div id="buttons" class="nav-wrapper suggested-right" jstcache="0">
      <div id="control-buttons" jstcache="0">
        <button id="reload-button" class="blue-button text-button" onclick="trackClick(this.trackingId);
                     reloadButtonClick(this.url);" jsselect="reloadButton" jsvalues=".url:reloadUrl; .trackingId:reloadTrackingId" jscontent="msg" jstcache="6">Reload</button>
        <button id="download-button" class="blue-button text-button" onclick="downloadButtonClick()" jsselect="downloadButton" jscontent="msg" jsvalues=".disabledText:disabledMsg" jstcache="7" style="display: none;">
        </button>
      </div>
      <button id="details-button" class="secondary-button text-button small-link" onclick="detailsButtonClick(); toggleHelpBox()" jscontent="details" jsdisplay="(suggestionsDetails &amp;&amp; suggestionsDetails.length > 0) || diagnose" jsvalues=".detailsText:details; .hideDetailsText:hideDetails;" jstcache="3" style="display: none;"></button>
    </div>
    <div id="details" class="hidden" jstcache="0">
      <div class="suggestions" jsselect="suggestionsDetails" jstcache="4" jsinstance="*0" style="display: none;">
        <div class="suggestion-header" jsvalues=".innerHTML:header" jstcache="8"></div>
        <div class="suggestion-body" jsvalues=".innerHTML:body" jstcache="9"></div>
      </div>
    </div>
  </div>
  <div id="sub-frame-error" jstcache="0">
    <!-- Show details when hovering over the icon, in case the details are
         hidden because they're too large. -->
    <div class="icon icon-generic" jseval="updateIconClass(this.classList, iconClass)" jstcache="1"></div>
    <div id="sub-frame-error-details" jsselect="summary" jsvalues=".innerHTML:msg" jstcache="2">No webpage was found for the web address: <strong jscontent="failedUrl" jstcache="24">https://www.hackerrank.com/rest/contests/master/challenges/red-john-is-back/hackers/_/download_solution?primary=true</strong></div>
  </div>

  <div id="offline-resources" jstcache="0">
    <img id="offline-resources-1x" src="data:image/png;base64,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" jstcache="0">
    <img id="offline-resources-2x" src="data:image/png;base64,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" jstcache="0">
    <template id="audio-resources" jstcache="0">
      <audio id="offline-sound-press" src="data:audio/mpeg;base64,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"></audio>
      <audio id="offline-sound-hit" src="data:audio/mpeg;base64,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"></audio>
      <audio id="offline-sound-reached" src="data:audio/mpeg;base64,T2dnUwACAAAAAAAAAABVDxppAAAAABYzHfUBHgF2b3JiaXMAAAAAAkSsAAD/////AHcBAP////+4AU9nZ1MAAAAAAAAAAAAAVQ8aaQEAAAC9PVXbEEf//////////////////+IDdm9yYmlzNwAAAEFPOyBhb1R1ViBiNSBbMjAwNjEwMjRdIChiYXNlZCBvbiBYaXBoLk9yZydzIGxpYlZvcmJpcykAAAAAAQV2b3JiaXMlQkNWAQBAAAAkcxgqRqVzFoQQGkJQGeMcQs5r7BlCTBGCHDJMW8slc5AhpKBCiFsogdCQVQAAQAAAh0F4FISKQQghhCU9WJKDJz0IIYSIOXgUhGlBCCGEEEIIIYQQQgghhEU5aJKDJ0EIHYTjMDgMg+U4+ByERTlYEIMnQegghA9CuJqDrDkIIYQkNUhQgwY56ByEwiwoioLEMLgWhAQ1KIyC5DDI1IMLQoiag0k1+BqEZ0F4FoRpQQghhCRBSJCDBkHIGIRGQViSgwY5uBSEy0GoGoQqOQgfhCA0ZBUAkAAAoKIoiqIoChAasgoAyAAAEEBRFMdxHMmRHMmxHAsIDVkFAAABAAgAAKBIiqRIjuRIkiRZkiVZkiVZkuaJqizLsizLsizLMhAasgoASAAAUFEMRXEUBwgNWQUAZAAACKA4iqVYiqVoiueIjgiEhqwCAIAAAAQAABA0Q1M8R5REz1RV17Zt27Zt27Zt27Zt27ZtW5ZlGQgNWQUAQAAAENJpZqkGiDADGQZCQ1YBAAgAAIARijDEgNCQVQAAQAAAgBhKDqIJrTnfnOOgWQ6aSrE5HZxItXmSm4q5Oeecc87J5pwxzjnnnKKcWQyaCa0555zEoFkKmgmtOeecJ7F50JoqrTnnnHHO6WCcEcY555wmrXmQmo21OeecBa1pjppLsTnnnEi5eVKbS7U555xzzjnnnHPOOeec6sXpHJwTzjnnnKi9uZab0MU555xPxunenBDOOeecc84555xzzjnnnCA0ZBUAAAQAQBCGjWHcKQjS52ggRhFiGjLpQffoMAkag5xC6tHoaKSUOggllXFSSicIDVkFAAACAEAIIYUUUkghhRRSSCGFFGKIIYYYcsopp6CCSiqpqKKMMssss8wyyyyzzDrsrLMOOwwxxBBDK63EUlNtNdZYa+4555qDtFZaa621UkoppZRSCkJDVgEAIAAABEIGGWSQUUghhRRiiCmnnHIKKqiA0JBVAAAgAIAAAAAAT/Ic0REd0REd0REd0REd0fEczxElURIlURIt0zI101NFVXVl15Z1Wbd9W9iFXfd93fd93fh1YViWZVmWZVmWZVmWZVmWZVmWIDRkFQAAAgAAIIQQQkghhRRSSCnGGHPMOegklBAIDVkFAAACAAgAAABwFEdxHMmRHEmyJEvSJM3SLE/zNE8TPVEURdM0VdEVXVE3bVE2ZdM1XVM2XVVWbVeWbVu2dduXZdv3fd/3fd/3fd/3fd/3fV0HQkNWAQASAAA6kiMpkiIpkuM4jiRJQGjIKgBABgBAAACK4iiO4ziSJEmSJWmSZ3mWqJma6ZmeKqpAaMgqAAAQAEAAAAAAAACKpniKqXiKqHiO6IiSaJmWqKmaK8qm7Lqu67qu67qu67qu67qu67qu67qu67qu67qu67qu67qu67quC4SGrAIAJAAAdCRHciRHUiRFUiRHcoDQkFUAgAwAgAAAHMMxJEVyLMvSNE/zNE8TPdETPdNTRVd0gdCQVQAAIACAAAAAAAAADMmwFMvRHE0SJdVSLVVTLdVSRdVTVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTdM0TRMIDVkJAJABAKAQW0utxdwJahxi0nLMJHROYhCqsQgiR7W3yjGlHMWeGoiUURJ7qihjiknMMbTQKSet1lI6hRSkmFMKFVIOWiA0ZIUAEJoB4HAcQLIsQLI0AAAAAAAAAJA0DdA8D7A8DwAAAAAAAAAkTQMsTwM0zwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQNI0QPM8QPM8AAAAAAAAANA8D/BEEfBEEQAAAAAAAAAszwM80QM8UQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwNE0QPM8QPM8AAAAAAAAALA8D/BEEfA8EQAAAAAAAAA0zwM8UQQ8UQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABDgAAAQYCEUGrIiAIgTADA4DjQNmgbPAziWBc+D50EUAY5lwfPgeRBFAAAAAAAAAAAAADTPg6pCVeGqAM3zYKpQVaguAAAAAAAAAAAAAJbnQVWhqnBdgOV5MFWYKlQVAAAAAAAAAAAAAE8UobpQXbgqwDNFuCpcFaoLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAABhwAAAIMKEMFBqyIgCIEwBwOIplAQCA4ziWBQAAjuNYFgAAWJYligAAYFmaKAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAGHAAAAgwoQwUGrISAIgCADAoimUBy7IsYFmWBTTNsgCWBtA8gOcBRBEACAAAKHAAAAiwQVNicYBCQ1YCAFEAAAZFsSxNE0WapmmaJoo0TdM0TRR5nqZ5nmlC0zzPNCGKnmeaEEXPM02YpiiqKhBFVRUAAFDgAAAQYIOmxOIAhYasBABCAgAMjmJZnieKoiiKpqmqNE3TPE8URdE0VdVVaZqmeZ4oiqJpqqrq8jxNE0XTFEXTVFXXhaaJommaommqquvC80TRNE1TVVXVdeF5omiapqmqruu6EEVRNE3TVFXXdV0giqZpmqrqurIMRNE0VVVVXVeWgSiapqqqquvKMjBN01RV15VdWQaYpqq6rizLMkBVXdd1ZVm2Aarquq4ry7INcF3XlWVZtm0ArivLsmzbAgAADhwAAAKMoJOMKouw0YQLD0ChISsCgCgAAMAYphRTyjAmIaQQGsYkhBJCJiWVlEqqIKRSUikVhFRSKiWjklJqKVUQUikplQpCKqWVVAAA2IEDANiBhVBoyEoAIA8AgCBGKcYYYwwyphRjzjkHlVKKMeeck4wxxphzzkkpGWPMOeeklIw555xzUkrmnHPOOSmlc84555yUUkrnnHNOSiklhM45J6WU0jnnnBMAAFTgAAAQYKPI5gQjQYWGrAQAUgEADI5jWZqmaZ4nipYkaZrneZ4omqZmSZrmeZ4niqbJ8zxPFEXRNFWV53meKIqiaaoq1xVF0zRNVVVVsiyKpmmaquq6ME3TVFXXdWWYpmmqquu6LmzbVFXVdWUZtq2aqiq7sgxcV3Vl17aB67qu7Nq2AADwBAcAoAIbVkc4KRoLLDRkJQCQAQBAGIOMQgghhRBCCiGElFIICQAAGHAAAAgwoQwUGrISAEgFAACQsdZaa6211kBHKaWUUkqpcIxSSimllFJKKaWUUkoppZRKSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoFAC5VOADoPtiwOsJJ0VhgoSErAYBUAADAGKWYck5CKRVCjDkmIaUWK4QYc05KSjEWzzkHoZTWWiyecw5CKa3FWFTqnJSUWoqtqBQyKSml1mIQwpSUWmultSCEKqnEllprQQhdU2opltiCELa2klKMMQbhg4+xlVhqDD74IFsrMdVaAABmgwMARIINqyOcFI0FFhqyEgAICQAgjFGKMcYYc8455yRjjDHmnHMQQgihZIwx55xzDkIIIZTOOeeccxBCCCGEUkrHnHMOQgghhFBS6pxzEEIIoYQQSiqdcw5CCCGEUkpJpXMQQgihhFBCSSWl1DkIIYQQQikppZRCCCGEEkIoJaWUUgghhBBCKKGklFIKIYRSQgillJRSSimFEEoIpZSSUkkppRJKCSGEUlJJKaUUQggllFJKKimllEoJoYRSSimlpJRSSiGUUEIpBQAAHDgAAAQYQScZVRZhowkXHoBCQ1YCAGQAAJSyUkoorVVAIqUYpNpCR5mDFHOJLHMMWs2lYg4pBq2GyjGlGLQWMgiZUkxKCSV1TCknLcWYSuecpJhzjaVzEAAAAEEAgICQAAADBAUzAMDgAOFzEHQCBEcbAIAgRGaIRMNCcHhQCRARUwFAYoJCLgBUWFykXVxAlwEu6OKuAyEEIQhBLA6ggAQcnHDDE294wg1O0CkqdSAAAAAAAAwA8AAAkFwAERHRzGFkaGxwdHh8gISIjJAIAAAAAAAYAHwAACQlQERENHMYGRobHB0eHyAhIiMkAQCAAAIAAAAAIIAABAQEAAAAAAACAAAABARPZ2dTAABARwAAAAAAAFUPGmkCAAAAZa2xyCElHh4dHyQvOP8T5v8NOEo2/wPOytDN39XY2P8N/w2XhoCs0CKt8NEKLdIKH63ShlVlwuuiLze+3BjtjfZGe0lf6As9ggZstNJFphRUtpUuMqWgsqrasj2IhOA1F7LFMdFaWzkAtNBFpisIQgtdZLqCIKjqAAa9WePLkKr1MMG1FlwGtNJFTSkIcitd1JSCIKsCAQWISK0Cyzw147T1tAK00kVNKKjQVrqoCQUVqqr412m+VKtZf9h+TDaaztAAtNRFzVEQlJa6qDkKgiIrc2gtfES4nSQ1mlvfMxfX4+b2t7ICVNGwkKiiYSGxTQtK1YArN+DgTqdjMwyD1q8dL6RfOzXZ0yO+qkZ8+Ub81WP+DwNkWcJhvlmWcJjvSbUK/WVm3LgxClkyiuxpIFtS5Gwi5FBkj2DGWEyHYBiLcRJkWnQSZGbRGYGZAHr6vWVJAWGE5q724ldv/B8Kp5II3dPvLUsKCCM0d7UXv3rj/1A4lUTo+kCUtXqtWimLssjIyMioViORobCJAQLYFnpaAACCAKEWAMCiQGqMABAIUKknAFkUIGsBIBBAHYBtgAFksAFsEySQgQDWQ4J1AOpiVBUHd1FE1d2IGDfGAUzmKiiTyWQyuY6Lx/W4jgkQZQKioqKuqioAiIqKwagqCqKiogYxCgACCiKoAAAIqAuKAgAgjyeICQAAvAEXmQAAmYNhMgDAZD5MJqYzppPpZDqMwzg0TVU9epXf39/9xw5lBaCpqJiG3VOsht0wRd8FgAeoB8APKOABQFT23GY0GgoAolkyckajHgBoZEYujQY+230BUoD/uf31br/7qCHLXLWwIjMIz3ZfgBTgf25/vdvvPmrIMlctrMgMwiwCAAB4FgAAggAAAM8CAEAgkNG0DgCeBQCAIAAAmEUBynoASKANMIAMNoBtAAlkMAGoAzKQgDoAdQYAKOoEANFgAoAyKwAAGIOiAACVBACyAAAAFYMDAAAyxyMAAMBMfgQAAMi8GAAACDfoFQAAYHgxACA16QiK4CoWcTcVAADDdNpc7AAAgJun080DAAAwPTwxDQAAxYanm1UFAAAVD0MsAA4AyCUztwBwBgAyQOTMTZYA0AAiySW3Clar/eRUAb5fPDXA75e8QH//jkogHmq1n5wqwPeLpwb4/ZIX6O/fUQnEgwf9fr/f72dmZmoaRUREhMLTADSVgCAgVLKaCT0tAABk2AFgAyQgEEDTSABtQiSQwQDUARksYBtAAgm2AQSQYBtAAuYPOK5rchyPLxAABFej4O7uAIgYNUYVEBExbozBGHdVgEoCYGZmAceDI0mGmZlrwYDHkQQAiLhxo6oKSHJk/oBrZgYASI4XAwDAXMMnIQAA5DoyDAAACa8AAMDM5JPEZDIZhiFJoN33vj4X6N19v15gxH8fAE1ERMShbm5iBYCOAAMFgAzaZs3ITURECAAhInKTNbNtfQDQNnuWHBERFgBUVa4iDqyqXEUc+AKkZlkmZCoJgIOBBaubqwoZ2SDNgJlj5MgsMrIV44xgKjCFYTS36QRGQafwylRZAhMXr7IEJi7+AqQ+gajAim2S1W/71ACEi4sIxsXVkSNDQRkgzGp6eNgMJDO7kiVXcmStkCVL0Ry0MzMgzRklI2dLliQNEbkUVFvaCApWW9oICq7rpRlKs2MBn8eVJRlk5JARjONMdGSYZArDOA0ZeKHD6+KN9oZ5MBDTCO8bmrptBBLgcnnOcBmk/KMhS2lL6rYRSIDL5TnDZZDyj4YspS3eIOoN9Uq1KIsMpp1gsU0gm412AISQyICYRYmsFQCQwWIgwWRCABASGRDawAKYxcCAyYQFgLhB1Rg17iboGF6v1+fIcR2TyeR4PF7HdVzHdVzHcYXPbzIAQNTFuBoVBQAADJOL15WBhNcFAADAI9cAAAAAAJAEmIsMAOBlvdTLVcg4mTnJzBnTobzDfKPRaDSaI1IAnUyHhr6LALxFo5FmyZlL1kAU5lW+LIBGo9lym1OF5ikAOsyctGkK8fgfAfgPIQDAvBLgmVsGoM01lwRAvCwAHje0zTiA/oUDAOYAHqv9+AQC4gEDMJ/bIrXsH0Ggyh4rHKv9+AQC4gEDMJ/bIrXsH0Ggyh4rDPUsAADAogBCk3oCQBAAAABBAAAg6FkAANCzAAAgBELTAACGQAAoGoFBFoWoAQDaBPoBQ0KdAQAAAK7iqkAVAABQNixAoRoAAKgE4CAiAAAAACAYow6IGjcAAAAAAPL4DfZ6kkZkprlkj6ACu7i7u5sKAAAOd7vhAAAAAEBxt6m6CjSAgKrFasUOAAAoAABic/d0EwPIBjAA0CAggABojlxzLQD+mv34BQXEBQvYH5sijDr0/FvZOwu/Zj9+QQFxwQL2x6YIow49/1b2zsI9CwAAeBYAAIBANGlSDQAABAEAAKBnIQEAeloAABgCCU0AAEMgAGQTYNAG+gCwAeiBIWMAGmYAAICogRg16gAAABB1gwVkNlgAAIDIGnCMOwIAAACAgmPA8CpgBgAAAIDMG/QbII/PLwAAaKN9vl4Pd3G6maoAAAAAapiKaQUAANPTxdXhJkAWXHBzcRcFAAAHAABqNx2YEQAHHIADOAEAvpp9fyMBscACmc9Lku7s1RPB+kdWs+9vJCAWWCDzeUnSnb16Ilj/CNOzAACAZwEAAAhEk6ZVAAAIAgAAQc8CAICeFgAAhiAAABgCAUAjMGgDPQB6CgCikmDIGIDqCAAAkDUQdzUOAAAAKg3WIKsCAABkFkAJAAAAQFzFQXh8QQMAAAAABCMCKEhAAACAkXcOo6bDxCgqOMXV6SoKAAAAoGrabDYrAAAiHq5Ww80EBMiIi01tNgEAAAwAAKiHGGpRQADUKpgGAAAOEABogFFAAN6K/fghBIQ5cH0+roo0efVEquyBaMV+/BACwhy4Ph9XRZq8eiJV9kCQ9SwAAMCiAGhaDwAIAgAAIAgAAAQ9CwAAehYAAIQgAAAYAgGgaAAGWRTKBgBAG4AMADI2ANVFAAAAgKNqFKgGAACKRkpQqAEAgCKBAgAAAIAibkDFuDEAAAAAYODzA1iQoAEAAI3+ZYOMNls0AoEdN1dPiwIAgNNp2JwAAAAAYHgaLoa7QgNwgKeImAoAAA4AALU5XNxFoYFaVNxMAQCAjADAAQaeav34QgLiAQM4H1dNGbXoH8EIlT2SUKr14wsJiAcM4HxcNWXUon8EI1T2SEJMzwIAgJ4FAAAgCAAAhCAAABD0LAAA6GkBAEAIAgCAIRAAqvUAgywK2QgAyKIAoBEYAiGqCQB1BQAAqCNAmQEAAOqGFZANCwAAoBpQJgAAAKDiuIIqGAcAAAAA3Ig64LgoAADQHJ+WmYbJdMzQBsGuVk83mwIAAAIAgFNMV1cBUz1xKAAAgAEAwHR3sVldBRxAQD0d6uo0FAAADAAA6orNpqIAkMFqqMNAAQADKABkICgAfmr9+AUFxB0ANh+vita64VdPLCP9acKn1o9fUEDcAWDz8aporRt+9cQy0p8mjHsWAADwLAAAAEEAAAAEAQCAoGchAAD0LAAADIHQpAIADIEAUCsSDNpACwA2AK2EIaOVgLoCAACUBZCVAACAKBssIMqGFQAAoKoAjIMLAAAAAAgYIyB8BAUAAAAACPMJkN91ZAAA5O6kwzCtdAyIVd0cLi4KAAAAIFbD4uFiAbW5mu42AAAAAFBPwd1DoIEjgNNF7W4WQAEABwACODxdPcXIAAIHAEEBflr9/A0FxAULtD9eJWl006snRuXfq8Rp9fM3FBAXLND+eJWk0U2vnhiVf68STM8CAACeBQAAIAgAAIAgAAAQ9CwAAOhpAQBgCITGOgAwBAJAYwYYZFGoFgEAZFEAKCsBhkDIGgAoqwAAAFVAVCUAAKhU1aCIhgAAIMoacKNGVAEAAABwRBRQXEUUAAAAABUxCGAMRgAAAABNpWMnaZOWmGpxt7kAAAAAIBimq9pAbOLuYgMAAAAAww0300VBgAMRD0+HmAAAZAAAAKvdZsNUAAcoaAAgA04BXkr9+EIC4gQD2J/XRWjmV0/syr0xpdSPLyQgTjCA/XldhGZ+9cSu3BvD9CwAAOBZAAAAggAAAAgCgAQIehYAAPQsAAAIQQAAMAQCQJNMMMiiUDTNBABZFACyHmBIyCoAACAKoCIBACCLBjMhGxYAACCzAhQFAAAAYMBRFMUYAwAAAAAorg5gPZTJOI4yzhiM0hI1TZvhBgAAAIAY4mZxNcBQV1dXAAAAAAA3u4u7h4ICIYOni7u7qwGAAqAAAIhaHKI2ICCGXe2mAQBAgwwAAQIKQK6ZuREA/hm9dyCg9xrQforH3TSBf2dENdKfM5/RewcCeq8B7ad43E0T+HdGVCP9OWN6WgAA5CkANERJCAYAAIBgAADIAD0LAAB6WgAAmCBCUW8sAMAQCEBqWouAQRZFaigBgDaBSBgCIeoBAFkAwAiou6s4LqqIGgAAKMsKKKsCAAColIgbQV3ECAAACIBRQVzVjYhBVQEAAADJ55chBhUXEQEAIgmZOXNmTSNLthmTjNOZM8cMw2RIa9pdPRx2Q01VBZGNquHTq2oALBfQxKcAh/zVDReL4SEqIgBAbqcKYhiGgdXqblocygIAdL6s7qbaDKfdNE0FAQ4AVFVxeLi7W51DAgIAAwSWDoAPoHUAAt6YvDUqoHcE7If29ZNi2H/k+ir/85yQNiZvjQroHQH7oX39pBj2H7m+yv88J6QWi7cXgKFPJtNOABIEEGVEvUljJckAbdhetBOgpwFkZFbqtWqAUBgysL2AQR2gHoDYE3Dld12P18HkOuY1r+M4Hr/HAAAVBRejiCN4HE/QLOAGPJhMgAJi1BhXgwCAyZUCmOuHZuTMkTUia47sGdIs2TPajKwZqUiTNOKl/1fyvHS8fOn/1QGU+5U0SaOSzCxpmiNntsxI0LhZ+/0dmt1CVf8HNAXKl24AoM0D7jsIAMAASbPkmpvssuTMktIgALMAUESaJXuGzCyZQQBwgEZl5JqbnBlvgIyT0TAdSgG+6Px/rn+NclEGFGDR+f9c/xrlogwoAKjPiKKfIvRhGKYgzZLZbDkz2hC4djgeCVkXEKJlXz1uAosCujLkrDz6p0CZorVVOjvIQOAp3aVcLyCErGACSRKImCRMETeKzA6cFNd2X3KG1pyLgOnTDtnHXMSpVY1A6IXSjlNoh70ubc2VzXgfgd6uEQOBEmCt1O4wOHBQB2ANvtj8f65/jXKiAkiwWGz+P9e/RjlRASRYAODhfxqlH5QGhuxAobUGtOqEll3GqBEhYLIJQLMr6oQooHFcGpIsDK4yPg3UfMJtO/hTFVma3lrt+JI/EFBxbvlT2OiH0mhEfBofQDudLtq0lTiGSOKaVl6peD3XTDACuSXYNQAp4JoD7wjgUAC+2Px/rn+NcqIMKDBebP4/179GOVEGFBgDQPD/fxBW4I7k5DEgDtxdcwFpcNNx+JoDICRCTtO253ANTbn7DmF+TXalagLadQ23yhGw1Pj7SzpOajGmpeeYyqUY1/Y6KfuTVOU5cvu0gW2boGlMfFv5TejrOmkOl0iEpuQMpAYBB09nZ1MABINhAAAAAAAAVQ8aaQMAAAB/dp+bB5afkaKgrlp+2Px/rn+NchECSMBh8/+5/jXKRQggAQAI/tMRHf0LRqDj05brTRlASvIy1PwPFcajBhcoY0BtuEqvBZw0c0jJRaZ4n0f7fOKW0Y8QZ/M7xFeaGJktZ2ePGFTOLl4XzRCQMnJET4bVsFhMiiHf5vXtJ9vtMsf/Wzy030v3dqzCbkfN7af9JmpkTSXXICMpLAVO16AZoAF+2Px/rn91uQgGDOCw+f9c/+pyEQwYAACCH51SxFCg6SCEBi5Yzvla/iwJC4ekcPjs4PTWuY3tqJ0BKbo3cSYE4Oxo+TYjMXbYRhO+7lamNITiY2u0SUbFcZRMTaC5sUlWteBp+ZP4wUl9lzksq8hUQ5JOZZBAjfd98+8O6pvScEnEsrp/Z5BczwfWpkx5PwQ37EoIH7fMBgYGgusZAQN+2Px/rn91uQgGFOCw+f9c/+pyEQwoAPD/I8YfOD1cxsESTiLRCq0XjEpMtryCW+ZYCL2OrG5/pdkExMrQmjY9KVY4h4vfDR0No9dovrC2mxka1Pr0+Mu09SplWO6YXqWclpXdoVKuagQllrWfCaGA0R7bvLk41ZsRTBiieZFaqyFRFbasq0GwHT0MKbUIB2QAftj8f65/NbkIAQxwOGz+P9e/mlyEAAY4gEcfPYMyMh8UBxBogIAtTU0qrERaVBLhCkJQ3MmgzZNrxplCg6xVj5AdH8J2IE3bUNgyuD86evYivJmI+NREqmWbKqosI6xblSnNmJJUum+0qsMe4o8fIeCXELdErT52+KQtXSIl3XJNKOKv3BnKtS2cKmmnGpCqP/5YNQ9MCB2P8VUnCJiYDEAAXrj8f65/jXIiGJCAwuX/c/1rlBPBgAQA/ymlCDEi+hsNB2RoT865unFOQZiOpcy11YPQ6BiMettS0AZ0JqI4PV/Neludd25CqZDuiL82RhzdohJXt36nH+HlZiHE5ILqVSQL+T5/0h9qFzBVn0OFT9herDG3XzXz299VNY2RkejrK96EGyybKbXyG3IUUv5QEvq2bAP5CjJa9IiDeD5OOF64/H8uf3W5lAAmULj8fy5/dbmUACYAPEIfUcpgMGh0GgjCGlzQcHwGnb9HCrHg86LPrV1SbrhY+nX/N41X2DMb5NsNtkcRS9rs95w9uDtvP+KP/MupnfH3yHIbPG/1zDBygJimTvFcZywqne6OX18E1zluma5AShnVx4aqfxLo6K/C8P2fxH5cuaqtqE3Lbru4hT4283zc0Hqv2xINtisxZXBVfQuOAK6kCHjBAF6o/H+uf09ycQK6w6IA40Ll/3P9e5KLE9AdFgUYAwAAAgAAgDD4g+AgXAEEyAAEoADiPAAIcHGccHEAxN271+bn5+dt4B2YmGziAIrZMgZ4l2nedkACHggIAA=="></audio>
    </template>
  </div>


<script jstcache="0">// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This file defines a singleton which provides access to all data
 * that is available as soon as the page's resources are loaded (before DOM
 * content has finished loading). This data includes both localized strings and
 * any data that is important to have ready from a very early stage (e.g. things
 * that must be displayed right away).
 *
 * Note that loadTimeData is not guaranteed to be consistent between page
 * refreshes (https://crbug.com/740629) and should not contain values that might
 * change if the page is re-opened later.
 */

// #import {assert} from './assert.m.js';
// #import {parseHtmlSubset} from './parse_html_subset.m.js';

/**
 * @typedef {{
 *   substitutions: (Array<string>|undefined),
 *   attrs: (Object<function(Node, string):boolean>|undefined),
 *   tags: (Array<string>|undefined),
 * }}
 */
/* #export */ let SanitizeInnerHtmlOpts;

// eslint-disable-next-line no-var
/* #export */ /** @type {!LoadTimeData} */ var loadTimeData;

// Expose this type globally as a temporary work around until
// https://github.com/google/closure-compiler/issues/544 is fixed.
/** @constructor */
function LoadTimeData(){}

(function() {
  'use strict';

  LoadTimeData.prototype = {
    /**
     * Sets the backing object.
     *
     * Note that there is no getter for |data_| to discourage abuse of the form:
     *
     *     var value = loadTimeData.data()['key'];
     *
     * @param {Object} value The de-serialized page data.
     */
    set data(value) {
      expect(!this.data_, 'Re-setting data.');
      this.data_ = value;
    },

    /**
     * Returns a JsEvalContext for |data_|.
     * @returns {JsEvalContext}
     */
    createJsEvalContext: function() {
      return new JsEvalContext(this.data_);
    },

    /**
     * @param {string} id An ID of a value that might exist.
     * @return {boolean} True if |id| is a key in the dictionary.
     */
    valueExists: function(id) {
      return id in this.data_;
    },

    /**
     * Fetches a value, expecting that it exists.
     * @param {string} id The key that identifies the desired value.
     * @return {*} The corresponding value.
     */
    getValue: function(id) {
      expect(this.data_, 'No data. Did you remember to include strings.js?');
      const value = this.data_[id];
      expect(typeof value != 'undefined', 'Could not find value for ' + id);
      return value;
    },

    /**
     * As above, but also makes sure that the value is a string.
     * @param {string} id The key that identifies the desired string.
     * @return {string} The corresponding string value.
     */
    getString: function(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'string');
      return /** @type {string} */ (value);
    },

    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument.
     * @param {string} id The ID of the string we want.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    getStringF: function(id, var_args) {
      const value = this.getString(id);
      if (!value) {
        return '';
      }

      const args = Array.prototype.slice.call(arguments);
      args[0] = value;
      return this.substituteString.apply(this, args);
    },

    /**
     * Make a string safe for use with with Polymer bindings that are
     * inner-h-t-m-l (or other innerHTML use).
     * @param {string} rawString The unsanitized string.
     * @param {SanitizeInnerHtmlOpts=} opts Optional additional allowed tags and
     *     attributes.
     * @return {string}
     */
    sanitizeInnerHtml: function(rawString, opts) {
      opts = opts || {};
      return parseHtmlSubset('<b>' + rawString + '</b>', opts.tags, opts.attrs)
          .firstChild.innerHTML;
    },

    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument. Any standalone $ signs must be escaped as
     * $$.
     * @param {string} label The label to substitute through.
     *     This is not an resource ID.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    substituteString: function(label, var_args) {
      const varArgs = arguments;
      return label.replace(/\$(.|$|\n)/g, function(m) {
        assert(m.match(/\$[$1-9]/), 'Unescaped $ found in localized string.');
        return m == '$$' ? '$' : varArgs[m[1]];
      });
    },

    /**
     * Returns a formatted string where $1 to $9 are replaced by the second to
     * tenth argument, split apart into a list of pieces describing how the
     * substitution was performed. Any standalone $ signs must be escaped as $$.
     * @param {string} label A localized string to substitute through.
     *     This is not an resource ID.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {!Array<!{value: string, arg: (null|string)}>} The formatted
     *     string pieces.
     */
    getSubstitutedStringPieces: function(label, var_args) {
      const varArgs = arguments;
      // Split the string by separately matching all occurrences of $1-9 and of
      // non $1-9 pieces.
      const pieces = (label.match(/(\$[1-9])|(([^$]|\$([^1-9]|$))+)/g) ||
                      []).map(function(p) {
        // Pieces that are not $1-9 should be returned after replacing $$
        // with $.
        if (!p.match(/^\$[1-9]$/)) {
          assert(
              (p.match(/\$/g) || []).length % 2 == 0,
              'Unescaped $ found in localized string.');
          return {value: p.replace(/\$\$/g, '$'), arg: null};
        }

        // Otherwise, return the substitution value.
        return {value: varArgs[p[1]], arg: p};
      });

      return pieces;
    },

    /**
     * As above, but also makes sure that the value is a boolean.
     * @param {string} id The key that identifies the desired boolean.
     * @return {boolean} The corresponding boolean value.
     */
    getBoolean: function(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'boolean');
      return /** @type {boolean} */ (value);
    },

    /**
     * As above, but also makes sure that the value is an integer.
     * @param {string} id The key that identifies the desired number.
     * @return {number} The corresponding number value.
     */
    getInteger: function(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'number');
      expect(value == Math.floor(value), 'Number isn\'t integer: ' + value);
      return /** @type {number} */ (value);
    },

    /**
     * Override values in loadTimeData with the values found in |replacements|.
     * @param {Object} replacements The dictionary object of keys to replace.
     */
    overrideValues: function(replacements) {
      expect(
          typeof replacements == 'object',
          'Replacements must be a dictionary object.');
      for (const key in replacements) {
        this.data_[key] = replacements[key];
      }
    }
  };

  /**
   * Checks condition, displays error message if expectation fails.
   * @param {*} condition The condition to check for truthiness.
   * @param {string} message The message to display if the check fails.
   */
  function expect(condition, message) {
    if (!condition) {
      console.error(
          'Unexpected condition on ' + document.location.href + ': ' + message);
    }
  }

  /**
   * Checks that the given value has the given type.
   * @param {string} id The id of the value (only used for error message).
   * @param {*} value The value to check the type on.
   * @param {string} type The type we expect |value| to be.
   */
  function expectIsType(id, value, type) {
    expect(
        typeof value == type, '[' + value + '] (' + id + ') is not a ' + type);
  }

  expect(!loadTimeData, 'should only include this file once');
  loadTimeData = new LoadTimeData;

  // Expose |loadTimeData| directly on |window|. This is only necessary by the
  // auto-generated load_time_data.m.js, since within a JS module the scope is
  // local.
  window.loadTimeData = loadTimeData;
})();
</script><script jstcache="0">loadTimeData.data = {"details":"Details","errorCode":"HTTP ERROR 404","fontfamily":"system-ui, sans-serif","fontsize":"75%","heading":{"hostName":"www.hackerrank.com","msg":"This \u003Cspan jscontent=\"hostName\">\u003C/span> page can’t be found"},"hideDetails":"Hide details","iconClass":"icon-generic","language":"en","reloadButton":{"msg":"Reload","reloadTrackingId":-1,"reloadUrl":"https://www.hackerrank.com/rest/contests/master/challenges/red-john-is-back/hackers/_/download_solution?primary=true"},"suggestionsDetails":[],"suggestionsSummaryList":[],"summary":{"failedUrl":"https://www.hackerrank.com/rest/contests/master/challenges/red-john-is-back/hackers/_/download_solution?primary=true","hostName":"www.hackerrank.com","msg":"No webpage was found for the web address: \u003Cstrong jscontent=\"failedUrl\">\u003C/strong>"},"textdirection":"ltr","title":"www.hackerrank.com"};</script><script jstcache="0">// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file serves as a proxy to bring the included js file from /third_party
// into its correct location under the resources directory tree, whence it is
// delivered via a chrome://resources URL.  See ../webui_resources.grd.

// Note: this <include> is not behind a single-line comment because the first
// line of the file is source code (so the first line would be skipped) instead
// of a licence header.
// clang-format off
(function(){var i=null;function k(){return Function.prototype.call.apply(Array.prototype.slice,arguments)}function l(a,b){var c=k(arguments,2);return function(){return b.apply(a,c)}}function m(a,b){var c=new n(b);for(c.f=[a];c.f.length;){var e=c,d=c.f.shift();e.g(d);for(d=d.firstChild;d;d=d.nextSibling)d.nodeType==1&&e.f.push(d)}}function n(a){this.g=a}function o(a){a.style.display=""}function p(a){a.style.display="none"};var q=":",r=/\s*;\s*/;function s(){this.i.apply(this,arguments)}s.prototype.i=function(a,b){if(!this.a)this.a={};if(b){var c=this.a,e=b.a,d;for(d in e)c[d]=e[d]}else for(c in d=this.a,e=t,e)d[c]=e[c];this.a.$this=a;this.a.$context=this;this.d=typeof a!="undefined"&&a!=i?a:"";if(!b)this.a.$top=this.d};var t={$default:i},u=[];function v(a){for(var b in a.a)delete a.a[b];a.d=i;u.push(a)}function w(a,b,c){try{return b.call(c,a.a,a.d)}catch(e){return t.$default}}
function x(a,b,c,e){if(u.length>0){var d=u.pop();s.call(d,b,a);a=d}else a=new s(b,a);a.a.$index=c;a.a.$count=e;return a}var y="a_",z="b_",A="with (a_) with (b_) return ",D={};function E(a){if(!D[a])try{D[a]=new Function(y,z,A+a)}catch(b){}return D[a]}function F(a){for(var b=[],a=a.split(r),c=0,e=a.length;c<e;++c){var d=a[c].indexOf(q);if(!(d<0)){var f;f=a[c].substr(0,d).replace(/^\s+/,"").replace(/\s+$/,"");d=E(a[c].substr(d+1));b.push(f,d)}}return b};var G="jsinstance",H="jsts",I="*",J="div",K="id";function L(){}var M=0,N={0:{}},P={},Q={},R=[];function S(a){a.__jstcache||m(a,function(a){T(a)})}var U=[["jsselect",E],["jsdisplay",E],["jsvalues",F],["jsvars",F],["jseval",function(a){for(var b=[],a=a.split(r),c=0,e=a.length;c<e;++c)if(a[c]){var d=E(a[c]);b.push(d)}return b}],["transclude",function(a){return a}],["jscontent",E],["jsskip",E]];
function T(a){if(a.__jstcache)return a.__jstcache;var b=a.getAttribute("jstcache");if(b!=i)return a.__jstcache=N[b];for(var b=R.length=0,c=U.length;b<c;++b){var e=U[b][0],d=a.getAttribute(e);Q[e]=d;d!=i&&R.push(e+"="+d)}if(R.length==0)return a.setAttribute("jstcache","0"),a.__jstcache=N[0];var f=R.join("&");if(b=P[f])return a.setAttribute("jstcache",b),a.__jstcache=N[b];for(var h={},b=0,c=U.length;b<c;++b){var d=U[b],e=d[0],g=d[1],d=Q[e];d!=i&&(h[e]=g(d))}b=""+ ++M;a.setAttribute("jstcache",b);N[b]=
h;P[f]=b;return a.__jstcache=h}function V(a,b){a.h.push(b);a.k.push(0)}function W(a){return a.c.length?a.c.pop():[]}
L.prototype.e=function(a,b){var c=X(b),e=c.transclude;if(e)(c=Y(e))?(b.parentNode.replaceChild(c,b),e=W(this),e.push(this.e,a,c),V(this,e)):b.parentNode.removeChild(b);else if(c=c.jsselect){var c=w(a,c,b),d=b.getAttribute(G),f=!1;d&&(d.charAt(0)==I?(d=parseInt(d.substr(1),10),f=!0):d=parseInt(d,10));var h=c!=i&&typeof c=="object"&&typeof c.length=="number",e=h?c.length:1,g=h&&e==0;if(h)if(g)d?b.parentNode.removeChild(b):(b.setAttribute(G,"*0"),p(b));else if(o(b),d===i||d===""||f&&d<e-1){f=W(this);
d=d||0;for(h=e-1;d<h;++d){var j=b.cloneNode(!0);b.parentNode.insertBefore(j,b);Z(j,c,d);g=x(a,c[d],d,e);f.push(this.b,g,j,v,g,i)}Z(b,c,d);g=x(a,c[d],d,e);f.push(this.b,g,b,v,g,i);V(this,f)}else d<e?(f=c[d],Z(b,c,d),g=x(a,f,d,e),f=W(this),f.push(this.b,g,b,v,g,i),V(this,f)):b.parentNode.removeChild(b);else c==i?p(b):(o(b),g=x(a,c,0,1),f=W(this),f.push(this.b,g,b,v,g,i),V(this,f))}else this.b(a,b)};
L.prototype.b=function(a,b){var c=X(b),e=c.jsdisplay;if(e){if(!w(a,e,b)){p(b);return}o(b)}if(e=c.jsvars)for(var d=0,f=e.length;d<f;d+=2){var h=e[d],g=w(a,e[d+1],b);a.a[h]=g}if(e=c.jsvalues){d=0;for(f=e.length;d<f;d+=2)if(g=e[d],h=w(a,e[d+1],b),g.charAt(0)=="$")a.a[g]=h;else if(g.charAt(0)=="."){for(var g=g.substr(1).split("."),j=b,O=g.length,B=0,$=O-1;B<$;++B){var C=g[B];j[C]||(j[C]={});j=j[C]}j[g[O-1]]=h}else g&&(typeof h=="boolean"?h?b.setAttribute(g,g):b.removeAttribute(g):b.setAttribute(g,""+
h))}if(e=c.jseval){d=0;for(f=e.length;d<f;++d)w(a,e[d],b)}e=c.jsskip;if(!e||!w(a,e,b))if(c=c.jscontent){if(c=""+w(a,c,b),b.innerHTML!=c){for(;b.firstChild;)e=b.firstChild,e.parentNode.removeChild(e);b.appendChild(this.j.createTextNode(c))}}else{c=W(this);for(e=b.firstChild;e;e=e.nextSibling)e.nodeType==1&&c.push(this.e,a,e);c.length&&V(this,c)}};function X(a){if(a.__jstcache)return a.__jstcache;var b=a.getAttribute("jstcache");if(b)return a.__jstcache=N[b];return T(a)}
function Y(a,b){var c=document;if(b){var e=c.getElementById(a);if(!e){var e=b(),d=H,f=c.getElementById(d);if(!f)f=c.createElement(J),f.id=d,p(f),f.style.position="absolute",c.body.appendChild(f);d=c.createElement(J);f.appendChild(d);d.innerHTML=e;e=c.getElementById(a)}c=e}else c=c.getElementById(a);return c?(S(c),c=c.cloneNode(!0),c.removeAttribute(K),c):i}function Z(a,b,c){c==b.length-1?a.setAttribute(G,I+c):a.setAttribute(G,""+c)};window.jstGetTemplate=Y;window.JsEvalContext=s;window.jstProcess=function(a,b){var c=new L;S(b);c.j=b?b.nodeType==9?b:b.ownerDocument||document:document;var e=l(c,c.e,a,b),d=c.h=[],f=c.k=[];c.c=[];e();for(var h,g,j;d.length;)h=d[d.length-1],e=f[f.length-1],e>=h.length?(e=c,g=d.pop(),g.length=0,e.c.push(g),f.pop()):(g=h[e++],j=h[e++],h=h[e++],f[f.length-1]=e,g.call(c,j,h))};
})()
</script><script jstcache="0">var tp = document.getElementById('t');jstProcess(loadTimeData.createJsEvalContext(), tp);</script>
----------
====================
----------
ALGORITHMS.297
medium
----------
PROBLEM STATEMENT:
Given two strings, [expression] such that the length of the Longest Common Subsequence of characters in the two strings increases by one.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

int N, M;
char S[5002];
char T[5002];
int dp[5002][5002];
int dp2[5002][5002];
bool ok[256];

int main()
{
    scanf("%s", S+1);
    N=strlen(S+1);
    scanf("%s", T+1);
    M=strlen(T+1);
    for(int i=1; i&lt;=N; i++) for(int j=1; j&lt;=M; j++)
    {
        if(S[i]==T[j])
            dp[i][j]=dp[i-1][j-1]+1;
        else
            dp[i][j]=max(dp[i-1][j], dp[i][j-1]);
    }
    for(int i=N; i&gt;=1; i--) for(int j=M; j&gt;=1; j--)
    {
        if(S[i]==T[j])
            dp2[i][j]=dp2[i+1][j+1]+1;
        else
            dp2[i][j]=max(dp2[i+1][j], dp2[i][j+1]);
    }
    int lcs=dp[N][M];
    int ans=0;
    for(int i=0; i&lt;=N; i++)
    {
        for(int j=1; j&lt;=M; j++)
        {
            if(dp[i][j-1]+dp2[i+1][j+1]==lcs)
                ok[(int)T[j]]=true;
        }
        for(int j=0; j&lt;256; j++)
        {
            ans+=ok[j];
            ok[j]=false;
        }
    }
    printf("%d\n", ans);
    return 0;
}

----------
====================
----------
ALGORITHMS.298
medium
----------
PROBLEM STATEMENT:
You are situated in an [expression].

For example, you start off in a 3 dimensional grid at position [expression].    

  

If we started at [expression].

Function Description

Complete the gridWalking function in the editor below.  It should return an integer that represents the number of possible moves, modulo [expression].

gridWalking has the following parameter(s):


m: an integer that represents the number of steps  
x: an integer array where each [expression]
D: an integer array where each [expression] dimension  

----------
TOP SOLUTION:
----------
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#define MOD 1000000007

int memo[102][102][302] ;
int solve(int D,int x,int M)
{
 if(x &lt;= 0 || x &gt; D) return 0 ;
 if(M == 0) return 1 ;
 if(memo[D][x][M] != -1) return memo[D][x][M] ;
 return memo[D][x][M] = (solve(D,x - 1,M - 1) + solve(D,x + 1,M - 1)) % MOD ;
}

int n,x[10],D[10] ;
int ncr[302][302],memo2[10][302] ;
int solve2(int k,int M)
{
 if(k == n) return M == 0 ? 1 : 0 ;
 if(memo2[k][M] != -1) return memo2[k][M] ;
 int ret = 0 ;
 for(int i = 0;i &lt;= M;i++)
 {
  long long cret = 1LL * solve(D[k],x[k],i) * ncr[M][i] % MOD ;
  ret += cret * solve2(k + 1,M - i) % MOD ;
  if(ret &gt;= MOD) ret -= MOD ;
 }
 return memo2[k][M] = ret ;
}

int brute(int M)
{
 if(M == 0) return 1 ;
 int ret = 0 ;
 for(int i = 0;i &lt; n;i++)
 {
  x[i]-- ;
  if(x[i] &gt;= 1) ret += brute(M - 1) ;
  x[i] += 2 ;
  if(x[i] &lt;= D[i]) ret += brute(M - 1) ;
  x[i]-- ;
 }
 return ret ;
}

int main()
{
 for(int i = 0;i &lt; 302;i++)
 {
  ncr[i][0] = ncr[i][i] = 1 ;
  for(int j = 1;j &lt; i;j++)
   ncr[i][j] = (ncr[i - 1][j] + ncr[i - 1][j - 1]) % MOD ;
 }
 memset(memo,255,sizeof memo) ;

 int runs ;
 scanf("%d",&amp;runs) ;
 while(runs--)
 {
  int M ;
  scanf("%d%d",&amp;n,&amp;M) ;
  for(int i = 0;i &lt; n;i++) scanf("%d",&amp;x[i]) ;
  for(int i = 0;i &lt; n;i++) scanf("%d",&amp;D[i]) ;
  memset(memo2,255,sizeof memo2) ;
  int ret = solve2(0,M) ;
//  int retB = brute(M) ;
  
//  printf("%d\n",retB) ;
  printf("%d\n",ret) ;
 }
 return 0 ;
}

----------
====================
----------
ALGORITHMS.299
hard
----------
PROBLEM STATEMENT:
You are playing a matrix-based game with the following setup and rules:   


You are given a matrix [expression]. (If the cell number is positive their score increases, otherwise it decreases.)
The player starts from any cell in the first row and can move left, right or down.  
The game is over when the player reaches the last row and stops moving.  


  

Print the maximum score that the player can get. 
----------
TOP SOLUTION:
----------

<center><h1>404 Not Found</h1></center>
<hr><center>nginx</center>


<!-- a padding to disable MSIE and Chrome friendly error page -->
<!-- a padding to disable MSIE and Chrome friendly error page -->
<!-- a padding to disable MSIE and Chrome friendly error page -->
<!-- a padding to disable MSIE and Chrome friendly error page -->
<!-- a padding to disable MSIE and Chrome friendly error page -->
<!-- a padding to disable MSIE and Chrome friendly error page -->

----------
====================
----------
ALGORITHMS.300
medium
----------
PROBLEM STATEMENT:
Given an array of integers and a target sum, determine the sum nearest to but not exceeding the target that can be created.  To create the sum, use any element of your array zero or more times.

For example, if [expression].  In this case, you can arrive at exactly the target.  

Function Description  

Complete the unboundedKnapsack function in the editor below.  It must return an integer that represents the sum nearest to without exceeding the target value.  

unboundedKnapsack has the following parameter(s):  


k: an integer  
arr: an array of integers  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;
int dp[2005]; 
int main() {
    int a; cin &gt;&gt; a;
    for (int g=0;g&lt;a; g++)
        {memset(dp,0,sizeof(dp)); 
        int b,c; cin &gt;&gt; b &gt;&gt; c; vector &lt;int&gt; t;
        for (int y=0;y&lt;b; y++){int d; cin &gt;&gt; d;t.push_back(d);}
        dp[0]=1; int r=0; 
        for (int g=1; g&lt;=c; g++)
            {
            for (int y=0;y&lt;t.size(); y++)
                {
                if (t[y]&gt;g) continue; if (dp[g-t[y]]) dp[g]=1; 
            }
            if (dp[g]) r=g; 
        }
        cout &lt;&lt; r &lt;&lt; '\n'; 
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.301
medium
----------
PROBLEM STATEMENT:
You and your friend decide to play a game using a stack consisting of N bricks. In this game, you can alternatively remove 1, 2 or 3 bricks from the top, and the numbers etched on the removed bricks are added to your score. You have to play so that you obtain the maximum possible score. It is given that your friend will also play optimally and you make the first move.  

As an example, bricks are numbered [expression] in your first move.  

Function Description  

Complete the bricksGame function in the editor below.  It should return an integer that represents your maximum possible score.  

bricksGame has the following parameter(s):  


arr:  an array of integers  

----------
TOP SOLUTION:
----------
#include&lt;math.h&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;map&gt;
#include&lt;ext/hash_map&gt;
#include&lt;ext/hash_set&gt;
#include&lt;set&gt;
#include&lt;string&gt;
#include&lt;assert.h&gt;
#include&lt;vector&gt;
#include&lt;time.h&gt;
#include&lt;queue&gt;
#include&lt;deque&gt;
#include&lt;sstream&gt;
#include&lt;stack&gt;
#include&lt;sstream&gt;
#define MA(a,b) ((a)&gt;(b)?(a):(b))
#define MI(a,b) ((a)&lt;(b)?(a):(b))
#define AB(a) (-(a)&lt;(a)?(a):-(a))
#define X first
#define Y second
#define mp make_pair
#define pb push_back
#define pob pop_back
#define ep 0.0000000001
#define Pi 3.1415926535897932384626433832795
using namespace std;
using namespace __gnu_cxx;
const long long  MO=1000000000+7;
int i,j,n,m,k;
int a[1000000];
long long s[1000000],su[1000000];
bool f[1000000];
long long sol(int x)
{
    if (x==n+1) return 0;
    if (f[x]) return s[x];
    if (n-x&lt;=2) return s[x]=su[x];
    f[x]=1;
    s[x]=0;
    if (x+1&lt;=n+1)s[x]=max(s[x],su[x]-sol(x+1));
    if (x+2&lt;=n+1)s[x]=max(s[x],su[x]-sol(x+2));
    if (x+3&lt;=n+1)s[x]=max(s[x],su[x]-sol(x+3));
}
int main()
{
    int t;
    cin&gt;&gt;t;
    while (t--)
    {
        cin&gt;&gt;n;
        for (i=1;i&lt;=n;i++)
            scanf("%d",&amp;a[i]);
        for (i=n;i&gt;=1;i--)
            su[i]=su[i+1]+a[i];
        for (i=1;i&lt;=n;i++)
            f[i]=0;
        cout&lt;&lt;sol(1)&lt;&lt;endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.302
advanced
----------
PROBLEM STATEMENT:
An Introduction to the Longest Increasing Subsequence Problem  

The task is to find the length of the longest subsequence in a given array of integers such that all elements of the subsequence are sorted in strictly ascending order. This is called the Longest Increasing Subsequence (LIS) problem.

For example, the length of the LIS for [expression].  

Here's a great YouTube video of a lecture from MIT's Open-CourseWare covering the topic.  

   

This is one approach which solves this in quadratic time using dynamic programming. A more efficient algorithm which solves the problem in [expression] time is available here. 

Given a sequence of integers, find the length of its longest strictly increasing subsequence.

Function Description  

Complete the longestIncreasingSubsequence function in the editor below.  It should return an integer that denotes the array's LIS.  

longestIncreasingSubsequence has the following parameter(s):  


arr: an unordered array of integers  

----------
TOP SOLUTION:
----------
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

class Solution {
    static void Main(String[] args) 
    {
            List&lt;int&gt; lista = new List&lt;int&gt;();
            List&lt;int&gt; semiLista = new List&lt;int&gt;();
            List&lt;int&gt; indeksi = new List&lt;int&gt;();
            int j = 0;
            
            // upis
            int N = Convert.ToInt32(Console.ReadLine());
            for (int i = 0; i &lt; N; i++)
            {
                lista.Add(Convert.ToInt32(Console.ReadLine()));
            }

            // alg
            semiLista.Add(lista.First());
            indeksi.Add(0);
            foreach(int broj in lista)
            {
                if (broj &gt; semiLista.Last())
                {
                    semiLista.Add(broj);
                    indeksi.Add(j);
                }
                else
                {
                    int index = semiLista.BinarySearch(broj);
                    if (index &lt; 0)
                    {
                        semiLista[+~index] = broj;
                        indeksi[+~index] = j;
                    }
                    else
                    {
                        semiLista[index] = broj;
                        indeksi[index] = j;
                    }
                }
                j++;
            }

            // ispis
                Console.WriteLine(indeksi.Count);
        }
}
----------
====================
----------
ALGORITHMS.303
medium
----------
PROBLEM STATEMENT:
You have a rectangular board consisting of [expression] - there is a coin on the top-left cell of your board. Each cell of your board contains one of these letters:  


*: Exactly one of your cells has letter '*'.
U: If at time [expression].
L: If at time [expression].
D: If at time [expression].
R: If at time [expression].


When the coin reaches a cell that has letter '*', it will stay there permanently. When you punch on your board, your timer starts and the coin moves between cells. Before starting the game, you can make operations to change the board, such that you are sure that at or before time [expression] the coin will reach the cell having letter '*'. In each operation you can select a cell with some letter other than '*' and change the letter to 'U', 'L', 'R' or 'D'. You need to carry out as few operations as possible in order to achieve your goal. Your task is to find the minimum number of operations. 

For example, given a grid of [expression] columns:

[expression]
[expression]



the goal is to get from [expression].  

Function Description  

Complete the coinOnTheTable function in the editor below.  It should return an integer that represents the minimum operations to achieve the goal, or [expression] if it is not possible.  

coinOnTheTable has the following parameters:  


m: an integer, the number of columns on the board  
k: an integer, the maximum time to reach the goal  
board: an array of strings where each string represents a row of the board  

----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
using namespace std;

int m,n;
char s[55][55];
int dp[2][55][55];
int last,now;

bool valid(int x,int y) {
	return (x&gt;=0) &amp;&amp; (x&lt;n) &amp;&amp; (y&gt;=0) &amp;&amp; (y&lt;m) &amp;&amp; (dp[last][x][y]&gt;=0);
}

int haha(int x,int y,char c) {
	return (s[x][y]==c)?0:1;
}

void better(int &amp;x,int y) {
	if ((x&lt;0) || (x&gt;y)) {
		x=y;
	}
}

int main() {
int i,j,t,x,y,ans;
	scanf("%d%d%d",&amp;n,&amp;m,&amp;t);
	memset(dp[0],0xff,sizeof(dp[0]));
	for (i=0;i&lt;n;++i) {
		scanf("%s",s[i]);
	}
	dp[0][0][0]=0;
	ans=(s[0][0]=='*')?0:(-1);
	for (last=0;t;--t) {
		memset(dp[now=1^last],0xff,sizeof(dp[now]));
		for (i=0;i&lt;n;++i) {
			for (j=0;j&lt;m;++j) {
				x=i-1;
				y=j;
				if (valid(x,y)) {
					better(dp[now][i][j],dp[last][x][y]+haha(x,y,'D'));
				}
				x=i+1;
				if (valid(x,y)) {
					better(dp[now][i][j],dp[last][x][y]+haha(x,y,'U'));
				}
				x=i;
				y=j-1;
				if (valid(x,y)) {
					better(dp[now][i][j],dp[last][x][y]+haha(x,y,'R'));
				}
				y=j+1;
				if (valid(x,y)) {
					better(dp[now][i][j],dp[last][x][y]+haha(x,y,'L'));
				}
				if ((s[i][j]=='*') &amp;&amp; (dp[now][i][j]&gt;=0)) {
					better(ans,dp[now][i][j]);
				}
			}
		}
		last=now;
	}
	printf("%d\n",ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.304
medium
----------
PROBLEM STATEMENT:
A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.  Longest common subsequence (LCS) of 2 sequences is a subsequence, with maximal length, which is common to both the sequences. 

Given two sequences of integers, [expression], find the longest common subsequence and print it as a line of space-separated integers. If there are multiple common subsequences with the same maximum length, print any one of them.

In case multiple solutions exist, print any of them. It is guaranteed that at least one non-empty common subsequence will exist.    

Recommended References  

This Youtube video tutorial explains the problem and its solution quite well.  

   

Function Description  

Complete the longestCommonSubsequence function in the editor below.  It should return an integer array of a longest common subsequence.  

longestCommonSubsequence has the following parameter(s):  


a: an array of integers  
b: an array of integers

----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;ctime&gt;
#include &lt;list&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;deque&gt;
#include &lt;stack&gt;
#include &lt;iostream&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iterator&gt;
#include &lt;numeric&gt;

using namespace std;

#define F_TO_R          freopen("input.txt", "r" , stdin)
#define _pair(x,y)      make_pair(x,y)
#define INF             (1&lt;&lt;30)
#define sf              scanf
#define pf              printf
#define mem(a,b)        memset(a, b, sizeof(a))
#define fs              first
#define se              second
#define MAX             1010
#define MAXR            205
#define MAXC            5
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int u_int;
const double PI = 2.0 * acos(0.0);
const double eps = 1e-11;
const int _mod = 1000000;
const int save[10][4] = {{0},{0},{6,2,4,8},{1,3,9,7},{6,4},{0},{0},{1,7,9,3},{6,8,4,2},{1,9}};
int todigit(char c) { return ( isdigit(c) ) ?( c - 48 ) : c ; }
int toint(string s) { int r = 0; istringstream sin(s); sin &gt;&gt; r; return r; }
ll tolong(string s) {  ll r = 0; istringstream sin(s); sin &gt;&gt; r; return r; }
double todouble(string s) { double r = 0.0 ; istringstream sin(s); sin &gt;&gt; r; return r; }
bool bit_check(int k , int p){ return (bool)(k&amp;(1 &lt;&lt; p)); }
int bit_set(int k , int p) { return k = (k|(1 &lt;&lt; p));}
template &lt; class T &gt; string toString(T n) { ostringstream ost; ost &lt;&lt; n; ost.flush() ; return ost.str(); }
template &lt; class T &gt; T Abs(T x) { return x &gt; 0 ? x : -x;}
template &lt; class T &gt; T power(T N , T P) { return (P == 0) ?  1 : N * power(N , P - 1); }
template &lt; class T &gt; inline T max_(T a,T b) {return a &gt; b ? a : b ;}
template &lt; class T &gt; inline T min_(T a,T b) {return a &lt; b ? a : b ;}
template &lt; class T &gt; inline T gcd(T a,T b) {if(a &lt; 0) return gcd(-a,b); if(b &lt; 0)return gcd(a,-b); return (b == 0) ? a : gcd(b ,a % b);}
template &lt; class T &gt; inline T lcm(T a,T b) {if(a &lt; 0) return lcm(-a,b); if(b &lt; 0)return lcm(a,-b); return a * (b / gcd(a , b));}

//ll big_mod(ll n , ll  p , ll m)
//{
//  ll sum;
//  if(!p) return 1;
//  if(p % 2 == 0) { sum = big_mod(n  , p / 2 , m); return ((sum % m ) *(sum % m)) % m; }
//  else return (( n % m) * (big_mod( n , p - 1 , m) % m ))% m;
//}

//bool siv[MAX];
//int prime[MAX];
//void is_prime()
//{
//    int k = 0;
//    int n = sqrt(MAX);
//    prime[k++] = 2;
//    for(int i = 3 ; i &lt; n ; i += 2) if(!siv[i]) for(int j = i * i ; j &lt; MAX ; j += (2 * i)) siv[j] = true;
//    for(int i = 3 ; i &lt; MAX ; i += 2) if(!siv[i]) prime[k++] = i;
//}
//
//int one[]={1,0,-1,0}; //4 Direction
//int two[]={0,1,0,-1}; //4 Direction
//int two[]={0,1,1,1,0,-1,-1,-1};//8 direction
//int one[]={2,1,-1,-2,-2,-1,1,2}; //Knight Direction
//int two[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction

///***************************************  END  **********************************************///


int DP[1010][1010];
int one[1010];
int two[1010];
vector &lt; int &gt; ans;
void printLCS(int a , int b);
int main()
{
    int n , m;
    sf("%d %d", &amp;n , &amp;m);
    for(int i = 0 ; i &lt; n ; ++i) sf("%d", &amp;one[i]);
    for(int i = 0 ; i &lt; m ; ++i) sf("%d", &amp;two[i]);
    mem(DP , 0);
    for(int i = 1 ; i &lt;= n ; ++i)
    {
        for(int j = 1 ; j &lt;= m ; ++j)
        {
            if(one[i - 1] == two[j - 1]) DP[i][j] = DP[i - 1][j - 1] + 1;
            else DP[i][j] = max_(DP[i - 1][j] , DP[i][j - 1]);
        }
    }
   // pf("%d", DP[n][m]);
    printLCS(n , m);
    int len = ans.size();
    pf("%d", ans[len - 1]);
    for(int i = len - 2 ; i &gt;= 0 ; --i) pf(" %d", ans[i]);
    return 0;
}

void printLCS(int a , int b)
{
    if(a == 0 || b == 0) return ;
    if(one[a - 1] == two[b - 1])
    {
        ans.push_back(one[a - 1]);
        printLCS(a - 1 , b - 1);
    }
    else if(DP[a][b] == DP[a - 1][b]) printLCS(a - 1 , b);
    else printLCS(a , b - 1);
}
----------
====================
----------
ALGORITHMS.305
medium
----------
PROBLEM STATEMENT:
Shaka and his brother have created a boring game which is played like this:  

They take a word composed of lowercase English letters and try to get the maximum possible score by building exactly 2 palindromic subsequences. The score obtained is the product of the length of these 2 subsequences.

Let's say [expression], then the following statements hold true: 
[expression], 
[expression], &amp; 
[expression]. 
i.e., the positions of the subsequences should not cross over each other. 

Hence the score obtained is the product of lengths of subsequences [expression]. Such subsequences can be numerous for a larger initial word, and hence it becomes harder to find out the maximum possible score. Can you help Shaka and his brother find this out?
----------
TOP SOLUTION:
----------
/*
*/
 
//#pragma comment(linker, "/STACK:16777216")
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;
#include &lt;memory.h&gt;
#include &lt;ctime&gt; 
 
#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
 
#define eps 1e-11
//#define M_PI 3.141592653589793
#define bs1 1000000007ll
#define bs2 1000000009ll
#define P1 173
#define P2 187
#define bsize 256
#define right adsgasgadsg
#define free adsgasdg
 
using namespace std;

string st;
long dp[3050][3050],mpref[3050],msuf[3050];
long n;
long ans;

int main(){
//freopen("lesson.in","r",stdin);
//freopen("lesson.out","w",stdout);
//freopen("C:/input.txt","r",stdin);
//freopen("C:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);
//cin.tie(0);

cin&gt;&gt;st;
n=st.size();
for (int r=0;r&lt;n;r++)
{
 for (int l=r;l&gt;=0;l--)
 {
  if (l==r-1)
  dp[l][r]=(st[l]==st[r]);
  dp[l][r]=max(dp[l][r],n-(n-1));
  dp[l][r]=max(dp[l][r],dp[l+1][r]);
  dp[l][r]=max(dp[l][r],dp[l][r-1]);
  if (st[l]==st[r]&amp;&amp;l&lt;r)
   dp[l][r]=max(dp[l][r],dp[l+1][r-1]+2);
 }
}
/*
for (int i=0;i&lt;n;i++)
{
    for (int j=0;j&lt;n;j++)
     cout&lt;&lt;dp[i][j]&lt;&lt;" ";
    cout&lt;&lt;endl;
}*/

for (int i=0;i&lt;n;i++)
{
 for (int j=0;j&lt;=i;j++)
  mpref[i]=max(mpref[i],dp[j][i]);
 for (int j=i;j&lt;n;j++)
  msuf[i]=max(msuf[i],dp[i][j]);
}

for (int i=1;i&lt;n;i++)
 mpref[i]=max(mpref[i],mpref[i-1]);
for (int i=n-2;i&gt;=0;--i)
 msuf[i]=max(msuf[i],msuf[i+1]);

ans=0;
for (int i=0;i&lt;n;i++)
 ans=max(ans,mpref[i]*msuf[i+1]);
cout&lt;&lt;ans&lt;&lt;endl;


cin.get();cin.get();
return 0;}

----------
====================
----------
ALGORITHMS.306
hard
----------
PROBLEM STATEMENT:
Nikita is making a graph as a birthday gift for her boyfriend, a fellow programmer! She drew an undirected connected graph with [expression] in her notebook.

Each node is shaded in either white or black. We define [expression] to be the number of black nodes. The graph is drawn in such a way that:


No [expression] adjacent nodes have same coloring.
The value of [expression], is minimal.


Nikita's mischievous little brother erased some of the edges and all of the coloring from her graph! As a result, the graph is now decomposed into one or more components. Because you're her best friend, you've decided to help her reconstruct the graph by adding [expression] edges such that the aforementioned graph properties hold true.

Given the decomposed graph, construct and shade a valid connected graph such that the difference [expression] between its shaded nodes is minimal.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
// #include "testlib.h"
using namespace std ;

#define ft first
#define sd second
#define pb push_back
#define all(x) x.begin(),x.end()

#define ll long long int
#define vi vector&lt;int&gt;
#define vii vector&lt;pair&lt;int,int&gt; &gt;
#define pii pair&lt;int,int&gt;
#define vl vector&lt;ll&gt;
#define vll vector&lt;pair&lt;ll,ll&gt; &gt;
#define pll pair&lt;ll,ll&gt;
#define pli pair&lt;ll,int&gt;
#define mp make_pair

#define sc1(x) scanf("%d",&amp;x)
#define sc2(x,y) scanf("%d%d",&amp;x,&amp;y)
#define sc3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)

#define scll1(x) scanf("%lld",&amp;x)
#define scll2(x,y) scanf("%lld%lld",&amp;x,&amp;y)
#define scll3(x,y,z) scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z)

#define pr1(x) printf("%d\n",x)
#define pr2(x,y) printf("%d %d\n",x,y)
#define pr3(x,y,z) printf("%d %d %d\n",x,y,z)

#define prll1(x) printf("%lld\n",x)
#define prll2(x,y) printf("%lld %lld\n",x,y)
#define prll3(x,y,z) printf("%lld %lld %lld\n",x,y,z)

#define pr_vec(v) for(int i=0;i&lt;v.size();i++) cout &lt;&lt; v[i] &lt;&lt; " " ;

#define f_in(st) freopen(st,"r",stdin)
#define f_out(st) freopen(st,"w",stdout)

#define fr(i, a, b) for(i=a; i&lt;=b; i++)
#define fb(i, a, b) for(i=a; i&gt;=b; i--)

#include &lt;ext/pb_ds/assoc_container.hpp&gt;
#include &lt;ext/pb_ds/tree_policy.hpp&gt;

const int maxn = 1e5 + 10;
const int mod = 1e9 + 7;
const int N=200010;
int w[2];
vector &lt;int&gt; v[N];
int a[N], d[N], p[N], c[N], col[N], sz, ccol[2][N];
bool f[N];
queue&lt;int&gt; q[N];
void dfs(int x,int y){
    f[x]=1;
    w[y]++;
    col[x] = y;
    ccol[y][sz] = x;
    for (int i=0;i&lt;v[x].size();i++)
    if (!f[v[x][i]])
        dfs(v[x][i],(y^1));
    else if( col[v[x][i]] != 1 - y ) 
        assert(0);
}

int main() {
    int n,m;
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=0,x,y;i&lt;m;i++){
        scanf("%d%d",&amp;x,&amp;y);
        v[x].push_back(y);
        v[y].push_back(x);
    }

    int k=0;
    for (int i=1;i&lt;=n;i++) {
        if (!f[i]) {
            w[0] = w[1]=0;
            dfs(i,0);
            c[i] = (w[0] &lt; w[1]);
            k+=abs(w[0]-w[1]);
            a[abs(w[0]-w[1])]++;
            q[abs(w[0]-w[1])].push( i );
        }
    }

    for (int j=1;j&lt;=k;j++) d[j]=N;

    for (int i=1;i&lt;=n;i++)
        if (a[i]) {
            for (int j=0;j+i&lt;=k;j++) {
                if( d[i+j] == N &amp;&amp; d[j] != N ) {
                    d[i+j] = d[j] + 1;
                    p[i+j] = j;
                }
            }

            for (int j=1;j&lt;=k;j++) {
                if (d[j]&gt;a[i]) {
                    d[j]=N;
                    p[j]=0;
                } else {
                    d[j]=0;
                }
            }
        }

    int ans=k, v = 0;
    for (int i=0;i&lt;=k;i++) {
        if(d[i]&lt;N) {
            if( ans &gt;= abs(k - 2 * i) ) {
                ans = abs(k - 2 * i);
                v = i;
            }
        }
    }

    memset(f, 0, sizeof f);
    while( v != 0 ) {
        int diff = v - p[v];
        int nd = q[diff].front();
        q[diff].pop();
        sz ++;
        dfs(nd, c[nd]);
        v = p[v];
    }

    for(int i=1; i&lt;=n; i++) {
        if( !f[i] ) {
            sz ++;
            dfs(i, 1 - c[i]);
        }
    }

    int blk, wht, idb, idw;
    blk = wht = idb = idw = -1;
    for(int i=1; i&lt;=sz; i++) {

        if( ccol[0][i] ) {
            blk = ccol[0][i];
            idb = i;
        }

        if( ccol[1][i] ) {
            wht = ccol[1][i];
            idw = i;
        }
    }
    cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; sz - 1 &lt;&lt; "\n";
    if( idb != idw ) cout &lt;&lt; blk &lt;&lt; " " &lt;&lt; wht &lt;&lt; "\n";
    for(int i=1; i&lt;=sz; i++) {
        if( i != idb &amp;&amp; i != idw ) {
            if( ccol[0][i] ) {
                cout &lt;&lt; wht &lt;&lt; " " &lt;&lt; ccol[0][i] &lt;&lt; "\n";
            } else {
                cout &lt;&lt; blk &lt;&lt; " " &lt;&lt; ccol[1][i] &lt;&lt; "\n";
            }
        }
    }
    return 0;
}
----------
====================
----------
ALGORITHMS.307
medium
----------
PROBLEM STATEMENT:
Given an [expression]. 

A [expression].

For each [expression]).
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; static void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; static void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

int main() {
	int T;
	scanf("%d", &amp;T);
	for(int ii = 0; ii &lt; T; ++ ii) {
		static int A[50][50][50];
		int n;
		scanf("%d", &amp;n);
		rep(i, n) rep(j, n) rep(k, n)
			scanf("%d", &amp;A[i][j][k]);
		static int dp[51][51][51], ndp[51][51][51];
		rer(s, 1, n) {
			if(s == 1) {
				rep(i, n) rep(j, n) rep(k, n)
					ndp[i][j][k] = A[i][j][k];
			} else {
				rer(i, 0, n - s) rer(j, 0, n - s) rer(k, 0, n - s) {
					int x = -1;
					rep(di, 2) rep(dj, 2) rep(dk, 2)
						amax(x, dp[i + di][j + dj][k + dk]);
					ndp[i][j][k] = x;
				}
			}
			rer(i, 0, n - s + 1) rer(j, 0, n - s + 1) rer(k, 0, n - s + 1)
				dp[i][j][k] = i &lt;= n - s &amp;&amp; j &lt;= n - s &amp;&amp; k &lt;= n - s ? ndp[i][j][k] : -1;
			int ans = 0;
			rer(i, 0, n - s) rer(j, 0, n - s) rer(k, 0, n - s)
				ans += dp[i][j][k] == s;
			if(s != 1) putchar(' ');
			printf("%d", ans);
		}
		puts("");
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.308
medium
----------
PROBLEM STATEMENT:
Given a set of [expression] intervals, find the size of its largest possible subset of intervals such that no three intervals in the subset share a common point.
----------
TOP SOLUTION:
----------
#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;
#include&lt;sstream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;string.h&gt;
using namespace std ;
#define INF (int)1e9
#define MAXN 1002
int n,s[MAXN],e[MAXN] ;

int bit[1 &lt;&lt; 20] ;
int solve1()
{
 int ret = 0 ;
 for(int i = 1;i &lt; 1 &lt;&lt; n;i++)
 {
  bit[i] = bit[i / 2] + (i &amp; 1) ;
  int valid = 1,occ[1002] = {} ;
  for(int j = 0;valid &amp;&amp; j &lt; n;j++)
   if(i &amp; 1 &lt;&lt; j)
    for(int k = s[j];k &lt;= e[j];k++)
     if(++occ[k] &gt; 2)
     {
      valid = 0 ;
      break ;
     }
  if(valid) ret = max(ret,bit[i]) ;
 }
 return ret ;
}

int memo[MAXN][MAXN],memo2[MAXN][MAXN],f[MAXN] ;
int solve2()
{
 if(n &lt;= 2) return n ;

 for(int i = 0;i &lt; n;i++)
  for(int j = i + 1;j &lt; n;j++)
   if(s[i] &gt; s[j])
   {
    swap(s[i],s[j]) ;
    swap(e[i],e[j]) ;
   }

 for(int i = 0;i &lt; n;i++)
 {
  f[i] = n ;
  int low = i,high = n ;
  while(low + 1 &lt; high)
  {
   int mid = low + (high - low) / 2 ;
   if(s[mid] &gt; e[i]) high = mid ;
   else low = mid ;
  }
  f[i] = high ;
 }

 int ret = 2 ;
 memset(memo2,0,sizeof memo2) ;
 memset(memo,0,sizeof memo) ;
 for(int p1 = n - 2;p1 &gt;= 0;p1--)
  for(int p2 = n - 1;p2 &gt; p1;p2--)
  {
   int nstart = max(p2 + 1,min(f[p1],f[p2])) ;
   if(nstart == n) continue ;
   if(e[p1] &lt; e[p2]) memo[p1][p2] = 1 + memo2[p2][nstart] ;
   else memo[p1][p2] = 1 + memo2[p1][nstart] ;
   memo2[p1][p2] = max(memo2[p1][p2 + 1],memo[p1][p2]) ;
   ret = max(ret,2 + memo[p1][p2]) ;
  }
 return ret ;
}

void gen()
{
 n = rand() % 15 + 1 ;
 for(int i = 0;i &lt; n;i++)
 {
  s[i] = rand() % 20 + 1 ;
  e[i] = rand() % 20 + 1 ;
  if(s[i] &gt; e[i]) swap(e[i],s[i]) ;
 }
}

void test()
{
 for(int t = 0;t &lt; 10000;t++)
 {
  gen() ;
  int ret1 = solve1() ;
  int ret2 = solve2() ;
  cout &lt;&lt; ret1 &lt;&lt; " " &lt;&lt; ret2 &lt;&lt; endl ;
  if(ret1 != ret2)
  {
   cout &lt;&lt; "failed on: " &lt;&lt; t &lt;&lt; endl ;
   cout &lt;&lt; n &lt;&lt; endl ;
   for(int i = 0;i &lt; n;i++) cout &lt;&lt; s[i] &lt;&lt; " " &lt;&lt; e[i] &lt;&lt; endl ;
   while(1) ;
  }
 }
}

void generate()
{
 char in[] = "in .txt" ;
 for(int test = 0;test &lt; 10;test++)
 {
  in[2] = test + '0' ;
  FILE * fout = fopen(in,"w") ;
  int runs = 100 ;
  fprintf(fout,"%d\n",runs) ;
  for(int t = 0;t &lt; runs;t++)
  {
   int lim ;
   if(test &lt; 2) n = rand() % 10 + 2,lim = rand() % 10 + 1 ;
   else if(test &lt; 5) n = rand() % 100 + 2,lim = rand() % 100 + 1 ;
   else if(test &lt; 8) n = 1000 - rand() % 100,lim = rand() % 1000000000 + 1 ;
   else n = 1000 - rand() % 100,lim = rand() % 1000 + 1 ;
   
   for(int i = 0;i &lt; n;i++)
   {
    s[i] = rand() % lim + 1 ;
    e[i] = rand() % lim + 1 ;
    if(s[i] &gt; e[i]) swap(s[i],e[i]) ;
   }

   fprintf(fout,"%d\n",n) ;
   for(int i = 0;i &lt; n;i++)
   {
    fprintf(fout,"%d %d\n",s[i],e[i]) ;
   }
  }
 }
}

int main()
{
// test() ; return 0 ;
// generate() ; return 0 ;
 
 int runs ;
 scanf("%d",&amp;runs) ;
 while(runs--)
 {
  scanf("%d",&amp;n) ;
  if(n &lt; 1 || n &gt; 1000) while(1) ;
  for(int i = 0;i &lt; n;i++)
  {
   scanf("%d%d",&amp;s[i],&amp;e[i]) ;
   if(s[i] &lt; 1 || e[i] &gt; (int)1e9 || s[i] &gt; e[i]) { cerr &lt;&lt; "bad interval" &lt;&lt; endl ; while(1) ; }
  }
  int ret = solve2() ;
  printf("%d\n",ret) ;
 }

 return 0 ;
}
----------
====================
----------
ALGORITHMS.309
hard
----------
PROBLEM STATEMENT:
Given a string consisting of the letters [expression], we can perform the following operation: 


Take any two adjacent distinct characters and replace them with the third character. 


Find the shortest string obtainable through applying this operation repeatedly.  

For example, given the string [expression].  

Function Description  

Complete the stringReduction function in the editor below.  It must return an integer that denotes the length of the shortest string obtainable.  

stringReduction has the following parameter: 
- s: a string  
----------
TOP SOLUTION:
----------
/*
 * stringReduction.cpp
 *
 *  Created on: 29-10-2011
 *      Author: Piotr Szczesniak
 */
#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;utility&gt;
using namespace std;

int main() {
	string s;
	int T=0, res=0;
	int tab[3];

	cin &gt;&gt; T;

	for (int t = 0; t &lt; T; t++) {
		s.clear();
		tab[0] = 0;
		tab[1] = 0;
		tab[2] = 0;
		res = 0;

		cin &gt;&gt; s;
		for (unsigned int i = 0; i &lt; s.size(); i++) {
			if (s[i] == 'a') tab[0]++;
			else if(s[i] == 'b') tab[1]++;
			else if(s[i] == 'c') tab[2]++;
			else cerr &lt;&lt; "dupa!" &lt;&lt; endl;
		}

		sort(tab, tab+3);

		while (tab[1] &gt; 0) {
			tab[2]--;
			tab[1]--;
			tab[0]++;
			sort(tab, tab+3);
		}

		cout &lt;&lt; tab[2] &lt;&lt; endl;
	}


	return 0;
}

----------
====================
----------
ALGORITHMS.310
hard
----------
PROBLEM STATEMENT:
You are given a tree that has N vertices and N-1 edges. Your task is to mark as small number of vertices as possible, such that, the maximum distance between two unmarked vertices is less than or equal to K. Output this value.
Distance between two vertices i and j is defined as the minimum number of edges you have to pass in order to reach vertex i from vertex j.  

Input Format 
The first line of input contains two integers N and K. The next N-1 lines contain two integers (ui,vi) each, where 1 &lt;= ui,vi &lt;= N. Each of these lines specifies an edge. 
N is no more than 100. K is less than N.  

Output Format 
Print an integer that denotes the result of the test.

Sample Input:

5 1  
1 2  
1 3  
1 4  
1 5


Sample Output:

3


Sample Input:

5 2  
1 2  
1 3  
1 4  
1 5


Sample Output:

0


Explanation:

In the first case you have to mark at least 3 vertices, and in the second case you don't need to mark any vertices.
----------
TOP SOLUTION:
----------
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;deque&gt;
#include &lt;stack&gt;
#include &lt;bitset&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;string.h&gt;
#include &lt;limits.h&gt;

using namespace std;

#define rep(i,a,b) for(int i=(a);i&lt;(b);i++)
#define ll long long int
#define ii pair&lt;int,int&gt;
#define Clear(x,val) memset(x,val,sizeof(x))
#define SZ(v) (v).size()
#define maxv 200

vector &lt; vector&lt;int&gt; &gt; vv(200);
int a[maxv][maxv];
int visited[maxv];
int val[maxv];


int main()
{
	for( int i = 0; i &lt; maxv; i++   ) for( int j = 0; j &lt; maxv; j++ ) a[i][j] = 1e9;

	int n , K; cin &gt;&gt; n &gt;&gt; K;
	for( int i = 1;i &lt; n; i++ ) {
		int x , y;
		cin &gt;&gt; x &gt;&gt; y;
		--x;--y;
		a[x][y] = min( a[x][y] , 1 );
		a[y][x] = min( a[y][x] , 1 );		
		vv[x].push_back(y);
		vv[y].push_back(x);
	}
	for( int i = 0; i &lt; n; i++ ) a[i][i] = 0;

	int ans = 0;

	for( int k = 0; k &lt; n; k++ )
		for( int i = 0; i &lt; n; i++ ) 
			for( int j = 0; j &lt; n; j++ )
				a[i][j] = min( a[i][j] , a[i][k]+a[k][j] );





	
	Clear( visited , 0 );Clear( val , 0 );  
	int u = -1;
	for( int i = 0; i &lt; n; i++ ) {
		u = -1;
		for( int j = n-1; j &gt;= 0; j-- ) {		
			if( !visited[j] &amp;&amp; ( u&lt;0 || val[j]&gt;val[u] ) )
				u = j;
		}
		
		visited[u] = 1;int tmp = 0;
		for( int i = 0; i &lt; n; i++ ) if( a[u][i] &lt;= K ) {	
			if( visited[i] ) ++tmp;
			else val[i] += 1; 
		}

		ans = max( ans , tmp );

	}
	cout &lt;&lt; n-ans &lt;&lt; "\n";
	return 0;
}
----------
====================
----------
ALGORITHMS.311
expert
----------
PROBLEM STATEMENT:
Lukas is a Civil Engineer who loves designing road networks to connect [expression]. He can build any number of bidirectional roads as long as the resultant network satisfies these constraints:


It must be possible to reach any city from any other city by traveling along the network of roads.  
No two roads can directly connect the same two cities.   
A road cannot directly connect a city to itself.  


In other words, the roads and cities must form a simple connected labeled graph.

You must answer [expression].
----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long num;
typedef vector&lt;num&gt; poly;
const num p=663224321;
 
num pm(num a,num n=p-2,num m=p){
	num r=1;
	for(;n;n&gt;&gt;=1,a=a*a%m)
		if(n&amp;1)r=r*a%m;
	return r;
}
 
struct NTT{
	static const int g=3;
	void go(num *a,size_t n){
		size_t l,b,i,s;
		num d=pm(g,(p-1)/n,p),w,t;
		for(b=n&gt;&gt;1,l=n;b;b&gt;&gt;=1,l&gt;&gt;=1,d=d*d%p)
		for(w=1,s=0;s&lt;b;++s,w=w*d%p)
		for(i=s;i&lt;n;i+=l){
			a[i|b]=(a[i]-(t=a[i|b]))*w%p;
			a[i]=(a[i]+t)%p;
		}
	}
	void back(num *a,size_t n){
		size_t l,b,i,s;
		num d=pm(n,p-2,p),w,t;
		for(i=0;i&lt;n;++i)a[i]=a[i]*d%p;
		for(b=1,l=2;b&lt;n;b&lt;&lt;=1,l&lt;&lt;=1)
		for(d=pm(g,p-1-(p-1)/l,p),w=1,s=0;s&lt;b;++s,w=w*d%p)
		for(i=s;i&lt;n;i+=l){
			t=a[i|b]*w;
			a[i|b]=(a[i]-t)%p;
			a[i]=(a[i]+t)%p;
		}
	}
}ntt;

void sqr(poly&amp; a){
	int n=1,m=a.size();
	for(;n&lt;a.size()*2-1;n&lt;&lt;=1);
	a.resize(n,0);
	ntt.go(&amp;a[0],n);
	for(int i=0;i&lt;n;++i)a[i]=a[i]*a[i]%p;
	ntt.back(&amp;a[0],n);
	a.resize(m*2-1);
}
poly mul(poly a,poly b){
	int n=1,l=a.size()+b.size()-1;
	for(;n&lt;l;n&lt;&lt;=1);
	a.resize(n,0);b.resize(n,0);
	ntt.go(&amp;a[0],n);
	ntt.go(&amp;b[0],n);
	for(int i=0;i&lt;n;++i)a[i]=a[i]*b[i]%p;
	ntt.back(&amp;a[0],n);
	a.resize(l);
	return a;
}
 
poly invM(poly f,int m){
	poly g;int n=1;
	g.push_back(pm(f[0]));
	for(;n&lt;m;){
		n&lt;&lt;=1;
		poly t=g;sqr(t);
		for(auto&amp;x:g)x=(x&lt;&lt;1)%p;
		t=mul(poly(f.begin(),min(f.begin()+n,f.end())),t);
		g.resize(n,0);
		for(int i=0;i&lt;n &amp;&amp; i&lt;t.size();++i)g[i]=(g[i]-t[i])%p;
	}
	return poly(g.begin(),g.begin()+m);
}

poly h,g,invG,f;

// comb
#define MAX 300005
#define MOD 663224321
#define ll long long
ll fact[MAX],inverse[MAX],fact_inverse[MAX];

void precalc()
{
	fact[0]=1;
	
	inverse[0]=1;inverse[1]=1;
	
	fact_inverse[0]=1;fact_inverse[1]=1;
	
	for(ll i=1;i&lt;MAX;i++)
		fact[i]=(i*fact[i-1])%MOD;
		
	for(ll i=2;i&lt;MAX;i++)
	{
		inverse[i]=(MOD-((MOD/i) * inverse[MOD % i])%MOD)%MOD;
		fact_inverse[i]=(inverse[i]*fact_inverse[i-1])%MOD;
	}
}
// ENDS

int main(){
	precalc();
	
	int lim=5+(1e5);
	h.resize(lim);g.resize(lim);
	for(int i=0;i&lt;lim;i++){
		h[i]=pm(2,(i*1LL*(i-1))/2);
		h[i]*=fact_inverse[i];
		h[i]%=p;
		
		g[i]=h[i];
		h[i]=i*h[i]%p;
	}
	
	invG=invM(g,lim);
	f=mul(h,invG);
	
	for(int i=1;i&lt;f.size();i++){
		f[i]*=fact[i-1];
		f[i]%=p;
		if(f[i]&lt;0) f[i]+=p;
	}
	
	#define sd(x) scanf("%d",&amp;x)
	int q;sd(q);
	while(q--){
		int n;sd(n);
		printf("%lld\n",f[n]);
	}
}
 
----------
====================
----------
ALGORITHMS.312
hard
----------
PROBLEM STATEMENT:
Superman has been invited to India to celebrate Diwali. Unfortunately, on his arrival he learns that he has been invited mainly to help rescue people from a fire accident that has happened in a posh residential locale of New Delhi, where rescue is proving to be especially difficult. As he reaches the place of the fire, before him there are [expression], which are on fire. Since it is Diwali, some floors of the buildings are empty as the occupants have gone elsewhere for celebrations. In his hurry to start the rescue Superman reaches the top of the building, but realizes that his jumping power is depleted and restricted due to change in his geographical setting.
He soon understands the restrictions of his jumping power, and they are as follows: 


He can use the jumping power any number of times until he reaches the bottom floor, which means he can use the jumping power only until before he reaches the bottom (Ground floor), which means, once he reaches the bottom floor, he cannot move to the top floor again and try to save people. (In one single drop from the top to bottom)
While switching buildings, he loses height [expression] while jumping.


The second restriction is explained below with an example.

Assume [expression].

Given the information about the occupied floors in each of the [expression] buildings, help Superman to determine the maximum number of people he can save in one single drop from the top to the bottom floor with the given restrictions.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

#define dbgs(x) cerr &lt;&lt; (#x) &lt;&lt; " --&gt; " &lt;&lt; (x) &lt;&lt; ' '
#define dbg(x) cerr &lt;&lt; (#x) &lt;&lt; " --&gt; " &lt;&lt; (x) &lt;&lt; endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii&lt;=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii&gt;=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son &gt;&gt; 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair &lt; int ,int &gt; pii;
typedef long long int ll;

const int inf = 1e9, mod = 1e9+7;
const int N = 1905;

int n, H, d, t, mx[N], dp[N][N], ans ,x, h[N][N];

int main(){

	scanf("%d %d %d",&amp;n,&amp;H,&amp;d);

	FOR(i,1,n){
		
		scanf("%d",&amp;t);

		FOR(j,1,t){
			
			scanf("%d",&amp;x);

			h[i][x]++;
			
		}

	}
	
	FOR(j,0,H)
		FOR(i,1,n){

			dp[i][j] = max(dp[i][j-1],mx[j-d]) + h[i][j];
			
			mx[j] = max(mx[j], dp[i][j]);
			
			if(j == H)
				
				ans = max(ans, dp[i][j]);

		}

	cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}

----------
====================
----------
ALGORITHMS.313
hard
----------
PROBLEM STATEMENT:
You are given a hexagonal grid consisting of two rows, each row consisting of [expression].  

For example, for [expression]:



(Note that the [expression].)

Your task is to tile this grid with [expression] tiles that look like the following:



As you can see above, there are three possible orientations in which a tile can be placed.

Your goal is to tile the whole grid such that every cell is covered by a tile, and no two tiles occupy the same cell. To add to the woes, certain cells of the hexagonal grid are blackened. No tile must occupy a blackened cell.

Is it possible to tile the grid?

Here's an example. Suppose we want to tile this grid:



Then we can do the tiling as follows:


----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
using namespace std;

char s[2][13];
int n;
bool can(char s[2][13],int x,int y) {
	//printf("x = %d y = %d\n%s\n%s\n",x,y,s[0],s[1]);
	if (y &gt;= n) {
		return can(s, x + 1, 0);
	}
	if (x &gt; 1) {
		return true;
	}
	if (s[x][y] == '1') {
		return can(s, x, y + 1);
	}
	if ((y + 1 &lt; n) &amp;&amp; (s[x][y + 1] == '0')) {
		s[x][y] = s[x][y + 1] = '1';
		if (can(s, x, y + 1)) {
			return true;
		}
		s[x][y] = s[x][y + 1] = '0';
	}
	if (x == 0) {
		if (s[1][y] == '0') {
			s[0][y] = s[1][y] = '1';
			if (can(s, x , y + 1)) {
				return true;
			}
			s[0][y] = s[1][y] = '0';
		}
		if ((y)  &amp;&amp; (s[1][y - 1] == '0')) {
			s[0][y] = s[1][y - 1] = '1';
			if (can(s, x, y + 1)) {
				return true;
			}
			s[0][y] = s[1][y - 1] = '0';
		}
	}	
	return false;
}
 

int main()  {
int z;
	for (scanf("%d",&amp;z);z;--z) {
		scanf("%d%s%s",&amp;n,s[0],s[1]);
		int sum = 0;
		for (int i = 0; i &lt; n; ++i) {
			sum += s[0][i] - '1';
			sum += s[1][i] - '1';
		}
		puts((((sum &amp; 1) == 0) &amp;&amp; can(s, 0, 0))?"YES":"NO");
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.314
hard
----------
PROBLEM STATEMENT:
Queens on Board

You have an N * M chessboard on which some squares are blocked out. In how many ways can you place one or more queens on the board, such that, no two queens attack each other? Two queens attack each other, if one can reach the other by moving horizontally, vertically, or diagonally without passing over any blocked square. At most one queen can be placed on a square. A queen cannot be placed on a blocked square.
----------
TOP SOLUTION:
----------
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;fstream&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;bitset&gt;
#include &lt;cctype&gt;
#include &lt;utility&gt;
#include &lt;cassert&gt;

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned int ui;
typedef unsigned long long ull;

#define Rep(i,n) for(int i = 0; i &lt; (n); ++i)
#define Repd(i,n) for(int i = (n)-1; i &gt;= 0; --i)
#define For(i,a,b) for(int i = (a); i &lt;= (b); ++i)
#define Ford(i,a,b) for(int i = (a); i &gt;= (b); --i)
#define Fit(i,v) For(__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++i)
#define Fitd(i,v) For(__typeof((v).rbegin()) i = (v).rbegin(); i != (v).rend(); ++i)
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define sz(a) ((int)(a).size())
#define all(a) (a).begin(), (a).end()
#define ms(a,x) memset(a, x, sizeof(a))

template&lt;class F, class T&gt; T convert(F a, int p = -1) { stringstream ss; if (p &gt;= 0) ss &lt;&lt; fixed &lt;&lt; setprecision(p); ss &lt;&lt; a; T r; ss &gt;&gt; r; return r; }
template&lt;class T&gt; T gcd(T a, T b) { T r; while (b != 0) { r = a % b; a = b; b = r; } return a; }
template&lt;class T&gt; T lcm(T a, T b) { return a / gcd(a, b) * b; }
template&lt;class T&gt; T sqr(T x) { return x * x; }
template&lt;class T&gt; T cube(T x) { return x * x * x; }
template&lt;class T&gt; int getbit(T s, int i) { return (s &gt;&gt; i) &amp; 1; }
template&lt;class T&gt; T onbit(T s, int i) { return s | (T(1) &lt;&lt; i); }
template&lt;class T&gt; T offbit(T s, int i) { return s &amp; (~(T(1) &lt;&lt; i)); }
template&lt;class T&gt; int cntbit(T s) { return __builtin_popcount(s); }
const int bfsz = 1 &lt;&lt; 16; char bf[bfsz + 5]; int rsz = 0;int ptr = 0;
char gc() { if (rsz &lt;= 0) { ptr = 0; rsz = (int) fread(bf, 1, bfsz, stdin); if (rsz &lt;= 0) return EOF; } --rsz; return bf[ptr++]; }
void ga(char &amp;c) { c = EOF; while (!isalpha(c)) c = gc(); }
int gs(char s[]) { int l = 0; char c = gc(); while (isspace(c)) c = gc(); while (c != EOF &amp;&amp; !isspace(c)) { s[l++] = c; c = gc(); } s[l] = '\0'; return l; }
template&lt;class T&gt; bool gi(T &amp;v) {
    v = 0; char c = gc(); while (c != EOF &amp;&amp; c != '-' &amp;&amp; !isdigit(c)) c = gc(); if (c == EOF) return false; bool neg = c == '-'; if (neg) c = gc();
    while (isdigit(c)) { v = v * 10 + c - '0'; c = gc(); } if (neg) v = -v; return true;
}

typedef pair&lt;int, int&gt; II;

const ld PI = acos(ld(-1.0));
const ld eps = 1e-9;

const int inf = (int)1e9 + 5;
const ll linf = (ll)1e17 + 5;
int dr[8] = {-1, +1, 0, 0, +1, +1, -1, -1};
int dc[8] = {0, 0, +1, -1, -1, +1, -1, +1};
const int mod = 1000000007;

#define maxn 1000005

int n, m;
int f[55][1 &lt;&lt; 5][1 &lt;&lt; 5][1 &lt;&lt; 5];
int nex[3][1 &lt;&lt; 5], a[105], b[105];
string s[105];
bool can[1 &lt;&lt; 5][1 &lt;&lt; 5];

int cal0(int A){
	return A;
}

int cal1(int A, int num){
	int res = 0;
	For(i, 1, num - 1) if(getbit(A, i)) res = onbit(res, i - 1);
	return res;
}

int cal2(int A, int num){
	int res = 0;
	For(i, 0, num - 2) if(getbit(A, i)) res = onbit(res, i + 1);
	return res;
}

void add(int &amp;a, int b){
	a += b;
	if(a &gt;= mod) a -= mod;
}

void solve(){
	cin &gt;&gt; n &gt;&gt; m;
	Rep(mask, (1 &lt;&lt; m)){
		nex[0][mask] = mask;
		nex[1][mask] = cal1(mask, m);
		nex[2][mask] = cal2(mask, m);
	}

	ms(can, 0);
	Rep(mask, 1 &lt;&lt; m){
		Rep(M, 1 &lt;&lt; m) if((mask &amp; M) == M){
			can[mask][M] = 1;
			Rep(i, m) For(j, i + 1, m - 1) if(getbit(M, i) &amp; getbit(M, j)){
				bool ok = false;
				For(k, i, j) if(!getbit(mask, k)) ok = true;
				if(!ok) can[mask][M] = 0;
			}
		}
	}

	ms(f, 0); f[0][0][0][0] = 1;
	Rep(i, n) {
		cin &gt;&gt; s[i];
		a[i] = 0;
		b[i] = 0;
		Rep(j, m) {
			if(s[i][j] == '.') a[i] = onbit(a[i], j);
			else b[i] = onbit(b[i], j);
		}
	}
	Rep(i, n) Rep(mask1, (1 &lt;&lt; m)) Rep(mask2, (1 &lt;&lt; m)) Rep(mask3, (1 &lt;&lt; m)) if(f[i][mask1][mask2][mask3]){
		int M1, M2, M3;
		int mask = (mask1 | mask2 | mask3);
		Rep(m, (1 &lt;&lt; m)) if(can[a[i]][m] &amp;&amp; (mask &amp; m) == 0){
			M1 = nex[0][(mask1 | m) &amp; a[i]];
			M2 = nex[1][(mask2 | m) &amp; a[i]];
			M3 = nex[2][(mask3 | m) &amp; a[i]];
			add(f[i + 1][M1][M2][M3], f[i][mask1][mask2][mask3]);
		}
	}

	int res = -1;
	Rep(mask1, (1 &lt;&lt; m)) Rep(mask2, (1 &lt;&lt; m)) Rep(mask3, (1 &lt;&lt; m)) {
		add(res, f[n][mask1][mask2][mask3]);
	}
	cout &lt;&lt; res &lt;&lt; endl;
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
//    freopen("in.txt", "r", stdin);
	int test;
	cin &gt;&gt; test;
	Rep(itest, test){
		solve();
	}

    return 0;
}

----------
====================
----------
ALGORITHMS.315
advanced
----------
PROBLEM STATEMENT:
Shashank loves strings, but he loves palindromic strings the most. He has a list of [expression] such that the following conditions are satisfied:


[expression].
[expression] is a palindromic string, where + denotes the string concatenation operator.


You are given [expression], on a new line.

Note: Two subsequences consisting of the same characters are considered to be different if their characters came from different indices in the original string.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

#define forn(i,n) for (int i = 0; i &lt; int(n); i++)
#define ford(i,n) for (int i = int(n) - 1; i &gt;= 0; i--)
#define fore(i,l,r) for (int i = int(l); i &lt; int(r); i++)
#define all(a) a.begin(), a.end()
#define sz(a) int(a.size())
#define mp make_pair
#define pb push_back
#define ft first
#define sc second
#define x first
#define y second

template&lt;typename X&gt; inline X abs(const X&amp; a) { return a &lt; 0 ? -a : a; }
template&lt;typename X&gt; inline X sqr(const X&amp; a) { return a * a; }

typedef long long li;
typedef long double ld;
typedef pair&lt;int, int&gt; pt;

const int INF = int(1e9);
const li INF64 = li(1e18);
const ld EPS = 1e-9;
const ld PI = acosl(ld(-1));

mt19937 mt(time(NULL));

const int N = 1000 + 13;
int n;
string s[N];
char buf[N];

inline void gen()
{
	n = 50;
	forn (i, n)
	{
		s[i].resize(20);
		forn (j, 20)
			s[i][j] = char(mt() % 2 + 'a');
	}
}

inline bool read()
{
	//gen();
	//return true;
	
	if (scanf ("%d", &amp;n) != 1)
		return false;

	forn (i, n)
	{
		assert(scanf ("%s", buf) == 1);
		
		s[i] = string(buf);
	}
	
	return true;
}

const int MOD = 1000 * 1000 * 1000 + 7;

inline int norm (int val)
{
	if (val &gt;= MOD)
		val -= MOD;
		
	return val;
}

int m;
int poss[N];
char t[N];
int d[N][N][2][2][2];

inline void solve()
{
	m = 0;

	forn (i, n)
		forn (j, sz(s[i]))
		{
			t[m] = s[i][j];
			poss[m++] = i;
		}
		
	memset(d, 0, sizeof d);
	d[0][m - 1][0][0][0] = 1;
	
	int ans = 0;
	
	forn (i, m)
		for(int j = m - 1; j &gt;= i; j--)
			forn(k, 2)
				forn (c1, 2)
					forn (c2, 2)
					{
						int dv = d[i][j][k][c1][c2];
						if (!dv)
							continue;
							
						if (i == j)
						{
							//cerr &lt;&lt; 'B' &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; k &lt;&lt; ' ' &lt;&lt; c1 &lt;&lt; ' ' &lt;&lt; c2 &lt;&lt; ' ' &lt;&lt; dv &lt;&lt; endl;
							ans = norm(ans + dv);
							
							continue;
						}
							
						if (k == 0)
						{
							d[i][j][1][c1][c2] = norm(d[i][j][1][c1][c2] + dv);
							
							if (poss[i + 1] == poss[i] || c1)
							{
								int nc1 = c1;
								if (poss[i + 1] != poss[i])
									nc1 = 0;
									
								d[i + 1][j][0][nc1][c2] = norm(d[i + 1][j][0][nc1][c2] + dv);
							}
						}
						else
						{
							if (poss[j - 1] == poss[j] || c2)
							{
								int nc2 = c2;
								if (poss[j - 1] != poss[j])
									nc2 = 0;
									
								d[i][j - 1][1][c1][nc2] = norm(d[i][j - 1][1][c1][nc2] + dv);
							}
							
							if (t[i] == t[j])
							{
								int nc1, nc2;
								if (poss[i + 1] != poss[i])
									nc1 = 0;
								else
									nc1 = 1;
									
								if (poss[j - 1] != poss[j])
									nc2 = 0;
								else
									nc2 = 1;
									
								if (i + 1 == j)
								{
									//cerr &lt;&lt; 'C' &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; k &lt;&lt; ' ' &lt;&lt; c1 &lt;&lt; ' ' &lt;&lt; c2 &lt;&lt; ' ' &lt;&lt; dv &lt;&lt; endl;
									ans = norm(ans + dv);
								}
								else
								{
									if (poss[i] == poss[j] || poss[i] + 1 == poss[j])
									{
										//cerr &lt;&lt; 'A' &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; k &lt;&lt; ' ' &lt;&lt; c1 &lt;&lt; ' ' &lt;&lt; c2 &lt;&lt; ' ' &lt;&lt; dv &lt;&lt; endl;									
										ans = norm(ans + dv);
									}

									d[i + 1][j - 1][0][nc1][nc2] = norm(d[i + 1][j - 1][0][nc1][nc2] + dv);
								}
							}
						}
					}
					
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main()
{
#ifdef SU2_PROJ
	assert(freopen("input.txt", "r", stdin));
	assert(freopen("output.txt", "w", stdout));
#endif

	cout &lt;&lt; setprecision(25) &lt;&lt; fixed;
	cerr &lt;&lt; setprecision(10) &lt;&lt; fixed;

	srand(int(time(NULL)));
	
	int testCnt;
	assert(scanf ("%d", &amp;testCnt) == 1);

	forn (test, testCnt)
	{
		assert(read());
		solve();
	}

#ifdef SU2_PROJ
	cerr &lt;&lt; "TIME: " &lt;&lt; clock() &lt;&lt; endl;
#endif

	return 0;
}

----------
====================
----------
ALGORITHMS.316
advanced
----------
PROBLEM STATEMENT:
There are N points on an XY plane. In one turn, you can select a set of collinear points on the plane and remove them. Your goal is to remove all the points in the least number of turns. Given the coordinates of the points, calculate two things:


The minimum number of turns (T) needed to remove all the points.
The number of ways to to remove them in T turns. Two ways are considered different if any point is removed in a different turn.

----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;
#include&lt;sstream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;string.h&gt;
using namespace std ;
#define MOD 1000000007
#define INF (int)1e9
#define MAXN 20
typedef pair&lt;int,int&gt; P ;

int n,pre[MAXN],fac[MAXN],x[MAXN],y[MAXN] ;
int col[MAXN][MAXN] ;

char bit[1 &lt;&lt; MAXN] ;
char good[1 &lt;&lt; MAXN] ;
char best[1 &lt;&lt; MAXN] ;
char valid[1 &lt;&lt; MAXN] ;

char vid,id[1 &lt;&lt; MAXN] ;
int memo[1 &lt;&lt; MAXN] ;
int solve(int mask)
{
 if(bit[mask] &lt;= 2) return 1 ;
 if(id[mask] == vid) return memo[mask] ;
 if(good[mask]) return pre[bit[mask]] ;
 id[mask] = vid ;

 int j,nmask = mask ;
 for(j = 0;j &lt; n;j++) if(mask &amp; 1 &lt;&lt; j)
 {
  nmask ^= 1 &lt;&lt; j ;
  break ;
 }

 int ways = 0,can = best[mask] ;
 if(best[nmask] == can - 1) ways = solve(nmask) ;
 for(int i = nmask;i &gt; 0;i = ((i - 1) &amp; nmask))
 {
  int k = i | 1 &lt;&lt; j ;
  if(valid[k] &amp;&amp; best[mask ^ k] == can - 1)
  {
   ways += solve(mask ^ k) ;
   if(ways &gt;= MOD) ways -= MOD ;
  }
 }
 return memo[mask] = ways ;
}

void generate()
{
 for(int tt = 0;tt &lt; 10;tt++)
 {
  char in[] = "in .txt" ;
  in[2] = tt + '0' ;
  FILE * fout = fopen(in,"w") ;
  
  int runs = 50 ;
  fprintf(fout,"%d\n",runs) ;
  for(int j = 0;j &lt; runs;j++)
  {
   n = rand() % 18 ;
   if(tt == 8) n = 18 ;
   
   char vis[102][102] ;
   memset(vis,0,sizeof vis) ;
   for(int i = 0;i &lt; n;i++)
   {
    if(tt &lt; 3 &amp;&amp; j &lt; 15)
    {
     x[i] = rand() % 10 ;
     y[i] = rand() % 10 ;     
    }
    else if(tt &lt; 6 &amp;&amp; j &lt; 15)
    {
     x[i] = rand() % 5 ;
     y[i] = rand() % 5 ;
    }
    else if(tt &lt; 10 &amp;&amp; j &lt; 15)
    {
     x[i] = i ;
     y[i] = i + (rand() % 5 - 2) ;
     if(y[i] &lt; 0) y[i] = i ;
    }
    else
    {
     x[i] = rand() % 100 + 1 ;
     y[i] = rand() % 100 + 1 ;
    }
    
    if(vis[x[i]][y[i]]) { i-- ; continue ; }
    vis[x[i]][y[i]] = 1 ;
   }


   fprintf(fout,"%d\n",n) ;
   for(int i = 0;i &lt; n;i++) fprintf(fout,"%d %d\n",x[i],y[i]) ;
  }
  fclose(fout) ;
 }
}

int main()
{
 fac[0] = 1 ;
 for(int i = 1;i &lt; MAXN;i++) fac[i] = 1LL * i * fac[i - 1] % MOD ;
 for(int i = 1;i &lt; 1 &lt;&lt; MAXN;i++) bit[i] = bit[i &gt;&gt; 1] + (i &amp; 1) ;
 pre[0] = pre[1] = 1 ;
 for(int i = 2;i &lt; MAXN;i++)
 {
  pre[i] = 1LL * pre[i - 2] * (i - 1) % MOD ;
  if(i % 2 == 1) pre[i] += pre[i - 1] ;
  pre[i] %= MOD ;
 }

// generate() ; return 0 ;

 int runs ; 
 scanf("%d",&amp;runs) ;
 while(runs--)
 {
  scanf("%d",&amp;n) ;
  for(int i = 0;i &lt; n;i++) scanf("%d%d",&amp;x[i],&amp;y[i]) ;
  
  memset(col,0,sizeof col) ;
  for(int k1 = 0;k1 &lt; n;k1++)
   for(int k2 = 0;k2 &lt; n;k2++)
   {
    for(int j = 0;j &lt; n;j++)
    {
     int area = x[j] * (y[k1] - y[k2]) + x[k1] * (y[k2] - y[j]) + x[k2] * (y[j] - y[k1]) ;
     if(area == 0) col[k1][k2] |= 1 &lt;&lt; j ;
    }
   }
  
  for(int i = 0;i &lt; 1 &lt;&lt; n;i++)
  {
   if(bit[i] &lt;= 2) { valid[i] = true ; continue ; }
   for(int j = 0;j &lt; n;j++) if(i &amp; 1 &lt;&lt; j)
   {
    int k1 = -1 ;
    for(int k = j + 1;k &lt; n;k++) if(i &amp; 1 &lt;&lt; k) { k1 = k ; break ; }
    if((col[j][k1] | i) == col[j][k1]) valid[i] = true ;
    else valid[i] = false ;
    break ;
   }
  }
  
  best[0] = 0 ;
  for(int i = 1;i &lt; 1 &lt;&lt; n;i++)
  {
   if(bit[i] == 1) { best[i] = 1 ; continue ; }
   int j;
   for(j = 0;j &lt; n;j++) if(i &amp; 1 &lt;&lt; j) break ;
   
   int cret = n ;
   for(int k = j + 1;k &lt; n;k++)
    if(i &amp; 1 &lt;&lt; k)
     cret = min(cret,1 + best[i &amp; ~col[j][k]]) ;
   best[i] = cret ;
  }
  
  for(int i = 0;i &lt; 1 &lt;&lt; n;i++)
  {
   good[i] = 1 ;
   if(bit[i] &lt;= 2) continue ;
   int j;
   for(j = 0;j &lt; n;j++) if(i &amp; 1 &lt;&lt; j) break ;
   if(!good[i ^ 1 &lt;&lt; j]) { good[i] = 0 ; continue ; }
   
   for(int k = j + 1;k &lt; n;k++)
    if(i &amp; 1 &lt;&lt; k)
     if(bit[i &amp; col[j][k]] &gt; 2)
      good[i] = 0 ;
  }
  
  int tot = best[(1 &lt;&lt; n) - 1] ;
  vid++ ;
  int ret = solve((1 &lt;&lt; n) - 1) ;
  ret = 1LL * ret * fac[tot] % MOD ;
  printf("%d %d\n",tot,ret) ;
 }
 
 return 0 ;
}

----------
====================
----------
ALGORITHMS.317
hard
----------
PROBLEM STATEMENT:
There are [expression]. 
Each bulb [expression] will be toggled(off-&gt;on, on-&gt;off). 

Given [expression] bulbs if they're all on initially.
----------
TOP SOLUTION:
----------
/*
*/

#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;
#include &lt;memory.h&gt;
#include &lt;assert.h&gt;

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 350

using namespace std;

const int INF = 1e9;
const int N = 200031;

int n, k, ar[N];

long long solve(int start)
{
	long long res = 0;
	for (int i = start; i &lt;= n; i += 2 * k + 1)
	{
		res += ar[i];
		if (i + k + 1 &lt;= n&amp;&amp;i + k * 2 + 1 &gt; n)
			return 1e18;
	}
	return res;
}

bool good_mask(int mask)
{
	int ar[25];

	for (int i = 0; i &lt; n; i++)
	{
		ar[i] = 1;
	}
	for (int i = 0; i &lt; n; i++)
	{
		if (mask&amp;(1 &lt;&lt; i))
		{
			for (int j = i - k; j &lt;= i + k; j++)
			{
				if (j &gt;= 0 &amp;&amp; j &lt; n)
					ar[j] ^= 1;
			}
		}
	}
	for (int i = 0; i &lt; n; i++)
	{
		if (ar[i])
			return 0;
	}
	return 1;
}

int ans_mask;

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);

	while (true)
	{
		cin &gt;&gt; n &gt;&gt; k;
		for (int i = 1; i &lt;= n; i++)
		{
			cin &gt;&gt; ar[i];
			//ar[i] = rand() % 10;
		}

		long long ans = 1e18;

		/*for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++)
		{
		if (good_mask(mask))
		{
		int here = 0;
		for (int i = 0; i &lt; n; i++)
		{
		if (mask&amp;(1 &lt;&lt; i))
		here += ar[i + 1];
		}
		if (here &lt; ans)
		ans = min(ans, 0ll + here),
		ans_mask = mask;
		}
		}*/
		long long ans2 = 1e18;

		for (int F = 1; F &lt;= k + 1&amp;&amp;F&lt;=n; F++)
		{
			ans2 = min(ans2, solve(F));
		}

		/*if (ans != ans2)
		{
		cout &lt;&lt; "!" &lt;&lt; endl;
		for (int i = 1; i &lt;= n; i++)
		{
		cout &lt;&lt; ar[i] &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
		cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; ans2 &lt;&lt; " " &lt;&lt; ans_mask &lt;&lt; endl;
		while (true);
		}

		else
		cout &lt;&lt; "OK" &lt;&lt; endl;*/

		cout &lt;&lt; ans2 &lt;&lt; endl;
		return 0;
	}
	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.318
hard
----------
PROBLEM STATEMENT:
Capeta is working part-time for an animal shipping company. He needs to pick up animals from various zoos and drop them to other zoos. The company ships four kinds of animals: elephants, dogs, cats, and mice.

There are [expression] where Capeta needs to deliver it to. 



Capeta is given a truck with a huge capacity where [expression] animals can easily fit. He is also given additional instructions:


He must visit the zoos in increasing order. He also cannot skip zoos. 
Dogs are scared of elephants, so he is not allowed to bring them together at the same time. 
Cats are scared of dogs, so he is not allowed to bring them together at the same time. 
Mice are scared of cats, so he is not allowed to bring them together at the same time. 
Elephants are scared of mice, so he is not allowed to bring them together at the same time. 


Also, loading and unloading animals are complicated, so once an animal is loaded onto the truck, that animal will only be unloaded at its destination. 

Because of these reasons, Capeta might not be able to transport all animals. He will need to ignore some animals. Which ones? The company decided to leave that decision for Capeta. He is asked to prepare a report and present it at a board meeting of the company.

Capeta needs to report the minimum number of zoos that must be reached so that she is able to transport [expression]. 

Complete the function minimumZooNumbers and return an integer array where the [expression] animals. 

He is good at driving, but not so much at planning. Hence, he needs your help.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
#define f first
#define s second
#define mp make_pair
#define pb push_back
#define lp(i,a,n) for(int i=a;i&lt;=n;++i)
#define lpd(i,a,n) for(int i=a;i&gt;=n;--i)
#define mem(a,b) memset(a,b,sizeof a)
#define all(v) v.begin(),v.end()
#define println(a) cout &lt;&lt;(a) &lt;&lt;endl
#define sz(x) ((int)(x).size())
#define readi(x) scanf("%d",&amp;x)
#define read2i(x,y) scanf("%d%d",&amp;x,&amp;y)
#define read3i(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)
#define mod 1000000007
#define eps 1e-8
#define infi 1000000000
#define infll 1000000000000000000ll
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; pii;
typedef pair&lt;ll,ll&gt; pll;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef vector&lt;ll&gt; vll;
typedef set&lt;int&gt; si;
typedef map&lt;int,int&gt; mii;

const int N = 50002;
int t,m,n,dp[N][2];
int tree[4*N][2],lazy[4*N][2];
int type[N],s[N],d[N];
vvi g(N);

void propagate(int i, int j, bool leaf){
    tree[i][j] += lazy[i][j];
    if(!leaf){
        lazy[2*i][j] += lazy[i][j];
        lazy[2*i+1][j] += lazy[i][j];
    }
    lazy[i][j] = 0;
}

int query(int i, int start, int end, int l, int r, int j){
    propagate(i, j, start == end);
    if(l &lt;= start &amp;&amp; r &gt;= end) return tree[i][j];
    if(r &lt; start || l &gt; end) return 0;
    int mid = (start+end)/2;
    return max(query(2*i,start,mid,l,r,j), query(2*i+1,mid+1,end,l,r,j));
}

void update(int i, int start, int end, int l, int r, int j, int v){
    propagate(i, j, start == end);
    if(l &lt;= start &amp;&amp; r &gt;= end){
        lazy[i][j] += v;
        propagate(i, j, start == end);
        return;
    }
    if(r &lt; start || l &gt; end) return;

    int mid = (start+end)/2;
    update(2*i, start, mid, l, r, j, v);
    update(2*i+1, mid+1, end, l, r, j, v);

    tree[i][j] = max(tree[2*i][j], tree[2*i+1][j]);
}

int main(){
    readi(t);
    while(t--){
        read2i(m,n);
        lp(i,1,n){
            char c;
            scanf(" %c", &amp;c);
            type[i] = c == 'D' or c == 'M' ? 0 : 1;
        }
        lp(i,1,n) readi(s[i]);
        lp(i,1,n) readi(d[i]), g[d[i]].pb(i);

        lp(i,1,m){
            for(int idx : g[i]) if(s[idx] &lt; i) update(1,1,m, 1, s[idx], !type[idx], 1);
            dp[i][0] = query(1,1,m, 1, i, 1);
            dp[i][1] = query(1,1,m, 1, i, 0);
            update(1,1,m, i, i, 0, dp[i][0]);
            update(1,1,m, i, i, 1, dp[i][1]);
        }

        vi ans;
        lp(i,1,m) ans.pb(max(dp[i][0], dp[i][1]));
        lp(i,1,n){
            int x = lower_bound(all(ans), i) - ans.begin() + 1;
            if(x == m+1) x = -1;
            printf("%d ", x);
        }
        puts("");

        g.clear();
        g.resize(N);
        mem(tree, 0);
        mem(lazy, 0);
    }
}

/*
freopen("input.txt","r",stdin);
freopen("output.txt","w",stdout);
*/

----------
====================
----------
ALGORITHMS.319
medium
----------
PROBLEM STATEMENT:
It is the Indian version of the famous heist “The Italian Job”. N robbers have already broken into the National Museum and are just about to get inside the main vault which is full of jewels. They were lucky that just as they broke into the museum, the guard was leaving the museum for exactly G minutes. But there are other problems too. The main vault has heat sensors that if at any moment of time there are more than two people present in the vault, the alarm goes off.  

To collect the jewels, the ith robber needs to be inside the vault for exactly A[i] minutes, 0 &lt;= i &lt; N, in one continuous stretch. As guard will return after G minutes, they have to finish their tasks within G minutes. The robbers want to know if there exists any arrangement such that demands of each robber is satisfied and also they are not caught?

Gotchas 
If a robber goes inside the vault at a time "X" and at the same time another robber comes out, it's equivalent to saying they were never in the vault at the same time. 
Similarly, when the guard gets inside vault at time G and a robber comes out exactly at time G, the guard will not be able see the robber.
----------
TOP SOLUTION:
----------
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define NMAX 101
#define VMAX 10001

int A[NMAX];
char ok[VMAX];
int N, G, i, j, sum;

int main() {
	int T;
	scanf("%d", &amp;T);

	while (T--) {
		scanf("%d %d", &amp;N, &amp;G);
		for (sum = 0, i = 1; i &lt;= N; i++) {
			scanf("%d", &amp;(A[i]));
			sum += A[i];
		}

		memset(ok, 0, sizeof(ok));
		ok[0] = 1;
		for (i = 1; i &lt;= N; i++)
			for (j = VMAX - 1 - A[i]; j &gt;= 0; j--)
				if (ok[j]) ok[j + A[i]] = 1;

		for (i = 0; i &lt; VMAX; i++)
			if (ok[i] &amp;&amp; i &lt;= G &amp;&amp; (sum - i) &lt;= G) {
				printf("YES\n");
				break;
			}

		if (i == VMAX)
			printf("NO\n");
	}

	return 0;
}

----------
====================
----------
ALGORITHMS.320
advanced
----------
PROBLEM STATEMENT:
There are [expression] variable. 

Your task is to assign non-negative numbers smaller than [expression].
----------
TOP SOLUTION:
----------
#include &lt;cstdlib&gt;
#include &lt;cctype&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;iomanip&gt;
#include &lt;bitset&gt;
#include &lt;list&gt;
#include &lt;stdexcept&gt;
#include &lt;functional&gt;
#include &lt;utility&gt;
#include &lt;ctime&gt;
#include &lt;complex&gt;
using namespace std;

// begin insert defines
#define two(x) (1LL&lt;&lt;(x))
#define forE(elem,v)  for(__typeof__(v.begin()) _it = v.begin(); _it != v.end();++_it) for(int _once=1, _done=0; _once; (!_done) ? (_it=v.end(), --_it) :_it ) for(__typeof__(*_it) &amp; elem = * _it; _once &amp;&amp; !(_once=0); _done=1)
#define Rep(i,n) for(int n_ = (n), i = 0; i&lt; n_; ++i)

// end insert defines

const int N = 13, B = 1 &lt;&lt; 13, M = 1007, L = 10;

vector&lt;int&gt; lnk[N];
int ls[B], f[L][B];

void madd(int &amp;a, int b)
{
  a += b;
  if (a &gt;= M) a -= M;
}

int dp(int lv, int s)
{
  if (lv &gt;= 10) return !s;
  int &amp;ret = f[lv][s];
  if (ret != -1) return ret;
  ret = 0;
  for (int subset = s; subset &gt; 0; subset = (subset - 1) &amp; s) {
    if (!(ls[subset] &amp; (~s))) {
      madd(ret, dp(lv + 1, s ^ subset));
    }
  }
  madd(ret, dp(lv + 1, s));
  return ret;
}

int n, m;

int main(int argc, char *argv[])
{
  cin &gt;&gt; n &gt;&gt; m;
  Rep(i, n) lnk[i].clear();
  Rep(i, m) {
    int x, y;
    cin &gt;&gt; x &gt;&gt; y;
    lnk[x].push_back(y);
  }
  Rep(i, two(n)) {
    ls[i] = 0;
    Rep(j, n) if (two(j) &amp; i) forE(v, lnk[j]) ls[i] |= two(v);
  }
  memset(f, -1, sizeof(f));
  cout &lt;&lt; dp(0, two(n) - 1) &lt;&lt; endl;
  return 0;
}

----------
====================
----------
ALGORITHMS.321
hard
----------
PROBLEM STATEMENT:
Ma5termind is crazy about Action Games. He just bought a new one and got down to play it. Ma5termind usually finishes all the levels of a game very fast. But, This time however he got stuck at the very first level of this new game. Can you help him play this game.  

To finish the game, Ma5termind has to cross [expression]. To knock down an enemy, Ma5termind needs to shoot him with one or multiple bullets whose collective count is equal to the power of the enemy. If Ma5termind manages to knock down any one enemy at a level, the rest of them run away and the level is cleared.   

Here comes the challenging part of the game. 
Ma5termind acquires all the bullets of an enemy once he has knocked him down. Ma5termind can use the bullets acquired after killing an enemy at [expression] level.  

However, the bullets Ma5termind carried before the start of the game can be taken forward and can be used to kill more enemies.  

Now, Ma5termind has to guess the minimum number of bullets he must have before the start of the game so that he clears all the [expression] levels successfully.  

NOTE  


Bullets carried before the start of the game can be used to kill an enemy at any level.  
One bullet decreases the power of an enemy by 1 Unit.  
For better understanding of the problem look at the sample testcases.  

----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#define MX 105
#define INF 100000000
using namespace std;

int val[MX][1005], N, M;
vector &lt;int&gt; P[MX], B[MX];

int calc(int n, int b) {
	int &amp;ret = val[n][b];
	if (ret != -1) return ret;
	if (n == N) return ret = 0;
	ret = INF;
	for (int i = 0; i &lt; M; i++) ret = min(ret, max(P[n][i] - b, 0)  + calc(n + 1, B[n][i]));
	return ret;
}

int main() {
	int T, i, j, k;
	for (scanf("%d", &amp;T); T--; ) {
		scanf("%d%d", &amp;N, &amp;M);
		memset(val, -1, sizeof val);
		for (i = 0; i &lt; N; i++) {
			P[i].clear();
			B[i].clear();
			P[i].resize(M + 1);
			B[i].resize(M + 1);
		}
		for (i = 0; i &lt; N; i++) for (j = 0; j &lt; M; j++) scanf("%d", &amp;P[i][j]);
		for (i = 0; i &lt; N; i++) for (j = 0; j &lt; M; j++) scanf("%d", &amp;B[i][j]);
		printf("%d\n", calc(0, 0));
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.322
hard
----------
PROBLEM STATEMENT:
Logan and Veronica live in Neptune, which has [expression].

Logan and Veronica are looking for clues and need to find the number of different paths of length [expression] edge in the path. Two paths are different if the binary sequences characterizing these paths are distinct. Note that they may need to visit the same house several times or use the same road several times to find all possible paths.

Given a map of Neptune, help Logan and Veronica find and print the number of different paths of length [expression] to the other houses in Neptune.
----------
TOP SOLUTION:
----------
SOLUTION NOT FOUND
----------
====================
----------
ALGORITHMS.323
hard
----------
PROBLEM STATEMENT:
Byteland has [expression] or more connected roads. It is guaranteed that there is a path from any city to any other city.

Steven is a road maintenance worker in Byteland. He is required to maintain exactly [expression] roads). Steven can start his workday in any city and, once he has finished maintaining a path, teleport to his next starting city.

Given [expression].
----------
TOP SOLUTION:
----------
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;limits&gt;
#include &lt;functional&gt;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus &gt; 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; inline void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; inline void amax(T &amp;x, U y) { if(x &lt; y) x = y; }


template&lt;int MOD&gt;
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt &lt; 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt &lt; 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &amp;operator+=(ModInt that) { if((x += that.x) &gt;= MOD) x -= MOD; return *this; }
	ModInt &amp;operator-=(ModInt that) { if((x += MOD - that.x) &gt;= MOD) x -= MOD; return *this; }
	ModInt &amp;operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
};
typedef ModInt&lt;1000000007&gt; mint;

int M;
vector&lt;vector&lt;int&gt; &gt; g;
vector&lt;mint&gt; memo;
mint rec(int i, int j, int p, int d1s, int m) {
	if(d1s &gt; M)
		return mint();
	if(j == g[i].size())
		return m == 0 ? 1 : 0;
	if(g[i][j] == p)
		return rec(i, j + 1, p, d1s, m);
	int c = g[i][j];
	mint &amp;r = memo[(c * (M + 1) + d1s) * (M + 1) + m];
	if(r.x != -1)
		return r;
	r = mint();
	rer(n, 0, m) {
		r +=
			rec(c, 0, i, 0, n) *
			rec(i, j + 1, p, d1s, m - n);
	}
	rer(n, 0, m - 1) {
		r +=
			rec(c, 0, i, 1, n) *
			rec(i, j + 1, p, d1s + 1, m - 1 - n);
	}
	if(d1s &gt; 0) rer(n, 0, m) {
		r +=
			rec(c, 0, i, 1, n) *
			rec(i, j + 1, p, d1s - 1, m - n) *
			d1s;
	}
	return r;
}

int main() {
	int N;
	while(~scanf("%d%d", &amp;N, &amp;M)) {
		g.assign(N, vi());
		for(int i = 0; i &lt; N - 1; ++ i) {
			int u, v;
			scanf("%d%d", &amp;u, &amp;v), -- u, -- v;
			g[u].push_back(v);
			g[v].push_back(u);
		}
		mint undef; undef.x = -1;
		memo.assign(N * (M + 1) * (M + 1), undef);
		mint ans = rec(0, 0, -1, 0, M);
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.324
advanced
----------
PROBLEM STATEMENT:
ADZEN is a popular advertising firm in your city that owns all [expression], ADZEN must remove either the middle billboard, the first two billboards, the last two billboards or the first and last billboard.

Being a for-profit company, ADZEN wants to lose as little advertising revenue as possible when removing the billboards. They want to comply with the new ordinance in such a way that the remaining billboards maximize their total revenues (i.e., the sum of  revenues generated by the billboards left standing on Main street).

Given [expression] billboards that can be removed but cannot be reordered in any way.  

For example, if there are [expression].  

Function Description  

Complete the billboards function in the editor below.  It should return an integer that represents the maximum revenue that can be generated under the rules.  

billboards has the following parameter(s):  


k: an integer that represents the longest contiguous group of billboards allowed  
revenue: an integer array where each element represents the revenue potential for a billboard at that index  

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;list&gt;
const int maxn = 100001;
long long mindec[maxn];

long long answer;

int main(){
        int n,k;
        std::cin&gt;&gt;n&gt;&gt;k;
        std::list&lt;int&gt; prev;
        mindec[0] = 0;
        prev.push_back(0);
        for (int i=1; i&lt;=n; ++i){
                long long v;
                std::cin&gt;&gt;v;
                answer += v;
                if (prev.front() &lt; i-k-1) prev.pop_front();
                mindec[i] = v + mindec[prev.front()];
                while (! prev.empty() &amp;&amp; mindec[prev.back()] &gt;= mindec[i]) prev.pop_back();
                prev.push_back(i);
        }
        if (prev.front() &lt; n-k) prev.pop_front();
        std::cout&lt;&lt;answer-mindec[prev.front()]&lt;&lt;std::endl;
}

----------
====================
----------
ALGORITHMS.325
hard
----------
PROBLEM STATEMENT:
You are given a string, [expression], consisting of lowercase English letters.

A string is beautiful with respect to [expression] characters.

Find and print the number of different strings that are beautiful with respect to [expression].
----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;
#include &lt;memory.h&gt;
#include &lt;assert.h&gt;

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 512

const int N = 1031;

using namespace std;

string st;
int naive(string st)
{
	set&lt;string&gt; res;
	for (int i = 0; i &lt; st.size(); i++)
	{
		for (int j = i + 1; j &lt; st.size(); j++)
		{
			string temp = "";
			for (int q = 0; q &lt; st.size(); q++)
			{
				if (q != i&amp;&amp;q != j)
					temp += st[q];
			}
			res.insert(temp);
		}
	}

	set&lt;string&gt;::iterator it;
	/*for (it = res.begin(); it != res.end(); it++)
	{
		cout &lt;&lt; *it &lt;&lt; endl;
	}*/
	return res.size();
}

long long smart(string st)
{
	int cnt = 0;
	vector&lt;int&gt; v;
	long long ans = 0;
	for (int i = 0; i &lt; st.size(); i++)
	{
		if (i == 0 || st[i] == st[i - 1])
			++cnt;
		else
		{
			v.push_back(cnt);
			cnt = 1;
		}
	}
	v.push_back(cnt);
	for (int i = 0; i &lt; v.size(); i++)
	{
		if (v[i]&gt;1)
			++ans;
	}

	for (int i = 1; i +1&lt; st.size(); i++)
	{
		if (st[i - 1] == st[i + 1] &amp;&amp; st[i] != st[i - 1])
			--ans;
	}
	ans += v.size() * 1ll * (v.size() - 1) / 2;
	return ans;
}

int main(){
//	freopen("hospital.in","r",stdin);
//	freopen("hospital.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);
	
	cin &gt;&gt; st;
//	cout &lt;&lt; naive(st) &lt;&lt; endl;

	cout &lt;&lt; smart(st) &lt;&lt; endl;
	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.326
hard
----------
PROBLEM STATEMENT:
There is a huge blanket on your bed but unfortunately it has N stains. You cover them using 
a single, rectangular silk cloth. The silk is expensive, which is why the rectangular piece needs to have the least area as possible. You love this blanket and decide to minimize the area covering the  stains. You buy some cleaning liquid to remove the stains but sadly it isn't enough to clean all of them. You can just remove exactly K stains. The rest of the stains need to be covered using a single, rectangular fragment of silk cloth.

Let X denote the area of the smallest possible silk cloth that may cover all the stains originally. You need to find the number of different ways in which you may remove K stains so that the remaining N-K stains can be covered with silk of area strictly less than X (We are looking for any configuration that will reduce the cost).

Assume that each stain is a point and that the rectangle is aligned parallel to the axes.  
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

const int MOD = 1000000007, MAXN = 1005;

int binom[MAXN][MAXN];

int N, K;
int X[MAXN], Y[MAXN];
int Xmin, Xmax, Ymin, Ymax;
pair&lt;int, int&gt; dude[4];

inline int calc(vector&lt;pair&lt;int, int&gt; &gt; vec) {
	int num = 0;
	for(int i = 0 ; i &lt; N ; i++) {
		for(int j = 0 ; j &lt; (int)vec.size() ; j++) {
			if (vec[j].first == 0 &amp;&amp; X[i] == vec[j].second) {
				num++;
				break;
			}	else if (vec[j].first == 1 &amp;&amp; Y[i] == vec[j].second) {
				num++;
				break;
			}
		}
	}
	if (num &gt; K) {
		return 0;
	}	else {
		return binom[N - num][K - num];
	}
}

int main() {
	scanf("%d %d", &amp;N, &amp;K);
	binom[0][0] = 1;
	for(int i = 1 ; i &lt;= N ; i++) {
		binom[i][0] = 1;
		for(int j = 1 ; j &lt;= i ; j++) {
			binom[i][j] = (binom[i - 1][j] + binom[i - 1][j - 1]) % MOD;
		}
	}
	
	for(int i = 0 ; i &lt; N ; i++) {
		scanf("%d %d", &amp;X[i], &amp;Y[i]);
	}
	Xmin = X[0];
	Xmax = X[0];
	Ymin = Y[0];
	Ymax = Y[1];
	for(int i = 1 ; i &lt; N ; i++) {
		Xmin = min(Xmin, X[i]);
		Xmax = max(Xmax, X[i]);
		Ymin = min(Ymin, Y[i]);
		Ymax = max(Ymax, Y[i]);
	}
	dude[0] = make_pair(0, Xmin);
	dude[1] = make_pair(0, Xmax);
	dude[2] = make_pair(1, Ymin);
	dude[3] = make_pair(1, Ymax);
	int ans = 0;
	for(int mask = 1 ; mask &lt; 16 ; mask++) {
		int sgn = __builtin_popcount(mask);
		vector&lt;pair&lt;int,int&gt; &gt; v;
		for(int i = 0 ; i &lt; 4 ; i++) {
			if ((mask &gt;&gt; i) &amp; 1) {
				v.push_back(dude[i]);
			}
		}
		if (sgn &amp; 1) {
			ans = (ans + calc(v)) % MOD;
		}	else {
			ans = (ans - calc(v)) % MOD;
		}
	}
	ans = (ans + MOD) % MOD;
	ans = (ans + MOD) % MOD;
	printf("%d\n", ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.327
hard
----------
PROBLEM STATEMENT:
Alex has two arrays defined as [expression]. 

For example, if [expression] like so:




  [expression]
  [expression]
  [expression]



  [expression]
  [expression]
  [expression]


  [expression]
  [expression]
  [expression]




Alex's friend Kiara loves matrices, so he gives her [expression]. For each question, find and print the number of distinct integers in the given submatrix on a new line.
----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class C2 {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	void solve()
	{
		int n = ni(), m = ni(), Q = ni();
		int[] a = na(n);
		int[] b = na(m);
		for(int z = 0;z &lt; Q;z++){
			int dist = 0;
			int r1 = ni(), c1 = ni(), r2 = ni(), c2 = ni();
			int[] fr = make(a, r1, r2);
			int[] fc = make(b, c1, c2);
			long[] f = new long[100005];
			for(int i = 0;i &lt; 100005;i++)f[i] = (long)fr[i] * fc[i];
			for(int i = 100004;i &gt;= 1;i--){
				for(int j = 2*i;j &lt; 100005;j+=i){
					f[i] -= f[j];
				}
			}
			for(int i = 0;i &lt; 100005;i++){
				assert f[i] &gt;= 0;
				if(f[i] &gt; 0)dist++;
			}
			out.println(dist);
		}
	}
	
	int[] make(int[] a, int l, int r)
	{
		int[] f = new int[100005];
		for(int i = l;i &lt;= r;i++){
			for(int d = 1;d*d &lt;= a[i];d++){
				if(a[i] % d == 0){
					f[d]++;
					if(d*d &lt; a[i])f[a[i]/d]++;
				}
			}
		}
		return f;
	}
	
	public static long gcd3(long a, long b) {
		if(a == 0)return b;
		if(b == 0)return a;
		
		int ashift = Long.numberOfTrailingZeros(a);
		int bshift = Long.numberOfTrailingZeros(b);
		a &gt;&gt;&gt;= ashift;
		b &gt;&gt;&gt;= bshift;
		while(b != a){
			if(a &gt; b){
				long t = a; a = b; b = t;
			}
			b -= a;
			b &gt;&gt;&gt;= Long.numberOfTrailingZeros(b);
		}
		
		return a&lt;&lt;Math.min(ashift, bshift);
	}

	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new C2().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.328
advanced
----------
PROBLEM STATEMENT:
Let's play Fairy Chess!

You have an [expression]) within the confines of the chessboard, meaning that diagonal moves are not allowed. In addition, the leaper cannot leap to any square that is occupied by a pawn.

Given the layout of the chessboard, can you determine the number of ways a leaper can move [expression] times within the chessboard?

Note: [expression].
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

#define long long long

const int maxn = 210;
const int mod = 1000000007;

int n, m, s;
char map[maxn][maxn];
long ans[maxn][maxn];
long sum[maxn][2*maxn];

void init()
{
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
	for(int i=0; i&lt;n; ++i)
		cin&gt;&gt;map[i];
}

long getsum(int x, int y)
{
	if(x&lt;0) {
		y += x;
		x = 0;
	}
	if(x&gt;=n) {
		y = y - x + n - 1;
		x = n - 1;
	}
	if(y&lt;0)
		return 0;
	return sum[x][y];
}

void calc_sum()
{
	for(int j=0; j&lt;2*n; ++j)
		for(int i=0; i&lt;n; ++i)
		{
			if(j&gt;=n)
				sum[i][j] = 0;
			else
				sum[i][j] = ans[i][j];
			sum[i][j] = (sum[i][j] + getsum(i-1, j-1) + getsum(i+1, j-1) - getsum(i, j-2) + mod) % mod;
		}
}

void solve() {
	memset(ans, 0, sizeof(ans));
	for(int i=0; i&lt;n; ++i)
		for(int j=0; j&lt;n; ++j)
			if(map[i][j] == 'L')
				ans[i][j] = 1;
	for(int k=1; k&lt;=m; ++k) {
		calc_sum();
		for(int i=0; i&lt;n; ++i)
			for(int j=0; j&lt;n; ++j)
				if(map[i][j] == 'P')
					ans[i][j] = 0;
				else
				{
					ans[i][j] = (getsum(i, j+s) - getsum(i-s-1, j-1) - getsum(i+s+1, j-1) + getsum(i, j-s-2) + mod + mod)%mod;
					ans[i][j] = (ans[i][j] + getsum(i, j+s-1) - getsum(i-s, j-1) - getsum(i+s, j-1) + getsum(i, j-s-1) + mod + mod)%mod;
				}
	}

	long res = 0;
	for(int i=0; i&lt;n; ++i)
		for(int j=0; j&lt;n; ++j)
			res = (res + ans[i][j])%mod;
	cout&lt;&lt;res&lt;&lt;endl;
}

int main() {
	int t;
	cin&gt;&gt;t;
	while(t--)
	{
		init();
		solve();
	}
}

----------
====================
----------
ALGORITHMS.329
expert
----------
PROBLEM STATEMENT:
Megan is playing a string game with the following rules:


It starts with a string, [expression].
During each turn, she performs the following move:

Choose an index in [expression]. The chosen index must be strictly greater than any index chosen in a prior move. 
Perform one or more circular rotations (in either direction) of the suffix starting at the chosen index.

For example, let's say [expression]: 
 
Note that this counts as one move.
The goal of the game is to convert [expression] into the lexicographically smallest possible string in as few moves as possible. In other words, we want the characters to be in alphabetical order.


Megan plays this game [expression] into the lexicographically smallest string and print that number on a new line.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define N 1010
#define inf 1010

int t;
char s[N];
map &lt;string, int&gt; mp;

int solve(char *s) {
//	puts(s);
	int len = strlen(s);
	if (!len) return 0;
	if (mp.count(s)) return mp[s];
	char c = *min_element(s, s + len);
	if (s[0] == c) return mp[s] = solve(s + 1);
	int rlt = 0;
	char ss[N];
	int runs = 0;
	bool vis[N];
	for (int i = 0; i &lt; len; i ++) if (s[i] != c) {
		ss[runs] = s[i];
		int prv = i ? i - 1 : len - 1;
		vis[runs++] = s[prv] == c;
		if (i &lt; len - 1 &amp;&amp; s[i+1] == c) rlt ++;
	}
	ss[runs] = 0;
	len = runs;
	c = *min_element(ss, ss + len);
	bool start_c = 0;
	for (int i = 0; i &lt; len; i ++) {
		if (vis[i] &amp;&amp; ss[i] == c) {
			start_c = 1; break;
		}
	}
	int mn = inf;
    char sss[N];
	for (int i = 0; i &lt; len; i ++) if (vis[i]) {
		if (start_c &amp;&amp; ss[i] != c) continue;
		for (int j = 0; j &lt; len; j ++) sss[j] = ss[(j+i)%len];
		sss[len] = 0;
		mn = min(mn, solve(sss));
	}
	return mp[s] = rlt + mn;
}

int main() {
//	freopen("s.in", "r", stdin);
//	freopen("s.out", "w", stdout);
	scanf("%d", &amp;t);
	while (t --) {
		scanf("%s", s);
		printf("%d\n", solve(s));
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.330
hard
----------
PROBLEM STATEMENT:
Nina received an odd New Year's present from a student: a set of [expression]. Deciding to turn the gift into a lesson, Nina asks her students the following:

How many ways can you build a square using exactly [expression] of these unbreakable sticks? 

Note: Two ways are distinct if they use at least one different stick. As there are [expression] choices of sticks, we must determine which combinations of sticks can build a square.
----------
TOP SOLUTION:
----------
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

using namespace std;

int main()
{
	const int max_l = 10000000;
	const int max_sticks = 3000;
	const int max_r = 4;
	
	// Precompute binomial coefficients up to choose 4
	uint64_t bin_coeff[1 + max_sticks][1 + max_r];
	
	for(uint64_t n = 1; n &lt;= max_sticks; n++)
	{
		bin_coeff[n][0] = 1ULL;
		
		for(uint64_t r = 1; r &lt;= ((n &lt; max_r) ? n : max_r); r++)
			bin_coeff[n][r] = (bin_coeff[n][r - 1] * (n - (r - 1))) / r;
	}
	
	int n;
	
	cin &gt;&gt; n;
	
	vector&lt;int&gt; sticks;
	map&lt;int,int&gt; sticks_multiplicity;
	vector&lt;pair&lt;int,int&gt; &gt; sticks_multiplicity_sorted;
	
	vector&lt;int&gt; sticks_multiplicity_array(1 + max_l, 0);
	
	for(int i = 0; i &lt; n; i++)
	{
		int a;
		
		cin &gt;&gt; a;
		
		sticks.push_back(a);
		
		if(sticks_multiplicity.find(a) == sticks_multiplicity.end())
			sticks_multiplicity[a] = 0;
			
		sticks_multiplicity[a]++;
		sticks_multiplicity_array[a]++;
	}
	
	sort(sticks.begin(), sticks.end());
	
	for(auto i = sticks_multiplicity.begin(); i != sticks_multiplicity.end(); i++)
		sticks_multiplicity_sorted.push_back(pair&lt;int,int&gt;(i-&gt;first,i-&gt;second));
		
	uint64_t count = 0ULL;
	
	// (1,1,1,3) case
	// Need to find sticks of multiplicity &gt;= 3
	vector&lt;pair&lt;int,int&gt; &gt; sticks_multiplicity_3;
	
	for(int i = 0; i &lt; sticks_multiplicity_sorted.size(); i++)
		if(sticks_multiplicity_sorted[i].second &gt;= 3)
			sticks_multiplicity_3.push_back(sticks_multiplicity_sorted[i]);
	
	// a + b + c, 2a + b, 3a
	// Strategy is to hash all possible pairs of integers a + b
	vector&lt;uint64_t&gt; pair_hash(2 * max_l + 1, 0);
	
	pair_hash[sticks[0] + sticks[1]] = 1;
	
	// O(n^2)
	for(int i = 2; i &lt; sticks.size(); i++)
	{
		for(int j = 0; j &lt; sticks_multiplicity_3.size(); j++)
			if(sticks_multiplicity_3[j].first - sticks[i] &gt;= 0)
				count += bin_coeff[sticks_multiplicity_3[j].second][3] * (uint64_t) pair_hash[sticks_multiplicity_3[j].first - sticks[i]];
		
		// Update pair_hash
		for(int j = 0; j &lt; i; j++)
			pair_hash[sticks[i] + sticks[j]]++;
	}
	
	// (1,1,2,2) case
	// Sub-cases: (2a,2a), (2a,b+c), (a+b,a+b) and (a+b,c+d)
	fill(pair_hash.begin(), pair_hash.end(), 0);
	
	vector&lt;uint64_t&gt; &amp;unique_pair_hash = pair_hash;
	
	// Data structures for (a+b,c+d)
	vector&lt;uint64_t&gt; pair_accum(2 * max_l + 1, 0ULL);
	vector&lt;uint64_t&gt; pair_combo(2 * max_l + 1, 0ULL);
	
	for(int i = 0; i &lt; sticks_multiplicity_sorted.size(); i++)
		for(int j = i + 1; j &lt; sticks_multiplicity_sorted.size(); j++)
		{
			// (a+b) data structure
			unique_pair_hash[sticks_multiplicity_sorted[i].first + sticks_multiplicity_sorted[j].first] +=
				sticks_multiplicity_sorted[i].second * sticks_multiplicity_sorted[j].second;
				
			// (a+b,c+d) data structure
			pair_combo[sticks_multiplicity_sorted[i].first + sticks_multiplicity_sorted[j].first] +=
				pair_accum[sticks_multiplicity_sorted[i].first + sticks_multiplicity_sorted[j].first] * 
				sticks_multiplicity_sorted[i].second * sticks_multiplicity_sorted[j].second;
				
			pair_accum[sticks_multiplicity_sorted[i].first + sticks_multiplicity_sorted[j].first] +=
				sticks_multiplicity_sorted[i].second * sticks_multiplicity_sorted[j].second;
		}
	
	vector&lt;pair&lt;int,int&gt; &gt; sticks_multiplicity_2;
	
	for(int i = 0; i &lt; sticks_multiplicity_sorted.size(); i++)
		if(sticks_multiplicity_sorted[i].second &gt;= 2)
		{
			sticks_multiplicity_2.push_back(sticks_multiplicity_sorted[i]);
			
			// (2a,2a)
			if(((sticks_multiplicity_sorted[i].first % 2) == 0) &amp;&amp; (sticks_multiplicity_array[sticks_multiplicity_sorted[i].first / 2] &gt;= 4))
				count += bin_coeff[sticks_multiplicity_sorted[i].second][2] * bin_coeff[sticks_multiplicity_array[sticks_multiplicity_sorted[i].first / 2]][4];
				
			// (2a,b+c)
			if(((sticks_multiplicity_sorted[i].first % 2) == 0) &amp;&amp; (sticks_multiplicity_array[sticks_multiplicity_sorted[i].first / 2] &gt;= 2))
				count += bin_coeff[sticks_multiplicity_sorted[i].second][2]
					* bin_coeff[sticks_multiplicity_array[sticks_multiplicity_sorted[i].first / 2]][2]
					* (uint64_t) unique_pair_hash[sticks_multiplicity_sorted[i].first];
					
			// (a+b,c+d)
			count += bin_coeff[sticks_multiplicity_sorted[i].second][2] *
				pair_combo[sticks_multiplicity_sorted[i].first];
		}
		
	// (a+b,a+b)
	// a and b must occur at least with a multiplicity of 2
	fill(pair_hash.begin(), pair_hash.end(), 0);
	
	for(int i = 0; i &lt; sticks_multiplicity_2.size(); i++)
		for(int j = i + 1; j &lt; sticks_multiplicity_2.size(); j++)
			unique_pair_hash[sticks_multiplicity_2[i].first + sticks_multiplicity_2[j].first] +=
				bin_coeff[sticks_multiplicity_2[i].second][2] * bin_coeff[sticks_multiplicity_2[j].second][2];
				
	for(int i = 0; i &lt; sticks_multiplicity_2.size(); i++)
		count += bin_coeff[sticks_multiplicity_2[i].second][2] *
			(uint64_t) unique_pair_hash[sticks_multiplicity_2[i].first];
			
	cout &lt;&lt; count &lt;&lt; endl;
	
	return 0;
}
----------
====================
----------
ALGORITHMS.331
medium
----------
PROBLEM STATEMENT:
There are N cities and N directed roads in Steven's world. The cities are numbered from 0 to N - 1. Steven can travel from city i to city (i + 1) % N, ( 0-&gt; 1 -&gt; 2 -&gt; .... -&gt; N - 1 -&gt; 0). 

Steven wants to travel around the world by car. The capacity of his car's fuel tank is C gallons. There are a[i] gallons he can use at the beginning of city i and the car takes b[i] gallons to travel from city i to (i + 1) % N.  

How many cities can Steven start his car from so that he can travel around the world and reach the same city he started? 

Note  

The fuel tank is initially empty. 
----------
TOP SOLUTION:
----------
/******************************************************************************\
*                         Author:  Dumbear                                     *
*                         Email:   dumbear[#at]163.com                         *
*                         Website: http://dumbear.com                          *
\******************************************************************************/
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;cctype&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;numeric&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;typeinfo&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

using namespace std;

#define output(x) cout &lt;&lt; #x &lt;&lt; ": " &lt;&lt; (x) &lt;&lt; endl;

typedef long long LL;
typedef vector&lt;int&gt; VI;
typedef vector&lt;long long&gt; VL;
typedef vector&lt;double&gt; VD;
typedef vector&lt;string&gt; VS;

const int max_n = 100000 + 10;

int n, a[max_n], b[max_n];
LL c, fuel[max_n];

int get_start() {
    int valid_start = -1;
    int start_city = 0, current_city = 0;
    LL current_fuel = 0;
    for (int i = 0; i &lt; n * 2 + 10; ++i) {
        fuel[current_city] = current_fuel;
        int next_city = (current_city + 1) % n;
        LL next_fuel = min(current_fuel + a[current_city], c) - b[current_city];
        if (next_fuel &lt; 0) {
            start_city = current_city = next_city;
            current_fuel = 0;
        } else if (next_city == start_city) {
            valid_start = start_city;
            break;
        } else {
            current_city = next_city;
            current_fuel = next_fuel;
        }
    }
    return valid_start;
}

int count_start() {
    int start = get_start();
    if (start == -1)
        return 0;
    int current = start;
    while (true) {
        int pre = (current + n - 1) % n;
        LL tmp = min(max(fuel[current] + b[pre] - a[pre], 0LL), c);
        if (tmp == fuel[pre])
            break;
        fuel[pre] = tmp;
        current = pre;
    }
    return count(fuel, fuel + n, 0);
}

void solve() {
    cin &gt;&gt; n &gt;&gt; c;
    for (int i = 0; i &lt; n; ++i)
        scanf("%d", &amp;a[i]);
    for (int i = 0; i &lt; n; ++i)
        scanf("%d", &amp;b[i]);
    printf("%d\n", count_start());
}

int main() {
    solve();
    return 0;
}

----------
====================
----------
ALGORITHMS.332
hard
----------
PROBLEM STATEMENT:
Steve loves playing with palindromes. He has a string, [expression]. Two ways are considered to be different if either of the following conditions are satisfied:


The positions of insertion are different.
The inserted characters are different. 


This means there are at most [expression].

Given [expression].
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I &lt; (N); ++I)
#define REPP(I, A, B) for (int I = (A); I &lt; (B); ++I)
#define RI(X) scanf("%d", &amp;(X))
#define RII(X, Y) scanf("%d%d", &amp;(X), &amp;(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &amp;(X), &amp;(Y), &amp;(Z))
#define DRI(X) int (X); scanf("%d", &amp;X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &amp;X, &amp;Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &amp;X, &amp;Y, &amp;Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &amp;___T); while (___T-- &gt; 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define PII pair&lt;int,int&gt;
#define VI vector&lt;int&gt;
#define VPII vector&lt;pair&lt;int,int&gt; &gt;
#define PLL pair&lt;long long,long long&gt;
#define VPLL vector&lt;pair&lt;long long,long long&gt; &gt;
#define F first
#define S second
typedef long long LL;
using namespace std;
const int MOD = 1e9+7;
const int SIZE = 3005;
int dp[SIZE][SIZE];
int dp2[SIZE][SIZE];
char s[SIZE];
int main(){
    CASET{
        DRII(n,K);
        RS(s+1);
        if(K&gt;2)puts("0");
        else if(K==0){
            printf("%d\n",n*26+26);
        }
        else{
            MS0(dp);
            MS0(dp2);
            REPP(i,1,n+1)dp2[i][i]=1;
            REPP(j,1,n){
                for(int k=1;k+j&lt;=n;k++){
                    int ll=k,rr=k+j;
                    if(s[ll]==s[rr])dp2[ll][rr]=max(dp2[ll][rr],dp2[ll+1][rr-1]+2);
                    dp2[ll][rr]=max(dp2[ll][rr],dp2[ll+1][rr]);
                    dp2[ll][rr]=max(dp2[ll][rr],dp2[ll][rr-1]);
                }
            }
            int ma=0;
            for(int i=1;i&lt;n;i++){
                for(int j=n;j&gt;i;j--){
                    if(s[i]==s[j])dp[i][j]=dp[i-1][j+1]+2;
                    else dp[i][j]=max(dp[i-1][j],dp[i][j+1]);
                    ma=max(ma,dp[i][j]);
                }
            }
            REPP(i,1,n+1)ma=max(ma,dp[i-1][i+1]+1);
            int an=0;
            REP(i,n+1){
                int me=0;
                me=dp[i][i+1]+1;
                if(me&gt;=ma+K){
                    an+=26;
                    continue;
                }
                bool used[26]={};
                REPP(j,1,n+1){
                    if(j&lt;=i){
                        if(dp2[j+1][i]+dp[j-1][i+1]+2&gt;=ma+K)used[s[j]-'a']=1;
                    }
                    else{
                        if(dp2[i+1][j-1]+dp[i][j+1]+2&gt;=ma+K)used[s[j]-'a']=1;
                    }
                }
                REP(j,26)
                    if(used[j]){
                        an++;
                    }
            }
            printf("%d\n",an);
        }
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.333
medium
----------
PROBLEM STATEMENT:
Tim is visiting his grandma for two days and is bored due to the lack of the electricity over there. That's why he starts to play with grandma's colorful candle collection.

He aligned the [expression], the number of colors. 

Now he stares at the sequence of candles and wonders, how many strictly increasing ( in height ) colorful subsequences are there? A subsequence is considered as colorful if every of the [expression] colors appears at least one times in the subsequence. 

As the number of subsequences fulfilling the requirement can be large, print the result modulo [expression].
----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;limits&gt;
#include &lt;functional&gt;
#include &lt;bitset&gt;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus &gt; 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector&lt;int&gt; vi; typedef pair&lt;int,int&gt; pii; typedef vector&lt;pair&lt;int,int&gt; &gt; vpii;
typedef long long ll; typedef vector&lt;long long&gt; vl; typedef pair&lt;long long,long long&gt; pll; typedef vector&lt;pair&lt;long long,long long&gt; &gt; vpll;
typedef vector&lt;string&gt; vs; typedef long double ld;
template&lt;typename T, typename U&gt; inline void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; inline void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

template&lt;int MOD&gt;
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt(): x(0) { }
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt &lt; 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt &lt; 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }
	
	ModInt &amp;operator+=(ModInt that) { if((x += that.x) &gt;= MOD) x -= MOD; return *this; }
	ModInt &amp;operator-=(ModInt that) { if((x += MOD - that.x) &gt;= MOD) x -= MOD; return *this; }
	ModInt &amp;operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	
	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
};
typedef ModInt&lt;1000000007&gt; mint;

struct FenwickTree {
	typedef mint T;
	vector&lt;T&gt; v;
	void init(int n) { v.assign(n, 0); }
	void add(int i, T x) {
		for(; i &lt; (int)v.size(); i |= i+1) v[i] += x;
	}
	T sum(int i) const {	//[0, i)
		T r = 0;
		for(-- i; i &gt;= 0; i = (i &amp; (i+1)) - 1) r += v[i];
		return r;
	}
	T sum(int left, int right) const {	//[left, right)
		return sum(right) - sum(left);
	}
};

int main() {
	int N, K;
	scanf("%d%d", &amp;N, &amp;K);
	vector&lt;int&gt; H(N), C(N);
	rep(i, N)
		scanf("%d%d", &amp;H[i], &amp;C[i]), -- C[i];
	vector&lt;FenwickTree&gt; dp(1 &lt;&lt; K);
	rep(k, 1 &lt;&lt; K) dp[k].init(50001);
	dp[0].add(0, mint(1));
	rep(i, N) {
		int c = C[i], h = H[i];
		for(int j = (1 &lt;&lt; K)-1; j &gt;= 0; -- j) {
			mint x = dp[j].sum(h);
			dp[j | 1 &lt;&lt; c].add(h, x);
		}
	}
	mint ans = dp[(1 &lt;&lt; K)-1].sum(50001);
	printf("%d\n", ans.get());
	return 0;
}

----------
====================
----------
ALGORITHMS.334
advanced
----------
PROBLEM STATEMENT:
String [expression] is called a Super String if and only if:


[expression];
For any [expression]


Given a set of Super Strings [expression]. We can use each Super String as many times as we want.

Given set [expression].  
----------
TOP SOLUTION:
----------
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;

using namespace std;
#define ll long long int 
vector&lt;string&gt; vs , distr;
map&lt;string , int &gt; mp;

void f( string s , int &amp;N   ) {
	if( mp[s] ) return;
	mp[s] = 1;
	char ch = s[s.size()-1];
	for( int i = 0; i &lt; N; i++ ) {	
		if( vs[i][0] &gt; ch ) f( s+vs[i] , N );
	}
	distr.push_back(s);
}

long long int dp[200][12];
int DISTR;

long long int MOD = 1000000007;

long long int f1( int len , int lastchar ) {
	
	if( len &lt;= 0 ) return 1;
	long long int &amp;ret = dp[len][lastchar];
	if( ret == -1ll ) { 
		ret = 0ll;
		for( int i = 0; i &lt; DISTR; i++ ) {
			int tsz = distr[i].size();
			int fs = distr[i][0]-'a' , ls = distr[i][tsz-1]-'a';
			if( (tsz &lt;= len) &amp;&amp;  (fs) &lt;= lastchar ) ret += f1( len-tsz , ls );
			ret %= MOD;
		}
	}
	return ret;
}
int main () {
	int N , L;mp.clear();
	scanf("%d %d" , &amp;N , &amp;L );	
	for( int i = 0; i &lt; N; i++ ) {
		string s; cin &gt;&gt; s;
		vs.push_back(s);
	}
	
	f( "" , N );	
	int sz = distr.size()-1;	
	distr.resize(sz);DISTR = sz;

	sort( distr.begin()  , distr.end() );
/*	cout &lt;&lt; DISTR &lt;&lt; "\n";
	for( int i = 0; i &lt; DISTR; i++ ) cout &lt;&lt; distr[i] &lt;&lt; "\n";
*/
	memset( dp , -1  , sizeof(dp) );		
	ll ans = 0;
	for( int i = 0; i &lt;= L; i++ ) {
		ans += f1( i , 11 );
		ans %= MOD;
	}
	cout &lt;&lt; ans &lt;&lt; "\n";
 
	return 0;
}
----------
====================
----------
ALGORITHMS.335
medium
----------
PROBLEM STATEMENT:
You are given an array A = [1, 2, 3, ..., n]:     


How many sequences (S1) can you get after exact k adjacent swaps on A? 
How many sequences (S2) can you get after at most k swaps on A?  


An adjacent swap can be made between two elements of the Array A, A[i] and A[i+1] or A[i] and A[i-1]. 
A swap otherwise can be between any two elements of the array A[i] and A[j] ∀ 1 ≤ i, j ≤ N, i ≠ j.
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.Arrays;

public class Solution {

    final static long mod = 1000000007;

    public static void solve(Input in, PrintWriter out) throws IOException {
        int n = in.nextInt();
        int k = in.nextInt();
        long[] d = new long[k + 1];
        d[0] = 1;
        for (int it = 0; it &lt; n; ++it) {
            long[] dd = new long[k + 1];
            long sum = 0;
            for (int i = 0; i &lt;= k; ++i) {
                sum = (sum + d[i]) % mod;
                dd[i] = sum;
                if (i &gt;= it) {
                    sum = (sum + mod - d[i - it]) % mod;
                }
            }
            d = dd;
        }
//        System.err.println(Arrays.toString(d));
        long ans1 = 0;
        for (int i = 0; i &lt;= k; ++i) {
            if (i % 2 == k % 2) {
                ans1 = (ans1 + d[i]) % mod;
            }
        }
        long[] d1 = new long[n + 1];
        d1[0] = 1;
        for (int it = 0; it &lt; n; ++it) {
            for (int i = n; i &gt;= 1; --i) {
                d1[i] = (d1[i] * it + d1[i - 1]) % mod;
            }
            d1[0] = 0;
        }
//        System.err.println(Arrays.toString(d1));
        long ans2 = 0;
        for (int i = 1; i &lt;= n; ++i) {
            if (n - i &lt;= k) {
                ans2 = (ans2 + d1[i]) % mod;
            }
        }
        out.println(ans1 + " " + ans2);
    }

    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);
        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);
        out.close();
    }

    static class Input {
        BufferedReader in;
        StringBuilder sb = new StringBuilder();

        public Input(BufferedReader in) {
            this.in = in;
        }

        public Input(String s) {
            this.in = new BufferedReader(new StringReader(s));
        }

        public String next() throws IOException {
            sb.setLength(0);
            while (true) {
                int c = in.read();
                if (c == -1) {
                    return null;
                }
                if (" \n\r\t".indexOf(c) == -1) {
                    sb.append((char)c);
                    break;
                }
            }
            while (true) {
                int c = in.read();
                if (c == -1 || " \n\r\t".indexOf(c) != -1) {
                    break;
                }
                sb.append((char)c);
            }
            return sb.toString();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }
}

----------
====================
----------
ALGORITHMS.336
medium
----------
PROBLEM STATEMENT:
Let's consider a permutation P = {p1, p2, ..., pN} of the set of N = {1, 2, 3, ..., N} elements .  

P is called a magic set if it satisfies both of the following constraints:  


Given a set of K integers, the elements in positions a1, a2, ..., aK are less than their adjacent elements, i.e., pai-1 &gt; pai &lt; pai+1
Given a set of L integers, elements in positions b1, b2, ..., bL are  greater than their adjacent elements, i.e., pbi-1 &lt; pbi &gt; pbi+1


How many such magic sets are there?

Input Format 
The first line of input contains three integers N, K, L separated by a single space. 
The second line contains K integers, a1, a2, ... aK each separated by single space. 
the third line contains L integers, b1, b2, ... bL each separated by single space. 

Output Format 
Output the answer modulo 1000000007 (109+7).

Constraints 
3 &lt;= N &lt;= 5000 
1 &lt;= K, L &lt;= 5000 
2 &lt;= ai, bj &lt;= N-1, where i ∈ [1, K] AND j ∈ [1, L]  

Sample Input #00  

4 1 1
2
3


Sample Output #00  

5


Explanation #00

Here, N = 4 a1 = 2 and b1 = 3. The 5 permutations of {1,2,3,4} that satisfy the condition are 


2 1 4 3
3 2 4 1
4 2 3 1
3 1 4 2
4 1 3 2


Sample Input #01

10 2 2
2 4
3 9


Sample Output #01

161280

----------
TOP SOLUTION:
----------
#include&lt;math.h&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;map&gt;
#include&lt;ext/hash_map&gt;
#include&lt;ext/hash_set&gt;
#include&lt;set&gt;
#include&lt;string&gt;
#include&lt;assert.h&gt;
#include&lt;vector&gt;
#include&lt;time.h&gt;
#include&lt;queue&gt;
#include&lt;deque&gt;
#include&lt;sstream&gt;
#include&lt;stack&gt;
#include&lt;sstream&gt;
#define MA(a,b) ((a)&gt;(b)?(a):(b))
#define MI(a,b) ((a)&lt;(b)?(a):(b))
#define AB(a) (-(a)&lt;(a)?(a):-(a))
#define X first
#define Y second
#define mp make_pair
#define pb push_back
#define pob pop_back
#define ep 0.0000000001
#define pi 3.1415926535897932384626433832795

using namespace std;
using namespace __gnu_cxx;
const long long P=1000000000+7;
const int N=5001;

int n,m,i,j,kk,k,l,r;
int a[N];
long long d[N],dd[N];
int main()
{
    cin&gt;&gt;n&gt;&gt;k&gt;&gt;l;
    for (i=1;i&lt;=k;i++)
    {
        cin&gt;&gt;j;
        a[j]|=1;
        a[j+1]|=2;
    }
    for (i=1;i&lt;=l;i++)
    {
        cin&gt;&gt;j;
        a[j]|=2;
        a[j+1]|=1;
    }
    for (i=2;i&lt;=n;i++)
    if (a[i]==3) {cout&lt;&lt;0&lt;&lt;endl; return 0;}
    d[1]=1;
    for (i=2;i&lt;=n;i++)
    {
        for (j=1;j&lt;=n;j++)
            d[j]=(d[j]+d[j-1])%P;
        if (a[i]==2)
        {
            for (j=1;j&lt;=i;j++)
            dd[j]=d[j-1];
        } else
        if (a[i]==1)
        {
            for (j=1;j&lt;=i;j++)
            dd[j]=(d[n]-d[j-1]+P)%P;
        }else
            for (j=1;j&lt;=i;j++)
            dd[j]=d[n];

        for (j=1;j&lt;=n;j++) d[j]=0;
      for (j=1;j&lt;=i;j++)
    d[j]=dd[j];
    // for (j=1;j&lt;=i;j++)
   //  cout&lt;&lt;d[j]&lt;&lt;" ";cout&lt;&lt;endl;
    }
    long long ans=0;
    for (i=1;i&lt;=n;i++) ans=(ans+d[i])%P;
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}


----------
====================
----------
ALGORITHMS.337
hard
----------
PROBLEM STATEMENT:
Square Subsequences

A string is called a square string if it can be obtained by concatenating two copies of the same string. For example, "abab", "aa" are square strings, while "aaa", "abba" are not. Given a string, how many (non-empty) subsequences of the string are square strings? A subsequence of a string can be obtained by deleting zero or more characters from it, and maintaining the relative order of the remaining characters.
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;
#include&lt;sstream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;string.h&gt;
using namespace std ;
#define MAXN 305
#define INF (int)1e9
#define MOD 1000000007

int brute(string s)
{
 int n = s.size() ;
 int ret = 0 ;
 for(int i = 1;i &lt; 1 &lt;&lt; n;i++)
 {
  string t ;
  for(int j = 0;j &lt; n;j++)
   if(i &amp; 1 &lt;&lt; j)
    t.push_back(s[j]) ;
  if(t.size() % 2 == 1) continue ;
  int tt = t.size() ;
  bool valid = true ;
  for(int j = 0;j &lt; tt / 2;j++)
   if(t[j] != t[tt / 2 + j])
    valid = false ;
  if(valid) ret++ ;
 }
 return ret ;
}

string s ;
int n ;
int start1,start2 ;

int memo[MAXN][MAXN] ;
int solve(int k1,int k2)
{
 if(k1 == start2 || k2 == n) return 0 ;
 int ret = s[k1] == s[k2] ? 1 : 0 ;
 if(memo[k1][k2] != -1) return memo[k1][k2] ;
 ret += solve(k1 + 1,k2) ;
 ret += solve(k1,k2 + 1) ;
 if(ret &gt;= MOD) ret -= MOD ; 
 ret -= solve(k1 + 1,k2 + 1) ;
 if(ret &lt; 0) ret += MOD ;
 if(s[k1] == s[k2]) ret += solve(k1 + 1,k2 + 1) ;
 if(ret &gt;= MOD) ret -= MOD ; 
 return memo[k1][k2] = ret ;
}

int solve(string _s)
{
 s = _s ;
 n = s.size() ;
 int ret = 0 ;
 for(start2 = 0;start2 &lt; n;start2++)
 {
  memset(memo,255,sizeof memo) ;
  for(start1 = 0;start1 &lt; start2;start1++)
   if(s[start1] == s[start2])
   {
    int cret = 1 + solve(start1 + 1,start2 + 1) ;
    ret += cret ;
    if(ret &gt;= MOD) ret -= MOD ;
   }
 }
 return ret ;
}

void test()
{
 for(int test = 0;test &lt; 10000;test++)
 {
  int n = rand() % 10 + 1 ;
  string t ;
  for(int j = 0;j &lt; n;j++) t.push_back('a' + rand() % 2) ;
  int ret1 = brute(t) ;
  int ret2 = solve(t) ;
  cout &lt;&lt; ret1 &lt;&lt; " " &lt;&lt; ret2 &lt;&lt; endl ;
  if(ret1 != ret2)
  {
   cout &lt;&lt; "Failed on: " &lt;&lt; test &lt;&lt; endl ;
   cout &lt;&lt; t &lt;&lt; endl ;
   while(1) ;
  }
 }
}

void generate()
{
 char in[10] = "in .txt" ;
 for(int test = 0;test &lt; 10;test++)
 {
  in[2] = test + '0' ;
  FILE * fout = fopen(in,"w") ;
  
  int runs = 20 ;
  fprintf(fout,"%d\n",runs) ;
  for(int t = 0;t &lt; runs;t++)
  {
   string c ;
   int n = rand() % 200 + 1 ;
   if(test &lt; 2) n = rand() % 20 + 1 ;
   
   if(test &lt; 4) for(int i = 0;i &lt; n;i++) c.push_back(rand() % 26 + 'a') ;
   else if(test &lt; 7) for(int i = 0;i &lt; n;i++) c.push_back(rand() % 3 + 'a') ;
   else if(test &lt; 10) for(int i = 0;i &lt; n;i++) c.push_back(rand() % 2 + 'a') ;

   fprintf(fout,"%s\n",c.c_str()) ;
  }
 }
}


int main()
{
// test() ; return 0 ;
// generate() ; return 0 ;

 int runs ;
 cin &gt;&gt; runs ;
 while(runs--)
 {
  string s ;
  cin &gt;&gt; s ;
  int ret = solve(s) ;
  cout &lt;&lt; ret &lt;&lt; endl ;
 }
 return 0 ;
}
----------
====================
----------
ALGORITHMS.338
advanced
----------
PROBLEM STATEMENT:
Mr. Dorsey Dawson recently stole [expression] grams of gold from ACME Jewellers. He is now on a train back home. To avoid getting caught by the police, he has to convert all the gold he has into paper money. He turns into a salesman and starts selling the gold in the train.  

There are [expression] dollars. Dawson wants to escape from the police and also maximize the profit. Can you help him maximize the profit?

Note: The [expression] grams if the transaction is successful.
----------
TOP SOLUTION:
----------
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#include &lt;iomanip&gt;
#include &lt;climits&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stack&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;queue&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,n) for(int i = 0; i &lt;(int)n; i++)
#define foreach(it,x) for(__typeof(x.begin()) it = x.begin() ; it!=x.end() ; it++ )

#ifdef KAZAR
    #define eprintf(...) fprintf(stderr, __VA_ARGS__)
#else
    #define eprintf(...)
#endif

using namespace std;

const int inf = (int)1e9 + 5757;

template&lt;class T&gt; inline void umax(T &amp;a,T b){if(a&lt;b) a = b;}
template&lt;class T&gt; inline void umin(T &amp;a,T b){if(a&gt;b) a = b;}
template&lt;class T&gt; inline T abs(T a){return a&gt;0 ? a : -a;}
template&lt;class T&gt; inline T lcm(T a,T b){return a/gcd(a,b)*b;}

inline int read(){int x;scanf(" %d",&amp;x);return x;}

const int N = 5050;

long long dp[N];
vector&lt;int&gt; g[N];
vector&lt;int&gt; a,b;

int main(){

#ifdef KAZAR
    freopen("f.i","r",stdin);
    freopen("f.cik","w",stdout);
    freopen("error","w",stderr);
#endif

    int n = read();
    int x = read();

    for(int i = 1; i &lt;= n; i++){
        int a = read(), v = read();
        if(v &lt;= x){
            g[v].push_back(a);
        }
    }

    for(int i = 1; i &lt;= x; i++){
        sort(g[i].begin(), g[i].end());
        reverse(g[i].begin(), g[i].end());
        int cnt = min(5000 / i + 1,(int)g[i].size());
        for(int j = 0; j &lt; cnt; j++){
            a.push_back(i);
            b.push_back(g[i][j]);
        }
    }

    memset(dp, -1, sizeof dp);

    dp[0] = 0;

    eprintf("%d\n",a.size());

    for(int i = 0; i &lt; (int)a.size(); i++){
        for(int j = x; j &gt;= 0; j--)
            if(dp[j] != -1 &amp;&amp; j + a[i] &lt;= x)
                umax(dp[j + a[i]],dp[j] + b[i]);
    }

    if(dp[x] == -1){
        puts("Got caught!");
    }else{
        cout &lt;&lt; dp[x] &lt;&lt; endl;
    }

    return 0;
}

----------
====================
----------
ALGORITHMS.339
advanced
----------
PROBLEM STATEMENT:
There are [expression] mines where it can be picked up by trucks. We do this according to the following rules:


You can move gold between any pair of mines (i.e., [expression]).
All the gold at some pickup mine [expression].
Move [expression].


Given [expression] pickup locations according to the above conditions.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
// iostream is too mainstream
#include &lt;cstdio&gt;
// bitch please
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;time.h&gt;
#define dibs reserve
#define OVER9000 1234567890123456789LL
#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)
#define tisic 47
#define soclose 1e-8
#define chocolate win
// so much chocolate
#define patkan 9
#define ff first
#define ss second
#define abs(x) ((x &lt; 0)?-(x):x)
#define uint unsigned int
#define dbl long double
#define pi 3.14159265358979323846
using namespace std;
// mylittledoge

#ifdef DONLINE_JUDGE
	// palindromic tree is better than splay tree!
	#define lld I64d
#endif

int main() {
	cin.sync_with_stdio(0);
	cin.tie(0);
	cout &lt;&lt; fixed &lt;&lt; setprecision(10);
	int N,K;
	cin &gt;&gt; N &gt;&gt; K;
	vector&lt;long long&gt; W(N),X(N);
	for(int i =0; i &lt; N; i++) cin &gt;&gt; X[i] &gt;&gt; W[i];
	vector&lt;long long&gt; sumW(N+1,0),sumWX(N+1,0);
	for(int i =0; i &lt; N; i++) sumW[i+1] =sumW[i]+W[i], sumWX[i+1] =sumWX[i]+W[i]*X[i];
	vector&lt; vector&lt;long long&gt; &gt; ansL(K+1,vector&lt;long long&gt;(N+1,OVER9000));
	vector&lt; vector&lt;long long&gt; &gt; ansR(K+1,vector&lt;long long&gt;(N+1,OVER9000));
	ansR[0][0] =0;

	for(int i =0; i &lt; N; i++) for(int k =0; k &lt; K; k++) {
		if(K-k &gt; N-i+3) continue;
		if(k &gt; i+3) break;
		for(int j =i; j &gt;= 0; j--) {
			ansL[k+1][i+1] =min(ansL[k+1][i+1],(ansR[k][j]+sumWX[j])-sumW[j]*X[i]);
			if(sumWX[j]-sumW[j]*X[i] &gt; ansL[k+1][i+1]) break;}
		ansL[k+1][i+1] +=sumW[i+1]*X[i]-sumWX[i+1];
		for(int j =i; j &gt;= 0; j--) {
			ansR[k+1][i+1] =min(ansR[k+1][i+1],(ansL[k+1][j+1]+X[j]*sumW[j]-sumWX[j])-X[j]*sumW[i+1]);
			if(X[j]*sumW[j]-sumWX[j]-X[j]*sumW[i+1] &gt; ansR[k+1][i+1]) break;}
		ansR[k+1][i+1] +=sumWX[i+1];
		}

	cout &lt;&lt; ansR[K][N] &lt;&lt; "\n";
	return 0;}

// look at my code
// my code is amazing

----------
====================
----------
ALGORITHMS.340
hard
----------
PROBLEM STATEMENT:
Roy is helping the police department of his city in crime fighting. Today, they informed him about a new planned operation.

Think of the city as a [expression] criminals live there. No two criminals live at the same position.

To catch these criminals, the police department has to recruit some police officers and give each of them USD [expression] ).

The police department asks Roy to plan this operation. So Roy has to tell them the number of officers to recruit and the routes these officers should take in order to catch all the criminals. Roy has to provide this information while minimizing the total expenses of this operation.

Find out the minimum amount of money required to complete the operation.
----------
TOP SOLUTION:
----------
#include &lt;stdio.h&gt;
int n, h, st, ed;
long long inp[2000010], deq[2000010], dp[2000010];
inline long long sq(long long x) {
    return x * x;
}
inline long long calc(long long x1, long long v1, long long x2, long long v2) {
    return (v1 - v2 - x2*x2 + x1*x1 + 2*(x1-x2) - 1) / ( 2*(x1-x2));
}
int main() {
    scanf("%d%d", &amp;n, &amp;h);
    for (int i=1; i&lt;=n; i++) scanf("%lld", &amp;inp[i]);
    st = 0;
    ed = 0;
    deq[st++] = 0;
    for (int i=1; i&lt;=n; i++) {
        while (st &gt; ed + 1 &amp;&amp; dp[deq[ed]] + sq(inp[i] - inp[deq[ed]+1]) &gt;=
                              dp[deq[ed+1]] + sq(inp[i] - inp[deq[ed+1]+1])) {
            ed ++;
        }
        dp[i] = dp[deq[ed]] + sq(inp[i] - inp[deq[ed]+1]) + h;
        if (i &lt; n) {
            while (st &gt; ed + 1 &amp;&amp; calc(inp[deq[st-1]+1], dp[deq[st-1]], inp[deq[st-2]+1], dp[deq[st-2]]) &gt;=
                                  calc(inp[i+1], dp[i], inp[deq[st-1]+1], dp[deq[st-1]])) {
                st --;
            }
            deq[st++] = i;
        }
    }
    printf("%lld\n", dp[n]);
    return 0;
}

----------
====================
----------
ALGORITHMS.341
hard
----------
PROBLEM STATEMENT:
Zurikela is creating a graph with a special graph maker. At the begining, it is empty and has no nodes or edges. He can perform [expression] types of operations:    


[expression].    
[expression].      
[expression]. Note that each node can only exist in one set, so other sets become empty.     


The first [expression] is referring to the index of new set:

K = [index of last created set] + 1


Create the graph by completing the [expression] operations specified during input. Then calculate the maximum number of independent nodes (i.e.:how many nodes in the final graph which don't have direct edge between them).
----------
TOP SOLUTION:
----------
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;limits&gt;
#include &lt;functional&gt;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus &gt; 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector&lt;int&gt; vi; typedef pair&lt;int, int&gt; pii; typedef vector&lt;pair&lt;int, int&gt; &gt; vpii; typedef long long ll;
template&lt;typename T, typename U&gt; inline void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; inline void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

vector&lt;int&gt; weight;
vector&lt;vi&gt; tree;
vector&lt;int&gt; child;
vector&lt;int&gt; memo;
int K;

int recTree(int i, int p, int j, bool b) {
	if(tree[i].size() == j) {
		int &amp;r = memo[(K + i) * 2 + b];
		if(r != -1) return r;
		if(!b) {
			return r = 0;
		} else if(child[i] == -1) {
			return r = weight[i];
		} else {
			r = 0;
			rep(cb, 2)
				amax(r, recTree(child[i], -1, 0, cb != 0));
			return r;
		}
	}
	int c = tree[i][j];
	if(c == p)
		return recTree(i, p, j + 1, b);
	int &amp;r = memo[c * 2 + b];
	if(r != -1) return r;
	r = 0;
	amax(r, recTree(c, i, 0, false) + recTree(i, p, j + 1, b));
	if(!b)
		amax(r, recTree(c, i, 0, true) + recTree(i, p, j + 1, b));
	return r;
}

void traverse(int x, vi &amp;q, vector&lt;bool&gt; &amp;vis) {
	q.clear();
	q.push_back(x);
	for(int h = 0; h != q.size(); ++ h) {
		int i = q[h];
		for(int j : tree[i]) if(!vis[j]) {
			vis[j] = true;
			q.push_back(j);
		}
	}
}

int main() {
	int Q;
	while(~scanf("%d", &amp;Q)) {
		K = 0;
		weight.assign(Q, -1);
		tree.assign(Q, vi());
		child.assign(Q, -1);
		vi q;
		vector&lt;bool&gt; vis(Q, false);
		for(int ii = 0; ii &lt; Q; ++ ii) {
			char ty[10];
			scanf("%s", ty);
			if(*ty == 'A') {
				int x;
				scanf("%d", &amp;x);
				weight[K] = x;
				++ K;
			} else if(*ty == 'B') {
				int x; int y;
				scanf("%d%d", &amp;x, &amp;y), -- x, -- y;
				if(!vis[x] &amp;&amp; !vis[y]) {
					tree[x].push_back(y);
					tree[y].push_back(x);
				}
			} else if(*ty == 'C') {
				int x;
				scanf("%d", &amp;x), -- x;
				traverse(x, q, vis);
				child[K] = x;
				++ K;
			} else abort();
		}
		memo.assign(K * 4, -1);
		int ans = 0;
		rep(i, K) if(!vis[i]) {
			traverse(i, q, vis);
			int x = 0;
			rep(b, 2)
				amax(x, recTree(i, -1, 0, b != 0));
			ans += x;
		}
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.342
advanced
----------
PROBLEM STATEMENT:
You are given a sequence of integers a1,a2,a3.....an. You are free to replace any integer with any other positive integer. How many integers must be replaced to make the resulting sequence strictly increasing? 

Input Format 
The first line of the test case contains an integer [expression] - the number of entries in the sequence. 
The next line contains [expression].

Output Format 
Output the minimal number of integers that should be replaced to make the sequence strictly increasing.

Constraints 
[expression] 
[expression]  

Sample Input #00

3
4 10 20


Sample Output #00

0


Sample Input #01

6
1 7 10 2 20 22


Sample Output #01

1


Sample Input #02

5
1 2 2 3 4 


Sample Output #02

3


Explanation 
In the first sample input, we need not replace anything, hence the output is 0. 
In the second sample input, we can replace 2 with any integer between 11 and 19 to make the sequence strictly increasing, hence the output is 1. 
In the third sample input, we can obtain 1, 2, 3, 4, 5 by changing the last three elements of the sequence.
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;fstream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;complex&gt;
#include &lt;utility&gt;
#include &lt;cctype&gt;
#include &lt;list&gt;

using namespace std;

#define FORALL(i,a,b) for(int i=(a);i&lt;=(b);++i)
#define FOR(i,n) for(int i=0;i&lt;(n);++i)
#define FORB(i,a,b) for(int i=(a);i&gt;=(b);--i)

typedef long long ll;
typedef long double ld;
typedef complex&lt;ld&gt; vec;

typedef pair&lt;int,int&gt; pii;
typedef map&lt;int,int&gt; mii;

#define pb push_back
#define mp make_pair

#define INF 2000000001
#define MAXN 1000100
int A[MAXN];
int dp[MAXN];

int main() {
	int N;
	cin &gt;&gt; N;
	A[0] = 1;
	FORALL(i,1,N) scanf("%d",A+i);
	FORALL(i,1,N) A[i] -= i;
	FORALL(i,0,N) dp[i] = INF;
	//FORALL(i,1,N) cout &lt;&lt; A[i] &lt;&lt; " "; cout &lt;&lt; endl;
	dp[0] = 0;
	FORALL(i,1,N) {
		if (A[i] &lt; 0) continue;
		int idx = upper_bound(dp,dp+N,A[i]) - dp - 1;
		//cout &lt;&lt; i &lt;&lt;  " " &lt;&lt; A[i] &lt;&lt; " " &lt;&lt; idx &lt;&lt; endl;
		assert(idx &gt;= 0);
		dp[idx+1] = A[i];
	}
	/*
	FOR(i,N) cout &lt;&lt; A[i] &lt;&lt; endl;
	*/
	int ans = 0;
	FORALL(i,0,N) if (dp[i] &lt; INF) ans = max(ans,i);
	/*
	FORALL(i,0,N) {
		cout &lt;&lt; i &lt;&lt; " " &lt;&lt; dp[i] &lt;&lt; endl;
	}*/
	
	cout &lt;&lt; N-ans &lt;&lt; endl;
}










----------
====================
----------
ALGORITHMS.343
hard
----------
PROBLEM STATEMENT:
In the middle of a nightmare, Maxine suddenly finds herself in a mysterious room with the following items: 


A piece of paper with the word score and the integer [expression] written on it.
A map of the castle where the room is located.
There are [expression].  
There are [expression] bidirectional corridors connecting pairs of rooms. The value of score changes every time she travels up or down a corridor, and this value differs depending on her direction of travel along the corridor. Each corridor can be traveled any number of times in either direction.
Every room is reachable from every other room.  
Maxine is located in the room labeled [expression].  
The exit is located in the room labeled [expression] and Maxine can (but is not required to) exit that level! 


Assume some corridor [expression]. Then:


Traveling corridor [expression].
Traveling corridor [expression]. 


There are [expression]. Given the above information, help Maxine by finding and printing her maximum possible score for each level. Only you can help her wake up from this nightmare!

Note: Recall that the result of a modulo operation is always non-negative.  For example, [expression].  
----------
TOP SOLUTION:
----------
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Iterator;
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.NoSuchElementException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Egor Kulikov (egor@egork.net)
 */
public class Solution {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        LongestModPath solver = new LongestModPath();
        solver.solve(1, in, out);
        out.close();
    }

    static class LongestModPath {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int n = in.readInt();
            int[] a = new int[n];
            int[] b = new int[n];
            int[] x = new int[n];
            IOUtils.readIntArrays(in, a, b, x);
            MiscUtils.decreaseByOne(a, b);
            Graph graph = BidirectionalGraph.createGraph(n, a, b);
            IntList cycle = dfs(graph, 0, -1, new boolean[n]);
            long cycleCost = 0;
            for (int i : cycle) {
                if ((i &amp; 1) == 0) {
                    cycleCost += x[i &gt;&gt; 1];
                } else {
                    cycleCost -= x[i &gt;&gt; 1];
                }
            }
            cycleCost = Math.abs(cycleCost);
            long[] cost = new long[n];
            dfs(graph, graph.source(cycle.get(0)), new boolean[n], cost, x, 0);
            int q = in.readInt();
            for (int i = 0; i &lt; q; i++) {
                int s = in.readInt() - 1;
                int e = in.readInt() - 1;
                long m = in.readInt();
                long mm = m;
                m = IntegerUtils.gcd(m, cycleCost);
                long answer = (cost[e] - cost[s]) % m;
                if (answer &lt; 0) {
                    answer += m;
                }
                answer += mm - m;
                out.printLine(answer);
            }
        }

        private void dfs(Graph graph, int vertex, boolean[] visited, long[] cost, int[] x, long current) {
            if (visited[vertex]) {
                return;
            }
            visited[vertex] = true;
            cost[vertex] = current;
            for (int i = graph.firstOutbound(vertex); i != -1; i = graph.nextOutbound(i)) {
                int next = graph.destination(i);
                dfs(graph, next, visited, cost, x, current + ((i &amp; 1) == 0 ? x[i &gt;&gt; 1] : -x[i &gt;&gt; 1]));
            }
        }

        private IntList dfs(Graph graph, int vertex, int edge, boolean[] visited) {
            visited[vertex] = true;
            for (int i = graph.firstOutbound(vertex); i != -1; i = graph.nextOutbound(i)) {
                if ((i ^ 1) == edge) {
                    continue;
                }
                int next = graph.destination(i);
                if (visited[next]) {
                    IntList result = new IntArrayList();
                    result.add(i);
                    return result;
                }
                IntList result = dfs(graph, next, i, visited);
                if (result != null) {
                    if (graph.destination(result.first()) != graph.source(result.last())) {
                        result.add(i);
                    }
                    return result;
                }
            }
            return null;
        }

    }

    static class Graph {
        public static final int REMOVED_BIT = 0;
        protected int vertexCount;
        protected int edgeCount;
        private int[] firstOutbound;
        private int[] firstInbound;
        private Edge[] edges;
        private int[] nextInbound;
        private int[] nextOutbound;
        private int[] from;
        private int[] to;
        private long[] weight;
        public long[] capacity;
        private int[] reverseEdge;
        private int[] flags;

        public Graph(int vertexCount) {
            this(vertexCount, vertexCount);
        }

        public Graph(int vertexCount, int edgeCapacity) {
            this.vertexCount = vertexCount;
            firstOutbound = new int[vertexCount];
            Arrays.fill(firstOutbound, -1);

            from = new int[edgeCapacity];
            to = new int[edgeCapacity];
            nextOutbound = new int[edgeCapacity];
            flags = new int[edgeCapacity];
        }

        public int addEdge(int fromID, int toID, long weight, long capacity, int reverseEdge) {
            ensureEdgeCapacity(edgeCount + 1);
            if (firstOutbound[fromID] != -1) {
                nextOutbound[edgeCount] = firstOutbound[fromID];
            } else {
                nextOutbound[edgeCount] = -1;
            }
            firstOutbound[fromID] = edgeCount;
            if (firstInbound != null) {
                if (firstInbound[toID] != -1) {
                    nextInbound[edgeCount] = firstInbound[toID];
                } else {
                    nextInbound[edgeCount] = -1;
                }
                firstInbound[toID] = edgeCount;
            }
            this.from[edgeCount] = fromID;
            this.to[edgeCount] = toID;
            if (capacity != 0) {
                if (this.capacity == null) {
                    this.capacity = new long[from.length];
                }
                this.capacity[edgeCount] = capacity;
            }
            if (weight != 0) {
                if (this.weight == null) {
                    this.weight = new long[from.length];
                }
                this.weight[edgeCount] = weight;
            }
            if (reverseEdge != -1) {
                if (this.reverseEdge == null) {
                    this.reverseEdge = new int[from.length];
                    Arrays.fill(this.reverseEdge, 0, edgeCount, -1);
                }
                this.reverseEdge[edgeCount] = reverseEdge;
            }
            if (edges != null) {
                edges[edgeCount] = createEdge(edgeCount);
            }
            return edgeCount++;
        }

        protected final GraphEdge createEdge(int id) {
            return new GraphEdge(id);
        }

        public final int addFlowWeightedEdge(int from, int to, long weight, long capacity) {
            if (capacity == 0) {
                return addEdge(from, to, weight, 0, -1);
            } else {
                int lastEdgeCount = edgeCount;
                addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());
                return addEdge(from, to, weight, capacity, lastEdgeCount);
            }
        }

        protected int entriesPerEdge() {
            return 1;
        }

        public final int addWeightedEdge(int from, int to, long weight) {
            return addFlowWeightedEdge(from, to, weight, 0);
        }

        public final int addSimpleEdge(int from, int to) {
            return addWeightedEdge(from, to, 0);
        }

        protected final int edgeCapacity() {
            return from.length;
        }

        public final int firstOutbound(int vertex) {
            int id = firstOutbound[vertex];
            while (id != -1 &amp;&amp; isRemoved(id)) {
                id = nextOutbound[id];
            }
            return id;
        }

        public final int nextOutbound(int id) {
            id = nextOutbound[id];
            while (id != -1 &amp;&amp; isRemoved(id)) {
                id = nextOutbound[id];
            }
            return id;
        }

        public final int source(int id) {
            return from[id];
        }

        public final int destination(int id) {
            return to[id];
        }

        public final boolean flag(int id, int bit) {
            return (flags[id] &gt;&gt; bit &amp; 1) != 0;
        }

        public final boolean isRemoved(int id) {
            return flag(id, REMOVED_BIT);
        }

        protected void ensureEdgeCapacity(int size) {
            if (from.length &lt; size) {
                int newSize = Math.max(size, 2 * from.length);
                if (edges != null) {
                    edges = resize(edges, newSize);
                }
                from = resize(from, newSize);
                to = resize(to, newSize);
                nextOutbound = resize(nextOutbound, newSize);
                if (nextInbound != null) {
                    nextInbound = resize(nextInbound, newSize);
                }
                if (weight != null) {
                    weight = resize(weight, newSize);
                }
                if (capacity != null) {
                    capacity = resize(capacity, newSize);
                }
                if (reverseEdge != null) {
                    reverseEdge = resize(reverseEdge, newSize);
                }
                flags = resize(flags, newSize);
            }
        }

        protected final int[] resize(int[] array, int size) {
            int[] newArray = new int[size];
            System.arraycopy(array, 0, newArray, 0, array.length);
            return newArray;
        }

        private long[] resize(long[] array, int size) {
            long[] newArray = new long[size];
            System.arraycopy(array, 0, newArray, 0, array.length);
            return newArray;
        }

        private Edge[] resize(Edge[] array, int size) {
            Edge[] newArray = new Edge[size];
            System.arraycopy(array, 0, newArray, 0, array.length);
            return newArray;
        }

        protected class GraphEdge implements Edge {
            protected int id;

            protected GraphEdge(int id) {
                this.id = id;
            }

        }

    }

    static class BidirectionalGraph extends Graph {
        public int[] transposedEdge;

        public BidirectionalGraph(int vertexCount) {
            this(vertexCount, vertexCount);
        }

        public BidirectionalGraph(int vertexCount, int edgeCapacity) {
            super(vertexCount, 2 * edgeCapacity);
            transposedEdge = new int[2 * edgeCapacity];
        }

        public static BidirectionalGraph createGraph(int vertexCount, int[] from, int[] to) {
            BidirectionalGraph graph = new BidirectionalGraph(vertexCount, from.length);
            for (int i = 0; i &lt; from.length; i++) {
                graph.addSimpleEdge(from[i], to[i]);
            }
            return graph;
        }


        public int addEdge(int fromID, int toID, long weight, long capacity, int reverseEdge) {
            int lastEdgeCount = edgeCount;
            super.addEdge(fromID, toID, weight, capacity, reverseEdge);
            super.addEdge(toID, fromID, weight, capacity, reverseEdge == -1 ? -1 : reverseEdge + 1);
            this.transposedEdge[lastEdgeCount] = lastEdgeCount + 1;
            this.transposedEdge[lastEdgeCount + 1] = lastEdgeCount;
            return lastEdgeCount;
        }


        protected int entriesPerEdge() {
            return 2;
        }


        protected void ensureEdgeCapacity(int size) {
            if (size &gt; edgeCapacity()) {
                super.ensureEdgeCapacity(size);
                transposedEdge = resize(transposedEdge, edgeCapacity());
            }
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void close() {
            writer.close();
        }

        public void printLine(long i) {
            writer.println(i);
        }

    }

    static interface Edge {
    }

    static abstract class IntAbstractStream implements IntStream {

        public String toString() {
            StringBuilder builder = new StringBuilder();
            boolean first = true;
            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
                if (first) {
                    first = false;
                } else {
                    builder.append(' ');
                }
                builder.append(it.value());
            }
            return builder.toString();
        }


        public boolean equals(Object o) {
            if (!(o instanceof IntStream)) {
                return false;
            }
            IntStream c = (IntStream) o;
            IntIterator it = intIterator();
            IntIterator jt = c.intIterator();
            while (it.isValid() &amp;&amp; jt.isValid()) {
                if (it.value() != jt.value()) {
                    return false;
                }
                it.advance();
                jt.advance();
            }
            return !it.isValid() &amp;&amp; !jt.isValid();
        }


        public int hashCode() {
            int result = 0;
            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
                result *= 31;
                result += it.value();
            }
            return result;
        }

    }

    static class IntegerUtils {
        public static long gcd(long a, long b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b != 0) {
                long temp = a % b;
                a = b;
                b = temp;
            }
            return a;
        }

    }

    static interface IntIterator {
        public int value() throws NoSuchElementException;

        public boolean advance();

        public boolean isValid();

    }

    static class IOUtils {
        public static void readIntArrays(InputReader in, int[]... arrays) {
            for (int i = 0; i &lt; arrays[0].length; i++) {
                for (int j = 0; j &lt; arrays.length; j++) {
                    arrays[j][i] = in.readInt();
                }
            }
        }

    }

    static interface IntList extends IntReversableCollection {
        public abstract int get(int index);

        public abstract void addAt(int index, int value);

        public abstract void removeAt(int index);

        default public int first() {
            return get(0);
        }

        default public int last() {
            return get(size() - 1);
        }

        default public IntIterator intIterator() {
            return new IntIterator() {
                private int at;
                private boolean removed;

                public int value() {
                    if (removed) {
                        throw new IllegalStateException();
                    }
                    return get(at);
                }

                public boolean advance() {
                    at++;
                    removed = false;
                    return isValid();
                }

                public boolean isValid() {
                    return !removed &amp;&amp; at &lt; size();
                }

                public void remove() {
                    removeAt(at);
                    at--;
                    removed = true;
                }
            };
        }


        default public void add(int value) {
            addAt(size(), value);
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar &gt;= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars &lt;= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c &lt; '0' || c &gt; '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }

    static class IntArrayList extends IntAbstractStream implements IntList {
        private int size;
        private int[] data;

        public IntArrayList() {
            this(3);
        }

        public IntArrayList(int capacity) {
            data = new int[capacity];
        }

        public IntArrayList(IntCollection c) {
            this(c.size());
            addAll(c);
        }

        public IntArrayList(IntStream c) {
            this();
            if (c instanceof IntCollection) {
                ensureCapacity(((IntCollection) c).size());
            }
            addAll(c);
        }

        public IntArrayList(IntArrayList c) {
            size = c.size();
            data = c.data.clone();
        }

        public IntArrayList(int[] arr) {
            size = arr.length;
            data = arr.clone();
        }

        public int size() {
            return size;
        }

        public int get(int at) {
            if (at &gt;= size) {
                throw new IndexOutOfBoundsException("at = " + at + ", size = " + size);
            }
            return data[at];
        }

        private void ensureCapacity(int capacity) {
            if (data.length &gt;= capacity) {
                return;
            }
            capacity = Math.max(2 * data.length, capacity);
            data = Arrays.copyOf(data, capacity);
        }

        public void addAt(int index, int value) {
            ensureCapacity(size + 1);
            if (index &gt; size || index &lt; 0) {
                throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
            }
            if (index != size) {
                System.arraycopy(data, index, data, index + 1, size - index);
            }
            data[index] = value;
            size++;
        }

        public void removeAt(int index) {
            if (index &gt;= size || index &lt; 0) {
                throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
            }
            if (index != size - 1) {
                System.arraycopy(data, index + 1, data, index, size - index - 1);
            }
            size--;
        }

    }

    static interface IntReversableCollection extends IntCollection {
    }

    static interface IntStream extends Iterable&lt;Integer&gt;, Comparable&lt;IntStream&gt; {
        public IntIterator intIterator();

        default public Iterator&lt;Integer&gt; iterator() {
            return new Iterator&lt;Integer&gt;() {
                private IntIterator it = intIterator();

                public boolean hasNext() {
                    return it.isValid();
                }

                public Integer next() {
                    int result = it.value();
                    it.advance();
                    return result;
                }
            };
        }

        default public int compareTo(IntStream c) {
            IntIterator it = intIterator();
            IntIterator jt = c.intIterator();
            while (it.isValid() &amp;&amp; jt.isValid()) {
                int i = it.value();
                int j = jt.value();
                if (i &lt; j) {
                    return -1;
                } else if (i &gt; j) {
                    return 1;
                }
                it.advance();
                jt.advance();
            }
            if (it.isValid()) {
                return 1;
            }
            if (jt.isValid()) {
                return -1;
            }
            return 0;
        }

    }

    static interface IntCollection extends IntStream {
        public int size();

        default public void add(int value) {
            throw new UnsupportedOperationException();
        }

        default public IntCollection addAll(IntStream values) {
            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {
                add(it.value());
            }
            return this;
        }

    }

    static class MiscUtils {
        public static void decreaseByOne(int[]... arrays) {
            for (int[] array : arrays) {
                for (int i = 0; i &lt; array.length; i++) {
                    array[i]--;
                }
            }
        }

    }
}


----------
====================
----------
ALGORITHMS.344
hard
----------
PROBLEM STATEMENT:
We call a sequence of N natural numbers (a1, a2, ..., aN) a P-sequence, if the product of any two adjacent numbers in it is not greater than P. In other words, if a sequence (a1, a2, ..., aN) is a P-sequence, then ai * ai+1 ≤ P ∀ 1 ≤ i &lt; N

You are given N and P. Your task is to find the number of such P-sequences of N integers modulo 109+7.
----------
TOP SOLUTION:
----------
#include &lt;stdio.h&gt;

#define P 1000000007LL

long long b[100000][3],i,j,k,l,m,n,t;
long long a[1010][65000];

int main()
{

scanf("%lld %lld",&amp;n,&amp;t);

k = 1;
l = 0;

while(k&lt;=t)
 {
   b[l][0] = k;
   b[l][1] = t/(t/k);
   b[l][2] = b[l][1] - b[l][0] + 1;
   k = b[l][1] + 1;
   l++;
 }

for(i=0;i&lt;l;i++) a[0][i] = 0;
a[0][0] = 1;

for(i=1;i&lt;=n;i++)
{
 k = 0;
 for(j=0;j&lt;l;j++)
   {
    k = (k+a[i-1][j]*b[j][2])%P;
    a[i][l-1-j] = k;   
   }
}

k = 0;

for(i=0;i&lt;l;i++) k = (k+a[n][i]*b[i][2])%P;

printf("%lld\n",k);

//for(i=0;i&lt;l;i++) printf("%lld: %lld-%lld -&gt; %lld\n",i,b[i][0],b[i][1],t/b[i][0]);

return 0;
}
----------
====================
----------
ALGORITHMS.345
advanced
----------
PROBLEM STATEMENT:
You have two arrays of integers, [expression] number of elements. Consider the following function:

score = 0

int Go(step, energy) {
    if (step == N) {
        score += V[step];
        return (score);
    }
    else {
        int way = random(1, 2);
        if (way == 1) {
            score += V[step];
        }
        else {
            energy = P[step];
        }
        if (energy &gt; 0) {
            Go(step + 1, energy - 1);
        }
        else {
            KillTheWorld();
        }
    }
}


What is the maximum possible value of score that we can get in the end, if we call [expression]?. 
Note that the function should never invoke KillTheWorld function. And [expression] generates a random integer from set  [1, 2]. 
It is guaranteed there will be a solution that wont kill the world.
----------
TOP SOLUTION:
----------
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.InputStream;
import java.util.NoSuchElementException;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.io.IOException;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Egor Kulikov (egor@egork.net)
 */
public class Solution {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		Robot solver = new Robot();
		solver.solve(1, in, out);
		out.close();
	}
}

class Robot {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
		int count = in.readInt();
		int[] value = new int[count];
		int[] energy = new int[count];
		IOUtils.readIntArrays(in, value, energy);
		IntervalTree tree = new LongIntervalTree(count) {
			@Override
			protected long joinValue(long left, long right) {
				return Math.max(left, right);
			}

			@Override
			protected long joinDelta(long was, long delta) {
				return was + delta;
			}

			@Override
			protected long accumulate(long value, long delta, int length) {
				return value + delta;
			}

			@Override
			protected long neutralValue() {
				return Long.MIN_VALUE / 2;
			}

			@Override
			protected long neutralDelta() {
				return 0;
			}
		};
		tree.update(count - 1, count - 1, value[count - 1] - Long.MIN_VALUE / 2);
		for (int i = count - 2; i &gt;= 0; i--) {
			if (energy[i] &gt; 0) {
				tree.update(i, i, tree.query(i + 1, i + energy[i]) - Long.MIN_VALUE / 2);
			}
			tree.update(i + 1, count - 1, value[i]);
		}
		out.printLine(tree.query(0, 0));
    }
}

class InputReader {

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar &gt;= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars &lt;= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c &lt; '0' || c &gt; '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public boolean isSpaceChar(int c) {
		if (filter != null)
			return filter.isSpaceChar(c);
		return isWhitespace(c);
	}

	public static boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	public interface SpaceCharFilter {
		public boolean isSpaceChar(int ch);
	}
}

class OutputWriter {
	private final PrintWriter writer;

	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
	}

	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}

	public void close() {
		writer.close();
	}

	public void printLine(long i) {
		writer.println(i);
	}

}

class IOUtils {

	public static void readIntArrays(InputReader in, int[]... arrays) {
		for (int i = 0; i &lt; arrays[0].length; i++) {
			for (int j = 0; j &lt; arrays.length; j++)
				arrays[j][i] = in.readInt();
		}
	}

}

abstract class IntervalTree {
	protected int size;

	protected IntervalTree(int size) {
		this(size, true);
	}

	public IntervalTree(int size, boolean shouldInit) {
		this.size = size;
		int nodeCount = Math.max(1, Integer.highestOneBit(size) &lt;&lt; 2);
		initData(size, nodeCount);
		if (shouldInit)
			init();
	}

	protected abstract void initData(int size, int nodeCount);
	protected abstract void initAfter(int root, int left, int right, int middle);
	protected abstract void initBefore(int root, int left, int right, int middle);
	protected abstract void initLeaf(int root, int index);
	protected abstract void updatePostProcess(int root, int left, int right, int from, int to, long delta, int middle);
	protected abstract void updatePreProcess(int root, int left, int right, int from, int to, long delta, int middle);
	protected abstract void updateFull(int root, int left, int right, int from, int to, long delta);
	protected abstract long queryPostProcess(int root, int left, int right, int from, int to, int middle, long leftResult, long rightResult);
	protected abstract void queryPreProcess(int root, int left, int right, int from, int to, int middle);
	protected abstract long queryFull(int root, int left, int right, int from, int to);
	protected abstract long emptySegmentResult();

	public void init() {
		if (size == 0)
			return;
		init(0, 0, size - 1);
	}

	private void init(int root, int left, int right) {
		if (left == right) {
			initLeaf(root, left);
		} else {
			int middle = (left + right) &gt;&gt; 1;
			initBefore(root, left, right, middle);
			init(2 * root + 1, left, middle);
			init(2 * root + 2, middle + 1, right);
			initAfter(root, left, right, middle);
		}
	}

	public void update(int from, int to, long delta) {
		update(0, 0, size - 1, from, to, delta);
	}

	protected void update(int root, int left, int right, int from, int to, long delta) {
		if (left &gt; to || right &lt; from)
			return;
		if (left &gt;= from &amp;&amp; right &lt;= to) {
			updateFull(root, left, right, from, to, delta);
			return;
		}
		int middle = (left + right) &gt;&gt; 1;
		updatePreProcess(root, left, right, from, to, delta, middle);
		update(2 * root + 1, left, middle, from, to, delta);
		update(2 * root + 2, middle + 1, right, from, to, delta);
		updatePostProcess(root, left, right, from, to, delta, middle);
	}

	public long query(int from, int to) {
		return query(0, 0, size - 1, from, to);
	}

	protected long query(int root, int left, int right, int from, int to) {
		if (left &gt; to || right &lt; from)
			return emptySegmentResult();
		if (left &gt;= from &amp;&amp; right &lt;= to)
			return queryFull(root, left, right, from, to);
		int middle = (left + right) &gt;&gt; 1;
		queryPreProcess(root, left, right, from, to, middle);
		long leftResult = query(2 * root + 1, left, middle, from, to);
		long rightResult = query(2 * root + 2, middle + 1, right, from, to);
		return queryPostProcess(root, left, right, from, to, middle, leftResult, rightResult);
	}
}

abstract class LongIntervalTree extends IntervalTree {
    protected long[] value;
    protected long[] delta;

    protected LongIntervalTree(int size) {
        this(size, true);
    }

	public LongIntervalTree(int size, boolean shouldInit) {
		super(size, shouldInit);
	}

	protected void initData(int size, int nodeCount) {
		value = new long[nodeCount];
		delta = new long[nodeCount];
	}

	protected abstract long joinValue(long left, long right);
    protected abstract long joinDelta(long was, long delta);
    protected abstract long accumulate(long value, long delta, int length);
    protected abstract long neutralValue();
    protected abstract long neutralDelta();

    protected long initValue(int index) {
        return neutralValue();
    }

	protected void initAfter(int root, int left, int right, int middle) {
		value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);
		delta[root] = neutralDelta();
	}

	protected void initBefore(int root, int left, int right, int middle) {
	}

	protected void initLeaf(int root, int index) {
		value[root] = initValue(index);
		delta[root] = neutralDelta();
	}

	protected void updatePostProcess(int root, int left, int right, int from, int to, long delta, int middle) {
		value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);
	}

	protected void updatePreProcess(int root, int left, int right, int from, int to, long delta, int middle) {
		pushDown(root, left, middle, right);
	}

	protected void pushDown(int root, int left, int middle, int right) {
		value[2 * root + 1] = accumulate(value[2 * root + 1], delta[root], middle - left + 1);
		value[2 * root + 2] = accumulate(value[2 * root + 2], delta[root], right - middle);
		delta[2 * root + 1] = joinDelta(delta[2 * root + 1], delta[root]);
		delta[2 * root + 2] = joinDelta(delta[2 * root + 2], delta[root]);
		delta[root] = neutralDelta();
	}

	protected void updateFull(int root, int left, int right, int from, int to, long delta) {
		value[root] = accumulate(value[root], delta, right - left + 1);
		this.delta[root] = joinDelta(this.delta[root], delta);
	}

	protected long queryPostProcess(int root, int left, int right, int from, int to, int middle, long leftResult, long rightResult) {
		return joinValue(leftResult, rightResult);
	}

	protected void queryPreProcess(int root, int left, int right, int from, int to, int middle) {
		pushDown(root, left, middle, right);
	}

	protected long queryFull(int root, int left, int right, int from, int to) {
		return value[root];
	}

	protected long emptySegmentResult() {
		return neutralValue();
	}
}


----------
====================
----------
ALGORITHMS.346
expert
----------
PROBLEM STATEMENT:
A number is called lucky if the sum of its digits, as well as the sum of the squares of its digits is a prime number. How many numbers between [expression] inclusive, are lucky?

For example, [expression].  Each number is tested below:  

        digit   digit   squares
value   sum     squares sum 
20      2       4,0     4
21      3       4,1     5
22      4       4,4     8
23      5       4,9     13
24      6       4,16    20
25      7       4,25    29


We see that two numbers, [expression] are lucky.

Note: These lucky numbers are not to be confused with Lucky Numbers

Function Description  

Complete the luckyNumbers function in the editor below.  It should return an integer that represents the number of lucky numbers in the given range.  

luckyNumbers has the following parameter(s):  


a: an integer, the lower range bound  
b: an integer, the higher range bound  

----------
TOP SOLUTION:
----------
#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;
#include&lt;sstream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;string.h&gt;
using namespace std ;
#define MAXN 2000
#define INF (int)1e9
bool sieve[MAXN] ;

void generate()
{
 for(int tt = 0;tt &lt; 10;tt++)
 {
  char in[] = "in .txt" ;
  in[2] = tt + '0' ;
  FILE * fout = fopen(in,"w") ;
  int n,p,runs ;
  runs = 10000 ;
  fprintf(fout,"%d\n",runs) ;
  for(int i = 0;i &lt; runs;i++)
  {
   int L = 1000000000 ;
   long long a = 1LL * (rand() % L) * (rand() % L) + 1 ;
   long long b = 1LL * (rand() % L) * (rand() % L) + 1 ;
   if(rand() % 10 == 0) a = rand() % L + 1 ;
   if(a &gt; b) swap(a,b) ;
   fprintf(fout,"%lld %lld\n",a,b) ;
  }
 }
}

int brute(int a,int b)
{
 int ret = 0 ;
 for(int i = a;i &lt;= b;i++)
 {
  int sum1 = 0,sum2 = 0 ;
  for(int temp = i;temp &gt; 0;temp /= 10) { sum1 += temp % 10 ; sum2 += (temp % 10) * (temp % 10) ; }
  if(sieve[sum1] &amp;&amp; sieve[sum2]) ret++ ;
 }
 return ret ;
}

int d,D[20] ;
long long memo[20][200][2000] ;
long long solve(int k,int st,int sum1,int sum2)
{
 if(k == -1) return sieve[sum1] &amp;&amp; sieve[sum2] ? 1 : 0 ;
 if(st == 0 &amp;&amp; memo[k][sum1][sum2] != -1) return memo[k][sum1][sum2] ;
 long long ret = 0 ;
 for(int i = 0;i &lt; 10;i++) if(!st || i &lt;= D[k])
 {
  ret += solve(k - 1,st &amp;&amp; i == D[k] ? 1 : 0,sum1 + i,sum2 + i * i) ;
 }
 if(st == 0) memo[k][sum1][sum2] = ret ;
 return ret ;
}

long long solve(long long n)
{
 d = 0 ;
 while(n &gt; 0)
 {
  D[d++] = n % 10 ;
  n /= 10 ;
 }
 long long ret = 0 ;
 for(int i = d - 1;i &gt;= 0;i--)
  for(int j = 1;j &lt; 10;j++)
   if(i &lt; d - 1 || j &lt;= D[i])
    ret += solve(i - 1,i == d - 1 &amp;&amp; j == D[i],j,j * j) ;
 return ret ;
}


int main()
{
 for(int i = 2;i &lt; MAXN;i++) sieve[i] = true ;
 for(int i = 2;i &lt; MAXN;i++)
  for(int j = i + i;j &lt; MAXN;j += i)
   sieve[j] = false ;

 memset(memo,255,sizeof memo) ;
// generate() ; return 0 ;
 int runs ;
 cin &gt;&gt; runs ;
 while(runs--)
 {
  long long a,b ;
  cin &gt;&gt; a &gt;&gt; b ;
  if(a &lt; 1 || a &gt; b || b &gt; 1000000000000000000LL) { cout &lt;&lt; "bad input\n" ; return 1 ; }
  long long ret = solve(b) ;
  if(a &gt; 1) ret -= solve(a - 1) ;
  cout &lt;&lt; ret &lt;&lt; endl ;
//  cout &lt;&lt; brute(a,b) &lt;&lt; endl ;
 }
 return 0 ;
}

----------
====================
----------
ALGORITHMS.347
advanced
----------
PROBLEM STATEMENT:
You are playing a game of Nim with a friend. The rules are are follows:

1) Initially, there are N piles of stones. Two players play alternately.

2) In each turn, a player can choose one non empty pile and remove any number of stones from it. At least one stone must be removed.

3) The player who picks the last stone from the last non empty pile wins the game.

It is currently your friend's turn. You suddenly realize that if your friend was to play optimally in that position, you would lose the game. So while he is not looking, you decide to cheat and add some (possibly 0) stones to each pile. You want the resultant position to be such that your friend has no guaranteed winning strategy, even if plays optimally. You cannot create a new pile of stones. You can only add stones, and not remove stones from a pile. What is the least number of stones you need to add?
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

#define REP(i,n) for(int (i)=0,_n=(n);(i)&lt;_n;(i)++)
#define FOR(i,a,b) for(int (i)=(a),_n=(b);(i)&lt;=_n;(i)++)
#define FORD(i,a,b) for(int (i)=(a),_n=(b);(i)&gt;=_n;(i)--)

typedef long long LL;

const LL inf = 0x7ffffffffffffffLL;

int main()
{
	int T;
	scanf( "%d", &amp;T );
	while ( T-- ) {
		int n;
		LL  ts[20];
		scanf( "%d", &amp;n );
		REP(i,n) cin &gt;&gt; ts[i];
		LL  ans = inf;


		REP(bit,1&lt;&lt;n) {
			LL s[20];
			REP(i,n) s[i] = ts[i];
			
			LL tans = 0;
			FORD(x,40,0) {
				bool odd = false;
				REP(i,n) if ( s[i] &amp; (1LL &lt;&lt; x) ) odd = !odd;
				if ( !odd ) continue;
				
				if ( __builtin_popcount(bit) &lt;= 1 ) goto done;

				int choose = 0;
				LL  cost   = inf;
				LL  value  = 1LL &lt;&lt; x;
				LL  mask   = value - 1;
				REP(i,n) if ( (bit &amp; (1 &lt;&lt; i)) &amp;&amp; !(s[i] &amp; (1LL &lt;&lt; x)) &amp;&amp; value - (s[i] &amp; mask) &lt; cost ) 
					cost = value - (s[i] &amp; mask), choose = i;

				if ( cost == inf ) {
					do {
						x++;
						value = 1LL &lt;&lt; x;
						mask  = value - 1;
						REP(i,n) if ( (bit &amp; (1 &lt;&lt; i)) &amp;&amp; !(s[i] &amp; (1LL &lt;&lt; x)) &amp;&amp; value - (s[i] &amp; mask) &lt; cost )
							cost = value - (s[i] &amp; mask), choose = i;
						if ( cost == inf ) continue;
						s[choose] = (s[choose] &amp; ~mask) | (1LL &lt;&lt; x);
						tans += cost;
						break;
					} while ( true );
					x++;
				}
				else {
					s[choose] = (s[choose] &amp; ~mask) | (1LL &lt;&lt; x);
					tans += cost;
				}
			}
			ans = min(ans,tans);
			done:;
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.348
hard
----------
PROBLEM STATEMENT:
Mr. Road Runner bought a piece of land in the middle of a desert for a nominal amount. It turns out that the piece of land is now worth millions of dollars as it has an oil reserve under it. Mr. Road Runner contacts the ACME corp to set up the oil wells on his land. Setting up oil wells is a costly affair and the charges of setting up oil wells are as follows. 

The rectangular plot bought by Mr. Road Runner is divided into r * c blocks. Only some blocks are suitable for setting up the oil well and these blocks have been marked. ACME charges nothing for building the first oil well. For every subsequent oil well built, the cost would be the maximum ACME distance between the new oil well and the existing oil wells. 

If (x,y) is the position of the block where a new oil well is setup and (x1, y1) is the position of the block of an existing oil well, the ACME distance is given by 

max(|x-x1|, |y-y1|)


the maximum ACME distance is the maximum among all the ACME distance between existing oil wells and new wells. 

If the distance of any two adjacent blocks (horizontal or vertical) is considered 1 unit, what is the minimum cost (E) in units it takes to set up oil wells across all the marked blocks?
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cassert&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;stdint.h&gt;

#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#include &lt;bitset&gt;
#include &lt;deque&gt;
#include &lt;list&gt;
#include &lt;stack&gt;

using namespace std;

typedef long long ll;

#define mp make_pair
#define pb push_back
#define all(v) (v).begin(), (v).end()
#define forn(i, n) for(int i = 0; i &lt; int(n); ++i)
#define foreach(it, v) for(__typeof((v).begin()) it = (v).begin(); it != (v).end(); ++it)
#define sz(v) int((v).size())

const int max_n = 50, inf = 1e9;

bool is_oil[max_n][max_n];
bool used[max_n][max_n][max_n][max_n];
int d[max_n][max_n][max_n][max_n];

inline int get_penalty(int x0, int y0, int x1, int y1, int x, int y) {
  return max(max(abs(x - x0), abs(x - x1)), max(abs(y - y0), abs(y - y1)));
}

int rec(int x0, int y0, int x1, int y1, int n, int m) {
  assert(x0 &lt;= x1 &amp;&amp; x0 &gt;= 0 &amp;&amp; x1 &lt; n);
  assert(y0 &lt;= y1 &amp;&amp; y0 &gt;= 0 &amp;&amp; y1 &lt; m);

  if(used[x0][y0][x1][y1]) {
    return d[x0][y0][x1][y1];
  }
  
  int result = inf;

  if(x0 == 0 &amp;&amp; y0 == 0 &amp;&amp; x1 == n - 1 &amp;&amp; y1 == m - 1) {
    result = 0;
  } else {
    if(x0 &gt; 0) {
      int add = 0;
      for(int y = y0; y &lt;= y1; y++) {
        if(is_oil[x0 - 1][y]) {
          add += get_penalty(x0 - 1, y0, x1, y1, x0 - 1, y);
        }
      }
      result = min(result, add + rec(x0 - 1, y0, x1, y1, n, m));
    }
    if(y0 &gt; 0) {
      int add = 0;
      for(int x = x0; x &lt;= x1; x++) {
        if(is_oil[x][y0 - 1]) {
          add += get_penalty(x0, y0 - 1, x1, y1, x, y0 - 1);
        }
      }
      result = min(result, add + rec(x0, y0 - 1, x1, y1, n, m));
    }
    if(x1 + 1 &lt; n) {
      int add = 0;
      for(int y = y0; y &lt;= y1; y++) {
        if(is_oil[x1 + 1][y]) {
          add += get_penalty(x0, y0, x1 + 1, y1, x1 + 1, y);
        }
      }
      result = min(result, add + rec(x0, y0, x1 + 1, y1, n, m));
    }
    if(y1 + 1 &lt; m) {
      int add = 0;
      for(int x = x0; x &lt;= x1; x++) {
        if(is_oil[x][y1 + 1]) {
          add += get_penalty(x0, y0, x1, y1 + 1, x, y1 + 1);
        }
      }
      result = min(result, add + rec(x0, y0, x1, y1 + 1, n, m));
    }
  }

  used[x0][y0][x1][y1] = true;
  return d[x0][y0][x1][y1] = result;
}

int main() {
  int n, m;
  scanf("%d%d", &amp;n, &amp;m);
  bool empty = true;
  forn(i, n) {
    forn(j, m) {
      int k;
      scanf("%d", &amp;k);
      is_oil[i][j] = (k == 1);
      if(is_oil[i][j]) {
        empty = false;
      }
    }
  }
  int result = (empty) ? 0 : inf;
  forn(i, n) {
    forn(j, m) {
      if(is_oil[i][j]) {
        result = min(result, rec(i, j, i, j, n, m));
      }
    }
  }
  printf("%d\n", result);
  return 0;
}

----------
====================
----------
ALGORITHMS.349
advanced
----------
PROBLEM STATEMENT:
A company needs random numbers for its operation. [expression] numbers as seeds and the following recurrence formula:

[expression]

The numbers used as seeds are [expression] term of the recurrence.

Due to a failure on the servers, the company lost its seed numbers. Now they just have the recurrence formula and the previously generated [expression] random numbers.

The company wants to recover the numbers used as seeds, so they have hired you for doing this task.
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class Solution {
  private static InputReader in;
  private static PrintWriter out;
  public static long mod = 1000000007;
  
  public static long inv(long N, long M) {
    long x = 0, lastx = 1, y = 1, lasty = 0, q, t, a = N, b = M;
    while (b != 0) {
      q = a / b; t = a % b; a = b; b = t; 
      t = x; x = lastx - q * x; lastx = t; 
      t = y; y = lasty - q * y; lasty = t;
    }
    return (lastx + M) % M;
  }

  public static void main(String[] args) throws IOException {
    in = new InputReader(System.in);
    out = new PrintWriter(System.out, true);
    
    int N = in.nextInt(), K = in.nextInt();
    long[][] mat = new long[N][N];
    long[] vec = new long[N];
    long[] coef = new long[N];
    for (int i = 0; i &lt; N; i++) vec[i] = in.nextInt();
    for (int i = 0; i &lt; N; i++) coef[i] = in.nextInt();
    for (int i = 0; i &lt; N-1; i++) mat[i][i+1] = 1;
    
    long iv = inv(coef[N-1], mod);
    mat[N-1][0] = iv;
    for (int i = 1; i &lt; N; i++)
      mat[N-1][i] = (mod - coef[i-1]) * iv % mod;
    
    mat = mat_exp(mat, K - N + 1);
    for (int i = 0; i &lt; N; i++) {
      long s = 0;
      for (int j = 0; j &lt; N; j++) {
        s = (s + mat[i][j] * vec[j]) % mod;
      }
      if (i &gt; 0) out.print(" ");
      out.print(s);
    }
    out.println();
    out.close();
    System.exit(0);
  }
  
  private static long[][] mat_exp(long[][] A, int e) {
    if (e == 0) {
      long[][] ret = new long[A.length][A.length];
      for (int i = 0; i &lt; A.length; i++) ret[i][i] = 1;
      return ret;
    }
    if (e == 1)
      return A;
    else if (e % 2 == 0) {
      long[][] A1 = mat_exp(A, e / 2);
      return matrix_mult(A1, A1);
    } else
      return matrix_mult(A, mat_exp(A, e - 1));
  }

  private static long[][] matrix_mult(long[][] A, long[][] B) {
    long[][] C = new long[A.length][A.length];
    for (int i = 0; i &lt; A.length; i++)
      for (int j = 0; j &lt; A.length; j++)
        for (int k = 0; k &lt; A.length; k++)
          C[i][k] = (C[i][k] + A[i][j] * B[j][k]) % mod;
    return C;
  }

  static class InputReader {
    public BufferedReader reader;
    public StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
      reader = new BufferedReader(new InputStreamReader(stream), 32768);
      tokenizer = null;
    }

    public String next() {
      while (tokenizer == null || !tokenizer.hasMoreTokens()) {
        try {
          tokenizer = new StringTokenizer(reader.readLine());
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
      return tokenizer.nextToken();
    }

    public int nextInt() {
      return Integer.parseInt(next());
    }
  }


}

----------
====================
----------
ALGORITHMS.350
advanced
----------
PROBLEM STATEMENT:
A new gangster is trying to take control of the city. He makes a list of his [expression]) and plans to get rid of them.

[expression].

While our new gangster wants to kill all of them, he also wants to pay the least amount of money. All mercenaries charge a different amount to kill different people. So he asks you to help him minimize his expenses.  
----------
TOP SOLUTION:
----------
//Coder: Balajiganapathi
#define TRACE
#define DEBUG

#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;deque&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;numeric&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

using namespace std;

typedef long long ll;
typedef vector&lt;int&gt; vi;
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;string&gt; vs;

// Basic macros
#define st          first
#define se          second
#define all(x)      (x).begin(), (x).end()
#define ini(a, v)   memset(a, v, sizeof(a))
#define re(i,s,n)  	for(int i=s;i&lt;(n);++i)
#define rep(i,s,n)  for(int i=s;i&lt;=(n);++i)
#define fr(i,n)     re(i,0,n)
#define repv(i,f,t) for(int i = f; i &gt;= t; --i)
#define rev(i,f,t)  repv(i,f - 1,t)
#define frv(i,n)    rev(i,n,0)
#define pu          push_back
#define mp          make_pair
#define sz(x)       (int)(x.size())

const int oo = 1000000009;
const double eps = 1e-9;

#ifdef TRACE
    #define trace1(x)                cerr &lt;&lt; #x &lt;&lt; ": " &lt;&lt; x &lt;&lt; endl;
    #define trace2(x, y)             cerr &lt;&lt; #x &lt;&lt; ": " &lt;&lt; x &lt;&lt; " | " &lt;&lt; #y &lt;&lt; ": " &lt;&lt; y &lt;&lt; endl;
    #define trace3(x, y, z)          cerr &lt;&lt; #x &lt;&lt; ": " &lt;&lt; x &lt;&lt; " | " &lt;&lt; #y &lt;&lt; ": " &lt;&lt; y &lt;&lt; " | " &lt;&lt; #z &lt;&lt; ": " &lt;&lt; z &lt;&lt; endl;
    #define trace4(a, b, c, d)       cerr &lt;&lt; #a &lt;&lt; ": " &lt;&lt; a &lt;&lt; " | " &lt;&lt; #b &lt;&lt; ": " &lt;&lt; b &lt;&lt; " | " &lt;&lt; #c &lt;&lt; ": " &lt;&lt; c &lt;&lt; " | " &lt;&lt; #d &lt;&lt; ": " &lt;&lt; d &lt;&lt; endl;
    #define trace5(a, b, c, d, e)    cerr &lt;&lt; #a &lt;&lt; ": " &lt;&lt; a &lt;&lt; " | " &lt;&lt; #b &lt;&lt; ": " &lt;&lt; b &lt;&lt; " | " &lt;&lt; #c &lt;&lt; ": " &lt;&lt; c &lt;&lt; " | " &lt;&lt; #d &lt;&lt; ": " &lt;&lt; d &lt;&lt; " | " &lt;&lt; #e &lt;&lt; ": " &lt;&lt; e &lt;&lt; endl;
    #define trace6(a, b, c, d, e, f) cerr &lt;&lt; #a &lt;&lt; ": " &lt;&lt; a &lt;&lt; " | " &lt;&lt; #b &lt;&lt; ": " &lt;&lt; b &lt;&lt; " | " &lt;&lt; #c &lt;&lt; ": " &lt;&lt; c &lt;&lt; " | " &lt;&lt; #d &lt;&lt; ": " &lt;&lt; d &lt;&lt; " | " &lt;&lt; #e &lt;&lt; ": " &lt;&lt; e &lt;&lt; " | " &lt;&lt; #f &lt;&lt; ": " &lt;&lt; f &lt;&lt; endl;

#else

    #define trace1(x)
    #define trace2(x, y)
    #define trace3(x, y, z)
    #define trace4(a, b, c, d)
    #define trace5(a, b, c, d, e)
    #define trace6(a, b, c, d, e, f)

#endif

int n, k;
const int mx = 25;
int a[mx], b[mx], c[mx][mx];
int dp[mx][(1 &lt;&lt; 10) + 10];

int solve(int i, int mask) {
    if(i == n) return 0;
    if(mask == (1 &lt;&lt; k) - 1) return oo;
    int &amp;ret = dp[i][mask];
    if(ret != -1) return ret;
    ret = oo;

    fr(nxt, k) if((mask &amp; (1 &lt;&lt; nxt)) == 0) {
        int cur = 0;
        re(j, i, n) {
            cur += c[nxt][j];
            ret = min(ret, cur + solve(j + 1, mask | (1 &lt;&lt; nxt)));
        }
    }

    return ret;
}

int main() {
    scanf("%d %d", &amp;n, &amp;k);
    fr(i, k) {
        fr(j, n) scanf("%d", &amp;c[i][j]);
    }


    ini(dp, -1);
    printf("%d\n", solve(0, 0));
    
	return 0;
}

----------
====================
----------
ALGORITHMS.351
advanced
----------
PROBLEM STATEMENT:
A tree, [expression]. 

Given [expression]'s maximal total weight on a new line.

Note: If [expression] nodes.
----------
TOP SOLUTION:
----------
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
using namespace std;
const int NMAX = 100004;
const long long INF = 1LL&lt;&lt;60;
vector &lt;int&gt; Tree[NMAX], Level[NMAX];
long long dp[NMAX][201], sum[NMAX];
int n, Father[NMAX], v[NMAX], val[NMAX], First[NMAX], Last[NMAX], ind;
inline void DFS(const int node,const int father){
    First[node] = ++ind;
    v[ind] = node;
    for(vector &lt; int &gt;::iterator it = Tree[node].begin();it != Tree[node].end();++it)
        if(*it != father)
            DFS(*it,node);
    Last[node] = ind;
}

int main(){
    int n, k;
    cin.sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; k;
    for(int i = 1;i &lt;= n; ++i)
        cin &gt;&gt; val[i];    
    for(int i=1;i&lt;n;++i){
        int x,y;
        cin &gt;&gt; x &gt;&gt; y;
        Tree[x].push_back(y);
        Tree[y].push_back(x);
    }
    DFS(1,0);
    for(int i = 1;i &lt;= n; ++i){
        for(int j=0;j&lt;=k;++j)
            dp[i][j] = -INF;
    }
    dp[1][0] = 0;
    for(int i = 1;i &lt;= n; ++i)
    {
        int node = v[i];
        for(int j = 0;j &lt;= k; ++j)
            if(dp[i][j]!=-INF)
            {
                dp[i + 1][j] =max(dp[i+1][j],dp[i][j]+val[node]);
                if(j+1&lt;=k)
                    dp[Last[node]+1][j+1] =  max(dp[i][j],dp[Last[node]+1][j+1]);
            }
    }
    long long sol = 0;
    for(int j = 0;j &lt;= k;++j)
        sol = max(sol,dp[n+1][j]);
    cout&lt;&lt;sol&lt;&lt;"\n";
    return 0;
}
----------
====================
----------
ALGORITHMS.352
hard
----------
PROBLEM STATEMENT:
You are using at most A number of 1s and at most B number of 2s. How many different evaluation results are possible when they are formed in an expression containing only addition + sign and multiplication * sign are allowed?

Note that, multiplication takes precedence over addition.

For example, if A=2 and B=2, then we have the following expressions:


1, 1*1 = 1
2, 1*2, 1*1*2, 1+1 = 2
1+2, 1+1*2 = 3
2+2, 2*2, 1+1+2, 1*2*2, 1*1*2*2, 1*2+1*2, 1*1*2+2, 1*2+2 = 4
1+2+2, 1+1*2+2 = 5
1+1+2+2,  1+1+2*2 = 6


So there are 6 unique results that can be formed if A = 2 and B = 2. 
----------
TOP SOLUTION:
----------
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;string.h&gt;
using namespace std;
const int MOD = 1e9 + 7;
int dp_sum[1001][1001],dp_bit[1001][1001];
void add(int &amp;x,long long v){
    v%=MOD;
    x+=v;
    if(x&gt;=MOD)x-=MOD;
}
int f_bit(int lv,int B);
int f_sum(int lv,int B){
    if(lv&gt;B)return 1;
    if(dp_sum[lv][B]!=-1)return dp_sum[lv][B];
    int tmp=f_sum(lv+1,B);
    add(tmp,f_bit(lv,B));
    return dp_sum[lv][B]=tmp;

}
int f_bit(int lv,int B){
    if(lv&gt;B)return 0;
    if(dp_bit[lv][B]!=-1)return dp_bit[lv][B];
    return dp_bit[lv][B]=f_sum(lv+1,B-lv);
}
int main(){
    int T,A,B;
    scanf("%d",&amp;T);
    memset(dp_sum,-1,sizeof(dp_sum));
    memset(dp_bit,-1,sizeof(dp_bit));
    while(T--){
        scanf("%d%d",&amp;A,&amp;B);
        int an=0;
        if(A==0)an=f_sum(1,B);
        else{
            int k=1;
            while((1LL&lt;&lt;k)&lt;=A)k++;
            k++;
            add(an,(long long)(A+1)*f_sum(k,B));
            long long ha=(1LL&lt;&lt;k)-A-1;
            int now=0,i=1;
            long long last=0;
            while(ha&gt;0){
                now++;
                if(B&lt;now)break;
                add(an,min((1LL&lt;&lt;i)-last,ha)*f_sum(k,B-now));
                ha-=(1LL&lt;&lt;i)-last;
                last=1LL&lt;&lt;i;
                i++;
                if(i==k){
                    last=0;
                    i=1;
                }
            }
            /*
            long long last=A;
            for(int i=1;i&lt;=B;i++){
                if(last+1&gt;=(1LL&lt;&lt;k))break;
                add(an,(min(((long long)A+(1LL&lt;&lt;i)),(1LL&lt;&lt;k)-1)-last)*f_sum(k,B-i));
                last=min((long long)A+(1LL&lt;&lt;i),(1LL&lt;&lt;k)-1);
            }*/
        }
        printf("%d\n",(an+MOD-1)%MOD);
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.353
expert
----------
PROBLEM STATEMENT:
In a tournament, [expression] players play against each other exactly once. Each game results in exactly one player winning. There are no ties. You have been given a scorecard containing the scores of each player at the end of the tournament. The score of a player is the total number of games the player won in the tournament. However, the scores of some players might have been erased from the scorecard. How many possible scorecards are consistent with the input scorecard?
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std ;
#define MAXN 42
#define MOD 1000000007

int n ;
vector&lt;int&gt; G ;

int check(vector&lt;int&gt; gg)
{
 sort(gg.begin(),gg.end()) ;
 int sum = 0 ;
 for(int i = 0;i &lt; n;i++)
 {
  sum += gg[i] ;
  if(sum &lt; i * (i + 1) / 2) return 0 ;
 }
 return 1 ;
}

int solve1(int k,int sum)
{
 if(sum &gt; n * (n - 1) / 2) return 0 ;
 if(k == n) return sum == n * (n - 1) / 2 &amp;&amp; check(G) ? 1 : 0 ;
 if(G[k] != -1) return solve1(k + 1,sum + G[k]) ;
 
 int ret = 0 ;
 for(int i = 0;i &lt; n;i++)
 {
  G[k] = i ;
  ret += solve1(k + 1,sum + i) ;
  G[k] = -1 ;
 }
 return ret ;
}

int solve1(vector&lt;int&gt; g)
{
 G = g ;
 n = G.size() ;
 int ret = solve1(0,0) ;
 return ret ;
}

int fac[MAXN],inv[MAXN] ;
int pow(int a,int b)
{
 if(b == 0) return 1 ;
 int ret = pow(a,b / 2) ;
 ret = 1LL * ret * ret % MOD ;
 if(b &amp; 1) ret = 1LL * ret * a % MOD ;
 return ret ;
}

int occ[MAXN],big[MAXN] ;
int memo[MAXN][MAXN][MAXN * MAXN] ;
int solve2(int k,int last,int sum)
{
 if(last == n) return 0 ;
 if(sum &gt; n * (n - 1) / 2) return 0 ;
 if(k == n) return big[last + 1] == 0 &amp;&amp; sum == n * (n - 1) / 2 ? 1 : 0 ;
 if(memo[k][last + 1][sum] != -1) return memo[k][last + 1][sum] ;
 int occr = occ[last + 1] ;
 int ret = 0,added = 0 ;
 for(int i = 0;k + i &lt;= n;i++)
 {
  if(sum + added &lt; (k + i) * (k + i - 1) / 2) break ;
  if(i &gt;= occr) ret += 1LL * inv[i - occr] * solve2(k + i,last + 1,sum + added) % MOD ;
  if(ret &gt;= MOD) ret -= MOD ;
  added += last + 1 ;
 }
 return memo[k][last + 1][sum] = ret ;
}

int solve2(vector&lt;int&gt; g)
{
 fac[0] = inv[0] = 1 ;
 for(int i = 1;i &lt; MAXN;i++)
 {
  fac[i] = 1LL * i * fac[i - 1] % MOD ;
  inv[i] = pow(fac[i],MOD - 2) ;
 }
 n = g.size() ;

 int start = 0 ;
 memset(occ,0,sizeof occ) ;
 memset(big,0,sizeof big) ;
 for(int i = 0;i &lt; g.size();i++) if(g[i] != -1) occ[g[i]]++,start++ ;
 for(int i = 0;i &lt; n;i++)
  for(int j = i;j &lt; n;j++)
   big[i] += occ[j] ;
 memset(memo,255,sizeof memo) ;
 int ret = solve2(0,-1,0) ; 
 ret = 1LL * ret * fac[n - start] % MOD ;
 return ret ;
}


vector&lt;int&gt; gen()
{
 int n = rand() % 10 + 1 ;
 vector&lt;int&gt; ret ;
 for(int i = 0;i &lt; n;i++)
 {
  if(rand() % 2 == 0) ret.push_back(-1) ;
  else ret.push_back(rand() % n) ;
 }
 return ret ;
}

void test()
{
 for(int t = 1;t &lt; 100;t++)
 {
  vector&lt;int&gt; g = gen() ;
  int ret1 = solve1(g) ;
  int ret2 = solve2(g) ;

  cout &lt;&lt; ret1 &lt;&lt; " " &lt;&lt; ret2 &lt;&lt; endl ;
  if(ret1 != ret2)
  {
   cout &lt;&lt; "failed on: " &lt;&lt; t &lt;&lt; endl ;
   cout &lt;&lt; g.size() &lt;&lt; " : " ;
   for(int i = 0;i &lt; g.size();i++) cout &lt;&lt; g[i] &lt;&lt; " " ; cout &lt;&lt; endl ;
   while(1) ;
  }
 }
}

void generate()
{
 char in[] = "in .txt" ;
 for(int test = 0;test &lt; 10;test++)
 {
  in[2] = test + '0' ;
  FILE * fout = fopen(in,"w") ;
  int runs = 20 ;
  fprintf(fout,"%d\n",runs) ;
  for(int t = 0;t &lt; runs;t++)
  {
   if(rand() % 3 != 0) n = rand() % 40 + 1 ;
   else n = 40 - rand() % 10 ;
   int per = 70 ;
   
   vector&lt;int&gt; g ;
   for(int i = 0;i &lt; n;i++)
   {
    if(rand() % 100 &lt; per) g.push_back(-1) ;
    else g.push_back(rand() % n) ;
   }

   fprintf(fout,"%d\n",n) ;
   for(int i = 0;i &lt; n;i++)
   {
    if(i) fprintf(fout," ") ;
    fprintf(fout,"%d",g[i]) ;
   }
   fprintf(fout,"\n") ;
  }
 }
}

int main()
{
// srand(time(NULL)) ; 
// generate() ; return 0 ;
// test() ; return 0 ;
 
 int runs ;
 cin &gt;&gt; runs ;
 while(runs--)
 {
  int n ;
  vector&lt;int&gt; g ;
  cin &gt;&gt; n ;
  for(int i = 0;i &lt; n;i++)
  {
   int k ;
   cin &gt;&gt; k ;
   g.push_back(k) ;
  }
  int ret = solve2(g) ;
  printf("%d\n",ret) ;
 } 
 return 0 ;
}
----------
====================
----------
ALGORITHMS.354
advanced
----------
PROBLEM STATEMENT:
A war has broken down between Vim and Emacs. Gedit, being Vim's ally, is captured by Emacs as a prisoner of war and it is up to Vim to rescue him by defeating Emacs.

For this task, Vim has to assemble an army of appropriate skills. He can choose a non-empty subset of soldiers from a set of [expression]. 

Note : The chosen army's skill-set must exactly match the skill-set requirement of Vim (i.e no extra skills must be present in the army's skill-set than what is required).
----------
TOP SOLUTION:
----------
/*
*/
 
//#pragma comment(linker, "/STACK:16777216")
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;ctime&gt;
#include &lt;memory.h&gt;
#include &lt;ctime&gt; 

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 512

using namespace std;

int pw[1&lt;&lt;20];

int cbits(int x)
{
	return x==0?0:cbits(x/2)+x%2;
}

int n,m,ans[1&lt;&lt;20];
string st;
int sub[1&lt;&lt;20];
int cnt[1&lt;&lt;20];
int nmask;

int main(){
//freopen("enigmatic.in","r",stdin);
//freopen("enigmatic.out","w",stdout);
//freopen("F:/in.txt","r",stdin);
//freopen("F:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);
//cin.tie(0)

pw[0]=1;
for (int i=1;i&lt;(1&lt;&lt;20);i++)
	pw[i]=pw[i-1]*2%bs;

cin&gt;&gt;m&gt;&gt;n;
for (int i=0;i&lt;m;i++)
{
	cin&gt;&gt;st;
	int mask=0;
	for (int j=0;j&lt;n;j++)
		mask=mask*2+st[j]-48;
	cnt[mask]++;
}

string st;
cin&gt;&gt;st;
for (int i=0;i&lt;n;i++)
	nmask=nmask*2+st[i]-48;
	
for (int i=0;i&lt;(1&lt;&lt;n);i++)
	sub[i]=cnt[i];
	
for (int ps=0;ps&lt;n;ps++)
	for (int mask=0;mask&lt;(1&lt;&lt;n);mask++)
		if (mask&amp;(1&lt;&lt;ps))
			sub[mask]+=sub[mask-(1&lt;&lt;ps)];

ans[nmask]=pw[sub[nmask]];

for (int mask=nmask-1;mask&gt;=0;--mask)
{
	int tmask=(mask|nmask);
	if (tmask!=nmask)continue;
	int dif=cbits(mask^nmask);
	
	if (dif%2==1)
		ans[nmask]-=pw[sub[mask]]%bs;
	else
		ans[nmask]+=pw[sub[mask]]%bs;
	
	ans[nmask]%=bs;
}

if (nmask==0)
	ans[nmask]-=1;

cout&lt;&lt;(ans[nmask]%bs+bs)%bs&lt;&lt;endl;

//cin.get();cin.get();
return 0;}

----------
====================
----------
ALGORITHMS.355
advanced
----------
PROBLEM STATEMENT:
In Chile, land are partitioned into a one large grid, where each element represents a land of size 1x1. 

Shaka is a newcomer in Chile and is trying to start his own business. He is planning to build a store. He has his own ideas for the "perfect store" which can be represented by a HxW grid. Element at position (i, j) represents height of land at index (i, j) in the grid. 

Shaka has purchased a land area which can be represented RxC grid (H &lt;= R, W &lt;= C). Shaka is interested in finding best HxW sub-grid in the acquired land. In order to compare the possible sub-grids, Shaka will be using the sum of squared difference between each cell of his "perfect store" and  it's corresponding cell in the subgrid. Amongst all possible sub-grids, he will choose the one with smallest such sum.

Note


The grids are 1-indexed and rows increase from top to bottom and columns increase from left to right. 
If x is the height of a cell in the "perfect store" and y is the height of the corresponding cell in a sub-grid of the acquired land, then the squared difference is defined as (x-y)2 

----------
TOP SOLUTION:
----------
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.math.BigInteger;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.io.IOException;
import java.util.Arrays;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.util.Comparator;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Egor Kulikov (egor@egork.net)
 */
public class Solution {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		BestSpot solver = new BestSpot();
		solver.solve(1, in, out);
		out.close();
	}
}

class BestSpot {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
		int height = in.readInt();
		int width = in.readInt();
		int[][] grid = IOUtils.readIntTable(in, height, width);
		int rowCount = in.readInt();
		int columnCount = in.readInt();
		int[][] sample = IOUtils.readIntTable(in, rowCount, columnCount);
		long[] first = new long[height * width];
		for (int i = 0; i &lt; height; i++) {
			for (int j = 0; j &lt; width; j++) {
				first[i * width + j] = grid[i][j];
				grid[i][j] *= grid[i][j];
			}
		}
		long[] second = new long[rowCount * width];
		long sampleSquared = 0;
		for (int i = 0; i &lt; rowCount; i++) {
			for (int j = 0; j &lt; columnCount; j++) {
				second[second.length - 1 - i * width - j] = sample[i][j];
				sampleSquared += sample[i][j] * sample[i][j];
			}
		}
		long[] result = FastFourierTransform.multiply(first, second);
		long[][] gridSquared = ArrayUtils.partialSums(grid);
		long best = Long.MAX_VALUE;
		int row = -1;
		int column = -1;
		for (int i = 0; i &lt;= height - rowCount; i++) {
			for (int j = 0; j &lt;= width - columnCount; j++) {
				long candidate = gridSquared[i][j] + gridSquared[i + rowCount][j + columnCount] -
					gridSquared[i][j + columnCount] - gridSquared[i + rowCount][j] + sampleSquared -
					2 * result[i * width + j + second.length - 1];
				if (candidate &lt; best) {
					best = candidate;
					row = i + 1;
					column = j + 1;
				}
			}
		}
		out.printLine(best);
		out.printLine(row, column);
	}
}

class InputReader {

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar &gt;= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars &lt;= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c &lt; '0' || c &gt; '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public boolean isSpaceChar(int c) {
		if (filter != null)
			return filter.isSpaceChar(c);
		return isWhitespace(c);
	}

	public static boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	public interface SpaceCharFilter {
		public boolean isSpaceChar(int ch);
	}
}

class OutputWriter {
	private final PrintWriter writer;

	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
	}

	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}

	public void print(Object...objects) {
		for (int i = 0; i &lt; objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void printLine(Object...objects) {
		print(objects);
		writer.println();
	}

	public void close() {
		writer.close();
	}

	public void printLine(long i) {
		writer.println(i);
	}

}

class IOUtils {

	public static int[] readIntArray(InputReader in, int size) {
		int[] array = new int[size];
		for (int i = 0; i &lt; size; i++)
			array[i] = in.readInt();
		return array;
	}

	public static int[][] readIntTable(InputReader in, int rowCount, int columnCount) {
		int[][] table = new int[rowCount][];
		for (int i = 0; i &lt; rowCount; i++)
			table[i] = readIntArray(in, columnCount);
		return table;
	}

}

class FastFourierTransform {
	public static void fft(double[] a, double[] b, boolean invert) {
		int count = a.length;
		for (int i = 1, j = 0; i &lt; count; i++) {
			int bit = count &gt;&gt; 1;
			for (; j &gt;= bit; bit &gt;&gt;= 1)
				j -= bit;
			j += bit;
			if (i &lt; j) {
				double temp = a[i];
				a[i] = a[j];
				a[j] = temp;
				temp = b[i];
				b[i] = b[j];
				b[j] = temp;
			}
		}
		for (int len = 2; len &lt;= count; len &lt;&lt;= 1) {
			int halfLen = len &gt;&gt; 1;
			double angle = 2 * Math.PI / len;
			if (invert)
				angle = -angle;
			double wLenA = Math.cos(angle);
			double wLenB = Math.sin(angle);
			for (int i = 0; i &lt; count; i += len) {
				double wA = 1;
				double wB = 0;
				for (int j = 0; j &lt; halfLen; j++) {
					double uA = a[i + j];
					double uB = b[i + j];
					double vA = a[i + j + halfLen] * wA - b[i + j + halfLen] * wB;
					double vB = a[i + j + halfLen] * wB + b[i + j + halfLen] * wA;
					a[i + j] = uA + vA;
					b[i + j] = uB + vB;
					a[i + j + halfLen] = uA - vA;
					b[i + j + halfLen] = uB - vB;
					double nextWA = wA * wLenA - wB * wLenB;
					wB = wA * wLenB + wB * wLenA;
					wA = nextWA;
				}
			}
		}
		if (invert) {
			for (int i = 0; i &lt; count; i++) {
				a[i] /= count;
				b[i] /= count;
			}
		}
	}

	public static long[] multiply(long[] a, long[] b) {
		int resultSize = Integer.highestOneBit(Math.max(a.length, b.length) - 1) &lt;&lt; 2;
		resultSize = Math.max(resultSize, 1);
		double[] aReal = new double[resultSize];
		double[] aImaginary = new double[resultSize];
		double[] bReal = new double[resultSize];
		double[] bImaginary = new double[resultSize];
		for (int i = 0; i &lt; a.length; i++)
			aReal[i] = a[i];
		for (int i = 0; i &lt; b.length; i++)
			bReal[i] = b[i];
		fft(aReal, aImaginary, false);
		if (a == b) {
			System.arraycopy(aReal, 0, bReal, 0, aReal.length);
			System.arraycopy(aImaginary, 0, bImaginary, 0, aImaginary.length);
		} else
			fft(bReal, bImaginary, false);
		for (int i = 0; i &lt; resultSize; i++) {
			double real = aReal[i] * bReal[i] - aImaginary[i] * bImaginary[i];
			aImaginary[i] = aImaginary[i] * bReal[i] + bImaginary[i] * aReal[i];
			aReal[i] = real;
		}
		fft(aReal, aImaginary, true);
		long[] result = new long[resultSize];
		for (int i = 0; i &lt; resultSize; i++)
			result[i] = Math.round(aReal[i]);
		return result;
	}
}

class ArrayUtils {

	public static long[][] partialSums(int[][] array) {
		int height = array.length;
		int width = array[0].length;
		long[][] result = new long[height + 1][width + 1];
		for (int i = 1; i &lt;= height; i++) {
			for (int j = 1; j &lt;= width; j++) {
				result[i][j] = result[i][j - 1] + result[i - 1][j] - result[i - 1][j - 1] + array[i - 1][j - 1];
			}
		}
		return result;
	}

}


----------
====================
----------
ALGORITHMS.356
expert
----------
PROBLEM STATEMENT:
Given an integer, [expression]) and satisfies the following properties:


[expression] must not contain zeroes in its decimal representation. 
The sum of [expression]'s digits. 


Given [expression]'s decimal representation. 
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;

using namespace std;

#define M 30300
#define N 300
#define INF 100000000

int d[M][N], p[M][N], n, len = 1, bon = 10;

void pre(void){
	for (int i = 0; i &lt; n; ++i)
	for (int j = 0; j &lt; N; ++j)
		p[i][j] = d[i][j] = INF;

	for (int i = 1; i &lt;= 9; ++i)
		p[i][i] = i;
}

bool din(void){
	for (int i = 0; i &lt; n; ++i)
	for (int j = 0; j &lt; N &amp;&amp; j &lt;= len * 9; ++j)
	for (int k = 1, to = i + bon; k &lt;= 9 &amp;&amp; j + k&lt;N; ++k, to += bon){
		if (to &gt;= n)
			to -= n;
		d[to][j + k] = min(d[to][j + k], p[i][j] * k);
	}

	for (int j = 0; j &lt; N; ++j)
	if (p[0][j] &lt;= j)
		return 1;

	for (int i = 0; i &lt; n; ++i)
	for (int j = 0; j &lt; N; ++j){
		p[i][j] = d[i][j];
		d[i][j] = INF;
	}

	return 0;
}

int ans[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 3, 3, 5, 3, 2, 3, 3, 0, 2, 4, 3, 4, 6, 4, 3, 3, 3, 0, 2, 5, 4, 3, 5, 5, 3, 4, 4, 0, 2, 3, 3, 5, 18, 3, 3, 3, 3, 0, 2, 4, 4, 4, 5, 3, 4, 5, 4, 0, 2, 5, 3, 6, 7, 6, 3, 3, 3, 0, 2, 4, 4, 5, 6, 4, 4, 4, 5, 0, 2, 5, 4, 7, 5, 4, 4, 5, 12, 0, 4, 4, 5, 3, 7, 3, 3, 5, 5, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 4, 5, 5, 5, 6, 4, 0, 3, 3, 5, 5, 12, 5, 3, 5, 4, 0, 3, 5, 6, 5, 6, 6, 4, 6, 5, 0, 3, 6, 5, 6, 7, 3, 6, 7, 4, 0, 3, 6, 4, 4, 21, 5, 5, 5, 4, 0, 3, 5, 4, 6, 6, 4, 5, 5, 4, 0, 3, 5, 4, 7, 30, 4, 4, 7, 5, 0, 3, 4, 7, 6, 5, 5, 5, 12, 6, 0, 4, 4, 4, 8, 5, 5, 5, 6, 5, 0, 3, 3, 3, 8, 9, 6, 6, 5, 5, 0, 3, 6, 4, 5, 13, 8, 5, 8, 5, 0, 3, 5, 6, 6, 11, 6, 3, 7, 5, 0, 5, 5, 5, 8, 11, 6, 4, 6, 6, 0, 6, 5, 5, 9, 8, 6, 4, 8, 6, 0, 5, 6, 6, 4, 9, 7, 5, 6, 4, 0, 5, 5, 4, 6, 32, 7, 5, 4, 4, 0, 4, 9, 4, 5, 5, 6, 5, 5, 8, 0, 4, 6, 6, 5, 6, 6, 13, 5, 9, 0, 8, 4, 4, 8, 7, 5, 7, 6, 5, 0, 3, 3, 6, 7, 12, 7, 4, 6, 5, 0, 3, 6, 6, 6, 14, 7, 5, 4, 6, 0, 6, 6, 6, 6, 9, 5, 5, 8, 8, 0, 6, 11, 6, 6, 9, 6, 7, 6, 6, 0, 5, 4, 4, 6, 6, 7, 7, 5, 6, 0, 5, 5, 7, 5, 12, 8, 5, 9, 9, 0, 4, 4, 4, 4, 7, 7, 4, 6, 6, 0, 5, 6, 6, 6, 18, 8, 4, 7, 4, 0, 5, 5, 6, 7, 14, 12, 4, 7, 6, 0, 7, 9, 8, 4, 12, 5, 4, 8, 6, 0, 3, 5, 5, 5, 10, 10, 7, 5, 5, 0, 7, 6, 5, 6, 13, 6, 6, 8, 6, 0, 6, 6, 7, 7, 10, 7, 4, 6, 5, 0, 5, 8, 6, 6, 5, 9, 6, 10, 7, 0, 7, 8, 6, 8, 18, 8, 8, 10, 5, 0, 7, 8, 5, 9, 7, 8, 8, 6, 5, 0, 8, 6, 8, 7, 15, 9, 6, 10, 7, 0, 6, 6, 7, 5, 14, 7, 8, 8, 7, 0, 5, 6, 5, 9, 27, 8, 5, 6, 8, 0, 6, 8, 7, 5, 20, 5, 8, 9, 5, 0, 3, 7, 5, 4, 5, 8, 7, 6, 7, 0, 6, 6, 5, 6, 15, 6, 5, 4, 5, 0, 5, 10, 7, 5, 12, 6, 4, 7, 6, 0, 7, 23, 7, 7, 12, 6, 4, 6, 5, 0, 5, 7, 9, 8, 61, 4, 4, 4, 4, 0, 4, 4, 8, 9, 14, 4, 6, 7, 6, 0, 4, 6, 6, 6, 12, 6, 7, 8, 7, 0, 8, 6, 7, 8, 5, 9, 5, 5, 5, 0, 5, 8, 8, 13, 10, 5, 7, 9, 6, 0, 7, 8, 9, 8, 18, 4, 4, 11, 7, 0, 3, 9, 8, 10, 9, 6, 5, 5, 5, 0, 5, 7, 5, 8, 23, 9, 8, 7, 9, 0, 5, 7, 6, 5, 6, 6, 4, 5, 5, 0, 7, 8, 10, 6, 13, 6, 7, 7, 7, 0, 6, 8, 6, 5, 10, 4, 5, 9, 5, 0, 7, 6, 7, 6, 7, 6, 6, 8, 7, 0, 7, 5, 5, 9, 13, 8, 7, 8, 4, 0, 5, 9, 5, 12, 16, 6, 6, 9, 7, 0, 5, 6, 12, 9, 9, 6, 5, 7, 6, 0, 7, 13, 7, 4, 15, 4, 4, 6, 6, 0, 3, 7, 5, 8, 18, 9, 6, 9, 6, 0, 8, 9, 5, 8, 12, 8, 6, 5, 5, 0, 6, 8, 9, 8, 15, 9, 4, 13, 7, 0, 5, 7, 8, 8, 9, 9, 6, 8, 8, 0, 8, 10, 6, 5, 7, 6, 5, 10, 7, 0, 7, 10, 5, 12, 12, 9, 6, 6, 8, 0, 8, 8, 6, 9, 14, 7, 6, 4, 8, 0, 7, 5, 5, 5, 16, 6, 8, 7, 7, 0, 6, 12, 5, 5, 13, 7, 7, 7, 5, 0, 5, 11, 8, 9, 11, 12, 7, 5, 6, 0, 3, 5, 8, 8, 14, 10, 6, 8, 6, 0, 9, 6, 6, 8, 34, 11, 8, 7, 8, 0, 8, 11, 6, 10, 16, 8, 6, 9, 5, 0, 8, 9, 7, 8, 16, 11, 6, 6, 5, 0, 6, 6, 9, 8, 5, 8, 5, 8, 8, 0, 6, 7, 8, 11, 14, 9, 8, 9, 10, 0, 6, 7, 4, 8, 6, 6, 6, 8, 6, 0, 8, 5, 6, 8, 14, 8, 6, 6, 6, 0, 13, 9, 5, 6, 15, 11, 9, 7, 9, 0, 8, 9, 8, 8, 15, 9, 8, 8, 12, 0, 3, 11, 7, 10, 15, 11, 6, 5, 8, 0, 7, 9, 9, 8, 53, 5, 5, 10, 9, 0, 8, 8, 6, 8, 20, 9, 8, 9, 6, 0, 7, 11, 8, 6, 12, 11, 5, 7, 8, 0, 5, 12, 7, 6, 13, 11, 8, 7, 6, 0, 9, 6, 10, 6, 15, 13, 6, 8, 6, 0, 6, 7, 6, 8, 18, 8, 7, 8, 8, 0, 7, 6, 8, 6, 14, 7, 9, 9, 11, 0, 8, 8, 6, 7, 8, 6, 11, 9, 21, 0, 6, 6, 8, 8, 15, 9, 7, 5, 8, 0, 5, 5, 7, 8, 11, 9, 9, 10, 8, 0, 5, 11, 8, 7, 17, 11, 7, 4, 6, 0, 8, 9, 7, 7, 13, 6, 4, 7, 6, 0, 8, 9, 8, 6, 18, 9, 8, 8, 9, 0, 7, 6, 9, 9, 15, 4, 4, 8, 9, 0, 7, 10, 8, 10, 15, 8, 7, 7, 8, 0, 11, 10, 6, 12, 14, 7, 9, 6, 10, 0, 8, 7, 10, 23, 15, 11, 8, 7, 12, 0, 6, 6, 7, 8, 12, 6, 7, 10, 13, 0, 5, 5, 6, 9, 9, 9, 9, 8, 9, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 13, 10, 7, 9, 8, 0, 4, 4, 8, 6, 14, 7, 6, 6, 7, 0, 4, 4, 7, 6, 9, 6, 8, 7, 8, 0, 4, 6, 5, 8, 21, 8, 11, 12, 8, 0, 4, 10, 9, 7, 14, 8, 7, 10, 5, 0, 4, 9, 5, 13, 15, 5, 8, 7, 8, 0, 4, 12, 8, 8, 15, 8, 7, 13, 10, 0, 4, 5, 6, 8, 13, 9, 6, 12, 8, 0, 5, 9, 8, 10, 15, 9, 9, 8, 8, 0, 4, 4, 4, 4, 21, 11, 7, 11, 10, 0, 4, 14, 7, 9, 18, 9, 6, 10, 8, 0, 4, 6, 11, 9, 5, 5, 5, 5, 5, 0, 4, 5, 5, 7, 13, 5, 7, 10, 5, 0, 12, 9, 7, 8, 10, 7, 5, 9, 5, 0, 8, 8, 9, 7, 21, 13, 8, 5, 5, 0, 5, 6, 8, 6, 13, 10, 9, 9, 5, 0, 7, 11, 6, 8, 14, 12, 12, 10, 7, 0, 6, 6, 8, 10, 38, 13, 6, 12, 8, 0, 11, 7, 9, 8, 20, 11, 7, 7, 7, 0, 4, 4, 7, 13, 7, 9, 7, 11, 6, 0, 4, 10, 6, 6, 15, 13, 8, 9, 6, 0, 6, 6, 8, 7, 15, 8, 8, 9, 9, 0, 6, 8, 7, 11, 14, 5, 9, 9, 5, 0, 9, 9, 8, 7, 52, 10, 5, 12, 6, 0, 9, 12, 9, 10, 50, 10, 7, 12, 7, 0, 8, 6, 6, 13, 32, 11, 10, 12, 5, 0, 9, 5, 9, 7, 14, 12, 6, 9, 5, 0, 8, 9, 8, 5, 13, 7, 10, 8, 9, 0, 8, 9, 8, 13, 16, 8, 10, 11, 6, 0, 4, 4, 11, 5, 12, 6, 8, 7, 9, 0, 4, 9, 5, 7, 18, 8, 9, 9, 10, 0, 11, 9, 8, 13, 15, 12, 7, 12, 5, 0, 6, 11, 6, 9, 12, 6, 7, 10, 11, 0, 8, 8, 6, 12, 15, 6, 5, 10, 5, 0, 8, 6, 7, 8, 14, 11, 9, 8, 6, 0, 7, 10, 6, 11, 15, 13, 6, 13, 5, 0, 7, 9, 7, 7, 27, 9, 11, 8, 8, 0, 5, 12, 9, 6, 14, 8, 8, 8, 11, 0, 9, 8, 6, 10, 14, 9, 8, 5, 11, 0, 4, 7, 5, 5, 21, 11, 9, 9, 6, 0, 11, 8, 5, 10, 12, 9, 8, 12, 7, 0, 8, 9, 8, 6, 7, 13, 7, 9, 9, 0, 8, 8, 8, 8, 18, 6, 7, 9, 8, 0, 9, 7, 8, 6, 16, 4, 9, 12, 8, 0, 8, 7, 10, 9, 6, 11, 10, 5, 5, 0, 6, 6, 6, 12, 21, 7, 6, 8, 5, 0, 9, 11, 10, 13, 14, 12, 9, 5, 5, 0, 10, 7, 5, 7, 18, 12, 7, 9, 9, 0, 10, 5, 5, 11, 14, 11, 10, 9, 8, 0, 4, 12, 8, 7, 15, 5, 7, 8, 6, 0, 8, 10, 11, 5, 14, 32, 5, 8, 10, 0, 6, 13, 7, 6, 17, 8, 10, 6, 5, 0, 8, 11, 7, 6, 11, 9, 5, 8, 8, 0, 7, 11, 8, 11, 14, 7, 9, 10, 10, 0, 7, 8, 6, 13, 61, 7, 8, 10, 8, 0, 7, 8, 5, 10, 9, 9, 8, 10, 5, 0, 5, 14, 12, 9, 19, 8, 8, 8, 8, 0, 9, 11, 7, 10, 15, 6, 7, 8, 6, 0, 7, 12, 6, 8, 18, 9, 9, 8, 11, 0, 4, 14, 5, 12, 14, 8, 8, 10, 12, 0, 8, 14, 8, 11, 15, 11, 7, 13, 7, 0, 8, 9, 5, 8, 9, 10, 7, 12, 7, 0, 9, 6, 8, 12, 15, 13, 10, 9, 7, 0, 13, 9, 10, 11, 21, 8, 6, 13, 8, 0, 7, 8, 9, 5, 12, 7, 6, 8, 10, 0, 9, 8, 5, 12, 16, 8, 8, 9, 8, 0, 8, 13, 6, 9, 12, 9, 9, 6, 9, 0, 7, 14, 8, 9, 17, 7, 6, 9, 8, 0, 7, 8, 9, 9, 16, 11, 7, 12, 10, 0, 4, 9, 6, 9, 21, 8, 10, 12, 9, 0, 6, 6, 9, 11, 29, 10, 9, 10, 8, 0, 8, 11, 9, 8, 17, 11, 8, 10, 8, 0, 8, 14, 10, 11, 21, 11, 7, 8, 10, 0, 10, 5, 5, 5, 16, 12, 5, 9, 9, 0, 7, 9, 6, 8, 14, 13, 10, 8, 5, 0, 9, 10, 5, 12, 23, 9, 8, 11, 9, 0, 12, 10, 10, 11, 6, 8, 9, 11, 5, 0, 10, 11, 5, 10, 12, 7, 8, 12, 9, 0, 8, 5, 7, 13, 15, 11, 11, 6, 8, 0, 4, 11, 9, 14, 13, 7, 9, 6, 10, 0, 5, 13, 10, 6, 34, 10, 10, 10, 10, 0, 11, 13, 6, 10, 13, 11, 8, 15, 10, 0, 9, 13, 7, 7, 13, 7, 8, 8, 12, 0, 9, 12, 6, 11, 17, 8, 9, 12, 8, 0, 9, 7, 7, 6, 10, 13, 8, 6, 9, 0, 11, 12, 6, 9, 14, 9, 11, 11, 10, 0, 7, 10, 10, 12, 14, 6, 11, 7, 11, 0, 8, 6, 8, 12, 7, 9, 13, 22, 10, 0, 6, 6, 11, 14, 12, 13, 10, 8, 7, 0, 5, 9, 7, 7, 14, 5, 10, 13, 5, 0, 11, 12, 8, 9, 13, 11, 10, 8, 10, 0, 7, 9, 9, 11, 30, 10, 4, 8, 8, 0, 8, 12, 11, 11, 15, 9, 7, 7, 8, 0, 6, 13, 10, 7, 23, 4, 8, 6, 7, 0, 6, 8, 9, 9, 14, 11, 7, 7, 11, 0, 7, 12, 11, 14, 17, 7, 9, 6, 13, 0, 7, 9, 8, 9, 21, 8, 8, 6, 8, 0, 9, 9, 11, 14, 11, 8, 6, 13, 8, 0, 5, 8, 7, 6, 13, 13, 9, 9, 7, 0, 4, 4, 4, 4, 20, 8, 8, 9, 9, 0, 4, 12, 8, 10, 13, 13, 7, 10, 8, 0, 4, 9, 9, 7, 11, 7, 6, 13, 11, 0, 4, 13, 10, 13, 22, 12, 10, 13, 9, 0, 6, 7, 9, 13, 14, 6, 8, 10, 7, 0, 8, 9, 8, 8, 15, 13, 8, 23, 5, 0, 8, 11, 5, 8, 15, 7, 6, 12, 9, 0, 6, 8, 11, 8, 13, 8, 8, 8, 7, 0, 8, 13, 11, 12, 18, 12, 9, 14, 11, 0, 8, 10, 9, 10, 21, 10, 6, 13, 7, 0, 4, 9, 8, 13, 15, 9, 11, 12, 9, 0, 8, 12, 5, 12, 5, 7, 9, 12, 9, 0, 8, 9, 9, 11, 9, 9, 8, 13, 8, 0, 10, 12, 5, 8, 10, 9, 8, 8, 7, 0, 9, 10, 11, 7, 23, 11, 8, 12, 9, 0, 10, 14, 7, 8, 7, 12, 7, 6, 6, 0, 11, 11, 9, 13, 90, 6, 12, 14, 7, 0, 7, 8, 9, 5, 8, 13, 6, 6, 6, 0, 9, 13, 10, 8, 12, 7, 10, 13, 8, 0, 11, 10, 12, 6, 11, 8, 8, 8, 11, 0, 4, 8, 8, 13, 14, 12, 6, 8, 6, 0, 6, 9, 8, 10, 21, 11, 9, 7, 6, 0, 6, 8, 8, 14, 19, 11, 8, 9, 9, 0, 10, 14, 13, 9, 16, 5, 12, 13, 5, 0, 9, 5, 8, 11, 16, 10, 8, 13, 8, 0, 8, 13, 11, 12, 21, 11, 10, 19, 9, 0, 9, 10, 11, 9, 15, 13, 11, 13, 5, 0, 11, 9, 9, 11, 13, 10, 8, 11, 10, 0, 7, 9, 7, 12, 14, 13, 9, 12, 6, 0, 8, 13, 7, 9, 56, 11, 10, 10, 9, 0, 4, 9, 7, 11, 15, 10, 11, 13, 6, 0, 7, 6, 5, 8, 26, 15, 6, 6, 8, 0, 7, 14, 8, 11, 16, 11, 11, 11, 17, 0, 10, 8, 10, 14, 15, 11, 12, 13, 8, 0, 9, 9, 8, 8, 7, 10, 9, 11, 8, 0, 10, 7, 9, 10, 14, 13, 8, 9, 9, 0, 9, 8, 10, 13, 45, 13, 7, 11, 11, 0, 11, 10, 10, 11, 21, 8, 10, 7, 10, 0, 9, 7, 11, 9, 15, 11, 7, 10, 11, 0, 9, 14, 10, 9, 18, 15, 11, 8, 11, 0, 10, 8, 6, 13, 17, 9, 8, 13, 13, 0, 11, 13, 8, 8, 92, 9, 9, 12, 11, 0, 8, 13, 9, 10, 16, 7, 7, 11, 10, 0, 8, 9, 11, 6, 19, 8, 5, 6, 9, 0, 7, 10, 6, 9, 12, 9, 9, 11, 9, 0, 7, 8, 10, 11, 21, 11, 7, 8, 8, 0, 6, 12, 8, 12, 8, 10, 8, 7, 10, 0, 7, 11, 9, 6, 22, 13, 6, 10, 9, 0, 9, 13, 10, 12, 16, 12, 7, 9, 8, 0, 9, 13, 8, 10, 22, 9, 10, 9, 10, 0, 9, 11, 11, 7, 18, 7, 10, 11, 11, 0, 7, 9, 10, 14, 15, 8, 7, 13, 10, 0, 6, 12, 7, 8, 18, 11, 11, 9, 5, 0, 12, 12, 8, 10, 10, 6, 10, 6, 10, 0, 7, 13, 11, 8, 21, 11, 5, 8, 7, 0, 9, 10, 11, 6, 10, 13, 11, 10, 9, 0, 7, 9, 13, 17, 14, 9, 6, 12, 5, 0, 9, 6, 9, 8, 15, 11, 6, 11, 10, 0, 11, 9, 11, 9, 20, 9, 10, 12, 8, 0, 9, 10, 9, 15, 14, 9, 8, 7, 12, 0, 6, 10, 9, 8, 15, 12, 7, 10, 11, 0, 8, 13, 12, 14, 16, 10, 13, 10, 8, 0, 6, 10, 8, 10, 15, 13, 7, 12, 8, 0, 10, 11, 6, 7, 20, 12, 9, 13, 7, 0, 8, 11, 7, 11, 14, 13, 10, 13, 11, 0, 12, 9, 11, 5, 16, 13, 7, 12, 13, 0, 7, 13, 8, 10, 189, 9, 10, 5, 5, 0, 5, 12, 5, 17, 7, 10, 9, 5, 8, 0, 9, 7, 8, 12, 14, 8, 9, 13, 6, 0, 7, 9, 5, 11, 22, 10, 12, 13, 8, 0, 8, 8, 10, 13, 15, 18, 6, 9, 12, 0, 8, 13, 7, 9, 15, 13, 9, 5, 8, 0, 8, 6, 12, 8, 12, 7, 9, 12, 8, 0, 8, 7, 10, 9, 22, 11, 8, 7, 6, 0, 13, 8, 5, 10, 11, 13, 13, 13, 7, 0, 13, 11, 10, 10, 23, 13, 11, 13, 12, 0, 12, 12, 8, 7, 12, 14, 6, 5, 9, 0, 11, 10, 9, 12, 16, 6, 13, 9, 10, 0, 7, 6, 13, 14, 15, 10, 8, 13, 8, 0, 6, 13, 12, 13, 10, 6, 6, 12, 11, 0, 7, 12, 9, 10, 23, 12, 7, 10, 10, 0, 7, 8, 10, 6, 30, 12, 11, 8, 9, 0, 8, 11, 10, 11, 19, 11, 8, 11, 8, 0, 11, 12, 11, 11, 11, 6, 7, 11, 8, 0, 8, 13, 12, 6, 21, 13, 11, 14, 10, 0, 10, 13, 7, 9, 12, 11, 13, 7, 10, 0, 10, 9, 9, 11, 20, 8, 8, 11, 7, 0, 8, 14, 10, 13, 18, 13, 10, 6, 10, 0, 11, 10, 9, 9, 17, 8, 21, 15, 12, 0, 11, 10, 6, 8, 17, 6, 7, 10, 11, 0, 9, 9, 11, 10, 21, 5, 8, 14, 8, 0, 7, 13, 11, 13, 32, 12, 8, 5, 8, 0, 9, 11, 6, 9, 10, 9, 4, 9, 10, 0, 8, 13, 7, 10, 21, 9, 10, 10, 11, 0, 11, 9, 5, 12, 20, 13, 8, 7, 11, 0, 7, 11, 10, 9, 17, 11, 9, 6, 12, 0, 6, 13, 5, 7, 27, 9, 13, 13, 8, 0, 8, 13, 8, 8, 21, 10, 6, 13, 8, 0, 9, 6, 9, 12, 18, 9, 7, 8, 8, 0, 8, 13, 11, 11, 21, 10, 10, 6, 8, 0, 4, 4, 7, 11, 16, 12, 6, 9, 9, 0, 4, 9, 11, 7, 139, 11, 11, 9, 11, 0, 8, 11, 9, 14, 21, 13, 10, 16, 10, 0, 10, 6, 10, 8, 33, 12, 9, 12, 8, 0, 8, 7, 8, 11, 18, 8, 8, 9, 9, 0, 6, 11, 11, 14, 15, 11, 8, 13, 9, 0, 8, 13, 5, 11, 6, 11, 12, 10, 10, 0, 8, 12, 11, 7, 24, 10, 10, 7, 11, 0, 9, 12, 10, 7, 21, 9, 6, 9, 10, 0, 9, 10, 9, 7, 12, 11, 12, 11, 12, 0, 4, 11, 11, 12, 12, 11, 9, 13, 6, 0, 8, 12, 11, 13, 23, 12, 10, 7, 11, 0, 10, 8, 8, 12, 23, 13, 10, 9, 11, 0, 8, 8, 9, 12, 23, 12, 7, 10, 13, 0, 13, 32, 12, 14, 15, 8, 8, 13, 12, 0, 11, 12, 7, 13, 9, 15, 13, 6, 8, 0, 6, 8, 8, 10, 23, 6, 9, 5, 7, 0, 10, 8, 9, 11, 12, 7, 12, 6, 11, 0, 11, 9, 13, 13, 17, 8, 13, 9, 11, 0, 13, 9, 6, 11, 17, 13, 7, 11, 8, 0, 9, 13, 8, 9, 9, 10, 12, 14, 11, 0, 11, 12, 8, 8, 20, 11, 11, 17, 8, 0, 9, 15, 9, 11, 11, 10, 7, 11, 11, 0, 9, 14, 8, 8, 18, 16, 9, 10, 9, 0, 6, 9, 10, 9, 27, 10, 11, 13, 8, 0, 9, 12, 8, 14, 14, 13, 6, 9, 14, 0, 9, 8, 10, 8, 13, 12, 10, 12, 8, 0, 7, 16, 7, 11, 16, 12, 8, 10, 10, 0, 12, 6, 9, 10, 18, 8, 9, 15, 8, 0, 9, 7, 9, 12, 18, 10, 8, 15, 10, 0, 11, 9, 9, 13, 18, 8, 11, 12, 11, 0, 6, 15, 8, 15, 23, 5, 10, 12, 12, 0, 10, 8, 11, 11, 9, 10, 8, 13, 7, 0, 8, 12, 10, 14, 22, 9, 13, 11, 10, 0, 7, 11, 8, 13, 10, 13, 5, 11, 5, 0, 6, 8, 7, 9, 27, 14, 12, 8, 12, 0, 11, 14, 10, 13, 19, 12, 8, 9, 5, 0, 11, 16, 10, 6, 15, 13, 7, 20, 9, 0, 11, 13, 12, 12, 15, 9, 11, 8, 11, 0, 12, 16, 10, 17, 19, 13, 12, 12, 10, 0, 11, 11, 13, 8, 33, 13, 10, 13, 5, 0, 10, 14, 8, 8, 15, 9, 8, 5, 9, 0, 8, 7, 10, 7, 32, 11, 9, 10, 14, 0, 13, 10, 13, 8, 18, 13, 10, 12, 9, 0, 10, 8, 9, 12, 21, 9, 11, 13, 11, 0, 11, 12, 9, 13, 19, 6, 10, 11, 8, 0, 12, 9, 12, 9, 36, 6, 11, 9, 6, 0, 7, 14, 10, 15, 23, 12, 11, 9, 8, 0, 6, 7, 8, 14, 15, 9, 8, 8, 10, 0, 10, 13, 11, 8, 19, 9, 12, 9, 8, 0, 9, 11, 12, 7, 15, 12, 8, 13, 10, 0, 9, 14, 8, 9, 12, 17, 11, 9, 6, 0, 9, 14, 10, 12, 14, 13, 7, 12, 10, 0, 10, 6, 7, 8, 21, 13, 6, 11, 10, 0, 9, 10, 12, 11, 23, 10, 10, 12, 9, 0, 9, 11, 13, 14, 18, 14, 7, 8, 12, 0, 8, 11, 12, 13, 21, 10, 7, 9, 5, 0, 6, 12, 8, 14, 20, 12, 8, 11, 10, 0, 11, 11, 7, 13, 15, 13, 10, 12, 12, 0, 7, 13, 9, 5, 5, 5, 5, 5, 9, 0, 5, 12, 12, 5, 14, 9, 5, 12, 7, 0, 11, 8, 6, 13, 14, 14, 5, 11, 11, 0, 8, 13, 8, 11, 13, 8, 5, 5, 9, 0, 9, 11, 7, 10, 14, 11, 5, 12, 6, 0, 9, 9, 13, 14, 24, 11, 11, 12, 9, 0, 9, 12, 7, 10, 16, 14, 9, 11, 12, 0, 5, 8, 11, 9, 16, 11, 5, 5, 8, 0, 10, 10, 10, 11, 24, 10, 12, 10, 11, 0, 8, 13, 9, 23, 21, 12, 9, 13, 8, 0, 9, 12, 12, 5, 15, 8, 5, 20, 10, 0, 8, 13, 9, 12, 12, 6, 9, 11, 11, 0, 7, 11, 12, 19, 13, 13, 7, 14, 8, 0, 13, 7, 9, 13, 6, 6, 5, 10, 6, 0, 6, 13, 10, 13, 16, 16, 9, 12, 6, 0, 8, 11, 9, 14, 20, 10, 9, 16, 6, 0, 13, 15, 8, 13, 15, 6, 9, 10, 7, 0, 10, 14, 11, 12, 14, 15, 12, 12, 13, 0, 10, 13, 10, 13, 109, 12, 11, 13, 5, 0, 8, 7, 8, 12, 17, 12, 13, 13, 7, 0, 13, 15, 13, 14, 23, 13, 13, 11, 11, 0, 8, 8, 9, 17, 21, 13, 11, 13, 11, 0, 8, 14, 9, 7, 19, 10, 7, 6, 8, 0, 8, 13, 12, 9, 13, 21, 5, 14, 8, 0, 11, 13, 9, 12, 7, 15, 14, 9, 8, 0, 13, 11, 6, 11, 14, 11, 9, 11, 9, 0, 9, 15, 11, 14, 15, 10, 7, 12, 6, 0, 11, 6, 8, 13, 15, 7, 11, 13, 6, 0, 11, 12, 10, 13, 14, 12, 6, 12, 12, 0, 9, 9, 9, 13, 14, 22, 7, 11, 8, 0, 10, 14, 9, 6, 20, 14, 8, 14, 11, 0, 12, 13, 9, 10, 18, 8, 9, 7, 9, 0, 13, 11, 11, 9, 12, 8, 11, 14, 11, 0, 11, 13, 11, 10, 14, 13, 5, 5, 11, 0, 12, 11, 6, 12, 21, 13, 5, 9, 9, 0, 15, 11, 12, 10, 14, 9, 8, 10, 13, 0, 12, 7, 10, 17, 52, 12, 8, 11, 10, 0, 9, 10, 13, 14, 18, 8, 10, 15, 11, 0, 7, 16, 9, 12, 16, 12, 11, 11, 12, 0, 9, 13, 12, 8, 61, 7, 10, 14, 7, 0, 10, 16, 9, 13, 18, 12, 7, 11, 11, 0, 4, 4, 12, 11, 21, 6, 9, 7, 6, 0, 4, 13, 6, 10, 34, 11, 9, 12, 8, 0, 12, 12, 12, 15, 22, 7, 5, 11, 12, 0, 7, 17, 9, 13, 17, 16, 11, 14, 12, 0, 11, 7, 6, 9, 18, 6, 10, 13, 13, 0, 6, 13, 7, 9, 17, 14, 9, 9, 12, 0, 10, 13, 8, 11, 23, 13, 9, 13, 10, 0, 11, 14, 5, 9, 19, 13, 9, 15, 9, 0, 10, 15, 6, 12, 21, 13, 9, 11, 11, 0, 10, 12, 11, 8, 13, 14, 9, 15, 12, 0, 4, 13, 9, 13, 21, 9, 9, 8, 10, 0, 10, 12, 5, 13, 23, 9, 11, 8, 8, 0, 9, 11, 14, 15, 25, 9, 11, 11, 13, 0, 7, 13, 10, 13, 12, 8, 9, 10, 8, 0, 8, 13, 12, 13, 30, 15, 12, 11, 12, 0, 7, 12, 13, 9, 16, 13, 10, 7, 5, 0, 9, 18, 9, 6, 21, 13, 10, 12, 8, 0, 9, 14, 10, 13, 18, 10, 11, 17, 12, 0, 9, 12, 11, 12, 18, 13, 8, 15, 13, 0, 10, 13, 11, 11, 21, 12, 8, 14, 6, 0, 10, 6, 12, 16, 8, 10, 11, 14, 11, 0, 6, 12, 9, 13, 19, 12, 7, 8, 6, 0, 13, 13, 9, 13, 12, 26, 7, 13, 9, 0, 11, 14, 9, 13, 25, 11, 12, 13, 13, 0, 7, 7, 11, 13, 17, 13, 9, 10, 11, 0, 8, 15, 10, 8, 21, 13, 10, 13, 9, 0, 5, 8, 9, 12, 23, 8, 5, 10, 11, 0, 8, 9, 10, 13, 13, 14, 10, 12, 12, 0, 10, 12, 11, 10, 15, 14, 9, 13, 7, 0, 9, 9, 12, 15, 20, 13, 11, 10, 10, 0, 12, 10, 11, 14, 14, 13, 12, 13, 6, 0, 12, 13, 11, 9, 30, 8, 13, 13, 12, 0, 9, 13, 8, 16, 15, 12, 5, 15, 9, 0, 11, 15, 11, 12, 6, 13, 8, 19, 11, 0, 8, 9, 8, 12, 27, 12, 12, 9, 10, 0, 13, 11, 9, 12, 17, 14, 10, 11, 14, 0, 9, 9, 5, 8, 17, 14, 9, 15, 9, 0, 12, 13, 7, 12, 21, 6, 11, 8, 12, 0, 9, 9, 6, 8, 22, 8, 11, 10, 14, 0, 11, 13, 9, 12, 18, 12, 10, 13, 6, 0, 7, 14, 6, 8, 15, 12, 11, 13, 8, 0, 9, 12, 6, 14, 19, 16, 13, 8, 13, 0, 11, 12, 11, 10, 15, 7, 8, 14, 11, 0, 10, 14, 7, 11, 28, 12, 11, 13, 10, 0, 9, 6, 9, 12, 15, 14, 10, 11, 13, 0, 13, 9, 13, 8, 21, 13, 8, 5, 5, 0, 11, 14, 9, 8, 23, 12, 7, 13, 5, 0, 12, 13, 7, 13, 15, 10, 10, 8, 10, 0, 10, 13, 8, 14, 23, 13, 10, 8, 11, 0, 10, 13, 11, 10, 7, 16, 13, 13, 10, 0, 7, 8, 10, 10, 15, 8, 9, 11, 12, 0, 10, 10, 13, 12, 53, 13, 8, 13, 11, 0, 10, 12, 9, 6, 19, 8, 13, 6, 10, 0, 7, 12, 7, 9, 16, 12, 8, 10, 7, 0, 8, 11, 13, 14, 17, 15, 12, 10, 8, 0, 12, 6, 10, 11, 18, 11, 12, 14, 7, 0, 9, 11, 9, 16, 34, 9, 12, 9, 5, 0, 7, 13, 9, 14, 14, 14, 13, 11, 11, 0, 10, 9, 11, 12, 15, 13, 7, 11, 12, 0, 14, 12, 10, 5, 18, 8, 5, 12, 11, 0, 8, 10, 6, 17, 21, 13, 13, 14, 8, 0, 15, 15, 8, 13, 29, 16, 8, 12, 10, 0, 11, 12, 13, 13, 12, 40, 5, 12, 13, 0, 9, 13, 9, 10, 17, 11, 12, 9, 10, 0, 8, 13, 12, 14, 18, 13, 10, 12, 13, 0, 9, 14, 8, 9, 18, 15, 8, 15, 9, 0, 8, 10, 10, 12, 20, 11, 14, 17, 12, 0, 11, 7, 13, 13, 21, 13, 7, 12, 11, 0, 7, 14, 10, 9, 16, 12, 9, 6, 12, 0, 12, 13, 10, 13, 15, 7, 11, 9, 7, 0, 7, 11, 11, 14, 19, 11, 16, 13, 9, 0, 12, 12, 7, 9, 33, 14, 8, 11, 8, 0, 6, 14, 13, 16, 17, 13, 6, 6, 9, 0, 7, 7, 9, 6, 15, 13, 8, 8, 9, 0, 12, 15, 12, 14, 16, 6, 6, 9, 7, 0, 10, 12, 9, 14, 23, 12, 11, 11, 12, 0, 9, 11, 9, 15, 18, 11, 7, 36, 12, 0, 11, 12, 14, 8, 21, 14, 11, 14, 9, 0, 10, 11, 6, 15, 28, 13, 11, 12, 9, 0, 11, 13, 8, 9, 21, 12, 10, 8, 10, 0, 10, 14, 8, 22, 8, 13, 13, 12, 8, 0, 12, 12, 8, 7, 33, 13, 12, 10, 7, 0, 12, 13, 14, 8, 15, 9, 9, 9, 12, 0, 13, 12, 10, 8, 14, 13, 9, 13, 10, 0, 12, 13, 11, 7, 15, 11, 9, 11, 9, 0, 12, 13, 7, 10, 15, 11, 7, 11, 10, 0, 9, 8, 9, 10, 20, 11, 10, 15, 9, 0, 8, 12, 7, 7, 16, 13, 10, 9, 10, 0, 10, 13, 12, 12, 78, 10, 13, 17, 11, 0, 8, 12, 10, 14, 18, 14, 11, 12, 12, 0, 14, 15, 11, 13, 17, 8, 13, 12, 11, 0, 10, 14, 14, 8, 23, 12, 12, 13, 13, 0, 12, 9, 8, 17, 21, 13, 5, 14, 9, 0, 11, 11, 14, 13, 17, 14, 10, 8, 13, 0, 6, 12, 11, 15, 21, 12, 13, 11, 10, 0, 8, 12, 8, 13, 16, 18, 11, 12, 9, 0, 7, 11, 10, 11, 12, 11, 10, 13, 14, 0, 11, 12, 10, 9, 21, 14, 11, 6, 9, 0, 7, 8, 8, 14, 21, 6, 6, 12, 12, 0, 13, 15, 8, 13, 15, 12, 10, 9, 10, 0, 4, 9, 10, 12, 22, 12, 12, 15, 12, 0, 10, 13, 13, 8, 17, 12, 11, 11, 14, 0, 9, 11, 8, 9, 17, 14, 8, 8, 5, 0, 8, 12, 12, 12, 17, 13, 11, 13, 12, 0, 8, 10, 10, 13, 19, 9, 12, 12, 10, 0, 10, 14, 12, 11, 15, 14, 9, 12, 8, 0, 11, 14, 9, 11, 21, 10, 9, 17, 9, 0, 8, 14, 9, 13, 20, 11, 9, 12, 9, 0, 9, 12, 10, 10, 21, 9, 8, 12, 12, 0, 10, 11, 12, 13, 9, 10, 11, 10, 9, 0, 13, 9, 8, 18, 10, 9, 7, 13, 8, 0, 11, 9, 13, 11, 32, 14, 14, 7, 10, 0, 11, 14, 11, 14, 15, 12, 11, 13, 12, 0, 13, 17, 13, 9, 17, 12, 14, 14, 14, 0, 8, 8, 13, 12, 22, 13, 8, 13, 10, 0, 8, 12, 14, 15, 21, 7, 6, 8, 8, 0, 6, 11, 10, 13, 23, 9, 12, 5, 12, 0, 11, 13, 12, 12, 10, 8, 11, 10, 9, 0, 6, 6, 8, 10, 12, 6, 11, 10, 7, 0, 6, 13, 5, 13, 17, 13, 13, 8, 10, 0, 9, 11, 9, 18, 15, 8, 13, 15, 8, 0, 9, 15, 12, 10, 24, 12, 8, 13, 11, 0, 12, 13, 9, 14, 31, 10, 11, 18, 12, 0, 6, 12, 8, 14, 14, 13, 12, 17, 12, 0, 12, 9, 9, 11, 12, 12, 8, 13, 13, 0, 9, 13, 11, 6, 36, 13, 12, 8, 7, 0, 11, 14, 7, 10, 14, 17, 13, 14, 14, 0, 13, 13, 9, 9, 21, 13, 8, 9, 8, 0, 6, 12, 11, 13, 12, 14, 8, 8, 8, 0, 12, 16, 12, 10, 26, 14, 12, 19, 13, 0, 7, 9, 8, 8, 18, 7, 11, 12, 11, 0, 11, 14, 10, 16, 23, 13, 10, 8, 12, 0, 7, 12, 11, 12, 13, 13, 9, 11, 6, 0, 11, 16, 13, 13, 27, 13, 13, 14, 10, 0, 12, 10, 8, 13, 12, 11, 11, 8, 11, 0, 13, 14, 6, 10, 21, 14, 11, 10, 13, 0, 12, 14, 10, 7, 29, 12, 9, 13, 8, 0, 9, 11, 12, 11, 20, 20, 12, 13, 13, 0, 13, 12, 8, 14, 19, 13, 11, 15, 9, 0, 10, 8, 11, 11, 17, 7, 10, 11, 11, 0, 13, 13, 8, 10, 20, 15, 13, 15, 11, 0, 11, 12, 11, 9, 17, 14, 8, 5, 13, 0, 9, 13, 10, 14, 21, 16, 11, 16, 9, 0, 7, 10, 11, 13, 27, 14, 13, 10, 10, 0, 7, 9, 11, 12, 129, 5, 5, 5, 5, 0, 5, 5, 13, 12, 16, 5, 9, 18, 10, 0, 5, 10, 12, 9, 25, 5, 9, 17, 12, 0, 14, 9, 7, 7, 15, 9, 9, 12, 7, 0, 11, 8, 9, 14, 22, 13, 11, 13, 11, 0, 13, 11, 10, 9, 14, 5, 5, 11, 10, 0, 5, 10, 11, 15, 23, 14, 9, 12, 13, 0, 10, 15, 10, 8, 29, 14, 13, 13, 9, 0, 8, 18, 11, 13, 11, 9, 9, 13, 12, 0, 10, 12, 13, 14, 18, 14, 14, 11, 11, 0, 9, 13, 11, 11, 18, 5, 12, 8, 14, 0, 13, 13, 13, 11, 30, 12, 8, 13, 7, 0, 9, 7, 11, 13, 16, 13, 13, 16, 5, 0, 9, 14, 10, 13, 18, 14, 11, 9, 7, 0, 12, 11, 10, 14, 24, 7, 9, 60, 13, 0, 10, 13, 8, 12, 17, 5, 11, 10, 8, 0, 15, 14, 7, 15, 20, 13, 11, 14, 13, 0, 12, 13, 10, 13, 20, 10, 9, 10, 8, 0, 11, 13, 6, 16, 41, 13, 11, 13, 13, 0, 9, 14, 13, 15, 18, 12, 9, 7, 11, 0, 11, 14, 8, 6, 23, 5, 13, 9, 10, 0, 13, 15, 11, 10, 25, 16, 12, 12, 11, 0, 13, 6, 11, 16, 34, 12, 12, 10, 10, 0, 10, 13, 11, 11, 14, 14, 12, 14, 8, 0, 6, 10, 13, 13, 18, 13, 12, 11, 8, 0, 13, 12, 13, 15, 21, 14, 11, 14, 12, 0, 9, 6, 10, 21, 19, 12, 10, 17, 12, 0, 7, 7, 9, 12, 28, 13, 8, 13, 10, 0, 11, 13, 11, 18, 15, 13, 7, 10, 9, 0, 12, 12, 12, 8, 24, 12, 13, 6, 6, 0, 7, 12, 11, 11, 18, 14, 13, 12, 6, 0, 9, 11, 8, 11, 23, 17, 6, 11, 6, 0, 15, 17, 5, 13, 15, 12, 10, 14, 7, 0, 14, 16, 9, 12, 21, 13, 13, 20, 9, 0, 10, 6, 12, 14, 29, 11, 13, 14, 10, 0, 11, 12, 10, 14, 15, 15, 9, 18, 14, 0, 13, 13, 13, 14, 30, 14, 12, 13, 15, 0, 7, 14, 13, 13, 21, 11, 10, 9, 9, 0, 12, 16, 9, 13, 16, 16, 11, 11, 12, 0, 10, 13, 7, 9, 10, 10, 9, 11, 13, 0, 9, 14, 7, 12, 21, 11, 11, 14, 10, 0, 11, 27, 9, 15, 17, 15, 13, 13, 12, 0, 9, 13, 8, 14, 20, 6, 14, 17, 11, 0, 10, 14, 13, 19, 26, 9, 12, 9, 11, 0, 13, 8, 13, 22, 29, 15, 18, 19, 8, 0, 10, 11, 6, 14, 16, 8, 8, 8, 12, 0, 9, 14, 12, 19, 12, 14, 9, 16, 8, 0, 13, 14, 13, 9, 17, 11, 11, 13, 10, 0, 16, 14, 14, 13, 16, 14, 5, 13, 12, 0, 9, 7, 10, 13, 22, 12, 11, 29, 8, 0, 12, 12, 12, 13, 16, 5, 5, 12, 6, 0, 5, 10, 12, 14, 14, 12, 13, 9, 12, 0, 14, 9, 14, 15, 21, 9, 10, 13, 13, 0, 11, 17, 11, 13, 19, 7, 11, 10, 7, 0, 11, 9, 7, 12, 23, 14, 11, 13, 13, 0, 9, 11, 8, 9, 61, 5, 11, 12, 13, 0, 4, 13, 7, 8, 17, 7, 15, 15, 10, 0, 8, 13, 8, 11, 18, 13, 8, 12, 11, 0, 9, 11, 10, 9, 15, 6, 9, 13, 16, 0, 7, 6, 11, 27, 20, 15, 12, 7, 12, 0, 13, 13, 12, 13, 29, 13, 8, 14, 10, 0, 9, 16, 7, 13, 29, 8, 13, 8, 13, 0, 8, 13, 6, 6, 23, 16, 10, 12, 6, 0, 10, 12, 11, 6, 22, 13, 10, 12, 9, 0, 7, 13, 12, 7, 24, 9, 8, 11, 10, 0, 13, 8, 10, 13, 23, 16, 11, 11, 7, 0, 13, 14, 10, 16, 31, 12, 9, 14, 12, 0, 8, 15, 9, 16, 19, 16, 11, 11, 6, 0, 9, 12, 8, 6, 21, 9, 13, 13, 8, 0, 10, 10, 15, 9, 18, 13, 9, 7, 10, 0, 13, 11, 9, 13, 21, 13, 8, 14, 14, 0, 8, 8, 11, 11, 18, 13, 8, 14, 6, 0, 8, 13, 9, 16, 11, 17, 10, 10, 11, 0, 14, 14, 12, 6, 17, 10, 12, 8, 9, 0, 6, 13, 13, 13, 15, 12, 10, 16, 12, 0, 8, 13, 13, 7, 26, 8, 10, 11, 12, 0, 12, 13, 9, 14, 13, 9, 14, 14, 8, 0, 12, 14, 10, 11, 32, 17, 7, 14, 10, 0, 15, 11, 10, 12, 17, 13, 11, 10, 11, 0, 7, 15, 10, 16, 21, 9, 12, 11, 13, 0, 8, 14, 11, 12, 17, 10, 11, 13, 11, 0, 11, 11, 13, 14, 22, 13, 12, 10, 13, 0, 13, 10, 13, 16, 13, 7, 8, 13, 9, 0, 7, 12, 12, 14, 10, 15, 13, 7, 5, 0, 10, 11, 11, 17, 26, 9, 10, 10, 9, 0, 12, 9, 11, 10, 18, 12, 10, 7, 11, 0, 12, 11, 11, 16, 23, 14, 11, 13, 12, 0, 11, 12, 8, 11, 25, 13, 9, 16, 10, 0, 9, 16, 13, 10, 28, 13, 11, 12, 9, 0, 11, 10, 10, 13, 25, 11, 10, 18, 11, 0, 14, 12, 11, 13, 13, 7, 10, 16, 9, 0, 11, 13, 10, 19, 14, 9, 12, 13, 12, 0, 13, 14, 12, 13, 53, 9, 13, 13, 12, 0, 14, 8, 8, 8, 32, 14, 8, 12, 13, 0, 10, 12, 10, 13, 15, 10, 11, 13, 11, 0, 8, 15, 11, 32, 16, 16, 12, 14, 11, 0, 9, 19, 13, 14, 20, 14, 11, 14, 11, 0, 13, 11, 8, 15, 21, 11, 10, 13, 11, 0, 11, 15, 13, 13, 19, 6, 10, 17, 10, 0, 12, 6, 6, 8, 20, 14, 12, 10, 11, 0, 9, 13, 9, 18, 15, 5, 15, 11, 13, 0, 10, 12, 13, 8, 21, 9, 8, 13, 12, 0, 12, 11, 11, 15, 15, 13, 10, 13, 13, 0, 10, 17, 6, 9, 18, 14, 12, 13, 7, 0, 11, 8, 10, 17, 6, 9, 13, 15, 12, 0, 12, 16, 9, 9, 25, 14, 10, 11, 13, 0, 11, 17, 10, 7, 29, 11, 12, 11, 14, 0, 13, 12, 11, 13, 15, 19, 10, 9, 10, 0, 16, 10, 13, 18, 15, 16, 11, 16, 10, 0, 14, 13, 10, 12, 15, 8, 11, 12, 9, 0, 12, 11, 8, 14, 25, 18, 12, 14, 10, 0, 9, 18, 15, 15, 20, 19, 12, 11, 9, 0, 11, 19, 9, 17, 26, 15, 9, 13, 11, 0, 9, 13, 14, 14, 21, 8, 9, 20, 7, 0, 9, 18, 13, 9, 17, 10, 14, 9, 9, 0, 12, 11, 10, 18, 21, 13, 14, 9, 10, 0, 14, 10, 6, 13, 17, 15, 14, 17, 9, 0, 13, 9, 12, 14, 16, 15, 9, 14, 6, 0, 14, 13, 9, 6, 23, 12, 11, 14, 8, 0, 10, 13, 13, 8, 15, 15, 12, 11, 13, 0, 11, 12, 11, 12, 25, 12, 9, 13, 11, 0, 11, 13, 10, 16, 33, 7, 11, 13, 11, 0, 8, 12, 7, 12, 52, 10, 9, 14, 11, 0, 13, 13, 11, 6, 20, 14, 12, 14, 9, 0, 12, 8, 12, 10, 21, 16, 12, 14, 13, 0, 7, 9, 13, 7, 21, 12, 13, 12, 8, 0, 6, 10, 11, 16, 18, 15, 7, 15, 9, 0, 11, 13, 14, 14, 109, 13, 9, 13, 13, 0, 13, 8, 7, 18, 14, 12, 9, 13, 11, 0, 14, 17, 7, 15, 38, 8, 12, 15, 12, 0, 14, 5, 8, 11, 21, 12, 9, 14, 12, 0, 8, 16, 15, 13, 18, 13, 12, 11, 8, 0, 9, 10, 9, 11, 52, 13, 9, 7, 10, 0, 11, 8, 12, 13, 12, 12, 7, 14, 10, 0, 13, 9, 9, 13, 17, 14, 8, 12, 11, 0, 10, 7, 11, 11, 17, 11, 12, 13, 13, 0, 8, 13, 12, 14, 15, 11, 10, 15, 9, 0, 10, 15, 15, 8, 20, 14, 11, 16, 7, 0, 11, 14, 10, 15, 21, 8, 9, 15, 13, 0, 12, 13, 11, 14, 23, 14, 6, 13, 12, 0, 6, 12, 12, 8, 17, 11, 6, 7, 9, 0, 10, 17, 13, 16, 18, 14, 14, 6, 8, 0, 11, 13, 13, 7, 21, 20, 10, 16, 14, 0, 13, 11, 12, 13, 32, 19, 8, 12, 7, 0, 14, 16, 21, 11, 21, 8, 12, 11, 8, 0, 12, 14, 9, 16, 21, 12, 6, 18, 10, 0, 13, 13, 10, 14, 11, 12, 9, 15, 9, 0, 11, 18, 13, 19, 32, 15, 14, 8, 13, 0, 11, 13, 7, 14, 16, 13, 5, 5, 8, 0, 12, 11, 8, 14, 16, 23, 5, 10, 7, 0, 11, 9, 12, 8, 10, 5, 11, 16, 8, 0, 12, 14, 9, 7, 26, 10, 12, 10, 12, 0, 9, 16, 11, 14, 24, 10, 8, 17, 7, 0, 13, 13, 11, 10, 17, 16, 10, 12, 11, 0, 11, 13, 10, 12, 21, 14, 10, 11, 12, 0, 13, 10, 7, 19, 11, 11, 13, 12, 14, 0, 4, 9, 13, 11, 14, 13, 13, 16, 11, 0, 9, 11, 9, 12, 21, 12, 9, 13, 8, 0, 12, 6, 10, 14, 21, 15, 5, 11, 13, 0, 7, 19, 14, 9, 14, 13, 10, 9, 11, 0, 10, 11, 12, 13, 21, 9, 13, 15, 9, 0, 8, 13, 7, 14, 20, 11, 10, 15, 13, 0, 10, 12, 11, 15, 22, 9, 10, 9, 11, 0, 14, 13, 6, 9, 26, 8, 12, 14, 10, 0, 13, 9, 11, 13, 14, 8, 9, 11, 12, 0, 8, 15, 10, 13, 18, 17, 11, 14, 7, 0, 8, 9, 11, 18, 64, 14, 12, 12, 12, 0, 15, 17, 14, 11, 13, 12, 13, 7, 13, 0, 11, 12, 7, 13, 27, 13, 11, 10, 8, 0, 13, 13, 12, 14, 20, 14, 9, 10, 12, 0, 13, 17, 13, 14, 18, 9, 6, 18, 7, 0, 8, 10, 11, 18, 20, 14, 11, 12, 11, 0, 8, 13, 9, 15, 26, 12, 9, 16, 11, 0, 13, 10, 8, 6, 24, 18, 10, 8, 8, 0, 9, 13, 7, 11, 22, 14, 13, 12, 12, 0, 8, 11, 5, 10, 16, 12, 11, 11, 15, 0, 12, 19, 13, 11, 18, 13, 17, 10, 13, 0, 11, 19, 13, 13, 26, 14, 12, 21, 10, 0, 13, 14, 9, 16, 21, 8, 10, 18, 13, 0, 14, 13, 13, 13, 23, 13, 13, 14, 12, 0, 14, 10, 9, 14, 25, 9, 8, 15, 8, 0, 7, 10, 13, 12, 7, 14, 13, 14, 10, 0, 9, 12, 8, 13, 15, 14, 13, 13, 12, 0, 13, 15, 13, 11, 15, 7, 11, 13, 9, 0, 13, 13, 13, 12, 15, 12, 10, 13, 13, 0, 8, 12, 12, 13, 17, 15, 13, 12, 11, 0, 11, 12, 12, 11, 16, 13, 11, 12, 11, 0, 14, 13, 8, 21, 45, 13, 11, 13, 8, 0, 10, 11, 12, 13, 18, 12, 11, 12, 9, 0, 13, 11, 11, 8, 14, 17, 10, 14, 10, 0, 8, 14, 9, 11, 21, 20, 10, 19, 10, 0, 13, 15, 8, 13, 15, 13, 11, 11, 12, 0, 13, 8, 14, 8, 33, 7, 14, 10, 11, 0, 10, 9, 13, 11, 15, 10, 10, 13, 8, 0, 7, 11, 13, 14, 20, 12, 11, 10, 15, 0, 13, 9, 9, 13, 25, 15, 14, 14, 11, 0, 12, 11, 11, 13, 20, 12, 13, 17, 13, 0, 13, 15, 7, 13, 14, 7, 13, 10, 11, 0, 11, 14, 10, 18, 32, 14, 11, 15, 11, 0, 13, 13, 10, 8, 21, 14, 11, 9, 10, 0, 9, 11, 10, 13, 27, 5, 13, 11, 8, 0, 12, 16, 12, 10, 24, 13, 10, 11, 13, 0, 13, 10, 13, 15, 92, 10, 11, 13, 7, 0, 13, 11, 12, 14, 53, 17, 11, 23, 15, 0, 9, 14, 8, 10, 18, 13, 14, 8, 9, 0, 10, 18, 10, 12, 21, 15, 10, 11, 10, 0, 13, 8, 7, 11, 21, 20, 12, 17, 8, 0, 11, 8, 12, 13, 12, 11, 11, 12, 11, 0, 14, 6, 10, 9, 23, 11, 8, 11, 13, 0, 12, 15, 7, 13, 30, 13, 11, 19, 12, 0, 10, 13, 7, 13, 15, 14, 11, 8, 6, 0, 8, 13, 12, 15, 12, 13, 12, 14, 9, 0, 9, 6, 9, 14, 24, 10, 14, 16, 11, 0, 10, 14, 13, 13, 20, 10, 12, 16, 12, 0, 14, 17, 16, 14, 21, 13, 11, 17, 11, 0, 9, 13, 13, 11, 14, 16, 8, 14, 11, 0, 7, 10, 6, 13, 19, 17, 16, 17, 8, 0, 9, 29, 7, 15, 23, 12, 9, 13, 10, 0, 9, 10, 8, 9, 25, 12, 10, 10, 14, 0, 8, 10, 9, 16, 14, 11, 12, 13, 9, 0, 9, 15, 8, 19, 22, 12, 6, 14, 15, 0, 10, 14, 11, 13, 17, 12, 10, 14, 13, 0, 10, 12, 9, 15, 23, 13, 7, 5, 11, 0, 13, 13, 10, 7, 19, 17, 9, 13, 9, 0, 7, 14, 9, 14, 25, 13, 13, 16, 9, 0, 15, 17, 11, 15, 13, 13, 13, 18, 8, 0, 10, 14, 7, 14, 22, 11, 14, 14, 6, 0, 13, 11, 6, 11, 29, 12, 11, 17, 11, 0, 12, 13, 11, 17, 19, 13, 11, 15, 11, 0, 13, 8, 14, 14, 18, 14, 7, 7, 13, 0, 10, 13, 11, 13, 21, 6, 12, 8, 16, 0, 9, 8, 12, 13, 22, 12, 14, 9, 12, 0, 13, 21, 12, 16, 21, 14, 13, 9, 10, 0, 7, 18, 11, 13, 11, 12, 12, 19, 12, 0, 7, 15, 6, 15, 24, 15, 9, 15, 13, 0, 12, 13, 8, 11, 18, 6, 7, 11, 12, 0, 13, 11, 11, 13, 22, 19, 9, 9, 12, 0, 11, 11, 12, 17, 28, 19, 11, 14, 12, 0, 8, 10, 9, 18, 10, 14, 6, 6, 13, 0, 13, 11, 10, 6, 16, 16, 10, 13, 8, 0, 11, 13, 8, 14, 33, 13, 13, 6, 11, 0, 13, 12, 13, 12, 21, 19, 12, 13, 12, 0, 8, 12, 11, 14, 32, 14, 10, 12, 9, 0, 11, 14, 14, 9, 15, 14, 9, 13, 13, 0, 12, 22, 9, 13, 10, 14, 10, 16, 7, 0, 12, 16, 10, 14, 19, 14, 12, 6, 13, 0, 13, 14, 10, 13, 22, 14, 11, 12, 13, 0, 7, 17, 12, 13, 26, 10, 13, 13, 13, 0, 8, 19, 10, 12, 23, 7, 5, 13, 13, 0, 11, 15, 13, 11, 23, 13, 13, 18, 10, 0, 11, 8, 7, 11, 21, 14, 13, 14, 9, 0, 6, 14, 12, 13, 16, 15, 13, 10, 10, 0, 9, 13, 11, 12, 28, 14, 11, 17, 11, 0, 14, 16, 8, 11, 34, 12, 11, 12, 10, 0, 10, 13, 7, 14, 18, 10, 8, 16, 12, 0, 14, 18, 9, 11, 23, 18, 13, 10, 10, 0, 4, 19, 10, 13, 21, 10, 11, 14, 9, 0, 13, 12, 12, 7, 25, 10, 13, 17, 7, 0, 12, 12, 11, 13, 24, 13, 8, 10, 9, 0, 13, 14, 11, 10, 28, 15, 8, 15, 13, 0, 12, 8, 13, 10, 14, 15, 11, 15, 13, 0, 13, 14, 13, 16, 22, 14, 9, 12, 14, 0, 7, 14, 10, 13, 23, 14, 12, 14, 13, 0, 13, 13, 14, 14, 20, 16, 12, 8, 9, 0, 14, 7, 6, 17, 32, 17, 13, 13, 13, 0, 13, 10, 12, 16, 15, 14, 10, 13, 7, 0, 13, 12, 9, 12, 13, 13, 13, 15, 13, 0, 13, 11, 12, 11, 19, 13, 8, 11, 13, 0, 13, 13, 10, 18, 28, 7, 10, 16, 12, 0, 10, 13, 12, 13, 15, 7, 12, 10, 15, 0, 8, 11, 13, 15, 24, 12, 9, 16, 17, 0, 13, 14, 8, 12, 14, 12, 13, 15, 11, 0, 14, 11, 10, 13, 29, 11, 13, 15, 13, 0, 9, 9, 13, 17, 30, 11, 8, 19, 11, 0, 9, 16, 11, 17, 23, 14, 13, 13, 9, 0, 11, 12, 11, 12, 26, 14, 13, 9, 12, 0, 12, 15, 11, 14, 20, 13, 7, 14, 11, 0, 16, 17, 13, 13, 195, 14, 10, 9, 9, 0, 10, 14, 12, 13, 17, 10, 8, 15, 13, 0, 8, 11, 13, 13, 16, 19, 12, 11, 13, 0, 13, 22, 11, 14, 7, 13, 8, 19, 12, 0, 13, 11, 13, 14, 20, 15, 8, 15, 10, 0, 12, 13, 14, 9, 9, 15, 13, 12, 13, 0, 15, 14, 13, 15, 21, 14, 11, 13, 11, 0, 15, 14, 11, 13, 22, 11, 11, 12, 13, 0, 15, 16, 7, 12, 22, 13, 14, 11, 11, 0, 7, 14, 12, 9, 27, 18, 12, 14, 14, 0, 13, 12, 10, 14, 21, 12, 9, 13, 11, 0, 15, 11, 10, 17, 21, 8, 7, 17, 11, 0, 11, 13, 12, 12, 15, 11, 9, 18, 13, 0, 10, 14, 14, 17, 16, 8, 13, 12, 14, 0, 11, 9, 8, 15, 23, 15, 7, 15, 10, 0, 9, 9, 11, 13, 23, 11, 7, 13, 9, 0, 9, 7, 8, 13, 14, 15, 14, 13, 12, 0, 12, 8, 8, 16, 19, 13, 12, 14, 13, 0, 14, 8, 9, 13, 29, 15, 10, 13, 10, 0, 9, 15, 13, 12, 14, 11, 13, 12, 14, 0, 13, 12, 13, 13, 32, 18, 15, 9, 13, 0, 11, 13, 13, 12, 23, 7, 12, 11, 10, 0, 11, 15, 7, 22, 25, 13, 6, 6, 12, 0, 11, 16, 13, 16, 6, 12, 6, 14, 13, 0, 13, 15, 7, 14, 20, 14, 10, 13, 8, 0, 18, 10, 12, 13, 26, 20, 12, 12, 10, 0, 7, 14, 13, 12, 29, 13, 10, 13, 11, 0, 12, 19, 13, 17, 29, 15, 12, 15, 16, 0, 12, 12, 11, 13, 16, 14, 12, 11, 10, 0, 11, 12, 13, 12, 23, 14, 14, 12, 11, 0, 8, 14, 12, 6, 15, 12, 6, 16, 7, 0, 11, 12, 16, 13, 28, 14, 14, 13, 7, 0, 11, 6, 11, 13, 18, 10, 6, 16, 11, 0, 6, 12, 9, 12, 18, 12, 12, 6, 6, 0, 13, 15, 9, 15, 18, 13, 10, 13, 12, 0, 11, 26, 11, 15, 26, 13, 8, 9, 13, 0, 9, 14, 10, 14, 21, 9, 16, 14, 13, 0, 12, 11, 12, 13, 30, 13, 17, 15, 13, 0, 6, 12, 11, 7, 16, 18, 11, 13, 13, 0, 12, 13, 11, 14, 18, 12, 10, 13, 12, 0, 13, 9, 7, 15, 19, 12, 14, 13, 11, 0, 11, 13, 11, 16, 17, 13, 9, 12, 13, 0, 12, 13, 10, 8, 28, 14, 9, 12, 7, 0, 14, 8, 12, 14, 21, 10, 13, 17, 10, 0, 11, 14, 9, 9, 18, 13, 11, 13, 10, 0, 12, 15, 11, 19, 54, 12, 12, 13, 14, 0, 13, 17, 11, 13, 10, 17, 9, 10, 11, 0, 10, 16, 13, 15, 23, 18, 14, 19, 14, 0, 14, 11, 10, 9, 19, 17, 8, 15, 12, 0, 13, 13, 10, 11, 24, 20, 8, 13, 13, 0, 12, 15, 14, 11, 20, 12, 12, 14, 13, 0, 9, 13, 13, 12, 22, 16, 10, 6, 8, 0, 11, 18, 13, 13, 11, 17, 11, 16, 12, 0, 8, 8, 8, 13, 21, 13, 13, 15, 14, 0, 13, 15, 12, 13, 21, 12, 14, 16, 10, 0, 14, 12, 13, 14, 16, 16, 13, 13, 10, 0, 10, 12, 13, 15, 21, 15, 14, 12, 7, 0, 9, 13, 13, 8, 12, 19, 9, 13, 13, 0, 13, 21, 9, 9, 27, 16, 10, 12, 14, 0, 13, 17, 13, 16, 24, 9, 11, 17, 10, 0, 13, 14, 11, 11, 23, 18, 11, 14, 10, 0, 9, 14, 13, 15, 22, 11, 12, 15, 12, 0, 13, 12, 17, 9, 22, 14, 8, 13, 11, 0, 10, 14, 14, 14, 21, 15, 11, 13, 11, 0, 12, 12, 7, 13, 18, 11, 14, 13, 11, 0, 8, 8, 13, 17, 33, 10, 10, 13, 13, 0, 15, 20, 10, 9, 26, 11, 11, 8, 10, 0, 21, 8, 7, 15, 14, 11, 13, 14, 16, 0, 13, 12, 13, 13, 23, 16, 10, 16, 12, 0, 15, 12, 9, 13, 23, 13, 10, 14, 13, 0, 11, 14, 9, 14, 19, 13, 11, 8, 12, 0, 11, 12, 9, 11, 25, 13, 13, 13, 13, 0, 10, 13, 9, 12, 21, 10, 11, 14, 8, 0, 13, 16, 12, 14, 17, 8, 8, 15, 14, 0, 15, 13, 11, 12, 38, 13, 13, 10, 11, 0, 12, 14, 9, 10, 34, 17, 15, 13, 13, 0, 11, 17, 12, 14, 24, 12, 8, 11, 10, 0, 10, 12, 10, 19, 18, 13, 10, 12, 14, 0, 8, 9, 9, 14, 23, 9, 15, 13, 12, 0, 4, 14, 16, 18, 17, 12, 13, 13, 11, 0, 11, 16, 16, 9, 29, 20, 6, 8, 13, 0, 11, 13, 9, 17, 21, 18, 14, 12, 12, 0, 13, 17, 12, 14, 23, 14, 12, 8, 13, 0, 13, 12, 12, 11, 22, 17, 11, 16, 11, 0, 11, 14, 10, 15, 30, 9, 14, 13, 9, 0, 11, 10, 9, 14, 31, 8, 12, 12, 13, 0, 15, 16, 7, 14, 25, 11, 8, 15, 10, 0, 7, 14, 11, 15, 17, 8, 13, 15, 13, 0, 13, 13, 11, 13, 16, 17, 13, 10, 14, 0, 13, 16, 6, 23, 19, 13, 9, 13, 7, 0, 10, 10, 11, 8, 53, 11, 9, 13, 10, 0, 13, 15, 11, 13, 11, 11, 8, 17, 8, 0, 12, 10, 13, 10, 21, 13, 15, 16, 11, 0, 8, 13, 9, 21, 21, 13, 13, 13, 12, 0, 6, 14, 10, 17, 17, 17, 8, 6, 11, 0, 13, 8, 9, 19, 25, 6, 10, 15, 13, 0, 9, 13, 15, 12, 21, 15, 9, 9, 8, 0, 11, 12, 12, 11, 27, 13, 13, 81, 16, 0, 6, 15, 8, 11, 14, 13, 12, 14, 15, 0, 11, 19, 11, 22, 21, 10, 6, 14, 10, 0, 13, 12, 12, 6, 23, 12, 8, 11, 13, 0, 8, 11, 11, 14, 15, 14, 10, 7, 7, 0, 9, 11, 6, 11, 17, 18, 6, 16, 12, 0, 6, 9, 14, 16, 23, 9, 13, 11, 11, 0, 13, 15, 12, 13, 26, 9, 12, 14, 13, 0, 10, 14, 12, 15, 139, 11, 8, 11, 9, 0, 14, 14, 10, 9, 13, 15, 11, 12, 12, 0, 11, 17, 8, 12, 17, 11, 7, 18, 13, 0, 11, 14, 13, 15, 28, 14, 12, 13, 10, 0, 13, 8, 13, 20, 22, 14, 13, 14, 9, 0, 11, 16, 13, 10, 24, 6, 10, 17, 11, 0, 11, 13, 10, 16, 61, 14, 11, 12, 12, 0, 9, 18, 13, 17, 15, 13, 11, 13, 12, 0, 9, 16, 8, 11, 23, 14, 15, 20, 13, 0, 11, 19, 13, 12, 18, 14, 7, 13, 14, 0, 14, 42, 11, 15, 22, 12, 10, 18, 10, 0, 8, 14, 6, 13, 52, 13, 9, 10, 12, 0, 11, 17, 14, 12, 21, 9, 12, 11, 13, 0, 14, 11, 12, 13, 14, 14, 9, 14, 8, 0, 12, 13, 10, 10, 30, 17, 12, 20, 13, 0, 11, 14, 11, 14, 35, 14, 12, 13, 13, 0, 12, 15, 10, 14, 21, 15, 13, 13, 12, 0, 10, 16, 8, 10, 21, 12, 6, 12, 11, 0, 12, 14, 14, 18, 50, 18, 11, 13, 13, 0, 11, 14, 12, 7, 16, 18, 12, 13, 10, 0, 12, 13, 12, 13, 29, 12, 11, 11, 14, 0, 12, 7, 7, 19, 21, 19, 12, 9, 15, 0, 11, 12, 10, 14, 20, 6, 14, 15, 13, 0, 15, 14, 14, 13, 15, 16, 11, 13, 12, 0, 11, 7, 7, 12, 12, 9, 15, 14, 12, 0, 12, 19, 14, 11, 34, 11, 12, 14, 14, 0, 14, 19, 10, 16, 16, 13, 13, 20, 12, 0, 14, 17, 15, 12, 12, 18, 11, 13, 13, 0, 11, 14, 8, 13, 16, 11, 6, 8, 12, 0, 9, 16, 8, 14, 21, 14, 11, 16, 14, 0, 12, 13, 9, 16, 29, 6, 9, 12, 8, 0, 11, 18, 9, 7, 9, 15, 12, 11, 11, 0, 10, 16, 13, 15, 17, 8, 10, 16, 8, 0, 14, 12, 10, 15, 23, 18, 14, 14, 12, 0, 10, 9, 8, 13, 23, 9, 11, 15, 13, 0, 11, 17, 8, 12, 22, 14, 9, 15, 9, 0, 14, 12, 10, 16, 34, 11, 9, 13, 15, 0, 13, 19, 12, 16, 20, 18, 13, 15, 13, 0, 14, 11, 13, 14, 22, 36, 9, 18, 12, 0, 12, 14, 12, 16, 21, 16, 13, 8, 12, 0, 13, 14, 12, 13, 25, 14, 12, 16, 14, 0, 8, 10, 13, 11, 24, 12, 9, 15, 14, 0, 14, 13, 9, 11, 23, 12, 12, 19, 12, 0, 13, 12, 10, 13, 38, 16, 8, 19, 12, 0, 14, 12, 9, 16, 24, 8, 14, 15, 12, 0, 10, 10, 10, 19, 35, 15, 12, 22, 13, 0, 12, 17, 8, 14, 20, 12, 13, 11, 14, 0, 12, 12, 14, 12, 27, 20, 7, 7, 10, 0, 13, 13, 16, 13, 12, 13, 13, 7, 11, 0, 12, 12, 13, 13, 16, 19, 13, 8, 12, 0, 9, 15, 13, 9, 14, 9, 10, 12, 13, 0, 10, 14, 14, 14, 18, 19, 9, 8, 15, 0, 13, 17, 12, 9, 12, 13, 16, 12, 17, 0, 11, 14, 13, 13, 18, 14, 14, 7, 13, 0, 9, 11, 13, 9, 19, 11, 10, 13, 11, 0, 7, 13, 14, 13, 26, 7, 9, 10, 14, 0, 11, 13, 9, 14, 24, 14, 13, 14, 8, 0, 10, 9, 13, 8, 28, 9, 11, 10, 11, 0, 13, 21, 14, 14, 23, 15, 15, 9, 13, 0, 13, 16, 13, 12, 19, 19, 9, 11, 15, 0, 12, 13, 9, 15, 27, 9, 13, 19, 12, 0, 11, 18, 14, 17, 23, 14, 13, 14, 12, 0, 12, 10, 9, 17, 25, 19, 17, 12, 30, 0, 8, 20, 17, 12, 23, 19, 14, 14, 16, 0, 7, 14, 12, 17, 14, 22, 11, 14, 11, 0, 12, 14, 13, 15, 33, 14, 12, 14, 8, 0, 12, 13, 9, 15, 19, 12, 11, 16, 12, 0, 11, 19, 10, 14, 16, 20, 12, 16, 13, 0, 13, 12, 6, 12, 22, 15, 8, 13, 10, 0, 14, 12, 11, 17, 27, 16, 12, 18, 12, 0, 13, 16, 11, 13, 20, 14, 9, 18, 11, 0, 14, 11, 11, 15, 14, 14, 6, 13, 13, 0, 8, 14, 6, 11, 18, 13, 8, 13, 17, 0, 6, 6, 6, 12, 19, 11, 14, 15, 14, 0, 6, 14, 9, 13, 12, 11, 13, 18, 13, 0, 6, 11, 12, 12, 13, 14, 13, 14, 14, 0, 13, 18, 13, 14, 25, 12, 8, 19, 11, 0, 15, 14, 13, 20, 18, 19, 8, 13, 11, 0, 12, 11, 10, 11, 24, 13, 13, 19, 12, 0, 13, 11, 10, 18, 20, 15, 12, 9, 10, 0, 14, 14, 13, 13, 56, 6, 11, 12, 9, 0, 13, 10, 15, 8, 18, 8, 14, 14, 11, 0, 9, 6, 10, 17, 17, 15, 12, 15, 15, 0, 6, 19, 13, 18, 25, 13, 14, 18, 9, 0, 13, 12, 10, 14, 21, 9, 9, 15, 9, 0, 8, 8, 12, 15, 18, 15, 15, 13, 11, 0, 13, 12, 12, 16, 30, 15, 13, 12, 12, 0, 11, 13, 9, 13, 18, 17, 13, 8, 14, 0, 11, 13, 14, 15, 17, 11, 11, 18, 13, 0, 11, 15, 8, 11, 19, 15, 12, 9, 11, 0, 6, 21, 13, 14, 23, 8, 11, 5, 13, 0, 11, 15, 6, 12, 25, 12, 12, 12, 7, 0, 6, 17, 14, 15, 14, 13, 10, 23, 14, 0, 6, 15, 13, 10, 29, 17, 13, 13, 10, 0, 12, 9, 13, 13, 29, 12, 10, 13, 11, 0, 11, 17, 13, 14, 33, 13, 10, 11, 13, 0, 15, 14, 11, 12, 22, 12, 11, 19, 12, 0, 14, 18, 16, 14, 23, 14, 13, 11, 14, 0, 12, 10, 15, 9, 14, 17, 12, 10, 10, 0, 13, 13, 12, 14, 23, 16, 12, 13, 11, 0, 5, 14, 11, 12, 17, 12, 5, 17, 7, 0, 13, 19, 12, 12, 17, 13, 15, 13, 11, 0, 12, 9, 10, 17, 53, 16, 9, 17, 11, 0, 13, 12, 7, 11, 17, 12, 13, 13, 11, 0, 13, 10, 13, 11, 23, 14, 12, 15, 13, 0, 11, 14, 11, 9, 32, 14, 13, 19, 11, 0, 11, 9, 9, 9, 17, 15, 5, 14, 10, 0, 9, 12, 11, 15, 20, 16, 12, 11, 10, 0, 13, 14, 9, 17, 21, 7, 10, 13, 13, 0, 13, 11, 12, 20, 35, 17, 11, 15, 7, 0, 11, 12, 11, 16, 23, 13, 10, 15, 13, 0, 13, 17, 10, 17, 21, 20, 10, 9, 13, 0, 14, 14, 11, 14, 23, 14, 11, 15, 14, 0, 10, 8, 13, 8, 32, 16, 10, 12, 10, 0, 15, 20, 11, 8, 23, 13, 8, 13, 13, 0, 13, 8, 9, 12, 33, 19, 14, 16, 12, 0, 9, 15, 11, 14, 17, 11, 11, 14, 13, 0, 9, 14, 10, 16, 61, 16, 8, 13, 10, 0, 12, 9, 14, 17, 14, 5, 5, 13, 9, 0, 5, 18, 16, 13, 20, 14, 13, 12, 8, 0, 13, 8, 7, 13, 29, 13, 13, 9, 8, 0, 8, 41, 7, 13, 14, 15, 12, 10, 12, 0, 8, 12, 13, 18, 29, 10, 14, 16, 11, 0, 10, 20, 12, 14, 40, 5, 9, 14, 12, 0, 12, 13, 8, 17, 24, 8, 15, 17, 13, 0, 11, 17, 13, 11, 35, 13, 12, 19, 13, 0, 11, 8, 10, 15, 23, 15, 10, 13, 12, 0, 11, 9, 11, 15, 21, 14, 12, 10, 12, 0, 9, 12, 13, 8, 17, 14, 15, 11, 14, 0, 9, 12, 9, 13, 29, 15, 11, 14, 8, 0, 13, 10, 14, 13, 12, 18, 11, 12, 11, 0, 6, 18, 13, 12, 22, 13, 9, 14, 12, 0, 13, 13, 13, 15, 27, 17, 13, 14, 9, 0, 13, 15, 7, 14, 10, 12, 13, 11, 10, 0, 11, 12, 12, 8, 23, 13, 14, 14, 12, 0, 11, 9, 6, 13, 52, 16, 14, 6, 11, 0, 11, 13, 8, 17, 14, 14, 13, 12, 13, 0, 11, 14, 11, 14, 21, 21, 14, 19, 10, 0, 12, 18, 13, 13, 47, 14, 13, 18, 7, 0, 13, 16, 13, 13, 25, 13, 8, 17, 10, 0, 7, 13, 12, 12, 33, 9, 12, 8, 14, 0, 8, 14, 12, 18, 15, 11, 14, 13, 12, 0, 12, 14, 11, 8, 16, 8, 11, 8, 8, 0, 16, 12, 11, 16, 10, 18, 7, 10, 14, 0, 10, 14, 8, 12, 23, 21, 9, 13, 8, 0, 13, 7, 16, 9, 15, 8, 12, 9, 10, 0, 11, 19, 13, 18, 24, 13, 7, 14, 12, 0, 13, 12, 8, 14, 21, 18, 13, 17, 8, 0, 10, 13, 14, 14, 19, 13, 13, 15, 12, 0, 14, 11, 12, 15, 24, 14, 14, 12, 11, 0, 16, 13, 12, 17, 21, 11, 9, 17, 11, 0, 13, 17, 11, 16, 23, 16, 12, 13, 15, 0, 12, 14, 13, 14, 17, 18, 11, 14, 13, 0, 9, 12, 13, 12, 21, 13, 8, 13, 13, 0, 7, 14, 13, 18, 38, 8, 13, 11, 12, 0, 11, 14, 13, 14, 33, 6, 8, 18, 14, 0, 12, 17, 14, 12, 21, 10, 11, 17, 7, 0, 11, 17, 14, 14, 18, 10, 10, 13, 14, 0, 9, 13, 13, 17, 16, 13, 10, 8, 15, 0, 13, 11, 14, 13, 23, 14, 11, 11, 12, 0, 10, 20, 9, 13, 21, 19, 9, 19, 13, 0, 14, 14, 11, 12, 19, 13, 9, 14, 26, 0, 15, 14, 11, 13, 18, 15, 13, 14, 14, 0, 7, 16, 10, 8, 22, 13, 13, 21, 10, 0, 6, 7, 8, 15, 21, 11, 11, 13, 13, 0, 7, 14, 12, 15, 21, 19, 13, 10, 12, 0, 7, 17, 11, 14, 30, 15, 5, 17, 13, 0, 13, 17, 13, 12, 30, 16, 13, 9, 13, 0, 13, 14, 13, 14, 34, 5, 8, 16, 13, 0, 11, 14, 11, 13, 19, 15, 11, 14, 9, 0, 12, 16, 13, 11, 34, 17, 14, 11, 9, 0, 10, 13, 12, 11, 15, 17, 12, 13, 14, 0, 12, 15, 12, 14, 17, 10, 12, 18, 13, 0, 6, 12, 7, 24, 23, 13, 13, 17, 15, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 17, 9, 12, 10, 0, 5, 5, 5, 14, 16, 18, 12, 16, 13, 0, 5, 5, 11, 10, 21, 15, 12, 9, 12, 0, 5, 5, 8, 17, 21, 17, 15, 13, 15, 0, 5, 19, 15, 9, 26, 15, 14, 13, 6, 0, 5, 14, 12, 9, 22, 12, 8, 14, 10, 0, 5, 16, 12, 18, 25, 9, 13, 15, 12, 0, 5, 13, 9, 12, 24, 13, 12, 11, 11, 0, 14, 14, 14, 11, 21, 16, 12, 9, 11, 0, 5, 5, 5, 5, 5, 11, 10, 22, 10, 0, 5, 5, 11, 10, 33, 11, 16, 17, 9, 0, 5, 20, 16, 17, 26, 12, 13, 18, 13, 0, 5, 12, 15, 15, 29, 12, 15, 11, 11, 0, 5, 14, 9, 13, 18, 13, 13, 15, 14, 0, 11, 17, 11, 39, 24, 11, 11, 13, 6, 0, 11, 9, 10, 15, 49, 17, 13, 14, 14, 0, 12, 12, 13, 12, 30, 13, 12, 14, 10, 0, 14, 14, 8, 16, 21, 13, 11, 15, 15, 0, 9, 10, 8, 13, 17, 19, 12, 17, 11, 0, 5, 5, 5, 12, 23, 8, 14, 18, 12, 0, 5, 14, 12, 14, 26, 14, 12, 11, 15, 0, 5, 12, 13, 12, 22, 14, 8, 7, 7, 0, 16, 16, 16, 7, 20, 17, 9, 13, 11, 0, 12, 13, 9, 17, 26, 16, 10, 14, 12, 0, 12, 9, 10, 14, 24, 12, 13, 16, 11, 0, 11, 14, 8, 11, 90, 13, 8, 12, 13, 0, 10, 32, 11, 15, 28, 13, 10, 14, 13, 0, 13, 14, 10, 19, 26, 60, 13, 13, 11, 0, 13, 17, 12, 13, 8, 14, 7, 15, 13, 0, 5, 5, 12, 11, 26, 10, 12, 8, 12, 0, 5, 19, 9, 21, 26, 17, 13, 15, 14, 0, 13, 13, 8, 19, 16, 14, 11, 17, 9, 0, 13, 12, 9, 13, 21, 17, 12, 13, 11, 0, 9, 16, 13, 13, 18, 16, 12, 13, 13, 0, 13, 16, 7, 13, 29, 12, 14, 16, 16, 0, 8, 19, 10, 18, 13, 13, 8, 15, 14, 0, 13, 9, 13, 14, 24, 17, 8, 19, 12, 0, 11, 12, 13, 11, 27, 7, 8, 11, 13, 0, 7, 14, 13, 14, 30, 13, 15, 6, 13, 0, 5, 5, 15, 14, 22, 9, 8, 14, 8, 0, 5, 15, 6, 15, 30, 17, 10, 10, 13, 0, 14, 16, 12, 15, 18, 14, 12, 20, 15, 0, 14, 19, 11, 12, 15, 11, 13, 17, 14, 0, 16, 15, 8, 15, 23, 11, 9, 10, 9, 0, 10, 14, 7, 13, 21, 15, 11, 13, 9, 0, 9, 14, 12, 20, 14, 14, 17, 14, 14, 0, 12, 14, 13, 10, 15, 17, 10, 14, 12, 0, 12, 13, 14, 13, 21, 11, 14, 17, 9, 0, 14, 17, 14, 12, 28, 18, 8, 15, 15, 0, 5, 14, 16, 12, 32, 14, 10, 14, 13, 0, 15, 13, 8, 6, 21, 15, 15, 21, 9, 0, 17, 12, 13, 14, 23, 17, 13, 14, 14, 0, 10, 13, 14, 7, 16, 13, 13, 13, 12, 0, 13, 13, 13, 16, 114, 13, 14, 17, 12, 0, 11, 18, 7, 13, 15, 17, 15, 18, 11, 0, 11, 13, 13, 12, 21, 10, 16, 11, 8, 0, 8, 12, 8, 12, 24, 16, 11, 13, 11, 0, 13, 12, 11, 14, 16, 21, 7, 10, 7, 0, 12, 15, 14, 12, 16, 15, 14, 11, 13, 0, 5, 14, 9, 17, 34, 12, 9, 13, 13, 0, 13, 9, 14, 11, 31, 15, 13, 12, 6, 0, 11, 17, 8, 6, 19, 11, 16, 16, 12, 0, 17, 18, 10, 22, 29, 13, 12, 13, 13, 0, 12, 12, 11, 13, 21, 14, 11, 17, 13, 0, 12, 14, 13, 16, 26, 14, 14, 12, 9, 0, 12, 13, 12, 18, 26, 22, 12, 19, 13, 0, 12, 10, 12, 6, 19, 15, 13, 14, 10, 0, 13, 14, 8, 13, 21, 14, 14, 16, 12, 0, 9, 13, 9, 12, 17, 18, 13, 21, 15, 0, 5, 15, 12, 14, 19, 18, 13, 16, 9, 0, 11, 13, 11, 14, 32, 13, 11, 14, 12, 0, 7, 14, 10, 18, 21, 13, 11, 19, 11, 0, 15, 12, 15, 15, 20, 17, 13, 14, 8, 0, 10, 11, 13, 14, 19, 11, 9, 12, 13, 0, 13, 20, 15, 17, 18, 18, 12, 13, 13, 0, 9, 16, 11, 11, 36, 11, 9, 12, 10, 0, 9, 19, 10, 13, 27, 19, 8, 12, 11, 0, 13, 17, 6, 15, 15, 11, 13, 14, 11, 0, 7, 10, 13, 16, 25, 13, 8, 12, 13, 0, 5, 11, 14, 18, 24, 14, 14, 12, 8, 0, 6, 15, 15, 27, 38, 9, 9, 15, 14, 0, 11, 15, 14, 14, 20, 15, 13, 12, 13, 0, 16, 19, 13, 13, 15, 14, 14, 18, 10, 0, 14, 13, 11, 14, 15, 17, 13, 12, 12, 0, 12, 15, 12, 14, 28, 17, 13, 19, 14, 0, 9, 9, 11, 15, 32, 9, 15, 15, 13, 0, 13, 13, 12, 15, 18, 17, 15, 22, 15, 0, 11, 15, 12, 23, 24, 19, 12, 13, 15, 0, 11, 17, 12, 17, 24, 22, 14, 14, 12, 0, 7, 8, 14, 14, 21, 8, 12, 18, 10, 0, 11, 19, 14, 14, 56, 19, 14, 19, 13, 0, 11, 14, 12, 18, 15, 17, 11, 8, 14, 0, 14, 14, 16, 15, 34, 14, 10, 18, 9, 0, 13, 11, 12, 14, 7, 13, 12, 19, 10, 0, 15, 18, 13, 23, 21, 18, 12, 13, 14, 0, 11, 15, 8, 18, 15, 13, 13, 12, 11, 0, 13, 15, 13, 14, 16, 18, 13, 13, 16, 0, 14, 12, 13, 15, 19, 29, 12, 16, 11, 0, 6, 14, 11, 12, 29, 14, 9, 14, 11, 0, 5, 5, 5, 5, 5, 13, 13, 12, 9, 0, 5, 5, 14, 10, 26, 15, 9, 14, 14, 0, 5, 12, 13, 17, 21, 11, 14, 13, 8, 0, 5, 20, 11, 9, 23, 17, 9, 15, 16, 0, 5, 14, 16, 14, 25, 19, 15, 18, 13, 0, 12, 13, 11, 17, 23, 18, 9, 13, 14, 0, 8, 11, 12, 15, 25, 19, 13, 16, 11, 0, 10, 20, 15, 9, 24, 7, 12, 13, 13, 0, 10, 21, 10, 17, 71, 15, 13, 14, 13, 0, 8, 9, 10, 11, 22, 9, 12, 17, 10, 0, 5, 5, 13, 13, 24, 12, 14, 18, 13, 0, 5, 14, 15, 13, 35, 15, 11, 8, 14, 0, 11, 7, 10, 15, 21, 17, 15, 17, 12, 0, 13, 17, 7, 13, 26, 18, 14, 11, 14, 0, 12, 13, 10, 12, 23, 21, 13, 14, 18, 0, 11, 14, 9, 11, 25, 17, 13, 15, 14, 0, 10, 13, 10, 15, 29, 13, 14, 16, 13, 0, 10, 13, 15, 6, 72, 15, 9, 28, 12, 0, 11, 18, 10, 14, 20, 7, 7, 12, 9, 0, 11, 14, 10, 19, 16, 17, 8, 15, 10, 0, 5, 13, 10, 8, 18, 14, 12, 17, 11, 0, 7, 12, 11, 16, 15, 22, 11, 14, 12, 0, 7, 8, 15, 13, 18, 8, 11, 14, 13, 0, 14, 14, 14, 13, 21, 6, 6, 6, 6, 0, 14, 16, 15, 10, 24, 13, 6, 6, 6, 0, 17, 14, 13, 12, 15, 13, 9, 6, 6, 0, 9, 13, 14, 18, 45, 12, 13, 14, 6, 0, 12, 10, 10, 27, 15, 14, 13, 13, 13, 0, 8, 9, 12, 11, 38, 15, 9, 19, 15, 0, 13, 15, 16, 8, 24, 15, 13, 13, 9, 0, 5, 16, 12, 11, 19, 11, 16, 19, 8, 0, 13, 13, 8, 14, 31, 17, 11, 19, 12, 0, 12, 13, 12, 9, 17, 14, 13, 21, 11, 0, 13, 13, 8, 15, 23, 14, 13, 16, 16, 0, 11, 16, 13, 11, 25, 11, 6, 6, 6, 0, 15, 9, 14, 13, 21, 30, 10, 6, 6, 0, 13, 9, 11, 13, 27, 15, 13, 15, 6, 0, 13, 15, 6, 10, 32, 15, 12, 9, 7, 0, 10, 13, 11, 9, 26, 7, 13, 14, 7, 0, 11, 16, 15, 11, 15, 17, 14, 13, 11, 0, 5, 20, 11, 8, 16, 15, 11, 14, 10, 0, 13, 11, 12, 8, 23, 13, 12, 14, 12, 0, 13, 13, 10, 13, 23, 14, 10, 13, 13, 0, 14, 8, 11, 15, 19, 14, 10, 16, 10, 0, 14, 17, 11, 12, 21, 10, 18, 13, 10, 0, 16, 14, 15, 21, 17, 14, 9, 6, 6, 0, 11, 12, 13, 13, 33, 25, 9, 9, 6, 0, 17, 14, 8, 13, 21, 14, 11, 13, 10, 0, 9, 19, 11, 17, 32, 16, 11, 16, 7, 0, 13, 12, 11, 13, 26, 14, 11, 7, 11, 0, 14, 8, 12, 17, 21, 11, 10, 14, 8, 0, 9, 12, 8, 17, 92, 20, 12, 14, 8, 0, 14, 9, 13, 14, 17, 14, 8, 11, 14, 0, 8, 15, 13, 14, 21, 15, 13, 11, 7, 0, 14, 17, 17, 14, 24, 14, 14, 17, 13, 0, 11, 17, 10, 16, 9, 17, 13, 14, 11, 0, 14, 13, 9, 11, 30, 14, 10, 14, 6, 0, 12, 16, 12, 15, 20, 13, 8, 19, 13, 0, 17, 10, 9, 19, 18, 11, 8, 13, 14, 0, 13, 17, 9, 23, 28, 11, 12, 13, 8, 0, 13, 10, 8, 13, 18, 13, 13, 19, 10, 0, 13, 14, 11, 16, 19, 13, 12, 16, 15, 0, 12, 13, 14, 19, 12, 10, 12, 14, 11, 0, 9, 18, 17, 10, 21, 16, 12, 16, 8, 0, 12, 15, 11, 8, 24, 13, 12, 9, 13, 0, 19, 13, 16, 17, 61, 12, 11, 15, 14, 0, 13, 15, 7, 17, 29, 7, 16, 5, 10, 0, 14, 10, 7, 11, 19, 13, 9, 17, 14, 0, 14, 9, 13, 17, 31, 10, 14, 14, 11, 0, 13, 17, 12, 9, 20, 14, 12, 17, 11, 0, 11, 16, 16, 13, 30, 21, 11, 19, 9, 0, 15, 15, 13, 11, 37, 13, 10, 16, 13, 0, 12, 20, 12, 20, 10, 14, 14, 17, 14, 0, 11, 13, 13, 12, 18, 16, 14, 11, 10, 0, 14, 13, 13, 17, 18, 16, 11, 10, 13, 0, 13, 16, 10, 19, 13, 16, 14, 10, 9, 0, 8, 13, 14, 16, 8, 12, 14, 16, 11, 0, 14, 17, 16, 10, 18, 10, 9, 13, 10, 0, 14, 11, 11, 17, 25, 22, 15, 20, 12, 0, 14, 18, 15, 12, 19, 13, 14, 16, 14, 0, 15, 11, 14, 16, 21, 16, 13, 15, 13, 0, 11, 12, 12, 14, 34, 11, 16, 26, 13, 0, 17, 9, 10, 18, 22, 13, 17, 12, 12, 0, 13, 20, 13, 17, 23, 13, 13, 13, 12, 0, 13, 9, 14, 14, 23, 13, 11, 16, 12, 0, 17, 15, 6, 8, 25, 13, 9, 8, 13, 0, 11, 16, 12, 20, 35, 18, 10, 14, 10, 0, 13, 13, 10, 12, 21, 10, 22, 13, 12, 0, 12, 21, 13, 16, 16, 13, 14, 17, 15, 0, 13, 13, 12, 15, 12, 11, 15, 36, 15, 0, 7, 16, 9, 13, 23, 15, 9, 18, 13, 0, 10, 18, 13, 19, 24, 18, 7, 14, 9, 0, 9, 14, 15, 14, 34, 14, 10, 11, 11, 0, 12, 16, 13, 13, 23, 12, 15, 15, 11, 0, 11, 12, 14, 15, 16, 13, 13, 11, 13, 0, 14, 19, 12, 15, 26, 18, 15, 13, 10, 0, 14, 13, 14, 19, 27, 19, 13, 11, 13, 0, 10, 15, 8, 17, 23, 19, 12, 8, 10, 0, 13, 14, 15, 12, 21, 10, 13, 13, 8, 0, 14, 20, 13, 13, 27, 16, 12, 18, 9, 0, 5, 5, 5, 17, 27, 11, 14, 14, 9, 0, 5, 20, 13, 12, 23, 20, 16, 8, 14, 0, 5, 9, 12, 14, 38, 15, 13, 14, 12, 0, 12, 19, 8, 11, 38, 13, 12, 15, 13, 0, 9, 13, 11, 15, 19, 13, 11, 14, 11, 0, 10, 13, 9, 17, 28, 18, 12, 15, 12, 0, 15, 19, 16, 12, 23, 13, 15, 20, 13, 0, 11, 17, 13, 8, 21, 16, 11, 17, 13, 0, 13, 9, 13, 13, 30, 16, 7, 12, 13, 0, 10, 13, 9, 16, 24, 9, 12, 9, 12, 0, 5, 21, 12, 15, 23, 11, 12, 13, 8, 0, 13, 13, 11, 17, 30, 14, 13, 7, 13, 0, 9, 11, 13, 19, 14, 11, 13, 18, 11, 0, 11, 14, 11, 14, 23, 16, 13, 13, 11, 0, 12, 19, 12, 13, 30, 9, 6, 10, 14, 0, 14, 16, 13, 13, 14, 13, 7, 18, 11, 0, 13, 18, 14, 16, 30, 16, 14, 16, 16, 0, 13, 18, 13, 13, 32, 12, 14, 12, 13, 0, 13, 8, 14, 18, 17, 13, 13, 15, 8, 0, 11, 21, 14, 11, 15, 9, 14, 14, 9, 0, 5, 28, 14, 17, 15, 15, 13, 11, 14, 0, 7, 16, 11, 18, 32, 15, 13, 21, 11, 0, 14, 19, 13, 13, 23, 11, 11, 13, 11, 0, 8, 19, 11, 19, 25, 14, 14, 17, 16, 0, 13, 15, 8, 9, 26, 13, 14, 11, 8, 0, 10, 13, 13, 13, 28, 17, 9, 14, 10, 0, 12, 8, 12, 9, 14, 20, 11, 18, 11, 0, 11, 19, 14, 18, 25, 19, 7, 9, 9, 0, 14, 14, 14, 19, 21, 13, 11, 14, 7, 0, 10, 12, 14, 11, 17, 16, 16, 22, 15, 0, 7, 13, 13, 14, 19, 9, 11, 11, 13, 0, 11, 14, 13, 13, 35, 6, 13, 14, 18, 0, 9, 15, 10, 18, 23, 17, 9, 14, 15, 0, 13, 15, 17, 9, 28, 20, 15, 15, 12, 0, 14, 15, 7, 13, 21, 18, 6, 6, 6, 0, 11, 18, 10, 13, 19, 16, 16, 6, 6, 0, 15, 22, 9, 20, 40, 14, 14, 19, 6, 0, 7, 21, 13, 13, 23, 14, 13, 8, 12, 0, 13, 15, 14, 14, 26, 11, 14, 17, 12, 0, 13, 18, 14, 19, 38, 14, 11, 12, 9, 0, 12, 12, 13, 20, 18, 13, 11, 14, 8, 0, 12, 16, 10, 13, 29, 13, 6, 16, 7, 0, 12, 11, 15, 14, 16, 14, 13, 19, 13, 0, 12, 8, 14, 12, 19, 19, 14, 12, 16, 0, 18, 17, 12, 14, 27, 14, 13, 16, 11, 0, 17, 15, 13, 13, 29, 17, 17, 6, 6, 0, 11, 14, 14, 18, 34, 14, 13, 19, 6, 0, 13, 12, 15, 8, 18, 14, 14, 18, 13, 0, 13, 16, 11, 13, 15, 14, 13, 14, 13, 0, 15, 14, 9, 9, 15, 13, 13, 7, 11, 0, 13, 12, 14, 18, 24, 14, 12, 14, 7, 0, 15, 16, 12, 14, 16, 14, 9, 16, 8, 0, 11, 15, 14, 13, 28, 15, 16, 12, 15, 0, 11, 19, 15, 13, 28, 18, 11, 14, 13, 0, 12, 13, 13, 20, 16, 13, 11, 17, 11, 0, 14, 13, 10, 23, 15, 16, 8, 18, 11, 0, 10, 12, 8, 14, 21, 13, 14, 11, 6, 0, 9, 18, 13, 17, 22, 17, 12, 16, 13, 0, 15, 8, 14, 19, 21, 18, 14, 13, 9, 0, 8, 17, 13, 5, 27, 13, 5, 11, 14, 0, 11, 18, 11, 20, 30, 14, 8, 15, 10, 0, 13, 8, 9, 17, 37, 19, 17, 13, 15, 0, 7, 13, 12, 13, 22, 12, 5, 13, 14, 0, 11, 13, 13, 20, 13, 16, 12, 12, 7, 0, 17, 13, 14, 9, 15, 12, 12, 10, 11, 0, 12, 21, 13, 8, 24, 12, 12, 13, 11, 0, 8, 12, 10, 7, 19, 14, 11, 14, 13, 0, 13, 14, 9, 9, 23, 12, 14, 13, 14, 0, 15, 14, 12, 8, 14, 15, 11, 16, 15, 0, 11, 13, 13, 15, 32, 13, 12, 14, 15, 0, 13, 11, 12, 18, 21, 14, 11, 16, 12, 0, 18, 14, 15, 13, 27, 21, 13, 16, 10, 0, 11, 11, 12, 17, 26, 17, 8, 15, 11, 0, 7, 10, 15, 15, 15, 16, 11, 8, 13, 0, 11, 17, 11, 11, 16, 22, 15, 8, 14, 0, 10, 20, 11, 14, 24, 17, 14, 15, 13, 0, 12, 16, 15, 17, 189, 18, 13, 20, 12, 0, 18, 19, 11, 13, 23, 13, 11, 14, 6, 0, 15, 17, 10, 6, 22, 13, 15, 16, 9, 0, 11, 6, 9, 12, 29, 15, 11, 8, 13, 0, 13, 11, 13, 6, 22, 7, 18, 9, 15, 0, 17, 16, 12, 18, 33, 13, 9, 16, 15, 0, 13, 14, 12, 14, 27, 14, 14, 14, 6, 0, 13, 15, 14, 13, 20, 13, 17, 7, 12, 0, 9, 24, 14, 12, 15, 17, 12, 17, 14, 0, 14, 14, 12, 11, 24, 13, 11, 20, 8, 0, 13, 19, 18, 13, 35, 12, 14, 9, 13, 0, 7, 18, 12, 20, 28, 22, 11, 13, 10, 0, 12, 14, 11, 14, 21, 17, 15, 14, 12, 0, 13, 12, 15, 14, 23, 14, 14, 18, 12, 0, 13, 12, 14, 6, 24, 18, 14, 13, 9, 0, 14, 20, 12, 13, 34, 17, 17, 14, 15, 0, 12, 16, 14, 9, 23, 15, 5, 14, 12, 0, 17, 20, 12, 19, 19, 19, 15, 22, 19, 0, 8, 15, 17, 14, 21, 8, 13, 14, 13, 0, 13, 17, 11, 15, 29, 7, 11, 14, 15, 0, 15, 13, 13, 19, 34, 9, 14, 16, 15, 0, 15, 16, 12, 11, 21, 12, 13, 14, 12, 0, 7, 23, 12, 18, 21, 14, 12, 7, 8, 0, 11, 18, 14, 9, 36, 12, 11, 8, 14, 0, 5, 5, 13, 17, 18, 17, 8, 11, 16, 0, 5, 16, 13, 14, 15, 17, 14, 7, 11, 0, 11, 10, 9, 17, 24, 10, 14, 13, 6, 0, 13, 21, 14, 16, 21, 12, 18, 14, 8, 0, 13, 10, 13, 14, 18, 17, 12, 17, 15, 0, 14, 16, 15, 13, 24, 15, 15, 10, 15, 0, 12, 16, 14, 13, 29, 18, 9, 16, 9, 0, 8, 18, 6, 13, 30, 15, 12, 12, 10, 0, 16, 19, 11, 13, 22, 16, 13, 23, 13, 0, 11, 14, 13, 10, 23, 7, 14, 42, 11, 0, 5, 11, 11, 13, 11, 14, 13, 16, 13, 0, 12, 12, 9, 9, 25, 13, 16, 11, 9, 0, 13, 13, 11, 14, 21, 17, 12, 21, 11, 0, 13, 11, 13, 11, 131, 18, 12, 13, 9, 0, 17, 12, 8, 10, 25, 13, 11, 19, 15, 0, 11, 14, 11, 6, 22, 10, 8, 14, 17, 0, 16, 15, 12, 12, 25, 11, 13, 18, 12, 0, 15, 12, 14, 19, 29, 17, 13, 14, 8, 0, 13, 13, 13, 19, 18, 9, 14, 15, 10, 0, 13, 15, 10, 26, 16, 15, 12, 14, 16, 0, 15, 13, 8, 17, 15, 15, 14, 13, 13, 0, 12, 18, 15, 14, 23, 13, 13, 14, 11, 0, 15, 11, 14, 17, 23, 29, 13, 16, 8, 0, 14, 13, 13, 16, 24, 20, 12, 15, 13, 0, 14, 13, 11, 15, 34, 9, 15, 13, 13, 0, 9, 20, 17, 13, 20, 11, 12, 9, 13, 0, 13, 14, 13, 14, 33, 14, 9, 18, 14, 0, 13, 15, 7, 17, 23, 18, 8, 14, 6, 0, 9, 8, 17, 9, 25, 11, 13, 12, 12, 0, 10, 14, 12, 15, 14, 16, 9, 14, 12, 0, 13, 17, 7, 15, 21, 14, 13, 7, 8, 0, 12, 14, 14, 13, 25, 13, 14, 18, 12, 0, 13, 20, 7, 17, 29, 12, 9, 15, 15, 0, 10, 15, 7, 17, 21, 17, 10, 11, 8, 0, 16, 13, 10, 13, 24, 7, 13, 18, 7, 0, 12, 11, 12, 18, 22, 18, 14, 13, 7, 0, 8, 13, 13, 15, 35, 10, 14, 14, 13, 0, 13, 14, 11, 13, 17, 12, 8, 14, 16, 0, 16, 14, 12, 13, 23, 14, 11, 16, 14, 0, 12, 19, 16, 17, 17, 17, 9, 14, 14, 0, 11, 21, 13, 6, 21, 18, 13, 16, 13, 0, 10, 16, 10, 16, 31, 11, 10, 18, 10, 0, 13, 14, 15, 17, 26, 12, 11, 13, 10, 0, 8, 16, 12, 14, 20, 17, 9, 15, 16, 0, 14, 12, 13, 14, 22, 16, 15, 17, 12, 0, 16, 14, 10, 10, 23, 14, 14, 6, 6, 0, 13, 18, 7, 15, 38, 18, 11, 14, 6, 0, 14, 20, 13, 17, 21, 13, 11, 11, 13, 0, 8, 14, 12, 14, 23, 12, 12, 12, 13, 0, 14, 8, 14, 11, 24, 19, 13, 11, 14, 0, 13, 15, 11, 11, 30, 11, 14, 15, 9, 0, 14, 16, 18, 19, 30, 17, 7, 11, 13, 0, 7, 14, 16, 36, 22, 10, 14, 13, 11, 0, 9, 14, 13, 19, 28, 16, 9, 13, 14, 0, 11, 14, 17, 12, 23, 21, 15, 17, 10, 0, 13, 19, 10, 14, 25, 18, 14, 16, 14, 0, 11, 8, 13, 10, 25, 18, 15, 13, 6, 0, 10, 17, 11, 13, 28, 17, 12, 13, 12, 0, 11, 13, 8, 19, 18, 14, 9, 19, 15, 0, 11, 17, 11, 16, 23, 13, 11, 14, 8, 0, 14, 9, 14, 11, 21, 15, 10, 14, 11, 0, 13, 18, 11, 10, 33, 14, 15, 12, 12, 0, 11, 19, 10, 16, 28, 17, 13, 13, 12, 0, 10, 22, 11, 12, 21, 16, 7, 13, 11, 0, 13, 25, 12, 13, 18, 14, 11, 18, 17, 0, 16, 16, 12, 19, 21, 19, 8, 11, 13, 0, 13, 7, 12, 13, 35, 13, 7, 13, 15, 0, 12, 13, 11, 13, 24, 22, 13, 12, 12, 0, 16, 12, 15, 19, 30, 13, 10, 16, 16, 0, 13, 8, 16, 12, 21, 16, 15, 17, 13, 0, 9, 15, 14, 19, 7, 12, 13, 13, 15, 0, 14, 17, 14, 12, 23, 12, 15, 11, 10, 0, 13, 14, 9, 17, 15, 12, 14, 13, 14, 0, 11, 15, 12, 14, 28, 18, 13, 21, 13, 0, 12, 13, 14, 19, 16, 13, 9, 16, 13, 0, 11, 17, 15, 20, 15, 15, 7, 13, 11, 0, 9, 12, 10, 11, 20, 12, 9, 12, 10, 0, 11, 17, 14, 18, 9, 13, 16, 8, 9, 0, 16, 17, 12, 13, 29, 15, 11, 17, 7, 0, 13, 19, 15, 14, 52, 12, 13, 11, 12, 0, 13, 20, 13, 17, 26, 19, 9, 16, 18, 0, 14, 22, 10, 15, 29, 13, 11, 19, 8, 0, 18, 21, 14, 18, 21, 11, 14, 17, 9, 0, 11, 15, 11, 16, 11, 14, 12, 8, 13, 0, 12, 7, 10, 16, 23, 10, 11, 13, 12, 0, 10, 19, 13, 9, 21, 17, 10, 14, 14, 0, 11, 10, 14, 16, 26, 13, 15, 13, 12, 0, 11, 12, 13, 12, 78, 14, 10, 14, 8, 0, 14, 12, 12, 21, 27, 18, 21, 16, 16, 0, 18, 14, 20, 12, 24, 17, 13, 13, 13, 0, 14, 21, 9, 18, 50, 14, 14, 17, 17, 0, 14, 17, 12, 13, 29, 18, 12, 13, 14, 0, 13, 12, 14, 13, 15, 17, 13, 17, 11, 0, 11, 13, 19, 15, 17, 17, 14, 13, 8, 0, 13, 7, 11, 17, 26, 10, 11, 12, 9, 0, 13, 18, 11, 14, 18, 21, 8, 18, 16, 0, 15, 14, 11, 11, 30, 15, 12, 16, 14, 0, 13, 16, 14, 13, 28, 14, 13, 18, 11, 0, 14, 14, 13, 16, 23, 9, 10, 13, 8, 0, 11, 22, 12, 24, 26, 13, 12, 13, 11, 0, 5, 5, 13, 14, 15, 11, 12, 17, 13, 0, 5, 15, 13, 16, 32, 15, 15, 10, 14, 0, 9, 14, 13, 13, 21, 11, 11, 14, 6, 0, 14, 15, 12, 10, 20, 14, 13, 15, 9, 0, 11, 10, 11, 17, 15, 14, 16, 17, 11, 0, 9, 15, 15, 11, 21, 12, 15, 14, 13, 0, 13, 19, 13, 11, 32, 23, 13, 17, 14, 0, 13, 12, 12, 19, 25, 17, 13, 10, 9, 0, 13, 13, 14, 14, 16, 8, 13, 19, 8, 0, 13, 13, 15, 18, 31, 14, 9, 12, 16, 0, 5, 15, 13, 15, 15, 11, 15, 13, 10, 0, 7, 14, 14, 10, 35, 20, 8, 11, 11, 0, 11, 20, 10, 17, 23, 17, 14, 14, 11, 0, 9, 17, 11, 8, 24, 12, 9, 14, 13, 0, 8, 11, 12, 19, 29, 17, 12, 14, 11, 0, 14, 16, 14, 6, 19, 17, 9, 9, 14, 0, 11, 11, 14, 8, 32, 11, 12, 17, 8, 0, 12, 22, 18, 15, 23, 21, 8, 13, 14, 0, 6, 13, 14, 21, 15, 19, 15, 17, 14, 0, 12, 12, 13, 13, 26, 19, 12, 13, 8, 0, 10, 14, 9, 18, 15, 8, 10, 14, 11, 0, 10, 13, 10, 17, 30, 20, 13, 18, 14, 0, 12, 13, 10, 14, 18, 14, 12, 18, 10, 0, 14, 14, 14, 13, 28, 13, 13, 14, 9, 0, 12, 10, 14, 21, 30, 17, 12, 18, 12, 0, 15, 15, 10, 14, 21, 13, 13, 13, 16, 0, 13, 13, 14, 14, 27, 17, 12, 12, 11, 0, 11, 18, 14, 17, 24, 16, 15, 14, 14, 0, 16, 19, 17, 15, 23, 17, 12, 11, 12, 0, 15, 9, 13, 13, 24, 16, 11, 14, 14, 0, 8, 16, 15, 14, 23, 14, 13, 12, 11, 0, 13, 11, 15, 10, 24, 15, 11, 13, 12, 0, 9, 17, 11, 16, 29, 19, 16, 13, 13, 0, 16, 13, 13, 29, 26, 7, 12, 15, 10, 0, 10, 12, 12, 11, 32, 13, 15, 16, 13, 0, 8, 14, 9, 10, 21, 8, 13, 9, 8, 0, 13, 18, 12, 16, 23, 10, 13, 21, 13, 0, 11, 15, 14, 18, 28, 19, 13, 17, 13, 0, 16, 11, 9, 14, 15, 13, 9, 14, 13, 0, 12, 12, 12, 19, 25, 8, 14, 19, 13, 0, 14, 14, 14, 19, 25, 14, 14, 16, 13, 0, 13, 16, 15, 16, 30, 13, 9, 15, 9, 0, 14, 16, 13, 20, 17, 14, 9, 15, 14, 0, 12, 10, 13, 12, 13, 14, 8, 15, 9, 0, 13, 13, 9, 12, 20, 5, 14, 11, 11, 0, 9, 13, 12, 13, 32, 18, 9, 13, 15, 0, 7, 19, 9, 13, 26, 13, 12, 15, 12, 0, 9, 13, 10, 26, 21, 16, 11, 14, 13, 0, 8, 13, 9, 16, 27, 16, 13, 12, 13, 0, 13, 19, 12, 17, 11, 11, 12, 15, 13, 0, 13, 16, 15, 17, 29, 19, 12, 13, 10, 0, 13, 18, 14, 14, 465, 9, 9, 14, 11, 0, 13, 14, 19, 19, 27, 14, 9, 12, 8, 0, 14, 29, 14, 11, 21, 16, 12, 18, 11, 0, 7, 14, 13, 13, 32, 17, 14, 13, 14, 0, 9, 12, 11, 16, 24, 13, 13, 17, 13, 0, 9, 13, 12, 11, 34, 19, 10, 14, 6, 0, 14, 13, 13, 19, 27, 19, 10, 14, 16, 0, 11, 14, 11, 20, 29, 14, 13, 19, 11, 0, 14, 15, 9, 19, 21, 11, 13, 13, 11, 0, 13, 22, 12, 13, 23, 8, 14, 23, 13, 0, 13, 14, 13, 8, 53, 17, 13, 18, 13, 0, 15, 15, 14, 19, 21, 14, 13, 12, 12, 0, 14, 18, 7, 21, 22, 15, 14, 16, 16, 0, 15, 14, 13, 16, 16, 9, 13, 14, 13, 0, 15, 12, 12, 18, 22, 11, 14, 13, 12, 0, 11, 12, 10, 13, 29, 20, 13, 20, 12, 0, 14, 17, 8, 15, 23, 14, 11, 15, 17, 0, 7, 16, 13, 17, 27, 15, 11, 22, 16, 0, 14, 14, 13, 13, 23, 15, 8, 11, 8, 0, 14, 6, 13, 17, 23, 11, 10, 19, 16, 0, 15, 14, 12, 11, 23, 15, 11, 16, 11, 0, 13, 19, 11, 17, 24, 9, 14, 12, 12, 0, 12, 15, 18, 11, 20, 15, 13, 17, 12, 0, 11, 19, 14, 20, 23, 14, 13, 14, 12, 0, 13, 18, 12, 10, 32, 18, 14, 18, 10, 0, 15, 26, 6, 6, 6, 6, 14, 13, 11, 0, 16, 14, 6, 16, 12, 18, 13, 6, 19, 0, 11, 16, 6, 10, 34, 13, 15, 9, 9, 0, 14, 17, 6, 27, 28, 14, 7, 14, 13, 0, 15, 13, 18, 13, 32, 6, 7, 15, 14, 0, 14, 14, 13, 12, 90, 14, 18, 12, 10, 0, 15, 19, 17, 12, 27, 13, 7, 18, 13, 0, 11, 18, 14, 12, 23, 14, 15, 14, 10, 0, 13, 16, 9, 15, 23, 14, 8, 16, 12, 0, 10, 17, 14, 14, 21, 22, 12, 9, 14, 0, 17, 14, 6, 16, 29, 13, 13, 14, 8, 0, 12, 17, 15, 22, 28, 9, 13, 13, 16, 0, 13, 14, 12, 16, 20, 16, 14, 12, 12, 0, 12, 14, 15, 16, 34, 21, 16, 16, 8, 0, 14, 14, 18, 18, 14, 6, 12, 18, 16, 0, 17, 18, 6, 14, 20, 21, 13, 13, 11, 0, 12, 14, 10, 14, 15, 12, 12, 13, 11, 0, 13, 10, 11, 17, 18, 12, 13, 20, 15, 0, 11, 15, 14, 14, 23, 13, 10, 17, 9, 0, 12, 18, 11, 19, 12, 13, 13, 12, 12, 0, 8, 7, 6, 13, 32, 18, 14, 19, 12, 0, 14, 11, 12, 16, 21, 13, 11, 11, 16, 0, 12, 13, 12, 13, 61, 19, 8, 19, 14, 0, 19, 11, 15, 8, 27, 7, 12, 11, 7, 0, 5, 18, 14, 17, 30, 14, 13, 15, 7, 0, 13, 10, 12, 14, 23, 16, 13, 23, 20, 0, 17, 15, 11, 20, 15, 10, 14, 12, 11, 0, 17, 15, 16, 22, 33, 13, 13, 12, 13, 0, 14, 16, 12, 17, 21, 17, 14, 14, 6, 0, 14, 14, 12, 16, 20, 16, 14, 11, 9, 0, 11, 12, 6, 13, 33, 12, 12, 10, 14, 0, 12, 13, 15, 13, 26, 9, 15, 14, 16, 0, 13, 10, 15, 8, 16, 16, 8, 13, 8, 0, 14, 19, 13, 18, 23, 16, 13, 13, 13, 0, 11, 18, 8, 13, 29, 13, 7, 14, 7, 0, 12, 19, 9, 22, 34, 18, 14, 20, 14, 0, 11, 12, 16, 16, 24, 14, 11, 15, 8, 0, 11, 17, 11, 19, 29, 15, 6, 7, 15, 0, 13, 18, 15, 13, 17, 17, 15, 15, 14, 0, 9, 18, 14, 12, 26, 14, 15, 13, 12, 0, 12, 20, 15, 19, 35, 10, 11, 13, 13, 0, 10, 17, 12, 14, 17, 15, 16, 21, 12, 0, 15, 15, 13, 15, 18, 15, 12, 14, 13, 0, 13, 13, 6, 18, 15, 18, 9, 13, 14, 0, 14, 15, 13, 11, 20, 15, 6, 15, 13, 0, 12, 19, 16, 14, 32, 20, 15, 16, 13, 0, 8, 14, 9, 18, 27, 15, 12, 14, 13, 0, 15, 18, 8, 14, 21, 12, 14, 13, 13, 0, 10, 19, 12, 17, 24, 14, 11, 18, 12, 0, 13, 13, 13, 19, 26, 18, 13, 14, 10, 0, 13, 16, 13, 14, 23, 12, 13, 18, 12, 0, 16, 14, 14, 7, 17, 17, 10, 17, 6, 0, 13, 17, 14, 16, 21, 13, 15, 14, 14, 0, 13, 14, 17, 10, 24, 17, 13, 17, 14, 0, 9, 14, 15, 19, 22, 22, 12, 16, 11, 0, 8, 13, 10, 12, 29, 12, 16, 12, 13, 0, 15, 19, 8, 13, 20, 16, 8, 20, 16, 0, 14, 13, 11, 11, 22, 17, 12, 12, 13, 0, 13, 13, 7, 21, 26, 11, 10, 20, 16, 0, 13, 14, 10, 16, 38, 19, 13, 18, 9, 0, 14, 7, 18, 15, 18, 19, 13, 17, 10, 0, 15, 14, 13, 13, 26, 16, 7, 13, 13, 0, 12, 12, 13, 15, 16, 13, 14, 20, 9, 0, 12, 14, 17, 11, 21, 13, 12, 15, 13, 0, 12, 24, 12, 13, 29, 16, 8, 17, 14, 0, 10, 14, 18, 14, 25, 16, 11, 14, 13, 0, 16, 15, 13, 19, 23, 15, 13, 15, 8, 0, 13, 21, 9, 16, 27, 14, 6, 17, 13, 0, 13, 11, 14, 16, 21, 15, 11, 21, 14, 0, 14, 11, 11, 9, 16, 14, 11, 17, 11, 0, 9, 11, 15, 14, 24, 45, 13, 14, 14, 0, 12, 18, 12, 16, 14, 18, 13, 17, 9, 0, 10, 16, 9, 15, 22, 13, 15, 16, 14, 0, 16, 14, 12, 12, 29, 12, 13, 22, 7, 0, 11, 14, 12, 21, 26, 9, 9, 19, 8, 0, 9, 13, 7, 15, 20, 11, 14, 14, 11, 0, 9, 13, 15, 7, 27, 14, 15, 14, 16, 0, 13, 19, 9, 17, 24, 19, 13, 13, 14, 0, 9, 14, 7, 15, 29, 9, 15, 13, 11, 0, 15, 17, 15, 14, 129, 24, 13, 13, 14, 0, 15, 10, 12, 17, 12, 15, 13, 14, 11, 0, 9, 8, 12, 11, 25, 20, 14, 15, 13, 0, 13, 19, 11, 12, 20, 11, 12, 14, 16, 0, 14, 13, 10, 22, 31, 20, 12, 16, 11, 0, 15, 13, 9, 14, 24, 19, 10, 12, 15, 0, 11, 13, 13, 11, 29, 15, 13, 16, 9, 0, 12, 15, 7, 17, 14, 19, 12, 15, 13, 0, 14, 16, 18, 13, 25, 18, 13, 9, 10, 0, 12, 18, 12, 14, 15, 17, 14, 14, 8, 0, 9, 20, 14, 14, 22, 16, 13, 17, 13, 0, 18, 18, 12, 13, 40, 13, 13, 11, 9, 0, 9, 19, 11, 14, 29, 16, 15, 13, 8, 0, 17, 11, 9, 13, 27, 12, 14, 14, 13, 0, 12, 26, 13, 16, 14, 15, 8, 16, 13, 0, 15, 13, 16, 14, 29, 20, 10, 21, 13, 0, 7, 17, 12, 14, 19, 17, 12, 9, 14, 0, 17, 18, 10, 13, 109, 14, 13, 21, 11, 0, 15, 19, 12, 12, 23, 23, 13, 14, 15, 0, 13, 12, 12, 17, 16, 13, 13, 11, 11, 0, 9, 19, 10, 27, 18, 20, 12, 17, 13, 0, 13, 8, 6, 12, 29, 17, 13, 14, 10, 0, 16, 11, 11, 13, 30, 15, 13, 14, 15, 0, 7, 11, 13, 16, 26, 18, 9, 16, 14, 0, 16, 15, 13, 14, 26, 19, 10, 17, 8, 0, 9, 18, 13, 13, 25, 12, 12, 19, 14, 0, 14, 13, 10, 9, 24, 17, 17, 27, 13, 0, 12, 15, 13, 21, 18, 15, 20, 14, 11, 0, 14, 19, 10, 11, 16, 14, 12, 13, 18, 0, 14, 13, 10, 12, 25, 14, 10, 13, 11, 0, 8, 19, 15, 16, 21, 20, 11, 13, 10, 0, 12, 15, 14, 14, 26, 17, 14, 12, 14, 0, 8, 20, 21, 8, 26, 13, 15, 16, 14, 0, 8, 22, 12, 14, 34, 17, 15, 13, 8, 0, 13, 14, 9, 16, 18, 12, 13, 18, 11, 0, 14, 15, 13, 20, 23, 13, 7, 10, 13, 0, 9, 16, 15, 15, 18, 18, 16, 13, 8, 0, 16, 13, 7, 16, 17, 12, 5, 15, 8, 0, 13, 15, 9, 12, 25, 14, 13, 13, 18, 0, 18, 18, 10, 15, 28, 27, 11, 14, 13, 0, 14, 16, 11, 13, 9, 18, 12, 12, 12, 0, 8, 7, 17, 12, 25, 11, 14, 18, 10, 0, 14, 14, 14, 18, 25, 18, 15, 22, 17, 0, 11, 15, 15, 60, 22, 18, 13, 14, 13, 0, 16, 15, 10, 20, 25, 13, 13, 16, 14, 0, 5, 12, 15, 14, 27, 14, 12, 14, 11, 0, 11, 19, 12, 15, 23, 20, 13, 14, 14, 0, 13, 14, 15, 11, 25, 14, 16, 19, 8, 0, 17, 21, 13, 15, 21, 14, 13, 13, 11, 0, 11, 24, 13, 14, 20, 14, 15, 15, 10, 0, 14, 9, 13, 14, 26, 16, 15, 19, 17, 0, 17, 13, 17, 12, 35, 13, 11, 17, 13, 0, 13, 16, 15, 22, 24, 14, 8, 17, 10, 0, 10, 15, 15, 16, 29, 15, 14, 16, 14, 0, 10, 17, 10, 19, 61, 11, 13, 13, 11, 0, 15, 14, 15, 13, 18, 15, 13, 13, 16, 0, 11, 19, 16, 12, 24, 14, 11, 12, 15, 0, 15, 19, 11, 21, 27, 12, 10, 18, 14, 0, 9, 8, 12, 14, 20, 12, 13, 13, 14, 0, 14, 18, 11, 17, 14, 19, 16, 19, 8, 0, 16, 13, 10, 13, 23, 16, 15, 13, 9, 0, 13, 14, 12, 18, 38, 13, 13, 15, 13, 0, 9, 17, 15, 6, 12, 19, 10, 13, 13, 0, 8, 10, 9, 19, 32, 20, 9, 20, 14, 0, 16, 6, 6, 12, 26, 14, 12, 12, 13, 0, 14, 20, 16, 15, 15, 6, 12, 13, 13, 0, 17, 17, 13, 15, 46, 13, 12, 15, 10, 0, 16, 13, 13, 10, 22, 13, 12, 19, 10, 0, 16, 14, 14, 30, 15, 13, 16, 15, 11, 0, 16, 13, 11, 15, 32, 9, 12, 14, 9, 0, 12, 19, 13, 14, 25, 10, 11, 17, 12, 0, 11, 9, 6, 17, 22, 14, 13, 13, 18, 0, 11, 14, 13, 11, 18, 14, 12, 21, 11, 0, 12, 13, 10, 17, 24, 15, 15, 18, 16, 0, 11, 19, 14, 12, 29, 14, 12, 7, 13, 0, 14, 18, 17, 14, 29, 15, 13, 21, 16, 0, 11, 18, 13, 14, 27, 11, 12, 18, 10, 0, 14, 12, 11, 10, 32, 13, 9, 19, 10, 0, 12, 21, 8, 9, 26, 12, 11, 15, 12, 0, 13, 23, 14, 17, 16, 16, 14, 16, 15, 0, 8, 16, 13, 13, 16, 19, 14, 16, 9, 0, 10, 13, 13, 17, 29, 12, 12, 13, 8, 0, 13, 13, 10, 13, 17, 10, 13, 13, 9, 0, 16, 14, 11, 13, 25, 13, 15, 16, 11, 0, 14, 19, 16, 21, 29, 13, 17, 14, 9, 0, 13, 10, 12, 21, 23, 17, 13, 18, 15, 0, 12, 19, 13, 14, 34, 17, 8, 9, 14, 0, 13, 14, 7, 18, 24, 13, 13, 12, 7, 0, 13, 15, 11, 15, 18, 19, 10, 19, 12, 0, 14, 14, 16, 19, 23, 13, 12, 14, 11, 0, 15, 15, 11, 17, 18, 18, 12, 14, 14, 0, 17, 17, 13, 19, 53, 10, 10, 11, 12, 0, 16, 12, 11, 22, 15, 14, 10, 15, 18, 0, 13, 18, 6, 16, 26, 19, 11, 17, 15, 0, 6, 19, 8, 11, 24, 18, 12, 15, 16, 0, 10, 17, 16, 19, 52, 17, 8, 16, 18, 0, 14, 13, 11, 13, 15, 18, 14, 17, 8, 0, 10, 20, 14, 18, 15, 14, 7, 17, 6, 0, 9, 19, 14, 15, 29, 17, 18, 11, 13, 0, 13, 12, 13, 15, 21, 16, 14, 14, 6, 0, 16, 10, 8, 20, 17, 13, 13, 12, 13, 0, 14, 16, 12, 18, 92, 6, 10, 15, 14, 0, 8, 14, 12, 18, 29, 19, 16, 13, 10, 0, 17, 17, 16, 14, 27, 22, 13, 13, 13, 0, 11, 17, 13, 8, 20, 17, 12, 16, 12, 0, 13, 14, 15, 16, 15, 15, 10, 15, 14, 0, 14, 16, 8, 18, 28, 12, 14, 15, 13, 0, 10, 12, 13, 14, 20, 16, 15, 10, 13, 0, 12, 14, 17, 12, 50, 15, 16, 14, 11, 0, 14, 16, 8, 13, 14, 13, 17, 10, 13, 0, 14, 20, 12, 14, 32, 14, 15, 15, 15, 0, 10, 15, 15, 15, 21, 12, 15, 11, 13, 0, 14, 9, 14, 13, 17, 15, 9, 8, 12, 0, 10, 20, 19, 14, 17, 16, 7, 14, 14, 0, 11, 13, 10, 21, 32, 14, 14, 16, 14, 0, 12, 16, 13, 11, 24, 12, 13, 19, 13, 0, 9, 19, 14, 19, 22, 13, 10, 16, 13, 0, 10, 9, 14, 13, 10, 17, 13, 10, 12, 0, 9, 14, 12, 19, 25, 12, 13, 11, 11, 0, 10, 18, 13, 12, 25, 14, 9, 18, 13, 0, 15, 13, 8, 14, 21, 13, 8, 15, 12, 0, 11, 15, 6, 21, 36, 18, 13, 17, 14, 0, 14, 20, 13, 12, 22, 47, 11, 19, 17, 0, 12, 15, 15, 19, 21, 13, 10, 19, 12, 0, 13, 19, 14, 14, 25, 14, 15, 14, 10, 0, 8, 15, 9, 18, 21, 13, 15, 13, 13, 0, 14, 14, 17, 12, 27, 7, 11, 14, 11, 0, 18, 11, 15, 19, 28, 22, 11, 11, 15, 0, 12, 8, 11, 14, 38, 14, 11, 19, 14, 0, 14, 19, 9, 18, 30, 14, 13, 19, 15, 0, 16, 19, 14, 20, 27, 14, 11, 9, 10, 0, 10, 11, 13, 11, 15, 8, 10, 10, 13, 0, 14, 22, 15, 8, 29, 10, 14, 15, 11, 0, 19, 11, 12, 19, 25, 14, 8, 17, 11, 0, 14, 16, 16, 12, 20, 13, 12, 13, 14, 0, 14, 16, 14, 14, 25, 16, 12, 12, 15, 0, 13, 19, 16, 14, 29, 15, 14, 13, 13, 0, 12, 13, 9, 10, 21, 14, 12, 20, 12, 0, 12, 19, 10, 14, 12, 19, 12, 14, 11, 0, 9, 13, 17, 22, 30, 8, 8, 21, 12, 0, 12, 11, 19, 17, 23, 14, 13, 11, 13, 0, 12, 13, 11, 13, 35, 13, 12, 13, 9, 0, 14, 18, 19, 13, 14, 20, 15, 12, 11, 0, 15, 16, 16, 20, 36, 14, 13, 19, 14, 0, 17, 14, 13, 16, 24, 19, 13, 14, 10, 0, 5, 14, 15, 18, 24, 15, 13, 14, 8, 0, 12, 16, 9, 19, 52, 11, 11, 14, 11, 0, 13, 13, 14, 19, 22, 10, 14, 18, 14, 0, 13, 12, 13, 30, 25, 15, 8, 13, 17, 0, 17, 17, 12, 15, 19, 13, 12, 19, 13, 0, 14, 13, 10, 19, 16, 21, 14, 14, 14, 0, 9, 13, 12, 12, 24, 16, 12, 18, 15, 0, 15, 10, 8, 12, 24, 10, 11, 19, 12, 0, 16, 14, 14, 14, 14, 14, 13, 14, 16, 0, 13, 21, 9, 9, 32, 9, 12, 17, 13, 0, 16, 9, 14, 16, 7, 13, 16, 20, 17, 0, 13, 15, 14, 21, 29, 18, 12, 19, 12, 0, 15, 12, 13, 13, 24, 15, 17, 18, 11, 0, 13, 16, 13, 16, 21, 17, 13, 9, 13, 0, 7, 20, 10, 6, 21, 18, 14, 18, 14, 0, 13, 16, 15, 13, 25, 20, 14, 17, 11, 0, 14, 20, 17, 17, 25, 12, 9, 12, 13, 0, 12, 13, 15, 17, 23, 16, 9, 14, 14, 0, 11, 14, 12, 13, 20, 8, 13, 21, 13, 0, 13, 14, 11, 13, 25, 20, 14, 11, 13, 0, 11, 17, 14, 11, 61, 20, 11, 14, 14, 0, 15, 21, 11, 20, 33, 17, 16, 15, 11, 0, 12, 9, 12, 15, 25, 13, 11, 14, 15, 0, 10, 13, 13, 10, 27, 14, 11, 14, 14, 0, 15, 8, 15, 18, 29, 13, 14, 20, 11, 0, 12, 15, 13, 16, 27, 14, 11, 14, 13, 0, 15, 11, 14, 15, 21, 17, 12, 13, 10, 0, 14, 12, 13, 19, 30, 12, 11, 15, 13, 0, 8, 16, 9, 13, 24, 15, 11, 18, 16, 0, 14, 17, 12, 13, 21, 14, 17, 13, 7, 0, 14, 17, 12, 14, 17, 12, 17, 15, 13, 0, 10, 20, 13, 16, 34, 6, 15, 23, 16, 0, 13, 30, 12, 12, 20, 13, 13, 18, 12, 0, 12, 10, 15, 15, 29, 11, 12, 12, 12, 0, 10, 11, 17, 20, 24, 13, 8, 11, 12, 0, 12, 14, 9, 25, 29, 18, 15, 13, 13, 0, 13, 11, 8, 14, 33, 17, 13, 14, 13, 0, 13, 13, 9, 10, 20, 20, 13, 10, 11, 0, 14, 13, 16, 22, 29, 16, 15, 14, 13, 0, 17, 18, 15, 13, 28, 13, 13, 21, 19, 0, 8, 14, 13, 16, 24, 13, 14, 20, 6, 0, 6, 6, 11, 14, 35, 20, 6, 18, 13, 0, 13, 17, 8, 15, 25, 6, 6, 16, 11, 0, 12, 16, 16, 10, 25, 18, 6, 19, 14, 0, 18, 6, 13, 12, 33, 15, 18, 13, 17, 0, 16, 9, 10, 13, 26, 17, 10, 13, 13, 0, 12, 15, 8, 9, 25, 13, 14, 8, 13, 0, 13, 19, 12, 12, 29, 12, 12, 11, 17, 0, 11, 13, 16, 15, 24, 81, 13, 20, 13, 0, 9, 6, 13, 15, 29, 8, 15, 19, 14, 0, 14, 13, 13, 16, 23, 17, 18, 17, 11, 0, 14, 20, 16, 19, 14, 11, 15, 22, 12, 0, 17, 10, 14, 10, 28, 14, 17, 11, 11, 0, 12, 16, 14, 12, 34, 12, 11, 13, 13, 0, 9, 12, 11, 19, 41, 18, 12, 14, 14, 0, 11, 15, 8, 14, 30, 15, 15, 14, 12, 0, 9, 18, 17, 14, 38, 10, 15, 19, 11, 0, 11, 15, 16, 11, 44, 6, 6, 28, 14, 0, 15, 18, 9, 15, 23, 16, 15, 21, 8, 0, 13, 6, 9, 13, 21, 14, 11, 16, 17, 0, 13, 19, 15, 15, 26, 11, 15, 22, 10, 0, 9, 14, 10, 15, 14, 19, 16, 13, 17, 0, 11, 9, 6, 15, 18, 14, 17, 13, 14, 0, 14, 15, 13, 14, 14, 12, 14, 15, 12, 0, 11, 11, 13, 8, 32, 11, 12, 18, 9, 0, 14, 16, 14, 14, 21, 21, 14, 22, 10, 0, 11, 15, 13, 14, 28, 12, 14, 13, 16, 0, 13, 20, 13, 17, 27, 8, 9, 13, 13, 0, 16, 11, 14, 14, 18, 18, 12, 13, 16, 0, 11, 11, 14, 14, 24, 19, 11, 15, 9, 0, 11, 16, 13, 12, 22, 13, 15, 17, 9, 0, 8, 16, 10, 15, 35, 20, 13, 22, 14, 0, 14, 16, 13, 14, 15, 14, 13, 14, 14, 0, 13, 19, 14, 16, 29, 14, 15, 22, 14, 0, 16, 6, 14, 17, 29, 17, 11, 20, 12, 0, 12, 14, 13, 21, 30, 10, 15, 16, 13, 0, 10, 14, 6, 14, 16, 19, 9, 17, 13, 0, 13, 13, 12, 18, 15, 17, 9, 17, 6, 0, 20, 13, 15, 16, 14, 13, 13, 12, 13, 0, 11, 15, 11, 16, 18, 13, 10, 11, 13, 0, 16, 14, 16, 20, 26, 20, 16, 20, 16, 0, 15, 13, 13, 19, 37, 19, 18, 15, 9, 0, 15, 14, 12, 14, 22, 13, 14, 15, 9, 0, 15, 14, 14, 42, 13, 21, 10, 15, 15, 0, 14, 12, 13, 14, 19, 18, 14, 10, 11, 0, 15, 20, 13, 14, 13, 14, 16, 13, 15, 0, 11, 13, 14, 18, 46, 21, 14, 17, 13, 0, 21, 17, 15, 17, 25, 20, 14, 12, 11, 0, 13, 9, 15, 12, 27, 11, 16, 17, 13, 0, 18, 14, 14, 11, 26, 17, 16, 13, 16, 0, 12, 14, 11, 10, 18, 14, 14, 11, 7, 0, 17, 16, 16, 13, 34, 15, 13, 10, 13, 0, 15, 17, 15, 16, 29, 20, 12, 21, 15, 0, 13, 19, 8, 14, 31, 18, 14, 14, 11, 0, 7, 14, 13, 13, 38, 19, 14, 13, 11, 0, 14, 14, 13, 15, 24, 10, 13, 17, 17, 0, 11, 15, 17, 13, 34, 22, 11, 15, 15, 0, 8, 20, 17, 17, 32, 15, 10, 19, 13, 0, 12, 14, 14, 16, 23, 18, 11, 13, 8, 0, 14, 12, 17, 22, 24, 16, 13, 18, 13, 0, 5, 18, 17, 11, 27, 13, 16, 18, 13, 0, 9, 18, 12, 15, 13, 19, 15, 7, 9, 0, 8, 19, 14, 13, 22, 13, 15, 18, 13, 0, 15, 14, 13, 13, 27, 12, 13, 13, 13, 0, 12, 14, 12, 17, 15, 11, 17, 16, 7, 0, 13, 16, 17, 7, 20, 13, 16, 26, 16, 0, 14, 19, 13, 20, 29, 12, 13, 20, 11, 0, 11, 17, 11, 12, 26, 10, 14, 14, 16, 0, 12, 6, 11, 22, 29, 20, 14, 17, 17, 0, 6, 17, 12, 14, 22, 14, 12, 13, 11, 0, 14, 19, 11, 13, 20, 19, 12, 17, 10, 0, 13, 19, 13, 7, 34, 13, 11, 15, 14, 0, 16, 19, 12, 17, 31, 14, 13, 12, 18, 0, 16, 21, 15, 19, 27, 17, 12, 14, 13, 0, 13, 16, 10, 13, 23, 14, 15, 17, 14, 0, 13, 17, 11, 19, 24, 17, 9, 16, 13, 0, 18, 13, 11, 20, 30, 20, 11, 13, 16, 0, 10, 16, 11, 17, 24, 17, 14, 13, 13, 0, 14, 18, 16, 16, 21, 22, 11, 15, 14, 0, 7, 11, 14, 14, 28, 18, 13, 13, 18, 0, 11, 11, 13, 14, 15, 8, 13, 12, 15, 0, 14, 15, 13, 16, 24, 17, 12, 14, 11, 0, 11, 14, 13, 11, 29, 16, 14, 14, 15, 0, 14, 14, 11, 22, 25, 19, 11, 16, 13, 0, 17, 6, 18, 9, 16, 12, 10, 12, 12, 0, 13, 13, 11, 18, 18, 18, 14, 7, 7, 0, 14, 15, 18, 17, 31, 21, 13, 15, 12, 0, 10, 10, 13, 16, 27, 20, 12, 15, 11, 0, 16, 19, 13, 21, 14, 18, 13, 9, 17, 0, 12, 19, 14, 13, 33, 18, 13, 16, 16, 0, 14, 18, 14, 16, 24, 14, 15, 19, 14, 0, 15, 13, 16, 21, 189, 16, 13, 13, 14, 0, 13, 9, 13, 21, 23, 15, 12, 22, 10, 0, 14, 17, 15, 17, 14, 8, 13, 12, 13, 0, 16, 14, 12, 16, 33, 15, 12, 14, 13, 0, 8, 21, 14, 12, 9, 13, 14, 16, 13, 0, 14, 11, 10, 15, 27, 20, 14, 19, 10, 0, 12, 13, 16, 19, 21, 14, 14, 22, 13, 0, 11, 18, 10, 13, 7, 16, 11, 13, 14, 0, 16, 14, 13, 18, 17, 16, 10, 14, 11, 0, 13, 36, 12, 18, 18, 18, 9, 17, 11, 0, 14, 14, 8, 14, 32, 21, 11, 16, 13, 0, 10, 18, 11, 16, 23, 19, 10, 12, 13, 0, 14, 14, 11, 16, 24, 16, 18, 14, 15, 0, 11, 16, 13, 14, 14, 20, 11, 14, 15, 0, 13, 8, 13, 10, 41, 22, 16, 23, 8, 0, 11, 17, 12, 20, 30, 15, 10, 14, 11, 0, 10, 19, 16, 13, 24, 20, 11, 11, 14, 0, 10, 12, 11, 16, 22, 19, 13, 20, 13, 0, 16, 13, 13, 12, 27, 10, 14, 13, 17, 0, 14, 16, 14, 22, 23, 20, 15, 20, 12, 0, 11, 17, 16, 12, 19, 17, 18, 16, 11, 0, 8, 8, 15, 18, 28, 15, 10, 14, 13, 0, 15, 10, 13, 10, 23, 18, 13, 19, 12, 0, 12, 15, 15, 14, 24, 22, 13, 14, 14, 0, 14, 19, 18, 19, 21, 19, 12, 16, 11, 0, 17, 12, 11, 13, 33, 11, 15, 14, 12, 0, 15, 18, 14, 12, 26, 14, 16, 12, 16, 0, 13, 21, 15, 23, 21, 20, 14, 18, 13, 0, 13, 19, 13, 13, 29, 17, 12, 13, 17, 0, 15, 18, 15, 13, 24, 16, 15, 18, 13, 0, 13, 15, 16, 17, 15, 21, 13, 13, 16, 0, 14, 19, 13, 13, 30, 8, 13, 16, 13, 0, 10, 9, 16, 22, 32, 21, 15, 12, 14, 0, 13, 9, 12, 15, 21, 12, 14, 14, 16, 0, 14, 19, 13, 20, 24, 14, 14, 14, 12, 0, 12, 19, 14, 14, 33, 8, 10, 15, 16, 0, 13, 22, 9, 17, 32, 18, 13, 9, 11, 0, 13, 13, 13, 19, 33, 12, 13, 22, 15, 0, 17, 12, 17, 14, 27, 19, 14, 16, 11, 0, 15, 14, 14, 19, 33, 7, 12, 14, 15, 0, 16, 14, 12, 11, 28, 22, 13, 9, 11, 0, 12, 11, 13, 18, 21, 22, 15, 15, 10, 0, 13, 7, 12, 16, 29, 20, 17, 13, 12, 0, 14, 7, 14, 14, 32, 18, 15, 17, 17, 0, 11, 18, 13, 16, 25, 12, 13, 14, 11, 0, 16, 14, 14, 17, 15, 14, 7, 19, 15, 0, 11, 14, 15, 9, 17, 15, 13, 12, 14, 0, 9, 9, 16, 23, 30, 10, 13, 12, 13, 0, 13, 18, 9, 21, 15, 19, 13, 19, 13, 0, 11, 15, 14, 17, 24, 9, 13, 17, 15, 0, 12, 16, 14, 16, 28, 13, 11, 12, 10, 0, 16, 19, 13, 9, 29, 14, 14, 17, 12, 0, 13, 15, 9, 13, 19, 9, 11, 15, 14, 0, 15, 9, 13, 13, 24, 19, 13, 18, 9, 0, 13, 14, 12, 18, 27, 19, 13, 18, 12, 0, 13, 15, 13, 14, 37, 14, 15, 15, 16, 0, 15, 21, 16, 20, 27, 18, 11, 17, 15, 0, 16, 19, 16, 22, 27, 12, 19, 30, 13, 0, 18, 8, 10, 20, 20, 18, 13, 12, 14, 0, 15, 19, 12, 14, 18, 22, 14, 16, 11, 0, 15, 19, 7, 14, 37, 16, 13, 17, 11, 0, 9, 22, 14, 13, 15, 17, 11, 11, 16, 0, 10, 21, 13, 14, 26, 13, 12, 22, 14, 0, 18, 14, 12, 28, 26, 14, 13, 8, 15, 0, 15, 19, 12, 20, 20, 16, 9, 15, 13, 0, 17, 12, 16, 18, 36, 18, 10, 18, 13, 0, 14, 15, 13, 19, 24, 10, 15, 14, 15, 0, 14, 20, 10, 18, 20, 16, 13, 17, 14, 0, 6, 17, 16, 12, 26, 13, 14, 12, 10, 0, 12, 18, 12, 19, 21, 17, 14, 14, 16, 0, 16, 21, 12, 13, 12, 18, 11, 19, 13, 0, 8, 16, 14, 17, 25, 19, 8, 18, 6, 0, 11, 13, 13, 18, 27, 11, 16, 18, 10, 0, 14, 14, 14, 18, 24, 18, 9, 19, 13, 0, 17, 20, 13, 11, 38, 11, 15, 15, 12, 0, 15, 14, 6, 19, 35, 15, 17, 22, 12, 0, 9, 20, 16, 14, 38, 6, 6, 14, 8, 0, 10, 18, 14, 11, 27, 13, 13, 17, 9, 0, 18, 6, 13, 16, 29, 16, 15, 22, 14, 0, 17, 11, 12, 14, 24, 15, 15, 18, 8, 0, 13, 18, 10, 25, 35, 14, 15, 13, 14, 0, 15, 11, 9, 18, 15, 18, 11, 15, 8, 0, 13, 15, 11, 11, 25, 15, 14, 12, 14, 0, 13, 14, 11, 21, 27, 19, 14, 19, 13, 0, 17, 19, 13, 18, 25, 19, 15, 14, 15, 0, 16, 16, 12, 18, 14, 19, 14, 11, 11, 0, 17, 15, 18, 16, 25, 13, 12, 20, 10, 0, 12, 19, 8, 8, 53, 13, 12, 11, 13, 0, 11, 17, 13, 13, 14, 12, 13, 11, 14, 0, 18, 13, 8, 18, 17, 19, 14, 17, 13, 0, 16, 20, 11, 11, 52, 19, 12, 18, 19, 0, 13, 15, 15, 14, 26, 14, 11, 15, 12, 0, 15, 17, 13, 14, 15, 13, 12, 13, 14, 0, 18, 6, 14, 17, 29, 12, 13, 14, 14, 0, 13, 13, 13, 17, 20, 19, 19, 11, 14, 0, 16, 8, 17, 14, 18, 15, 7, 14, 12, 0, 14, 17, 11, 13, 21, 21, 14, 17, 9, 0, 12, 15, 12, 14, 25, 15, 13, 19, 10, 0, 14, 16, 12, 19, 38, 16, 14, 18, 19, 0, 9, 13, 13, 15, 21, 18, 12, 18, 15, 0, 14, 19, 16, 12, 32, 10, 8, 14, 16, 0, 14, 17, 14, 13, 17, 15, 13, 18, 13, 0, 15, 17, 14, 15, 18, 21, 15, 15, 9, 0, 14, 15, 13, 15, 31, 13, 9, 12, 9, 0, 18, 20, 17, 19, 17, 13, 16, 17, 15, 0, 14, 15, 15, 19, 115, 12, 13, 19, 16, 0, 12, 18, 12, 13, 25, 18, 14, 13, 13, 0, 10, 19, 13, 14, 24, 8, 12, 18, 13, 0, 16, 18, 9, 13, 15, 17, 15, 15, 18, 0, 14, 11, 10, 21, 30, 18, 11, 17, 13, 0, 13, 17, 16, 15, 33, 19, 11, 21, 7, 0, 15, 15, 12, 19, 61, 9, 10, 11, 13, 0, 17, 18, 12, 21, 21, 13, 14, 14, 13, 0, 10, 13, 14, 13, 20, 5, 13, 16, 8, 0, 11, 11, 11, 15, 21, 11, 15, 12, 14, 0, 11, 12, 13, 14, 33, 19, 17, 7, 15, 0, 9, 21, 11, 17, 25, 18, 12, 15, 16, 0, 8, 13, 13, 12, 18, 23, 14, 16, 17, 0, 13, 17, 10, 15, 32, 18, 8, 13, 13, 0, 15, 17, 11, 19, 28, 13, 7, 21, 12, 0, 10, 14, 17, 9, 52, 13, 19, 13, 7, 0, 13, 12, 15, 18, 26, 13, 13, 18, 14, 0, 18, 13, 11, 17, 14, 14, 8, 16, 16, 0, 17, 17, 8, 19, 21, 20, 8, 19, 10, 0, 16, 19, 16, 14, 18, 19, 10, 12, 16, 0, 16, 20, 13, 12, 33, 19, 14, 14, 9, 0, 13, 14, 12, 19, 32, 20, 17, 14, 14, 0, 13, 18, 8, 15, 30, 11, 14, 16, 12, 0, 11, 12, 13, 19, 32, 15, 12, 9, 13, 0, 14, 17, 14, 18, 26, 10, 11, 20, 17, 0, 14, 17, 17, 13, 22, 15, 13, 17, 11, 0, 11, 16, 13, 14, 30, 20, 14, 15, 17, 0, 10, 14, 11, 14, 29, 14, 13, 12, 14, 0, 14, 18, 17, 21, 22, 17, 9, 21, 14, 0, 11, 13, 10, 19, 28, 16, 8, 15, 15, 0, 11, 21, 10, 15, 32, 13, 9, 14, 11, 0, 12, 17, 14, 21, 29, 10, 11, 17, 15, 0, 17, 16, 11, 19, 34, 17, 14, 23, 13, 0, 12, 19, 8, 12, 21, 18, 17, 11, 11, 0, 19, 12, 13, 18, 23, 18, 13, 16, 11, 0, 11, 13, 13, 10, 28, 13, 13, 11, 13, 0, 8, 16, 14, 12, 27, 15, 15, 17, 14, 0, 17, 21, 14, 21, 28, 18, 13, 19, 17, 0, 17, 15, 13, 14, 25, 19, 13, 18, 12, 0, 17, 22, 12, 18, 22, 16, 8, 11, 14, 0, 12, 15, 12, 14, 23, 14, 16, 12, 13, 0, 16, 9, 14, 18, 18, 18, 11, 15, 13, 0, 11, 16, 11, 12, 29, 23, 13, 14, 14, 0, 15, 19, 12, 14, 38, 14, 13, 17, 16, 0, 12, 7, 16, 19, 24, 13, 14, 13, 14, 0, 9, 19, 12, 11, 38, 17, 17, 20, 15, 0, 13, 17, 12, 20, 31, 15, 16, 17, 15, 0, 14, 14, 13, 18, 17, 11, 13, 19, 13, 0, 16, 13, 17, 19, 34, 15, 13, 19, 9, 0, 13, 13, 14, 17, 17, 14, 7, 17, 15, 0, 17, 20, 14, 14, 24, 22, 14, 13, 21, 0, 15, 19, 12, 14, 21, 15, 7, 14, 13, 0, 12, 33, 18, 17, 16, 15, 14, 18, 11, 0, 13, 23, 12, 8, 24, 14, 13, 9, 11, 0, 7, 16, 8, 10, 21, 12, 15, 17, 19, 0, 7, 19, 11, 30, 33, 13, 10, 8, 13, 0, 16, 13, 20, 8, 23, 13, 10, 18, 13, 0, 18, 14, 13, 8, 35, 13, 8, 12, 11, 0, 13, 19, 13, 19, 23, 25, 11, 21, 9, 0, 14, 9, 13, 15, 34, 19, 14, 14, 15, 0, 13, 19, 10, 17, 35, 14, 17, 22, 17, 0, 14, 17, 17, 14, 17, 10, 13, 24, 17, 0, 13, 16, 11, 16, 25, 13, 18, 13, 13, 0, 12, 21, 15, 16, 26, 18, 14, 17, 12, 0, 5, 5, 5, 5, 5, 13, 8, 20, 12, 0, 5, 5, 12, 18, 23, 17, 9, 13, 8, 0, 5, 14, 13, 13, 27, 12, 14, 32, 13, 0, 5, 19, 14, 14, 18, 21, 7, 13, 14, 0, 5, 13, 14, 13, 25, 9, 13, 18, 12, 0, 17, 8, 14, 41, 30, 17, 11, 21, 11, 0, 13, 15, 11, 17, 40, 10, 13, 18, 16, 0, 14, 13, 17, 12, 19, 14, 12, 18, 13, 0, 11, 10, 15, 17, 29, 16, 14, 16, 12, 0, 12, 19, 11, 20, 24, 20, 12, 14, 17, 0, 5, 5, 9, 16, 30, 16, 9, 21, 17, 0, 5, 14, 14, 13, 35, 17, 15, 18, 11, 0, 13, 12, 11, 19, 23, 17, 7, 17, 13, 0, 15, 17, 13, 17, 25, 13, 8, 21, 13, 0, 17, 13, 14, 15, 26, 19, 10, 16, 17, 0, 10, 11, 12, 22, 30, 14, 13, 15, 10, 0, 10, 15, 14, 10, 53, 14, 14, 14, 10, 0, 12, 12, 18, 11, 35, 12, 14, 15, 9, 0, 13, 19, 13, 21, 24, 11, 14, 20, 14, 0, 14, 9, 13, 12, 24, 13, 12, 18, 7, 0, 5, 22, 17, 20, 26, 11, 18, 19, 14, 0, 13, 9, 13, 12, 29, 9, 15, 15, 16, 0, 11, 18, 18, 11, 27, 14, 14, 8, 13, 0, 13, 16, 13, 19, 21, 14, 9, 13, 18, 0, 14, 18, 9, 16, 25, 12, 11, 19, 13, 0, 12, 14, 9, 18, 25, 15, 14, 12, 9, 0, 14, 13, 12, 19, 21, 26, 16, 12, 10, 0, 19, 21, 13, 13, 36, 17, 18, 15, 11, 0, 11, 18, 12, 14, 24, 14, 17, 9, 16, 0, 19, 20, 13, 17, 21, 7, 13, 18, 8, 0, 5, 12, 11, 17, 26, 14, 13, 19, 14, 0, 16, 18, 7, 20, 34, 19, 13, 8, 14, 0, 15, 13, 11, 14, 22, 14, 15, 20, 17, 0, 14, 11, 14, 9, 24, 18, 11, 15, 13, 0, 13, 16, 15, 14, 17, 16, 15, 11, 15, 0, 12, 13, 15, 15, 28, 15, 12, 19, 9, 0, 13, 14, 16, 21, 33, 13, 11, 22, 16, 0, 9, 20, 13, 16, 24, 13, 16, 16, 9, 0, 12, 21, 10, 14, 26, 20, 17, 11, 14, 0, 19, 21, 14, 30, 34, 14, 16, 13, 13, 0, 5, 14, 13, 13, 14, 18, 11, 7, 11, 0, 14, 18, 17, 16, 27, 18, 12, 13, 10, 0, 13, 13, 10, 9, 27, 21, 11, 16, 13, 0, 17, 7, 14, 13, 26, 13, 10, 12, 13, 0, 10, 9, 11, 18, 30, 18, 17, 17, 10, 0, 14, 19, 10, 14, 27, 12, 13, 18, 12, 0, 9, 11, 13, 14, 8, 13, 15, 12, 11, 0, 11, 13, 12, 18, 14, 19, 16, 8, 10, 0, 13, 8, 18, 11, 23, 12, 14, 12, 15, 0, 14, 17, 14, 12, 23, 15, 9, 16, 10, 0, 17, 18, 12, 12, 34, 24, 14, 22, 14, 0, 16, 14, 16, 14, 19, 13, 7, 12, 17, 0, 14, 26, 15, 13, 27, 13, 18, 18, 11, 0, 16, 18, 16, 7, 69, 16, 17, 14, 11, 0, 16, 8, 8, 12, 17, 9, 17, 17, 17, 0, 13, 11, 18, 26, 18, 17, 17, 18, 16, 0, 10, 13, 16, 19, 13, 14, 18, 12, 15, 0, 13, 14, 16, 12, 19, 9, 16, 14, 11, 0, 12, 19, 11, 14, 25, 17, 8, 17, 13, 0, 19, 13, 11, 13, 30, 14, 13, 14, 15, 0, 14, 17, 16, 19, 25, 15, 13, 12, 14, 0, 14, 19, 13, 21, 32, 13, 8, 29, 12, 0, 17, 14, 15, 20, 29, 12, 18, 14, 14, 0, 9, 17, 14, 14, 31, 16, 12, 17, 11, 0, 9, 11, 13, 19, 25, 17, 14, 11, 13, 0, 14, 20, 17, 17, 18, 19, 12, 16, 11, 0, 13, 16, 17, 18, 33, 17, 7, 21, 14, 0, 14, 14, 8, 14, 26, 13, 14, 14, 13, 0, 7, 18, 14, 19, 27, 14, 16, 14, 13, 0, 14, 23, 12, 12, 17, 20, 13, 14, 8, 0, 11, 13, 18, 16, 19, 13, 15, 15, 14, 0, 19, 19, 14, 14, 30, 19, 16, 20, 13, 0, 11, 8, 9, 20, 34, 13, 12, 15, 11, 0, 16, 15, 13, 14, 23, 18, 10, 14, 8, 0, 15, 6, 18, 19, 24, 21, 16, 18, 8, 0, 13, 14, 12, 17, 22, 18, 8, 18, 16, 0, 17, 18, 14, 21, 144, 17, 14, 17, 12, 0, 14, 11, 13, 18, 22, 14, 10, 14, 18, 0, 13, 10, 13, 19, 26, 13, 12, 22, 13, 0, 13, 9, 11, 13, 30, 13, 11, 17, 11, 0, 12, 13, 11, 20, 29, 8, 10, 15, 12, 0, 11, 13, 8, 11, 26, 18, 16, 13, 17, 0, 13, 14, 13, 16, 17, 19, 15, 17, 16, 0, 19, 13, 16, 20, 33, 15, 16, 13, 17, 0, 17, 19, 11, 14, 27, 19, 13, 16, 13, 0, 9, 19, 11, 14, 23, 19, 13, 14, 13, 0, 14, 17, 16, 17, 35, 14, 11, 47, 14, 0, 13, 19, 16, 21, 30, 19, 10, 13, 18, 0, 16, 15, 13, 17, 13, 14, 13, 15, 9, 0, 13, 16, 15, 16, 21, 14, 10, 8, 14, 0, 14, 13, 14, 21, 38, 21, 16, 13, 13, 0, 10, 12, 14, 15, 23, 18, 13, 15, 14, 0, 10, 14, 11, 16, 30, 19, 11, 13, 15, 0, 13, 18, 15, 14, 30, 12, 14, 21, 17, 0, 14, 19, 16, 16, 30, 10, 13, 15, 11, 0, 7, 14, 15, 19, 33, 20, 12, 14, 17, 0, 17, 18, 16, 15, 29, 17, 13, 19, 12, 0, 13, 19, 15, 17, 18, 21, 17, 12, 13, 0, 17, 16, 15, 15, 29, 20, 16, 16, 11, 0, 13, 20, 16, 14, 17, 19, 14, 14, 13, 0, 5, 5, 9, 19, 32, 16, 16, 16, 9, 0, 5, 13, 10, 14, 30, 18, 18, 14, 10, 0, 18, 15, 12, 13, 25, 15, 12, 17, 10, 0, 15, 15, 13, 26, 23, 19, 14, 19, 13, 0, 12, 17, 15, 14, 15, 21, 12, 20, 16, 0, 11, 21, 15, 13, 34, 16, 13, 11, 14, 0, 15, 17, 16, 14, 31, 13, 17, 14, 13, 0, 16, 12, 13, 15, 29, 21, 13, 16, 12, 0, 10, 15, 15, 13, 24, 18, 14, 18, 19, 0, 11, 11, 13, 13, 25, 16, 7, 28, 14, 0, 5, 13, 11, 15, 21, 19, 16, 15, 16, 0, 19, 30, 6, 19, 6, 14, 11, 18, 12, 0, 12, 17, 17, 17, 17, 14, 17, 12, 12, 0, 11, 14, 6, 13, 16, 18, 13, 13, 16, 0, 11, 18, 13, 16, 21, 15, 13, 21, 13, 0, 13, 17, 17, 14, 28, 14, 8, 16, 8, 0, 15, 28, 15, 17, 45, 16, 14, 13, 11, 0, 11, 15, 12, 13, 29, 19, 8, 13, 8, 0, 15, 15, 10, 15, 30, 11, 12, 14, 12, 0, 14, 13, 17, 21, 26, 16, 11, 18, 15, 0, 14, 17, 16, 17, 21, 15, 10, 17, 10, 0, 12, 19, 13, 19, 33, 18, 13, 9, 11, 0, 14, 15, 14, 19, 26, 23, 17, 27, 13, 0, 10, 18, 7, 14, 21, 20, 13, 9, 18, 0, 16, 17, 8, 15, 22, 20, 15, 11, 12, 0, 13, 11, 13, 19, 21, 16, 13, 26, 10, 0, 12, 9, 12, 29, 17, 15, 16, 19, 11, 0, 14, 16, 13, 20, 38, 16, 12, 12, 8, 0, 15, 13, 11, 16, 23, 11, 15, 14, 8, 0, 16, 15, 17, 14, 19, 21, 14, 11, 11, 0, 19, 16, 16, 23, 17, 9, 12, 11, 14, 0, 11, 8, 6, 14, 35, 18, 17, 7, 12, 0, 15, 11, 18, 10, 26, 22, 11, 13, 12, 0, 14, 16, 16, 13, 24, 21, 12, 14, 13, 0, 18, 11, 13, 17, 29, 17, 16, 18, 11, 0, 10, 12, 15, 20, 19, 18, 13, 17, 11, 0, 12, 12, 12, 18, 22, 18, 12, 18, 13, 0, 15, 14, 10, 12, 26, 21, 16, 15, 13, 0, 11, 12, 13, 18, 18, 22, 15, 20, 10, 0, 16, 16, 13, 16, 21, 9, 16, 13, 9, 0, 18, 19, 18, 19, 27, 15, 17, 21, 10, 0, 14, 18, 17, 17, 22, 14, 13, 56, 8, 0, 16, 11, 12, 16, 24, 13, 14, 15, 13, 0, 17, 13, 15, 9, 30, 18, 11, 15, 10, 0, 13, 17, 12, 18, 24, 18, 13, 20, 15, 0, 14, 18, 13, 12, 21, 20, 17, 17, 11, 0, 7, 13, 13, 17, 29, 19, 11, 10, 10, 0, 13, 24, 12, 17, 26, 8, 11, 16, 14, 0, 12, 13, 14, 18, 24, 16, 15, 20, 13, 0, 13, 22, 11, 18, 34, 12, 12, 14, 12, 0, 14, 19, 13, 21, 20, 17, 13, 22, 14, 0, 12, 20, 13, 16, 19, 21, 11, 12, 16, 0, 8, 8, 13, 19, 29, 18, 17, 14, 9, 0, 13, 19, 9, 14, 29, 12, 13, 14, 15, 0, 16, 14, 13, 15, 28, 11, 6, 17, 10, 0, 14, 13, 9, 12, 27, 13, 11, 12, 10, 0, 13, 19, 12, 17, 32, 7, 15, 7, 7, 0, 17, 19, 12, 16, 17, 16, 12, 7, 13, 0, 16, 17, 16, 20, 29, 16, 15, 13, 10, 0, 19, 19, 19, 13, 13, 17, 14, 17, 14, 0, 16, 16, 18, 13, 34, 14, 9, 22, 14, 0, 15, 15, 15, 9, 116, 12, 10, 14, 16, 0, 14, 12, 18, 13, 20, 25, 7, 18, 7, 0, 13, 13, 13, 14, 14, 19, 16, 11, 13, 0, 11, 14, 13, 12, 61, 12, 13, 18, 14, 0, 13, 20, 15, 32, 25, 11, 15, 18, 17, 0, 13, 13, 16, 22, 36, 14, 9, 20, 12, 0, 16, 19, 11, 27, 18, 20, 14, 20, 18, 0, 14, 60, 12, 13, 26, 13, 15, 18, 15, 0, 13, 19, 14, 17, 20, 20, 14, 13, 18, 0, 13, 14, 15, 19, 27, 15, 16, 17, 17, 0, 15, 17, 15, 14, 36, 12, 15, 19, 19, 0, 15, 11, 13, 12, 26, 8, 13, 18, 7, 0, 12, 11, 9, 19, 21, 15, 12, 21, 13, 0, 15, 17, 16, 17, 28, 15, 17, 17, 12, 0, 8, 18, 12, 17, 14, 8, 18, 19, 13, 0, 14, 14, 14, 11, 23, 17, 15, 13, 14, 0, 11, 16, 15, 12, 20, 20, 11, 16, 13, 0, 15, 17, 17, 20, 30, 15, 15, 11, 13, 0, 19, 9, 14, 16, 29, 16, 15, 13, 16, 0, 16, 25, 14, 20, 20, 13, 19, 14, 9, 0, 12, 13, 20, 16, 25, 19, 12, 15, 12, 0, 12, 13, 11, 20, 34, 16, 13, 18, 9, 0, 13, 18, 15, 19, 23, 14, 17, 18, 16, 0, 15, 13, 10, 19, 27, 15, 12, 20, 13, 0, 16, 13, 13, 19, 15, 19, 11, 14, 10, 0, 14, 20, 10, 8, 33, 23, 21, 17, 13, 0, 10, 19, 18, 12, 27, 13, 18, 11, 17, 0, 16, 16, 14, 20, 12, 11, 13, 13, 14, 0, 14, 7, 15, 15, 14, 20, 9, 14, 15, 0, 12, 13, 14, 17, 24, 6, 8, 17, 13, 0, 16, 14, 11, 17, 32, 19, 15, 14, 11, 0, 14, 9, 9, 18, 52, 14, 11, 21, 15, 0, 10, 16, 18, 15, 29, 14, 11, 15, 13, 0, 14, 17, 13, 11, 27, 15, 16, 13, 9, 0, 15, 19, 10, 16, 22, 17, 12, 15, 14, 0, 17, 25, 15, 17, 20, 20, 17, 17, 16, 0, 12, 14, 13, 19, 21, 16, 16, 13, 17, 0, 14, 18, 15, 21, 15, 17, 11, 14, 13, 0, 14, 19, 13, 15, 18, 16, 14, 15, 14, 0, 5, 11, 8, 9, 30, 10, 15, 16, 13, 0, 14, 11, 11, 14, 53, 17, 13, 13, 10, 0, 18, 15, 7, 18, 24, 21, 17, 9, 13, 0, 14, 13, 14, 14, 24, 16, 17, 20, 7, 0, 16, 19, 13, 17, 33, 14, 8, 14, 14, 0, 14, 16, 9, 14, 22, 29, 11, 10, 7, 0, 13, 19, 13, 13, 37, 14, 18, 12, 16, 0, 11, 13, 16, 13, 23, 21, 15, 13, 17, 0, 19, 11, 9, 17, 32, 17, 12, 9, 8, 0, 11, 14, 13, 17, 50, 18, 9, 12, 8, 0, 13, 18, 10, 13, 29, 15, 17, 15, 14, 0, 7, 16, 16, 14, 35, 22, 15, 12, 13, 0, 15, 19, 16, 20, 25, 14, 16, 21, 12, 0, 14, 16, 12, 13, 111, 19, 11, 17, 9, 0, 11, 15, 9, 18, 18, 21, 12, 11, 8, 0, 13, 21, 17, 14, 45, 13, 9, 14, 17, 0, 10, 17, 13, 14, 20, 14, 15, 14, 16, 0, 12, 16, 10, 13, 29, 14, 16, 7, 11, 0, 11, 13, 10, 23, 29, 17, 15, 12, 14, 0, 14, 19, 15, 14, 18, 23, 15, 16, 14, 0, 17, 21, 14, 17, 23, 17, 18, 12, 13, 0, 8, 21, 12, 19, 23, 17, 14, 13, 13, 0, 9, 17, 13, 16, 23, 18, 16, 12, 10, 0, 14, 12, 13, 14, 11, 13, 18, 12, 17, 0, 8, 10, 8, 20, 29, 19, 16, 19, 16, 0, 16, 13, 13, 13, 19, 22, 9, 12, 16, 0, 8, 16, 13, 20, 34, 14, 19, 17, 9, 0, 14, 21, 18, 12, 29, 14, 13, 17, 10, 0, 14, 21, 17, 18, 23, 15, 9, 12, 12, 0, 14, 22, 16, 15, 20, 17, 13, 16, 11, 0, 11, 15, 12, 15, 30, 11, 17, 13, 11, 0, 13, 16, 13, 19, 15, 19, 13, 17, 11, 0, 16, 12, 13, 24, 23, 14, 10, 18, 13, 0, 16, 22, 13, 9, 22, 14, 14, 11, 12, 0, 19, 16, 17, 14, 32, 20, 6, 6, 6, 0, 11, 16, 13, 17, 23, 11, 7, 6, 6, 0, 16, 14, 13, 16, 33, 17, 9, 12, 6, 0, 11, 17, 16, 18, 32, 20, 14, 22, 14, 0, 15, 13, 16, 15, 41, 13, 14, 17, 11, 0, 13, 17, 13, 14, 22, 15, 11, 13, 16, 0, 11, 14, 14, 16, 22, 17, 13, 14, 16, 0, 12, 17, 17, 14, 24, 21, 18, 16, 14, 0, 16, 14, 9, 14, 28, 19, 14, 14, 15, 0, 12, 19, 11, 13, 19, 22, 16, 18, 11, 0, 8, 28, 13, 17, 32, 19, 11, 20, 13, 0, 11, 13, 14, 10, 30, 23, 14, 6, 6, 0, 12, 15, 15, 16, 22, 14, 18, 19, 6, 0, 16, 13, 14, 21, 33, 19, 12, 13, 12, 0, 13, 14, 11, 18, 22, 16, 13, 21, 17, 0, 14, 13, 12, 13, 33, 14, 12, 12, 10, 0, 10, 20, 14, 22, 17, 21, 19, 17, 15, 0, 15, 16, 12, 15, 29, 12, 16, 14, 17, 0, 14, 19, 13, 14, 27, 18, 13, 9, 15, 0, 7, 16, 7, 13, 14, 18, 12, 25, 11, 0, 10, 13, 14, 19, 29, 15, 14, 12, 15, 0, 12, 7, 7, 22, 21, 17, 18, 18, 19, 0, 16, 13, 13, 16, 32, 19, 9, 19, 6, 0, 18, 16, 13, 12, 30, 22, 18, 15, 15, 0, 13, 19, 11, 19, 26, 15, 13, 21, 13, 0, 8, 12, 14, 11, 27, 21, 11, 14, 8, 0, 10, 11, 14, 9, 21, 18, 17, 16, 11, 0, 13, 19, 13, 20, 36, 20, 13, 22, 13, 0, 18, 19, 13, 18, 36, 22, 13, 13, 13, 0, 16, 13, 13, 16, 23, 14, 9, 19, 14, 0, 9, 11, 11, 9, 27, 12, 12, 22, 15, 0, 12, 9, 11, 19, 25, 11, 14, 16, 13, 0, 12, 19, 17, 8, 37, 26, 14, 20, 14, 0, 14, 21, 14, 17, 17, 17, 12, 15, 15, 0, 17, 17, 8, 18, 21, 14, 14, 12, 9, 0, 11, 19, 8, 10, 13, 14, 10, 26, 12, 0, 13, 13, 15, 13, 30, 15, 13, 13, 8, 0, 17, 16, 13, 18, 27, 19, 12, 18, 13, 0, 12, 14, 11, 14, 25, 12, 16, 18, 14, 0, 12, 19, 11, 15, 28, 16, 8, 27, 14, 0, 11, 9, 14, 17, 25, 19, 13, 14, 13, 0, 13, 14, 15, 15, 61, 19, 14, 14, 10, 0, 13, 15, 13, 20, 23, 12, 11, 14, 11, 0, 13, 16, 14, 19, 25, 14, 10, 20, 14, 0, 13, 14, 16, 23, 29, 21, 9, 19, 9, 0, 17, 16, 13, 13, 23, 19, 18, 14, 12, 0, 14, 17, 20, 18, 19, 17, 12, 17, 11, 0, 10, 21, 12, 18, 52, 16, 13, 14, 11, 0, 14, 17, 13, 19, 26, 19, 9, 20, 11, 0, 18, 14, 16, 17, 28, 25, 6, 16, 19, 0, 18, 25, 19, 20, 23, 15, 11, 14, 14, 0, 9, 19, 11, 13, 21, 21, 13, 15, 16, 0, 13, 19, 17, 18, 23, 22, 16, 19, 9, 0, 15, 13, 16, 15, 21, 17, 14, 23, 13, 0, 18, 19, 16, 20, 32, 13, 15, 15, 8, 0, 11, 18, 12, 17, 30, 17, 11, 18, 10, 0, 15, 22, 14, 15, 23, 17, 11, 19, 14, 0, 14, 20, 14, 8, 35, 14, 13, 14, 16, 0, 13, 21, 13, 15, 34, 18, 13, 12, 13, 0, 16, 14, 15, 19, 23, 18, 14, 14, 16, 0, 11, 19, 11, 22, 25, 19, 13, 21, 11, 0, 14, 11, 15, 19, 24, 22, 18, 18, 16, 0, 16, 17, 10, 18, 37, 8, 14, 16, 10, 0, 13, 20, 9, 14, 30, 23, 13, 15, 11, 0, 12, 14, 14, 22, 20, 19, 19, 9, 14, 0, 10, 21, 16, 11, 26, 15, 13, 14, 16, 0, 5, 13, 16, 19, 35, 19, 13, 17, 16, 0, 14, 17, 13, 18, 33, 15, 18, 23, 13, 0, 15, 18, 9, 12, 24, 13, 12, 14, 12, 0, 14, 14, 11, 22, 23, 15, 20, 19, 12, 0, 13, 18, 12, 13, 19, 13, 7, 11, 7, 0, 15, 16, 9, 15, 21, 15, 9, 14, 14, 0, 13, 19, 13, 14, 35, 13, 16, 18, 16, 0, 10, 18, 6, 12, 32, 14, 17, 15, 13, 0, 17, 29, 10, 18, 24, 16, 14, 15, 16, 0, 13, 14, 13, 14, 26, 13, 10, 15, 14, 0, 12, 14, 14, 19, 23, 14, 17, 13, 11, 0, 12, 19, 6, 25, 38, 9, 15, 14, 8, 0, 11, 16, 16, 19, 38, 18, 14, 20, 13, 0, 7, 15, 14, 17, 24, 22, 14, 10, 14, 0, 17, 18, 8, 19, 45, 14, 8, 17, 17, 0, 15, 20, 15, 12, 15, 20, 16, 19, 14, 0, 13, 22, 13, 14, 20, 13, 10, 18, 7, 0, 12, 14, 14, 21, 18, 13, 13, 13, 12, 0, 20, 17, 13, 19, 29, 15, 13, 20, 14, 0, 16, 14, 14, 18, 26, 18, 14, 14, 15, 0, 15, 19, 10, 22, 23, 19, 15, 22, 9, 0, 17, 19, 14, 13, 34, 14, 20, 17, 20, 0, 16, 18, 10, 21, 25, 22, 12, 20, 17, 0, 11, 22, 13, 11, 21, 17, 15, 15, 17, 0, 18, 22, 14, 14, 25, 16, 17, 13, 14, 0, 19, 19, 13, 20, 32, 16, 16, 14, 16, 0, 17, 7, 17, 22, 81, 13, 8, 16, 12, 0, 14, 10, 15, 21, 21, 16, 14, 17, 11, 0, 16, 15, 12, 21, 20, 14, 15, 19, 13, 0, 15, 13, 11, 9, 29, 17, 13, 16, 13, 0, 8, 14, 15, 15, 29, 23, 13, 17, 15, 0, 17, 18, 13, 18, 33, 14, 13, 13, 11, 0, 15, 19, 11, 18, 29, 19, 15, 18, 14, 0, 11, 12, 14, 21, 18, 19, 13, 13, 13, 0, 13, 15, 12, 17, 21, 8, 11, 14, 16, 0, 14, 20, 12, 20, 33, 10, 17, 15, 14, 0, 13, 17, 13, 16, 42, 18, 16, 14, 14, 0, 16, 20, 18, 17, 19, 14, 10, 13, 13, 0, 15, 18, 15, 20, 26, 11, 16, 14, 15, 0, 13, 19, 14, 13, 25, 14, 14, 16, 13, 0, 12, 21, 7, 23, 24, 14, 12, 21, 14, 0, 13, 13, 16, 14, 38, 17, 16, 17, 13, 0, 12, 17, 15, 14, 29, 15, 13, 17, 14, 0, 11, 16, 13, 25, 15, 19, 14, 16, 14, 0, 15, 14, 13, 20, 24, 17, 17, 17, 15, 0, 13, 20, 12, 15, 32, 18, 11, 6, 6, 0, 13, 15, 14, 13, 21, 28, 11, 20, 6, 0, 13, 20, 14, 18, 34, 17, 10, 21, 13, 0, 13, 13, 13, 17, 26, 14, 14, 16, 10, 0, 9, 21, 13, 14, 38, 20, 10, 25, 17, 0, 11, 17, 16, 14, 21, 18, 13, 14, 12, 0, 13, 20, 15, 22, 33, 17, 8, 8, 15, 0, 12, 14, 13, 16, 23, 17, 13, 16, 12, 0, 14, 13, 12, 12, 13, 20, 11, 16, 11, 0, 13, 24, 16, 17, 21, 20, 16, 14, 14, 0, 8, 18, 13, 14, 22, 22, 14, 13, 12, 0, 11, 22, 12, 14, 26, 14, 14, 22, 6, 0, 8, 18, 19, 14, 24, 19, 14, 16, 17, 0, 16, 12, 14, 15, 34, 14, 15, 21, 13, 0, 16, 19, 12, 18, 29, 18, 16, 17, 13, 0, 13, 13, 14, 21, 10, 15, 14, 20, 15, 0, 13, 22, 14, 14, 33, 14, 11, 12, 12, 0, 15, 14, 12, 17, 15, 9, 14, 7, 7, 0, 12, 13, 14, 13, 36, 23, 16, 19, 10, 0, 15, 18, 8, 13, 15, 20, 16, 16, 14, 0, 18, 19, 10, 10, 24, 10, 14, 29, 15, 0, 9, 14, 16, 17, 35, 13, 21, 21, 13, 0, 18, 21, 13, 16, 24, 20, 16, 11, 13, 0, 14, 17, 16, 13, 29, 19, 13, 15, 11, 0, 18, 14, 15, 15, 32, 16, 16, 8, 10, 0, 10, 15, 14, 19, 27, 19, 13, 9, 10, 0, 17, 13, 15, 16, 29, 17, 8, 11, 10, 0, 13, 12, 17, 21, 16, 19, 13, 18, 7, 0, 11, 17, 9, 13, 20, 9, 17, 14, 13, 0, 14, 17, 15, 19, 34, 19, 12, 14, 11, 0, 8, 12, 16, 19, 28, 12, 14, 13, 15, 0, 12, 14, 14, 20, 20, 21, 12, 21, 11, 0, 13, 19, 15, 13, 29, 15, 11, 15, 14, 0, 14, 14, 16, 13, 24, 24, 9, 17, 13, 0, 14, 21, 14, 16, 16, 13, 11, 11, 17, 0, 15, 13, 16, 10, 34, 14, 15, 14, 17, 0, 13, 21, 13, 9, 16, 18, 19, 26, 14, 0, 11, 30, 13, 13, 30, 15, 14, 19, 13, 0, 9, 18, 15, 19, 26, 18, 12, 13, 14, 0, 14, 15, 16, 19, 31, 16, 14, 21, 10, 0, 11, 17, 19, 15, 14, 21, 16, 10, 16, 0, 9, 15, 15, 14, 204, 18, 15, 14, 17, 0, 13, 12, 14, 14, 27, 18, 9, 17, 14, 0, 13, 19, 14, 17, 34, 14, 15, 23, 14, 0, 19, 20, 16, 16, 29, 17, 13, 22, 18, 0, 12, 17, 14, 19, 32, 13, 13, 18, 17, 0, 9, 15, 8, 20, 90, 15, 13, 20, 13, 0, 10, 15, 16, 23, 29, 14, 16, 20, 14, 0, 18, 13, 15, 11, 21, 16, 13, 8, 9, 0, 14, 17, 13, 18, 19, 22, 13, 19, 13, 0, 13, 19, 15, 13, 21, 21, 14, 13, 9, 0, 8, 19, 19, 21, 25, 15, 17, 18, 16, 0, 17, 18, 13, 8, 20, 11, 16, 15, 14, 0, 12, 14, 13, 10, 23, 18, 17, 16, 14, 0, 13, 18, 15, 19, 30, 23, 10, 12, 16, 0, 5, 10, 15, 19, 30, 13, 9, 10, 14, 0, 9, 19, 17, 14, 23, 16, 16, 21, 13, 0, 15, 14, 14, 13, 23, 18, 14, 13, 14, 0, 14, 16, 16, 12, 26, 14, 11, 13, 14, 0, 15, 25, 14, 20, 21, 9, 12, 14, 8, 0, 13, 20, 9, 14, 24, 12, 11, 17, 17, 0, 12, 15, 17, 19, 35, 14, 12, 21, 12, 0, 11, 13, 14, 28, 29, 14, 14, 17, 10, 0, 14, 16, 17, 17, 20, 16, 13, 19, 17, 0, 11, 13, 15, 14, 28, 18, 13, 13, 9, 0, 13, 14, 14, 23, 23, 19, 13, 20, 11, 0, 15, 19, 13, 17, 30, 14, 20, 17, 14, 0, 18, 15, 11, 19, 24, 14, 14, 22, 13, 0, 18, 9, 10, 12, 28, 18, 16, 19, 16, 0, 13, 21, 7, 14, 24, 14, 14, 16, 12, 0, 16, 14, 13, 22, 15, 17, 10, 14, 13, 0, 17, 14, 16, 17, 21, 11, 14, 18, 16, 0, 9, 17, 16, 15, 24, 13, 17, 14, 16, 0, 14, 15, 15, 19, 25, 11, 14, 7, 19, 0, 8, 17, 14, 17, 21, 18, 13, 14, 12, 0, 14, 14, 10, 19, 25, 17, 14, 13, 13, 0, 12, 16, 18, 17, 31, 13, 14, 21, 15, 0, 14, 17, 13, 16, 29, 14, 13, 11, 12, 0, 9, 18, 11, 30, 38, 15, 16, 11, 15, 0, 12, 14, 13, 14, 32, 14, 14, 20, 14, 0, 17, 20, 9, 16, 26, 16, 16, 15, 18, 0, 13, 13, 10, 12, 12, 23, 14, 17, 14, 0, 13, 17, 14, 18, 24, 9, 17, 19, 13, 0, 18, 15, 12, 19, 26, 13, 11, 21, 16, 0, 13, 23, 11, 17, 13, 15, 14, 25, 16, 0, 17, 19, 9, 13, 30, 13, 14, 22, 11, 0, 16, 13, 13, 18, 30, 8, 14, 13, 14, 0, 12, 13, 11, 14, 33, 19, 14, 18, 19, 0, 16, 20, 12, 18, 25, 18, 11, 16, 8, 0, 10, 13, 19, 13, 29, 25, 18, 21, 19, 0, 14, 12, 6, 13, 27, 16, 14, 19, 18, 0, 14, 10, 17, 27, 33, 14, 14, 15, 11, 0, 11, 19, 14, 18, 23, 21, 11, 22, 14, 0, 14, 16, 17, 17, 27, 16, 13, 8, 14, 0, 16, 17, 14, 21, 28, 21, 16, 8, 9, 0, 14, 17, 15, 16, 29, 9, 15, 15, 13, 0, 10, 19, 15, 13, 23, 19, 13, 17, 16, 0, 14, 12, 12, 19, 21, 15, 13, 19, 15, 0, 12, 13, 14, 15, 26, 14, 15, 17, 14, 0, 13, 17, 12, 20, 25, 5, 17, 14, 19, 0, 13, 17, 13, 10, 30, 18, 19, 14, 13, 0, 18, 13, 11, 14, 34, 17, 16, 22, 11, 0, 17, 19, 12, 9, 25, 19, 13, 17, 17, 0, 14, 10, 11, 15, 24, 14, 12, 11, 13, 0, 11, 22, 11, 17, 29, 21, 8, 9, 15, 0, 16, 14, 9, 22, 19, 20, 18, 17, 13, 0, 11, 19, 13, 16, 84, 18, 20, 13, 7, 0, 12, 22, 19, 12, 26, 20, 18, 19, 13, 0, 14, 18, 9, 17, 20, 19, 12, 19, 11, 0, 13, 19, 15, 16, 24, 16, 12, 21, 13, 0, 8, 17, 15, 20, 34, 12, 9, 20, 12, 0, 16, 14, 18, 14, 26, 21, 13, 14, 6, 0, 13, 16, 13, 13, 27, 21, 13, 12, 7, 0, 13, 16, 10, 20, 20, 11, 10, 14, 11, 0, 11, 15, 15, 13, 33, 24, 8, 21, 16, 0, 16, 16, 20, 21, 38, 10, 12, 14, 17, 0, 12, 13, 16, 16, 37, 19, 11, 20, 16, 0, 12, 16, 13, 14, 19, 11, 17, 19, 16, 0, 13, 12, 14, 22, 52, 14, 13, 16, 13, 0, 15, 12, 11, 20, 40, 16, 14, 14, 18, 0, 13, 23, 14, 17, 29, 19, 14, 10, 13, 0, 13, 14, 14, 16, 36, 22, 15, 17, 13, 0, 8, 20, 11, 11, 30, 19, 16, 17, 18, 0, 14, 22, 16, 15, 20, 21, 17, 12, 13, 0, 17, 17, 13, 18, 14, 19, 16, 14, 16, 0, 13, 13, 13, 19, 21, 16, 19, 14, 17, 0, 13, 19, 15, 11, 34, 19, 11, 16, 14, 0, 15, 16, 14, 20, 19, 17, 15, 19, 14, 0, 8, 17, 13, 15, 23, 16, 7, 14, 14, 0, 15, 11, 20, 17, 27, 27, 14, 14, 11, 0, 12, 23, 8, 9, 29, 19, 12, 18, 14, 0, 8, 13, 6, 20, 21, 12, 7, 12, 10, 0, 12, 13, 14, 22, 25, 16, 7, 18, 11, 0, 16, 13, 13, 18, 22, 13, 12, 16, 17, 0, 15, 13, 14, 12, 28, 14, 15, 14, 13, 0, 19, 13, 9, 13, 14, 18, 7, 19, 10, 0, 17, 19, 17, 15, 38, 6, 15, 8, 13, 0, 13, 13, 18, 19, 50, 8, 18, 14, 14, 0, 9, 13, 15, 16, 23, 13, 14, 20, 8, 0, 14, 26, 16, 21, 26, 14, 9, 23, 14, 0, 16, 19, 17, 16, 21, 16, 8, 12, 15, 0, 12, 17, 12, 22, 37, 13, 13, 13, 13, 0, 16, 18, 13, 21, 14, 15, 10, 16, 9, 0, 15, 20, 13, 17, 18, 17, 17, 16, 14, 0, 10, 14, 18, 13, 21, 21, 12, 15, 16, 0, 16, 11, 16, 19, 32, 36, 13, 19, 11, 0, 11, 15, 8, 16, 26, 12, 15, 13, 13, 0, 8, 25, 12, 9, 23, 18, 13, 19, 14, 0, 9, 12, 14, 18, 21, 14, 15, 19, 12, 0, 15, 18, 15, 8, 29, 14, 13, 9, 15, 0, 17, 16, 13, 14, 30, 18, 13, 14, 16, 0, 18, 14, 14, 16, 14, 11, 7, 21, 13, 0, 9, 22, 16, 16, 61, 21, 14, 13, 19, 0, 19, 12, 9, 15, 22, 21, 16, 20, 18, 0, 11, 16, 19, 14, 23, 14, 18, 15, 14, 0, 15, 13, 14, 18, 26, 11, 16, 19, 10, 0, 13, 19, 16, 19, 32, 18, 13, 22, 14, 0, 14, 18, 12, 19, 26, 13, 12, 17, 16, 0, 14, 14, 18, 27, 21, 16, 16, 19, 14, 0, 13, 19, 11, 20, 27, 11, 12, 18, 12, 0, 14, 17, 13, 15, 24, 22, 14, 17, 7, 0, 16, 21, 9, 12, 35, 21, 20, 23, 11, 0, 14, 18, 15, 14, 34, 19, 19, 12, 18, 0, 12, 18, 11, 19, 23, 13, 16, 8, 17, 0, 15, 19, 13, 20, 23, 20, 12, 13, 11, 0, 11, 16, 11, 20, 34, 18, 13, 21, 13, 0, 15, 11, 13, 16, 34, 20, 12, 17, 12, 0, 17, 13, 15, 14, 28, 15, 19, 15, 15, 0, 12, 9, 13, 20, 28, 21, 9, 12, 12, 0, 15, 20, 14, 21, 17, 8, 16, 22, 17, 0, 14, 14, 17, 9, 21, 19, 15, 18, 15, 0, 14, 23, 16, 19, 26, 14, 11, 19, 17, 0, 16, 18, 16, 19, 30, 14, 16, 11, 14, 0, 12, 13, 15, 19, 26, 15, 9, 22, 13, 0, 13, 20, 13, 13, 26, 15, 13, 15, 11, 0, 9, 13, 17, 16, 28, 22, 8, 19, 11, 0, 16, 19, 13, 13, 54, 21, 14, 17, 19, 0, 12, 18, 13, 13, 19, 19, 14, 15, 15, 0, 7, 19, 13, 19, 25, 19, 11, 12, 14, 0, 17, 21, 16, 15, 16, 20, 9, 17, 13, 0, 12, 15, 14, 19, 10, 16, 14, 19, 16, 0, 13, 16, 17, 18, 23, 19, 13, 19, 15, 0, 14, 16, 13, 19, 26, 18, 11, 21, 6, 0, 14, 16, 14, 19, 26, 12, 14, 21, 14, 0, 16, 12, 19, 13, 19, 11, 14, 16, 17, 0, 11, 9, 19, 17, 21, 9, 13, 17, 12, 0, 15, 18, 13, 21, 27, 19, 18, 15, 13, 0, 9, 11, 13, 17, 24, 13, 17, 20, 16, 0, 16, 13, 19, 13, 26, 19, 15, 23, 8, 0, 13, 20, 10, 13, 94, 7, 13, 13, 15, 0, 13, 12, 15, 11, 25, 19, 10, 19, 14, 0, 11, 11, 16, 20, 32, 19, 15, 13, 15, 0, 14, 19, 12, 14, 27, 18, 14, 14, 13, 0, 15, 16, 9, 21, 26, 13, 19, 12, 13, 0, 17, 12, 12, 19, 22, 22, 12, 19, 12, 0, 16, 19, 12, 6, 25, 17, 8, 15, 11, 0, 16, 14, 14, 16, 33, 19, 13, 13, 13, 0, 11, 13, 10, 7, 21, 18, 11, 20, 17, 0, 13, 20, 13, 19, 30, 14, 18, 16, 15, 0, 13, 16, 17, 19, 18, 16, 14, 26, 11, 0, 15, 13, 10, 18, 21, 16, 12, 13, 17, 0, 14, 12, 16, 19, 19, 17, 14, 16, 13, 0, 15, 17, 13, 8, 25, 15, 15, 18, 15, 0, 16, 13, 15, 15, 29, 17, 11, 18, 14, 0, 15, 17, 11, 21, 20, 19, 11, 19, 13, 0, 15, 9, 14, 16, 20, 19, 16, 18, 16, 0, 14, 14, 12, 30, 26, 18, 17, 18, 14, 0, 13, 15, 19, 22, 24, 11, 13, 19, 10, 0, 16, 19, 10, 16, 25, 22, 17, 18, 13, 0, 16, 15, 13, 16, 21, 24, 14, 22, 12, 0, 14, 15, 13, 19, 13, 22, 14, 13, 13, 0, 18, 12, 14, 15, 36, 15, 12, 18, 17, 0, 13, 8, 13, 20, 12, 19, 16, 24, 14, 0, 16, 14, 18, 21, 29, 17, 13, 17, 17, 0, 18, 18, 20, 20, 26, 23, 9, 9, 9, 0, 18, 13, 15, 19, 33, 11, 13, 16, 18, 0, 13, 17, 7, 19, 20, 13, 17, 13, 14, 0, 16, 17, 14, 21, 23, 17, 12, 20, 13, 0, 12, 16, 16, 15, 24, 21, 15, 9, 19, 0, 11, 21, 16, 17, 28, 18, 10, 20, 11, 0, 12, 13, 13, 19, 32, 14, 15, 20, 18, 0, 16, 19, 19, 16, 38, 9, 16, 18, 8, 0, 11, 19, 10, 22, 32, 17, 15, 19, 16, 0, 9, 13, 13, 11, 22, 14, 16, 21, 13, 0, 14, 15, 17, 12, 32, 17, 15, 11, 14, 0, 13, 16, 13, 18, 22, 22, 17, 18, 9, 0, 12, 19, 13, 13, 53, 18, 16, 14, 17, 0, 15, 9, 13, 17, 29, 11, 19, 14, 17, 0, 15, 18, 9, 14, 35, 19, 12, 27, 17, 0, 10, 6, 13, 20, 26, 14, 13, 18, 16, 0, 14, 14, 11, 23, 29, 10, 19, 18, 14, 0, 14, 17, 13, 13, 33, 21, 18, 18, 14, 0, 12, 16, 12, 15, 30, 19, 14, 11, 17, 0, 8, 20, 17, 17, 34, 25, 16, 19, 17, 0, 14, 21, 8, 15, 24, 19, 11, 13, 15, 0, 10, 18, 8, 18, 16, 11, 15, 21, 14, 0, 12, 17, 9, 18, 35, 21, 13, 14, 18, 0, 16, 18, 13, 17, 26, 12, 13, 16, 13, 0, 14, 20, 15, 22, 33, 20, 13, 20, 14, 0, 12, 17, 12, 17, 29, 19, 14, 11, 18, 0, 12, 16, 14, 21, 25, 13, 14, 14, 14, 0, 12, 14, 21, 19, 33, 8, 10, 14, 13, 0, 12, 20, 16, 15, 27, 25, 19, 17, 13, 0, 21, 13, 8, 14, 27, 18, 17, 12, 13, 0, 11, 20, 13, 18, 32, 19, 11, 19, 13, 0, 14, 14, 12, 17, 23, 16, 19, 22, 14, 0, 14, 12, 10, 19, 33, 19, 13, 20, 16, 0, 8, 13, 16, 23, 26, 14, 5, 16, 9, 0, 16, 21, 16, 16, 29, 12, 12, 13, 15, 0, 18, 13, 17, 14, 22, 20, 13, 16, 16, 0, 11, 14, 13, 11, 30, 22, 18, 14, 9, 0, 12, 14, 14, 14, 35, 19, 17, 17, 16, 0, 20, 21, 8, 8, 32, 14, 13, 12, 13, 0, 12, 19, 14, 17, 31, 12, 14, 18, 15, 0, 7, 21, 13, 22, 32, 16, 13, 21, 11, 0, 16, 17, 18, 13, 32, 19, 13, 16, 12, 0, 17, 17, 13, 15, 23, 13, 14, 13, 14, 0, 14, 17, 17, 21, 21, 28, 18, 10, 17, 0, 11, 19, 15, 14, 27, 14, 8, 18, 16, 0, 10, 14, 13, 19, 23, 19, 14, 19, 15, 0, 12, 14, 14, 12, 23, 18, 13, 8, 8, 0, 11, 15, 13, 15, 34, 18, 15, 17, 8, 0, 12, 23, 19, 16, 27, 20, 15, 14, 11, 0, 10, 14, 10, 23, 109, 14, 9, 13, 14, 0, 13, 17, 12, 14, 26, 9, 13, 9, 11, 0, 14, 18, 17, 19, 26, 21, 14, 13, 15, 0, 14, 17, 14, 12, 45, 17, 17, 18, 15, 0, 17, 19, 13, 13, 26, 17, 13, 14, 9, 0, 12, 22, 13, 16, 25, 19, 12, 22, 17, 0, 10, 14, 15, 15, 24, 16, 13, 13, 16, 0, 12, 19, 14, 19, 24, 16, 11, 13, 14, 0, 7, 15, 10, 17, 35, 12, 15, 18, 13, 0, 15, 19, 15, 19, 18, 19, 15, 13, 18, 0, 14, 18, 16, 17, 36, 24, 14, 14, 19, 0, 13, 12, 8, 13, 23, 13, 16, 20, 14, 0, 13, 15, 11, 19, 27, 17, 13, 21, 17, 0, 15, 20, 11, 16, 35, 11, 16, 24, 14, 0, 9, 16, 13, 18, 32, 18, 10, 19, 18, 0, 15, 21, 14, 12, 24, 8, 14, 14, 17, 0, 14, 13, 15, 17, 29, 11, 14, 20, 12, 0, 14, 21, 11, 20, 30, 16, 17, 17, 19, 0, 7, 17, 13, 18, 29, 22, 15, 21, 17, 0, 12, 19, 10, 8, 28, 19, 13, 19, 13, 0, 14, 30, 13, 19, 22, 13, 16, 21, 14, 0, 14, 22, 13, 17, 29, 20, 14, 20, 14, 0, 14, 13, 19, 14, 21, 11, 12, 14, 14, 0, 11, 21, 13, 20, 33, 17, 14, 20, 12, 0, 14, 14, 14, 22, 23, 15, 20, 15, 11, 0, 13, 14, 7, 8, 36, 21, 18, 18, 19, 0, 14, 19, 14, 22, 25, 13, 13, 20, 12, 0, 11, 22, 8, 16, 29, 18, 12, 20, 14, 0, 16, 13, 14, 17, 19, 13, 14, 14, 15, 0, 16, 13, 15, 13, 13, 20, 15, 28, 15, 0, 19, 19, 17, 20, 30, 14, 10, 17, 17, 0, 15, 22, 8, 13, 24, 14, 15, 17, 14, 0, 12, 18, 13, 16, 23, 10, 12, 19, 9, 0, 8, 14, 14, 21, 32, 15, 14, 8, 12, 0, 12, 12, 12, 12, 10, 13, 13, 25, 10, 0, 16, 22, 16, 12, 26, 18, 10, 7, 13, 0, 15, 30, 14, 12, 34, 14, 12, 21, 8, 0, 18, 21, 13, 15, 38, 20, 10, 20, 19, 0, 8, 12, 12, 21, 31, 14, 12, 20, 11, 0, 14, 15, 14, 14, 29, 14, 18, 8, 17, 0, 13, 15, 9, 19, 26, 19, 15, 21, 11, 0, 15, 17, 13, 13, 27, 17, 17, 15, 18, 0, 13, 13, 11, 16, 16, 15, 17, 17, 14, 0, 13, 19, 14, 11, 17, 24, 18, 18, 18, 0, 11, 14, 13, 19, 32, 16, 12, 13, 6, 0, 8, 32, 16, 14, 19, 21, 13, 13, 16, 0, 9, 21, 10, 13, 17, 16, 14, 17, 10, 0, 13, 20, 11, 16, 21, 15, 13, 17, 12, 0, 15, 17, 17, 16, 53, 15, 13, 11, 13, 0, 14, 18, 13, 13, 29, 19, 13, 16, 14, 0, 16, 16, 13, 20, 13, 22, 13, 13, 11, 0, 16, 20, 14, 17, 23, 11, 11, 11, 17, 0, 8, 22, 13, 17, 25, 15, 11, 16, 16, 0, 8, 19, 13, 20, 35, 11, 16, 22, 13, 0, 11, 17, 13, 19, 21, 15, 16, 13, 12, 0, 19, 17, 18, 16, 27, 17, 14, 17, 15, 0, 15, 18, 8, 18, 41, 20, 9, 13, 13, 0, 13, 23, 14, 19, 21, 20, 12, 13, 15, 0, 13, 13, 10, 13, 705, 14, 16, 6, 6, 0, 6, 18, 6, 18, 22, 14, 12, 6, 10, 0, 15, 22, 13, 17, 29, 16, 11, 17, 11, 0, 13, 20, 6, 6, 30, 16, 11, 12, 13, 0, 15, 15, 13, 13, 23, 8, 11, 21, 12, 0, 13, 20, 15, 19, 35, 19, 9, 6, 18, 0, 16, 7, 14, 21, 26, 9, 14, 19, 12, 0, 8, 21, 13, 20, 25, 13, 10, 18, 19, 0, 12, 13, 6, 18, 21, 16, 18, 15, 18, 0, 9, 20, 18, 14, 20, 12, 16, 15, 16, 0, 13, 16, 20, 16, 25, 14, 13, 6, 16, 0, 17, 13, 14, 20, 28, 14, 18, 13, 17, 0, 14, 13, 15, 95, 34, 7, 16, 17, 12, 0, 16, 14, 6, 27, 24, 15, 13, 17, 13, 0, 15, 17, 17, 13, 26, 17, 17, 15, 16, 0, 18, 17, 18, 14, 16, 12, 20, 13, 10, 0, 10, 17, 13, 19, 38, 22, 9, 25, 11, 0, 11, 22, 12, 19, 29, 19, 17, 13, 16, 0, 13, 19, 14, 14, 25, 20, 10, 13, 13, 0, 19, 19, 13, 18, 21, 12, 13, 27, 15, 0, 14, 22, 14, 14, 34, 13, 13, 17, 8, 0, 19, 21, 17, 14, 26, 11, 13, 16, 15, 0, 11, 17, 8, 17, 36, 14, 16, 17, 15, 0, 9, 14, 16, 12, 15, 19, 10, 14, 13, 0, 17, 14, 8, 25, 20, 20, 13, 12, 12, 0, 15, 15, 14, 17, 15, 21, 11, 6, 6, 0, 18, 18, 14, 19, 21, 13, 11, 18, 15, 0, 11, 18, 15, 20, 31, 19, 13, 18, 15, 0, 7, 17, 6, 22, 28, 14, 14, 18, 16, 0, 7, 21, 11, 16, 29, 19, 10, 9, 17, 0, 13, 15, 16, 11, 26, 14, 18, 13, 10, 0, 14, 23, 13, 20, 32, 18, 17, 19, 19, 0, 9, 19, 9, 18, 26, 22, 16, 22, 13, 0, 16, 15, 11, 15, 18, 21, 13, 14, 15, 0, 10, 8, 13, 20, 23, 14, 17, 17, 12, 0, 18, 22, 15, 17, 142, 18, 9, 23, 13, 0, 14, 15, 14, 11, 23, 14, 9, 20, 17, 0, 11, 17, 14, 13, 30, 14, 13, 19, 14, 0, 14, 9, 14, 20, 13, 16, 15, 19, 15, 0, 12, 20, 16, 16, 28, 21, 12, 11, 9, 0, 14, 14, 16, 16, 33, 17, 7, 24, 12, 0, 18, 12, 9, 23, 17, 17, 17, 20, 15, 0, 7, 27, 12, 18, 22, 14, 13, 15, 15, 0, 16, 26, 12, 18, 21, 14, 15, 9, 13, 0, 12, 17, 15, 11, 28, 9, 16, 15, 16, 0, 18, 21, 14, 13, 33, 20, 13, 17, 13, 0, 14, 17, 13, 21, 20, 11, 14, 18, 13, 0, 14, 20, 21, 16, 26, 13, 11, 14, 15, 0, 13, 17, 16, 14, 19, 24, 11, 11, 8, 0, 12, 18, 13, 10, 22, 16, 18, 17, 13, 0, 12, 19, 13, 23, 24, 13, 17, 6, 16, 0, 14, 23, 6, 21, 29, 15, 14, 16, 13, 0, 17, 12, 17, 19, 23, 14, 8, 8, 10, 0, 6, 16, 15, 19, 61, 20, 13, 14, 13, 0, 13, 18, 15, 12, 21, 17, 13, 17, 12, 0, 17, 19, 9, 16, 38, 19, 9, 13, 17, 0, 19, 21, 14, 19, 15, 10, 15, 19, 10, 0, 18, 19, 9, 16, 30, 18, 14, 14, 15, 0, 12, 18, 11, 15, 19, 16, 17, 19, 13, 0, 18, 11, 14, 20, 23, 22, 17, 14, 12, 0, 15, 16, 15, 22, 16, 16, 14, 10, 12, 0, 12, 21, 11, 26, 25, 20, 13, 13, 16, 0, 9, 16, 12, 13, 29, 23, 10, 18, 16, 0, 16, 11, 15, 14, 23, 14, 15, 10, 17, 0, 12, 14, 14, 17, 25, 42, 19, 19, 11, 0, 8, 21, 16, 11, 24, 16, 13, 13, 15, 0, 10, 16, 15, 21, 34, 16, 14, 13, 16, 0, 16, 13, 8, 12, 18, 14, 9, 25, 11, 0, 18, 13, 16, 17, 52, 11, 15, 13, 15, 0, 15, 19, 11, 22, 29, 11, 13, 20, 15, 0, 15, 17, 11, 13, 34, 21, 13, 19, 18, 0, 14, 15, 10, 11, 21, 20, 13, 11, 17, 0, 13, 18, 13, 21, 23, 13, 13, 9, 15, 0, 15, 18, 19, 12, 29, 11, 11, 10, 12, 0, 14, 13, 13, 13, 27, 19, 14, 15, 14, 0, 10, 19, 15, 14, 18, 17, 8, 6, 19, 0, 18, 10, 13, 20, 25, 16, 18, 21, 11, 0, 12, 17, 15, 15, 33, 22, 17, 20, 7, 0, 12, 11, 15, 20, 19, 18, 13, 12, 16, 0, 11, 16, 16, 19, 30, 16, 7, 19, 19, 0, 8, 17, 18, 18, 38, 14, 13, 14, 13, 0, 14, 18, 11, 13, 24, 19, 13, 19, 8, 0, 12, 18, 12, 14, 28, 15, 14, 10, 13, 0, 14, 14, 15, 20, 21, 18, 16, 26, 11, 0, 13, 17, 12, 13, 30, 14, 14, 23, 18, 0, 11, 16, 15, 20, 20, 16, 8, 17, 15, 0, 17, 15, 13, 14, 21, 16, 10, 14, 13, 0, 16, 17, 12, 18, 21, 15, 11, 14, 13, 0, 14, 13, 14, 21, 25, 14, 14, 19, 16, 0, 18, 18, 18, 11, 61, 16, 14, 19, 14, 0, 15, 30, 12, 13, 53, 17, 13, 17, 18, 0, 17, 15, 18, 13, 21, 14, 11, 18, 13, 0, 10, 20, 14, 21, 23, 15, 11, 19, 12, 0, 13, 24, 12, 13, 24, 13, 10, 21, 15, 0, 15, 9, 14, 18, 29, 13, 15, 16, 12, 0, 13, 13, 14, 20, 35, 23, 11, 13, 16, 0, 13, 11, 15, 17, 32, 9, 14, 16, 16, 0, 19, 15, 14, 14, 22, 13, 9, 14, 7, 0, 19, 20, 12, 23, 29, 18, 16, 20, 12, 0, 17, 20, 11, 15, 28, 20, 15, 21, 15, 0, 11, 18, 13, 22, 27, 14, 12, 6, 13, 0, 15, 14, 10, 8, 40, 19, 15, 9, 16, 0, 14, 11, 9, 24, 33, 12, 13, 12, 10, 0, 13, 20, 15, 14, 31, 19, 11, 15, 14, 0, 9, 22, 14, 13, 15, 16, 17, 22, 15, 0, 11, 19, 12, 17, 33, 7, 12, 15, 9, 0, 19, 22, 15, 21, 28, 7, 11, 8, 7, 0, 16, 12, 10, 14, 12, 24, 9, 19, 7, 0, 16, 13, 12, 14, 16, 19, 12, 17, 13, 0, 14, 13, 12, 20, 33, 19, 12, 17, 16, 0, 15, 12, 18, 14, 34, 19, 11, 19, 8, 0, 12, 11, 16, 15, 33, 12, 14, 17, 18, 0, 9, 17, 17, 13, 23, 24, 13, 19, 11, 0, 13, 19, 13, 17, 23, 15, 14, 13, 8, 0, 13, 21, 18, 20, 12, 18, 13, 20, 23, 0, 14, 21, 14, 15, 14, 21, 17, 18, 16, 0, 16, 18, 16, 19, 12, 13, 15, 18, 13, 0, 13, 20, 8, 14, 22, 18, 13, 15, 10, 0, 15, 16, 11, 19, 27, 14, 16, 18, 8, 0, 12, 13, 17, 14, 18, 18, 15, 13, 13, 0, 21, 15, 17, 8, 24, 19, 18, 18, 16, 0, 13, 20, 11, 14, 29, 20, 8, 13, 13, 0, 16, 14, 15, 18, 21, 16, 12, 18, 16, 0, 11, 15, 16, 19, 26, 18, 14, 19, 14, 0, 8, 17, 12, 20, 17, 14, 15, 16, 9, 0, 16, 19, 10, 21, 29, 14, 14, 6, 11, 0, 14, 18, 14, 14, 25, 18, 8, 18, 13, 0, 11, 13, 13, 16, 38, 18, 17, 16, 12, 0, 18, 11, 14, 10, 9, 18, 11, 17, 14, 0, 12, 20, 15, 14, 29, 15, 15, 17, 19, 0, 13, 20, 15, 25, 34, 18, 14, 20, 20, 0, 15, 15, 15, 16, 18, 23, 14, 30, 12, 0, 11, 17, 11, 24, 34, 15, 20, 18, 13, 0, 6, 14, 14, 19, 32, 13, 12, 14, 15, 0, 14, 16, 15, 15, 37, 17, 14, 18, 14, 0, 14, 23, 16, 14, 28, 12, 14, 10, 13, 0, 12, 14, 10, 18, 17, 9, 12, 17, 18, 0, 13, 13, 9, 18, 23, 21, 15, 15, 16, 0, 13, 26, 12, 19, 20, 14, 13, 20, 8, 0, 16, 14, 16, 20, 15, 17, 13, 18, 13, 0, 7, 13, 17, 15, 24, 11, 11, 14, 10, 0, 13, 21, 12, 27, 33, 16, 14, 14, 14, 0, 10, 18, 14, 14, 28, 12, 15, 16, 18, 0, 14, 18, 12, 18, 34, 20, 13, 11, 11, 0, 10, 19, 18, 13, 19, 11, 16, 18, 16, 0, 10, 19, 13, 15, 28, 19, 8, 11, 14, 0, 16, 22, 17, 20, 23, 15, 17, 18, 14, 0, 13, 14, 14, 16, 18, 20, 13, 25, 14, 0, 11, 18, 17, 17, 30, 11, 13, 19, 13, 0, 16, 14, 9, 16, 26, 17, 17, 36, 15, 0, 9, 16, 12, 19, 28, 13, 12, 11, 18, 0, 16, 20, 14, 14, 20, 14, 11, 19, 15, 0, 15, 16, 11, 9, 29, 19, 15, 16, 13, 0, 13, 13, 18, 14, 23, 18, 14, 12, 10, 0, 9, 21, 14, 19, 27, 17, 8, 17, 17, 0, 7, 14, 12, 19, 26, 18, 18, 14, 18, 0, 12, 18, 18, 20, 24, 16, 14, 17, 18, 0, 17, 11, 16, 24, 25, 18, 15, 10, 13, 0, 11, 18, 17, 18, 33, 13, 14, 12, 10, 0, 13, 17, 10, 18, 21, 19, 14, 13, 18, 0, 13, 17, 16, 20, 42, 13, 16, 13, 11, 0, 14, 25, 16, 13, 28, 17, 11, 19, 14, 0, 14, 17, 11, 21, 33, 19, 13, 19, 15, 0, 13, 23, 13, 17, 24, 21, 11, 26, 17, 0, 19, 13, 15, 18, 61, 14, 16, 21, 14, 0, 13, 21, 16, 19, 32, 19, 17, 11, 14, 0, 8, 15, 14, 15, 21, 14, 13, 12, 11, 0, 15, 23, 12, 20, 32, 13, 14, 10, 13, 0, 18, 14, 19, 15, 23, 16, 14, 18, 14, 0, 16, 11, 15, 19, 28, 10, 11, 16, 13, 0, 14, 28, 8, 16, 38, 13, 17, 19, 14, 0, 13, 14, 16, 22, 19, 19, 14, 20, 17, 0, 16, 16, 12, 15, 23, 17, 15, 13, 8, 0, 15, 14, 7, 25, 32, 21, 17, 17, 17, 0, 13, 14, 19, 11, 33, 18, 14, 20, 9, 0, 13, 18, 14, 16, 26, 12, 8, 19, 14, 0, 16, 19, 13, 25, 27, 27, 18, 27, 16, 0, 17, 18, 9, 7, 32, 16, 10, 13, 17, 0, 9, 15, 18, 19, 14, 13, 17, 15, 16, 0, 19, 13, 16, 17, 21, 18, 16, 13, 18, 0, 14, 22, 13, 21, 90, 12, 11, 22, 15, 0, 16, 20, 12, 19, 31, 15, 10, 19, 13, 0, 17, 13, 15, 17, 21, 16, 16, 19, 18, 0, 13, 22, 14, 8, 23, 19, 16, 16, 16, 0, 12, 20, 12, 19, 22, 17, 17, 22, 13, 0, 12, 9, 19, 15, 21, 20, 16, 21, 16, 0, 14, 19, 17, 16, 23, 13, 13, 16, 13, 0, 11, 23, 10, 17, 40, 21, 13, 12, 14, 0, 16, 17, 12, 17, 21, 11, 15, 22, 11, 0, 14, 13, 14, 14, 23, 18, 18, 17, 13, 0, 13, 12, 19, 20, 32, 19, 17, 14, 13, 0, 14, 14, 13, 15, 12, 16, 15, 16, 8, 0, 20, 20, 15, 19, 25, 21, 17, 20, 16, 0, 10, 18, 11, 13, 23, 14, 13, 19, 13, 0, 10, 16, 11, 18, 18, 16, 12, 14, 15, 0, 17, 18, 12, 17, 22, 20, 14, 20, 16, 0, 15, 15, 9, 7, 31, 13, 8, 18, 14, 0, 7, 9, 8, 18, 29, 22, 16, 11, 15, 0, 18, 12, 16, 13, 26, 12, 11, 12, 12, 0, 11, 18, 13, 17, 29, 14, 14, 18, 15, 0, 13, 13, 10, 20, 34, 18, 18, 16, 14, 0, 9, 21, 13, 18, 38, 12, 16, 14, 14, 0, 16, 15, 13, 15, 20, 17, 9, 7, 12, 0, 11, 14, 15, 19, 27, 18, 14, 14, 11, 0, 13, 12, 14, 14, 29, 11, 20, 22, 13, 0, 16, 17, 16, 20, 26, 21, 12, 17, 13, 0, 17, 19, 13, 20, 28, 18, 14, 19, 12, 0, 17, 16, 13, 22, 24, 17, 11, 15, 13, 0, 19, 13, 13, 14, 24, 25, 13, 17, 14, 0, 17, 19, 16, 21, 28, 20, 15, 18, 17, 0, 15, 18, 14, 14, 20, 17, 17, 20, 17, 0, 12, 11, 13, 17, 28, 17, 12, 16, 13, 0, 11, 17, 9, 15, 23, 8, 15, 29, 13, 0, 9, 16, 15, 21, 29, 18, 19, 21, 13, 0, 15, 10, 14, 20, 25, 13, 12, 15, 9, 0, 13, 15, 13, 19, 45, 13, 16, 9, 11, 0, 15, 17, 19, 21, 29, 17, 12, 19, 13, 0, 15, 14, 13, 10, 26, 18, 17, 16, 17, 0, 8, 20, 13, 18, 23, 13, 11, 20, 17, 0, 13, 17, 15, 14, 15, 21, 15, 21, 19, 0, 19, 14, 18, 18, 32, 14, 11, 8, 9, 0, 16, 17, 12, 19, 28, 23, 15, 21, 15, 0, 20, 18, 11, 27, 26, 17, 30, 24, 21, 0 };

int main()
{
	cin &gt;&gt; n;
	cout &lt;&lt; ans[n - 1] &lt;&lt; endl;
	return 0;
}
----------
====================
----------
ALGORITHMS.357
advanced
----------
PROBLEM STATEMENT:
Divide-and-Conquer on a tree is a powerful approach to solving tree problems. 

Imagine a tree, [expression].

The Divide-and-Conquer approach can be described as follows:


Initially, there is a tree, [expression] vertices.
Find vertex [expression].
Remove [expression].
Perform this approach recursively for each of the connected components.


We can prove that if we find such a vertex [expression] that we can choose.

Given [expression].
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define rep(i, from, to) for (int i = from; i &lt; (to); ++i)
#define trav(a, x) for (auto&amp; a : x)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef vector&lt;int&gt; vi;

ll mod;
vector&lt;ll&gt; fact, ifact;

vector&lt;int&gt; mem;
vector&lt;vector&lt;int&gt;&gt; mem2;
ll solve2(int left, int max);

ll rsolve(int n) {
	if (n &lt;= 5) return n != 2;
	return solve2(n-1, (n-1)/2);
}

ll solve(int n) {
	assert(n &gt; 0);
	int&amp; out = mem[n];
	if (out != -1) return out;
	return out = (int)(rsolve(n) * n % mod);
}

ll solve2(int left, int max) {
	if (left == 0) return 1;
	if (!max) return 0;
	int&amp; out = mem2[left][max];
	if (out != -1) return out;
	ll res = solve2(left, max-1);
	if (max &gt; left) return out = (int)res;
	int lim = left / max;
	ll one = solve(max) * max % mod * ifact[max] % mod;
	ll mult = one * fact[left] % mod;
	for (int i = 1;; i++) {
		ll bin = ifact[i] * ifact[left - i * max] % mod;
		res += solve2(left - i * max, max-1) * mult % mod * bin;
		if (i == lim) break;
		if (i % 4 == 0) res %= mod;
		mult = mult * one % mod;
	}
	res %= mod;
	return out = (int)res;
}

int main() {
	cin.sync_with_stdio(false);
	cin.exceptions(cin.failbit);
	int N;
	cin &gt;&gt; N &gt;&gt; mod;
	mem.assign(N+1, -1);
	mem2.assign(N+1, vector&lt;int&gt;(N+1, -1));
	int LIM = N+1;
	ll* inv = new ll[LIM] - 1; inv[1] = 1;
	rep(i,2,LIM) inv[i] = mod - (mod / i) * inv[mod % i] % mod;
	fact.resize(N+1);
	ifact.resize(N+1);
	fact[0] = ifact[0] = 1;
	rep(i,1,N+1) {
		fact[i] = fact[i-1] * i % mod;
		ifact[i] = ifact[i-1] * inv[i] % mod;
	}
	cout &lt;&lt; solve(N) &lt;&lt; endl;
	exit(0);
}

----------
====================
----------
ALGORITHMS.358
expert
----------
PROBLEM STATEMENT:
The King of Byteland wants to grow his territory by conquering [expression] heirs for the future, he decides they must work together to capture each country. 

The King has an army, [expression], the heirs will fight alone without any help.

The battalions chosen for battle must be selected in the following way:


A subsequence of [expression]). 
The [expression]. 


The soldiers within a battalion have unique strengths. For a battalion of size [expression]

The King tasks you with finding the number of ways of selecting [expression].
----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define FOR(i,a,b) for(int i = (a); i &lt;= (b); ++i)
#define FORD(i,a,b) for(int i = (a); i &gt;= (b); --i)
#define RI(i,n) FOR(i,1,(n))
#define REP(i,n) FOR(i,0,(n)-1)
#define mini(a,b) a=min(a,b)
#define maxi(a,b) a=max(a,b)
#define mp make_pair
#define pb push_back
#define st first
#define nd second
#define sz(w) (int) w.size()
typedef vector&lt;int&gt; vi;
typedef long long ll;
typedef long double ld;
typedef pair&lt;int,int&gt; pii;
const int inf = 1e9 + 5;
const int nax = 1e6 + 5;
const int mod = 1e9 + 7;

pii mul(pii a, pii b) {
	ll c = (ll) a.st * b.st - (ll) a.nd * b.nd;
	ll d = (ll) a.st * b.nd + (ll) a.nd * b.st;
	c %= mod;
	d %= mod;
	if(c &lt; 0) c += mod;
	if(d &lt; 0) d += mod;
	return mp((int) c, (int) d);
}

pii pw(pii a, int k) {
	pii r = mp(1, 0);
	while(k) {
		if(k % 2) r = mul(r, a);
		a = mul(a, a);
		k /= 2;
	}
	return r;
}
int pw(int a, int k) {
	int r = 1;
	while(k) {
		if(k % 2) r = (ll) r * a % mod;
		a = (ll) a * a % mod;
		k /= 2;
	}
	return r;
}

int f(int n) {
	int r = pw(mp(1,mod-1), n).st + pw(mp(1,1), n).st;
	r %= mod;
	r += pw(2, n);
	r %= mod;
	r = (ll) r * pw(4, mod - 2) % mod;
	return r;
}

int dp[105];

int main() {
	int n, k;
	scanf("%d%d", &amp;n, &amp;k);
	dp[0] = 1;
	REP(_, n) {
		int a;
		scanf("%d", &amp;a);
		a = f(a);
		FORD(j, k, 1)
			dp[j] = (dp[j] + (ll) dp[j-1] * a) % mod;
	}
	printf("%d\n", dp[k]);
	return 0;
}

----------
====================
----------
ALGORITHMS.359
advanced
----------
PROBLEM STATEMENT:
Borussia Dortmund are a famous football ( soccer ) club from Germany. Apart from their fast-paced style of playing, the thing that makes them unique is the hard to pronounce names of their players ( błaszczykowski , papastathopoulos , großkreutz etc. ).

The team's coach is your friend. He is in a dilemma as he can't decide how to make it easier to call the players by name, during practice sessions. So, you advise him to assign easy names to his players. A name is easy to him if 

1. It consists of only one word. 
2. It consists of only lowercase english letters. 
3. Its length is exactly [expression]. 
4. It contains exactly [expression] letters of English alphabet. 
5. At least one of its proper prefixes matches with its proper suffix of same length.

Given, [expression].

Note : A prefix [expression].

Input Format 
The first line of the input will contain [expression] ( the number of testcases ).
Each of the next [expression].

Output Format 
For each testcase, output the number of ways the coach can assign names to his players modulo [expression].

Constraints 
[expression] 
[expression] 
[expression]

Sample Input #1

3
1 1
2 1
4 2


Sample Output #1

0  
26 
2600  


Sample Input #2

5  
2 2
5 1
3 2
6 2
1 3


Sample Output #2

0
26
650
13650
0

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I &lt; (N); ++I)
#define REPP(I, A, B) for (int I = (A); I &lt; (B); ++I)
#define RI(X) scanf("%d", &amp;(X))
#define RII(X, Y) scanf("%d%d", &amp;(X), &amp;(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &amp;(X), &amp;(Y), &amp;(Z))
#define DRI(X) int (X); scanf("%d", &amp;X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &amp;X, &amp;Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &amp;X, &amp;Y, &amp;Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &amp;___T); while (___T-- &gt; 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
typedef long long LL;
using namespace std;
const int SIZE = 1e5+5;
const int MOD = 1e9+9;
LL C[27][27],an[27][SIZE],tmp[27][SIZE],pp[27][SIZE],tmp2[27][SIZE],ha[27];
int main(){
    REPP(i,1,27){
        pp[i][0]=1;
        REPP(j,1,SIZE)pp[i][j]=pp[i][j-1]*i%MOD;
    }
    REP(i,27){
        C[i][0]=1;
        REPP(j,1,i+1){
            C[i][j]=C[i-1][j-1]+C[i-1][j];
        }
    }
    REPP(i,1,27){
        an[i][1]=i;
        tmp[i][1]=i;
        REPP(j,2,SIZE){
            if(j%2==0)an[i][j]=tmp[i][j/2];
            else an[i][j]=tmp[i][j/2]*i%MOD;
            an[i][j]=pp[i][j]-an[i][j];
            REPP(k,1,i){
                an[i][j]=(an[i][j]-an[k][j]*C[i][k])%MOD;
            }
            if(an[i][j]&lt;0)an[i][j]+=MOD;
            tmp[i][j]=tmp[i][j-1]*i*i%MOD;
            REPP(k,1,i+1){
                tmp[i][j]=(tmp[i][j]+C[i][k]*an[k][j])%MOD;
            }

        }

    }
    CASET{ 
        DRII(N,K);
        if(N==1){
            puts("0");
            continue;
        }
        LL res=0;
        if(N%2==0){
            ha[1]=tmp[1][N/2];
            REPP(i,2,K+1){
                ha[i]=tmp[i][N/2];
                REPP(j,1,i)ha[i]=(ha[i]-ha[j]*C[i][j])%MOD;
                if(ha[i]&lt;0)ha[i]+=MOD;
            }
            res=ha[K]*C[26][K]%MOD;
        }
        else{
            ha[1]=tmp[1][N/2];
            REPP(i,2,K+1){
                ha[i]=tmp[i][N/2]*i%MOD;
                REPP(j,1,i)ha[i]=(ha[i]-ha[j]*C[i][j])%MOD;
                if(ha[i]&lt;0)ha[i]+=MOD;
            }
            res=ha[K]*C[26][K]%MOD;
        }
        if(K==1)res=26;
        if(res&lt;0)res+=MOD;
        printf("%lld\n",res);
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.360
advanced
----------
PROBLEM STATEMENT:
Given an array of [expression].

Two subsequences [expression].
----------
TOP SOLUTION:
----------
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

using namespace std;

#define FOR(i, a, b) for (int i = (a); i &lt; (b); ++i)
#define REP(i, n) FOR(i, 0, n)
#define TRACE(x) cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl
#define _ &lt;&lt; " _ " &lt;&lt;

typedef long long llint;

const int MAX = 100100;
const llint inf = 2e18;

int L[MAX];

int getMax(int x) {
  int r = 0;
  for (++x; x; x -= x&amp;-x)
    r = max(r, L[x]);
  return r;
}

void update(int x, int v) {
  for (++x; x &lt; MAX; x += x&amp;-x)
    L[x] = max(L[x], v);
}

llint S[MAX];

llint add(llint x, llint y) { return min(inf, x + y); }
llint mul(llint x, llint y) {
  if (x == 0 || y == 0) return 0;
  if (x &lt; (inf + y - 1) / y) return min(x * y, inf);
  return inf;
}

llint sum(int x) {
  llint r = 0;
  for (++x; x; x -= x&amp;-x)
    r = add(r, S[x]);
  return r;
}

void add(int x, llint v) {
  for (++x; x &lt; MAX; x += x&amp;-x)
    S[x] = add(S[x], v);
}

void clear(int x) {
  for (++x; x &lt; MAX; x += x&amp;-x)
    S[x] = 0;
}

int a[MAX];
int f[MAX];
llint g[MAX];
vector&lt;int&gt; v[MAX];

int main(void) {
  int N;
  llint K;
  scanf("%d %lld", &amp;N, &amp;K);
  REP(i, N) scanf("%d", &amp;a[i]);

  for (int i = N-1; i &gt;= 0; --i) {
    f[i] = getMax(N-a[i]-1) + 1;
    update(N-a[i], f[i]);
  }

  int L = getMax(N);
  REP(i, N) v[f[i]].push_back(i);
  
  for (int i = 1; i &lt;= L; ++i) {
    int p = (int)v[i - 1].size() - 1;
    for (int j = (int)v[i].size() - 1; j &gt;= 0; --j) {
      while (p &gt;= 0 &amp;&amp; v[i-1][p] &gt; v[i][j]) {
        add(N-a[v[i-1][p]], g[v[i-1][p]]);
        p--;
      }
      if (i == 1) g[v[i][j]] = 1;
      else g[v[i][j]] = sum(N-a[v[i][j]]-1);
    }
    while (++p &lt; (int)v[i-1].size()) clear(N-a[v[i-1][p]]);
  }

  llint total = 0;
  for (int x: v[L]) total = add(total, g[x]);
  if (total &lt; K) {
    puts("-1");
    return 0;
  }

  vector&lt;pair&lt;int, llint&gt;&gt; cur = {{-1, 1}};
  vector&lt;int&gt; ans;
  int last = 0;
  for (int i = L; i &gt; 0; --i) {
    auto count = [&amp;] (int x) {
      int p = (int)v[i].size() - 1;
      llint total = 0;
      llint rsum = 0;
      for (int j = (int)cur.size() - 1; j &gt;= 0; --j) {
        while (p &gt;= 0 &amp;&amp; v[i][p] &gt; cur[j].first) {
          if (last &lt; a[v[i][p]] &amp;&amp; a[v[i][p]] &lt;= x) rsum = add(rsum, g[v[i][p]]);
          p--;
        }
        total = add(total, mul(rsum, cur[j].second));
      }
      return total;
    };


    int lo = last + 1, hi = N;
    while (lo &lt; hi) {
      int mid = (lo + hi) / 2;
      if (count(mid) &lt; K) lo = mid + 1;
      else hi = mid;
    }

    K -= count(lo - 1);
    
    vector&lt;pair&lt;int, llint&gt;&gt; ncur;
    int p = 0;
    llint rsum = 0;
    REP(j, (int)v[i].size()) {
      while (p &lt; (int)cur.size() &amp;&amp; cur[p].first &lt; v[i][j]) rsum = add(rsum, cur[p++].second);
      if (a[v[i][j]] == lo) ncur.push_back({v[i][j], rsum});
    }

    cur = ncur;
    ans.push_back(lo);
    last = lo;
  }

  for (int x: ans) printf("%d ", x); printf("\n");
  return 0;
}

----------
====================
----------
ALGORITHMS.361
expert
----------
PROBLEM STATEMENT:
Little Walter likes playing with his toy scales. He has [expression]. There are infinitely many weights of each type.

Recently, Walter defined a function, [expression]. Ways are considered to be different if there is a type which has a different number of weights used in these two ways.

For example, if there are [expression]:


Use [expression].
Use [expression].
Use [expression].
Use [expression].


Given [expression]?
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;cctype&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

using namespace std;

#define forn(i, n) for (int i = 0; i &lt; (int)(n); i++)
#define forit(i, a) for (__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)
#define pb push_back
#define mp make_pair
#define sz(a) (int)(a).size()
#define all(a) (a).begin(), (a).end()

typedef long long ll;
typedef vector &lt;int&gt; vi;
typedef pair &lt;int, int&gt; pii;

int a[11]; // weights
int N;
int prod;

int DP[11][100001*11]; // DP[k][n] is number of ways with k weights of achieving total &lt;= n

#define MOD 1000000007

ll mul_inv(ll a, ll b)
{
	ll b0 = b, t, q;
	ll x0 = 0, x1 = 1;
	if (b == 1) return 1;
	while (a &gt; 1) {
		q = a / b;
		t = b, b = a % b, a = t;
		t = x0, x0 = x1 - q * x0, x1 = t;
	}
	if (x1 &lt; 0) x1 += b0;
	return x1;
}

// Count ways of combining weights to make target of top
ll f(ll top) {
	ll total = 0;
	int b = top % prod;
	ll top2 = top / prod;
	// denumerant evaluated at position a.x+b is polynomial of degree at most 10
	// so evaluate at 11 points
	int last = 10*prod+b; // last location to evaluate
	forn(i,last+1)
		DP[0][i] = 1; // Consider weight 0 to be of value 1
	for(int k=1;k&lt;=N;k++) {
		int w=a[k-1];
		forn(i,last+1) {
			DP[k][i] = (i&gt;=w) ? ((DP[k][i-w] + DP[k-1][i]) % MOD) : DP[k-1][i];
		}
	}
	forn(x,11) {
		ll y = DP[N][x*prod+b];
		ll den = 1;
		forn(i,11) {
			if (i==x) continue;
			y = y*(((top2-i)+MOD)%MOD)%MOD;
			den = den*(((x-i)+MOD)%MOD)%MOD;
		}
		total = (total + y*mul_inv(den,MOD)%MOD) % MOD;
	}
	return total;
}

int main(int argc,char *argv[])
{
	ll total = 0;
	ll L,R;
	cin &gt;&gt; N;
	prod = 1;
	forn(n,N) {
		int x,y;
		cin &gt;&gt; a[n];
		prod *= a[n];
	}
	cin &gt;&gt; L &gt;&gt; R;
	total = (f(R) - f(L-1) + MOD) % MOD;
	cout &lt;&lt; total &lt;&lt; endl;
	return 0;
}





----------
====================
----------
ALGORITHMS.362
expert
----------
PROBLEM STATEMENT:
There are [expression] pairs of hard disk drives (HDDs) in a cluster. Each HDD is located at an integer coordinate on an infinite straight line, and each pair consists of one primary HDD and one backup HDD.

Next, you want to place [expression] computers at integer coordinates on the same infinite straight line. Each pair of HDDs must then be connected to a single computer via wires, but a computer can have any number (even zero) of HDDs connected to it. The length of a wire connecting a single HDD to a computer is the absolute value of the distance between their respective coordinates on the infinite line. We consider the total length of wire used to connect all the HDDs to computers to be the sum of the lengths of all the wires used to connect HDDs to computers. Note that both the primary and secondary HDDs in a pair must connect to the same computer.

Given the locations of [expression] computers in such a way that the total length of wire needed to connect each pair of HDDs to computers is minimal. Then print the total length on a new line.
----------
TOP SOLUTION:
----------
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cassert&gt;
#include &lt;ctime&gt;
#include &lt;map&gt;
#include &lt;math.h&gt;
#include &lt;cstdio&gt;
#include &lt;set&gt;
#include &lt;deque&gt;
#include &lt;memory.h&gt;
#include &lt;queue&gt;
#include &lt;unordered_map&gt;

#pragma comment(linker, "/STACK:64000000")
typedef long long ll;

using namespace std;

const int MAXN = 1 &lt;&lt; 18;
const int MOD = 1; // 1000 * 1000 * 1000 + 7;
const ll INF = (ll)(1e18);

int n, k, m;
vector&lt;int&gt; a, b, vct;
vector&lt;vector&lt;ll&gt; &gt; dp;
vector&lt;vector&lt;int&gt; &gt; id[2];

vector&lt;pair&lt;int, int&gt; &gt; t[2][MAXN * 2];
vector&lt;int&gt; tt[2][MAXN * 2];
vector&lt;ll&gt; s[2][MAXN * 2];

void make(int tp, int v) {
	s[tp][v].resize(t[tp][v].size());
	for (int i = 0; i &lt; (int)t[tp][v].size(); i++) {
		s[tp][v][i] = (i ? s[tp][v][i - 1] : 0) + t[tp][v][i].second;
	}
	tt[tp][v].resize(t[tp][v].size());
	for (int i = 0; i &lt; (int)t[tp][v].size(); i++) {
		tt[tp][v][i] = t[tp][v][i].first;
	}
}

void build(int tp, int v, int tl, int tr) {
	t[tp][v].clear();
	if (tl == tr) {
		t[tp][v].reserve(id[tp][tl].size());
		for (int r : id[tp][tl]) {
			if (tp == 0) {
				t[tp][v].push_back(make_pair(vct[a[r]] + vct[b[r]], vct[a[r]]));
			}
			else {
				t[tp][v].push_back(make_pair(-vct[a[r]] - vct[b[r]], -vct[b[r]]));
			}
		}
		sort(t[tp][v].begin(), t[tp][v].end());
		make(tp, v);
		return;
	}
	int tm = (tl + tr) &gt;&gt; 1;
	build(tp, v * 2, tl, tm);
	build(tp, v * 2 + 1, tm + 1, tr);
	t[tp][v].resize(t[tp][v * 2].size() + t[tp][v * 2 + 1].size());
	merge(t[tp][v * 2].begin(), t[tp][v * 2].end(), t[tp][v * 2 + 1].begin(), t[tp][v * 2 + 1].end(), t[tp][v].begin());
	make(tp, v);
}

ll coef;
ll get(int tp, int v, int tl, int tr, int l, int r, int x) {
	if (l &gt; r) return 0;
	if (l == tl &amp;&amp; r == tr) {
		//int id = lower_bound(t[tp][v].begin(), t[tp][v].end(), make_pair(x, -(int)(1.1e9))) - t[tp][v].begin();
		int id = lower_bound(tt[tp][v].begin(), tt[tp][v].end(), x) - tt[tp][v].begin();
		return (id &gt; 0) ? (id * coef + s[tp][v][id - 1]) : 0LL;
	}
	int tm = (tl + tr) &gt;&gt; 1;
	return get(tp, v * 2, tl, tm, l, min(r, tm), x) + get(tp, v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, x);
}


unordered_map&lt;ll, ll&gt; mp;

ll cost(int l, int j) {
	if (l &gt; j) return INF;
	ll hh = ((ll)l &lt;&lt; 32) + j;
	if (mp.count(hh)) {
		return mp[hh];
	}
	ll cost = 0;

	coef = -vct[l];
	cost += get(0, 1, 0, m - 1, l, j, vct[l] + vct[j] + 1);

	coef = vct[j];
	cost += get(1, 1, 0, m - 1, l, j, -vct[l] - vct[j]);

	cost *= 2;

	mp[hh] = cost;
	return cost;
}

void rec(int k, int l, int r, int optL, int optR) {
	if (l &gt; r) return;
	int m = (l + r) &gt;&gt; 1;
	int opt = -1;
	for (int i = optL; i &lt;= optR; i++) {
		if (dp[k - 1][i] &gt;= dp[k][m]) continue;
		if (dp[k][m] &gt; dp[k - 1][i] + cost(i, m)) {
			dp[k][m] = dp[k - 1][i] + cost(i, m);
			opt = i;
		}
	}
	rec(k, l, m - 1, optL, opt);
	rec(k, m + 1, r, opt, optR);
}


int main() {
#ifdef _MSC_VER
	freopen("input.txt", "r", stdin);
#endif
	mp.reserve((int)(5e6));

	while (scanf("%d%d", &amp;n, &amp;k) == 2) {
		a.resize(n);
		b.resize(n);
		for (int i = 0; i &lt; n; i++) {
			int x, y;
			scanf("%d%d", &amp;x, &amp;y);
			a[i] = x;
			b[i] = y;
			if (a[i] &gt; b[i]) swap(a[i], b[i]);
		}

		vct.clear();
		for (int i = 0; i &lt; n; i++) {
			vct.push_back(a[i]);
			vct.push_back(b[i]);
		}
		vct.push_back(-1.001e9);
		vct.push_back(1.001e9);
		sort(vct.begin(), vct.end());
		vct.resize(unique(vct.begin(), vct.end()) - vct.begin());

		m = vct.size();

		for (int i = 0; i &lt; n; i++) {
			a[i] = lower_bound(vct.begin(), vct.end(), a[i]) - vct.begin();
			b[i] = lower_bound(vct.begin(), vct.end(), b[i]) - vct.begin();
		}

		id[0].assign(m, vector&lt;int&gt;());
		id[1].assign(m, vector&lt;int&gt;());
		for (int i = 0; i &lt; n; i++) {
			id[0][a[i]].push_back(i);
			id[1][b[i]].push_back(i);
		}
		build(0, 1, 0, m - 1);
		build(1, 1, 0, m - 1);

		ll sum = 0;
		for (int i = 0; i &lt; n; i++) sum += vct[b[i]] - vct[a[i]];

		dp.assign(k + 1, vector&lt;ll&gt;(m, INF));
		dp[0][0] = 0;
		cerr &lt;&lt; clock() / (double)CLOCKS_PER_SEC &lt;&lt; endl;
		for (int i = 1; i &lt;= k; i++) {
			rec(i, 1, m - 1, 0, m - 1);
		}

		ll mn = INF;
		ll ssum = 0;
		int cnt = 0;
		for (int i = m - 1; i &gt;= 0; i--) {
			mn = min(mn, dp[k][i] + 2 * (ssum - 1LL * cnt * vct[i]));
			for (int ii = 0; ii &lt; (int)id[0][i].size(); ii++) {
				int iid = id[0][i][ii];
				cnt++;
				ssum += vct[a[iid]];
			}
		}
		//ll mn = dp[k + 1][m - 1];
		cout &lt;&lt; sum + mn &lt;&lt; endl;
	}
	cerr &lt;&lt; clock() / (double)CLOCKS_PER_SEC &lt;&lt; endl;

	return 0;
}
----------
====================
----------
ALGORITHMS.363
expert
----------
PROBLEM STATEMENT:
Chinese Version
Russian Version

Tom and Derpina have a rectangular shaped chocolate bar with chocolates labeled T, D and U. They want to split the bar into exactly two pieces such that:


Tom's piece can not contain any chocolate labeled D and similarly, Derpina's piece can not contain any chocolate labeled T and U can be used by either of the two.  
All chocolates in each piece must be connected (two chocolates are connected if they share an edge), i.e. the chocolates should form one connected component
The absolute difference between the number of chocolates in pieces should be at most K
After dividing it into exactly two pieces, in any piece, there should not be 4 adjacent chocolates that form a square, i.e. there should not be a fragment like this: 
XX 
XX

----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
using namespace std;

typedef unsigned long long llu;
struct node {
int  num;   // black - white
char a[9];  //the number of the grid even-white odd-black
char no;   //the forbideen color the 0-white 1-black 2-both can
char vwb;  //the valid color 0-white 1-black 2-both 3-neither
char dwb;  //0-dead white (Never can appear a white grid) 1-dead black 3-neither dead
};

int m,n,last,now,pp,un;
llu ans;
char s[10][10];


inline bool operator&lt;(const node &amp;a,const node &amp;b) {
    if (a.no &lt; b.no) {
        return true;
    }
    if (a.no &gt; b.no) {
        return false;
    }
    if (a.dwb &lt; b.dwb) {
        return true;
    }
    if (a.dwb &gt; b.dwb) {
        return false;
    }
    if (a.vwb &lt; b.vwb) {
        return true;
    }
    if (a.vwb &gt; b.vwb) {
        return false;
    }
        if (a.num&lt;b.num) {
            return true;
        }
        if (a.num&gt;b.num) {
            return false;
        }
    for (int i = 0;i &lt; n;++i) {
        if (a.a[i] &lt; b.a[i]) {
            return true;
        }
        if (a.a[i] &gt; b.a[i]) {
            return false;
        }
    }
    return false;
}

map&lt;node,llu&gt; save[2];

inline bool iswhite(int x) {
    return !(x &amp; 1);
}

inline bool isblack(int x) {
    return (x &amp; 1);
}

void makelone(node &amp;temp,int y,int x,int n) {
int i,j,z = (y &lt;&lt; 1) + x;
    temp.a[y] = z;
    z = (y &lt;&lt; 1);
    for (i = y + 1;i &lt; n;++i) {
        if (temp.a[i] == z) {
            break;
        }
    }
    for (j = i,i &lt;&lt;= 1; j &lt; n; ++j) {
        if (temp.a[j] == z) {
            temp.a[j] = i;
        }
    }
    z = (y &lt;&lt; 1) | 1;
    for (i = y + 1;i &lt; n;++i) {
        if (temp.a[i] == z) {
            break;
        }
    }
    for (j = i,i = (i &lt;&lt; 1) | 1;j &lt; n;++j) {
        if (temp.a[j] == z) {
            temp.a[j] = i;
        }
    }

}

void makeunion(node &amp;temp,int x,int y,int n) {
    if (x &lt; y) {
        x ^= y ^= x ^= y;
    }
    for (int i = 0; i &lt; n;++i) {
        if (temp.a[i] == x) {
            temp.a[i] = y;
        }
    }
}


void makewhite(int x,int y,node temp,llu ans,int add) {
bool yes;
int i,j,k,ll,uu;
map&lt;node,llu&gt;::iterator t;

    if ((temp.no == 0) || (temp.dwb == 0))  { 
        return;
    }
    temp.num += add;
    if ((temp.num + un &lt; -pp) || (temp.num - un &gt; pp)) {
        return;
    }
    yes = (temp.dwb == 1);

    if ((x) &amp;&amp; (temp.a[y] == ((y &lt;&lt; 1) | 1))) { //above is the head of black
        for (i = y + 1;i &lt; n;++i) {
            if (temp.a[i] == temp.a[y]) {
                break;
            }
        }
        if (i &gt;= n) {
            if ((temp.vwb != 1) &amp;&amp; (temp.vwb != 2)) { //make black dead
                return;
            }
            yes = true;
        }
    }
    ll = ((y) &amp;&amp; iswhite(temp.a[y - 1]))?temp.a[y - 1]:(-1);
    uu = ((x) &amp;&amp; iswhite(temp.a[y]))?temp.a[y]:(-1);
    k = x?n:(y + 1);
    if (uu &lt; 0) {
        makelone(temp, y,0 ,k);
        if (ll &gt;= 0) {
            temp.a[y] = ll;
        }
    }
    else if ((ll &gt;= 0) &amp;&amp; (ll != uu)) {
        makeunion(temp,ll,uu,k);

    }
    for (i = j = 0;i &lt; k;++i) {
        if ((temp.a[i]== (i&lt;&lt;1)) &amp;&amp; (++j &gt; 1)) {
            break;
        }
    }
    if (j == 1) {
        temp.vwb = ((temp.vwb == 1) || (temp.vwb == 2))?2:0;
    }
    else { //j &gt; 1
        temp.vwb = ((temp.vwb == 1) || (temp.vwb == 2))?1:3;
    }
    temp.dwb = yes?1:3;
    temp.no = ((uu &gt;= 0) &amp;&amp; (y + 1 &lt; n) &amp;&amp; ((temp.a[y + 1] &amp; 1) == 0))?0:2;
    save[now][temp] += ans;

}


void makeblack(int x,int y,node temp,llu ans,int add) {
bool yes;
int i,j,k,ll,uu;
map&lt;node,llu&gt;::iterator t;

    if ((temp.no == 1) || (temp.dwb == 1))  { 
        return;
    }
    temp.num += add;
    if ((temp.num + un &lt; -pp) || (temp.num - un &gt; pp)) {
        return;
    }

    yes = (temp.dwb == 0);
    if ((x) &amp;&amp; (temp.a[y]==(y &lt;&lt; 1))) { //above is the head of white
        for (i = y + 1;i &lt; n;++i) {
            if (temp.a[i] == temp.a[y]) {
                break;
            }
        }
        if (i &gt;= n) {
            if ((temp.vwb != 0) &amp;&amp; (temp.vwb != 2)) { ///make black dead
                return;
            }
            yes = true;
        }
    }

    ll = ((y) &amp;&amp; isblack(temp.a[ y - 1]))?temp.a[y - 1]:(-1);
    uu = ((x) &amp;&amp; isblack(temp.a[y]))?temp.a[y]:(-1);
    k = x?n:(y + 1);
    if (uu &lt; 0) {
        makelone(temp,y,1,k);
        if (ll &gt;= 0) {
            temp.a[y] = ll;
        }
    }
    else if ((ll &gt;= 0) &amp;&amp; (ll != uu)) {
        makeunion(temp,ll,uu,k);
    }
    for (i = j = 0;i &lt; k;++i) {
        if ((temp.a[i]==((i &lt;&lt; 1) | 1)) &amp;&amp; (++j &gt; 1)) {
            break;
        }
    }
    if (j == 1) {
        temp.vwb = ((temp.vwb==0) || (temp.vwb==2))?2:1;
    }
    else { //j&gt;1
        temp.vwb = ((temp.vwb==0) || (temp.vwb==2))?0:3;
    }
    temp.dwb = yes?0:3;
    temp.no = ((uu &gt;= 0) &amp;&amp; (y + 1 &lt; n) &amp;&amp; ((temp.a[ y + 1] &amp; 1) == 1))?1:2;
    save[now][temp] += ans;

}


int main() {
int z;
node temp;
    scanf("%d%d%d",&amp;m,&amp;n,&amp;pp);
    assert(0 &lt;= m &amp;&amp; m &lt;= 8);
    assert(0 &lt;= n &amp;&amp; n &lt;= 8);
    assert(0 &lt;= pp &lt;= m*n);
    memset(temp.a,0,sizeof(temp.a));
    temp.num = 0;
    temp.no = temp.vwb = 2;
    temp.dwb = 3;
    save[0].clear();
    un = 0;
    for (int i  = 0;i &lt; m;++i) {
        scanf("%s",s[i]);
        for (int j = 0; j &lt; n; ++j) {
            if (s[i][j] == 'T') {
                ++temp.num;
            }
            else if (s[i][j] == 'D') {
                --temp.num;
            }
            else {
                ++un;
            }
        }
    }
    save[last = 0][temp] = 1;
    //printf("un = %d\n",un);
    for (int i = 0; i &lt; m; ++i) {
        for (int j = 0; j &lt; n;++j) {
            save[now = 1 ^ last].clear();
            if (s[i][j] == 'U') {
                --un;
            }   
            for (map&lt;node,llu&gt;::iterator t = save[last].begin();t != save[last].end();++t) {
                if (s[i][j] == 'T') {
                    makeblack(i,j,t-&gt;first,t-&gt;second, 0);
                }
                else if (s[i][j] == 'D') {
                    makewhite(i,j,t-&gt;first,t-&gt;second, 0);
                }
                else {
                    makeblack(i,j,t-&gt;first,t-&gt;second, 1);
                    makewhite(i,j,t-&gt;first,t-&gt;second, -1);
                }
            }
            last = now;
        }

    }
    ans = 0;
    //printf("un = %d\n",un);
    assert(un == 0);
    for (map&lt;node,llu&gt;::iterator t = save[last].begin();t != save[last].end();++t) {
        if (t-&gt;first.vwb == 2) {
            assert((t-&gt;first.num &gt;= -pp) &amp;&amp; (t-&gt;first.num &lt;= pp));
            //printf("%d %llu\n",t-&gt;first.num, t-&gt;second);
            ans += t-&gt;second;
        }
    }
    printf("%llu\n",ans);
    return 0;
}
----------
====================
----------
ALGORITHMS.364
easy
----------
PROBLEM STATEMENT:
You will be given an array of integers.  All of the integers except one occur twice.  That one is unique in the array.

Given an array of integers, find and print the unique element.  

For example, [expression].  

Function Description  

Complete the lonelyinteger function in the editor below.  It should return the integer which occurs only once in the input array.  

lonelyinteger has the following parameter(s):  


a: an array of integers  

----------
TOP SOLUTION:
----------
#!/usr/bin/py
def lonelyinteger(a):
    answer = 0
    for x in b:
        if(b.count(x)==1):
            answer=x
            break
    return answer
if __name__ == '__main__':
    a = input()
    b = map(int, raw_input().strip().split(" "))
    print lonelyinteger(b)

----------
====================
----------
ALGORITHMS.365
easy
----------
PROBLEM STATEMENT:
Given two integers, [expression] satisfy the following condition:

[expression]  

For example, if [expression], then 
[expression] 
[expression] 
[expression]  

Our maximum value is [expression].  

Function Description

Complete the maximizingXor function in the editor below.  It must return an integer representing the maximum value calculated.  

maximizingXor has the following parameter(s):


l: an integer, the lower bound, inclusive  
r: an integer, the upper bound, inclusive  

----------
TOP SOLUTION:
----------
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;bitset&gt;
#include &lt;cstdio&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;
#include &lt;numeric&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
/*
 * Complete the function below.
 */
int maxXor(int l, int r) {
    int a=0;
    for (int i=l;i&lt;=r;i++)
        for (int j=i;j&lt;=r;j++)
        a=max(a,(i^j));
        return a;

}

int main() {
    int res;
    int _l;
    cin &gt;&gt; _l;
    
    int _r;
    cin &gt;&gt; _r;
    
    res = maxXor(_l, _r);
    cout &lt;&lt; res;
    
    return 0;
}

----------
====================
----------
ALGORITHMS.366
medium
----------
PROBLEM STATEMENT:
Louise and Richard have developed a numbers game.  They pick a number and check to see if it is a power of [expression] wins the game.  Louise always starts.

Given an initial value, determine who wins the game.

As an example, let the initial value [expression].  She wins the game.

Update If they initially set counter to [expression], Richard wins.  Louise cannot make a move so she loses.

Function Description  

Complete the counterGame function in the editor below.  It should return the winner's name, either Richard or Louise.  

counterGame has the following parameter(s):  


n: an integer to initialize the game counter  

----------
TOP SOLUTION:
----------
def solve(n):
    count = 0

    while n != 1:
        s = bin(n)[2:]
        n = int(s[:-1], 2) if s.count('0') == len(s) - 1 else int(s[1:], 2)
        count += 1

    print 'Richard' if count % 2 == 0 else 'Louise'


def main():
    t = int(raw_input())
    for _ in xrange(t):
        solve(int(raw_input()))


if __name__ == '__main__':
    main()
----------
====================
----------
ALGORITHMS.367
medium
----------
PROBLEM STATEMENT:
An array, [expression], is defined as follows: 


[expression]
[expression] is the symbol for XOR


You will be given a left and right index [expression]. 

For example, [expression]. 

Print the answer to each question.

Function Description  

Complete the xorSequence function in the editor below.  It should return the integer value calculated.  

xorSequence has the following parameter(s):  


l: the lower index of the range to sum  
r: the higher index of the range to sum  

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;fstream&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i &lt; (int)(n); ++i)
#define for1(i, n) for (int i = 1; i &lt;= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i &gt;= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i &lt;= (int)(b); ++i)

using namespace std;

typedef pair&lt;int, int&gt; pii;
typedef vector&lt;int&gt; vi;
typedef vector&lt;pii&gt; vpi;
typedef vector&lt;vi&gt; vvi;
typedef long long i64;
typedef vector&lt;i64&gt; vi64;
typedef vector&lt;vi64&gt; vvi64;

template&lt;class T&gt; bool uin(T &amp;a, T b) { return a &gt; b ? (a = b, true) : false; }
template&lt;class T&gt; bool uax(T &amp;a, T b) { return a &lt; b ? (a = b, true) : false; }

i64 xorp(i64 x) {
    i64 ans = 0;
    while (x) {
        if (x % 4 == 3) break;
        ans ^= x;
        --x;
    }
    return ans;
}

i64 xorpp(i64 x) {
    i64 ans = 0;
    while (x) {
        if (x % 8 == 7) break;
        ans ^= xorp(x);
        --x;
    }
    return ans;
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout &lt;&lt; fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int q;
    cin &gt;&gt; q;
    forn(i, q) {
        i64 l, r;
        cin &gt;&gt; l &gt;&gt; r;
        cout &lt;&lt; (xorpp(r) ^ xorpp(l - 1)) &lt;&lt; '\n';
    }

#ifdef LOCAL_DEFINE
    cerr &lt;&lt; "Time elapsed: " &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.368
easy
----------
PROBLEM STATEMENT:
Given an integer [expression] such that:


[expression]
[expression]


where [expression]'s satisfying the criteria.

For example, if [expression], there are four values:  


[expression]
[expression]
[expression]
[expression].  


Function Description

Complete the sumXor function in the editor below.  It should return the number of values determined, as an integer.  

sumXor has the following parameter(s): 
- n: an integer  
----------
TOP SOLUTION:
----------
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;
#include &lt;cstdio&gt;
#include &lt;limits&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_map&gt;

using namespace std;


int main(){
    long long n;
    scanf("%lld", &amp;n);
    long long res=1;
    while(n){
        if(n%2 == 0) res *= 2;
        n /= 2;
    }
    printf("%lld", res);
    return 0;
}

----------
====================
----------
ALGORITHMS.369
medium
----------
PROBLEM STATEMENT:
Given a long integer [expression] satisfying the following conditions:  


[expression]
[expression]


where [expression] is the bitwise XOR operator.  

You are given [expression] satisfying the conditions above on a new line.

For example, you are given the value [expression].  The following tests are run:  

[expression] 
[expression] 
[expression] 
[expression]   

We find that there are [expression].  

Function Description  

Complete the theGreatXor function in the editor below.  It should return an integer that represents the number of values satisfying the constraints.  

theGreatXor has the following parameter(s):


x: an integer  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ll&gt; vl;
typedef pair&lt;int,int&gt; pii;
typedef pair&lt;ll,ll&gt; pll;

typedef int _loop_int;
#define REP(i,n) for(_loop_int i=0;i&lt;(_loop_int)(n);++i)
#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i&lt;(_loop_int)(b);++i)
#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i&gt;=(_loop_int)(a);--i)

#define DEBUG(x) cout&lt;&lt;#x&lt;&lt;": "&lt;&lt;x&lt;&lt;endl
#define DEBUG_VEC(v) cout&lt;&lt;#v&lt;&lt;":";REP(i,v.size())cout&lt;&lt;" "&lt;&lt;v[i];cout&lt;&lt;endl
#define ALL(a) (a).begin(),(a).end()

#define CHMIN(a,b) a=min((a),(b))
#define CHMAX(a,b) a=max((a),(b))

// mod
const ll MOD = 1000000007ll;
#define FIX(a) ((a)%MOD+MOD)%MOD

// floating
typedef double Real;
const Real EPS = 1e-11;
#define EQ0(x) (abs(x)&lt;EPS)
#define EQ(a,b) (abs(a-b)&lt;EPS)
typedef complex&lt;Real&gt; P;

int main(){
    int q;
    scanf("%d",&amp;q);
    while(q--){
        ll n;
        scanf("%lld",&amp;n);
        ll b = 1;
        ll ans = 0;
        while(b &lt; n){
            if(!(b&amp;n)){
                ans += b;
            }
            b&lt;&lt;=1;
        }
        printf("%lld\n",ans);
    }
  return 0;
}

----------
====================
----------
ALGORITHMS.370
easy
----------
PROBLEM STATEMENT:
You will be given a list of 32 bit unsigned integers. Flip all the bits ([expression]) and print the result as an unsigned integer.  

For example, your decimal input [expression].  We're working with 32 bits, so:  

[expression] 
[expression]  

Function Description

Complete the flippingBits function in the editor below.  It should return the unsigned decimal integer result.  

flippingBits has the following parameter(s):


n: an integer

----------
TOP SOLUTION:
----------
for _ in xrange(input()):
    print input() ^ (2 ** 32 - 1)
----------
====================
----------
ALGORITHMS.371
medium
----------
PROBLEM STATEMENT:
You are given [expression]. 

Find the permutation with the minimum possible score and print its score.

Note: [expression] is the exclusive-OR (XOR) operator.
----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class A {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	void solve()
	{
		int n = ni();
		int[] a = na(n);
		for(int d = 30;d &gt;= 0;d--){
			int ct = 0;
			for(int v : a){
				ct += v&gt;&gt;&gt;d&amp;1;
			}
			if(ct == 0 || ct == n)continue;
			int min = Integer.MAX_VALUE;
			for(int i = 0;i &lt; n;i++){
				for(int j = 0;j &lt; n;j++){
					if(a[i]&lt;&lt;~d&lt;0 &amp;&amp; a[j]&lt;&lt;~d&gt;=0){
						min = Math.min(min, a[i]^a[j]);
					}
				}
			}
			out.println(min);
			return;
		}
		out.println(0);
	}
	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new A().run(); }
	
	private byte[] inbuf = new byte[1024];
	private int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.372
medium
----------
PROBLEM STATEMENT:
Sansa has an array. She wants to find the value obtained by XOR-ing the contiguous subarrays, followed by XOR-ing the values thus obtained. Determine this value.  

For example, if [expression]: 

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



Now we take the resultant values and XOR them together:

[expression]  

Function Description  

Complete the sansaXor function in the editor below.  It should return an integer that represents the results of the calculations.  

sansaXor has the following parameter(s):  


arr:  an array of integers  

----------
TOP SOLUTION:
----------
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;limits&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
using namespace std;

#define pairii pair&lt;int, int&gt;
#define llong long long
#define pb push_back
#define sortall(x) sort((x).begin(), (x).end())
#define INFI  numeric_limits&lt;int&gt;::max()
#define INFLL numeric_limits&lt;llong&gt;::max()
#define INFD  numeric_limits&lt;double&gt;::max()
#define FOR(i,s,n) for (int (i) = (s); (i) &lt; (n); (i)++)
#define FORZ(i,n) FOR((i),0,(n))

void solve() {
  int n;
  scanf("%d",&amp;n);
  int res = 0;
  FORZ(i,n) {
    int x;
    scanf("%d",&amp;x);
    if ((i+1)%2 &amp;&amp; (n-i)%2) {
      res ^= x;
    }
  }
  printf("%d\n",res);
}

int main() {
#ifdef DEBUG
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  int t;
  scanf("%d",&amp;t);
  FORZ(i,t) solve();
  return 0;
}

----------
====================
----------
ALGORITHMS.373
medium
----------
PROBLEM STATEMENT:
Consider two non-negative long integers, [expression] is the bitwise AND operator. 

Given [expression].

For example, if [expression].  

Function Description  

Complete the andProduct in the editor below.  It should return the computed value as an integer.  

andProduct has the following parameter(s):  


a: an integer  
b: an integer  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef unsigned long long ll;
ll a, b, o = 1;

bool all(ll x, ll a, ll b) {
	return (a&amp;x) &amp;&amp; (b&amp;x) &amp;&amp; (b - a) &lt; x;
}

int main() {
	int T; scanf("%d", &amp;T); for(int ks = 1; ks &lt;= T; ++ks) {
		scanf("%llu%llu", &amp;a, &amp;b);
		ll bb = 0;
		for(int i = 0; i &lt; 63; ++i) {
			ll t = o &lt;&lt; i;
			if(all(t, a, b)) bb |= t;
		}
		printf("%llu\n", bb);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.374
medium
----------
PROBLEM STATEMENT:
The SuperBowl Lottery is about to commence, and there are several lottery tickets being sold, and each ticket is identified with a ticket ID. In one of the many winning scenarios in the Superbowl lottery, a winning pair of tickets is:


Concatenation of the two ticket IDs in the pair, in any order, contains each digit from [expression] at least once.


For example, if there are [expression] is a winning pair. 

NOTE: The ticket IDs can be concantenated in any order. Digits in the ticket ID can occur in any order. 

Your task is to find the number of winning pairs of distinct tickets, such that concatenation of their ticket IDs (in any order) makes for a winning scenario. Complete the function winningLotteryTicket which takes a string array of ticket IDs as input, and return the number of winning pairs. 
----------
TOP SOLUTION:
----------
SOLUTION NOT FOUND
----------
====================
----------
ALGORITHMS.375
hard
----------
PROBLEM STATEMENT:
An XOR operation on a list is defined here as the xor ([expression]). 

The [expression] can be expressed as:

[expression]     

For example: Given set [expression]


The set of possible non-empty subsets is: [expression]     
The [expression] of these non-empty subsets is then calculated as follows: 
[expression]


Given a list of [expression].    

For example, [expression].  

Note: The cardinality of powerset[expression] subsets.

Function Description  

Complete the xoringNinja function in the editor below.  It should return an integer that represents the XorSum of the input array, modulo [expression].  

xoringNinja has the following parameter(s):  


arr: an integer array

----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;bitset&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cctype&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;utility&gt;

using namespace std;

#define MAXN 100005
#define MOD 1000000007

int T, N;
int A[MAXN];
long long dp[MAXN][2];

int main() {
//	freopen("date.in", "r", stdin);
	
	cin &gt;&gt; T;
	while(T--) {
        cin &gt;&gt; N;
        for(int i = 0; i &lt; N; i++)
            cin &gt;&gt; A[i];
        
        long long ans = 0;
        for(int bit = 0; bit &lt; 32; bit++) {
            memset(dp, 0, sizeof(dp)); 
            dp[0][0] = 1;
            dp[0][1] = 0;
            for(int i = 0; i &lt; N; i++) {
                int crt = 0;
                if(A[i] &amp; (1 &lt;&lt; bit))
                    crt = 1;
                for(int j = 0; j &lt; 2; j++) {
                    int nj = j ^ crt;
                    dp[i + 1][nj] += dp[i][j];
                    dp[i + 1][j] += dp[i][j];
                    dp[i + 1][nj] %= MOD;
                    dp[i + 1][j] %= MOD;
                }
            }
            long long cnt = dp[N][1];
            ans += cnt * (1LL &lt;&lt; bit);
            ans %= MOD;
        }
        
        cout &lt;&lt; ans &lt;&lt; '\n';
	}
	
	return 0;
}

----------
====================
----------
ALGORITHMS.376
medium
----------
PROBLEM STATEMENT:
Jack and Daniel are friends.  They want to encrypt their conversations so that they can save themselves from interception by a detective agency so they invent a new cipher.  

Every message is encoded to its binary representation. Then it is written down [expression] bits. Each of the columns is XORed together to get the final encoded string.

If [expression] it looks like so:  

1001011     shift 0 
01001011    shift 1
001001011   shift 2
0001001011  shift 3
----------
1110101001  &lt;- XORed/encoded string s


Now we have to decode the message.  We know that [expression] position of the original string.  Continue with that logic until the end.

Then the encoded message [expression] are sent to Daniel.   

Jack is using this encoding algorithm and asks Daniel to implement a decoding algorithm. 
Can you help Daniel implement this?  

Function Description  

Complete the cipher function in the editor below.  It should return the decoded string.  

cipher has the following parameter(s):  


k: an integer that represents the number of times the string is shifted 
s: an encoded string of binary digits

----------
TOP SOLUTION:
----------
def xor(a,b):
	if int(a)==int(b): return 0
	else: return 1
def rev_xor(a,b):
	if int(a)==int(b): return 1
	else: return 0

n, k = map(int, raw_input().split())
code = raw_input()
res = int(code[0])
msg = [res]
rev = res
i=1
while i&lt;k and i&lt;n:
	new_res = xor(res, code[i])
	msg.append(new_res)
	res = xor(res, msg[i])
	i+=1
i=0
if n&gt;k:
	while i+k&lt;n:
		res = xor(res, msg[i])
		new_res2 = xor(res, code[i+k])
		msg.append(new_res2)
		i+=1
		res = xor(res, msg[-1])
print "".join(str(x) for x in msg)
----------
====================
----------
ALGORITHMS.377
hard
----------
PROBLEM STATEMENT:
Consider a zero-indexed matrix with [expression] columns, where each row is filled gradually. Given the first row of the matrix, you can generate the elements in the subsequent rows using the following formula:


[expression]
[expression]


Each row is generated one by one, from the second row through the last row. Given the first row of the matrix, find and print the elements of the last row as a single line of space-separated integers.

Note: The [expression] operator denotes bitwise XOR.
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;ctype.h&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;random&gt;
#include &lt;unordered_map&gt;
#include &lt;stdio.h&gt;

using namespace std;

typedef long long ll;
typedef std::vector&lt;int&gt; vi;
typedef std::vector&lt;bool&gt; vb;
typedef std::vector&lt;string&gt; vs;
typedef std::vector&lt;double&gt; vd;
typedef std::vector&lt;long long&gt; vll;
typedef std::vector&lt;std::vector&lt;int&gt; &gt; vvi;
typedef vector&lt;vvi&gt; vvvi;
typedef vector&lt;vll&gt; vvll;
typedef std::vector&lt;std::pair&lt;int, int&gt; &gt; vpi;
typedef vector&lt;vpi&gt; vvpi;
typedef std::pair&lt;int, int&gt; pi;
typedef std::pair&lt;ll, ll&gt; pll;
typedef std::vector&lt;pll&gt; vpll;

const long long mod = 1000000007;

#define all(c) (c).begin(),(c).end()
#define sz(c) (int)(c).size()
#define forn(i, a, b) for(int i = a; i &lt; b; i++)

#define pb push_back
#define mp make_pair

int main()
{

    int n;
    ll m;
    scanf("%d %lld", &amp;n, &amp;m);
    m--;
    vi a(n);
    vll d2(1,1);
    forn(i,0,60) d2.pb(d2.back()*2);
    forn(i,0,n) scanf("%d", &amp;a[i]);
    for(int bit = 60; bit&gt;=0; bit--) {
        if(m&gt;=d2[bit]) {
            vi b(n);
            forn(i,0,n) {
                
                b[i] = a[i]^a[((ll)i+d2[bit])%n];
                
            }
            a=std::move(b);
            m-=d2[bit];
        }
    }
    forn(i,0,n) printf("%d ", a[i]);
    
    
}



----------
====================
----------
ALGORITHMS.378
medium
----------
PROBLEM STATEMENT:
Johnny is playing with a large binary number, [expression].       

For example, suppose we have array [expression], as shown in this diagram:



When we assemble the sequential alternating sequences of [expression].

We define setCount([expression]).

Johnny isn't sure how to solve the problem. Given array [expression] as a single line of space-separated integers.
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

int main()
{
  int T;
  scanf("%d", &amp;T);
  for (int testcase = 0; testcase &lt; T; testcase++)
  {
    int n;
    scanf("%d", &amp;n);
    vector&lt;long long&gt; dat(n);
    for (int i = 0; i &lt; n; i++) {
      scanf("%lld", &amp;dat[i]);
    }
    vector&lt;long long&gt; ans;
    if (n == 1) {
      ans.push_back(1);
      ans.push_back(1);
      ans.push_back(dat[0] - 1);
    }
    else if (n == 2) {
      ans.push_back(1);
      ans.push_back(1 + dat[1]);
      ans.push_back(dat[0] - 1);
    }
    else if (n % 2 == 0) {
      for (int i = 0; i &lt; n - 3; i++) {
        ans.push_back(dat[i]);
      }
      ans.push_back(dat[n - 3] - 1);
      ans.push_back(1);
      ans.push_back(1 + dat[n - 1]);
      ans.push_back(dat[n - 2] - 1);
    }
    else {
      for (int i = 0; i &lt; n - 2; i++) {
        ans.push_back(dat[i]);
      }
      ans.push_back(dat[n - 2] - 1);
      ans.push_back(1);
      ans.push_back(1);
      ans.push_back(dat[n - 1] - 1);
    }
    for (;;)
    {
      vector&lt;long long&gt; res;
      for (int i = 0; i &lt; ans.size(); i++)
      {
        long long v = ans[i];
        if (v == 0) {
          if (i + 1 &lt; ans.size()) {
            res.back() += ans[i + 1];
            i++;
          }
          continue;
        }
        res.push_back(v);
      }
      if (res == ans)
        break;
      ans = res;
    }
    printf("%d\n", (int)ans.size());
    for (int i = 0; i &lt; ans.size(); i++) {
      printf("%lld%c", ans[i], " \n"[i + 1 == ans.size()]);
    }
  }
  return 0;
}
----------
====================
----------
ALGORITHMS.379
hard
----------
PROBLEM STATEMENT:
Bob has received a binary string of length N transmitted by Alice. He knows that due to errors in transmission, up to K bits might have been corrupted (and hence flipped). However, he also knows that the string Alice had intended to transmit was not periodic. A string is not periodic if it cannot be represented as a smaller string concatenated some number of times. For example, "0001", "0110" are not periodic while "00000", "010101" are periodic strings.

Now he wonders how many possible strings could Alice have transmitted.
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int mod = 1000000007;

#define MAXN 1005

int T, N, K;
char b[ MAXN ];

int c[ MAXN ][ MAXN ];
int cnt[ MAXN ][ 2 ];
int dp[ MAXN ];
int p[ MAXN ];

int main( void )
{
  scanf( "%d", &amp;T );

  for( int i = 0; i &lt; MAXN; ++i ) {
    for( int j = 0; j &lt; MAXN; ++j ) {
      if( j &gt; i ) continue;
      if( i == 0 ) { c[i][j] = 1; continue; }
      c[i][j] = c[i-1][j] + c[i-1][j-1];
      if( c[i][j] &gt; mod ) c[i][j] -= mod;
    }
  }

  while( T-- ) {
    scanf( "%d%d", &amp;N, &amp;K );
    scanf( "%s", b );

    for( int i = 1; i &lt; N; ++i )
      p[i] = 0;

    int periodic = 0;

    for( int i = 1; i &lt; N; ++i ) {
      if( N % i != 0 ) continue;

      for( int j = 0; j &lt; i; ++j ) 
	cnt[j][0] = cnt[j][1] = 0;

      for( int j = 0; j &lt; N; ++j )
	cnt[j%i][1-b[j]+'0']++;

      for( int j = 0; j &lt;= K; ++j )
	dp[j] = 1;

      for( int j = 0; j &lt; i; ++j ) {
	for( int k = K; k &gt;= 0; --k ) {
	  dp[k] = ( !cnt[j][0] || !cnt[j][1] ) ? dp[k] : 0;
	  if( k &gt;= cnt[j][0] &amp;&amp; cnt[j][0] ) dp[k] += dp[k-cnt[j][0]];
	  if( k &gt;= cnt[j][1] &amp;&amp; cnt[j][1] ) dp[k] += dp[k-cnt[j][1]];
	  if( dp[k] &gt; mod ) dp[k] -= mod;
	}
      }

      p[i] = dp[K];

      for( int j = 1; j &lt; i; ++j ) {
	if( i % j == 0 ) p[i] = p[i] + mod - p[j];
	if( p[i] &gt; mod ) p[i] -= mod;
      }

      periodic += p[i];
      if( periodic &gt;= mod ) periodic -= mod;
    }

    int total = 0;

    for( int i = 0; i &lt;= K; ++i ) {
      total += c[N][i];
      if( total &gt;= mod ) total -= mod;
    }

    int Sol = total - periodic + mod;
    if( Sol &gt;= mod ) Sol -= mod;

    printf( "%d\n", Sol );
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.380
medium
----------
PROBLEM STATEMENT:
Consider four numbers: [expression]. Here, the | symbol denotes the bitwise OR operation.

Given [expression] as small as possible. 

Notes: 


[expression] is given in decimal (base 10).
If the number of bits changed in [expression].

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define rep(i, from, to) for (int i = from; i &lt; (to); ++i)
#define trav(a, x) for (auto&amp; a : x)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
typedef vector&lt;int&gt; vi;
void PR(vi &amp;v) { trav(x, v) cout &lt;&lt; x &lt;&lt; ' '; cout &lt;&lt; endl; }

void unhex(char&amp; c) {
	if (0 &lt;= c &amp;&amp; c &lt; 10) c = (char)('0' + c);
	else c = (char)('A' + (c - 10));
}

void rehex(char&amp; c) {
	if ('0' &lt;= c &amp;&amp; c &lt;= '9') c = (char)(c - '0');
	else c = (char)(c - 'A' + 10);
}

string trim0(string&amp; s) {
	trav(x, s) unhex(x);
	rep(i,0,sz(s)) {
		if (s[i] != '0') return s.substr(i);
	}
	return "0";
}

bool solve() {
	int K, N;
	string a, b, c;
	cin &gt;&gt; K;
	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
	N = max(max(sz(a), sz(b)), sz(c));
	a = string(N-sz(a), '0') + a;
	b = string(N-sz(b), '0') + b;
	c = string(N-sz(c), '0') + c;
	trav(x, a) rehex(x);
	trav(x, b) rehex(x);
	trav(x, c) rehex(x);
	int bits[4] = {8,4,2,1};

	rep(i,0,N) trav(bi, bits) {
		if (!(c[i]&amp;bi)) {
			if (a[i]&amp;bi) {
				a[i] &amp;= ~bi;
				--K;
			}
			if (b[i]&amp;bi) {
				b[i] &amp;= ~bi;
				--K;
			}
		}
		else {
			if (!((a[i]&amp;bi) || (b[i]&amp;bi))) {
				b[i] |= bi;
				--K;
			}
		}
	}

	if (K &lt; 0) return false;

	rep(i,0,N) trav(bi, bits) {
		if (c[i]&amp;bi) {
			if ((a[i]&amp;bi) &amp;&amp; (b[i]&amp;bi) &amp;&amp; K &gt;= 1) {
				a[i] &amp;= ~bi;
				K--;
			}
			else if ((a[i]&amp;bi) &amp;&amp; K &gt;= 2) {
				a[i] &amp;= ~bi;
				b[i] |= bi;
				K -= 2;
			}
		}
	}

	cout &lt;&lt; trim0(a) &lt;&lt; endl;
	cout &lt;&lt; trim0(b) &lt;&lt; endl;
	return true;
}

int main() {
	cin.sync_with_stdio(false);
	cin.exceptions(cin.failbit);
	int N;
	cin &gt;&gt; N;
	rep(i,0,N) {
		if (!solve()) cout &lt;&lt; -1 &lt;&lt; endl;
	}
}

----------
====================
----------
ALGORITHMS.381
hard
----------
PROBLEM STATEMENT:
Suppose that [expression] is a permutation of these numbers, we say B is K-Manipulative if and only if:

[expression] represents the XOR operator.

You are given [expression].

Input:

The first line is an integer [expression].  

Output: 
The largest possible [expression] if there is no solution.

Constraints:  


[expression] 
[expression] 

----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;complex&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;fstream&gt;
#include &lt;numeric&gt;
#include &lt;string&gt;
#include &lt;valarray&gt;
#define int long long

using namespace std;

typedef pair&lt;int,int&gt; Pair;

template&lt;class t&gt;
ostream &amp; operator &lt;&lt; (ostream &amp; tout,const vector&lt;t&gt; &amp;s){
  tout&lt;&lt;'[';
  for (int i=0;i&lt;s.size();i++)
    if (i+1 == s.size())
      tout&lt;&lt;s[i];
    else
      tout&lt;&lt;s[i]&lt;&lt;',';
  tout&lt;&lt;']';
  return(tout);
}

template&lt;class a,class b&gt;
ostream &amp; operator &lt;&lt; (ostream &amp; tout,const pair&lt;a,b&gt; &amp;c){
  return(tout&lt;&lt;'('&lt;&lt;c.first&lt;&lt;','&lt;&lt;c.second&lt;&lt;')');
}

template&lt;class T&gt; struct __set__print{
  __set__print(ostream&amp; out) : tout(out), count(0) {}
  void operator() (T x) { 
    if (count &gt; 0)
      tout&lt;&lt;',';
    tout&lt;&lt;x;
    ++count; 
  }
  ostream&amp; tout;
  int count;
};

template&lt;class T&gt;
ostream &amp; operator &lt;&lt; (ostream &amp; tout,const set&lt;T&gt; &amp;s){
  tout&lt;&lt;'{';
  for_each(s.begin(),s.end(),__set__print&lt;T&gt;(tout));
  return(tout&lt;&lt;'}');
}

template&lt;class T,class Q&gt; struct print_map{
  print_map(ostream&amp; out) : tout(out), count(0) {}
  void operator() (const pair&lt;T,Q&gt; &amp;x) { 
    if (count &gt; 0)
      tout&lt;&lt;',';
    tout&lt;&lt;'('&lt;&lt;x.first&lt;&lt;" =&gt; "&lt;&lt;x.second&lt;&lt;')';
    ++count; 
  }
  ostream&amp; tout;
  int count;
};

template&lt;class T,class Q&gt;
ostream &amp; operator &lt;&lt; (ostream &amp; tout,map&lt;T,Q&gt; s){
  tout&lt;&lt;'{';
  for_each(s.begin(),s.end(),print_map&lt;T,Q&gt;(tout));
  return(tout&lt;&lt;'}');
}

template&lt;class T&gt;
string to_string(T s){
  stringstream tin;
  tin&lt;&lt;s;
  string res;
  getline(tin,res);
  return(res);
}


template&lt;class T&gt;
vector&lt;T&gt; to_vector(T *s,int n){
  vector&lt;T&gt; result;
  for (int i=0;i&lt;n;i++)
    result.push_back(s[i]);
  return(result);
}

// *********************************** MY CODE ***************************

const int MAX_N = 100+20;

int n,num[MAX_N];


bool good(int k){
  map&lt;int,int&gt; mp;
  for (int i=1;i&lt;=n;i++)
    mp[num[i]&gt;&gt;k]++;
  for (map&lt;int,int&gt; :: iterator i=mp.begin();i!=mp.end();i++)
    if (i-&gt;second*2 &gt; n)
      return(false);
  return(true);
}

#undef int
int main(){
#define int long long
  ios_base::sync_with_stdio(false) ;

  cin&gt;&gt;n;
  for (int i=1;i&lt;=n;i++)
    cin&gt;&gt;num[i];

  int biggest = 40;
  while (!good(biggest) &amp;&amp; biggest &gt;= 0)
    biggest--;
  cout&lt;&lt;biggest&lt;&lt;endl;
}
----------
====================
----------
ALGORITHMS.382
hard
----------
PROBLEM STATEMENT:
Alice and Bob are playing the game of Nim with [expression].

Since Bob already knows who will win (assuming optimal play), he decides to cheat by removing some stones in some piles before the game starts. However, to reduce the risk of suspicion, he must keep at least one pile unchanged. Your task is to count the number of ways Bob can remove the stones to force Alice into losing the game. Since the number can be very large, output the number of ways modulo [expression]. Assume that both players will try to optimize their strategy and try to win the game.
----------
TOP SOLUTION:
----------
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;complex&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;string&gt;
#include&lt;cstdlib&gt;
#include&lt;memory.h&gt;
#include&lt;ctime&gt;

using namespace std;


typedef long double ld;

typedef long long ll;
typedef pair&lt;int,int&gt;	pii;
typedef pair&lt;ld,ld&gt;	pdd;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ld&gt; vd;
typedef pair&lt;ll,ll&gt; pl;

#define FOR(i,a,b)		for(int i=(a);i&lt;(b);i++)
#define REP(i,n)		FOR(i,0,n)
#define SORT(v)			sort((v).begin(),(v).end())
#define UN(v)			SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b)			memset(a,b,sizeof a)
#define pb				push_back

const int mod = 1000000007;

int n;
int a[111],b[111];
void add(ll &amp;x,ll v){
	x+=v;
	x%=mod;
}
ll r[111][2];

ll qp(ll c,ll st){
	ll r = 1;
	while(st){
		if(st&amp;1)r*=c,r%=mod;
		c*=c,c%=mod;
		st&gt;&gt;=1;
	}
	return r;
}

int solve(){
	ll res = 0;
	for(int pos=30;pos&gt;=0;pos--){
		vi v;
		REP(j,n)if(a[j]&amp;(1&lt;&lt;pos))v.pb(j);

		CL(r,0);
		r[0][0] = 1;
		REP(j,n)REP(t,2)if(r[j][t]){
			ll val = r[j][t];
			if(a[j]&amp;(1&lt;&lt;pos)){
				add(r[j+1][t], val * (1&lt;&lt;pos));
				add(r[j+1][t^1], val * (a[j] - (1&lt;&lt;pos) + 1));
			}else{
				add(r[j+1][t], val * (a[j]+1));
			}
		}
		//cout&lt;&lt;"start "&lt;&lt;pos&lt;&lt;" -&gt; "&lt;&lt;res&lt;&lt;' '&lt;&lt;r[n][0]&lt;&lt;endl;
		res += r[n][0] * qp((1&lt;&lt;pos),mod-2);
		res %= mod;
		//cout&lt;&lt;"add "&lt;&lt;res&lt;&lt;endl;
		if(v.size()%2==0){
			ll t = 1;

			REP(j,n)if(a[j]&amp;(1&lt;&lt;pos)) t=(t*(a[j]-(1&lt;&lt;pos)+1))%mod;//,cout&lt;&lt;"mult1 "&lt;&lt;a[j]-(1&lt;&lt;pos)+1&lt;&lt;endl;
			else t=(t*(a[j]+1))%mod;//,cout&lt;&lt;"mult2 "&lt;&lt;a[j]+1&lt;&lt;endl;
			//cout&lt;&lt;t&lt;&lt;endl;
			t *= qp((1&lt;&lt;pos),mod-2);
			t%=mod;
		//	cout&lt;&lt;pos&lt;&lt;' '&lt;&lt;t&lt;&lt;endl;

			res -= t;
			res %= mod;
			if(res&lt;0) res += mod;
		}else return res;

		REP(j,n)if(a[j]&amp;(1&lt;&lt;pos))a[j]^=(1&lt;&lt;pos);
	}
	res++;
	//cout&lt;&lt;"!"&lt;&lt;res&lt;&lt;endl;
	return res;
}

int main(){
#ifdef LocalHost
	freopen("input.txt","r",stdin);
	//freopen("output.txt","w",stdout);
#endif

	cin&gt;&gt;n;
	REP(i,n) cin&gt;&gt;a[i],b[i]=a[i];

	int res = solve();
	REP(i,n) a[i]=b[i]-1;
	res -= solve();
	if(res&lt;0) res += mod;
	cout&lt;&lt;res&lt;&lt;endl;
	//stupid();
	//cout&lt;&lt;rr&lt;&lt;endl;
#ifdef LocalHost
//	printf("TIME: %.3lf\n",ld(clock())/CLOCKS_PER_SEC);
#endif
	return 0;
}

----------
====================
----------
ALGORITHMS.383
advanced
----------
PROBLEM STATEMENT:
Understanding [expression]'s would you write down in all?  

For example, using an [expression].  The two's complement representations for a few numbers are shown below:  

        |Number|                Representation in
Number   Binary     Inverse     Two's Complement
-3      00000011    11111100    11111101
-2      00000010    11111101    11111110
-1      00000001    11111110    11111111
 0      00000000                00000000
 1      00000001                00000001
 2      00000010                00000010
 3      00000011                00000011


To write down that range of numbers' two's complements in [expression] bit representation was chosen to reduce apparent complexity in the example.  

Function Description  

Complete the twosCompliment function in the editor below.  It should return an integer.  

twosCompliment has the following parameter(s): 
- a: an integer, the range minimum 
- b: an integer, the range maximum  
----------
TOP SOLUTION:
----------
// C++

/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;deque&gt;
#include &lt;stack&gt;
#include &lt;bitset&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;

using namespace std;

long long c(long long A)
{
  int ret = 0;
  for (int i = 0; i &lt; 32; i++) {
    ret += (A &amp; (1&lt;&lt;i)) &gt; 0;
  }
  return (long long)ret;
}

int high(long long A)
{
  int i;
  for (i = 32; i &gt;= 0; i--) {
    if((A &amp; (1LL&lt;&lt;i)) != 0)
      return i;
  }
  return 0;
}

long long res(long long A)
{
  assert(A &gt;= 0LL);
  if(A == 0LL) return 0LL;

 // if(A &gt; 1000000LL)
 //   printf("%lld: %d\n", A, high(A));
  fflush(stdout);
  long long h = high(A);

  long long ret;
  if(A == (long long)(1LL &lt;&lt; (h + 1LL)) - 1LL)
  {
    ret = 2LL * res(A &gt;&gt; 1LL) + ((A + 1LL) &gt;&gt; 1LL);
  } else {
    long long mask = (1LL&lt;&lt;h);
    ret = res((1LL &lt;&lt; h)- 1LL) + res(A ^ mask) + (A - (1LL &lt;&lt; h) + 1LL);
  }
  return ret;
}

long long comp2(int a)
{
  long long ret = 0;
  //cout &lt;&lt; "------" &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
  for(int i = 0;i &lt; 32; i++)
  {
    if( (a &amp; (1 &lt;&lt; i)) != 0)
    {
    //  cout &lt;&lt; "1";
      ret += (1LL &lt;&lt; i);
    } else {
     // cout &lt;&lt; "0";
    }
  }
 // cout &lt;&lt; endl &lt;&lt; "--------" &lt;&lt; endl;
  return ret;
}

int main()
{
  int sA,sB;
  long long A, B;
  int N;
  scanf("%d", &amp;N);
  while(N--)
  {
    scanf("%d%d", &amp;sA, &amp;sB);
    A = comp2(sA);
    B = comp2(sB);

    long long ret;
    if(A == 0) {
      ret = res(B);
    } else if(sB &lt; 0) {
      ret = res(B) - res(A) + c(A);
    } else if(sA &lt; 0) {
      ret = res(comp2(-1)) - res(A) + c(A) + res(B);
    } else {
      ret = res(B) - res(A) + c(A);
    }

    printf("%lld\n", ret);
    //cout &lt;&lt; endl;
    //cout &lt;&lt; ret &lt;&lt; endl;
  }

  return 0;
}
----------
====================
----------
ALGORITHMS.384
advanced
----------
PROBLEM STATEMENT:
Let a and b be binary numbers of length n (MSB to the left). The following commands may be performed:


set_a idx x: Set [expression].  
set_b idx x: Set [expression].  
get_c idx: Print [expression].  


Given [expression].  Print an answer string that contains the results of all commands on one line.  A series of commands and their results follow:


Starting 
ans = '' (empty string) 
a   b 
000 111 
set_a 1 1 
010 111 
set_b 0 1 
010 111 
get_c 3 
a + b = 1001 
ans = '1' 
010 111 
get_c 4 
a + b = 01001 
ans = '10' 


Note: When the command is get_c 4, [expression] to be long enough to return a value.  

Function Description  

Complete the changeBits function in the editor below.  For each get_c command, it should print either a 0 or a 1 without a newline until all commands have been processed. At that point, add a newline.   

changeBits has the following parameters: 
- a, b: two integers represented as binary strings 
- queries[queries[0]-queries[n-1]]: an array of query strings in the format described  
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;

using namespace std;

const int maxn = 100010;
int a[maxn], b[maxn], c[maxn];
int n, q;
char ss[maxn*5];
int l[maxn*2], r[maxn*2], s[maxn*2], tn;

int build(int ll, int rr)
{
	if(ll&gt;=rr)
		return -1;
	int ret = tn++;
	if(ll + 1 == rr)
	{
		l[ret] = r[ret] = -1;
		s[ret] = c[ll];
		return ret;
	}
	int mid = (ll + rr) / 2;
	l[ret] = build(ll, mid);
	r[ret] = build(mid, rr);
	s[ret] = (s[l[ret]] == s[r[ret]] ? s[l[ret]] : 2);
	return ret;
}

void init() {
	scanf("%d%d", &amp;n, &amp;q);
	//printf("%d %d\n", n, q);
	memset(c, 0, sizeof(c));
	scanf("%s", ss);
	//printf("%s\n", ss);
	for(int i=0; i&lt;n; ++i) {
		a[i] = c[i] = ss[n - i - 1] - '0';
	}
	scanf("%s", ss);
	//printf("%s\n", ss);
	for(int i=0; i&lt;n; ++i) {
		b[i] = ss[n - 1 - i] - '0';
		c[i] += ss[n - 1 - i] - '0';
		if(c[i] &gt;= 2)
		{
			c[i] -= 2;
			c[i+1] ++;
		}
	}
	a[n] = b[n] = 0;
	//memset(a, 0, sizeof(a));
	//memset(b, 0, sizeof(b));
	//memset(c, 0, sizeof(c));
	n++;
	tn = 0;
	build(0, n);
}

void push_down(int id) {
	if(s[id] == 2)
		return;
	if(l[id] &lt; 0)
		return;
	s[l[id]] = s[r[id]] = s[id];
}

int findright(int id, int ll, int rr, int i, int bit)
{
	if(rr &lt;= i)
		return -1;
	if(s[id] == bit)
		return i &lt; ll ? ll : i;
	if(s[id] == (bit ^ 1))
		return -1;
	push_down(id);
	int mid = (ll + rr) / 2;
	int t = findright(l[id], ll, mid, i, bit);
	if(t &gt;= 0)
		return t;
	return findright(r[id], mid, rr, i, bit);
}

void change(int id, int ll, int rr, int bl, int br, int bit)
{
	if(br &lt;= ll || rr &lt;= bl)
		return;
	if(bl &lt;= ll &amp;&amp; rr &lt;= br)
	{
		s[id] = bit;
		return;
	}
	push_down(id);
	int mid = (ll + rr) / 2;
	change(l[id], ll, mid, bl, br, bit);
	change(r[id], mid, rr, bl, br, bit);
	if(s[l[id]] == s[r[id]])
		s[id] = s[l[id]];
	else
		s[id] = 2;
}

int getbit(int id, int ll, int rr, int i)
{
	if(i&lt;ll || i&gt;=rr)
		return 0;
	if(s[id] &lt; 2)
		return s[id];
	int mid = (ll + rr) / 2;
	if(i &lt; mid)
		return getbit(l[id], ll, mid, i);
	else
		return getbit(r[id], mid, rr, i);
}

void work() {
	int i, bit;
	int pn = 0;
	char cmd[10];
	while(q--) {
		scanf("%s", cmd);
		//printf("%s ", cmd);
		if(cmd[4]=='a' || cmd[4] == 'b')
		{
			scanf("%d%d", &amp;i, &amp;bit);
			//printf("%d %d\n", i, bit);
			if(cmd[4] == 'a' &amp;&amp; a[i] == bit)
				continue;
			if(cmd[4] == 'b' &amp;&amp; b[i] == bit)
				continue;
			if(cmd[4] == 'a') a[i] = bit;
			else b[i] = bit;
			int lmb = findright(0, 0, n, i, bit ^ 1);
			if(lmb == -1)
				lmb = n;
			change(0, 0, n, i, lmb, bit ^ 1);
			change(0, 0, n, lmb, lmb + 1, bit);
		}
		else
		{
			scanf("%d", &amp;i);
			//printf("%d\n", i);
			ss[pn++] = getbit(0, 0, n, i) + '0';
			//printf("%c\n", ss[pn-1]);
		}
	}
	ss[pn] = 0;
	printf("%s\n", ss);
}

int main() {
	init();
	work();
}

----------
====================
----------
ALGORITHMS.385
advanced
----------
PROBLEM STATEMENT:
Xorq has invented an encryption algorithm which uses bitwise XOR operations extensively. This encryption algorithm uses a sequence of non-negative integers [expression]. Help Xorq implement this function.  

For example, [expression] inclusive:

j   x[j]    x[j]^4
1   3       7
2   5       1
3   9       13


Our maximum value is [expression].

Function Description

Complete the xorKey function in the editor below.  It should return an integer array where each value is the response to a query.

xorKey has the following parameters:  


x: a list of integers  
queries: a two dimensional array where each element is an integer array that consists of [expression] respectively.  

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#include &lt;algorithm&gt;
#include &lt;ctime&gt;
using namespace std;

const int MB = 14;
const int N = 100000;
int arr[N], t, n, q, a, b, c;

int sorted_arrs[N * (MB + 2)];
struct XorqNode {
    int child[2], idx, len;
} nodes[512 + N * (MB - 6)]; // 
int arr_cnt, node_cnt;

int split(int idx, int len, int bm, int r) {
    int cnt = 0;
    for(int i = 0; i &lt; len; i ++) {
        if((bm &amp; arr[sorted_arrs[i + idx]]) == r) {
            sorted_arrs[arr_cnt++] = sorted_arrs[i + idx];
            cnt ++;
        }
    }
    return cnt;
}

void build(int root, int idx, int len, int bit = MB) {
    nodes[root].idx = idx;
    nodes[root].len = len;
    if(bit == -1) return;
    int bm = (1 &lt;&lt; bit);
    int sidx1 = arr_cnt;
    int left_cnt = split(idx, len, bm, 0);
    int sidx2 = arr_cnt;
    int right_cnt = split(idx, len, bm, bm);
    assert(left_cnt + right_cnt == len);
    if(left_cnt) {
        nodes[root].child[0] = node_cnt;
        build(node_cnt ++, sidx1, left_cnt, bit - 1);
    } else {
        nodes[root].child[0] = -1;
    }
    if(right_cnt) {
        nodes[root].child[1] = node_cnt;
        build(node_cnt ++, sidx2, right_cnt, bit - 1);
    } else {
        nodes[root].child[1] = -1;
    }
}

bool search(int root, int from, int to) {
    int left = nodes[root].idx;
    int right = left + nodes[root].len - 1;
    int r = N;
    while(left &lt;= right) {
        int mid = (left + right) / 2;
        int val = sorted_arrs[mid];
        if(val &gt;= from) {
            r = val;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return r &lt;= to;
}

int query(int root, int n, int from, int to, int bit = MB) {
    if(bit == -1) return 0;
    int mybit = ((1 &lt;&lt; bit) &amp; n) ? 1 : 0;
    if(nodes[root].child[1 - mybit] != -1 &amp;&amp; search(nodes[root].child[1 - mybit], from, to)) {
        return query(nodes[root].child[1 - mybit], n, from, to, bit - 1) + (1 &lt;&lt; bit);
    } else {

        return query(nodes[root].child[mybit], n, from, to, bit - 1);
    }
}

int query2(int n, int from, int to) {
    int r = 0;
    for(int i = from; i &lt;= to; i ++) {
        r = max(r, arr[i] ^ n);
    }
    return r;
}

int main() {
    int cl = clock();
    int err_cnt = 0;
    for(scanf("%d", &amp;t); t--; ) {
        arr_cnt = node_cnt = 0;
        scanf("%d %d", &amp;n, &amp;q);
        for(int i = 0; i &lt; n; i ++) {
            scanf("%d", &amp;arr[i]);
        }
        for(int i = 0; i &lt; n; i ++) {
            sorted_arrs[arr_cnt++] = i;
        }
        node_cnt = 1;
        build(0, 0, n);
        for(int i = 0; i &lt; q; i ++) {
            scanf("%d %d %d", &amp;a, &amp;b, &amp;c);
            int r1 = query(0, a, b - 1, c - 1);
            cout &lt;&lt; r1 &lt;&lt; endl;
        }
    }
    //cerr &lt;&lt; (clock() - cl) * 0.001 &lt;&lt; endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.386
hard
----------
PROBLEM STATEMENT:
Consider an array of [expression].

Let [expression]:
[expression]

Given array [expression]. 

Note: Each query is independent and considered separately from all other queries, so changes made in one query have no effect on the other queries. 
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class C {

	BufferedReader br;
	PrintWriter out;
	StringTokenizer st;
	boolean eof;

	void solve() throws IOException {
		int n = nextInt();
		int q = nextInt();
		
		int[] b = new int[n + 1];
		for (int i = 0; i &lt; n; i++) {
			int x = nextInt();
			b[i + 1] = b[i] ^ x;
		}
		
		int[] c = new int[n + 2];
		for (int i = 0; i &lt; n + 1; i++) {
			c[i + 1] = c[i] + b[i];
		}
		
		while (q-- &gt; 0) {
			int x = nextInt();
			int y = nextInt();
			int k = nextInt();
			
			int len = y - x + 2;
			
			int ones;
			
			if (k == 0) {
				ones = c[y + 2] - c[x];
				
			} else {
				ones = len / 2;
			}
			out.println((long)ones * (len - ones));
		}
	}

	C() throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		solve();
		out.close();
	}

	public static void main(String[] args) throws IOException {
		new C();
	}

	String nextToken() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception e) {
				eof = true;
				return null;
			}
		}
		return st.nextToken();
	}

	String nextString() {
		try {
			return br.readLine();
		} catch (IOException e) {
			eof = true;
			return null;
		}
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
}
----------
====================
----------
ALGORITHMS.387
advanced
----------
PROBLEM STATEMENT:
Consider an array, [expression]). 
We take all consecutive subsequences of integers from the array that satisfy the following:
[expression] 

For example, if [expression] our subsequences will be:


[expression]
[expression]    
[expression]    
[expression]
[expression]
[expression] 


For each subsequence, we apply the bitwise XOR ([expression] numbers.   

Given array [expression] and determine the frequency at which each number occurs. Then print the number and its respective frequency as two space-separated values on a single line.  
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

const int MAXN = 100005, MAX = (1 &lt;&lt; 16);

int mem[MAXN], N, sum[MAXN];
long long total[1 &lt;&lt; 16];

inline void walk(int digits) {
	int n = (1 &lt;&lt; digits);
	for(int i = 1 ; i &lt;= digits ; i++) {
		int m = (1 &lt;&lt; i);
		int mh = m &gt;&gt; 1;
		for(int r = 0 ; r &lt; n ; r += m) {
			int t1 = r;
			int t2 = r + mh;
			for(int j = 0 ; j &lt; mh ; j++, t1++, t2++) {
				long long u = total[t1];
				long long v = total[t2];
				total[t1] = u + v;
				total[t2] = u - v;
			}
		}
	}
}

int main() {
	scanf("%d", &amp;N);
	for(int i = 1 ; i &lt;= N ; i++) {
		scanf("%d", &amp;mem[i]);
		sum[i] = sum[i - 1] ^ mem[i];
	}

	for(int i = 0 ; i &lt;= N ; i++) {
		total[sum[i]]++;
	}

	walk(16);
	for(int i = 0 ; i &lt; MAX ; i++) {
		total[i] = total[i] * total[i];
	}
	walk(16);
	for(int i = 0 ; i &lt; MAX ; i++) {
		total[i] /= MAX;
	}
	total[0] -= (N + 1);
	for(int i = 0 ; i &lt; MAX ; i++) {
		total[i] /= 2.0;
	}

	int ans = 0;
	long long best = 0;
	for(int i = 0 ; i &lt; MAX ; i++) {
		if (total[i] &gt; best) {
			best = total[i];
			ans = i;
		}
	}
	printf("%d %lld\n", ans, best);
	return 0;
}

----------
====================
----------
ALGORITHMS.388
expert
----------
PROBLEM STATEMENT:
Consider the following pseudocode, run on an array [expression]:

[expression]
[expression]
    [expression]
    [expression]
        [expression]
    [expression]
    [expression]



Given the values of [expression] after the pseudocode above terminates; if the loop will never terminate, print -1 instead.
----------
TOP SOLUTION:
----------

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class G {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	void solve()
	{
		int n = ni();
		int Z = 50003;
		long[] a = new long[Z];
		long[] ra = new long[Z];
		for(int v : na(n)){
			a[v] |= 1;
		}
		int step = 0;
		if(size(a) &lt;= 5){
			int[] who = new int[5];
			int p = 0;
			for(int i = 0;i &lt; Z;i++){
				if(a[i] == 1){
					who[p++] = i;
					a[i] = 0;
				}
			}
			who = Arrays.copyOf(who, p);
			while(p &lt;= 5){
				int[] nwho = new int[p*(p-1)/2];
				int q = 0;
				for(int i = 0;i &lt; p;i++){
					for(int j = i+1;j &lt; p;j++){
						nwho[q++] = who[j]-who[i];
					}
				}
				Arrays.sort(nwho, 0, q);
				who = uniq(nwho, q);
				p = who.length;
				step++;
				if(p == 0)break;
			}
			if(p == 0){
				out.println(step);
				return;
			}
			
			for(int w : who){
				a[w] = 1;
			}
		}
		
		while(true){
			n = a.length;
//			trnz(a);
			int g = 0;
			for(int i = 1;i &lt; Z;i++){
				if(a[i] == 1){
					g = gcd(g, i);
					if(g == 1)break;
				}
			}
			if(g &gt; 1){
				for(int i = 1;i &lt; Z;i++){
					if(a[i] == 1){
						a[i/g] = 1;
						a[i] = 0;
					}
				}
			}
			
			for(int i = 0;i &lt; Z;i++){
				ra[Z-1-i] = a[i];
			}
			long[] aa = convoluteSimply(a, ra, 998244353, 5);
			boolean end = true;
			int max = 0, tot = 0;
			for(int i = 1;i &lt; Z;i++){
				a[i] = aa[Z-1+i] &gt; 0 ? 1 : 0;
				if(a[i] == 1){
					max = i;
					tot++;
					end = false;
				}
			}
			step++;
			if(max == tot){
				step += max;
				break;
			}
			if(end)break;
		}
		out.println(step);
	}
	
	public static int gcd(int a, int b) {
		while (b &gt; 0) {
			int c = a;
			a = b;
			b = c % b;
		}
		return a;
	}
	
	
	public static int size(long... o)
	{
		int ret = 0;
		for(long v : o){
			ret += v;
		}
		return ret;
	}
	
	public static void trnz(long... o)
	{
		for(int i = 0;i &lt; o.length;i++)if(o[i] != 0)System.out.print(i+":"+o[i]+" ");
		System.out.println();
	}

	
	public static int[] uniq(int[] a, int n)
	{
		int p = 0;
		for(int i = 0;i &lt; n;i++) {
			if(i == 0 || a[i] != a[i-1])a[p++] = a[i];
		}
		return Arrays.copyOf(a, p);
	}
	
	public static final int[] NTTPrimes = {1053818881, 1051721729, 1045430273, 1012924417, 1007681537, 1004535809, 998244353, 985661441, 976224257, 975175681};
	public static final int[] NTTPrimitiveRoots = {7, 6, 3, 5, 3, 3, 3, 3, 3, 17};
//	public static final int[] NTTPrimes = {1012924417, 1004535809, 998244353, 985661441, 975175681, 962592769, 950009857, 943718401, 935329793, 924844033};
//	public static final int[] NTTPrimitiveRoots = {5, 3, 3, 3, 17, 7, 7, 7, 3, 5};
	
	public static long[] convoluteSimply(long[] a, long[] b, int P, int g)
	{
		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)&lt;&lt;2);
		long[] fa = nttmb(a, m, false, P, g);
		long[] fb = a == b ? fa : nttmb(b, m, false, P, g);
		for(int i = 0;i &lt; m;i++){
			fa[i] = fa[i]*fb[i]%P;
		}
		return nttmb(fa, m, true, P, g);
	}
	
	public static long[] convolute(long[] a, long[] b)
	{
		int USE = 2;
		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)&lt;&lt;2);
		long[][] fs = new long[USE][];
		for(int k = 0;k &lt; USE;k++){
			int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];
			long[] fa = nttmb(a, m, false, P, g);
			long[] fb = a == b ? fa : nttmb(b, m, false, P, g);
			for(int i = 0;i &lt; m;i++){
				fa[i] = fa[i]*fb[i]%P;
			}
			fs[k] = nttmb(fa, m, true, P, g);
		}
		
		int[] mods = Arrays.copyOf(NTTPrimes, USE);
		long[] gammas = garnerPrepare(mods);
		int[] buf = new int[USE];
		for(int i = 0;i &lt; fs[0].length;i++){
			for(int j = 0;j &lt; USE;j++)buf[j] = (int)fs[j][i];
			long[] res = garnerBatch(buf, mods, gammas);
			long ret = 0;
			for(int j = res.length-1;j &gt;= 0;j--)ret = ret * mods[j] + res[j];
			fs[0][i] = ret;
		}
		return fs[0];
	}
	
	public static long[] convolute(long[] a, long[] b, int USE, int mod)
	{
		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)&lt;&lt;2);
		long[][] fs = new long[USE][];
		for(int k = 0;k &lt; USE;k++){
			int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];
			long[] fa = nttmb(a, m, false, P, g);
			long[] fb = a == b ? fa : nttmb(b, m, false, P, g);
			for(int i = 0;i &lt; m;i++){
				fa[i] = fa[i]*fb[i]%P;
			}
			fs[k] = nttmb(fa, m, true, P, g);
		}
		
		int[] mods = Arrays.copyOf(NTTPrimes, USE);
		long[] gammas = garnerPrepare(mods);
		int[] buf = new int[USE];
		for(int i = 0;i &lt; fs[0].length;i++){
			for(int j = 0;j &lt; USE;j++)buf[j] = (int)fs[j][i];
			long[] res = garnerBatch(buf, mods, gammas);
			long ret = 0;
			for(int j = res.length-1;j &gt;= 0;j--)ret = (ret * mods[j] + res[j]) % mod;
			fs[0][i] = ret;
		}
		return fs[0];
	}
	
	// static int[] wws = new int[270000]; // outer faster
	
	// Modifed Montgomery + Barrett
	private static long[] nttmb(long[] src, int n, boolean inverse, int P, int g)
	{
		long[] dst = Arrays.copyOf(src, n);
		
		int h = Integer.numberOfTrailingZeros(n);
		long K = Integer.highestOneBit(P)&lt;&lt;1;
		int H = Long.numberOfTrailingZeros(K)*2;
		long M = K*K/P;
		
		int[] wws = new int[1&lt;&lt;h-1];
		long dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);
		long w = (1L&lt;&lt;32)%P;
		for(int k = 0;k &lt; 1&lt;&lt;h-1;k++){
			wws[k] = (int)w;
			w = modh(w*dw, M, H, P);
		}
		long J = invl(P, 1L&lt;&lt;32);
		for(int i = 0;i &lt; h;i++){
			for(int j = 0;j &lt; 1&lt;&lt;i;j++){
				for(int k = 0, s = j&lt;&lt;h-i, t = s|1&lt;&lt;h-i-1;k &lt; 1&lt;&lt;h-i-1;k++,s++,t++){
					long u = (dst[s] - dst[t] + 2*P)*wws[k];
					dst[s] += dst[t];
					if(dst[s] &gt;= 2*P)dst[s] -= 2*P;
//					long Q = (u&amp;(1L&lt;&lt;32)-1)*J&amp;(1L&lt;&lt;32)-1;
					long Q = (u&lt;&lt;32)*J&gt;&gt;&gt;32;
					dst[t] = (u&gt;&gt;&gt;32)-(Q*P&gt;&gt;&gt;32)+P;
				}
			}
			if(i &lt; h-1){
				for(int k = 0;k &lt; 1&lt;&lt;h-i-2;k++)wws[k] = wws[k*2];
			}
		}
		for(int i = 0;i &lt; n;i++){
			if(dst[i] &gt;= P)dst[i] -= P;
		}
		for(int i = 0;i &lt; n;i++){
			int rev = Integer.reverse(i)&gt;&gt;&gt;-h;
			if(i &lt; rev){
				long d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;
			}
		}
		
		if(inverse){
			long in = invl(n, P);
			for(int i = 0;i &lt; n;i++)dst[i] = modh(dst[i]*in, M, H, P);
		}
		
		return dst;
	}
	
	// Modified Shoup + Barrett
	private static long[] nttsb(long[] src, int n, boolean inverse, int P, int g)
	{
		long[] dst = Arrays.copyOf(src, n);
		
		int h = Integer.numberOfTrailingZeros(n);
		long K = Integer.highestOneBit(P)&lt;&lt;1;
		int H = Long.numberOfTrailingZeros(K)*2;
		long M = K*K/P;
		
		long dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);
		long[] wws = new long[1&lt;&lt;h-1];
		long[] ws = new long[1&lt;&lt;h-1];
		long w = 1;
		for(int k = 0;k &lt; 1&lt;&lt;h-1;k++){
			wws[k] = (w&lt;&lt;32)/P;
			ws[k] = w;
			w = modh(w*dw, M, H, P);
		}
		for(int i = 0;i &lt; h;i++){
			for(int j = 0;j &lt; 1&lt;&lt;i;j++){
				for(int k = 0, s = j&lt;&lt;h-i, t = s|1&lt;&lt;h-i-1;k &lt; 1&lt;&lt;h-i-1;k++,s++,t++){
					long ndsts = dst[s] + dst[t];
					if(ndsts &gt;= 2*P)ndsts -= 2*P;
					long T = dst[s] - dst[t] + 2*P;
					long Q = wws[k]*T&gt;&gt;&gt;32;
					dst[s] = ndsts;
					dst[t] = ws[k]*T-Q*P&amp;(1L&lt;&lt;32)-1;
				}
			}
//			dw = dw * dw % P;
			if(i &lt; h-1){
				for(int k = 0;k &lt; 1&lt;&lt;h-i-2;k++){
					wws[k] = wws[k*2];
					ws[k] = ws[k*2];
				}
			}
		}
		for(int i = 0;i &lt; n;i++){
			if(dst[i] &gt;= P)dst[i] -= P;
		}
		for(int i = 0;i &lt; n;i++){
			int rev = Integer.reverse(i)&gt;&gt;&gt;-h;
			if(i &lt; rev){
				long d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;
			}
		}
		
		if(inverse){
			long in = invl(n, P);
			for(int i = 0;i &lt; n;i++){
				dst[i] = modh(dst[i] * in, M, H, P);
			}
		}
		
		return dst;
	}
	
	static final long mask = (1L&lt;&lt;31)-1;
	
	public static long modh(long a, long M, int h, int mod)
	{
		long r = a-((M*(a&amp;mask)&gt;&gt;&gt;31)+M*(a&gt;&gt;&gt;31)&gt;&gt;&gt;h-31)*mod;
		return r &lt; mod ? r : r-mod;
	}
	
	private static long[] garnerPrepare(int[] m)
	{
		int n = m.length;
		assert n == m.length;
		if(n == 0)return new long[0];
		long[] gamma = new long[n];
		for(int k = 1;k &lt; n;k++){
			long prod = 1;
			for(int i = 0;i &lt; k;i++){
				prod = prod * m[i] % m[k];
			}
			gamma[k] = invl(prod, m[k]);
		}
		return gamma;
	}
	
	private static long[] garnerBatch(int[] u, int[] m, long[] gamma)
	{
		int n = u.length;
		assert n == m.length;
		long[] v = new long[n];
		v[0] = u[0];
		for(int k = 1;k &lt; n;k++){
			long temp = v[k-1];
			for(int j = k-2;j &gt;= 0;j--){
				temp = (temp * m[j] + v[j]) % m[k];
			}
			v[k] = (u[k] - temp) * gamma[k] % m[k];
			if(v[k] &lt; 0)v[k] += m[k];
		}
		return v;
	}
	
	private static long pow(long a, long n, long mod) {
		//		a %= mod;
		long ret = 1;
		int x = 63 - Long.numberOfLeadingZeros(n);
		for (; x &gt;= 0; x--) {
			ret = ret * ret % mod;
			if (n &lt;&lt; 63 - x &lt; 0)
				ret = ret * a % mod;
		}
		return ret;
	}
	
	private static long invl(long a, long mod) {
		long b = mod;
		long p = 1, q = 0;
		while (b &gt; 0) {
			long c = a / b;
			long d;
			d = a;
			a = b;
			b = d % b;
			d = p;
			p = q;
			q = d - c * q;
		}
		return p &lt; 0 ? p + mod : p;
	}

	
	void run() throws Exception
	{
//		int n = 100000, m = 99999;
//		Random gen = new Random();
//		StringBuilder sb = new StringBuilder();
//		sb.append(n + " ");
//		for (int i = 0; i &lt; n; i++) {
//			sb.append(gen.nextInt(16667)*3+1 + " ");
//		}
//		INPUT = sb.toString();

		
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new G().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.389
expert
----------
PROBLEM STATEMENT:
You are given a string [expression] queries to process. The queries are as follows:


C [expression];  
S [expression];   
R [expression] one;  
W [expression] one;  
H [expression].  


Everything is 1-indexed here.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I &lt; (N); ++I)
#define REPP(I, A, B) for (int I = (A); I &lt; (B); ++I)
#define RI(X) scanf("%d", &amp;(X))
#define RII(X, Y) scanf("%d%d", &amp;(X), &amp;(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &amp;(X), &amp;(Y), &amp;(Z))
#define DRI(X) int (X); scanf("%d", &amp;X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &amp;X, &amp;Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &amp;X, &amp;Y, &amp;Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &amp;___T); while (___T-- &gt; 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
typedef long long LL;
using namespace std;
const int LEN = 20;
const int BOUND = 1&lt;&lt;LEN;
int rev[BOUND],bit_cnt[BOUND];
int ONES;
void init(){
    REP(i,LEN)ONES|=1&lt;&lt;i;
    REP(i,BOUND){
        bit_cnt[i]=bit_cnt[i&gt;&gt;1]+(i&amp;1);
        int tmp=i;
        REP(j,LEN){
            rev[i]&lt;&lt;=1;
            rev[i]|=tmp&amp;1;
            tmp&gt;&gt;=1;
        }
    }
}
int a[50010];
char s[50010];
int tmp1[50010],tmp2[50010],tmp3[50010];
void get(int tmp[],int st,int len){
    if(!len){
        tmp[0]=0;
        return;
    }
    int w=len/LEN;
    int r=st%LEN;
    int x=st/LEN;
    int mask1=(1&lt;&lt;r)-1;
    int mask2=(1&lt;&lt;LEN)-1-mask1;
    REP(i,w){
        tmp[i]=((a[x+i]&amp;mask2)&gt;&gt;r)|((a[x+i+1]&amp;mask1)&lt;&lt;(LEN-r));
    }

    r=len-LEN*w;
    tmp[w]=0;
    REP(i,r){
        if((a[(st+w*LEN+i)/LEN]&gt;&gt;((st+w*LEN+i)%LEN))&amp;1)
            tmp[w]|=1&lt;&lt;i;
    }
}
void put(int tmp[],int st,int len){
    if(!len)return;
    int w=len/LEN;
    int r=st%LEN;
    int x=st/LEN;
    int mask1=(1&lt;&lt;r)-1;
    int mask2=(1&lt;&lt;LEN)-1-mask1;

    int mask3=(1&lt;&lt;(LEN-r))-1;
    int mask4=(1&lt;&lt;LEN)-1-mask3;
    REP(i,w){
        a[x+i]&amp;=mask1;
        a[x+i]|=(tmp[i]&amp;mask3)&lt;&lt;r;
        a[x+i+1]&amp;=mask2;
        a[x+i+1]|=(tmp[i]&amp;mask4)&gt;&gt;(LEN-r);
    }

    r=len-LEN*w;
    int xx=(st+w*LEN)/LEN;
    int yy=(st+w*LEN)%LEN;
    REP(i,r){
        if(((tmp[w]&gt;&gt;i)&amp;1) != ((a[xx]&gt;&gt;yy)&amp;1))
            a[xx]^=1&lt;&lt;yy;
        yy++;
        if(yy==LEN){
            xx++;
            yy=0;
        }
    }
}
int main(){
    init();
    DRII(N,M);
    RS(s);
    int sn=LEN(s);
    {
        int x=0,y=0;
        REP(i,sn){
            if(s[i]=='b')a[x]|=1&lt;&lt;y;
            y++;
            if(y==LEN){
                x++;
                y=0;
            }
        }
    }
    DRI(Q);
    while(Q--){
        //REP(i,5)printf("%d",a[i]);
        //puts("");
        char c[4];
        RS(c);
        if(c[0]=='C'){
            DRII(ll,rr);
            ll--;rr--;
            int st=(ll+LEN-1)/LEN,ed=(rr+1)/LEN;
            RS(c);
            int len=(rr-ll+LEN)/LEN;
            if(c[0]=='a'){
                REP(i,len)tmp1[i]=0;
            }
            else{
                REP(i,len)tmp1[i]=ONES;
            }
            put(tmp1,ll,rr-ll+1);
        }
        else if(c[0]=='S'){
            DRII(ll1,rr1);
            DRII(ll2,rr2);
            ll1--;rr1--;ll2--;rr2--;
            get(tmp1,ll1,rr1-ll1+1);
            get(tmp2,rr1+1,ll2-1-rr1);
            get(tmp3,ll2,rr2-ll2+1);
           // printf("[[%d%d]]\n",tmp1[0],tmp1[1]);
            //printf("[[%d]]\n",tmp3[0]);
            put(tmp3,ll1,rr2-ll2+1);
            put(tmp2,ll1+rr2-ll2+1,ll2-1-rr1);
            put(tmp1,ll1+rr2-rr1,rr1-ll1+1);
        }
        else if(c[0]=='R'){
            DRII(ll,rr);
            ll--;rr--;
            int len=rr-ll+1;
            get(tmp1,ll,len);
            //REP(i,5)printf("[%d]",tmp1[i]);
            if(len%LEN==0){
                int w=len/LEN;
                REP(i,w)tmp2[i]=rev[tmp1[w-i-1]];
            }
            else{
                int w=len/LEN;
                int r=len%LEN;
                int mask1=(1&lt;&lt;r)-1;
                int mask2=(1&lt;&lt;LEN)-1-mask1;
                REP(i,w)tmp2[i]=rev[((tmp1[w-i]&amp;mask1)&lt;&lt;(LEN-r))|((tmp1[w-i-1]&amp;mask2)&gt;&gt;r)];
                tmp2[w]=0;
                REP(i,r)
                    if((tmp1[0]&gt;&gt;(r-i-1))&amp;1)tmp2[w]|=1&lt;&lt;i;
            }
            put(tmp2,ll,len);
        }
        else if(c[0]=='W'){
            DRII(ll,rr);
            ll--;
            int x=ll/LEN;
            int y=ll%LEN;
            REPP(i,ll,rr){
                int now=(a[x]&gt;&gt;y)&amp;1;
                if(now)putchar('b');
                else putchar('a');
                y++;
                if(y==LEN){
                    x++;
                    y=0;
                }
            }
            puts("");
        }
        else if(c[0]=='H'){
            DRIII(st1,st2,len);
            st1--;st2--;
            get(tmp1,st1,len);
            get(tmp2,st2,len);
            len=(len+LEN-1)/LEN;
            int an=0;
            REP(i,len)an+=bit_cnt[tmp1[i]^tmp2[i]];
            printf("%d\n",an);
        }
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.390
hard
----------
PROBLEM STATEMENT:
Some scientists are working on protein recombination, and during their research, they have found a remarkable fact: there are 4 proteins in the protein ring that mutate after every second according to a fixed pattern. For simplicity, proteins are called [expression] (you know, protein names can be very complicated). A protein mutates into another one depending on itself and the protein right after it. Scientists determined that the mutation table goes like this:  

    A   B   C   D
    _   _   _   _
A|  A   B   C   D
B|  B   A   D   C
C|  C   D   A   B
D|  D   C   B   A


Here rows denote the protein at current position, while columns denote the protein at the next position. And the corresponding value in the table denotes the new protein that will emerge. So for example, if protein i is A, and protein i + 1 is B, protein i will change to B. All mutations take place simultaneously. The protein ring is seen as a circular list, so last protein of the list mutates depending on the first protein. 

Using this data, they have written a small simulation software to get mutations second by second. The problem is that the protein rings can be very long (up to 1 million proteins in a single ring) and they want to know the state of the ring after upto [expression] seconds. Thus their software takes too long to report the  results. They ask you for your help.  
----------
TOP SOLUTION:
----------
import java.io.*;

public class Solution {

    public static void solve(Input in, PrintWriter out) throws IOException {
        int n = in.nextInt(), k = in.nextInt();
        int[] a = new int[n];
        char[] c = in.next().toCharArray();
        for (int i = 0; i &lt; n; ++i) {
            a[i] = c[i] - 'A';
        }
        for (int i = 1; i &lt;= k; i *= 2) {
            if ((k &amp; i) != 0) {
                int[] b = new int[n];
                for (int j = 0; j &lt; n; ++j) {
                    b[j] = a[j] ^ a[(j + i) % n];
                }
                a = b;
            }
        }
        for (int i = 0; i &lt; n; ++i) {
            c[i] = (char) (a[i] + 'A');
        }
        out.println(c);
    }

    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);
        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);
        out.close();
    }

    static class Input {
        BufferedReader in;
        StringBuilder sb = new StringBuilder();

        public Input(BufferedReader in) {
            this.in = in;
        }

        public Input(String s) {
            this.in = new BufferedReader(new StringReader(s));
        }

        public String next() throws IOException {
            sb.setLength(0);
            while (true) {
                int c = in.read();
                if (c == -1) {
                    return null;
                }
                if (" \n\r\t".indexOf(c) == -1) {
                    sb.append((char)c);
                    break;
                }
            }
            while (true) {
                int c = in.read();
                if (c == -1 || " \n\r\t".indexOf(c) != -1) {
                    break;
                }
                sb.append((char)c);
            }
            return sb.toString();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }
}

----------
====================
----------
ALGORITHMS.391
medium
----------
PROBLEM STATEMENT:
Find the number of ways that a given integer, [expression] powers of unique, natural numbers. 

For example, if [expression].  

Function Description

Complete the powerSum function in the editor below.  It should return an integer that represents the number of possible combinations.  

powerSum has the following parameter(s):  


X: the integer to sum to  
N: the integer power to raise numbers to  

----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int power (int a, int n) {
    if(n == 0)
        return 1;
    // else
    if(n % 2 == 0) {
        int temp = power(a, n / 2);
        return temp * temp;
    }
    // else
    return a * power(a, n - 1);
}

int solve(int x, const vector&lt;int&gt; &amp;powers, int index) {
    if(index == 0) {
        return (x == 1) ? 1 : 0;
    }
    // else
    if(x == powers[index])
        return 1 + solve(x, powers, index - 1);
    // else
    int res = 0;
    res += solve(x - powers[index], powers, index - 1);
    res += solve(x, powers, index - 1);
    return res;
}


int main() {
    int x, n;
    cin &gt;&gt; x &gt;&gt; n;
    
    int pow = 1;
    vector&lt;int&gt; powers;
    for(int a = 2; pow &lt;= x; a++) {
        powers.push_back(pow);
        pow = power(a, n);
    }
    
    cout &lt;&lt; solve(x, powers, powers.size() - 1) &lt;&lt; endl;        
    return 0;
}

----------
====================
----------
ALGORITHMS.392
medium
----------
PROBLEM STATEMENT:
A [expression] Crossword grid is provided to you, along with a set of words (or names of places) which need to be filled into the grid.  Cells are marked either + or -.  Cells marked with a - are to be filled with the word list.  

The following shows an example crossword from the input [expression]:

[expression]

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



Function Description

Complete the crosswordPuzzle function in the editor below.  It should return an array of strings, each representing a row of the finished puzzle.

crosswordPuzzle has the following parameter(s):  


crossword: an array of [expression] representing the empty grid  
words: a string consisting of semicolon delimited strings to fit into [expression]  

----------
TOP SOLUTION:
----------

def display():
    for i in xrange(10):
        print grid[i]

def is_valid(text, k):
    i, j, l, x, y = init[k]

    if l != len(text):
        return False


    for t in xrange(l):
        if grid[i + x*t][j + y*t] not in [ord('-'), ord(text[t])]:
            return False

    return True

def put(text, k):
    i, j, l, x, y = init[k]

    changes = []
    for t in xrange(l):
        if grid[i + x*t][j + y*t] == ord('-'):
            grid[i + x*t][j + y*t] = ord(text[t])
            changes.append((i + x*t, j + y*t))

    return changes

def revert(changes):
    for i, j in changes:
        grid[i][j] = ord('-')

def Solve(t=0):

    global solved
    if t == len(init) or solved:
        solved = True
        return

    for i in xrange(len(init)):
        for key in keys:
            if solved: return
            if key not in used and is_valid(key, i):

                used.add(key)
                c = put(key, i)
                Solve(t+1)
                if solved: return
                revert(c)
                used.discard(key)


grid = [bytearray(raw_input()) for i in xrange(10)]
keys = raw_input().split(';')
init = []

for i in xrange(10):
    for j in xrange(10):
        if grid[i][j] == ord('-') and (j == 0 or grid[i][j-1] != ord('-')):
            init.append([i, j, 1, 0, 1])

        elif grid[i][j] == ord('-'):
            init[-1][2] += 1

for j in xrange(10):
    for i in xrange(10):
        if grid[i][j] == ord('-') and (i == 0 or grid[i-1][j] != ord('-')):
            init.append([i, j, 1, 1, 0])

        elif grid[i][j] == ord('-'):
            init[-1][2] += 1

solved = False
init = filter(lambda x: x[2] != 1, init)
init.sort(key=lambda x: x[2], reverse=1)

used = set()
Solve()
display()

----------
====================
----------
ALGORITHMS.393
medium
----------
PROBLEM STATEMENT:
We define super digit of an integer [expression] using the following rules:  

Given an integer, we need to find the super digit of the integer.


If [expression].   
Otherwise, the super digit of [expression].  


For example, the super digit of [expression] will be calculated as:

[expression] 
	[expression]
	[expression]
	[expression]  



You are given two numbers [expression] (spaces added for clarity).

[expression]
                  [expression]
    [expression]
                  [expression]
    [expression]



All of the digits of [expression] is only one digit, so it's the super digit.

Function Description

Complete the function superDigit in the editor below.  It must return the calculated super digit as an integer.  

superDigit has the following parameter(s):  


n: a string representation of an integer  
k: an integer, the times to concatenate [expression]  

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int k=0,flag=1;
int sum(string s){
   int64_t a=0,b;
    for(int i=0;i&lt;s.size();i++){
        b=s[i]-48;
        a+=b;
    }
    return a;
}
void super(int64_t a){
    if(a/10==0)
        {
        if(flag){
            flag=0;
        super(a*k);
            }
        else
            cout&lt;&lt;a;
     }
    else{
      int64_t val=0;
        while(a){
            val+=a%10;
            a=a/10;
        }
        super(val);
     }
}

int main() {
    string s;
    int64_t a;
    cin&gt;&gt;s&gt;&gt;k;
    a=sum(s);
    super(a);
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
ALGORITHMS.394
medium
----------
PROBLEM STATEMENT:
Chess is a very popular game played by hundreds of millions of people. Nowadays, we have chess engines such as Stockfish and Komodo to help us analyze games. These engines are very powerful pieces of well-developed software that use intelligent ideas and algorithms to analyze positions and sequences of moves, as well as find tactical ideas. Consider the following simplified version of chess:


Board: It's played on a [expression] board between two players named Black and White. 
Pieces and Movement: 
White initially has [expression] pieces. 
There are no Kings and no Pawns on the board. Each player has exactly one Queen, at most two Rooks, and at most two minor pieces (i.e., a Bishop and/or Knight). 
Each piece's possible moves are the same as in classical chess, and each move made by any player counts as a single move.
There is no draw when positions are repeated as there is in classical chess.
Objective: The goal of the game is to capture the opponent’s Queen without losing your own. 


Given [expression] moves (regardless of how Black plays) if White always moves first. For each game, print YES on a new line if White can win under the specified conditions; otherwise, print NO.
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;ctype.h&gt;
#include &lt;deque&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;random&gt;
#include &lt;unordered_map&gt;
#include &lt;stdio.h&gt;

using namespace std;

typedef long long ll;
typedef std::vector&lt;int&gt; vi;
typedef std::vector&lt;bool&gt; vb;
typedef std::vector&lt;string&gt; vs;
typedef std::vector&lt;double&gt; vd;
typedef std::vector&lt;long long&gt; vll;
typedef std::vector&lt;std::vector&lt;int&gt; &gt; vvi;
typedef vector&lt;vvi&gt; vvvi;
typedef vector&lt;vll&gt; vvll;
typedef std::vector&lt;std::pair&lt;int, int&gt; &gt; vpi;
typedef vector&lt;vpi&gt; vvpi;
typedef std::pair&lt;int, int&gt; pi;
typedef std::pair&lt;ll, ll&gt; pll;
typedef std::vector&lt;pll&gt; vpll;

const long long mod = 1000000007;

#define all(c) (c).begin(),(c).end()
#define sz(c) (int)(c).size()
#define forn(i, a, b) for(int i = a; i &lt; b; i++)

#define pb push_back
#define mp make_pair
int w,b,m;
pi a[4][4];
vvpi moves(5);
// 1 Q
// 2 R
// 3 N
// 4 B

vpi rook({{1,0}, {0,1}, {-1,0}, {0, -1}});
vpi bish({{1,1}, {-1,1}, {-1,-1}, {1, -1}});
vpi knight({{2,1},{1,2},{2,-1},{-1,2},{-2,1},{1,-2},{-2,-1},{-1,-2}});
vpi queen;
bool go(int turn) {
    if(m==0) return false;
    bool f = false;
    if(turn == 1) f = false;
    else f = true;
    forn(i,0,4) forn(j,0,4) {
        if(a[i][j].second != turn) continue;
        for(auto s : moves[a[i][j].first]) {
            int sx = s.first;
            int sy = s.second;
            int x = i+sx;
            int y = j+sy;
            while(x &gt;=0 &amp;&amp; x&lt; 4 &amp;&amp; y&gt;=0 &amp;&amp; y&lt;4) {
                if(a[x][y].second == turn) break;
                if(a[x][y].second == 3-turn) {
                    if(a[x][y].first == 1) {
                        if(turn == 1) return true;
                        else return false;
                    }
                }
                m--;
                pi was = a[x][y];
                a[x][y] = a[i][j];
                a[i][j] = mp(0,0);
                if(turn == 1) f |= go(3-turn);
                else if(turn == 2) f &amp;= go(3-turn);
                a[i][j] = a[x][y];
                a[x][y] = was;
                m++;
                if(a[x][y].second == 3-turn) {
                    break;
                }
                x+=sx;
                y+=sy;
            }
        }
    }
    return f;
}

int main()
{

    for(auto y : bish) queen.pb(y);
    for(auto y : rook) queen.pb(y);
    moves[1] = queen;
    moves[2] = rook;
    moves[3] = knight;
    moves[4] = bish;
    int t;
    cin&gt;&gt;t;
    forn(kappa,0,t){
        cin&gt;&gt;w&gt;&gt;b&gt;&gt;m;
        if (m==6) m = 5;
        forn(i,0,4) forn(j,0,4) a[i][j] = mp(0,0);
        forn(i,0,w) {
            char p, c;
            int u;
            cin&gt;&gt;p&gt;&gt;c&gt;&gt;u;
            int x = c-'A';
            int y= u-1;
            int v = 1;
            if(p=='R') v=2;
            if(p=='N') v=3;
            if(p=='B') v=4;
            a[x][y] = mp(v, 1);
        }
        forn(i,0,b) {
            char p, c;
            int u;
            cin&gt;&gt;p&gt;&gt;c&gt;&gt;u;
            int x = c-'A';
            int y= u-1;
            int v = 1;
            if(p=='R') v=2;
            if(p=='N') v=3;
            if(p=='B') v=4;
            a[x][y] = mp(v, 2);
        }
        if(go(1)) cout&lt;&lt;"YES"&lt;&lt;endl;
        else cout&lt;&lt;"NO"&lt;&lt;endl;
    }
    
}



----------
====================
----------
ALGORITHMS.395
medium
----------
PROBLEM STATEMENT:
There are N users registered on a website CuteKittens.com. Each of them has a unique password represented by pass[1], pass[2], ..., pass[N]. As this a very lovely site, many people want to access those awesomely cute pics of the kittens. But the adamant admin does not want the site to be available to the general public, so only those people who have passwords can access it.

Yu, being an awesome hacker finds a loophole in the password verification system. A string which is a concatenation of one or more passwords, in any order, is also accepted by the password verification system. Any password can appear [expression]loginAttempt$ string can be created by concatenating password strings, it is accepted.

For example, if there are 3 users with [expression] and so on.  Supplying abra ka dabra, concatenated, passes authentication.

Function Description

Complete the passwordCracker function in the editor below.  It should return the passwords as a single string in the order required for the password to be accepted, each separated by a space. If it is not possible to form the string, return the string WRONG PASSWORD.  

passwordCracker has the following parameters: 
- passwords: a list of password strings 
- loginAttempt: the string to attempt to create  
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

#include &lt;unordered_set&gt;

using namespace std;


void putReverses(vector&lt; string &gt; &amp;words, unordered_set&lt; string &gt; &amp;wordSet)
{
    int n = words.size();
    for(int i = 0;i != n;i++)
    {
        reverse(words[i].begin(), words[i].end());
        wordSet.insert(words[i]);
    }
}

vector&lt; string &gt; findComb(const string &amp;str, vector&lt; string &gt; &amp;words)
{
    vector&lt; string &gt; result;
    int m = str.size();
    
    unordered_set&lt; string &gt; wordSet;
    putReverses(words, wordSet);
    
    vector&lt; char &gt; valid(m + 1, 0);
    valid[0] = 1;
    vector&lt; int &gt; validLens(m + 1);
    
    for(int len = 1;len &lt;= m;len++)
    {
        int i = len - 1;
        string word;
        for(int j = i;j &gt;= 0;j--)
        {
            word += str[j];
            if(valid[j] &amp;&amp; wordSet.find(word) != wordSet.end())
            {
                valid[len] = 1;
                validLens[len] = len - j;
                break;
            }
        }
    }
    
    if(valid[m] == 0) { return result; }
    
    int len = m;
    while(len)
    {
        result.push_back(str.substr(len - validLens[len], validLens[len]));
        len -= validLens[len];
    }
    
    reverse(result.begin(), result.end());
    return result;
}


int main()
{
    int T, N;
    string word, str;
    cin &gt;&gt; T;
    while(T--)
    {
        cin &gt;&gt; N;
        vector&lt; string &gt; words;
        while(N--)
        {
            cin &gt;&gt; word;
            words.push_back(word);
        }
        
        cin &gt;&gt; str;
        
        vector&lt; string &gt; comb(findComb(str, words));
        if(comb.empty()) { cout &lt;&lt; "WRONG PASSWORD"; }
        else
        {
            int m = comb.size();
            cout &lt;&lt; comb[0];
            for(int i = 1;i != m;i++)
            {
                cout &lt;&lt; " " &lt;&lt; comb[i];
            }
        }
        
        cout &lt;&lt; endl;
    }
    
    return 0;
}

----------
====================
----------
ALGORITHMS.396
hard
----------
PROBLEM STATEMENT:
5-year-old Shinchan had just started learning mathematics. Meanwhile, one of his studious classmates, Kazama, had already written a basic calculator which supports only three operations on integers: multiplication [expression].  Since he had just learned about these operations, he didn't know about operator precedence, and so, in his calculator, all operators had the same precedence and were left-associative.

As always, Shinchan started to irritate him with his silly questions. He gave Kazama a list of [expression]. At his core, Shinchan is actually a good guy, so he only gave lists of integers for which an answer exists.  

Can you help Kazama create the required expression? If multiple solutions exist, print any one of them.   
----------
TOP SOLUTION:
----------
// Intention is a project that we can change with impunity

#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;memory&gt;
#include &lt;cstring&gt;
#include &lt;chrono&gt;
#include &lt;climits&gt;


using namespace std;


#ifdef WIN32
#define INPUT my_file
const char* input_file_root = "Input";
const char* input_file_suffix = ".txt";

class OutputCompare
{
public:
	~OutputCompare() {
		if (use_file) {
			if (problems == 0) {
				cout &lt;&lt; "Output identical to expected file\n";
			}
			else {
				cout &lt;&lt; "Output incorrect, found " &lt;&lt; problems &lt;&lt; " differences\n";
			}
		}
	}

	void set_file(const char* name) {
		expected_file.open(name);
		use_file = true;
	}

	OutputCompare&amp; operator&lt;&lt;(char c) {
		if (use_file) {
			if (!iswspace(c)) {
				char expected;
				expected_file &gt;&gt; expected;
				if (c != expected) {
					cout &lt;&lt; "Expected " &lt;&lt; expected &lt;&lt; " but program output was " &lt;&lt; c &lt;&lt; '\n';
					++problems;
				}
			}
		}
		else {
			cout &lt;&lt; c;
		}
		return *this;
	}

	template &lt;class T&gt;
	OutputCompare&amp; operator&lt;&lt;(const T&amp; value) {
		if (use_file) {
			T expected;
			expected_file &gt;&gt; expected;
			if (value != expected) {
				cout &lt;&lt; "Expected " &lt;&lt; expected &lt;&lt; " but program output was " &lt;&lt; value &lt;&lt; '\n';
				++problems;
			}
		}
		else {
			cout &lt;&lt; value;
		}
		return *this;
	}

private:
	ifstream expected_file;
	int problems = 0;
	bool use_file = false;
};
#define OUTPUT my_output_compare

#else
#define INPUT cin
#define OUTPUT cout
#define _ASSERT(x)
#endif

int main(int argc, const char * argv[])
{
	// Read in problem
#ifdef WIN32
	// Read from a file.  Command line argument [1] is appended to the file name.
	ifstream my_file;
	string input_file_name(input_file_root);
	if (argc &gt;= 2) {
		input_file_name.append(argv[1]);
	}
	input_file_name.append(input_file_suffix);
	my_file.open(input_file_name);

	OutputCompare my_output_compare;
	if (argc &lt; 3 || *argv[2] != 'x') {
		string output_file_name("Output");
		if (argc &gt;= 3) {
			output_file_name.append(argv[2]);
		}
		else if (argc &gt;= 2) {
			output_file_name.append(argv[1]);
		}
		output_file_name.append(".txt");
		my_output_compare.set_file(output_file_name.c_str());
	}
	auto start_time = std::chrono::system_clock::now();
#endif

	int n;
	INPUT &gt;&gt; n;
	int* data = new int[n];
	char* operators = new char[n * 101];
	char* follows = new char[n * 101];

	for (int i = 0; i &lt; n; ++i) {
		INPUT &gt;&gt; data[i];

		for (int j = 0; j &lt; 101; ++j) {
			operators[i * 101 + j] = ' ';
		}
	}

	// Specify that the first input number can be reached
	operators[data[0]] = '+';

	for (int i = 1; i &lt; n; ++i) {
		char* last_ops = operators + (i - 1) * 101;
		char* this_ops = operators + i * 101;
		char* this_follows = follows + i * 101;

		// See what numbers can be reached by combining numbers reachable after i-1 steps with data[i]
		// Note that once we've found a solution, multiplying each later operand will give correct answer
		// So we shortcircuit once entry 0 is filled in
		for (int j = 0; j &lt; 101 &amp;&amp; this_ops[0] == ' '; ++j) {
			if (last_ops[j] != ' ') {
				int reachable = j + data[i];
				reachable %= 101;
				if (this_ops[reachable] == ' ') {
					this_ops[reachable] = '+';
					this_follows[reachable] = j;
				}

				reachable = j - data[i];
				if (reachable &lt; 0) reachable += 101;
				if (this_ops[reachable] == ' ') {
					this_ops[reachable] = '-';
					this_follows[reachable] = j;
				}

				reachable = j * data[i];
				reachable %= 101;
				if (this_ops[reachable] == ' ') {
					this_ops[reachable] = '*';
					this_follows[reachable] = j;
				}
			}
		}
	}

	// We should have a result (i.e. 0 should be included in last one)
	if (operators[(n - 1) * 101] == ' ') {
		OUTPUT &lt;&lt; "ERROR!!!!!\n";
	}
	else {
		// We obtain the result in reverse order
		vector&lt;char&gt; result;
		result.reserve(n);
		int x = 0;
		for (int i = n - 1; i &gt; 0; --i) {
			result.push_back(operators[i * 101 + x]);
			x = follows[i * 101 + x];
		}
		_ASSERT(x == data[0]);
		OUTPUT &lt;&lt; data[0];
		auto it = result.rbegin();
		for (int i = 1; i &lt; n; ++i, ++it) {
			OUTPUT &lt;&lt; (*it);
			OUTPUT &lt;&lt; data[i];
		}
		OUTPUT &lt;&lt; '\n';
	}


	return 0;

#ifdef WIN32
	my_file.close();
	cout &lt;&lt; "time=" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::system_clock::now() - start_time).count() &lt;&lt; "ms\n";
#endif
	return 0;
}

----------
====================
----------
ALGORITHMS.397
medium
----------
PROBLEM STATEMENT:
You have a pile of [expression] distinct integers. We define a move as follows:


First, choose a pile of stones. Let's say that the chosen pile contains [expression] stones. 
Next, look for some [expression] equal smaller piles.


You are given [expression]. For each query, calculate the maximum possible number of moves you can perform and print it on a new line.
----------
TOP SOLUTION:
----------
SOLUTION NOT FOUND
----------
====================
----------
ALGORITHMS.398
hard
----------
PROBLEM STATEMENT:
At the time when Pythagoreanism was prevalent, people were also focused on different ways to factorize a number. In one class, Pythagoras asked his disciples to solve one such problem, Reverse Factorization. They were given a set of integer, [expression]. So they decided to find a way in which number of states are least. All of sudden they started on this new problem. People solved it and then started shouting their answer. CRAP!!!. There still exists multiple answers. So finally after much consideration, they settled on the lexicographically smallest series among those solutions which contains the least number of states.

For example, if [expression] then following ways exists  

[expression]
       [expression]

[expression]
       [expression]

[expression]
       [expression]



Here (a) is not the minimal state, as it has [expression] print -1.   
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class Solution {

    
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] a = new int[k];
        for(int i = 0; i &lt; k; i++) {
            a[i] = sc.nextInt();
        }
        
        LinkedList&lt;Integer&gt; sol = new LinkedList&lt;Integer&gt;();
        Arrays.sort(a);
        
        if(backtrack(n,a,a.length-1,sol)) {
            int curr = 1;
            for(int i = 0; i &lt; sol.size()-1; i++) {
                curr *= sol.get(i);
                System.out.print(curr + " ");
            }    
            curr *= sol.get(sol.size()-1);
            System.out.println(curr);
        } else {
            System.out.println(-1);
        }
        
        
        
    }
    
    public static boolean backtrack(int n, int[] a, int index,LinkedList&lt;Integer&gt; sol) {
        if(n == 1) {
            sol.add(1);
            return true;
        }
        
        for(int i = index; i &gt;= 0; i--) {
            if(n % a[i] == 0) {
                if(backtrack(n/a[i],a,i,sol)) {
                    sol.add(a[i]);
                    return true;
                }
            }
        }        
        
        return false;
    }
    
}
----------
====================
----------
ALGORITHMS.399
hard
----------
PROBLEM STATEMENT:
Bowling is a sport in which a player rolls a bowling ball towards a group of pins, the target being to knock down the pins at the end of a lane.



In this challenge, the rules of the game are slightly modified. Now, there are a given number of pins, and the pins are arranged in a horizontal line instead of a triangular formation. Two players have to play this game, taking alternate turns. Whoever knocks down the last pin(s) will be declared the winner.  

You are playing this game with your friend, and both of you have become proficient at it. You can knock down any single pin, or any two adjacent pins at one throw of a bowling ball, however, these are the only moves that you can perform. Some moves have already been played. Suddenly, you realize that it is possible to determine whether this game can be won or not, assuming optimal play. And luckily it's your turn right now.  

A configuration is represented by a string consisting of the letters X and I, where: 


I represents a position containing a pin.
X represents a position where a pin has been knocked down.


An example of such a configuration is shown in the image below. Here, the number of pins is [expression] pin has already been knocked down.  



Its representation will be IXIIIIIIIIIII.

Complete the function isWinning that takes the number of pins and the configuration of the pins as input, and return WIN or LOSE based on whether or not you will win. 

Given the current configuration of the pins, if both of you play optimally, determine whether you will win this game or not. 

Note   


A player has to knock down at least one pin in his turn.
Both players play optimally.  

----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int Maxn = 305;

int nim[Maxn];
int t;
int n;
char str[Maxn];

int main() {
    for (int i = 1; i &lt; Maxn; i++) {
        set &lt;int&gt; S;
        for (int j = 0; j &lt; i; j++)
            S.insert(nim[j] ^ nim[i - 1 - j]);
        for (int j = 0; j + 1 &lt; i; j++)
            S.insert(nim[j] ^ nim[i - 2 - j]);
        while (S.find(nim[i]) != S.end()) nim[i]++;
    }  
    scanf("%d", &amp;t);
    while (t--) {
        scanf("%d", &amp;n);
        scanf("%s", str);
        int res = 0;
        for (int i = 0; i &lt; n; i++) if (str[i] == 'I') {
            int j = i;
            while (j &lt; n &amp;&amp; str[j] == 'I') j++;
            res ^= nim[j - i];
            i = j;
        }
        printf("%s\n", res? "WIN": "LOSE");
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.400
hard
----------
PROBLEM STATEMENT:
Chess is a very popular game played by hundreds of millions of people. Nowadays, we have chess engines such as Stockfish and Komodo to help us analyze games. These engines are very powerful pieces of well-developed software that use intelligent ideas and algorithms to analyze positions and sequences of moves, as well as to find tactical ideas. Consider the following simplified version of chess:


Board: 
It's played on a [expression] board between two players named Black and White.
Rows are numbered from [expression].  
Columns are lettered from [expression].
Pieces and Movement: 
White initially has [expression] pieces.
There are no Kings on the board. Each player initially has exactly [expression] minor pieces (i.e., a Bishop and/or Knight).
White's Pawns move up the board, while Black's Pawns move down the board.
Each move made by any player counts as a single move.
Each piece's possible moves are the same as in classical chess, with the following exceptions:
Pawns cannot move two squares forward.
The en passant move is not possible.
Promotion:
Pawns promote to either a Bishop, Knight, or Rook when they reach the back row (promotion to a Queen is not allowed). 
The players must perform promotions whenever possible. This means White must promote their Pawns when they reach any cell in the top row, and Black must promote their Pawns when they reach any cell in the bottom row. 
Objective: 
The goal of the game is to capture the opponent’s Queen without losing your own.
There will never be a draw or tie scenario like you might see in classical chess.




Given [expression] moves; otherwise, print NO.
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
    static class Piece {
        public char type;
        public boolean isWhite;

        public Piece (char type, boolean isWhite) {
            this.type = type;
            this.isWhite = isWhite;
        }
        
        public Piece (Piece p) {
            this.type = p.type;
            this.isWhite = p.isWhite;
        }
    }
    
    static class Board {
        public Piece[][] pieces = new Piece[4][4];
        
        public Board(ArrayList&lt;String&gt; w, ArrayList&lt;String&gt; b) {
            for (String p : w) {
                String[] p3 = p.split(" ");
                char type = p3[0].charAt(0);
                int x = p3[1].charAt(0)-'A';
                int y = p3[2].charAt(0)-'1';
                pieces[x][y] = new Piece(type, true);
            }
            for (String p : b) {
                String[] p3 = p.split(" ");
                char type = p3[0].charAt(0);
                int x = p3[1].charAt(0)-'A';
                int y = p3[2].charAt(0)-'1';
                pieces[x][y] = new Piece(type, false);
            }
        }
        
        public Board(Board b) {
            for (int i = 0; i &lt; 4; i++) {
                for (int j = 0; j &lt; 4; j++) {
                    if (b.pieces[i][j] != null)
                        this.pieces[i][j] = new Piece(b.pieces[i][j]);
                }
            }
        }
        
        public ArrayList&lt;Board&gt; legalMoves(boolean whiteToMove) {
            ArrayList&lt;Board&gt; moves = new ArrayList&lt;Board&gt;();
            for (int a = 0; a &lt; 4; a++) {
                for (int b = 0; b &lt; 4; b++) {
                    if (pieces[a][b] != null &amp;&amp; pieces[a][b].isWhite == whiteToMove) {
                        if (pieces[a][b].type == 'P') {
                            int d = whiteToMove?b+1:b-1;
                            if (pieces[a][d] == null) {
                                if (d==0||d==3) {
                                    Board newBoard = new Board(this);
                                    newBoard.pieces[a][d] = newBoard.pieces[a][b];
                                    newBoard.pieces[a][b] = null;
                                    newBoard.pieces[a][d].type = 'R';
                                    moves.add(newBoard);
                                    newBoard = new Board(this);
                                    newBoard.pieces[a][d] = newBoard.pieces[a][b];
                                    newBoard.pieces[a][b] = null;
                                    newBoard.pieces[a][d].type = 'B';
                                    moves.add(newBoard);
                                    newBoard = new Board(this);
                                    newBoard.pieces[a][d] = newBoard.pieces[a][b];
                                    newBoard.pieces[a][b] = null;
                                    newBoard.pieces[a][d].type = 'N';
                                    moves.add(newBoard);
                                }
                                else {
                                    Board newBoard = new Board(this);
                                    newBoard.pieces[a][d] = newBoard.pieces[a][b];
                                    newBoard.pieces[a][b] = null;
                                    moves.add(newBoard);
                                }
                            }
                            for (int c = a-1; c &lt;= a+1; c+=2) {
                                if (c&gt;=0&amp;&amp;c&lt;4) {
                                    if (pieces[c][d] != null &amp;&amp; pieces[c][d].isWhite != whiteToMove) {
                                        if (d==0||d==3) {
                                            Board newBoard = new Board(this);
                                            newBoard.pieces[c][d] = newBoard.pieces[a][b];
                                            newBoard.pieces[a][b] = null;
                                            newBoard.pieces[c][d].type = 'R';
                                            moves.add(newBoard);
                                            newBoard = new Board(this);
                                            newBoard.pieces[c][d] = newBoard.pieces[a][b];
                                            newBoard.pieces[a][b] = null;
                                            newBoard.pieces[c][d].type = 'B';
                                            moves.add(newBoard);
                                            newBoard = new Board(this);
                                            newBoard.pieces[c][d] = newBoard.pieces[a][b];
                                            newBoard.pieces[a][b] = null;
                                            newBoard.pieces[c][d].type = 'N';
                                            moves.add(newBoard);
                                        }
                                        else {
                                            Board newBoard = new Board(this);
                                            newBoard.pieces[c][d] = newBoard.pieces[a][b];
                                            newBoard.pieces[a][b] = null;
                                            moves.add(newBoard);
                                        }
                                    }
                                }
                            }
                        }
                        if (pieces[a][b].type == 'N') {
                            for (int c = -2; c &lt;= 2; c+=4) {
                                for (int d = -1; d &lt;= 1; d+=2) {
                                    int e = a+c;
                                    int f = b+d;
                                    int g = a+d;
                                    int h = b+c;
                                    if (e &gt;= 0 &amp;&amp; e &lt; 4 &amp;&amp; f &gt;= 0 &amp;&amp; f &lt; 4) {
                                        if (pieces[e][f] == null || pieces[e][f].isWhite != whiteToMove) {
                                            Board newBoard = new Board(this);
                                            newBoard.pieces[e][f] = newBoard.pieces[a][b];
                                            newBoard.pieces[a][b] = null;
                                            moves.add(newBoard);
                                        }
                                    }
                                    if (g &gt;= 0 &amp;&amp; g &lt; 4 &amp;&amp; h &gt;= 0 &amp;&amp; h &lt; 4) {
                                        if (pieces[g][h] == null || pieces[g][h].isWhite != whiteToMove) {
                                            Board newBoard = new Board(this);
                                            newBoard.pieces[g][h] = newBoard.pieces[a][b];
                                            newBoard.pieces[a][b] = null;
                                            moves.add(newBoard);
                                        }
                                    }
                                }
                            }
                        }
                        if (pieces[a][b].type == 'R' || pieces[a][b].type == 'Q') {
                            for (int c = -1; c &lt;= 1; c += 2) {
                                for (int d = a+c; d &gt;= 0 &amp;&amp; d &lt; 4; d += c) {
                                    if (pieces[d][b] == null || pieces[d][b].isWhite != whiteToMove) {
                                        Board newBoard = new Board(this);
                                        newBoard.pieces[d][b] = newBoard.pieces[a][b];
                                        newBoard.pieces[a][b] = null;
                                        moves.add(newBoard);
                                    }
                                    if (pieces[d][b] != null)
                                        break;
                                }
                                for (int d = b+c; d &gt;= 0 &amp;&amp; d &lt; 4; d += c) {
                                    if (pieces[a][d] == null || pieces[a][d].isWhite != whiteToMove) {
                                        Board newBoard = new Board(this);
                                        newBoard.pieces[a][d] = newBoard.pieces[a][b];
                                        newBoard.pieces[a][b] = null;
                                        moves.add(newBoard);
                                    }
                                    if (pieces[a][d] != null)
                                        break;
                                }
                            }
                        }
                        if (pieces[a][b].type == 'B' || pieces[a][b].type == 'Q') {
                            for (int c = -1; c &lt;= 1; c += 2) {
                                for (int d = -1; d &lt;= 1; d += 2) {
                                    for (int e = 1; a+e*c &gt;= 0 &amp;&amp; a+e*c &lt; 4 &amp;&amp; b+e*d &gt;= 0 &amp;&amp; b+e*d &lt; 4; e++) {
                                        int f = a+e*c;
                                        int g = b+e*d;
                                        
                                        if (pieces[f][g] == null || pieces[f][g].isWhite != whiteToMove) {
                                            Board newBoard = new Board(this);
                                            newBoard.pieces[f][g] = newBoard.pieces[a][b];
                                            newBoard.pieces[a][b] = null;
                                            moves.add(newBoard);
                                        }
                                        if (pieces[f][g] != null)
                                            break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return moves;
        }
        
        public boolean doesQueenExist(boolean whiteQueen) {
            for (int a = 0; a &lt; 4; a++) {
                for (int b = 0; b &lt; 4; b++) {
                    if (pieces[a][b] != null &amp;&amp; pieces[a][b].type == 'Q' &amp;&amp; pieces[a][b].isWhite == whiteQueen)
                        return true;
                }
            }
            return false;
        }
        
        public boolean canCaptureQueen(boolean whiteToMove) {
            ArrayList&lt;Board&gt; moves = legalMoves(whiteToMove);
            for (Board b : moves) {
                if (!b.doesQueenExist(!whiteToMove))
                    return true;
            }
            return false;
        }
        
        public boolean canReachGoalWhite(int rem) {
            if (canCaptureQueen(true))
                return true;
            if (rem==1)
                return false;
            ArrayList&lt;Board&gt; moves = legalMoves(true);
            for (Board b : moves) {
                if (!b.canStopGoalBlack(rem))
                    return true;
            }
            return false;
        }
        
        public boolean canStopGoalBlack(int rem) {
            if (canCaptureQueen(false))
                return true;
            ArrayList&lt;Board&gt; moves = legalMoves(false);
            for (Board b : moves) {
                if (!b.canReachGoalWhite(rem-1))
                    return true;
            }
            return false;
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int g = sc.nextInt();
        for (int z = 0; z &lt; g; z++) {
            int w = sc.nextInt();
            int b = sc.nextInt();
            int m = (sc.nextInt()+1)/2;
            ArrayList&lt;String&gt; wl = new ArrayList&lt;String&gt;();
            ArrayList&lt;String&gt; bl = new ArrayList&lt;String&gt;();
            sc.nextLine();
            for (int i = 0; i &lt; w; i++) {
                wl.add(sc.nextLine());
            }
            for (int i = 0; i &lt; b; i++) {
                bl.add(sc.nextLine());
            }
            Board start = new Board(wl, bl);
            System.out.println(start.canReachGoalWhite(m)?"YES":"NO");
        }
    }
}
----------
====================
----------
ALGORITHMS.401
advanced
----------
PROBLEM STATEMENT:
Alice thinks of a non-decreasing sequence of non-negative integers and wants Bob to guess it by providing him the set of all its K-sums with repetitions. 

What is this? Let the sequence be {A[1], A[2], ..., A[N]} and K be some positive integer that both Alice and Bob know. Alice gives Bob the set of all possible values that can be genereated by this - A[i1] + A[i2] + ... + A[iK], where 1 ≤ i1 ≤ i2 ≤ ... ≤ iK ≤ N. She can provide the values generated in any order she wishes to. Bob's task is to restore the initial sequence.

Consider an example. Let N = 3 and K = 2. The sequence is {A[1], A[2], A[3]}. The sequence of its 2-sums with repetitions is {A[1] + A[1], A[1] + A[2], A[1] + A[3], A[2] + A[2], A[2] + A[3], A[3] + A[3]}. But its elements could be provided in any order. For example any permutation of {2, 3, 4, 4, 5, 6} corresponds to the sequence {1, 2, 3}.
----------
TOP SOLUTION:
----------
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using namespace std;

int Tot;

long long a[100010];
map &lt;long long,int&gt; mp;

void dfs(int now,int ee,int les)
{
    if (les==0||now+1==ee)
    {
        Tot++;
        return;
    }
    for (int i=0;i&lt;=les;i++)
        dfs(now+1,ee,les-i);
}

void dfs2(int now,long long num,int les)
{
    if (now==0) num+=les*a[0];
    if (les==0||now==0)
    {
        mp[num]--;
        if (mp[num]==0) mp.erase(num);
        return;
    }
    for (int i=0;i&lt;=les;i++)
        dfs2(now-1,num+i*a[now],les-i);
}

int main()
{
    int T;
    scanf("%d",&amp;T);
    while (T--)
    {
        int n,m;
        scanf("%d%d",&amp;n,&amp;m);
        Tot=0;
        dfs(0,n,m);
        for (int i=0;i&lt;Tot;i++)
        {
            long long x;
            scanf("%lld",&amp;x);
            mp[x]++;
        }
        for (int i=0;i&lt;n;i++)
        {
            long long now=mp.begin()-&gt;first;
            if (i==0)
            {
                a[i]=now/m;
                mp[now]--;
                if (mp[now]==0) mp.erase(now);
            }
            else
            {
                a[i]=now-a[0]*(m-1);
                for (int j=1;j&lt;=m;j++)
                {
                    dfs2(i-1,a[i]*j,m-j);
                }
            }
        }
        for (int i=0;i&lt;n;i++)
        {
            if (i) printf(" ");
            printf("%lld",a[i]);
        }
        puts("");
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.402
easy
----------
PROBLEM STATEMENT:
Two players called [expression] always plays first, and the two players move in alternating turns. The game's rules are as follows:


In a single move, a player can remove either [expression] stones from the game board. 
If a player is unable to make a move, that player loses the game.


Given the starting number of stones, find and print the name of the winner.  [expression] is named Second.  Each player plays optimally, meaning they will not make a move that causes them to lose the game if a winning move exists.

For example, if [expression] can make the following moves:  


[expression] stones and win.
[expression] cannot move and loses.


[expression] would make the second play and win the game.

Function Description

Complete the gameOfStones function in the editor below.  It should return a string, either First or Second.  

gameOfStones has the following parameter(s):


n: an integer that represents the starting number of stones

----------
TOP SOLUTION:
----------
for _ in xrange(input()):
    n=input() - 1
    if (n%7) in [0, 6]:
        print "Second"
    else:
        print "First"
----------
====================
----------
ALGORITHMS.403
easy
----------
PROBLEM STATEMENT:
Two players are playing a game of Tower Breakers! The rules of the game are as follows:
 
- Player [expression] always moves first, and both players always play optimally. 
- Initially there are [expression]. 
- The players move in alternating turns. In each turn, a player can choose a tower of height [expression]. 
- If the current player is unable to make a move, they lose the game. 
 
Given the values of [expression].  

For example, there are [expression] with no move.

Function Description  

Complete the towerBreakers function in the editor below.  It should return an integer that represents the winning player.  

towerBreakers has the following paramter(s):  


n: an integer that represents the number of towers  
m: an integer that represents the height of each tower  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;

int main()
{
	long nTest,n,m;
	scanf("%ld",&amp;nTest);
	while (nTest--)
	{
		scanf("%ld%ld",&amp;n,&amp;m);
		if (m==1) puts("2");
		else puts((n&amp;1)?"1":"2");
	}
}

----------
====================
----------
ALGORITHMS.404
easy
----------
PROBLEM STATEMENT:
Two players are playing a game on a [expression] chessboard. The rules of the game are as follows:


The game starts with a single coin located at some [expression].
In each move, a player must move the coin from cell [expression] to one of the following locations:

[expression] 
[expression] 
[expression] 
[expression]

Note: The coin must remain inside the confines of the board.
Beginning with player 1, the players alternate turns. The first player who is unable to make a move loses the game.


The figure below shows all four possible moves using an [expression] board for illustration:



Given the initial coordinates of the players' coins, assuming optimal play, determine which player will win the game. 

Function Description

Complete the chessboardGame function in the editor below.  It should return a string, either First or Second.

chessboardGame has the following parameter(s):  


x: an integer that represents the starting column position   
y: an integer that represents the starting row position  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
long DP[16][16];
long dx[4]={-2,-2,1,-1};
long dy[4]={1,-1,-2,-2};
bool inside(long u,long v)
{
	return (u&gt;0 &amp;&amp; v&gt;0 &amp;&amp; u&lt;=15 &amp;&amp; v&lt;=15);
}

bool dp(long x,long y)
{
	if (DP[x][y]!=-1) return DP[x][y];
	bool res=false;
	for (long i=0; i&lt;4; ++i)
	{
		long xx=x+dx[i],yy=y+dy[i];
		if (inside(xx,yy)) res=res|(!dp(xx,yy));
	}
	DP[x][y]=res;
	return res;
}
int main()
{
	long nTest,x,y;
	memset(DP,-1,sizeof(DP));
	DP[1][1]=DP[1][2]=DP[2][1]=DP[2][2]=false;
	scanf("%ld",&amp;nTest);
	while (nTest--)
	{
		scanf("%ld%ld",&amp;x,&amp;y);
		puts(dp(x,y)?"First":"Second");
	}
}

----------
====================
----------
ALGORITHMS.405
easy
----------
PROBLEM STATEMENT:
Nim is the most famous two-player algorithm game. The basic rules for this game are as follows:


The game starts with a number of piles of stones.  The number of stones in each pile may not be equal.
The players alternately pick up [expression] pile
The player to remove the last stone wins.


For example, there are [expression] stones in them.  Play may proceed as follows:

Player  Takes           Leaving
                        pile=[3,2,4]
1       2 from pile[1]  pile=[3,4]
2       2 from pile[1]  pile=[3,2]
1       1 from pile[0]  pile=[2,2]
2       1 from pile[0]  pile=[1,2]
1       1 from pile[1]  pile=[1,1]
2       1 from pile[0]  pile=[0,1]
1       1 from pile[1]  WIN


Given the value of [expression] and the number of stones in each pile, determine the game's winner if both players play optimally.

Function Desctription  

Complete the nimGame function in the editor below.  It should return a string, either First or Second.  

nimGame has the following parameter(s):  


pile: an integer array that represents the number of stones in each pile  

----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;

int main()
{
	long nTest,n,res,x;
	scanf("%ld",&amp;nTest);
	while (nTest--)
	{
		scanf("%ld%ld",&amp;n,&amp;res);
		for (long i=1; i&lt;n; ++i) scanf("%ld",&amp;x),res^=x;
		puts((!res)?"Second":"First");
	}
}

----------
====================
----------
ALGORITHMS.406
easy
----------
PROBLEM STATEMENT:
Two people are playing game of Misère Nim. The basic rules for this game are as follows:


The game starts with [expression] stones.
The players move in alternating turns. During each move, the current player must  remove one or more stones from a single pile. 
The player who removes the last stone loses the game.


Given the value of [expression] and the number of stones in each pile, determine whether the person who wins the game is the first or second person to move. If the first player to move wins, print First on a new line; otherwise, print Second. Assume both players move optimally. 
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;

int main()
{
	long nTest,n;
	scanf("%ld",&amp;nTest);
	while (nTest--)
	{
		long res=0,cnt=0,x;
		scanf("%ld",&amp;n);
		for (long i=0; i&lt;n; ++i)
		{
			scanf("%ld",&amp;x);
			if (x==1) ++cnt;
			res^=x;
		}
		if (cnt==n) puts((cnt&amp;1)?"Second":"First");
		else puts((res&gt;0)?"First":"Second");
	}
}

----------
====================
----------
ALGORITHMS.407
easy
----------
PROBLEM STATEMENT:
Two people are playing Nimble! The rules of the game are:


The game is played on a line of [expression] coins. For example: 

The players move in alternating turns. During each move, the current player must  remove exactly [expression].
The game ends when all coins are in square [expression] and nobody can make a move. The first player to have no available move loses the game.


Given the value of [expression] and the number of coins in each square, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;

int main()
{
	long nTest,n;
	scanf("%ld",&amp;nTest);
	while (nTest--)
	{
		ll res=0,x;
		scanf("%ld",&amp;n);
		for (long i=0; i&lt;n; ++i)
		{
			scanf("%lld",&amp;x);
			if (x&amp;1LL &amp;&amp; i&gt;0) res^=i;
		}
		if (n==1) puts("Second");
		else puts((!res)?"Second":"First");
	}
}
----------
====================
----------
ALGORITHMS.408
medium
----------
PROBLEM STATEMENT:
Alice and Bob invented the following silly game:


The game starts with an integer, [expression]).
Alice always plays first, and the two players move in alternating turns.
During each move, the current player chooses a prime number, [expression].
The first player to be unable to make a move loses the game.


Alice and Bob play [expression] for each game, print the name of the game's winner on a new line. If Alice wins, print Alice; otherwise, print Bob.

Note: Each player always plays optimally, meaning they will not make a move that causes them to lose the game if some better, winning move exists.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
using namespace std;
#define sim template &lt; class c
#define ris return * this
#define dor &gt; debug &amp; operator &lt;&lt;
#define eni(x) sim &gt; typename \
  enable_if&lt;sizeof dud&lt;c&gt;(0) x 1, debug&amp;&gt;::type operator&lt;&lt;(c i) {
sim &gt; struct rge { c b, e; };
sim &gt; rge&lt;c&gt; range(c i, c j) { return rge&lt;c&gt;{i, j}; }
sim &gt; auto dud(c* x) -&gt; decltype(cerr &lt;&lt; *x, 0);
sim &gt; char dud(...);
struct debug{
#ifdef LOCAL
~debug() { cerr &lt;&lt; endl; }
eni(!=) cerr &lt;&lt; boolalpha &lt;&lt; i; ris; }
eni(==) ris &lt;&lt; range(begin(i), end(i)); }
sim, class b dor(pair &lt; b, c &gt; d) {
  ris &lt;&lt; "(" &lt;&lt; d.first &lt;&lt; ", " &lt;&lt; d.second &lt;&lt; ")";
}
sim dor(rge&lt;c&gt; d) {
  *this &lt;&lt; "[";
  for (auto it = d.b; it != d.e; ++it)
    *this &lt;&lt; ", " + 2 * (it == d.b) &lt;&lt; *it;
  ris &lt;&lt; "]";
}
#else
sim dor(const c &amp;) { ris; }
#endif
};
#define imie(x) " [" &lt;&lt; #x ": " &lt;&lt; (x) &lt;&lt; "] "

const int nax = 1e5 + 5;
int ans[nax];
bool is[nax];

int main() {
	for(int i = 2; i &lt; nax; ++i) is[i] = true;
	for(int i = 2; i  * i &lt; nax; ++i) if(is[i])
		for(int j = i * i; j &lt; nax; j += i) is[j] = false;
	for(int i = 2; i &lt; nax; ++i) ans[i] = ans[i-1] + int(is[i]);
	int t;
	scanf("%d", &amp;t);
	while(t--) {
		int n;
		scanf("%d", &amp;n);
		puts(ans[n] % 2 ? "Alice" : "Bob");
	}
}

----------
====================
----------
ALGORITHMS.409
easy
----------
PROBLEM STATEMENT:
Poker Nim is another [expression]-player game that's a simple variation on a Nim game. The rules of the games are as follows:


The game starts with [expression] chips.
The players move in alternating turns. During each move, the current player must perform either of the following actions:

Remove one or more chips from a single pile. 
Add one or more chips to a single pile.     

At least [expression] chip must be added or removed during each turn.
To ensure that the game ends in finite time, a player cannot add chips to any pile [expression] times.
The player who removes the last chip wins the game.


Given the values of [expression] piles, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally.
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
typedef long long ll;
typedef unsigned long long ull;
using namespace std;

int main()
{
	long nTest,n,res,x,k;
	scanf("%ld",&amp;nTest);
	while (nTest--)
	{
		scanf("%ld%ld%ld",&amp;n,&amp;k,&amp;res);
		for (long i=1; i&lt;n; ++i) scanf("%ld",&amp;x),res^=x;
		puts((!res)?"Second":"First");
	}
}

----------
====================
----------
ALGORITHMS.410
medium
----------
PROBLEM STATEMENT:
Two players (numbered [expression]) are playing a game of Tower Breakers! The rules of the game are as follows:


Player [expression] always moves first, and both players always move optimally.
Initially there are [expression] towers of various heights.
The players move in alternating turns. In each turn, a player can choose a tower of height [expression].
If the current player is unable to make any move, they lose the game.


Given the value of [expression].
----------
TOP SOLUTION:
----------
#include &lt;ios&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int g[1000005] = {};
std::vector&lt;std::vector&lt;int&gt; &gt; factors;
std::vector&lt;int&gt; grundys;

int main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    factors.resize(1000005);
    for (int i = 1; i &lt; 1000005; i++)
        for (int j = 2*i; j &lt; 1000005; j+=i)
            factors[j].push_back(i);
    g[1] = 0;
    for (int i = 2; i &lt; 1000005; i++)
    {
        g[i] = -1;
        grundys.clear();
        for (std::vector&lt;int&gt;::iterator it = factors[i].begin(); it != factors[i].end(); it++)
            grundys.push_back(g[*it]);
        std::sort(grundys.begin(), grundys.end());
        int last = -1;
        for (std::vector&lt;int&gt;::iterator it = grundys.begin(); it != grundys.end(); it++)
        {
            if (*it != last &amp;&amp; *it != last+1)
            {
                g[*it] = last+1;
                break;
            }
            else if (*it == last+1)
            {
                last++;
            }
        }
        if (g[i] == -1)
            g[i] = last+1;
    }
    int tc, n, x;
    std::cin &gt;&gt; tc;
    while (tc--)
    {
        std::cin &gt;&gt; n;
        int grundy_total = 0;
        while (n--)
        {
            std::cin &gt;&gt; x;
            grundy_total ^= g[x];
        }
        if (grundy_total == 0)
            std::cout &lt;&lt; "2\n";
        else
            std::cout &lt;&lt; "1\n";
    }
}
----------
====================
----------
ALGORITHMS.411
medium
----------
PROBLEM STATEMENT:
Two players (numbered [expression]) are playing a game of Tower Breakers! The rules of the game are as follows:


Player [expression] always moves first.
Initially there are [expression] towers of various heights.
The players move in alternating turns. In each turn, a player must choose a tower of height [expression].  
If the current player is unable to make any move, they lose the game.


Given the value of [expression].
----------
TOP SOLUTION:
----------
#include &lt;ios&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int g[100005] = {};
std::vector&lt;std::vector&lt;int&gt; &gt; factors;
std::vector&lt;int&gt; grundys;

int main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    factors.resize(100005);
    for (int i = 1; i &lt; 100005; i++)
        for (int j = 2*i; j &lt; 100005; j+=i)
            factors[j].push_back(i);
    g[1] = 0;
    for (int i = 2; i &lt; 100005; i++)
    {
        g[i] = -1;
        grundys.clear();
        for (std::vector&lt;int&gt;::iterator it = factors[i].begin(); it != factors[i].end(); it++)
        {
            if ((i/(*it)) &amp; 1)
                grundys.push_back(g[*it]);
            else
                grundys.push_back(0);
        }
        std::sort(grundys.begin(), grundys.end());
        int last = -1;
        for (std::vector&lt;int&gt;::iterator it = grundys.begin(); it != grundys.end(); it++)
        {
            if (*it != last &amp;&amp; *it != last+1)
            {
                g[*it] = last+1;
                break;
            }
            else if (*it == last+1)
            {
                last++;
            }
        }
        if (g[i] == -1)
            g[i] = last+1;
    }
    int tc, n, x;
    std::cin &gt;&gt; tc;
    while (tc--)
    {
        std::cin &gt;&gt; n;
        int grundy_total = 0;
        while (n--)
        {
            std::cin &gt;&gt; x;
            grundy_total ^= g[x];
        }
        if (grundy_total == 0)
            std::cout &lt;&lt; "2\n";
        else
            std::cout &lt;&lt; "1\n";
    }
}
----------
====================
----------
ALGORITHMS.412
medium
----------
PROBLEM STATEMENT:

  Nim is a famous game in which two players take turns removing items from [expression] distinct piles. During each turn, a player must remove one or more items from a single, non-empty pile. The winner of the game is whichever player removes the last item from the last non-empty pile.


John and Kate modified Nim by adding the following rule, which they call a Zero-Move:

For each non-empty pile, either player can remove [expression]; that said, either player is free to perform a Zero-Move on any other non-empty pile that hasn't had a Zero-Move performed on it yet.

John and Kate play [expression] games of Zero-Move Nim. Given the number of items in each pile for each game, determine whether or not John can win the game if he always moves first and each player always moves optimally (i.e., never makes a move that causes them to lose if some better, winning move exists). For each game, print W on a new line if John can win; otherwise, print L instead.
----------
TOP SOLUTION:
----------
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class D {
	InputStream is;
	PrintWriter out;
	String INPUT = "";
	
	void solve()
	{
//		int[] nim = new int[1000];
//		for(int i = 0;i &lt; 1000;i++){
//			if(i == 0){
//				nim[i] = 0;
//				continue;
//			}
//			BitSet bs = new BitSet();
//			for(int j = 0;j &lt; i;j++){
//				bs.set(nim[j]);
//			}
//			bs.set(i);
//			nim[i] = bs.nextClearBit(0);
//		}
//		tr(nim);
		for(int T = ni();T &gt; 0;T--){
			int n = ni();
			int x = 0;
			for(int i = 0;i &lt; n;i++)x ^= (ni()-1^1)+1;
			out.println(x != 0 ? "W" : "L");
		}
	}
	
	void run() throws Exception
	{
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+"ms");
	}
	
	public static void main(String[] args) throws Exception { new D().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf &gt;= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf &lt;= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c &gt;= 33 &amp;&amp; c &lt;= 126); }
	private int skip() { int b; while((b = readByte()) != -1 &amp;&amp; isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) &amp;&amp; b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p &lt; n &amp;&amp; !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i &lt; n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i &lt; n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 &amp;&amp; !((b &gt;= '0' &amp;&amp; b &lt;= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b &gt;= '0' &amp;&amp; b &lt;= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
}

----------
====================
----------
ALGORITHMS.413
medium
----------
PROBLEM STATEMENT:
Two players are playing a game on a [expression] chessboard. The rules of the game are as follows:


The game starts with [expression].
In each move, a player must move a single coin from some cell [expression] to one of the following locations:

[expression] 
[expression] 
[expression] 
[expression]. 

Note: The coin must remain inside the confines of the board.
The players move in alternating turns. The first player who is unable to make a move loses the game.


The figure below shows all four possible moves:



Note: While the figure shows a [expression] board.

Given the value of [expression] coins, determine which player will win the game. Assume both players always move optimally.
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std ;

vector &lt; vector &lt; int &gt; &gt; grundy ( 16 , vector &lt; int &gt; ( 16 , - 1 ) ) ;

int find_grundy ( int x , int y )
{
    if ( x &lt; 1 || y &gt; 15 || x &gt; 15 || y &lt; 1 )
    {
        return - 1 ;    
    }
    if ( grundy [ x ] [ y ] != - 1 )
    {
        return grundy [ x ] [ y ] ;    
    }
    set &lt; int &gt; s ;
    int i = 0 ;
    set &lt; int &gt; :: iterator it ;
    s.insert ( find_grundy ( x - 2 , y + 1 ) ) ;
    s.insert ( find_grundy ( x - 2 , y - 1 ) ) ;
    s.insert ( find_grundy ( x + 1 , y - 2 ) ) ;
    s.insert ( find_grundy ( x - 1 , y - 2 ) ) ;
    while ( 1 )
    {
        it = s.find ( i ) ;
        if ( it == s.end () )
        {
            grundy [ x ] [ y ] = i ;
            return i ;
        }
        i ++ ;
    }
    return - 1 ;
}

int main ()
{
    for ( int i = 1 ; i &lt; 16 ; i ++ )
    {
        for ( int j = 1 ; j &lt; 16 ; j ++ )
        {
            find_grundy ( i , j ) ;
            //cout &lt;&lt; grundy [ i ] [ j ] &lt;&lt; " " ;
        }
        //cout &lt;&lt; endl ;
    }
    
    int t ;
    cin &gt;&gt; t;
    while ( t -- )
    {
        int k ;
        cin &gt;&gt; k ;
        int allxor = 0 ;
        while ( k -- )
        {
            int x , y ;
            cin &gt;&gt; x &gt;&gt; y ;
            allxor = allxor ^ grundy [ x ] [ y ] ;   
        }
        if ( allxor == 0 )
        {
            cout &lt;&lt;  "Second" &lt;&lt; endl ;   
        }
        else
        {
            cout &lt;&lt; "First" &lt;&lt; endl ;    
        }
    }
    return 0 ;
}
----------
====================
----------
ALGORITHMS.414
medium
----------
PROBLEM STATEMENT:
Two HackerRank staffers found a secret room with a mysterious [expression] square board and decided to play a game with it. The game has the following rules:


At the beginning of the game, the players write a single digit (given as input) ranging from [expression] square board. 
The players move in alternating turns. In each move, the current player performs the following actions:

Chooses a board that has at least one non-prime number written on it and has more than one cell (i.e., dimensions [expression]). 
Cuts the chosen board into [expression] smaller boards by breaking it along any horizontal or vertical line at the edge of a cell.

Note: Although the game starts with one [expression] pieces of the original board (as long as it can have a legal move performed on it).
The game ends when there are no more cuttable boards (i.e., there are [expression] boards, or all boards have only prime numbers written on them). The first player who is unable to make a move loses.


Given the value of [expression] cell of the board, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally.

Time Limit


Python: 18 seconds
Pypy2: 5 seconds


For other languages, the time limit is standard.
----------
TOP SOLUTION:
----------
'use strict';

function isPrime(n){
	return n == 2 || n == 3 || n == 5 || n == 7;
}


function num_composites(numbers){
	var dim = numbers.length;
	var composites_for_row = []
	for(var i = 0; i &lt; dim; i++){
		var add = []
		for(var j = 0; j &lt; dim; j++){
			add.push(0)
		}
		composites_for_row.push(add);
	}
	for(var top = 0; top &lt; dim; top++){
		for(var left = 0; left &lt; dim; left++){
			if (left == 0){
				if (!isPrime(numbers[top][left])) {
					composites_for_row[top][0] = 1
				}
			}
			else {
				if (!isPrime(numbers[top][left])) {
					composites_for_row[top][left] = composites_for_row[top][left-1] + 1
				}
				else{
					composites_for_row[top][left] = composites_for_row[top][left-1]
				}
			}
		}
	}
	var composites_between_rows = []
	for(var i = 0; i &lt; dim; i++){
		var add = []
		for(var j = 0; j &lt; dim; j++){
			var more_add = []
			for(var k = 0; k &lt; dim; k++){
				more_add.push(0);
			}
			add.push(more_add)
		}
		composites_between_rows.push(add);
	}	
	for(var top = 0; top &lt; dim; top++){
		for(var bottom = top; bottom &lt; dim; bottom++){
			for(var left = 0; left &lt; dim; left++){
				if (bottom == top){
					composites_between_rows[top][bottom][left] = composites_for_row[top][left]
				}
				else{
					composites_between_rows[top][bottom][left] = composites_between_rows[top][bottom-1][left] + composites_for_row[bottom][left]
				}
			}
		}
	}
	return composites_between_rows
}

function grundy_numbers(numbers, comps){
	var dim = numbers.length;
	var grundy_numbers = []
	for(var i = 0; i &lt; dim; i++){
		var add = []
		for(var j = 0; j &lt; dim; j++){
			add.push(0)
		}
		grundy_numbers.push(add);
	}
	for(var height = 0; height &lt; dim; height++){
		for(var width = 0; width &lt; dim; width++){
			var local_grundy = []
			for(var i = 0; i &lt; dim-height; i++){
				var add = []
				for(var j = 0; j &lt; dim-width; j++){
					add.push(0)
				}
				local_grundy.push(add);
			}
			for(var top = 0; top &lt; dim - height; top++){
				for(var left=0; left &lt; dim - width; left++){
					if (height == 0 &amp;&amp; width == 0){
						local_grundy[top][left] = 0
					}
					else{
						var allPrime = true
						if (left == 0){
							if (comps[top][top+height][left+width] &gt; 0){
								allPrime = false
							}
						}
						else{
							if (comps[top][top+height][left+width]-comps[top][top+height][left-1] &gt; 0){
								allPrime = false
							}
						}
						if (allPrime){
							local_grundy[top][left] = 0
						}
						else{
							var answers = []
							for(var j = 0; j &lt; 2*dim; j++){
								answers.push(0)
							}
							for(var j = 0; j &lt; width; j++){
								var val = grundy_numbers[height][j][top][left]^grundy_numbers[height][width-j-1][top][left+j+1]
								if (val &lt; 2*dim){
									answers[val] += 1
								}
							}
							for(var i = 0; i &lt; height; i++){
								var val = grundy_numbers[i][width][top][left]^grundy_numbers[height-i-1][width][top+i+1][left]
								if (val &lt; 2*dim) answers[val] += 1
							}
							var _i = 0
							for(var i = 0; i &lt; answers.length; i++){
								if (answers[i] == 0){
									_i = i;
									break;
								}
							}
							local_grundy[top][left] = i
						}
					}
				}
			}
			grundy_numbers[height][width] = local_grundy
		}
	}
	return grundy_numbers[dim-1][dim-1][0][0]
}

function solution(numbers){
	var dim = numbers.length;
	if (dim &lt; 2){
		return 'Second';
	}
	var comps = num_composites(numbers);
	if (comps[0][dim-1][dim-1] == 0){
		return 'Second'
	}
	var answer = grundy_numbers(numbers, comps)
	if(answer &gt; 0){
		return 'First'
	}
	else{
		return 'Second'	
	}
}

function processData(input) {
	input = input.split('\n');
	var num_cases = parseInt(input[0]);
	var currentLine = 1;
	for(var i = 0; i &lt; num_cases; i++){
		var length = parseInt(input[currentLine]);
		var numbers = []
		for(var j = 0; j &lt; length; j++){
			currentLine++;
			var row = []
			var info = input[currentLine].split(" ");
			for(var k = 0; k &lt; length; k++){
				row.push(parseInt(info[k]))
			}
			numbers.push(row);
		}
		var answer = solution(numbers);
		console.log(answer);
		currentLine++;
	}
} 


process.stdin.resume();
process.stdin.setEncoding("ascii");
var _input = "";
process.stdin.on("data", function (input) {
    _input += input;
});

process.stdin.on("end", function () {
   processData(_input);
});
----------
====================
----------
ALGORITHMS.415
medium
----------
PROBLEM STATEMENT:
Kyle and Mike are bored on a rainy day and decide to pass the time by creating a new game having the following rules:


The game starts with two [expression]. 
The players move in alternating turns, with [expression] points.
Each value of [expression] moves.
The player with the maximum number of points wins.
The arrays A and B are accessible to both the players P1 and P2. So the players make a optimal move at every turn. 


Given the values of [expression] if they will tie. Assume both players always move optimally.
----------
TOP SOLUTION:
----------
import math

def solution(A, B):
	n = len(A)
	C = [(A[i], B[i], A[i]+B[i]) for i in xrange(n)]
	C.sort(key=lambda x: -x[2])
	def compare(c1, c2):
		if c1[1][2] &gt; c2[1][2]: return -1
		elif c1[1][2] &lt; c2[1][2]: return 1
		else:
			if c1[0] % 2 == 0:
				return c1[1][0] - c2[1][0]
			else:
				return c1[1][1] - c2[1][1]
	C = sorted(enumerate(C), cmp=compare)
	_a = 0
	_b = 0
	for _ in xrange(n):
		if _ % 2 == 0:
			_a += C[_][1][0]
		else:
			_b += C[_][1][1]
	if _a &gt; _b:
		return 'First'
	elif _a &lt; _b:
		return 'Second'
	else:
		return 'Tie'

num_cases = int(raw_input())

for _ in xrange(num_cases):
	n = int(raw_input())
	A = [int(a) for a in raw_input().split()]	
	B = [int(b) for b in raw_input().split()]
	print solution(A, B)

----------
====================
----------
ALGORITHMS.416
hard
----------
PROBLEM STATEMENT:
Consider the following game:


There are two players, First and Second, sitting in front of a pile of [expression] stones. First always plays first.
There is a set, [expression].
The players move in alternating turns. During each turn, a player chooses some [expression] equal smaller piles, the player loses.
Both players always play optimally.


Given [expression], find and print the winner of the game. If First wins, print First; otherwise, print Second.
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
using namespace std;

long long N, M;
long long int S[12];

map&lt;long long int, int&gt; dp;

bool win(long long int n)
{
    int&amp; res = dp[n];
    if(!res){
        for(int i = 0; i &lt; M; i++)
            if(n % S[i] == 0){
                if(!(S[i] &amp; 1))
                    res = 1;
                else if(!win(n / S[i]))
                    res = 1;            
            }
        res++;
    }
    return res - 1;
    
}

int main() {
    
    cin &gt;&gt; N &gt;&gt; M;
    for(int i = 0; i &lt; M; i++)
        cin &gt;&gt; S[i];
    cout &lt;&lt; (win(N)? "First": "Second") &lt;&lt; '\n';
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
ALGORITHMS.417
medium
----------
PROBLEM STATEMENT:
Dexter and Debra are playing a game. They have N containers each having one or more chocolates. Containers are numbered from 1 to N, where ith container has A[i] number of chocolates.

The game goes like this. First player will choose a container and take one or more chocolates from it. Then, second player will choose a non-empty container and take one or more chocolates from it. And then they alternate turns. This process will continue, until one of the players is not able to take any chocolates (because no chocolates are left). One who is not able to take any chocolates loses the game. Note that player can choose only non-empty container.

The game between Dexter and Debra has just started, and Dexter has got the first Chance. He wants to know the number of ways to make a first move such that under optimal play, the first player always wins.
----------
TOP SOLUTION:
----------
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.InputMismatchException;
import java.io.PrintStream;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Writer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Nipuna Samarasekara
 */
public class Solution {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		FastScanner in = new FastScanner(inputStream);
		FastPrinter out = new FastPrinter(outputStream);
		Task2 solver = new Task2();
		solver.solve(1, in, out);
		out.close();
	}
}

class Task2 {

    /////////////////////////////////////////////////////////////

    public void solve(int testNumber, FastScanner in, FastPrinter out) {
        int n=in.nextInt();
        int[] A= in.readIntArray(n);
        int xor=0;
        for (int i : A) {
            xor^=i;
        }
        int ans=0;
        for (int i = 0; i &lt; n; i++) {
            int nn=xor^A[i];
            if(A[i]&gt;nn)ans++;
        }
        out.println(ans);
    }
}

class FastScanner extends BufferedReader {

    public FastScanner(InputStream is) {
        super(new InputStreamReader(is));
    }

    public int read() {
        try {
            int ret = super.read();
//            if (isEOF &amp;&amp; ret &lt; 0) {
//                throw new InputMismatchException();
//            }
//            isEOF = ret == -1;
            return ret;
        } catch (IOException e) {
            throw new InputMismatchException();
        }
    }

    static boolean isWhiteSpace(int c) {
        return c &gt;= 0 &amp;&amp; c &lt;= 32;
    }

    public int nextInt() {
        int c = read();
        while (isWhiteSpace(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int ret = 0;
        while (c &gt;= 0 &amp;&amp; !isWhiteSpace(c)) {
            if (c &lt; '0' || c &gt; '9') {
                throw new NumberFormatException("digit expected " + (char) c
                        + " found");
            }
            ret = ret * 10 + c - '0';
            c = read();
        }
        return ret * sgn;
    }

    public String readLine() {
        try {
            return super.readLine();
        } catch (IOException e) {
            return null;
        }
    }

    public int[] readIntArray(int n) {
        int[] ret = new int[n];
        for (int i = 0; i &lt; n; i++) {
            ret[i] = nextInt();
        }
        return ret;
    }

}

class FastPrinter extends PrintWriter {

    public FastPrinter(OutputStream out) {
        super(out);
    }

    public FastPrinter(Writer out) {
        super(out);
    }


}


----------
====================
----------
ALGORITHMS.418
medium
----------
PROBLEM STATEMENT:
Kitty and Katty have [expression] and begin playing a game in turns, with Kitty always taking the first turn. The game's rules are as follows:


For each turn, the player removes [expression], write the result on a new block, and insert the new block into the set. 
The game ends when only [expression]:
If [expression], then Kitty wins.
If [expression], then Katty wins.
If [expression], then the player who moved last wins.


Recall that [expression] is the Modulo Operation.

Given the value of [expression], can you find and print the name of the winner? Assume that both play optimally.

Note: The selection order for [expression].


----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;fstream&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i &lt; (int)(n); ++i)
#define for1(i, n) for (int i = 1; i &lt;= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i &gt;= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i &lt;= (int)(b); ++i)

using namespace std;

typedef pair&lt;int, int&gt; pii;
typedef vector&lt;int&gt; vi;
typedef vector&lt;pii&gt; vpi;
typedef vector&lt;vi&gt; vvi;
typedef long long i64;
typedef vector&lt;i64&gt; vi64;
typedef vector&lt;vi64&gt; vvi64;

template&lt;class T&gt; bool uin(T &amp;a, T b) { return a &gt; b ? (a = b, true) : false; }
template&lt;class T&gt; bool uax(T &amp;a, T b) { return a &lt; b ? (a = b, true) : false; }

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout &lt;&lt; fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int t;
    cin &gt;&gt; t;
    forn(i, t) {
        int n;
        cin &gt;&gt; n;
        cout &lt;&lt; (n == 1 || n % 2 == 0 ? "Kitty" : "Katty") &lt;&lt; '\n';
    }

#ifdef LOCAL_DEFINE
    cerr &lt;&lt; "Time elapsed: " &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.419
medium
----------
PROBLEM STATEMENT:
After their success in coming up with Fun Game, Kyle and Mike invented another game having the following rules:


The game starts with an [expression]. 
The players move in alternating turns, with [expression]) in the above sequence and changes it to either a + (plus) or a - (minus) sign.  
The game ends when there are no more asterisks ([expression] wins.


Given the value of [expression] will win. Assume both players always move optimally.
----------
TOP SOLUTION:
----------
def solution(N):
	return N

num_cases = int(raw_input())

for _ in xrange(num_cases):
	N = int(raw_input())
	if N % 8 == 0:
		print 'Second'
	else:
		print 'First'

----------
====================
----------
ALGORITHMS.420
medium
----------
PROBLEM STATEMENT:
Alice and Bob are playing a game with a rooted tree. The tree has [expression], is always the root. Here are the basic rules:


They move in alternating turns, and both players always move optimally.
During each move, a player removes an edge from the tree, disconnecting one of its leaves or branches. The leaf or branch that was disconnected from the rooted tree is removed from the game. 
The first player to be unable to make a move loses the game.
Alice always makes the first move. 


For example, the diagram below shows a tree of size [expression]:


Now, if a player removes the edge between [expression] become disconnected from the root and are removed from the game:



Given the structure of the tree, determine and print the winner of the game. If Alice wins, print [expression].
----------
TOP SOLUTION:
----------
from sets import Set

def grundy_number(root, parent, edges, num_neighbours):
	all_grundies = []
	if num_neighbours[root] == 0:
		return 0
	if num_neighbours[root] == 1 and root != 0:
		return 0
	if num_neighbours[root] == 1 and root == 0:
		return 1
	else:
		nim_sum = 0
		for index, neighbour in enumerate(edges[root]):
			if index != parent and neighbour &gt; 0:
				val = grundy_number(index, root, edges, num_neighbours)
				nim_sum = nim_sum ^ (1 + val)
		return nim_sum


def solution(edges):
	num_neighbours = [0 for _ in xrange(len(edges))]
	for node in xrange(len(num_neighbours)):
		num_neighbours[node] = sum(edges[node])
	val_for_root = grundy_number(0, -1, edges, num_neighbours)
	if val_for_root &gt; 0:
		return 'Alice'
	else:
		return 'Bob'

num_cases = int(raw_input())

for _ in xrange(num_cases):
	num_nodes = int(raw_input())
	edges = [[0 for _ in xrange(num_nodes)] for _ in xrange(num_nodes)]
	for _ in xrange(num_nodes-1):
		line = raw_input().split()
		A = int(line[0])
		B = int(line[1])
		edges[A-1][B-1] = 1
		edges[B-1][A-1] = 1
	print solution(edges)
----------
====================
----------
ALGORITHMS.421
medium
----------
PROBLEM STATEMENT:
Bob and Ben are playing a game with forests! The game's rules are as follows:


The game starts with a forest of [expression] trees.
Bob always moves first and they take alternating turns. The first player with no available move loses the game.
During each move, the player removes one node. If the node is not a leaf, then the whole tree vanishes; otherwise, the rest of the tree remains in the forest. We define a leaf to be a node with exactly [expression] connected edge.
Both players play optimally, meaning they will not make a move that causes them to lose the game if some better, winning move exists.


We define each tree [expression]-tree forest as follows:


Tree [expression] (a constant). 
Its nodes are numbered sequentially from [expression].
Its edges are numbered sequentially from [expression].


Given the values of [expression] for each tree in the forest, can you determine who will win the game?
----------
TOP SOLUTION:
----------
#include &lt;bits/stdc++.h&gt;
typedef long long LL;
using namespace std;

int main(){
	int g;
	cin &gt;&gt; g;
	for(int G = 0; G &lt; g; G++){
		int n;
		cin &gt;&gt; n;
		int ans = 0;
		for(int i = 0; i &lt; n; i++){
			int m, k;
			cin &gt;&gt; m &gt;&gt; k;
			if(m % 2){
				ans ^= 1;
			} else if(m &gt;= 4){
				ans ^= 2;
			}
		}
		if(ans == 0){
			cout &lt;&lt; "BEN" &lt;&lt; endl;
		} else {
			cout &lt;&lt; "BOB" &lt;&lt; endl;
		}
	}
}
----------
====================
----------
ALGORITHMS.422
medium
----------
PROBLEM STATEMENT:
Our unsung tower-breaking heroes (players [expression] days of Game Theory! The rules are as follows:


[expression] always moves first, and both players always move optimally.
Initially there is [expression].
The players move in alternating turns. The moves performed by each player are different:
At each turn, [expression] new tower.
At each turn, [expression] and the game continues.
The game is over when no valid move can be made by [expression].
[expression]'s goal is to earn as many coins as possible. 


Can you predict the number of coins that [expression] will earn?
----------
TOP SOLUTION:
----------
import math
import pprint 

pp = pprint.PrettyPrinter(indent=4)

def iterator():
	price_per_height = [0 for _ in xrange(200)]
	price_per_height[0] = 1
	price_per_height[1] = None
	price_per_height[2] = None
	price_per_height[3] = 1
	price_per_height[4] = 1
	price_per_height[5] = 2
	price_per_height[6] = 3
	price_per_height[7] = 4
	price_per_height[8] = 5
	price_per_height[9] = 7
	for i in xrange(10,200):
		sqrt = int(math.sqrt(i))
		total = price_per_height[i-1] 
		for diff in xrange(1, sqrt+1):
			k_th_stack = i - diff*diff
			if k_th_stack &gt; 3:
				total += price_per_height[k_th_stack] - price_per_height[k_th_stack-1]
			if i == diff*diff + 1:
				total += 1
		price_per_height[i] = total
	return price_per_height

price_per_height = iterator()
# pp.pprint(price_per_height[:17])

def solution2(height):
	result = 0
	for index, h in enumerate(price_per_height):
		# print index, h
		if height &gt; h:
			result = index
		else:
			break
	return result	

def solution(height):

	dp = [None for _ in xrange(height+1)]
	stacks = []
	for i in xrange(2, height+1):
		if i == 2:
			dp[i] = 4
			stacks = [1,1]
		elif i == 3:
			dp[i] = 5
			stacks = [2,1]
		else:
			# print i-1, stacks, dp[i-1]
			candidate = dp[i-1]
			num_stacks = len(stacks)
			next_candidate = None
			val = None
			for index in xrange(num_stacks):
				stack = stacks[index]
				if next_candidate &gt;= dp[stack+1] + (index+1)*(index+1) or next_candidate is None:
					next_candidate = dp[stack+1] + (index+1)*(index+1)
					val = index
			if next_candidate == candidate:
				stacks[val] += 1
				dp[i] = candidate
			elif next_candidate &lt;= (num_stacks+1)*(num_stacks+1):
				stacks[val] += 1
				dp[i] = next_candidate
			else:
				stacks.append(1)
				dp[i] = (num_stacks+1)*(num_stacks+1)
	# compare = 4
	# for index, val in enumerate(dp):
	# 	if val == compare:
	# 		print index-1, compare
	# 		compare += 1
	# val = iterator()
	# pp.pprint(val[:15])

	return dp[-1]

# for x in xrange(2, 500):
# 	a1 = solution(x)
# 	a2 = solution2(x)
# 	print a1, a2, x
num_cases = int(raw_input())

for _ in xrange(num_cases):
	height = int(raw_input())
	print solution2(height)


----------
====================
----------
ALGORITHMS.423
hard
----------
PROBLEM STATEMENT:
Big Cat and Little Cat love playing games. Today, they decide to play a Game of Stones, the Kitties are Coming edition. The game's rules are as follows: 


The game starts with [expression] piles. 
The cats move in alternating turns, and Little Cat always moves first.
During a move, a cat picks a pile having a number of stones [expression]. 
The first cat to be unable to make a move (e.g., because all piles contain exactly [expression] stone) loses the game. 


Little Cat is curious about the number of ways in which the stones can be initially arranged so that she is guaranteed to win. Two arrangements of stone piles are considered to be different if they contain different sequences of values. For example, arrangements [expression] are different.

Given the values for [expression]. 

Note: Each cat always moves optimally, meaning that they're both playing to win and neither cat will make a move that causes them to lose the game if some other (winning) sequence of moves can be made.
----------
TOP SOLUTION:
----------
import java.io.*;
import java.util.*;

public class HR_simple_game {

    final static long MOD = 1000000007;

    static int K;
    static HashMap&lt;Integer, BitSet&gt;[] cache;
    static int[] mexCache;

    static int mex(int n) {
        if (mexCache[n] == -1) {
            mexCache[n] = 0;
            BitSet set = new BitSet();
            for (int k = 2; k &lt;= K; ++k) {
                set.or(d(n, k));
            }
            while (set.get(mexCache[n])) {
                mexCache[n]++;
            }
        }
        return mexCache[n];
    }

    static BitSet d(int n, int k) {
        if (cache[n] == null) {
            cache[n] = new HashMap&lt;&gt;();
        }
        BitSet ret = cache[n].get(k);
        if (ret == null) {
            ret = new BitSet();
            if (k == 1) {
                ret.set(mex(n));
            } else {
                for (int n1 = 1; n1 &lt; n; ++n1) {
                    BitSet s1 = d(n1, k - 1);
                    int v2 = mex(n - n1);
                    for (int v1 = s1.nextSetBit(0); v1 &gt;= 0; v1 = s1.nextSetBit(v1 + 1)) {
                        ret.set(v1 ^ v2);
                    }
                }
            }
            cache[n].put(k, ret);
        }
        return ret;
    }

    public static void solve(Input in, PrintWriter out) throws IOException {
        int n = in.nextInt();
        int m = in.nextInt();
        K = in.nextInt();
        int[] values = new int[n + 1];
        if (K &lt;= 3) {
            cache = new HashMap[n + 1];
            mexCache = new int[n + 1];
            Arrays.fill(mexCache, -1);
            for (int i = 0; i &lt;= n; ++i) {
                values[i] = mex(i);
            }
        } else {
            for (int i = 2; i &lt;= n; ++i) {
                values[i] = i - 1;
            }
        }
        int maxValue = 1;
        for (int i = 0; i &lt;= n; ++i) {
            while (maxValue &lt;= values[i]) {
                maxValue *= 2;
            }
        }
//        System.err.println(Arrays.toString(values));
        long[][] d = new long[n + 1][maxValue];
        d[0][0] = 1;
        for (int it = 0; it &lt; m; ++it) {
            long[][] d1 = new long[n + 1][maxValue];
            for (int i = 0; i &lt;= n; ++i) {
                for (int v = 0; v &lt; maxValue; ++v) {
                    if (d[i][v] == 0) {
                        continue;
                    }
                    for (int j = 1; i + j &lt;= n; ++j) {
                        d1[i + j][v ^ values[j]] += d[i][v];
                    }
                }
            }
            d = d1;
            for (int i = 0; i &lt;= n; ++i) {
                for (int v = 0; v &lt; maxValue; ++v) {
                    d[i][v] %= MOD;
                }
            }
        }
        long ans = 0;
        for (int v = 1; v &lt; maxValue; ++v) {
            ans += d[n][v];
        }
        out.println(ans % MOD);
    }

    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);
        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);
        out.close();
    }

    static class Input {
        BufferedReader in;
        StringBuilder sb = new StringBuilder();

        public Input(BufferedReader in) {
            this.in = in;
        }

        public Input(String s) {
            this.in = new BufferedReader(new StringReader(s));
        }

        public String next() throws IOException {
            sb.setLength(0);
            while (true) {
                int c = in.read();
                if (c == -1) {
                    return null;
                }
                if (" \n\r\t".indexOf(c) == -1) {
                    sb.append((char)c);
                    break;
                }
            }
            while (true) {
                int c = in.read();
                if (c == -1 || " \n\r\t".indexOf(c) != -1) {
                    break;
                }
                sb.append((char)c);
            }
            return sb.toString();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }
}

----------
====================
----------
ALGORITHMS.424
medium
----------
PROBLEM STATEMENT:
Alice and Bob play the following game:


They choose a permutation of the numbers [expression].  
Alice plays first and they alternate.  
In a turn, they can remove any one remaining number from the permutation.  
The game ends when the remaining numbers form an increasing sequence of [expression] or more numbers. The person who played the last turn (after which the sequence becomes increasing) wins the game.  


Assuming both play optimally, who wins the game?  

For example, if [expression].  Since this is a decreasing sequence, Bob can remove any number for optimum play (he will lose regardless).  Alice then removes any number leaving an array of only one element.  Since Alice removed the last element to create an increasing sequence, Alice wins. 

Function Description  

Complete the permutationGame function in the editor below.  It should return a string that represents the winner of the game, either Bob or Alice.  

permutationGame has the following parameter: 
- arr: an array of integers that represents the starting permutation  
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cctype&gt;
#include &lt;numeric&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;sstream&gt;
#define FOR(i,s,e) for(int i=(s);i&lt;(int)(e);i++)
#define FOE(i,s,e) for(int i=(s);i&lt;=(int)(e);i++)
#define ALL(x) (x).begin(), (x).end()
#define CLR(s) memset(s,0,sizeof(s))
#define PB push_back
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
typedef map&lt;int,int&gt; mii;
typedef vector&lt;int&gt; vi;
#define x first
#define y second

int n, a[16];
bool win[1&lt;&lt;15];
int dp[1&lt;&lt;15];

int go(int x) {
        int &amp;res = dp[x];
        if (res != -1) return res;
        res = 0;
        if (win[x]) return res;
        FOR(i, 0, n)
                if ((x&gt;&gt;i)&amp;1)
                        res |= !go(x ^ (1&lt;&lt;i));
        return res;
}

int main() {
        int z;
        scanf("%d", &amp;z);
        while (z--) {
                scanf("%d", &amp;n);
                FOR(i, 0, n) scanf("%d", a+i);
                FOR(i, 0, 1&lt;&lt;n) {
                        win[i] = 1;
                        int last = -1;
                        FOR(j, 0, n) {
                                if ((i&gt;&gt;j)&amp;1) {
                                        if (last == -1) last = j;
                                        else win[i] &amp;= (a[last] &lt; a[j]), last = j;
                                }
                        }
                }
                FOR(i, 0, 1&lt;&lt;n) dp[i] = -1;
                int ans = go((1&lt;&lt;n) - 1);
                puts(ans ? "Alice" : "Bob");
        }
        return 0;
}

----------
====================
----------
ALGORITHMS.425
hard
----------
PROBLEM STATEMENT:
Alice and Bob are playing a game, defined below:


There is an undirected tree graph with [expression] nodes that has the following properties: 
Each node has [expression] golden coins. 
Node [expression] is root of the tree. 
The parent node of some node [expression].
Moves
Players move in turns. 
During a move, a player can select a node [expression]. 
If the current player can't make any move, they lose the game.


The game quickly becomes boring because the result is determined by the tree's configuration and the number of coins in each node (assuming that both players play optimally).

Alice decides to instead challenge Bob by asking him [expression]:


Alice picks a node [expression]. 
She picks another node [expression].


Bob must determine if the first player has a winning strategy for the new tree or not. It's possible that after Alice draws the new edge, the graph will no longer be a tree; if that happens, the question is invalid. Each question is independent, so the answer depends on the initial state of the graph (and not on previous questions).

Given the tree and the number of coins in each node, can you help Bob answer all [expression] questions?
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;iomanip&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
using namespace std;

#define N 1000000
int Time, n, x, y, q, c[N]; 
int L[N], R[N], ni[N][2], dep[N];
vector &lt;int&gt; ve[N];


void dfs(int k, int f) {
	L[k] = ++Time;
	ni[k][dep[k]] = c[k];
	for (int i = 0; i &lt; (int) ve[k].size(); i++)
		if (ve[k][i] != f) {
			dep[ve[k][i]] = dep[k] ^ 1;
			dfs(ve[k][i], k);
			ni[k][0] ^= ni[ve[k][i]][0];
			ni[k][1] ^= ni[ve[k][i]][1];
		}
	R[k] = Time;
}

int main() {
	scanf("%d", &amp;n);
	for (int i = 1; i &lt;= n; i++)
		scanf("%d", &amp;c[i]);
	for (int i = 1; i &lt; n; i++) {
		scanf("%d%d", &amp;x, &amp;y);
		ve[x].push_back(y);
		ve[y].push_back(x);
	}
	dep[1] = 0;
	dfs(1, 0);
	scanf("%d", &amp;q);
	while (q--) {
		scanf("%d%d", &amp;x, &amp;y);
		if (L[x] &lt;= L[y] &amp;&amp; L[y] &lt;= R[x])
			printf("INVALID\n");
		else {
			if ((dep[y] + dep[x]) % 2 == 1) {
				if (ni[1][1])
					printf("YES\n");
				else
					printf("NO\n");
			}else {
				if (ni[1][1] ^ ni[x][1] ^ ni[x][0])
					printf("YES\n");
				else
					printf("NO\n");
			}
		}
	}
}
----------
====================
----------
ALGORITHMS.426
medium
----------
PROBLEM STATEMENT:
General Iroh and Commandant Bumi are heading to the Republic City to stop a rebellion. But it's quite a long travel, so in the meantime they have started discussing about possible attacking plans. Right now, they're arguing about best ways for moving soldiers during the battle. Tired of not getting a final and concise strategy, Iroh proposed a particularly original idea.

Iroh:

Bumi, look at this map: here we have all possible locations in the battle field soldiers can occupy. I know a game which can give us some ideas.


Bumi:

A game? How will a game help us here?


Iroh:

It's pretty simple, we know which location is connected to each one, and also, that all those paths between locations are one-way (it's too dangerous to have two ways paths), so we place some soldiers at random initial locations, take turns, and in each turn, we try to make a valid move with one soldier from one location to another. Eventually, we won't be able to move any man so, the first one which is not able to perform any valid move, loses. One important thing is, at some moment, we may have some men at the same field location.


Bumi:

Are you sure we are gonna end this? We have so many locations and paths... don't know, soldiers could be moving in circles for ever.


Iroh:

Take it easy man, those paths were built by the best architects I've ever known, so there is no way that could happen.


Bumi:

Well, I still don't get how does this help us.


Iroh:

Me neither, but greatest generals from the Earth Kingdom created their strategies from this game, so, who knows?


Bumi:

Ok, I'm in. Who plays first?


Iroh:

You go first my friend. Just make sure you always do your best, because I will show no mercy to you :).

----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#define rep(i,n) for(int (i)=0;(i)&lt;(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)&lt;=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)&lt;(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus &gt; 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector&lt;int&gt; vi; typedef pair&lt;int,int&gt; pii; typedef vector&lt;pair&lt;int,int&gt; &gt; vpii;
typedef long long ll; typedef vector&lt;long long&gt; vl; typedef pair&lt;long long,long long&gt; pll; typedef vector&lt;pair&lt;long long,long long&gt; &gt; vpll;
typedef vector&lt;string&gt; vs; typedef long double ld;
template&lt;typename T, typename U&gt; inline void amin(T &amp;x, U y) { if(y &lt; x) x = y; }
template&lt;typename T, typename U&gt; inline void amax(T &amp;x, U y) { if(x &lt; y) x = y; }

bool topologicalSort(const vector&lt;vi&gt; &amp;g, vi &amp;ord) {
	int n = g.size();
	vi deg(n);
	rep(i, n) each(j, g[i]) deg[*j] ++;
	ord.assign(n, -1);
	int t = 0;
	rep(i, n) if(deg[i] == 0) ord[t ++] = i;
	for(int h = 0; h &lt; t; h ++) {
		int v = ord[h];
		each(j, g[v])
			if(-- deg[*j] == 0)
				ord[t ++] = *j;
	}
	return t == n;
}

int dp[100000];
int main() {
	int N, M;
	scanf("%d%d", &amp;N, &amp;M);
	vector&lt;vi&gt; g(N);
	rep(i, M) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b), a --, b --;
		g[a].pb(b);
	}
	vi ord;
	topologicalSort(g, ord);
	vi q;
	for(int ix = N-1; ix &gt;= 0; ix --) {
		int i = ord[ix];
		q.clear();
//		cerr &lt;&lt; i+1 &lt;&lt; ": ";
		each(j, g[i]) {
			q.push_back(dp[*j]);
//			cerr &lt;&lt; dp[*j] &lt;&lt; ", ";
		}
//		cerr &lt;&lt; "; ";
		make_heap(all(q), greater&lt;int&gt;());
		int x = 0;
		while(!q.empty() &amp;&amp; q[0] == x) {
			do {
				pop_heap(all(q), greater&lt;int&gt;());
				q.pop_back();
			}while(!q.empty() &amp;&amp; q[0] == x);
			x ++;
		}
//		cerr &lt;&lt; x &lt;&lt; endl;
		dp[i] = x;
	}
	int Q;
	scanf("%d", &amp;Q);
	rep(ii, Q) {
		int K;
		scanf("%d", &amp;K);
		int x = 0;
		rep(i, K) {
			int v;
			scanf("%d", &amp;v), v --;
			x ^= dp[v];
		}
		puts(x != 0 ? "Bumi" : "Iroh");
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.427
medium
----------
PROBLEM STATEMENT:
It's New Year's Day, and Balsa and Koca are stuck inside watching the rain. They decide to invent a game, the rules for which are described below.

Given array [expression] integers, they take turns making a single move. Balsa always moves first, and both players are moving optimally (playing to win and making no mistakes).

During each move, the current player chooses one element from [expression]; otherwise Balsa wins. 

Given [expression], determine the winner.

Note: [expression].
----------
TOP SOLUTION:
----------
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.io.*;
import java.math.*;
import java.security.*;
import java.text.*; 
import java.util.*;
import java.util.regex.*;
/*
	  br = new BufferedReader(new FileReader("input.txt"));
	  pw = new PrintWriter(new BufferedWriter(new FileWriter("output.txt")));
	  br = new BufferedReader(new InputStreamReader(System.in));
	  pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
 */


public class Solution {
	private static BufferedReader br;
	private static StringTokenizer st;
	private static PrintWriter pw;

	public static void main(String[] args) throws Exception {
		br = new BufferedReader(new InputStreamReader(System.in));
		pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
		//int qq = 1;
		//int qq = Integer.MAX_VALUE;
		int qq = readInt();
		for(int casenum = 1; casenum &lt;= qq; casenum++)	{
			int n = readInt();
			int o = 0;
			int t = 0;
			while(n-- &gt; 0) {
				int curr = readInt();
				if(curr % 3 == 1) o++;
				if(curr % 3 == 2) t++;
			}
			if(o%2 == 0 &amp;&amp; t%2 == 0) pw.println("Koca");
			else pw.println("Balsa");
		}
		exitImmediately();
	}

	private static void exitImmediately() {
		pw.close();
		System.exit(0);
	}

	private static long readLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	private static double readDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	private static int readInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	private static String nextLine() throws IOException  {
		if(!br.ready()) {
			exitImmediately();
		}
		st = null;
		return br.readLine();
	}

	private static String nextToken() throws IOException  {
		while(st == null || !st.hasMoreTokens())  {
			if(!br.ready()) {
				exitImmediately();
			}
			st = new StringTokenizer(br.readLine().trim());
		}
		return st.nextToken();
	}
}
----------
====================
----------
ALGORITHMS.428
hard
----------
PROBLEM STATEMENT:
There are [expression] stones in it. Alice and Bob play the following game:


Alice starts, and they alternate turns.
In a turn, a player can choose any one of the piles of stones and divide the stones in it into any number of unequal piles such that no two of the newly created piles have the same number of stones. For example, if there 8 stones in a pile, it can be divided into one of these set of piles: [expression].&nbsp;
The player who cannot make a move (because all the remaining piles are indivisible) loses the game.


Given the starting set of piles, who wins the game assuming both players play optimally (that means they will not make a move that causes them to lose the game if some better, winning move exists)?
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cctype&gt;
#include &lt;numeric&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;sstream&gt;
#define FOR(i,s,e) for(int i=(s);i&lt;(int)(e);i++)
#define FOE(i,s,e) for(int i=(s);i&lt;=(int)(e);i++)
#define ALL(x) (x).begin(), (x).end()
#define CLR(s) memset(s,0,sizeof(s))
#define PB push_back
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
typedef map&lt;int,int&gt; mii;
typedef vector&lt;int&gt; vi;
#define x first
#define y second

const int N = 60;

int sum = 0;
int sg[N+5];

int a[1000];
int kk = 0;

void F(int n, int f, int xr, vi &amp;v) {
        // create a pile of size "f"
        n  -= f;
        xr ^= sg[f];

        if (n&lt;0) return;
        if (n==0) {

//              FOR(i,0,kk) printf("%d ", a[i]); puts("");
//              FOR(i,0,kk) printf("%s%d ", (i==0?"(":""), sg[a[i]]); puts(")");

                v.PB(xr);
                return;
        }
        for(int k=f+1;k&lt;=n;k++) {
                a[kk++] = k;
                F(n, k, xr, v);
                kk--;
        }
}

void init() {
        CLR(sg);
        FOE(i,1,N) {
                vi v;
                F(i, 0, 0, v);
                sort(v.begin(), v.end());

                v.erase(v.begin());     // single..
//              FOR(r,0,v.size()) printf("-&gt;%d",v[r]);puts("");

                v.erase(unique(v.begin(), v.end()), v.end());
                // mex
                int lt = -1;
                FOR(j,0,v.size()) {
                        if(v[j] != lt+1) break;
                        lt = v[j];
                }
                sg[i] = lt+1;
//              printf("[%d] %d\n\n", i, sg[i]);
        }
}

int main() {
        init();

        int n, t;
        cin &gt;&gt; t;
        while (t--) {
                cin &gt;&gt; n;
                int xr = 0, x;
                while (n--) {
                        cin &gt;&gt; x;
                        xr ^= sg[x];
                }
                cout &lt;&lt; (xr ? "ALICE" : "BOB") &lt;&lt; endl;
        }
        return 0;
}

----------
====================
----------
ALGORITHMS.429
hard
----------
PROBLEM STATEMENT:
Laurel and Hardy have [expression] piles of chocolates with each pile containing some number of chocolates. The piles are arranged from left to right in a non decreasing order based on the number of chocolates in each pile. They play the following game. 

For every continuous subsequence of chocolate piles (at least 2 piles form a subsequence), Laurel and Hardy will play game on this subsequence of chocolate piles, Laurel plays first, and they play in turn. In one move, the player can choose one of the piles and remove at least one chocolate from it, but the non-decreasing order of the chocolate piles must be maintained. The last person to make a valid move wins. 

How many continuous subsequences of chocolate piles will Laurel win if both of them play optimally? The number of chocolates of each pile will be recovered after the game ends for each subsequences. 
----------
TOP SOLUTION:
----------
#pragma comment(linker, "/STACK:16777216")

#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;utility&gt;
#include&lt;algorithm&gt;
#include&lt;list&gt;
using namespace std;

#define pb push_back
#define MS( a ) memset( a,0,sizeof(a))
#define MSV( a,v ) memset( a,v,sizeof(a))

#define MP make_pair

typedef long long Long;
typedef vector&lt;long&gt; VL;
typedef pair&lt;long,long&gt; pll;

#define MAX 100007

long N,K;
long A[MAX+7];
long X[MAX+7];

long Find( long *A,long n )
{
    long i;
    for( i=1;i&lt;=n;i++ ){
        if( i&amp;1 ) X[i] = X[i-1];
        else X[i] = X[i-2]^(A[i-1]-A[i]);
    }
    long Cnt = 0;
    map&lt;long,long&gt; Map;
    Map[0] = 1;
    for( i=2;i&lt;=n;i++ ){
        if( i&amp;1 ){
            long v = X[i-1]^A[i];
            Map[v] += 0;
            Cnt += Map[v];
            Map[X[i-1]]++;
        }
        else{
            long v = X[i];
            Map[v] += 0;
            Cnt += Map[v];
        }
    }
    return Cnt;
}

int main( void )
{
    long i,j,v,Icase,k = 0;

    //freopen("text1.txt","r",stdin );

    scanf("%ld",&amp;N );
    for( i=1;i&lt;=N;i++ ){
        scanf("%ld",&amp;A[i] );
    }
    reverse( A+1,A+N+1 );
    Long Ans = ((Long)N*(N-1))/2 - Find( A,N ) - Find( A+1,N-1 );
    cout&lt;&lt;Ans&lt;&lt;endl;

    return 0;
}

----------
====================
----------
ALGORITHMS.430
hard
----------
PROBLEM STATEMENT:
Manasa loves the nim game, in which there are [expression]

The whole game can now be described as follows:   

There are [expression]. A player loses if there are no more available moves.

Manasa plays the first move against Sandy. Who will win if both of them play optimally?
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_set&gt;
using namespace std;
const int M = 1000100;
vector&lt;int&gt; val = {2,3,5,7,11,13};
vector&lt;int&gt; sg;
int n;

void SGFun(int u, unordered_set&lt;int&gt; &amp;st){
    if(u == 0 || u == 1){
        st.insert(0);
        return ;
    }
    for(int i = 0; i &lt; val.size(); ++ i){
        int v = u - val[i];
        if(v &lt; 0)
            break;
        if(sg[v] != -1)
            st.insert(sg[v]);
        else
            SGFun(v, st);
    }
}

void init(){
//    sg.resize(14);
    sg.resize(M);
    
    for(int i = 0; i &lt; M; ++ i)
        sg[i] = -1;
    
    sg[0] = sg[1] = 0;
    sg[2] = 1;//sg[3] = sg[5] = sg[7] = sg[11] = sg[13] = 1;
    
    for(int i = 3; i &lt; 100; ++ i){
        if(sg[i] != -1)
            continue;
        unordered_set&lt;int&gt; st;
        SGFun(i, st);
        sg[i] = 0;
        for(int j = 0; st.find(j) != st.end(); sg[i] = ++ j) ;
    }
 /*   
    for(int i = 0; i &lt; 31; ++ i){
        printf("%d -&gt; %d\n",i,sg[i]);
    }
    
    sg[0] = sg[1] = 0;
    sg[2] = sg[3] = sg[5] = sg[7] = sg[11] = sg[13] = 1;
    sg[4] = 2;
    sg[6] = 3;
    sg[8] = sg[9] = 4;
    sg[10] = 5;
    sg[12] = 6;
    */
}

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
//    init();
    int T;
    scanf("%d",&amp;T);
    while(T --){
        scanf("%d",&amp;n);
        long long ans = 0;
        for(int i = 0; i &lt; n; ++ i){
            long long x;
            scanf("%lld",&amp;x);
            long long val = x%9;
            if(val &lt;= 1)
                x = 0;
            else if(val &lt;= 3)
                x = 1;
            else if(val &lt;= 5)
                x = 2;
            else if(val &lt;= 7)
                x = 3;
            else
                x = 4;
            ans ^= x;
        }
        if(ans)
            puts("Manasa");
        else
            puts("Sandy");
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.431
medium
----------
PROBLEM STATEMENT:
HackerChess is a variant of chess played at HackerRank. It is a game played between two players who make moves in turns until one of them cannot make any move. The player who cannot make a move loses the game and the other player is declared the winner. The game is played on a board with [expression] columns of the board.

Given the initial position of the rooks and knowing that the second player makes the first move, decide who will win the game if both players play optimally.
----------
TOP SOLUTION:
----------
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
    int t;
    cin &gt;&gt; t;
    while (t--) {
        int n;
        cin &gt;&gt; n;
        vector&lt;int&gt; a(n), b(n);
        for (int i=0; i&lt;n; i++)
            cin &gt;&gt; a[i];
        for (int i=0; i&lt;n; i++)
            cin &gt;&gt; b[i];
        int s = 0;
        for (int i=0; i&lt;n; i++)
            s ^= abs(a[i]-b[i])-1;
        cout &lt;&lt; (s? "player-2": "player-1") &lt;&lt; endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.432
medium
----------
PROBLEM STATEMENT:
Koga and Ryuho, new generation Athena's saints, are training to improve their control over the cosmos. According to the ancient Masters, a saint's power to control the cosmos strengthens, when one allows the energy of the universe to flow within the body and then concentrates it. This energy can even be used to explode the objects. 

Today's training is based on a game, and the goal is to use as little cosmos as possible to win. Two saints play as follows: 

Initially there are [expression] stones. The saints take turns and in each turn, a saint must select a non-empty pile and destroy at least half of the stones in it. The winner is the saint who destroys the last available stone . 

For example, from a pile of [expression] stones, leaving a single (and possibly empty) pile at most 3 stones. With such game, saints learn how to use the appropriate amount of cosmos in a single strike: too much will destroy more stones than desired, too little won't be enough. They also improve their battle thinking and strategy skills.

Ryuho suspects that such game is not as random as it appears to be at first glance. He strongly believes that with the correct single blow, you're assured to win from the very first turn, if you play optimally, no matter how good the other saint plays. Moreover, he is particularly interested in knowing the minimum number of stones he needs to destroy at that first move. Can you help him?  
----------
TOP SOLUTION:
----------
#include&lt;bits/stdc++.h&gt;
using namespace std;

#define REP(i,a,b) for(i=a;i&lt;b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'&lt;=k&amp;&amp;k&lt;='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k&lt;'0'||k&gt;'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void writer(int x, char c){int i,sz=0,m=0;char buf[10];if(x&lt;0)m=1,x=-x;while(x)buf[sz++]=x%10,x/=10;if(!sz)buf[sz++]=0;if(m)mypc('-');while(sz--)mypc(buf[sz]+'0');mypc(c);}

int main(){
  int T, N;
  int i, j, k, h, x;
  int res, tmp;

  reader(&amp;T);
  while(T--){
    reader(&amp;N);
    res = 1000000000;

    if(N%2==1){
      res = 1;
    } else {
      k = N;
      h = 0;
      while(k) h++, k/=2;
      x = (h^1);
      for(i=h;i;i--) for(j=i-1;j&gt;=0;j--) if((x^i^j) == 0){
        tmp = (1&lt;&lt;(i-1)) - ((1&lt;&lt;j)-1);
        if(j==i-1) tmp = (1&lt;&lt;(i-1))/2;
        res = min(res, tmp);
      }
    }

    writer(res, '\n');
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.433
expert
----------
PROBLEM STATEMENT:
Stephanie just learned about a game called Nim in which there are two players and [expression] piles of stones. During each turn, a player must choose any non-empty pile and take as many stones as they want. The first player who cannot complete their turn (i.e., because all piles are empty) loses.  

Stephanie knows that, for each start position in this game, it's possible to know which player will win (i.e., the first or second player) if both players play optimally. Now she wants to know the number of different games that exist that satisfy all of the following conditions:


The game starts with [expression] stones.
All the piles contain pairwise different numbers of stones.
The first player wins if that player moves optimally.


Help Stephanie by finding and printing the number of such games satisfying all the above criteria, modulo [expression].
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;map&gt;
using namespace std;
typedef long long ll;
typedef vector&lt;int&gt; vi;
typedef vector&lt;ll&gt; vl;
typedef vector&lt;vl&gt; vvl;
typedef vector&lt;vi&gt; vvi;
typedef long double ld;
typedef vector&lt;double&gt; vd;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;double, double&gt; pdd;
typedef vector&lt;pii&gt; vii;
typedef vector&lt;string&gt; vs;
const int mod = 1000000007;

ll mpow(ll x, ll n) {
    ll res = 1;
    while (n) {
        if (n &amp; 1) res = res * x % mod;
        x = x * x % mod;
        n /= 2;
    }
    return res;
}

int stupid(int n, int m) {
    int c = 0;
    int all = (1 &lt;&lt; m) - 1;
    for (int mask = 1; mask &lt; (1 &lt;&lt; all); ++mask) if (__builtin_popcount(mask) == n) {
        int xr = 0;
        for (int i = 0; i &lt; all; ++i) if (mask &amp; (1 &lt;&lt; i)) {
            xr ^= 1 + i;
        }
        if (xr) ++c;
    }
    for (int i = 2; i &lt;= n; ++i) c = c * (ll)i % mod;
    return c;
}

int solve(int n, int m) {
    vi d(n + 1);
    vi a(n + 1);
    d[0] = 1;
    d[1] = 0;
    ll dif = mpow(2, m) - 1;
    a[0] = 1;
    for (int i = 1; i &lt;= n; ++i) a[i] = a[i-1] * (dif - i + 1) % mod;
    for (int i = 2; i &lt;= n; ++i) {
        d[i] = (a[i-1] - d[i-2] * (dif - i + 2) % mod * (i-1) - d[i-1]) % mod;
        //cerr &lt;&lt; i &lt;&lt; ' ' &lt;&lt; d[i] &lt;&lt; endl;
    }
    return (a[n] - (ll)d[n] + 2*mod) % mod;
}

int main() {
    int n,m;
    cin &gt;&gt; n &gt;&gt; m;
    cout &lt;&lt; solve(n, m) &lt;&lt; endl;
    //cerr &lt;&lt; stupid(n,m) &lt;&lt; ' ' &lt;&lt; a[n] &lt;&lt; endl;
    return 0;
}
----------
====================
----------
ALGORITHMS.434
hard
----------
PROBLEM STATEMENT:
Jenna is playing a computer game involving a large map with [expression] bidirectional roads. The game's objective is to travel to as many cities as possible without visiting any city more than once. The more cities the player visits, the more points they earn.

As Jenna's fellow student at Hackerland University, she asks you for help choosing an optimal path. Given the map, can you help her find a path that maximizes her score?

Note: She can start and end her path at any two distinct cities.
----------
TOP SOLUTION:
----------
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;ostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;array&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;bitset&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;chrono&gt;
#include &lt;sys/resource.h&gt;
    

using namespace std;


template &lt;class T&gt; 
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const vector&lt;T&gt;&amp; rhs)
{
	for (const auto&amp; x : rhs)
		os &lt;&lt; x &lt;&lt; " ";
	return os;
}

template &lt;class T&gt; 
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const vector&lt;vector&lt;T&gt;&gt;&amp; A)
{
	os &lt;&lt; endl;
	for (int i = 1; i &lt; A.size(); ++i)
		os &lt;&lt; i &lt;&lt; ": [" &lt;&lt; A[i] &lt;&lt; "]" &lt;&lt;endl;
	return os;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const map&lt;long,long&gt;&amp; t)
{
	for (auto p : t)
		os &lt;&lt; p.first &lt;&lt; "^" &lt;&lt; p.second &lt;&lt; "*";
	os &lt;&lt; endl;
	return os;
}


template &lt;class T&gt; 
T max(const vector&lt;T&gt;&amp; v)
{
// 	if (v.size() == 0)
// 		cout &lt;&lt; "SHIT!" &lt;&lt; endl;
	T m = v[0];
	size_t sz = v.size();
	for (size_t i = 0; i &lt; sz; ++i)
	{
		if (v[i] &gt; m)
			m = v[i];
	}
	return m;
}

template &lt;class T&gt; std::vector&lt;T&gt; range (T n) 
{
	std::vector&lt;T&gt; toReturn(n, 0);
	for (T i = 1; i &lt; n ; ++i)
		toReturn[i] = i;
	return toReturn;
}

typedef std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; clockt;

inline double diffclockt(clockt a, clockt b)
{
	
	const double t = 0.000001;
	return std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(a-b).count()*t;
}

class Chronometer
{
public:
	Chronometer() : m_timer(std::chrono::high_resolution_clock::now()) {}
	
	double Reset()
	{
		auto tlast = m_timer;
		m_timer = std::chrono::high_resolution_clock::now();
	
		return diffclockt(m_timer, tlast);
	}
	
	double Peek() const
	{
		auto tnow = std::chrono::high_resolution_clock::now();
	
		return diffclockt(tnow, m_timer);
	}
	
	std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; m_timer;
};

inline double TimeFromStart()
{
	static Chronometer C;
	return C.Peek();
}

inline std::default_random_engine &amp; random_engine()
{
	static std::default_random_engine e{};
	return e;
}

inline void randomize()
{
	static std::random_device rd{};
	random_engine().seed(rd());
}

inline bool probability_of_true(double p)
{
	static std::bernoulli_distribution d(p);
	return d(random_engine());
}

inline double random_real( double from, double upto )
{
	static std::uniform_real_distribution&lt;&gt; d{};
	using parm_t = decltype(d)::param_type;
	return d( random_engine(), parm_t{from, upto} );
}

inline int random_integer(int from, int to)
{
	static std::uniform_int_distribution&lt;&gt; d{};
	using parm_t = decltype(d)::param_type;
	return d( random_engine(), parm_t{from, to-1} );
}

inline int random_give_priority_to_primeros(int a, int b)
{
	int n = b-a;
	random_engine();
	int t = random_integer(0,(n*(n+1))/2);
	int u = n-1;
	int i = n-1;
	int toreturn = a;
	while (u &lt; t &amp;&amp; i &gt; 0)
	{
		u += i;
		--i;
		++toreturn;
	}
	return toreturn;
}


using node_t = int;
const node_t INVALID_NODE = -1;

using weight_t = int;

// something larger than weight_t for when you have that weight_t doesn't properly hold a sum of weight_t
using sumweight_t = int;
// const sumweight_t INF = 200000000;

struct NeighborNode
{
	explicit NeighborNode() : node(INVALID_NODE) {} 
	
	explicit NeighborNode(node_t v, weight_t w) : node(v) {}
	
	inline operator node_t() const
	{
		return node;
	}
	
	weight_t Weight() const
	{
// 		return weight;
		return 1;
	}
	
	node_t node;
// 	weight_t weight{1}; //comment 
};

class Path
{
public:
    Path(size_t n) : m_path(), m_explored(n), m_value(0) {}
    Path(size_t n, node_t initialnode) : m_path(), m_explored(n), m_value(0) 
    {
        emplace_back(initialnode,0);
    }
    const deque&lt;NeighborNode&gt;&amp; get_path() const { return m_path; }
    inline operator const deque&lt;NeighborNode&gt;&amp;() const { return m_path; }
//     inline operator vector&lt;NeighborNode&gt;&amp;()  { return m_path; }
    long value() const { return m_value; }
    long cost() const { return m_value; }
    long weight() const { return m_value; }
    
    bool is_node_in_path(node_t v) const
	{
		return m_explored[v] &gt; 0;
	}
    
    void push_back(const NeighborNode&amp; v)
    {
//         assert(v.weight == 0 || !m_path.empty());
        assert(v &lt; m_explored.size());

        ++m_explored[v];
//         m_value += v.weight;
        m_path.push_back(v);
    }
    
    void emplace_back(node_t node, weight_t weight = 1)
    {
        assert(weight == 0 || !m_path.empty());
        assert(node &lt; m_explored.size());
        ++m_explored[node];
        m_value += weight;
        m_path.emplace_back(node,weight);
    }
    
    void push_front(NeighborNode v)
	{
//         swap(m_path.front().weight,v.weight);
        assert(!m_path.empty() &amp;&amp; "Use push_back when it's empty");
        assert(v &lt; m_explored.size());
//         m_path.front().weight = v.weight;
        m_path.emplace_front(v,0);
		m_value += v.Weight();
        ++m_explored[v];
	}
	
    void emplace_front(node_t node, weight_t weight = 1)
	{
//         auto w = m_path.front().weight;
        assert(!m_path.empty() &amp;&amp; "Use emplace_back when it's empty");
        assert(node &lt; m_explored.size());
// 		m_path.front().weight = weight;
		m_path.emplace_front(node,0);
		m_value += weight;
        ++m_explored[node];
	}
    
    void pop_back()
    {
        assert(!m_path.empty() &amp;&amp; "Can't pop when it's already empty!");
        auto v = m_path.back();
        --m_explored[v];
        m_value -= v.Weight();
        m_path.pop_back();
    }
    
    void pop_front()
    {
        assert(!m_path.empty() &amp;&amp; "Can't pop when it's already empty!");
        auto v = m_path.front();
        --m_explored[v];
        m_path.pop_front();
        m_value -= m_path.front().Weight();
//         m_path.front().weight = 0;
    }
    
    void clear()
    {
        m_value = 0;
//         m_explored = vector&lt;char&gt;(m_explored.size(),0);
        auto n = m_explored.size();
        m_explored.clear();
        m_explored.resize(n,0);
        m_path.clear();
    }
    
    NeighborNode operator[](size_t i) const { return m_path[i]; }
    NeighborNode&amp; operator[](size_t i) { return m_path[i]; }
    
    bool empty() const
    {
        return m_path.empty();
    }
    
    size_t size() const
    {
        return m_path.size();
    }
    
    template &lt;class Compare&gt;
    NeighborNode first_not_explored_binary(const vector&lt;NeighborNode&gt;&amp; Nodes, node_t start, Compare comp) const
    {
        auto it = std::upper_bound(Nodes.begin(), Nodes.end(), start, comp);
    // 	++it;
        while (it != Nodes.end() &amp;&amp; m_explored[*it])
            ++it;
        if (it == Nodes.end())
            return NeighborNode(INVALID_NODE,0);
        return *it;
    }
    
    NeighborNode first_not_explored_binary(const vector&lt;NeighborNode&gt;&amp; Nodes, node_t start) const
    {
        return first_not_explored_binary(Nodes,start,std::less&lt;node_t&gt;());
    }
    
    NeighborNode first_not_explored(const vector&lt;NeighborNode&gt;&amp; Nodes, node_t start) const
    {
        bool seenstart = false;
        for (auto x : Nodes)
        {
            if (x == start)
            {
                seenstart = true;
                continue;
            }	
            
            if (seenstart &amp;&amp; !m_explored[x])
                return x;
        }
        return NeighborNode(INVALID_NODE,0);
    }
    
    NeighborNode first_not_explored(const vector&lt;NeighborNode&gt;&amp; Nodes) const
    {
        for (auto x : Nodes)
        {
            if (!m_explored[x])
                return x;
        }
        return NeighborNode(INVALID_NODE,0);
    }
    
    NeighborNode back() const
    {
        return m_path.back();
    }
    
    NeighborNode front() const
    {
        return m_path.front();
    }
    
    
private:
    deque&lt;NeighborNode&gt; m_path;
    vector&lt;char&gt; m_explored;
//     vector&lt;bool&gt; m_explored;
    long m_value;
public:
    const decltype(m_path)&amp; data() const { return m_path; }

};

// inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Path&amp; P)
// {
//     auto B = P.get_path();
//     for (size_t i = 0; i &lt; B.size()-1; ++i)
// 	{
// 	}
// 	os &lt;&lt; P.get_digraph()-&gt;get_vertex_name(B.back()) &lt;&lt; endl;
// 	return os;
// }

struct Edge
{
	Edge() : from(INVALID_NODE), to(INVALID_NODE), weight(0) {}
	Edge(node_t f, node_t t, weight_t w = 1) : from(f), to(t), weight(w) {}
	node_t operator[](bool i)
	{
		if (i)
			return to;
		return from;
	}
	node_t from;
	node_t to;
	weight_t weight;
};


class PseudoTopoOrder;

using ParamType = std::array&lt;double, 8&gt;;


class DiGraph
{
public:
    explicit DiGraph(node_t numberOfNodes);
    explicit DiGraph(const vector&lt;string&gt;&amp; vertex_names);

	//		Graph modification functions
	void add_edge(node_t from, node_t to, weight_t weight = 1);
	void add_edge(const string&amp; from, const string&amp; to, weight_t weight = 1);
	
	// Find connected components, heuristics, etc.
	void process(); // WARNING! Since it removes and renames nodes, after "processing" your nodes might have been renamed!

	// Get Graph Info
	node_t get_size() const { return m_n; }
	node_t num_vertices() const { return m_n; }
	size_t num_edges() const;
    
    const string&amp; get_vertex_name(node_t i) const { return m_node_names[i]; }
    node_t get_vertex_index(const string&amp; name) const 
    { 
        auto it = m_namemap.find(name);
        return (*it).second; 
        
    }
    const vector&lt;string&gt;&amp; get_vertex_names() const { return m_node_names; } 
    
    void set_parameters(const ParamType&amp; new_params) 
    {
        m_params = new_params;
        heuristic_processing();
    }
    
    static DiGraph ReadFromStdin(int n, int m);
    
	int rank_out(node_t node) const { return 0; }
	int rank_in(node_t node) const { return 0; }
	
	inline const vector&lt;NeighborNode&gt;&amp; outneighbors(node_t n) const { return m_outgraph[n]; }
	inline const vector&lt;NeighborNode&gt;&amp; inneighbors(node_t n) const { return m_ingraph[n]; }
// 	inline const weight_t edge_value(node_t from, node_t to) const { return m_edge_values(from,to); }
	
	// This is the order in which the outneighbors are sorted
	inline bool ex_compare(node_t a, node_t b) const { return m_basic_topological_ordering_inverse[a] &lt; m_basic_topological_ordering_inverse[b]; }

	// This is the order in which the outneighbors are sorted
	inline bool in_compare(node_t a, node_t b) const { return m_basic_topological_ordering_inverse_in[a] &lt; m_basic_topological_ordering_inverse_in[b]; }
	
	// Functions related to paths
	
	void dfs_search_path_forward(Path&amp; P, double maxnumseconds) const;
	void dfs_search_path_reverse(Path&amp; P, double maxnumseconds) const;
	
	Path dfs_search_path_forward(node_t start, double maxnumseconds) const;
	Path dfs_search_path_reverse(node_t start, double maxnumseconds) const;

	Path dfs_search(double maxnumsecondswithoutimprovement) const;
    void pto_search(Path&amp; A, double maxnumseconds) const;
    
	PseudoTopoOrder get_random_pseudotopological_order() const;
	//Paths
	Path FindLongestSimplePath(double numseconds);
	Path FindLongestSimplePathPureDFS(double numseconds);
	
	bool TopologicalLessThan(node_t a, node_t b) const { return m_basic_topological_ordering_inverse[a] &lt; m_basic_topological_ordering_inverse[b]; }
	
	static DiGraph CreateRandomDiGraph(int n, double p);
	static DiGraph CreateRandomWeightedDiGraph(int n, double p, weight_t minweight, weight_t maxweight);
	
private:
    // Utils for creating the graph
	void remove_bad_nodes();
	void remove_nodes(vector&lt;node_t&gt;&amp; toRemove);
	
	DiGraph with_nodes_removed(vector&lt;node_t&gt;&amp; toRemove) const;
	
	void heuristic_processing();
	double get_heuristic_out(node_t node);
	double get_heuristic_in(node_t node);
	
// 	void branch_and_bound();
	
	// Utils to find connected components
// 	void find_weakly_connected_components();
	void find_strongly_connected_components();
	void find_strongly_connected_componentsBOOST();
	void topo_fill_order( node_t v, vector&lt; char &gt;&amp; visited, stack&lt; node_t &gt;&amp; Stack ); 
	void topo_fill_order( node_t v, vector&lt; char &gt;&amp; visited, vector&lt; node_t &gt;&amp; Stack ); 
    void DFSUtil( node_t v, vector&lt; bool &gt;&amp; visited );
    void DFSUtilReversed( node_t v, vector&lt; char &gt;&amp; visited, int current );
//     void DFSUtilWeak(node_t start, int minvalidcoloring);
	
protected:
	// DiGraph insides
	node_t m_n;
	vector&lt;vector&lt;NeighborNode&gt;&gt; m_outgraph;
	vector&lt;vector&lt;NeighborNode&gt;&gt; m_ingraph;

private:
	bool m_processed;
	//Heuristics
	vector&lt;double&gt; m_heuristic_out;
	vector&lt;double&gt; m_heuristic_in;
	
	vector&lt;node_t&gt; m_basic_topological_ordering;
	vector&lt;node_t&gt; m_basic_topological_ordering_in;
	vector&lt;node_t&gt; m_basic_topological_ordering_inverse;
	vector&lt;node_t&gt; m_basic_topological_ordering_inverse_in;
	
    vector&lt;string&gt; m_node_names;
    unordered_map&lt;string, node_t&gt; m_namemap;
    
    
    ParamType m_params {{-43,31,11,58,-4,23,43,45}};
//     ParamType m_params {{1,4,16,64,1,4,16,64}};
    
	friend class PseudoTopoOrder;
};

DiGraph DiGraph::ReadFromStdin(int n, int m)
{
	DiGraph D(n);
	for (int i = 0; i &lt; m; ++i)
	{
		int x,y;
		cin &gt;&gt; x &gt;&gt; y;
		--x;
		--y;
		D.add_edge(x,y);
		D.add_edge(y,x);
	}
	return D;
}


std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const DiGraph&amp; M);
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParamType&amp; a);



void ExpandGreedyBack(const DiGraph&amp; G, Path&amp; P);


void ExpandGreedyFront(const DiGraph&amp; G, Path&amp; P);

template &lt;class Compare&gt;
bool dfs_outnext(const DiGraph&amp; G, Path&amp; P, Compare comp)
{
    auto lastNode = P.back();
    
    auto Neighs = &amp;G.outneighbors(lastNode);

    auto t = P.first_not_explored(*Neighs);

    while (t == INVALID_NODE &amp;&amp; P.size() &gt; 1) //this means all nodes in Neigh have been explored
    {
        lastNode = P.back();
        P.pop_back();
        int father = P.back();
        Neighs = &amp;G.outneighbors(father);
        t = P.first_not_explored_binary(*Neighs,lastNode, comp);
    }
    if (t == INVALID_NODE)
        return false; // this means we have finished DFS!!
    P.push_back(t);
	ExpandGreedyBack(G,P);
    return true;
}

template &lt;class Compare&gt;
bool dfs_innext(const DiGraph&amp; G, Path&amp; P, Compare comp)
{
    auto firstNode = P.front();
    
    auto Neighs = &amp;G.inneighbors(firstNode);

    auto t = P.first_not_explored(*Neighs);

    while (t == INVALID_NODE &amp;&amp; P.size() &gt; 1) //this means all nodes in Neigh have been explored
    {
        firstNode = P.front();
        P.pop_front();
        int father = P.front();
        Neighs = &amp;G.inneighbors(father);
        t = P.first_not_explored_binary(*Neighs,firstNode, comp);
    }
    if (t == INVALID_NODE)
        return false; // this means we have finished DFS!!
    P.push_front(t);
	ExpandGreedyFront(G,P);
    return true;
}


class PseudoTopoOrder
{
public:
	PseudoTopoOrder(const DiGraph&amp; m, const vector&lt;node_t&gt;&amp; ts, const vector&lt;node_t&gt;&amp; tsi) : 
	pto(ts), 
	pto_inverse(tsi), 
	dynamic_programming(ts.size(),0), 
	best_index(0), 
	first_unknown(0),
	path_filled(false),
	m_path(),
	m_parent(m) {}

	size_t size() const { return dynamic_programming.size(); }
	
	inline void set(int i, int v)
	{
		pto[i] = v;
		pto_inverse[v] = i;
		AnnounceModification(i);
	}

	inline void transpose(int i, int j)
	{
		swap(pto[i],pto[j]);
		pto_inverse[pto[i]] = i;
		pto_inverse[pto[j]] = j;
		AnnounceModification(i);
		AnnounceModification(j);
	}
	
	void transfer(int a, int b, int c, int d, int h);
	
	void reverse_order(int a, int b);
	
	Path get_path();

	void shuffle(int  a, int b); // this assumes already a &lt; b and they belong to the same component
	sumweight_t  Value() { FillDP(); return dynamic_programming[best_index]; }
	void apply(const Path&amp; P);
	void apply(const Path&amp; P, int u, int v);
// 	void random_apply(const Path&amp; P);
	
	bool eXtreme_edge_opener();
	
	void open_edges_until_no_more_improvement_found(double maxnumseconds);
	
	void open_edge();
	
	void randomize();
	
	// sorts range from a to b (must be same scc) according to a heuristic so as to maximize the improvement chance.
	void heuristic_sort(int a, int b, int numtimes);
	int get_outneighbor_in_range(int a, int b, node_t node);

private:
	void FillDP();
	void FillPath();
	void RecalcTopoInverse();
	
	inline void AnnounceModification(node_t i) { if  (i &lt; first_unknown) first_unknown = i; path_filled = false; }
	inline void transpose_na(int i, int j)
	{
		swap(pto[i],pto[j]);
		pto_inverse[pto[i]] = i;
		pto_inverse[pto[j]] = j;
	}
	
	inline void set_na(int i, int v)
	{
		pto[i] = v;
		pto_inverse[v] = i;
	}
	
	vector&lt;node_t&gt; pto;
	vector&lt;node_t&gt; pto_inverse;
	vector&lt;sumweight_t&gt; dynamic_programming;
	int best_index;
	int first_unknown;
	bool path_filled;
	vector&lt;NeighborNode&gt; m_path; //Path is filled with indices in REVERSE ORDER
	const DiGraph&amp; m_parent;
};



void PseudoTopoOrder::shuffle(int a, int b)
{
	random_shuffle(pto.begin()+a, pto.begin()+b);
	for (int i = a; i &lt; b; ++i)
	{
		pto_inverse[pto[i]] = i;
	}
	AnnounceModification(a);
}

void PseudoTopoOrder::RecalcTopoInverse()
{
	int n = pto.size();
	for (int i = 0; i &lt; n; ++i)
	{
		pto_inverse[pto[i]] = i;
	}
	AnnounceModification(0);
}

void PseudoTopoOrder::apply(const Path&amp; P)
{
	auto it = P.get_path().begin();
	int fu = -1;
	int n = pto.size();
	for (int i = 0; i &lt; n; ++i)
	{
		int x = pto[i];
		if (P.is_node_in_path(x))
		{
			if (fu == -1)
				fu = i;
			pto[i] = *it;
			pto_inverse[*it] = i;
			++it;
		}
	}
	AnnounceModification(fu);
}

void PseudoTopoOrder::apply(const Path&amp; P, int u, int v)
{

	vector&lt;int&gt; indexesofPbetweenuandv;
	vector&lt;int&gt; nodesofPbetweenuandv;
	for (auto x : P.get_path())
	{
		int index = pto_inverse[x];
		if (u &lt;= index &amp;&amp; index &lt; v)
		{
			indexesofPbetweenuandv.push_back(index);
			nodesofPbetweenuandv.push_back(x);
		}
	}
	sort(indexesofPbetweenuandv.begin(), indexesofPbetweenuandv.end());
	int i = 0;
	for (auto p : indexesofPbetweenuandv)
	{
		pto[p] = nodesofPbetweenuandv[i];
		pto_inverse[pto[p]] = p;
		++i;
	}
	AnnounceModification(u);
}


Path PseudoTopoOrder::get_path()
{
	FillPath();
	Path P(size());
	for (auto i : m_path)
	{
		P.emplace_front(pto[i],i.Weight());
	}
	return P;
}

void PseudoTopoOrder::FillDP()
{
	int n = pto.size();
	int best_val = 0;
	if (best_index &lt; first_unknown)
		best_val = dynamic_programming[best_index];
	
	for ( ; first_unknown &lt; n; ++first_unknown)
	{
		int u = pto[first_unknown];
		dynamic_programming[first_unknown] = 0;
		
		auto&amp; neigh = m_parent.inneighbors(u);
		for (auto v : neigh)
		{
			auto j = pto_inverse[v];
			if (first_unknown &lt; j) // should be ignored
				continue;
			auto candidate = dynamic_programming[j] + v.Weight();
			if (candidate &gt; dynamic_programming[first_unknown])
			{
				dynamic_programming[first_unknown] = candidate;
				if (candidate &gt; best_val)
				{
					best_val = candidate;
					best_index = first_unknown;
				}
			}
		}
	}
}

void PseudoTopoOrder::randomize()
{
	random_shuffle(pto.begin(), pto.end());
	for (int i = 0; i &lt; pto.size(); ++i)
	{
		pto_inverse[pto[i]] = i;
	}
	
	AnnounceModification(0);
}

void PseudoTopoOrder::transfer(int a, int b, int c, int d, int h)
{
	if (h == b-a)
	{
		return;
	}
	
	while (h &gt; b-a) // we must transfer from end to start
	{
		transpose(b,c);
		++b;
		++c;
	}
	
	
	while (h &lt; b-a) // we must transfer from start to end
	{
		--b;
		--c;
		transpose(b,c);
	}
}

void PseudoTopoOrder::reverse_order(int a, int b)
{
	std::reverse(pto.begin()+a, pto.begin()+b);
	for (int i = a; i &lt; b; ++i)
	{
		pto_inverse[pto[i]] = i;
	}
	AnnounceModification(a);
}

void PseudoTopoOrder::heuristic_sort(int a, int b, int numtimes)
{
	if (a == b)
		return;
	for (int r = b-1; r &gt;= a; --r)
	{
		node_t node = pto[r];
		int iu = get_outneighbor_in_range(a,r,node);
		if (iu != -1)
			transpose(iu,r);
	}
	for (int i = 0; i &lt; numtimes; ++i)
	{
		int r = rand()%(b-a)+a;
		node_t node = pto[r];
		int iu = get_outneighbor_in_range(a,r,node);
		if (iu != -1)
			transpose(iu,r);
	}
}

int PseudoTopoOrder::get_outneighbor_in_range(int a, int b, node_t node)
{
	for (auto u : m_parent.outneighbors(node))
	{
		int iu = pto_inverse[u];
		if (a &lt;= iu &amp;&amp; iu &lt; b)
			return iu;
	}
	return -1;
}

bool PseudoTopoOrder::eXtreme_edge_opener()
{
	auto oldval = Value();
	FillPath();

// 	for (const auto&amp; x : m_parent.big_scc())
// 	{
		int a = 0;
		int d = pto.size();
// 		if (d - a &lt; 5)
// 			continue;
		
		// true true true *false false
		auto f = std::partition_point(m_path.rbegin(), m_path.rend(), [this,a](node_t i) -&gt; bool
		{
			return i &lt; a;
		});

		int aa = a;
		while (*f &lt; d &amp;&amp; f != m_path.rend())
		{
			if (*f != aa)
				transpose(aa,*f);
			++f;
			++aa;
		}
		
		int c = d;
		int b = aa;
		
		auto order = range&lt;int&gt;(b-a+1);
		random_shuffle(order.begin(), order.end());
		shuffle(b,c);
		for (auto h : order)
		{
			transfer(a,b,c,d,h);
			int total = b-a + d-c;
			b = a+h;
			c = d-(total-h);
			heuristic_sort(b,c,10000);
			if (Value() &gt; oldval)
			{
				FillPath();
				return true;
			}
		}
// 	}
	FillPath();
	return false;
}

void PseudoTopoOrder::open_edges_until_no_more_improvement_found(double maxnumseconds)
{
	Chronometer C;
	while (C.Peek() &lt; maxnumseconds)
	{
		eXtreme_edge_opener();
	}
}


void PseudoTopoOrder::FillPath()
{
	if (path_filled)
		return;
	m_path.clear();
	FillDP();
	auto m = Value();
	weight_t currweight = 0;
	int a = best_index;
	path_filled = true;

	while (true)
	{
		bool found = false;
		node_t u = pto[a];
		m_path.emplace_back(a,currweight);
		for (auto v : m_parent.inneighbors(u))
		{
			node_t b = pto_inverse[v];
			if (b &gt; a)
				continue;
			if (dynamic_programming[b] == dynamic_programming[a] - v.Weight())
			{
				a = b;
				m = dynamic_programming[b];
				currweight = v.Weight();
				found = true;
				break;
			}
		}
		if (!found)
		{
			return;
		}
	}
}


DiGraph::DiGraph(node_t numNodes) :
			m_n(numNodes),
			m_outgraph(numNodes),
			m_ingraph(numNodes),
			m_processed(false),
			m_heuristic_out(),
			m_heuristic_in(),
			m_basic_topological_ordering(),
			m_basic_topological_ordering_in(),
			m_basic_topological_ordering_inverse(),
			m_basic_topological_ordering_inverse_in(),
			m_node_names(numNodes),
			m_namemap()
{
	for (node_t i = 0; i &lt; numNodes; ++i)
    {
        m_node_names[i] = to_string(i);
        m_namemap[to_string(i)] = i;
    }
    
}

DiGraph::DiGraph(const vector&lt;string&gt;&amp; vnames) :
			m_n(vnames.size()),
			m_outgraph(vnames.size()),
			m_ingraph(vnames.size()),
			m_processed(false),
			m_heuristic_out(),
			m_heuristic_in(),
			m_basic_topological_ordering(),
			m_basic_topological_ordering_in(),
			m_basic_topological_ordering_inverse(),
			m_basic_topological_ordering_inverse_in(),
			m_node_names(vnames),
			m_namemap()
{
	for (node_t i = 0; i &lt; vnames.size(); ++i)
    {
        m_namemap[vnames[i]] = i;
    }
    
}

void DiGraph::add_edge(node_t from, node_t to, weight_t weight)
{
// 	if (m_edge_values(from,to) == 0)
// 	{
		m_outgraph[from].emplace_back(to,weight);
		m_ingraph[to].emplace_back(from,weight);
// 	}
// 	m_edge_values(from,to) = weight;
	m_processed = false;
}

void DiGraph::add_edge(const string&amp; from, const string&amp; to, weight_t weight)
{
    add_edge(m_namemap[from],m_namemap[to],weight);
}


void DiGraph::process()
{
	if (!m_processed)
	{
		heuristic_processing();
		
		m_processed = true;
	}
}

Path DiGraph::dfs_search(double mnswi) const
{
	Chronometer C;
	Path A = dfs_search_path_forward(m_basic_topological_ordering[0],mnswi);
	for (int i = 1; i &lt; min(4,num_vertices()); ++i)
	{
		Path P = dfs_search_path_forward(m_basic_topological_ordering[i],mnswi);
		if (P.value() &gt; A.value())
			A = P;
	}
    return A;
}


Path DiGraph::FindLongestSimplePath(double numseconds)
{
    Chronometer C;
	process();
	
	double dfstime = 0.02 + numseconds/20.0; 
	
	Path best = dfs_search(dfstime);
// 	double timeleft = numseconds-C.Peek();
	
	
// 	pto_search(best,timeleft);
	
	return best;
}

void DiGraph::pto_search(Path&amp; A, double maxnumseconds) const
{
	Chronometer C;
	
    PseudoTopoOrder PTO = get_random_pseudotopological_order();
	PTO.apply(A);
	
	PTO.open_edges_until_no_more_improvement_found(maxnumseconds);
	
	
    if (A.value() &lt; PTO.Value())
        A = PTO.get_path();
	
	
}
size_t DiGraph::num_edges() const
{
	size_t toReturn = 0;
	for (node_t i = 0; i &lt; m_n; ++i)
	{
		toReturn += m_outgraph[i].size();
	}
	return toReturn;
}


void DiGraph::dfs_search_path_forward(Path&amp; P, double maxnumseconds) const
{
	ExpandGreedyBack(*this,P);
	
	Chronometer C;
	Path Q = P;
	auto comp = [this](node_t a, node_t b)
	{
		return ex_compare(a,b);
	};
	while (C.Peek() &lt; maxnumseconds &amp;&amp; dfs_outnext(*this,Q,comp))
	{
		if (Q.value() &gt; P.value())
		{
			P = Q;
			C.Reset();
		}
	}
}

void DiGraph::dfs_search_path_reverse(Path&amp; P, double maxnumseconds) const
{
	ExpandGreedyBack(*this,P);
	
	Chronometer C;
	Path Q = P;
	auto comp = [this](node_t a, node_t b)
	{
		return in_compare(a,b);
	};
	while (C.Peek() &lt; maxnumseconds &amp;&amp; dfs_innext(*this,Q,comp))
	{
		if (Q.value() &gt; P.value())
		{
			P = Q;
			C.Reset();
		}
	}
}

Path DiGraph::dfs_search_path_forward(node_t start, double maxnumseconds) const
{
	Path P(num_vertices(),start);
	dfs_search_path_forward(P,maxnumseconds);
	return P;
}

Path DiGraph::dfs_search_path_reverse(node_t start, double maxnumseconds) const
{
	Path P(num_vertices(),start);
	dfs_search_path_reverse(P,maxnumseconds);
	return P;
}

void DiGraph::heuristic_processing()
{
	m_heuristic_out.resize(m_n,0);
	m_heuristic_in.resize(m_n,0);
	
	// 	double maxtime = 0.2/n;
	
// 	#pragma omp parallel for
	for (node_t i = 0; i &lt; m_n; ++i)
	{
		m_heuristic_out[i] = get_heuristic_out(i);
		m_heuristic_in[i] = get_heuristic_in(i);
	}
	
	m_basic_topological_ordering = range&lt;node_t&gt;(m_n);
	
	for (auto a : m_basic_topological_ordering)
	{
		if (a &gt;= m_n) cout &lt;&lt; "SUPER ERROR!" &lt;&lt; endl;
		assert(a &lt; m_n);
	}
	
	sort (m_basic_topological_ordering.begin(), m_basic_topological_ordering.end(), [this](node_t a, node_t b) -&gt; bool
	{
		assert(a &lt; m_n &amp;&amp; b &lt; m_n);
		if (rank_out(a) == rank_out(b))
		{
			if (m_heuristic_out[a] == 0)
			{
				return false;
			}
			if (m_heuristic_out[b] == 0)
			{
				return true;
			}
			
			if (m_ingraph[a].size() == 1 )
				return true;
			if (m_ingraph[b].size() == 1)
				return false;
			return m_heuristic_out[a] &lt; m_heuristic_out[b];
		}
		
		
		return rank_out(a) &gt; rank_out(b);
		
	});
	
	m_basic_topological_ordering_inverse.resize(m_n);
	for (node_t i = 0; i &lt; m_n; ++i)
	{
		m_basic_topological_ordering_inverse[m_basic_topological_ordering[i]] = i; 
	}
	
	m_basic_topological_ordering_in = range&lt;node_t&gt;(m_n);
	sort (m_basic_topological_ordering_in.begin(), m_basic_topological_ordering_in.end(), [this](node_t a, node_t b) -&gt; bool
	{
		if (rank_in(a) &lt; rank_in(b))
			return true;
		if (rank_in(a) &gt; rank_in(b))
			return false;
		
// 		if (m_heuristic_in[a] == 0 &amp;&amp; m_heuristic_in[b] == 0)
// 		{
// 			return vertex_values[a] &gt; vertex_values[b];
// 		}
		
		if (m_heuristic_in[a] == 0)
			return false;
		if (m_heuristic_in[b] == 0)
			return true;
		
// 		if (ingraph[a].size() == 1 &amp;&amp; ingraph[b].size() == 1)
// 			return heuristic_out[a] &lt; heuristic_out[b];
		
		if (m_outgraph[a].size() == 1 )
			return true;
		if (m_outgraph[b].size() == 1)
			return false;
		
		return m_heuristic_in[a] &lt; m_heuristic_in[b];
	});
// 	random_shuffle(basic_topological_ordering.begin(), basic_topological_ordering.end());
	m_basic_topological_ordering_inverse_in.resize(m_n);
	for (node_t i = 0; i &lt; m_n; ++i)
	{
		m_basic_topological_ordering_inverse_in[m_basic_topological_ordering_in[i]] = i; 
	}
	
	
	for (size_t i = 0; i &lt; m_n; ++i)
	{
// 		random_shuffle(outgraph[i].begin(), outgraph[i].end());
// 		random_shuffle(ingraph[i].begin(), ingraph[i].end());
		sort(m_outgraph[i].begin(), m_outgraph[i].end(), [this] (node_t a, node_t b) -&gt; bool
		{
			return ex_compare(a,b);
		});
		
		sort(m_ingraph[i].begin(), m_ingraph[i].end(), [this] (node_t a, node_t b) -&gt; bool
		{
			return in_compare(a,b);
		});
	}
	
}

PseudoTopoOrder DiGraph::get_random_pseudotopological_order() const
{
	vector&lt;int&gt; topo_sort(num_vertices());
	for (int i = 0; i &lt; topo_sort.size(); ++i)
	{
		topo_sort[i] = i;
	}
	random_shuffle(topo_sort.begin(),topo_sort.end());
	vector&lt;int&gt; topo_sort_inverse(num_vertices());
	for (int i = 0; i &lt; topo_sort.size(); ++i)
	{
		topo_sort_inverse[topo_sort[i]] = i;
	}
	return PseudoTopoOrder(*this, std::move(topo_sort),std::move(topo_sort_inverse));
}


double DiGraph::get_heuristic_out(node_t node)
{
    double a1 = m_params[0];
	double a2 = m_params[1];
	double a3 = m_params[2];
	double a4 = m_params[3];
	double heuristicex = 0;
	
	for (auto x : m_outgraph[node])
	{
		heuristicex += a1;
		for (auto y : m_outgraph[x])
		{
			heuristicex += a2;
			for (auto z : m_outgraph[y])
			{
				heuristicex += a3+a4*m_outgraph[z].size();
// 				for (auto r : outgraph[z])
// 				{
// 					heuristicex += a4+a5*outgraph[r]./*size()*/;
// 				}
			}
		}
	}
	return heuristicex;
}


double DiGraph::get_heuristic_in(node_t node)
{
// 	return 0;
	double a1 = m_params[4];
	double a2 = m_params[5];
	double a3 = m_params[6];
	double a4 = m_params[7];
	double heuristicin = 0;

	for (auto x : m_ingraph[node])
	{
		heuristicin += a1;
		for (auto y : m_ingraph[x])
		{
			heuristicin  += a2;
			for (auto z : m_ingraph[y])
			{
				heuristicin  += a3+a4*m_ingraph[z].size(); 
			}
		}
	}
	return heuristicin;
}

DiGraph DiGraph::CreateRandomDiGraph(int n, double p)
{
	DiGraph D(n);
	
	for (int i = 0; i &lt; n; ++i)
	{
		for (int j = i+1; j &lt; n; ++j)
		{
			if (probability_of_true(p))
			{
				int a = i;
				int b = j;
				if (rand()%2 == 1) swap(a,b);
				D.add_edge(a,b);
			}
		}
	}
	return D;
}


DiGraph DiGraph::CreateRandomWeightedDiGraph(int n, double p, weight_t minweight, weight_t maxweight)
{
	DiGraph D(n);
	
	for (int i = 0; i &lt; n; ++i)
	{
		for (int j = i+1; j &lt; n; ++j)
		{
			if (probability_of_true(p))
			{
				int a = i;
				int b = j;
				weight_t w = random_real(minweight,maxweight);
				if (rand()%2 == 1) swap(a,b);
				D.add_edge(a,b,w);
			}
		}
	}
// 	D.process();
	return D;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParamType&amp; a)
{
	os &lt;&lt; endl &lt;&lt; "\tex: ";
	for (int i = 0; i &lt; 4; ++i)
		os &lt;&lt; a[i] &lt;&lt; " ";
	os &lt;&lt; endl;
	
	os &lt;&lt; "\tin: ";
	for (int i = 4; i &lt; 8; ++i)
		os &lt;&lt; a[i] &lt;&lt; " ";
	os &lt;&lt; endl;
	return os;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const DiGraph&amp; M)
{
    cout &lt;&lt; "Digraph on " &lt;&lt; M.num_vertices() &lt;&lt; " vertices: " &lt;&lt; M.get_vertex_names() &lt;&lt; endl;
    for (int i = 0; i &lt; M.num_vertices(); ++i)
    {
        string name = M.get_vertex_name(i);
        for (auto v : M.outneighbors(i))
        {
            string vname = M.get_vertex_name(v);
        }
    }
    return os;
}

void ExpandGreedyBack(const DiGraph&amp; G, Path&amp; P)
{
	while (true)
	{
		auto l = P.back();
		auto&amp; Neighs = G.outneighbors(l);
		
		auto t = P.first_not_explored(Neighs);
		if (t == INVALID_NODE)
			break;
		P.emplace_back(t,t.Weight());
	}
}


void ExpandGreedyFront(const DiGraph&amp; G, Path&amp; P)
{
	while (true)
	{
		auto l = P.front();
		auto&amp; Neighs = G.inneighbors(l);
		
		auto t = P.first_not_explored(Neighs);
		if (t == INVALID_NODE)
			break;
		P.emplace_front(t,t.Weight());
	}
}



int main() 
{
	
	int n,m;
	cin &gt;&gt; n &gt;&gt; m;
	DiGraph D = DiGraph::ReadFromStdin(n,m);
	auto P = D.FindLongestSimplePath(1.5);
	cout &lt;&lt; P.size() &lt;&lt; endl;
	for (int p : P.data())
		cout &lt;&lt; p+1 &lt;&lt; " ";
	return 0; 
}

----------
====================
----------
ALGORITHMS.435
advanced
----------
PROBLEM STATEMENT:
Sam invented a new puzzle game played on an [expression].

The Moves

A move consists of two steps:


Choose a sub-square of [expression].
Rotate the sub-square in the clockwise direction.


For example: 



We describe a move as the clockwise rotation of a [expression].

Good Pairs of Cells

A pair of cell is good if one of the following is true:


They're located in the same row and the number in the left cell is less than the number in the right cell. 
They're located in the same column and the number in the upper cell is less than the number in the lower cell.


The diagram below depicts all the good pairs of cells located in the same row:



The diagram below depicts all the good pairs of cells located in the same column:



Goodness of a Square

We define the goodness of a sub-square to be the total number of good pairs of cells in the sub-square.

The Goal

Given the initial value of [expression] moves. Then print the necessary moves according to the Output Format specified below.
----------
TOP SOLUTION:
----------
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;climits&gt;
#include &lt;chrono&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;
#include &lt;deque&gt;
#include &lt;fstream&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;numeric&gt;
#include &lt;queue&gt;
#include &lt;random&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;

using namespace std;

static default_random_engine dre;

class CField
{
public:
	unsigned n;
	vector&lt;unsigned&gt; vmap;

	CField() : n(0) {}
	CField(unsigned _n) : n(_n) { vmap.resize(n*n); }

	void Set(unsigned pos, unsigned value) { vmap[pos] = value;	}

	void Read()
	{
		cin &gt;&gt; n;
		vmap.resize(n*n);
		for (unsigned i = 0; i &lt; n * n; ++i)
		{
			int x;
			cin &gt;&gt; x;
			Set(i, x - 1);
		}
		AddCurrentPenalty();
	}

	static unsigned PenaltyBase(unsigned n, const vector&lt;unsigned&gt;&amp; vmap)
	{
		unsigned penalty = 0;
		for (unsigned i = 0; i &lt; n; ++i)
		{
			for (unsigned j = 0; j &lt; n; ++j)
			{
				unsigned x = vmap[i * n + j];
				for (unsigned i1 = i + 1; i1 &lt; n; ++i1)
				{
					if (vmap[i1 * n + j] &lt; x) ++penalty;
				}
				for (unsigned j1 = j + 1; j1 &lt; n; ++j1)
				{
					if (vmap[i * n + j1] &lt; x) ++penalty;
				}
			}
		}
		return penalty;
	}

	unsigned PenaltyBase() const { return PenaltyBase(n, vmap); }

	void Rotate(unsigned i, unsigned j, unsigned k)
	{
		unsigned kh0 = k / 2, kh1 = (k + 1) / 2;
		for (unsigned i1 = 0; i1 &lt; kh0; ++i1)
		{
			for (unsigned j1 = 0; j1 &lt; kh1; ++j1)
			{
				unsigned x = vmap[(i1 + i) * n + (j1 + j)];
				Set((i1 + i) * n + (j1 + j), vmap[(k - j1 - 1 + i) * n + (i1 + j)]);
				Set((k - j1 - 1 + i) * n + (i1 + j), vmap[(k - i1 - 1 + i) * n + (k - j1 - 1 + j)]);
				Set((k - i1 - 1 + i) * n + (k - j1 - 1 + j), vmap[(j1 + i) * n + (k - i1 - 1 + j)]);
				Set((j1 + i) * n + (k - i1 - 1 + j), x);
			}
		}
	}

	void Rotate(const vector&lt;unsigned&gt;&amp; v)
	{
		assert(v.size() == 3);
		Rotate(v[0], v[1], v[2]);
	}

	void RotateI(unsigned i, unsigned j, unsigned k)
	{
		unsigned kh0 = k / 2, kh1 = (k + 1) / 2;
		for (unsigned i1 = 0; i1 &lt; kh0; ++i1)
		{
			for (unsigned j1 = 0; j1 &lt; kh1; ++j1)
			{
				unsigned x = vmap[(i1 + i) * n + (j1 + j)];
				Set((i1 + i) * n + (j1 + j), vmap[(j1 + i) * n + (k - i1 - 1 + j)]);
				Set((j1 + i) * n + (k - i1 - 1 + j), vmap[(k - i1 - 1 + i) * n + (k - j1 - 1 + j)]);
				Set((k - i1 - 1 + i) * n + (k - j1 - 1 + j), vmap[(k - j1 - 1 + i) * n + (i1 + j)]);
				Set((k - j1 - 1 + i) * n + (i1 + j), x);
			}
		}
	}

	void RotateI(const vector&lt;unsigned&gt;&amp; v)
	{
		assert(v.size() == 3);
		RotateI(v[0], v[1], v[2]);
	}

	static void CalcAccumSumS(unsigned n, const vector&lt;unsigned&gt;&amp; vmap, vector&lt;vector&lt;unsigned&gt;&gt;&amp; output)
	{
		assert(vmap.size() == n*n);
		if (output.size() != (n + 1))
		{
			output.resize(n + 1);
			for (unsigned i = 0; i &lt; output.size(); ++i)
				output[i].resize(n + 1);
		}
		for (unsigned i = 0; i &lt;= n; ++i)
		{
			output[i][0] = output[0][0] = 0;
		}
		for (unsigned i = 0; i &lt; n; ++i)
		{
			for (unsigned j = 0; j &lt; n; ++j)
			{
				output[i + 1][j + 1] = output[i + 1][j] + output[i][j + 1] - output[i][j] + vmap[i * n + j];
			}
		}
	}

	static void CalcAccumSumS(unsigned n, const vector&lt;unsigned&gt;&amp; vmap, vector&lt;vector&lt;vector&lt;unsigned&gt;&gt;&gt;&amp; output)
	{
		assert(vmap.size() == n*n);
		if (output.size() != 3)
			output.resize(3);
		for (unsigned l = 0; l &lt; 3; ++l)
		{
			if (output[l].size() != (n + 1))
			{
				output[l].resize(n + 1);
				for (unsigned i = 0; i &lt; output[l].size(); ++i)
					output[l][i].resize(n + 1);
			}
		}
		for (unsigned l = 0; l &lt; 3; ++l)
		{
			for (unsigned i = 0; i &lt;= n; ++i)
			{
				output[l][i][0] = output[l][0][0] = 0;
			}
		}
		for (unsigned i = 0; i &lt; n; ++i)
		{
			for (unsigned j = 0; j &lt; n; ++j)
			{
				output[0][i + 1][j + 1] = output[0][i + 1][j] + output[0][i][j + 1] - output[0][i][j] + vmap[i * n + j];
				output[1][i + 1][j + 1] = output[1][i + 1][j] + output[1][i][j + 1] - output[1][i][j] + i * vmap[i * n + j];
				output[2][i + 1][j + 1] = output[2][i + 1][j] + output[2][i][j + 1] - output[2][i][j] + j * vmap[i * n + j];
			}
		}
	}

	static void CalcAccumSumS(unsigned n, const vector&lt;unsigned&gt;&amp; vmap, double noise_amplitude, vector&lt;vector&lt;vector&lt;double&gt;&gt;&gt;&amp; output)
	{
		static uniform_real_distribution&lt;double&gt; urd(0.0, 1.0);
		assert(vmap.size() == n*n);
		if (output.size() != 3)
			output.resize(3);
		for (unsigned l = 0; l &lt; 3; ++l)
		{
			if (output[l].size() != (n + 1))
			{
				output[l].resize(n + 1);
				for (unsigned i = 0; i &lt; output[l].size(); ++i)
					output[l][i].resize(n + 1);
			}
		}
		for (unsigned l = 0; l &lt; 3; ++l)
		{
			for (unsigned i = 0; i &lt;= n; ++i)
			{
				output[l][i][0] = output[l][0][0] = 0;
			}
		}
		for (unsigned i = 0; i &lt; n; ++i)
		{
			for (unsigned j = 0; j &lt; n; ++j)
			{
				double d = vmap[i * n + j] + noise_amplitude * urd(dre);
				output[0][i + 1][j + 1] = output[0][i + 1][j] + output[0][i][j + 1] - output[0][i][j] + d;
				output[1][i + 1][j + 1] = output[1][i + 1][j] + output[1][i][j + 1] - output[1][i][j] + i * d;
				output[2][i + 1][j + 1] = output[2][i + 1][j] + output[2][i][j + 1] - output[2][i][j] + j * d;
			}
		}
	}

	void CalcAccumSum(vector&lt;vector&lt;unsigned&gt;&gt;&amp; output) const { CalcAccumSumS(n, vmap, output); }
	void CalcAccumSum(vector&lt;vector&lt;vector&lt;unsigned&gt;&gt;&gt;&amp; output) const { CalcAccumSumS(n, vmap, output); }
	void CalcAccumSum(double noise_amplitude, vector&lt;vector&lt;vector&lt;double&gt;&gt;&gt;&amp; output) const { CalcAccumSumS(n, vmap, noise_amplitude, output); }

	static void FindBestMove(unsigned n, const vector&lt;vector&lt;vector&lt;unsigned&gt;&gt;&gt;&amp; accum, vector&lt;unsigned&gt;&amp; output_move)
	{
		output_move.resize(3); output_move[2] = 0;
		unsigned best_score = 0;
		for (unsigned k = 2; k &lt;= n; ++k)
		{
			for (unsigned i = 0; i + k &lt;= n; ++i)
			{
				for (unsigned j = 0; j + k &lt;= n; ++j)
				{
					unsigned a000 = accum[0][i][j];
					unsigned a001 = accum[0][i][j + k];
					unsigned a010 = accum[0][i + k][j];
					unsigned a011 = accum[0][i + k][j + k];
					unsigned a100 = accum[1][i][j];
					unsigned a101 = accum[1][i][j + k];
					unsigned a110 = accum[1][i + k][j];
					unsigned a111 = accum[1][i + k][j + k];
					unsigned a200 = accum[2][i][j];
					unsigned a201 = accum[2][i][j + k];
					unsigned a210 = accum[2][i + k][j];
					unsigned a211 = accum[2][i + k][j + k];

					unsigned s0 = a011 + a000 - a001 - a010;
					unsigned s1 = a111 + a100 - a101 - a110;
					unsigned s2 = a211 + a200 - a201 - a210;

					if (best_score + 2 * s1 &lt; (k - 1 + 2 * i) * s0)
					{
						best_score = (k - 1 + 2 * i) * s0 - 2 * s1;
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
					if (2 * best_score + 2 * (s1 + s2) &lt; 2 * (k - 1 + i + j) * s0)
					{
						best_score = (k - 1 + i + j) * s0 - (s1 + s2);
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
					if (3 * best_score + 2 * s2 &lt; (k - 1 + 2 * j) * s0)
					{
						best_score = ((k - 1 + 2 * j) * s0 - 2 * s2) / 3;
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
				}
			}
		}
	}

	static void FindBestMove(unsigned n, const vector&lt;vector&lt;vector&lt;double&gt;&gt;&gt;&amp; accum, vector&lt;unsigned&gt;&amp; output_move)
	{
		output_move.resize(3); output_move[2] = 0;
		double best_score = 0;
		for (unsigned k = 2; k &lt;= n; ++k)
		{
			for (unsigned i = 0; i + k &lt;= n; ++i)
			{
				for (unsigned j = 0; j + k &lt;= n; ++j)
				{
					double a000 = accum[0][i][j];
					double a001 = accum[0][i][j + k];
					double a010 = accum[0][i + k][j];
					double a011 = accum[0][i + k][j + k];
					double a100 = accum[1][i][j];
					double a101 = accum[1][i][j + k];
					double a110 = accum[1][i + k][j];
					double a111 = accum[1][i + k][j + k];
					double a200 = accum[2][i][j];
					double a201 = accum[2][i][j + k];
					double a210 = accum[2][i + k][j];
					double a211 = accum[2][i + k][j + k];

					double s0 = a011 + a000 - a001 - a010;
					double s1 = a111 + a100 - a101 - a110;
					double s2 = a211 + a200 - a201 - a210;

					if (best_score + 2 * s1 &lt; (k - 1 + 2 * i) * s0)
					{
						best_score = (k - 1 + 2 * i) * s0 - 2 * s1;
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
					if (2 * best_score + 2 * (s1 + s2) &lt; 2 * (k - 1 + i + j) * s0)
					{
						best_score = (k - 1 + i + j) * s0 - (s1 + s2);
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
					if (3 * best_score + 2 * s2 &lt; (k - 1 + 2 * j) * s0)
					{
						best_score = ((k - 1 + 2 * j) * s0 - 2 * s2) / 3;
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
				}
			}
		}
	}

	void FindBestMoveBase(vector&lt;unsigned&gt;&amp; output_move)
	{
		output_move.resize(3); output_move[2] = 0;
		unsigned best_score = PenaltyBase();
		for (unsigned k = 2; k &lt;= n; ++k)
		{
			for (unsigned i = 0; i + k &lt;= n; ++i)
			{
				for (unsigned j = 0; j + k &lt;= n; ++j)
				{
					Rotate(i, j, k);
					unsigned p = PenaltyBase();
					RotateI(i, j, k);
					if (best_score &gt; p)
					{
						best_score = p;
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
				}
			}
		}
	}

	vector&lt;vector&lt;unsigned&gt;&gt; moves;
	vector&lt;unsigned&gt; penalties;

	void AddCurrentPenalty() { penalties.push_back(PenaltyBase()); }
	void MakeMove(const vector&lt;unsigned&gt;&amp; move)
	{
		moves.push_back(move);
		Rotate(move);
		AddCurrentPenalty();
	}

	unsigned GetBestPenalty() const
	{
		unsigned best_penalty = penalties[0];
		for (unsigned p : penalties)
			best_penalty = min(p, best_penalty);
		return best_penalty;
	}

	void PrintMoves() const
	{
		unsigned best_index = 0;
		for (unsigned i = 1; i &lt; penalties.size(); ++i)
		{
			if (penalties[i] &lt; penalties[best_index])
			{
				best_index = i;
			}
		}
		// assert(penalties[best_index] == penalties.back());
		cout &lt;&lt; best_index &lt;&lt; endl;
		for (unsigned i = 0; i &lt; best_index; ++i)
		{
			const auto&amp; p = moves[i];
			cout &lt;&lt; p[0] + 1 &lt;&lt; " " &lt;&lt; p[1] + 1 &lt;&lt; " " &lt;&lt; p[2] &lt;&lt; endl;
		}
	}

	void SolveGreedy(double min_noise, double max_noise)
	{
		unsigned moves_so_far = 0;
		unsigned max_moves = 500;
		vector&lt;unsigned&gt; move;
		// vector&lt;vector&lt;unsigned&gt;&gt; accum;
		// vector&lt;vector&lt;vector&lt;unsigned&gt;&gt;&gt; accum;
		vector&lt;vector&lt;vector&lt;double&gt;&gt;&gt; accum;
		for (; moves_so_far &lt; max_moves; ++moves_so_far)
		{
			// CalcAccumSum(accum);
			double noise = (min_noise * moves_so_far + max_noise * (max_moves - moves_so_far - 1)) / (max_moves - 1);
			CalcAccumSum(noise, accum);
			FindBestMove(n, accum, move);
			// FindBestMoveBase(move);
			if (move[2] != 0)
				MakeMove(move);
			else
				break;
		}
		// PrintMoves();
	}
};

int main()
{
	auto start_time = chrono::system_clock::now();
	dre.seed(0);
	CField fbase;
	fbase.Read();
	CField fbest = fbase, ftemp;
	fbest.SolveGreedy(0.0, 0.0);
	unsigned best_penalty = fbest.GetBestPenalty();
	for (; best_penalty &gt; 0;)
	{
		ftemp = fbase;
		ftemp.SolveGreedy(1.0, 1.0);
		unsigned p = ftemp.GetBestPenalty();
		if (best_penalty &gt; p)
		{
			best_penalty = p;
			fbest = ftemp;
		}
		auto now_time = chrono::system_clock::now();
		auto time_ms = chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now_time - start_time);
		if (time_ms.count() &gt; 1800)
			break;
	}
	fbest.PrintMoves();
	return 0;
}

----------
====================
----------
ALGORITHMS.436
expert
----------
PROBLEM STATEMENT:
Two spies in a grid will have their covers blown if:


They are both in the same row.  
They are both in the same column.  
They can see each other diagonally (i.e., lie in a line inclined [expression]° to the base of the grid).


The level of danger is now increased! In addition to the conditions above, no [expression]° to the base of grid.

Write a program in the language of your choice to place [expression] lines describing a valid configuration:


The value of [expression].
A space-separated list of [expression]).


Solve this problem for [expression].

Note: Run and Custom Input are not available for this challenge; you must click Submit Code for your submission to be scored. Your score for this challenge will always be the maximum value scored by any of your submissions.

Examples 
In the examples below, [expression] denotes a spy and * denotes an empty cell.

Sample Configuration 0  

A valid configuration for [expression]:
&nbsp;

[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 



Sample Output 0     

This C++ code:

[expression]
[expression]  

[expression]  
    [expression]  
    [expression]  
    [expression]  
[expression]  



Produces this output:

11
2 4 7 1 8 11 5 3 9 6 10&nbsp;


This configuration will earn a score of [expression].

Sample Configuration 1      

A valid configuration for [expression]:

[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression]



Sample Output 1     

This Python code:

[expression]  
[expression]



Produces this output:

13
1 3 12 10 7 2 11 5 8 13 9 4 6


This configuration will earn a score of [expression].

Sample Configuration 2  

An invalid configuration for [expression]:

[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 



Sample Output 2         

The following output:

7
1 3 5 7 2 4 6&nbsp;


will earn a score of [expression] rows.      
----------
TOP SOLUTION:
----------
SOLUTION NOT FOUND
----------
====================
----------
ALGORITHMS.437
expert
----------
PROBLEM STATEMENT:
Quality Blimps Inc. is looking to expand their sales to other cities ([expression]), so they hired you as a salesman to fly to other cities to sell blimps. Blimps can be expensive to travel with, so you will need to determine how many blimps to take along with you on each trip and when to return to headquarters to get more. Quality Blimps has an unlimited supply of blimps. 

You will be able to sell only one blimp in each city you visit, but you do not need to visit every city, since some have expensive travel costs. Each city has an initial price that blimps sell for, but this goes down by a certain percentage as more blimps are sold (and the novelty wears off). Find a good route that will maximize profits. 

Details

Blimp Decline  - The blimps will decline ([expression]).

Note that if the price declines after you visit some city, then it will only happen after you made the sale on that city, so your sale on that city will not be affected. In particular, each blimp you sell in the first [expression] of the cities will always be sold at their corresponding city's initial price.
----------
TOP SOLUTION:
----------
SOLUTION NOT FOUND
----------
====================
----------
ALGORITHMS.438
medium
----------
PROBLEM STATEMENT:
In this challenge, the task is to debug the existing code to successfully execute all provided test files.



Given two dates each in the format dd-mm-yyyy, you have to find the number of lucky dates between them (inclusive). To see if a date is lucky,


Firstly, sequentially concatinate the date, month and year, into a new integer [expression] erasing the leading zeroes. 
Now if [expression], then we call the date a lucky date.


For example, let's take the date "02-08-2024". After concatinating the day, month and year, we get [expression] so the date "02-08-2024" is called a lucky date.

Debug the given function findPrimeDates and/or other lines of code, to find the correct lucky dates from the given input.

Note: You can modify at most five lines in the given code and you cannot add or remove lines to the code.

To restore the original code in the editor, create a new buffer by clicking on the top left icon in the editor.
----------
TOP SOLUTION:
----------
SOLUTION NOT FOUND
----------
====================
----------
ALGORITHMS.439
medium
----------
PROBLEM STATEMENT:
In this challenge, the task is to debug the existing code to successfully execute all provided test files.



There are [expression] blue balls. 

You want to separate the balls by their color. In each operation, you can pick a single ball from some box and put it into another box. The balls are separated if no box contains balls of more than one color.

Debug the given function min_operations and compute the minimal number of operations required to separate the balls.

Note: In this problem you can modify at most six lines of code and you cannot add any new lines.

To restore the original code in the editor, create a new buffer by clicking on the top left icon in the editor.
----------
TOP SOLUTION:
----------
#include &lt;cstdio&gt; 
#include &lt;cstdlib&gt; 
#include &lt;cstring&gt; 
#include &lt;algorithm&gt; 
#include &lt;vector&gt; 
#include &lt;cmath&gt; 
#include &lt;iostream&gt; 
#include &lt;map&gt; 
using namespace std; 

int dp[110][1&lt;&lt;3];

int min_operations(vector &lt;int&gt; red, vector &lt;int&gt; green, vector &lt;int&gt; blue) {

    int n = (int)red.size(), i, j;
    for (i = 0; i &lt;= n; i++) {
        for (j = 0; j &lt; 8; j++) {
            dp[i][j] = 1&lt;&lt;30;
        }
    }

    dp[0][0] = 0;
    for (i = 0; i &lt; n; i++){
        for (j = 0; j &lt; 8; j++){
            dp[i + 1][j | 1] = min(dp[i + 1][j | 1], dp[i][j] + green[i] + blue[i]);
            dp[i + 1][j | 2] = min(dp[i + 1][j | 2], dp[i][j] + red[i] + blue[i]);
            dp[i + 1][j | 4] = min(dp[i + 1][j | 4], dp[i][j] + red[i] + green[i]);
        }
    }
    j = 0;
    for (i = 0; i &lt; n; i++){
        if (red[i]) j |= 1;
        if (green[i]) j |= 2;
        if (blue[i]) j |= 4;
    }

    if (dp[n][j] &gt;= (1&lt;&lt;30))
        dp[n][j] = -1;

    return dp[n][j];
}

int main() {

    int n, r, g, b;
    cin &gt;&gt; n;
    vector&lt;int&gt; red, blue, green;

    for(int i = 0; i &lt; n; i++){

        cin &gt;&gt; r &gt;&gt; g &gt;&gt; b;
        red.push_back(r);
        green.push_back(g);
        blue.push_back(b);
    }

    cout &lt;&lt; min_operations(red, green, blue) &lt;&lt; "\n";
    return 0;
}

----------
====================
----------
ALGORITHMS.440
easy
----------
PROBLEM STATEMENT:
In this challenge, the task is to debug the existing code to successfully execute all provided test files.



Given two strings consisting of digits 0 and 1 only, find the XOR of the two strings.

To know more about XOR Click Here

Debug the given function strings_xor to find the XOR of the two given strings appropriately. 

Note: You can modify at most three lines in the given code and you cannot add or remove lines to the code.

To restore the original code in the editor, create a new buffer by clicking on the top left icon in the editor.
----------
TOP SOLUTION:
----------
def strings_xor(s, t):
    res = ""
    for i in range(len(s)):
        if s[i] == t[i]:
            res += '0';
        else:
            res += '1';
            
    return res
  
s = raw_input()
t = raw_input()
print strings_xor(s, t)



----------
====================
----------
ALGORITHMS.441
medium
----------
PROBLEM STATEMENT:
In this challenge, the task is to debug the existing code to successfully execute all provided test files.



Given an array of [expression]. You need to find the lexicographically smallest zig zag sequence of the given array.

For example let's say [expression], the result is a zig zag sequence.

Debug the given function findZigZagSequence to return the appropriate zig zag sequence for the given input array.

Note: You can modify at most three lines in the given code and you cannot add or remove lines to the code.

To restore the original code in the editor, create a new buffer by clicking on the top left icon in the editor.
----------
TOP SOLUTION:
----------
SOLUTION NOT FOUND
----------
====================
----------
ALGORITHMS.442
easy
----------
PROBLEM STATEMENT:
In this challenge, the task is to debug the existing code to successfully execute all provided test files.



A number is called a smart number if it has an odd number of factors. Given some numbers, find whether they are smart numbers or not.

Debug the given function is_smart_number to correctly check if a given number is a smart number. 

Note: You can modify only one line in the given code and you cannot add or remove any new lines.

To restore the original code in the editor, create a new buffer by clicking on the top left icon in the editor.
----------
TOP SOLUTION:
----------
import math

def is_smart_number(num):
    val = int(math.sqrt(num))
    if num == val**2:
        return True
    return False

for _ in range(int(input())):
    num = int(input())
    ans = is_smart_number(num)
    if ans:
        print("YES")
    else:
        print("NO")

----------
====================