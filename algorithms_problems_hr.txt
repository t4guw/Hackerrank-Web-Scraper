
----------
ALGORITHMS.1
easy
----------
PROBLEM STATEMENT:
Complete the function solveMeFirst to compute the sum of two integers.

Function prototype:  

int solveMeFirst(int a, int b);

where,


a is the first integer input.
b is the second integer input


Return values  


 sum of the above two integers   

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int solveMeFirst(int a, int b) {
 // Hint: Type return a+b; below:
  return a+b;
}

int main() {
  int num1, num2;
  int sum;
  cin>>num1>>num2;
  sum = solveMeFirst(num1,num2);
  cout<<sum;
  return 0;
}
----------
====================
----------
ALGORITHMS.2
easy
----------
PROBLEM STATEMENT:
Given an array of integers, find the sum of its elements.

For example, if the array [expression].  

Function Description

Complete the simpleArraySum function in the editor below.  It must return the sum of the array elements as an integer.  

simpleArraySum has the following parameter(s):  


ar: an array of integers  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    
    unsigned long long int N, Sum = 0, i, Num;
    
    cin>>N;
    
    for (i = 1 ; i <= N ; i++)
        {
        cin>> Num;
        Sum += Num;
    }
    
    cout<<Sum<<endl;
       
    
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
ALGORITHMS.3
easy
----------
PROBLEM STATEMENT:
Alice and Bob each created one problem for HackerRank. A reviewer rates the two challenges, awarding points on a scale from [expression] for three categories: problem clarity, originality, and difficulty. 

We define the rating for Alice's challenge to be the triplet [expression].

Your task is to find their comparison points by comparing [expression]. 


If [expression] point. 
If [expression] point. 
If [expression], then neither person receives a point.


Comparison points is the total points a person earned.

Given [expression], determine their respective comparison points.

For example, [expression] with Alice's score first and Bob's second.  

Function Description

Complete the function compareTriplets in the editor below.  It must return an array of two integers, the first being Alice's score and the second being Bob's.  

compareTriplets has the following parameter(s):


a: an array of integers representing Alice's challenge rating  
b: an array of integers representing Bob's challenge rating  

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;
#define FOR(i,a,b) for(int i = (a); i <= (b); ++i)
#define FORD(i,a,b) for(int i = (a); i >= (b); --i)
#define RI(i,n) FOR(i,1,(n))
#define REP(i,n) FOR(i,0,(n)-1)
#define mini(a,b) a=min(a,b)
#define maxi(a,b) a=max(a,b)
#define mp make_pair
#define pb push_back
#define st first
#define nd second
#define sz(w) (int) w.size()
typedef vector<int> vi;
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
const int inf = 1e9 + 5;
const int nax = 1e6 + 5;

int a[3], b[3];
int one, two;


int main() {
	REP(i, 3) scanf("%d", &a[i]);
	REP(i, 3) scanf("%d", &b[i]);
	REP(i, 3) {
		if(a[i] > b[i]) ++one;
		if(a[i] < b[i]) ++two;
	}
	printf("%d %d\n", one, two);
	return 0;
}

----------
====================
----------
ALGORITHMS.4
easy
----------
PROBLEM STATEMENT:
Calculate and print the sum of the elements in an array, keeping in mind that some of those integers may be quite large.

Function Description

Complete the aVeryBigSum function in the editor below.  It must return the sum of all array elements.

aVeryBigSum has the following parameter(s):


ar: an array of integers . 


Input Format 

The first line of the input consists of an integer [expression]. 
The next line contains [expression] space-separated integers contained in the array. 

Output Format

Print the integer sum of the elements in the array.

Constraints 
[expression] 
[expression]  

Sample Input  

5
1000000001 1000000002 1000000003 1000000004 1000000005


Output   

5000000015


Note: 

The range of the 32-bit integer is [expression]. 

When we add several integer values, the resulting sum might exceed the above range. You might need to use long long int in C/C++ or long data type in Java to store such sums.  
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int n;
    cin>>n;
    unsigned long long int sum=0,in;
    for(int i=0;i<n;i++)
        {cin>>in;
        sum+=in;}
    cout<<sum;
    return 0;
}

----------
====================
----------
ALGORITHMS.5
easy
----------
PROBLEM STATEMENT:
Given a square matrix, calculate the absolute difference between the sums of its diagonals.  

For example, the square matrix [expression] is shown below:  

1 2 3
4 5 6
9 8 9  


The left-to-right diagonal = [expression].  

Function description

Complete the [expression] function in the editor below.  It must return an integer representing the absolute diagonal difference.

diagonalDifference takes the following parameter:  


arr: an array of integers . 

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int N; 
    cin >> N; 
    
    int i, j; 
    
    int sumdiag1 = 0; 
    int sumdiag2 = 0; 
    for(i = 0; i < N; i++){
        for(j = 0; j< N; j++)
        {
           int no; 
           cin >> no; 
           if(i == j)
               sumdiag1 += no; 
           if(i+j == N-1)
              sumdiag2 += no; 
        }
    }
    
    cout << abs(sumdiag1 - sumdiag2);
    return 0;
}

----------
====================
----------
ALGORITHMS.6
easy
----------
PROBLEM STATEMENT:
Given an array of integers, calculate the fractions of its elements that are positive,  negative, and are zeros. Print the decimal value of each fraction on a new line.

Note: This challenge introduces precision problems. The test cases are scaled to six decimal places, though answers with absolute error of up to [expression] are acceptable.

For example, given the array [expression].  It should be printed as  

0.400000
0.400000
0.200000


Function Description

Complete the plusMinus function in the editor below.  It should print out the ratio of positive, negative and zero items in the array, each on a separate line rounded to six decimals.  

plusMinus has the following parameter(s):


arr: an array of integers

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int p=0,n=0,z=0,a,i,j;
    cin>>j;
    for(i=0;i<j;i++){
        cin>>a;
        
        if(a>0)
            p++;
        else if(a<0)
            n++;
        else
            z++;
    }
    
    printf("%.3f\n",(float)p/j);
    printf("%.3f\n",(float)n/j);
    printf("%.3f",(float)z/j);
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
ALGORITHMS.7
easy
----------
PROBLEM STATEMENT:
Consider a staircase of size [expression]:

   #
  ##
 ###
####


Observe that its base and height are both equal to [expression], and the image is drawn using # symbols and spaces. The last line is not preceded by any spaces. 

Write a program that prints a staircase of size [expression].  

Function Description

Complete the staircase function in the editor below.  It should print a staircase as described above.  

staircase has the following parameter(s):  


n: an integer

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
    int n;
    cin >> n;
    string str(n, ' ');
        
    for (int i = 1; i <= n; ++i) {
        str[n-i] = '#';
        cout << str << endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.8
easy
----------
PROBLEM STATEMENT:
Given five positive integers, find the minimum and maximum values that can be calculated by summing exactly four of the five integers. Then print the respective minimum and maximum values as a single line of two space-separated long integers.  

For example, [expression].  We would print  

16 24


Function Description  

Complete the miniMaxSum function in the editor below.  It should print two space-separated integers on one line: the minimum sum and the maximum sum of [expression] elements.  

miniMaxSum has the following parameter(s):


arr: an array of [expression] integers  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
typedef long long LL;
using namespace std;

int main(){
	LL s[5];
	LL d = 0;
	for(int i = 0; i < 5; i++){
		cin >> s[i];
		d += s[i];
	}
	sort(s,s+5);
	cout << d-s[4] << " " << d-s[0] << endl;
}
----------
====================
----------
ALGORITHMS.9
easy
----------
PROBLEM STATEMENT:
You are in charge of the cake for your niece's birthday and have decided the cake will have one candle for each year of her total age. When she blows out the candles, she’ll only be able to blow out the tallest ones. Your task is to find out how many candles she can successfully blow out. 

For example, if your niece is turning [expression] such candles.  

Function Description

Complete the function birthdayCakeCandles in the editor below.  It must return an integer representing the number of candles she can blow out.  

birthdayCakeCandles has the following parameter(s):


ar: an array of integers representing candle heights     

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int N; cin>>N;
    int a[N];
    for(int i=0;i<N;i++) cin>>a[i];
    int biggest = 0;
    for(int i=0;i<N;i++) biggest = max(biggest, a[i]);
    int count = 0;
    for(int i=0;i<N;i++) if (a[i] == biggest) count++;
        cout<<count<<endl;
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
ALGORITHMS.10
easy
----------
PROBLEM STATEMENT:
Given a time in [expression]-hour AM/PM format, convert it to military (24-hour) time.  

Note: Midnight is 12:00:00AM on a 12-hour clock, and 00:00:00 on a 24-hour clock. Noon is 12:00:00PM on a 12-hour clock, and 12:00:00 on a 24-hour clock. 

Function Description  

Complete the timeConversion function in the editor below.  It should return a new string representing the input time in 24 hour format.  

timeConversion has the following parameter(s):


s: a string representing time in [expression] hour format  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    string s;
    string h;
    int hr;
    cin>>s;
    hr = ((s[0]-'0')*10)+(s[1]-'0');
    if(s[8]=='P'&&s[9]=='M'&& hr ==12) cout<<to_string(hr);
    else if(s[8]=='P'&&s[9]=='M') cout<<to_string(hr+12);
    else if(s[8]=='A'&&s[9]=='M'&&hr==12) cout<<"00";
    
    else cout<< s[0]<<s[1];
    
   
    for(int i =2;i<8;i++)
        cout<<s[i];
    cout<<endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.11
easy
----------
PROBLEM STATEMENT:
HackerLand University has the following grading policy:


Every student receives a [expression].
Any [expression] is a failing grade. 


Sam is a professor at the university and likes to round each student's [expression] according to these rules:


If the difference between the [expression].
If the value of [expression], no rounding occurs as the result will still be a failing grade.


For example, [expression].  

Given the initial value of [expression] students, write code to automate the rounding process.   

Function Description  

Complete the function gradingStudents in the editor below.  It should return an integer array consisting of rounded grades.  

gradingStudents has the following parameter(s):  


grades:  an array of integers representing grades before rounding  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;


int main(){
    int n;
    cin >> n;
    for(int a0 = 0; a0 < n; a0++){
        int grade;
        cin >> grade;
        if (grade >= 38) {
            int rem = grade % 5;
            if (rem >= 3) grade += 5 - rem;
        }
        cout << grade << endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.12
easy
----------
PROBLEM STATEMENT:
Sam's house has an apple tree and an orange tree that yield an abundance of fruit. In the diagram below, the red region denotes his house, where [expression].



When a fruit falls from its tree, it lands [expression] units to the tree's right. 

Given the value of [expression])?

For example, Sam's house is between [expression] so we print 

1
2


Function Description  

Complete the countApplesAndOranges function in the editor below.  It should print the number of apples and oranges that land on Sam's house, each on a separate line.  

countApplesAndOranges has the following parameter(s):  


s: integer, starting point of Sam's house location.       
t: integer, ending location of Sam's house location.     
a: integer, location of the Apple tree.      
b: integer, location of the Orange tree.         
apples: integer array, distances at which each apple falls from the tree.      
oranges: integer array, distances at which each orange falls from the tree.  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <cmath>
#include <vector>
#include <cstdlib>
#include <cstdio>
#include <climits>
#include <ctime>
#include <cstring>
#include <queue>
#include <stack>
#include <list>
#include <algorithm>
#include <map>
#include <set>
#define LL long long
#define Pr pair<int,int>
#define fread(ch) freopen(ch,"r",stdin)
#define fwrite(ch) freopen(ch,"w",stdout)

using namespace std;
const int INF = 0x3f3f3f3f;
const int mod = 1e9+7;
const double eps = 1e-8;
const int maxn = 112345;


int main()
{
	//fread("");
	//fwrite("");

	int s,t,a,b,m,n,x;
	int aa,bb;
	aa = bb = 0;

	scanf("%d%d%d%d%d%d",&s,&t,&a,&b,&m,&n);
	while(m--)
	{
		scanf("%d",&x);
		if(s <= a+x && a+x <= t) aa++;
	}

	while(n--)
	{
		scanf("%d",&x);
		if(s <= b+x && b+x <= t) bb++;
	}

	printf("%d\n%d\n",aa,bb);

	return 0;
}



----------
====================
----------
ALGORITHMS.13
easy
----------
PROBLEM STATEMENT:
You are choreographing a circus show with various animals. For one act, you are given two kangaroos on a number line ready to jump in the positive direction (i.e, toward positive infinity). 


The first kangaroo starts at location [expression] meters per jump. 
The second kangaroo starts at location [expression] meters per jump.


You have to figure out a way to get both kangaroos at the same location at the same time as part of the show.  If it is possible, return YES, otherwise return NO.

For example, kangaroo [expression]), so our answer is YES.

Function Description

Complete the function kangaroo in the editor below.  It should return YES if they reach the same position at the same time, or NO if they don't.  

kangaroo has the following parameter(s):  


x1, v1: integers, starting position and jump distance for kangaroo 1
x2, v2: integers, starting position and jump distance for kangaroo 2

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <map>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <numeric>
#include <stack>
using namespace std;
#define REP(I,N)   FOR(I,0,N)
#define pb push_back
#define LL long long
LL limit=500000;
int main()
{
    int a,x,b,y;
    cin>>a>>x>>b>>y;
    a+=x;
    b+=y;
    if(a==b)
        cout<<"YES"<<endl;
    else
    {
        int d=0;
        for(;;a+=x,b+=y)
        {
            if(a==b)
            {
                d=1;
                break;
            }
           else if(a > b && x>=y)
                break;
           else if(b>a && y>=x)
                break;
        }
        if(d)
          cout<<"YES"<<endl;
        else
            cout<<"NO"<<endl;

    }
    return 0;
}

----------
====================
----------
ALGORITHMS.14
easy
----------
PROBLEM STATEMENT:
You will be given two arrays of integers and asked to determine all integers that satisfy the following two conditions:  


The elements of the first array are all factors of the integer being considered
The integer being considered is a factor of all elements of the second array


These numbers are referred to as being between the two arrays.  You must determine how many such numbers exist.

For example, given the arrays [expression].  

Function Description  

Complete the getTotalX function in the editor below.  It should return the number of integers that are betwen the sets.  

getTotalX has the following parameter(s):  


a: an array of integers  
b: an array of integers  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int n, m;
    cin >> n >> m;
    vi a(n); forn(i, n) cin >> a[i];
    vi b(m); forn(i, m) cin >> b[i];
    int ans = 0;
    for1(k, 100) {
        bool ok = true;
        for (int x: a) ok &= k % x == 0;
        for (int x: b) ok &= x % k == 0;
        if (ok) ++ans;
    }
    cout << ans << '\n';

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.15
easy
----------
PROBLEM STATEMENT:
Maria plays college basketball and wants to go pro.  Each season she maintains a record of her play.  She tabulates the number of times she breaks her season record for most points and least points in a game.  Points scored in the first game establish her record for the season, and she begins counting from there.

For example, assume her scores for the season are represented in the array [expression].  Scores are in the same order as the games played.  She would tabulate her results as follows:

                                 Count
Game  Score  Minimum  Maximum   Min Max
 0      12     12       12       0   0
 1      24     12       24       0   1
 2      10     10       24       1   1
 3      24     10       24       1   1


Given Maria's scores for a season, find and print the number of times she breaks her records for most and least points scored during the season.

Function Description  

Complete the breakingRecords function in the editor below.  It must return an integer array containing the numbers of times she broke her records.  Index [expression] is for breaking least points records.  

breakingRecords has the following parameter(s):  


scores: an array of integers  

----------
TOP SOLUTION:
----------
#ifndef __clang__
#pragma GCC optimize "-O3"
#pragma GCC target "tune=native"
#endif
#ifdef ONLINE_JUDGE
#define NDEBUG 1
#endif
#include <stdio.h>
#include <bits/stdc++.h>

#define DESTRUCT2(p, a, b)                      \
  auto a = get<0>(p);                           \
  auto b = get<1>(p);

#define DESTRUCT3(p, a, b, c)                   \
  auto a = get<0>(p);                           \
  auto b = get<1>(p);                           \
  auto c = get<2>(p);

#define DESTRUCT4(p, a, b, c, d)                \
  auto a = get<0>(p);                           \
  auto b = get<1>(p);                           \
  auto c = get<2>(p);                           \
  auto d = get<3>(p);

#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)
#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)
#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)

#define SQ(x) ((x)*(x))

#define all(x) begin(x), end(x)
#define rall(x) rbegin(x), rend(x)
#define mp make_pair
#define mt make_tuple
#define pb push_back
#define eb emplace_back

using namespace std;

template<typename... As>
struct tpl : public std::tuple<As...> {
  using std::tuple<As...>::tuple;

  template<typename T = tuple<As...> >
  typename tuple_element<0, T>::type const&
  x() const { return get<0>(*this); }
  template<typename T = tuple<As...> >
  typename tuple_element<0, T>::type&
  x() { return get<0>(*this); }

  template<typename T = tuple<As...> >
  typename tuple_element<1, T>::type const&
  y() const { return get<1>(*this); }
  template<typename T = tuple<As...> >
  typename tuple_element<1, T>::type&
  y() { return get<1>(*this); }

  template<typename T = tuple<As...> >
  typename tuple_element<2, T>::type const&
  z() const { return get<2>(*this); }
  template<typename T = tuple<As...> >
  typename tuple_element<2, T>::type&
  z() { return get<2>(*this); }

  template<typename T = tuple<As...> >
  typename tuple_element<3, T>::type const&
  w() const { return get<3>(*this); }
  template<typename T = tuple<As...> >
  typename tuple_element<3, T>::type&
  w() { return get<3>(*this); }
};

using lli   = long long int;
using llu   = long long unsigned;

using pii   = tpl<lli, lli>;
using piii  = tpl<lli, lli, lli>;
using piiii = tpl<lli, lli, lli, lli>;
using vi    = vector<lli>;
using vii   = vector<pii>;
using viii  = vector<piii>;
using vvi   = vector<vi>;
using vvii  = vector<vii>;
using vviii = vector<viii>;

template<class T>
using min_queue = priority_queue<T, vector<T>, greater<T> >;
template<class T>
using max_queue = priority_queue<T>;

template<size_t... I>
struct my_index_sequence {
  using type = my_index_sequence;
  static constexpr array<size_t, sizeof...(I)> value = { {I...} };
};

namespace my_index_sequence_detail {
  template<typename I, typename J> struct concat;
  template<size_t... I, size_t... J>
  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :
    my_index_sequence<I..., (sizeof...(I)+J)...> { };
  template<size_t N> struct make_index_sequence :
    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };
  template <> struct make_index_sequence<0> : my_index_sequence<>{};
  template <> struct make_index_sequence<1> : my_index_sequence<0>{};
}

template<class... A>
using my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;

template<class T, size_t... I>
void print_tuple(ostream& s, T const& a, my_index_sequence<I...>){
  using swallow = int[];
  (void)swallow{0, (void(s << (I == 0? "" : ", ") << get<I>(a)), 0)...};
}

template<class T>
ostream& print_collection(ostream& s, T const& a);
template<class... A>
ostream& operator<<(ostream& s, tpl<A...> const& a);
template<class... A>
ostream& operator<<(ostream& s, tuple<A...> const& a);
template<class A, class B>
ostream& operator<<(ostream& s, pair<A, B> const& a);

template<class T, size_t I>
ostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }
template<class T>
ostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }
template<class T, class U>
ostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }
template<class T>
ostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }
template<class T, class U>
ostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }
template<class T>
ostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }

template<class T>
ostream& print_collection(ostream& s, T const& a){
  s << '[';
  for(auto it = begin(a); it != end(a); ++it){
    s << *it;
    if(it != prev(end(a))) s << " ";
  }
  return s << ']';
}

template<class... A>
ostream& operator<<(ostream& s, tpl<A...> const& a){
  s << '(';
  print_tuple(s, a, my_index_sequence_for<A...>{});
  return s << ')';
}

template<class... A>
ostream& operator<<(ostream& s, tuple<A...> const& a){
  s << '(';
  print_tuple(s, a, my_index_sequence_for<A...>{});
  return s << ')';
}

template<class A, class B>
ostream& operator<<(ostream& s, pair<A, B> const& a){
  return s << "(" << get<0>(a) << ", " << get<1>(a) << ")";
}

namespace std {
  namespace {
    template <class T>
    inline void hash_combine(size_t& seed, T const& v) {
      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
    }
    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>
    struct HashValueImpl {
      static void apply(size_t& seed, Tuple const& tuple) {
        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);
        hash_combine(seed, get<Index>(tuple));
      }
    };
    template <class Tuple>
    struct HashValueImpl<Tuple, 0> {
      static void apply(size_t& seed, Tuple const& tuple) {
        hash_combine(seed, get<0>(tuple));
      }
    };
  }
  template <typename ... TT>
  struct hash<tuple<TT...>> {
    size_t operator()(tuple<TT...> const& tt) const {
      size_t seed = 0;
      HashValueImpl<tuple<TT...> >::apply(seed, tt);
      return seed;
    }
  };
  template <typename ... TT>
  struct hash<tpl<TT...>> {
    size_t operator()(tpl<TT...> const& tt) const {
      size_t seed = 0;
      HashValueImpl<tuple<TT...> >::apply(seed, tt);
      return seed;
    }
  };
}

lli read_positive(){
  char c; lli x=0;
  do { c = getchar(); } while(c<'0' || c>'9');
  while(c>='0'&&c<='9') {
    x=10*x+(c-'0');
    c = getchar();
  }
  return x;
}

//------------------------------------------------------------------------------

int main(){
  ios::sync_with_stdio(0); cin.tie(0);
  int n; cin >> n;
  int l,h;
  cin >> l; h=l;
  int a=0,b=0;
  FOR(i,n-1){
    int x;cin>>x;
    if(x<l) { a++; l=x; }
    if(x>h) { b++; h=x; }
  }
  cout << b << " " << a << endl;
  return 0;
}

----------
====================
----------
ALGORITHMS.16
easy
----------
PROBLEM STATEMENT:
Lily has a chocolate bar that she wants to share it with Ron for his birthday.  Each of the squares has an integer on it.  She decides to share a contiguous segment of the bar selected such that the length of the segment matches Ron's birth month and the sum of the integers on the squares is equal to his birth day.  You must determine how many ways she can divide the chocolate.

Consider the chocolate bar as an array of squares, [expression].

Function Description

Complete the birthday function in the editor below.  It should return an integer denoting the number of ways Lily can divide the chocolate bar.  

birthday has the following parameter(s):  


s: an array of integers, the numbers on each of the squares of chocolate  
d: an integer, Ron's birth day  
m: an integer, Ron's birth month  

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;
typedef long long int uli;
const int mx=123;
int s[mx];
int main(){
  int n,d,m;
  scanf("%d",&n);
  for(int i=0;i<n;i++){
    scanf("%d",s+i);
  }
  scanf("%d %d",&d,&m);
  int ans=0;
  for(int i=0;i<n;i++){
    for(int j=i;j<n;j++)if(j-i+1==m){
      int sm=0;
      for(int k=i;k<=j;k++)sm+=s[k];
      if(sm==d){
        ans++;
      }
    }
  }
  printf("%d\n",ans);
  return 0;
}

----------
====================
----------
ALGORITHMS.17
easy
----------
PROBLEM STATEMENT:
You are given an array of [expression].  

For example, [expression].  

Function Description

Complete the divisibleSumPairs function in the editor below.  It should return the integer count of pairs meeting the criteria.  

divisibleSumPairs has the following parameter(s):  


n: the integer length of array [expression]  
ar: an array of integers  
k: the integer to divide the pair sum by  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;


int main(){
    int n;
    int k;
    int count = 0;
    cin >> n >> k;
    vector<int> a(n);
    for(int a_i = 0;a_i < n;a_i++){
       cin >> a[a_i];
    }
    
    for(int i =0 ; i < n -1 ; i++){
        for(int j=i+1 ; j < n ; j++){
            if( (a[i]+a[j])%k ==0){
                count++;
            }
        }
    }
    
    cout << count;
    return 0;
}

----------
====================
----------
ALGORITHMS.18
easy
----------
PROBLEM STATEMENT:
You have been asked to help study the population of birds migrating across the continent.  Each type of bird you are interested in will be identified by an integer value.  Each time a particular kind of bird is spotted, its id number will be added to your array of sightings. You would like to be able to find out which type of bird is most common given a list of sightings. Your task is to print the type number of that bird and if two or more types of birds are equally common, choose the type with the smallest ID number.

For example, assume your bird sightings are of types [expression].  

Function Description

Complete the migratoryBirds function in the editor below.  It should return the lowest type number of the most frequently sighted bird.  

migratoryBirds has the following parameter(s):  


arr: an array of integers representing types of birds sighted  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

const int maxN = 1e5+10;
int N,A[10];

int main()
{
    cin >> N;
    for (int i=1,x; i <= N; i++) cin >> x, A[x]++;
    int ans = 1;
    for (int i=2; i <= 5; i++)
        if (A[i] > A[ans]) ans = i;
    cout << ans;
}

----------
====================
----------
ALGORITHMS.19
easy
----------
PROBLEM STATEMENT:
Marie invented a Time Machine and wants to test it by time-traveling to visit Russia on the Day of the Programmer (the [expression]. 

From [expression] day of the year in Russia.

In both calendar systems, February is the only month with a variable amount of days; it has [expression]; in the Gregorian calendar, leap years are either of the following:


Divisible by [expression].
Divisible by [expression].


Given a year, [expression].

For example, the given [expression].  

Function Description  

Complete the dayOfProgrammer function in the editor below.  It should return a string representing the date of the [expression] day of the year given.  

dayOfProgrammer has the following parameter(s):  


year: an integer  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
    int n;
    cin>>n;
    if(n<1918)
        {
        if(n%4==0)
            cout<<"12.09."<<n;
        else
            cout<<"13.09."<<n;
    }
    else if(n==1918)
        {
        cout<<"26.09.1918";
    }
    else
        {
        if(n%400==0 || (n%4==0 && n%100!=0))
            cout<<"12.09."<<n;
        else
            cout<<"13.09."<<n;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.20
easy
----------
PROBLEM STATEMENT:
Anna and Brian are sharing a meal at a restuarant and they agree to split the bill equally.  Brian wants to order something that Anna is allergic to though, and they agree that Anna won't pay for that item.  Brian gets the check and calculates Anna's portion.  You must determine if his calculation is correct.

For example, assume the bill has the following prices: [expression] to Anna.

Function Description  

Complete the bonAppetit function in the editor below.  It should print Bon Appetit if the bill is fairly split.  Otherwise, it should print the integer amount of money that Brian owes Anna.  

bonAppetit has the following parameter(s):  


bill: an array of integers representing the cost of each item ordered  
k: an integer representing the zero-based index of the item Anna doesn't eat  
b: the amount of money that Anna contributed to the bill  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int n, k, sum=0;
    cin >> n >> k;
    for (int i=0;i<n;i++) {
        int a;
        cin >> a;
        if (i!=k) sum+=a;
    }
    int l;
    cin >> l;
    if (sum/2==l) cout << "Bon Appetit" << endl;
    else cout << l-sum/2 << endl;
}

----------
====================
----------
ALGORITHMS.21
easy
----------
PROBLEM STATEMENT:
John works at a clothing store.  He has a large pile of socks that he must pair by color for sale.  Given an array of integers representing the color of each sock, determine how many pairs of socks with matching colors there are.

For example, there are [expression].  

Function Description  

Complete the sockMerchant function in the editor below.  It must return an integer representing the number of matching pairs of socks that are available.  

sockMerchant has the following parameter(s):  


n: the number of socks in the pile  
ar: the colors of each sock  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

#define FI(i,a,b) for(int i=(a);i<=(b);i++)
#define FD(i,a,b) for(int i=(a);i>=(b);i--)

#define LL long long
#define Ldouble long double
#define PI 3.1415926535897932384626

#define PII pair<int,int>
#define PLL pair<LL,LL>
#define mp make_pair
#define fi first
#define se second

using namespace std;

int n, c[105], x;

int main(){
	scanf("%d", &n);
	FI(i, 1, n){
		scanf("%d", &x);
		c[x]++;
	}
	
	int ans = 0;
	
	FI(i, 1, 100) ans += c[i] / 2;
	printf("%d\n", ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.22
easy
----------
PROBLEM STATEMENT:
Brie’s Drawing teacher asks her class to open their books to a page number. Brie can either start turning pages from the front of the book or from the back of the book. She always turns pages one at a time.  When she opens the book, page [expression] is always on the right side:



When she flips page [expression], what is the minimum number of pages she will turn?  She can start at the beginning or the end of the book. 

Given [expression]. 

Function Description  

Complete the pageCount function in the editor below.  It should return the minimum number of pages Brie must turn.  

pageCount has the following parameter(s):  


n: the number of pages in the book   
p: the page number to turn to  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;


int main(){
    int n;
    cin >> n;
    int p;
    cin >> p;
    cout<<min(p/2,(n-p)/2);
    // your code goes here
    return 0;
}

----------
====================
----------
ALGORITHMS.23
easy
----------
PROBLEM STATEMENT:
Gary is an avid hiker. He tracks his hikes meticulously, paying close attention to small details like topography. During his last hike he took exactly [expression] unit change in altitude. We define the following terms:


A mountain is a sequence of consecutive steps above sea level, starting with a step up from sea level and ending with a step down to sea level.  
A valley is a sequence of consecutive steps below sea level, starting with a step down from sea level and ending with a step up to sea level.


Given Gary's sequence of up and down steps during his last hike, find and print the number of valleys he walked through. 

For example, if Gary's path is [expression] units high.  Finally, he returns to sea level and ends his hike.  

Function Description  

Complete the countingValleys function in the editor below.  It must return an integer that denotes the number of valleys Gary traversed.  

countingValleys has the following parameter(s):  


n: the number of steps Gary takes  
s: a string describing his path  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int l;
    string str; cin>>l>>str;
    int height = 0;
    int count = 0;
    for(int i=0;i<l;i++){
        if (str[i]=='U') height++;
        else {
            if (height==0) count++;
            height--;
        }
    }
    if (height<0) count--;
    cout<<count<<endl;
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
ALGORITHMS.24
easy
----------
PROBLEM STATEMENT:
Monica wants to buy a keyboard and a USB drive from her favorite electronics store. The store has several models of each.  Monica wants to spend as much as possible for the [expression] items, given her budget.

Given the price lists for the store's keyboards and USB drives, and Monica's budget, find and print the amount of money Monica will spend. If she doesn't have enough money to both a keyboard and a USB drive, print -1 instead.  She will buy only the two required items.

For example, suppose she has [expression].  

Function Description  

Complete the getMoneySpent function in the editor below.  It should return the maximum total price for the two items within Monica's budget, or [expression] if she cannot afford both items.  

getMoneySpent has the following parameter(s):  


keyboards: an array of integers representing keyboard prices  
drives:  an array of integers representing drive prices  
b: the units of currency in Monica's budget  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
#define REP(i,a,b) for (int i = (a); i <= (b); ++i)
#define REPD(i,a,b) for (int i = (a); i >= (b); --i)
#define FORI(i,n) REP(i,1,n)
#define FOR(i,n) REP(i,0,int(n)-1)
#define mp make_pair
#define pb push_back
#define pii pair<int,int>
#define vi vector<int>
#define ll long long
#define SZ(x) int((x).size())
#define DBG(v) cerr << #v << " = " << (v) << endl;
#define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++)
#define fi first
#define se second


int main(){
    int s;
    int n;
    int m;
    cin >> s >> n >> m;
    vector<int> keyboards(n);
    for(int keyboards_i = 0;keyboards_i < n;keyboards_i++){
       cin >> keyboards[keyboards_i];
    }
    vector<int> pendrives(m);
    for(int pendrives_i = 0;pendrives_i < m;pendrives_i++){
       cin >> pendrives[pendrives_i];
    }
    int res=-1;
    FOR(i,n) FOR(j,m) if (keyboards[i]+pendrives[j] <= s) res = max(res, keyboards[i]+pendrives[j]);
        cout << res << "\n";
    return 0;
}

----------
====================
----------
ALGORITHMS.25
easy
----------
PROBLEM STATEMENT:
Two cats and a mouse are at various positions on a line.  You will be given their starting positions.  Your task is to determine which cat will reach the mouse first, assuming the mouse doesn't move and the cats travel at equal speed.  If the cats arrive at the same time, the mouse will be allowed to move and it will escape while they fight.

You are given [expression] to return the appropriate answer to each query, which will be printed on a new line.


If cat [expression] catches the mouse first, print Cat A.
If cat [expression] catches the mouse first, print Cat B.
If both cats reach the mouse at the same time, print Mouse C as the two cats fight and mouse escapes.  


For example, cat [expression] will catch the mouse.  

Function Description  

Complete the catAndMouse function in the editor below.  It should return one of the three strings as described.  

catAndMouse has the following parameter(s):  


x: an integer, Cat [expression]'s position  
y: an integer, Cat [expression]'s position  
z: an integer, Mouse [expression]'s position  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;


int main(){
    int q;
    cin >> q;
    for(int a0 = 0; a0 < q; a0++){
        int x;
        int y;
        int z;
        cin >> x >> y >> z;
        int d1 = abs(x - z), d2 = abs(y - z);
        if (d1 < d2) cout << "Cat A" << endl;
        else if (d1 > d2) cout << "Cat B" << endl;
            else cout << "Mouse C" << endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.26
medium
----------
PROBLEM STATEMENT:
We define a magic square to be an [expression] is always equal to the same number:  the magic constant. 

You will be given a [expression], convert it into a magic square at minimal cost. Print this cost on a new line.

Note: The resulting magic square must contain distinct integers in the inclusive range [expression].

For example, we start with the following matrix [expression]:  

[expression]
[expression]
[expression]



We can convert it to the following magic square:

[expression]
[expression]
[expression]



This took three replacements at a cost of [expression].

Function Description

Complete the formingMagicSquare function in the editor below.  It should return an integer that represents the minimal total cost of converting the input square to a magic square.

formingMagicSquare has the following parameter(s):  


s: a [expression] array of integers

----------
TOP SOLUTION:
----------
#include <iostream>

using namespace std;

int main() {
	
	int m1[3][3], m2[3][3], best = 2000000000;
	
	for( int i=0; i<3; i++ )
		for(int j=0; j<3; j++ )
				cin >> m1[i][j];
				
	for( int a=1; a<=9; a++ )
	for( int b=1; b<=9; b++ ) {
		if( b==a) continue;
	for( int c=1; c<=9; c++ ) {
		if( c==a || c==b ) continue;
	for( int d=1; d<=9; d++ ) {
		if( d==a || d==b || d==c ) continue;
	for( int e=1; e<=9; e++ ) {
		if( e==a || e==b || e==c || e==d ) continue;
	for( int f=1; f<=9; f++ ) {
		if( f==a || f==b || f==c || f==d || f==e ) continue;
	for( int g=1; g<=9; g++ ) {
		if( g==a || g==b || g==c || g==d || g==e || g==f ) continue;
	for( int h=1; h<=9; h++ ) {
		if( h==a || h==b || h==c || h==d || h==e || h==f || h==g ) continue;
	for( int i=1; i<=9; i++ ) {
		if( i==a || i==b || i==c || i==d || i==e || i==f || i==g || i==h ) continue;
		
		m2[0][0] = a;
		m2[0][1] = b;
		m2[0][2] = c,
		m2[1][0] = d;
		m2[1][1] = e;
		m2[1][2] = f;
		m2[2][0] = g;
		m2[2][1] = h;
		m2[2][2] = i;
		
		if( a + b + c  == d + e + f && d + e + f == g + h + i && 
			a + d + g == b + e + h && b + e + h == c + f + i &&
			a + b + c  == a + e + i && a + b + c == c + e + g ) {
				int cost = 0;
				for( int r=0; r<3; r++ )
					for( int s=0; s<3; s++ )
						cost += abs( m1[r][s] - m2[r][s] );
			best = min( best, cost );			
			}
	}}}}}}}}
	
	cout << best;
	return 0;
}
----------
====================
----------
ALGORITHMS.27
easy
----------
PROBLEM STATEMENT:
Given an array of integers, find and print the maximum number of integers you can select from the array such that the absolute difference between any two of the chosen integers is less than or equal to [expression] elements.

Function Description  

Complete the pickingNumbers function in the editor below.  It should return an integer that represents the length of the longest array that can be created.  

pickingNumbers has the following parameter(s):  


a: an array of integers  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

int N;
int A[1000];

int main()
{
    scanf("%d", &N);
    for(int i=0; i<N; i++)
    {
        int a;
        scanf("%d", &a);
        A[a]++;
    }
    int ans=0;
    for(int i=1; i<1000; i++)
        ans=max(ans, A[i-1]+A[i]);
    printf("%d\n", ans);
    return 0;
}

----------
====================
----------
ALGORITHMS.28
medium
----------
PROBLEM STATEMENT:
Alice is playing an arcade game and wants to climb to the top of the leaderboard and wants to track her ranking. The game uses Dense Ranking, so its leaderboard works like this:  


The player with the highest score is ranked number [expression] on the leaderboard. 
Players who have equal scores receive the same ranking number, and the next player(s) receive the immediately following ranking number.


For example, the four players on the leaderboard have high scores of [expression]. 

Function Description  

Complete the climbingLeaderboard function in the editor below.  It should return an integer array where each element [expression] game.

climbingLeaderboard has the following parameter(s):  


scores: an array of integers that represent leaderboard scores  
alice: an array of integers that represent Alice's scores  

----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }

int main() {
	int n;
	while (~scanf("%d", &n)) {
		vector<int> a(n);
		for (int i = 0; i < n; ++i)
			scanf("%d", &a[i]);
		a.erase(unique(a.begin(), a.end()), a.end());

		int m;
		scanf("%d", &m);
		rep(i, m) {
			int x;
			scanf("%d", &x);
			int ans = (int)(lower_bound(a.begin(), a.end(), x, greater<int>()) - a.begin());
			printf("%d\n", ans + 1);
		}
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.29
easy
----------
PROBLEM STATEMENT:
Dan is playing a video game in which his character competes in a hurdle race.  Hurdles are of varying heights, and Dan has a maximum height he can jump.  There is a magic potion he can take that will increase his maximum height by [expression] unit for each dose.  How many doses of the potion must he take to be able to jump all of the hurdles.

Given an array of hurdle heights [expression], determine the minimum number of doses Dan must take to be able to clear all the hurdles in the race.  

For example, if [expression] doses of potion to be able to jump all of the hurdles.  

Function Description  

Complete the hurdleRace function in the editor below.  It should return the minimum units of potion Dan needs to drink to jump all of the hurdles.  

hurdleRace has the following parameter(s):  


k: an integer denoting the height Dan can jump naturally  
height: an array of integers denoting the heights of each hurdle  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;


int main(){
    int n;
    int k;
    cin >> n >> k;
    vector<int> height(n);
    int maxall=0;
    for(int height_i = 0; height_i < n; height_i++){
       cin >> height[height_i];
        maxall=max(maxall,height[height_i]);
    }
    cout<<max(0,maxall-k);
    // your code goes here
    return 0;
}

----------
====================
----------
ALGORITHMS.30
easy
----------
PROBLEM STATEMENT:
When you select a contiguous block of text in a PDF viewer, the selection is highlighted with a blue rectangle. In this PDF viewer, each word is highlighted independently. For example: 



In this challenge, you will be given a list of letter heights in the alphabet and a string.  Using the letter heights given, determine the area of the rectangle highlight in [expression] wide.  

For example, the highlighted [expression].  

Function Description  

Complete the designerPdfViewer function in the editor below.  It should return an integer representing the size of the highlighted area.  

designerPdfViewer has the following parameter(s):


h: an array of integers representing the heights of each letter  
word: a string  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

int a[42];
char s[1231212];

int main() {
  for (int i = 0; i < 26; i++) {
    scanf("%d", a + i);
  }
  scanf("%s", s);
  int h = 0;
  int w = 0;
  for (int i = 0; s[i]; i++) {
    w++;
    h = max(h, a[s[i] - 'a']);
  }
  printf("%d\n", h * w);
  return 0;
}

----------
====================
----------
ALGORITHMS.31
easy
----------
PROBLEM STATEMENT:
The Utopian Tree goes through 2 cycles of growth every year. Each spring, it doubles in height. Each summer, its height increases by 1 meter.

Laura plants a Utopian Tree sapling with a height of 1 meter at the onset of spring. How tall will her tree be after [expression] growth cycles?

For example, if the number of growth cycles is [expression], the calculations are as follows:

Period  Height
0          1
1          2
2          3
3          6
4          7
5          14


Function Description

Complete the utopianTree function in the editor below.  It should return the integer height of the tree after the input number of growth cycles.  

utopianTree has the following parameter(s):


n:  an integer, the number of growth cycles to simulate  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

typedef pair<int, int> ii;
typedef vector<ii> vii;
typedef vector<int> vi;

#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define sz(v) (int)v.size()
#define all(c) (c).begin(), (c).end()

typedef long long int ll;

int main() {
	int t;
	while (scanf("%d", &t) == 1) {
		for (int i = 0; i < t; i++) {
			int n;
			scanf("%d", &n);

			int height = 1;
			for (int j = 0; j < n; j++) {
				if (j % 2 == 0)
					height *= 2;
				else
					height++;
			}

			printf("%d\n", height);
		}
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.32
easy
----------
PROBLEM STATEMENT:
A Discrete Mathematics professor has a class of students. Frustrated with their lack of discipline, he decides to cancel class if fewer than some number of students are present when class starts.  Arrival times go from on time ([expression]).

Given the arrival time of each student and a threshhold number of attendees, determine if the class is canceled.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int a; cin >> a;
	for (int g=0; g<a; g++)
	{
		int b,c; cin >> b >> c;
		int num=0; 
		for (int g=0; g<b; g++)
		{
			int d; cin >> d;
			if (d<=0) num++; 
		}
		if (num>=c)
		{
			cout << "NO" << '\n'; 
		}
		else cout << "YES" << '\n';
	}
	return 0; 
}
----------
====================
----------
ALGORITHMS.33
easy
----------
PROBLEM STATEMENT:
Lily likes to play games with integers.  She has created a new game where she determines the difference between a number and its reverse.  For instance, given the number [expression].

She decides to apply her game to decision making.  She will look at a numbered range of days and will only go to a movie on a beautiful day.

Given a range of numbered days, [expression].  If a day's value is a beautiful number, it is a beautiful day.  Print the number of beautiful days in the range.

Function Description  

Complete the beautifulDays function in the editor below.  It must return the number of beautiful days in the range.  

beautifulDays has the following parameter(s):  


i: the starting day number  
j: the ending day number  
k: the divisor  

----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
ALGORITHMS.34
easy
----------
PROBLEM STATEMENT:
HackerLand Enterprise is adopting a new viral advertising strategy. When they launch a new product, they advertise it to exactly [expression] people on social media. 

On the first day, half of those [expression] people receive the advertisement. 

Each day, [expression].

For example, assume you want to know how many have liked the ad by the end of the [expression] day.

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



The cumulative number of likes is [expression].  

Function Description  

Complete the viralAdvertising function in the editor below.  It should return the cumulative number of people who have liked the ad at a given time.  

viralAdvertising has the following parameter(s):  


n: the integer number of days  

----------
TOP SOLUTION:
----------
#include <algorithm>
#include <bitset>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <deque>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <vector>
using namespace std;

int n;
long long ans = 0;

int main() {
	cin >> n;
	int counts = 2;
	for (int i = 1; i <= n; i++) {
		ans += counts;
		counts = counts * 3 / 2;
	}
	cout << ans << endl;
	return 0;
}
----------
====================
----------
ALGORITHMS.35
easy
----------
PROBLEM STATEMENT:
A jail has a number of prisoners and a number of treats to pass out to them.  Their jailer decides the fairest way to divide the treats is to seat the prisoners around a circular table in sequentially numbered chairs.  A chair number will be drawn from a hat.  Beginning with the prisoner in that chair, one candy will be handed to each prisoner sequentially around the table until all have been distributed.

The jailer is playing a little joke, though.  The last piece of candy looks like all the others, but it tastes awful.  Determine the chair number occupied by the prisoner who will receive that candy.

For example, there are [expression].  

Function Description

Complete the saveThePrisoner function in the editor below.  It should return an integer representing the chair number of the prisoner to warn.  

saveThePrisoner has the following parameter(s):  


n:  an integer, the number of prisoners  
m:  an integer, the number of sweets  
s:  an integer, the chair number to begin passing out sweets from  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int t; cin >> t;
    
    while(t--) {
        int n,m,s; cin >> n >> m >> s;
        --s; --m;
        s += m;
        s %= n;
        s++;
        cout << s << endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.36
easy
----------
PROBLEM STATEMENT:
John Watson knows of an operation called a right circular rotation on an array of integers.  One rotation operation moves the last array element to the first position and shifts all remaining elements right one.  To test Sherlock's abilities, Watson provides Sherlock with an array of integers.  Sherlock is to perform the rotation operation a number of times then determine the value of the element at a given position.

For each array, perform a number of right circular rotations and return the value of the element at a given index.

For example, array [expression]. 
First we perform the two rotations: 
[expression] 
Now return the values from the zero-based indices [expression] array. 
[expression] 
[expression]  

Function Description  

Complete the circularArrayRotation function in the editor below.  It should return an array of integers representing the values at the specified indices.  

circularArrayRotation has the following parameter(s):  


a: an array of integers to rotate  
k: an integer, the rotation count  
queries: an array of integers, the indices to report  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

typedef pair<int, int> ii;
typedef vector<ii> vii;
typedef vector<int> vi;

#define FOR(i,s,e) for (int i = int(s); i < int(e); i++)
#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define sz(v) (int)v.size()
#define all(c) (c).begin(), (c).end()

typedef long long int ll;

// %I64d for ll in CF

int main() {
	int n, k, q;
	while (scanf("%d %d %d", &n, &k, &q) != EOF) {
		int as[n];
		for (int i = 0; i < n; i++) {
			scanf("%d", &as[i]);
		}

		for (int i = 0; i < q; i++) {
			int x;
			scanf("%d", &x);
			x -= k;
			while (x < 0) x += n;
			printf("%d\n", as[x]);
		}
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.37
easy
----------
PROBLEM STATEMENT:
Given a sequence of [expression] on a new line.

For example, assume the sequence [expression], the length of the sequence, is analyzed as follows:


[expression]
[expression]
[expression]
[expression]
[expression]


The values for [expression].  

Function Description  

Complete the permutationEquation function in the editor below.  It should return an array of integers that represent the values of [expression].  

permutationEquation has the following parameter(s):  


p: an array of integers  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

#define all(a) (a).begin(), (a).end()
#define sz(a) (int)(a).size()
#define pb push_back

using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
typedef long double ld;

int main()
{

	//ifstream cin("input.txt");
	//ofstream cout("output.txt");

	int n;
	cin >> n;

	vector<int> p(n);
	for (int i = 0; i < n; ++i) {
		int x;
		cin >> x;
		--x;
		p[x] = i;
	}

	for (int i = 0; i < n; ++i) {
		cout << p[p[i]] + 1 << "\n";
	}

}

----------
====================
----------
ALGORITHMS.38
easy
----------
PROBLEM STATEMENT:
Aerith is playing a cloud hopping game. In this game, there are sequentially numbered clouds that can be thunderheads or cumulus clouds.  Her character must jump from cloud to cloud until it reaches the start again.  

To play, Aerith is given an array of clouds, [expression].

Given the values of [expression] after the game ends?

For example, give [expression].

Note: Recall that [expression].  

Function Description  

Complete the jumpingOnClouds function in the editor below.  It should return an integer representing the energy level remaining after the game.  

jumpingOnClouds has the following parameter(s):  


c: an array of integers representing cloud types  
k: an integer representing the length of one jump  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

#define FO(i,a,b) for (int i = (a); i < (b); i++)
#define sz(v) int(v.size())

using namespace std;

int n, k, e;
int t[105];

int main() {
    scanf("%d %d", &n, &k); e = 100;
    FO(i,0,n) scanf("%d", t+i);
    int i = 0;
    while (1) {
        e -= 2*t[i]+1;
        i = (i+k)%n;
        if (i == 0) break;
    }
    printf("%d\n", e);
}

----------
====================
----------
ALGORITHMS.39
easy
----------
PROBLEM STATEMENT:
An integer [expression].  

Given an integer, for each digit that makes up the integer determine whether it is a divisor.  Count the number of divisors occurring within the integer.  

Note: Each digit is considered to be unique, so each occurrence of the same digit should be counted (e.g. for [expression]).

Function Description

Complete the findDigits function in the editor below.  It should return an integer representing the number of digits of [expression].  

findDigits has the following parameter(s):


n: an integer to analyze

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int getR(string n, int q) {
    if(!q) return 0;
    int r = 0;
    for(int i = 0;i < n.length();++i) {
        r *= 10;
        r += (n[i] - '0');
        r %= q;
    }
    if(!r) return 1;
    return 0;
}


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int T;
    string n;
    int res = 0;
    
    cin >> T;
    while(T--) {
        cin >> n;
        
        res = 0;
        for(int i = 0;i < n.length();++i)
            res += getR(n, n[i] - '0');
        
        cout << res << endl;
    }
    
    return 0;
}

----------
====================
----------
ALGORITHMS.40
medium
----------
PROBLEM STATEMENT:
The factorial of the integer [expression], is defined as:   

[expression]

Calculate and print the factorial of a given integer.  

For example, if [expression].

Function Description

Complete the extraLongFactorials function in the editor below.  It should print the result and return.  

extraLongFactorials has the following parameter(s):  


n: an integer


Note: Factorials of [expression] long long variable. Big integers must be used for such calculations. Languages like Java, Python, Ruby etc. can handle big integers, but we need to write additional code in C/C++ to handle huge values.  

We recommend solving this challenge using BigIntegers.  
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

string multiply(string &num1, string num2) {
    string res;
    int a, b, c, m, n, l, k, sum, carry;
    char d;

    m = num1.size() - 1;
    n = num2.size() - 1;
    carry = 0;
    for (int i = m; i >= 0; i--) {
        for (int j = n; j >= 0; j--) {
            l = res.size() - 1;
            a = num1[i] - '0';
            b = num2[j] - '0';
            k = (m-i) + (n-j);

            if (l >= k) c = res[l-k] - '0';
            else c = 0;

            sum = a * b + c + carry;
            carry = sum / 10;
            d = char(sum % 10 + '0');

            if (l >= k) res[l-k] = d;
            else res.insert(0, &d, 1);

            if (j == 0 && carry) {
                d = char(carry + '0');
                res.insert(0, &d, 1);
                carry = 0;
            }
        }
    }

    return res[0] == '0' ? "0" : res;
}

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
    int n;
    cin >> n;
    
    string s = "1";
    for (int i = 1; i <= n; ++i) {
        s = multiply(s, to_string(i));
    }
    cout << s << endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.41
easy
----------
PROBLEM STATEMENT:
You have a string of lowercase English alphabetic letters. You can perform two types of operations on the string:


Append a lowercase English alphabetic letter to the end of the string.
Delete the last character in the string. Performing this operation on an empty string results in an empty string.


Given an integer, [expression]. If it's possible, print Yes.  Otherwise, print No.

For example, strings [expression] moves, we would not have succeeded in creating the new string.  

Function Description  

Complete the appendAndDelete function in the editor below.  It should return a string, either Yes or No.  

appendAndDelete has the following parameter(s):  


s: the initial string  
t: the desired string  
k: an integer that represents the number of operations  

----------
TOP SOLUTION:
----------

#include <iostream>
#include <vector>
#include <string>
#include <string.h>
#include <cmath>

using namespace std;

int main() {
    string s, t;
    cin >> s >> t;
    int k;
    cin >> k;
    
    int i = 0, j = 0;
    for (; i < (int)s.size() && j < (int)t.size(); ++i,++j) {
        if (s[i] != t[j])
            break;
    }
    
    int need = ((int)s.size() - i) + ((int)t.size() - j);
    if ((need <= k && (k-need) % 2 == 0) || k >= (int)s.size() + (int)t.size()) {
        cout << "Yes";
    } else {
        cout << "No";
    }
    
    

    return 0;
}

----------
====================
----------
ALGORITHMS.42
easy
----------
PROBLEM STATEMENT:
Watson likes to challenge Sherlock's math ability.  He will provide a starting and ending value describing a range of integers.  Sherlock must determine the number of square integers within that range, inclusive of the endpoints.

Note: A square integer is an integer which is the square of an integer, e.g. [expression]. 

For example, the range is [expression].  

Function Description

Complete the squares function in the editor below.  It should return an integer representing the number of square integers in the inclusive range from [expression].  

squares has the following parameter(s):  


a: an integer, the lower range boundary
b: an integer, the uppere range boundary 

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
   int n,m;
  cin>>n;
  
  while (cin>>n>>m)
    {
        cout<<(int)(sqrt(m)+0.0000001)-(int)(sqrt(n-1)+0.0000001)<<endl;
    }
  return 0;
}

----------
====================
----------
ALGORITHMS.43
easy
----------
PROBLEM STATEMENT:
Your local library needs your help! Given the expected and actual return dates for a library book, create a program that calculates the fine (if any). The fee structure is as follows: 


If the book is returned on or before the expected return date, no fine will be charged (i.e.: [expression].
If the book is returned after the expected return day but still within the same calendar month and year as the expected return date, [expression]. 
If the book is returned after the expected return month but still within the same calendar year as the expected return date, the [expression].   
If the book is returned after the calendar year in which it was expected, there is a fixed fine of [expression].


Charges are based only on the least precise measure of lateness.  For example, whether a book is due January 1, 2017 or December 31, 2017, if it is returned January 1, 2018, that is a year late and the fine would be [expression].  

Function Description  

Complete the libraryFine function in the editor below.  It must return an integer representing the fine due.  

libraryFine has the following parameter(s):  


d1, m1, y1: returned date day, month and year  
d2, m2, y2: due date day, month and year  

----------
TOP SOLUTION:
----------
#include<iostream>
using namespace std;
int main()
{
    int actual[3],expected[3],i,j;
    for(i=0;i<3;i++)
    cin>>actual[i];
    for(i=0;i<3;i++)
    cin>>expected[i];
   
    if(actual[2]-expected[2]<0)
        cout<<0;
    else if(actual[2]-expected[2]>0)
        cout<<10000;
    else if(actual[1]-expected[1]<0)
        cout<<0;
    else if(actual[1]-expected[1]>0)
        cout<<500*(actual[1]-expected[1]);
    else if(actual[0]-expected[0]>0)
        cout<<15*(actual[0]-expected[0]);
    else
        cout<<0;

}   
----------
====================
----------
ALGORITHMS.44
easy
----------
PROBLEM STATEMENT:
You are given a number of sticks of varying lengths.  You will iteratively cut the sticks into smaller sticks, discarding the shortest pieces until there are none left.  At each iteration you will determine the length of the shortest stick remaining, cut that length from each of the longer sticks and then discard all the pieces of that shortest length.  When all the remaining sticks are the same length, they cannot be shortened so discard them.

Given the lengths of [expression] sticks, print the number of sticks that are left before each iteration until there are none left.

For example, there are [expression].  

Function Description  

Complete the cutTheSticks function in the editor below.  It should return an array of integers representing the number of sticks before each cut operation is performed.  

cutTheSticks has the following parameter(s):  


arr: an array of integers representing the length of each stick  


Input Format  

The first line contains a single integer [expression]. 
The next line contains [expression] stick.

Output Format  

For each operation, print the number of sticks that are present before the operation on separate lines.  

Constraints  


[expression]
[expression]


Sample Input 0

6
5 4 4 2 2 8


Sample Output 0

6
4
2
1


Explanation 0

[expression]sticks-length        length-of-cut   sticks-cut
5 4 4 2 2 8             2               6
3 2 2 _ _ 6             2               4
1 _ _ _ _ 4             1               2
_ _ _ _ _ 3             3               1
_ _ _ _ _ _           DONE            DONE



Sample Input 1

8
1 2 3 4 3 3 2 1


Sample Output 1

8
6
4
1


Explanation 1

[expression]sticks-length         length-of-cut   sticks-cut
1 2 3 4 3 3 2 1         1               8
_ 1 2 3 2 2 1 _         1               6
_ _ 1 2 1 1 _ _         1               4
_ _ _ 1 _ _ _ _         1               1
_ _ _ _ _ _ _ _       DONE            DONE


----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

int a[1000];
int main() {
	int N;
	scanf("%d", &N);
	rep(i, N) scanf("%d", &a[i]);
	sort(a, a+N);
	for(int i = 0; i < N; ) {
		printf("%d\n", N - i);
		int j = i+1;
		while(j < N && a[i] == a[j]) j ++;
		i = j;
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.45
medium
----------
PROBLEM STATEMENT:
Given a set of distinct integers, print the size of a maximal subset of [expression].

For example, the array [expression] elements.  

Function Description  

Complete the nonDivisibleSubset function in the editor below.  It should return an integer representing the length of the longest subset of [expression] meeting the criteria.  

nonDivisibleSubset has the following parameter(s):  


S: an array of integers  
k: an integer  

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;
#define FOR(i,a,b) for(int i = (a); i <= (b); ++i)
#define FORD(i,a,b) for(int i = (a); i >= (b); --i)
#define RI(i,n) FOR(i,1,(n))
#define REP(i,n) FOR(i,0,(n)-1)
#define mini(a,b) a=min(a,b)
#define maxi(a,b) a=max(a,b)
#define mp make_pair
#define pb push_back
#define st first
#define nd second
#define sz(w) (int) w.size()
typedef vector<int> vi;
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
const int inf = 1e9 + 5;
const int nax = 1e6 + 5;

int t[nax];
int main() {
	
	int n, k;
	scanf("%d%d", &n, &k);
	REP(_, n) {
		int a;
		scanf("%d", &a);
		++t[a%k];
	}
	int s = 0;
	s += min(t[0], 1);
	RI(i, k-1) {
		int j = k-i;
		if(j < i) break;
		if(i == j) s+= min(t[i], 1);
		else s += max(t[i], t[j]);
	}
	printf("%d\n", s);
	
	return 0;
}

----------
====================
----------
ALGORITHMS.46
easy
----------
PROBLEM STATEMENT:
Lilah has a string, [expression], of lowercase English letters that she repeated infinitely many times.

Given an integer, [expression] letters of Lilah's infinite string.

For example, if the string [expression] occurrences of a in the substring.  

Function Description  

Complete the repeatedString function in the editor below.  It should return an integer representing the number of occurrences of a in the prefix of length [expression] in the infinitely repeating string.  

repeatedString has the following parameter(s):  


s: a string to repeat  
n: the number of characters to consider  

----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 350

using namespace std;

const int INF = 1e9;
const int N = 531;

string st;
long long n;
long long res;

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);

	cin >> st;
	cin >> n;

	long long ful = n / st.size();
	int rem = n%st.size();
	for (int i = 0; i < st.size(); i++)
	{
		if (st[i] == 'a')
		{
			res += ful + (i < rem);
		}
	}
	cout << res << endl;

	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.47
easy
----------
PROBLEM STATEMENT:
Emma is playing a new mobile game that starts with consecutively numbered clouds.  Some of the clouds are thunderheads and others are cumulus.  She can jump on any cumulus cloud having a number that is equal to the number of the current cloud plus [expression].  She must avoid the thunderheads.  Determine the minimum number of jumps it will take Emma to jump from her starting postion to the last cloud.  It is always possible to win the game.  

For each game, Emma will get an array of clouds numbered [expression].

Function Description  

Complete the jumpingOnClouds function in the editor below.  It should return the minimum number of jumps required, as an integer.  

jumpingOnClouds has the following parameter(s):  


c: an array of binary integers  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;


int main(){
    int n;
    cin >> n;
    vector<int> c(n);
    for(int c_i = 0;c_i < n;c_i++){
       cin >> c[c_i];
    }
    vector<int>d(n, 10000);
    d[0] = 0;
    for (int i = 0; i < n; ++i) {
        if (c[i] == 1) continue;
        if (i + 1 < n && c[i + 1] == 0) {
            d[i + 1] = min(d[i + 1], d[i] + 1);
        }
        if (i + 2 < n && c[i + 2] == 0) {
            d[i + 2] = min(d[i + 2], d[i] + 1);
        }
    }
    cout << d[n - 1] << endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.48
easy
----------
PROBLEM STATEMENT:
Karl has an array of integers.  He wants to reduce the array until all remaining elements are equal.  Determine the minimum number of elements to delete to reach his goal.

For example, if his array is [expression].

Function Description  

Complete the equalizeArray function in the editor below. It must return an integer that denotes the minimum number of deletions required.  

equalizeArray has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 350

using namespace std;

const int INF = 1e9;
const int N = 100031;

int n, cnt[N], ar[N];
int ans;

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);

	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> ar[i];
		cnt[ar[i]]++;
		ans = max(ans, cnt[ar[i]]);
	}
	cout << n - ans << endl;

	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.49
medium
----------
PROBLEM STATEMENT:
You will be given a square chess board with one queen and a number of obstacles placed on it.  Determine how many squares the queen can attack.  

A queen is standing on an [expression], where the square is located.

The queen is standing at position [expression]: 



There are obstacles on the chessboard, each preventing the queen from attacking any square beyond it on that path. For example, an obstacle at location [expression]:



Given the queen's position and the locations of all the obstacles, find and print the number of squares the queen can attack from her position at [expression] such squares.

Function Description  

Complete the queensAttack function in the editor below.  It should return an integer that describes the number of squares the queen can attack.  

queensAttack has the following parameters: 
- n: an integer, the number of rows and columns in the board 
- k: an integer, the number of obstacles on the board 
- r_q: integer, the row number of the queen's position 
- c_q: integer, the column number of the queen's position 
- obstacles: a two dimensional array of integers where each element is an array of [expression] integers, the row and column of an obstacle  
----------
TOP SOLUTION:
----------
#include <algorithm>
#include <cassert>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <iostream>
#include <map>
#include <memory>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

using namespace std;

// DID YOU FIX GLOBAL STATE

typedef long long ll;
typedef pair<int, int> pii;

const double PI = 2 * acos(0);
const int MOD = 1000000007;
const int HASH = 3137;

int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};

void solve() {
  int n;
  int k;
  scanf("%d%d", &n, &k);
  int x, y;
  scanf("%d%d", &x, &y);
  set<pii> bad;
  while(k--) {
    int xx, yy;
    scanf("%d%d", &xx, &yy);
    bad.insert(pii(xx, yy));
  }
  set<pii> ret;
  for(int k = 0; k < 8; k++) {
    int nx = x + dx[k];
    int ny = y + dy[k];
    while(true) {
      if(min(nx, ny) < 1 || max(nx, ny) > n || bad.count(pii(nx, ny))) {
        break;
      }
      ret.insert(pii(nx, ny));
      nx += dx[k];
      ny += dy[k];
    }
  }
  printf("%d\n", ret.size());
}

int main() {
  solve();
  return 0;
}

----------
====================
----------
ALGORITHMS.50
easy
----------
PROBLEM STATEMENT:
There are a number of people who will be attending ACM-ICPC World Finals. Each of them may be well versed in a number of topics. Given a list of topics known by each attendee, you must determine the maximum number of topics a 2-person team can know. Also find out how many ways a team can be formed to know that many topics.  Lists will be in the form of bit strings, where each string represents an attendee and each position in that string represents a field of knowledge, 1 if its a known field or 0 if not.

For example, given three attendees' data as follows:

10101
11110
00010


These are all possible teams that can be formed:

Members Subjects
(1,2)   [1,2,3,4,5]
(1,3)   [1,3,4,5]
(2,3)   [1,2,3,4]


In this case, the first team will know all 5 subjects.  They are the only team that can be created knowing that many subjects.

Function Description  

Complete the acmTeam function in the editor below.  It should return an integer array with two elements: the maximum number of topics any team can know and the number of teams that can be formed that know that maximum number of topics.  

acmTeam has the following parameter(s):  


topic: a string of binary digits  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n, m, cnt = 0, max_tpc = 0, temp_cnt = 0;
    cin>>n>>m;
    string s[1005];
    for( int i = 0; i < n; i++ )    cin>>s[i];

    for( int i = 0; i < n; i++ )
        for( int j = i + 1; j < n; j++ ){
            temp_cnt = 0;

            for( int k = 0; k < m; k++ )
                if(  s[i][k] == '1' || s[j][k] == '1' ) temp_cnt++;

           if( temp_cnt == max_tpc ){
                cnt++;
                continue;
            }
            
            if( temp_cnt > max_tpc ){
                max_tpc = temp_cnt;
                cnt = 1;
                //cout<<" i :"<<i<<" j: "<<j<<" cnt: "<<max_tpc;
            }

            
        }

    cout<<max_tpc<<endl<<cnt<<endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.51
easy
----------
PROBLEM STATEMENT:
Taum is planning to celebrate the birthday of his friend, Diksha. There are two types of gifts that Diksha wants from Taum: one is black and the other is white. To make her happy, Taum has to buy [expression] white gifts. 


The cost  of each black gift is [expression] units.  
The cost of every white gift is [expression] units.  
The cost of converting each black gift into white gift or vice versa is [expression] units.  


Help Taum by deducing the minimum amount he needs to spend on Diksha's gifts.  

For example, if Taum wants to buy [expression].  

Function Description  

Complete the function taumBday in the editor below.  It should return the minimal cost of obtaining the desired gifts.  

taumBday has the following parameter(s):  


b: the number of black gifts  
w: the number of white gifts  
bc: the cost of a black gift  
wc: the cost of a white gift  
z: the cost to convert one color gift to the other color  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
  int cases;
  scanf("%d", &cases);
  while (cases--) {
    int B, W, X, Y, Z;
    scanf("%d %d %d %d %d", &B, &W, &X, &Y, &Z);
    long long res = (long long)B * X + (long long)W * Y;
    res = min(res, (long long)B * X + (long long)W * (X + Z));
    res = min(res, (long long)B * (Y + Z) + (long long)W * Y);
    printf("%lld\n", res);
  }
  return 0;
}

----------
====================
----------
ALGORITHMS.52
medium
----------
PROBLEM STATEMENT:
David has several containers, each with a number of balls in it.  He has just enough containers to sort each type of ball he has into its own container.  David wants to sort the balls using his sort method.

As an example, David has [expression]:



In a single operation, David can swap two balls located in different containers.

The diagram below depicts a single swap operation:



David wants to perform some number of swap operations such that:


Each container contains only balls of the same type.
No two balls of the same type are located in different containers.


You must perform [expression]. For each query, print Possible on a new line if David can satisfy the conditions above for the given matrix.  Otherwise, print Impossible.  

Function Description  

Complete the organizingContainers function in the editor below.  It should return a string, either Possible or Impossible.  

organizingContainers has the following parameter(s):  


containter: a two dimensional array of integers that represent the number of balls of each color in each container  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;


int main(){
    int q;
    cin >> q;
    for(int a0 = 0; a0 < q; a0++){
        int n;
        cin >> n;
        vector< vector<int> > M(n,vector<int>(n));
        long long totalIn[101]={0},totalOf[100]={0};
        for(int M_i = 0;M_i < n;M_i++){
           for(int M_j = 0;M_j < n;M_j++){
              cin >> M[M_i][M_j];
               totalIn[M_i]+=M[M_i][M_j];
               totalOf[M_j]+=M[M_i][M_j];
           }
        }
        sort(totalIn,totalIn+100);
        sort(totalOf,totalOf+100);
        int i;
        for(i=0;i<100;i++)
            {
            if(totalIn[i]!=totalOf[i])
                break;
        }
        if(i==100)
            cout<<"Possible"<<endl;
        else
            cout<<"Impossible"<<endl;
        // your code goes here
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.53
medium
----------
PROBLEM STATEMENT:
An English text needs to be encrypted using the following encryption scheme. 
First, the spaces are removed from the text. Let [expression] be the length of this text. 
Then, characters are written into a grid, whose rows and columns have the following constraints:

[expression] 

For example, the sentence [expression], so it is written in the form of a grid with 7 rows and 8 columns. 

ifmanwas  
meanttos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  
tayonthe  
groundgo  
dwouldha  
vegivenu  
sroots



Ensure that [expression]   
If multiple grids satisfy the above conditions, choose the one with the minimum area, i.e. [expression].  


The encoded message is obtained by displaying the characters in a column, inserting a space, and then displaying the next column and inserting a space, and so on. For example, the encoded message for the above rectangle is:  

imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn sseoau  

You will be given a message to encode and print.

Function Description  

Complete the encryption function in the editor below.  It should return a single string composed as described.  

encryption has the following parameter(s):  


s: a string to encrypt  

----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include <cstring>
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

#define MAXN 1000
char str[MAXN];
char res[MAXN][MAXN];
int gr,gc;
int r,c;

int main(){
   scanf("%s",str);
   int len = strlen(str); int DIFF = 1<<20; int AREA = 1<<20;
   for(int i=1; i<=100; ++i) {
     if(i*i>=len) {
         r = i; c = i; break;
     }     
     if(i*(i+1)>=len){
         r = i; c = i+1; break;
     }
   }
   int id = 0;
   for(int i=0; i<MAXN; ++i) for(int j=0; j<MAXN; ++j) res[i][j] = '\0';
   for(int i=0; i<r; ++i) for(int j=0; j<c; ++j) res[i][j] = str[id++];
   for(int i=0; i<c; ++i) {
      for(int j=0; res[j][i]!='\0'; ++j) printf("%c",res[j][i]);
      printf(" ");
   } 
   
   return 0;
}

----------
====================
----------
ALGORITHMS.54
medium
----------
PROBLEM STATEMENT:
Lexicographical order is often known as alphabetical order when dealing with strings.  A string is greater than another string if it comes later in a lexicographically sorted list.

Given a word, create a new word by swapping some or all of its characters.  This new word must meet two criteria:


It must be greater than the original word
It must be the smallest word that meets the first condition


For example, given the word [expression].  

Complete the function biggerIsGreater below to create and return the new string meeting the criteria.  If it is not possible, return no answer.

Function Description  

Complete the biggerIsGreater function in the editor below.  It should return the smallest lexicographically higher string possible from the given string or no answer.  

biggerIsGreater has the following parameter(s):  


w: a string

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

 string s;

int main() {
    int tc;
    scanf("%d", &tc);
    while (tc--) {
        cin >> s;
        if (next_permutation(s.begin(), s.end())) printf("%s\n", s.c_str());
        else printf("no answer\n");
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.55
easy
----------
PROBLEM STATEMENT:
A modified Kaprekar number is a positive whole number with a special property.  If you square it, then split the number into two integers and sum those integers, you have the same value you started with.

Consider a positive whole number [expression].

For example, if [expression]. 

Note: r may have leading zeros.  

Here's an explanation from Wikipedia about the ORIGINAL Kaprekar Number (spot the difference!):  


  In mathematics, a Kaprekar number for a given base is a non-negative integer, the representation of whose square in that base can be split into two parts that add up to the original number again. For instance, 45 is a Kaprekar number, because 45² = 2025 and 20+25 = 45.


Given two positive integers [expression], inclusive.

Function Description  

Complete the kaprekarNumbers function in the editor below.  It should print the list of modified Kaprekar numbers in ascending order.  

kaprekarNumbers has the following parameter(s):  


p: an integer   
q: an integer   

----------
TOP SOLUTION:
----------
#include <functional>
#include <algorithm>
#include <iostream>
#include <climits>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <numeric>
#include <cstring>
#include <cassert>
#include <cstdio>
#include <string>
#include <vector>
#include <bitset>
#include <queue>
#include <stack>
#include <cmath>
#include <ctime>
#include <list>
#include <set>
#include <map>

using namespace std;

typedef long long        LL;
typedef pair<int, int>   pii;
typedef pair<int, pii>   piii;
typedef vector<int>      vi;
typedef vector<pii>      vii;
typedef vector<piii>     viii;

#ifdef _WIN32
#define getchar_unlocked getchar
#endif
inline void inpint( int &n ) {
  n=0; register int ch = getchar_unlocked(); bool sign = 0;
  while(ch < 48 || ch > 57) { if(ch == '-') sign = 1; ch = getchar_unlocked(); }
  while(ch >= 48 && ch <= 57) { n = (n << 3) + (n << 1) + ch - 48, ch = getchar_unlocked(); }
  if(sign) n = -n;
}

inline int sqr(int x){return x * x;}
inline int cube(int x){return x * x * x;}
inline LL sqrLL(LL x){return x * x;}
inline LL cubeLL(LL x){return x * x * x;}

const LL LLINF      = 9223372036854775807LL;
const LL LLINF17    = 100000000000000000LL;
const int INF       = 2147483647;
const int INF9      = 1000000000;
const int MOD       = 1000000007;
const double eps    = 1e-7;
const double PI     = acos(-1.0);

#define FOR(a,b,c)   for (int (a)=(b); (a)<(c); (a)++)
#define FORN(a,b,c)  for (int (a)=(b); (a)<=(c); (a)++)
#define FORD(a,b,c)  for (int (a)=(b); (a)>=(c); (a)--)
#define REP(i,n)     FOR(i,0,n)
#define REPN(i,n)    FORN(i,1,n)
#define REPD(i,n)    FORD(i,n,1)

#define RESET(a,b)   memset(a,b,sizeof(a)) 
#define SYNC         ios_base::sync_with_stdio(0);
#define SIZE(a)      (int)(a.size())
#define MIN(a,b)     (a) = min((a),(b))
#define MAX(a,b)     (a) = max((a),(b))
#define ALL(a)       a.begin(),a.end()
#define RALL(a)      a.rbegin(),a.rend()
#define SIZE(a)      (int)(a.size())
#define LEN(a)       (int)(a.length())

#define fi           first
#define se           second
#define pb           push_back
#define mp           make_pair

int dr[] = {1,0,-1,0,-1,1,1,-1};
int dc[] = {0,-1,0,1,1,1,-1,-1};
int p, q;
inline int go(int z) {
  int ans = 0;
  while (z) {
    ans++;
    z /= 10;
  } return ans;
}
int main(){
  int ans = 0;
  cin >> p >> q;
  bool fir = true;
  for (int z = p; z <= q; z++) {
    int cnt = go(z);

    LL lol = sqrLL((LL)(z));

    vi v;
    while (lol) {
      v.pb(lol % 10);
      lol /= 10;
    }

    vi v1, v2;
    int half = cnt;
    int val1 = 0, val2 = 0;
    REP(i,half) {
      v1.pb(v[i]);
    }
    FOR(i,half,SIZE(v)) {
      v2.pb(v[i]);
    }

    while(SIZE(v1)) {
      val1 = val1 * 10 + v1.back();
      v1.pop_back();
    }

    while(SIZE(v2)) {
      val2 = val2 * 10 + v2.back();
      v2.pop_back();
    }

    if (val1 + val2 == z) {
      // cout << val1 << " " << val2 << endl;
      if (!fir) printf(" ");
      else fir = false;
      printf("%d",z);
      ans++;
    }
  }
  if(!ans) puts("INVALID RANGE");
  puts("");

  return 0;
}
----------
====================
----------
ALGORITHMS.56
easy
----------
PROBLEM STATEMENT:
Given a sequence of integers [expression] is beautiful if:


[expression]
[expression]


Given an increasing sequenc of integers and the value of [expression], count the number of beautiful triplets in the sequence.

For example, the sequence [expression].  

Function Description  

Complete the beautifulTriplets function in the editor below.  It must return an integer that represents the number of beautiful triplets in the sequence.  

beautifulTriplets has the following parameters:  


d: an integer  
arr: an array of integers, sorted ascending  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstring>
#include <set>
#include <map>
#include <list>
#include <queue>
#include <stack>
#include <bitset>
#define _USE_MATH_DEFINES
#include <math.h>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <assert.h>
using namespace std;

void smain();
int main(){
#ifdef TASK
    freopen(TASK".in","rt",stdin);
    const clock_t start = clock();
#endif
    smain();
#ifdef TASK
    cerr << "\nTotal Execution Time: " << float( clock () - start ) /  CLOCKS_PER_SEC << endl;
#endif
    return 0;
}

#ifndef M_PI
#define M_PI 3.14159265358979311599796346854418516
#endif
#define forn(i,n) for (int i=0;i<n;i++)
#define rforn(i,n) for (int i=n-1;i>=0;i--)
#define int long long
#define LL __int128
#define mp(a,b) make_pair(a,b)
#define INF 2305843009213693951LL
#define MOD 1000000007
#define EPS 1E-6
#define N 200001
/* --------- END TEMPLATE CODE --------- */
int n, d;
int a[N];


void smain() {
    for (; cin >> n >> d; ) {
        forn(i, n) cin >> a[i];
        int res = 0;
        map<int, int> l, r;
        forn(i, n) r[a[i]] += 1;
        forn(i, n) {
            r[a[i]] -= 1;
            res += l[a[i]-d] * r[a[i]+d];
            l[a[i]] += 1;
        }
        cout << res << '\n';
    }
}

----------
====================
----------
ALGORITHMS.57
easy
----------
PROBLEM STATEMENT:
We define the distance between two array values as the number of indices between the two values.  Given [expression].

For example, if [expression].

Function Description  

Complete the minimumDistances function in the editor below.  It should return the minimum distance between any two matching elements.  

minimumDistances has the following parameter(s):  


a: an array of integers  

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;
#define FOR(i,a,b) for(int i = (a); i <= (b); ++i)
#define FORD(i,a,b) for(int i = (a); i >= (b); --i)
#define RI(i,n) FOR(i,1,(n))
#define REP(i,n) FOR(i,0,(n)-1)
#define mini(a,b) a=min(a,b)
#define maxi(a,b) a=max(a,b)
#define mp make_pair
#define pb push_back
#define st first
#define nd second
#define sz(w) (int) w.size()
typedef vector<int> vi;
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
const int inf = 1e9 + 5;
const int nax = 1e6 + 5;

int t[nax];

int main() {
	int n;
	scanf("%d", &n);
	int ans = inf;
	REP(i, n) scanf("%d", &t[i]);
	REP(i, n) REP(j, i) if(t[i] == t[j]) mini(ans, abs(i-j));
	if(ans == inf) ans = -1;
	printf("%d\n", ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.58
easy
----------
PROBLEM STATEMENT:
You wish to buy video games from the famous online video game store Mist.

Usually, all games are sold at the same price, [expression] dollars each.

For example, if [expression] games you buy, in order:

[expression]

You have [expression] dollars in your Mist wallet. How many games can you buy during the Halloween Sale?
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int p, d, m, s;
    cin >> p >> d >> m >> s;
    int nr = 0;
    while(p <= s){
        s -= p;
        ++nr;
        p -= d;
        if(p < m) p = m;
    }
    cout << nr << endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.59
medium
----------
PROBLEM STATEMENT:
Given the time in numerals we may convert it into words, as shown below:  

[expression]

At [expression] use to.  Note the space between the apostrophe and clock in o' clock.  Write a program which prints the time in words for the input given in the format described.  

Function Description  

Complete the timeInWords function in the editor below.  It should return a time string as described.  

timeInWords has the following parameter(s):  


h: an integer representing hour of the day  
m: an integer representing minutes after the hour   

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

string words[30] = {string("one"),string("two"),string("three"),string("four"),string("five"),string("six"),string("seven"),string("eight"),string("nine"),string("ten"),string("eleven"),string("twelve"),string("thirteen"),string("fourteen"),string("fifteen"),string("sixteen"),string("seventeen"),string("eighteen"),string("nineteen"),string("twenty"),string("twenty one"),string("twenty two"),string("twenty three"),string("twenty four"),string("twenty five"),string("twenty six"),string("twenty seven"),string("twenty eight"),string("twenty nine")};


int main() {
    int H,M;
    cin >> H >> M;
    if (M==0) {
        printf("%s o' clock\n",words[H-1].c_str());
    } else if (M==1) {
        printf("one minute past %s\n",words[H-1].c_str());
    } else if (M==15) {
        printf("quarter past %s\n",words[H-1].c_str());
    } else if (M<30) {
        printf("%s minutes past %s\n",words[M-1].c_str(),words[H-1].c_str());
    } else if (M==30) {
        printf("half past %s\n",words[H-1].c_str());
    } else if (M==45) {
        printf("quarter to %s\n",words[H%12].c_str());
    } else if (M==59) {
        printf("one minute to %s\n",words[H%12].c_str());
    } else {
        printf("%s minutes to %s\n",words[60-M-1].c_str(),words[H%12].c_str());
    }
    
    return 0;
}

----------
====================
----------
ALGORITHMS.60
easy
----------
PROBLEM STATEMENT:
Little Bobby loves chocolate.  He frequently goes to his favorite [expression] store, Penny Auntie, to buy them.  They are having a promotion at Penny Auntie.  If Bobby saves enough wrappers, he can turn them in for a free chocolate.  

For example, Bobby has [expression] bars.    

Function Description   

Complete the chocolateFeast function in the editor below.  It must return the number of chocolates Bobby can eat after taking full advantage of the promotion.

chocolateFeast has the following parameter(s):  


n: an integer representing Bobby's initial amount of money  
c: an integer representing the cost of a chocolate bar  
m: an integer representing the number of wrappers he can turn in for a free bar  


Note: Little Bobby will always turn in his wrappers if he has enough to get a free chocolate.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int t,n,c,m;
    cin>>t;
    while(t--){
        cin>>n>>c>>m;
        int ans=0;
        ans+=n/c;
        int x=n/c;
        while(x>=m){
            ans+=x/m;
            x=x/m+x%m;
        }
        cout<<ans<<endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.61
easy
----------
PROBLEM STATEMENT:
Calvin is driving his favorite vehicle on the 101 freeway. He notices that the check engine light of his vehicle is on, and he wants to service it immediately to avoid any risks. Luckily, a service lane runs parallel to the highway. The service lane varies in width along its length.



You will be given an array of widths at points along the road (indices), then a list of the indices of entry and exit points. Considering each entry and exit point pair, calculate the maximum size vehicle that can travel that segment of the service lane safely.

For example, there are [expression].  

Function Description  

Complete the serviceLane function in the editor below.  It should return an array of integers representing the maximum width vehicle that can pass through each segment of the highway described.  

serviceLane has the following parameter(s):  


n: an integer denoting the size of the [expression] array
cases: a two dimensional array of integers where each element is an array of two integers representing starting and ending indices for a segment to consider . 

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int n, t;
    cin >> n >> t;
    int width[n];
    for(int i = 0; i < n; i++) cin >> width[i];
    for(int qq = 0; qq < t; qq++){
        int i, j;
        cin >> i >> j;
        int m = 3;
        for(int k = i; k <= j; k++){
            m = min(m, width[k]);
        }
        cout << m << endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.62
easy
----------
PROBLEM STATEMENT:
Lisa just got a new math workbook.  A workbook contains exercise problems, grouped into chapters.  Lisa believes a problem to be special if its index (within a chapter) is the same as the page number where it's located.  The format of Lisa's book is as follows:


There are [expression].
The [expression].
Each page can hold up to [expression] problems.
Each new chapter starts on a new page, so a page will never contain problems from more than one chapter.
The page number indexing starts at [expression].


Given the details for Lisa's workbook, can you count its number of special problems?

For example, Lisa's workbook contains [expression] special problem in her workbook.

Note: See the diagram in the Explanation section for more details.  

Function Description  

Complete the workbook function in the editor below.  It should return an integer that represents the number of special problems in the workbook.  

workbook has the following parameter(s):  


n: an integer that denotes the number of chapters  
k: an integer that denotes the maximum number of problems per page  
arr: an array of integers that denote the number of problems in each chapter  

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

#define ll long long
#define ull unsigned ll

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(double *x){scanf("%lf",x);}
int reader(char c[]){int i,s=0;for(;;){mygc(i);if(i!=' '&&i!='\n'&&i!='\r'&&i!='\t'&&i!=EOF) break;}c[s++]=i;for(;;){mygc(i);if(i==' '||i=='\n'||i=='\r'||i=='\t'||i==EOF) break;c[s++]=i;}c[s]='\0';return s;}
template <class T, class S> void reader(T *x, S *y){reader(x);reader(y);}
template <class T, class S, class U> void reader(T *x, S *y, U *z){reader(x);reader(y);reader(z);}
template <class T, class S, class U, class V> void reader(T *x, S *y, U *z, V *w){reader(x);reader(y);reader(z);reader(w);}

void writer(int x, char c){int s=0,m=0;char f[10];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(ll x, char c){int s=0,m=0;char f[20];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(double x, char c){printf("%.15f",x);mypc(c);}
void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}
void writer(const char x[], char c){int i;for(i=0;x[i]!='\0';i++)mypc(x[i]);mypc(c);}
template<class T> void writerLn(T x){writer(x,'\n');}
template<class T, class S> void writerLn(T x, S y){writer(x,' ');writer(y,'\n');}
template<class T, class S, class U> void writerLn(T x, S y, U z){writer(x,' ');writer(y,' ');writer(z,'\n');}
template<class T> void writerArr(T x[], int n){int i;if(!n){mypc('\n');return;}rep(i,n-1)writer(x[i],' ');writer(x[n-1],'\n');}

char memarr[17000000]; void *mem = memarr;
#define MD 1000000007

int N, K, T[100];

int main(){
  int i, j, k;
  int now = 1;
  int res = 0;

  reader(&N,&K);
  rep(i,N) reader(T+i);

  rep(i,N){
    rep(j,T[i]){
      if(now == j+1) res++;
      if( (j+1)%K==0 || j==T[i]-1 ) now++;
    }
  }

  writerLn(res);

  return 0;
}

----------
====================
----------
ALGORITHMS.63
easy
----------
PROBLEM STATEMENT:
Flatland is a country with a number of cities, some of which have space stations.  Cities are numbered consecutively and each has a road of [expression] length connecting it to the next city.  It is not a circular route, so the first city doesn't connect with the last city.  Determine the maximum distance from any city to it's nearest space station.

For example, there are [expression].

Function Description  

Complete the flatlandSpaceStations function in the editor below.  It should return an integer that represents the maximum distance any city is from a space station.  

flatlandSpaceStations has the following parameter(s):  


n: the number of cities  
c: an integer array that contains the indices of cities with a space station, [expression]-based indexing  

----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

int main() {
	int n; int m;
	while(~scanf("%d%d", &n, &m)) {
		vector<bool> ok(n);
		for(int i = 0; i < m; ++ i) {
			int c;
			scanf("%d", &c);
			ok[c] = true;
		}
		vi dist(n, INF);
		int p = -INF;
		rep(i, n) {
			if(ok[i]) p = i;
			amin(dist[i], i - p);
		}
		p = INF;
		for(int i = n - 1; i >= 0; -- i) {
			if(ok[i]) p = i;
			amin(dist[i], p - i);
		}
		int ans = *max_element(all(dist));
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.64
easy
----------
PROBLEM STATEMENT:
You are the benevolent ruler of Rankhacker Castle, and today you're distributing bread.  Your subjects are in a line, and some of them already have some loaves.  Times are hard and your castle's food stocks are dwindling, so you must distribute as few loaves as possible according to the following rules:


Every time you give a loaf of bread to some person [expression]).    
After all the bread is distributed, each person must have an even number of loaves.


Given the number of loaves already held by each citizen, find and print the minimum number of loaves you must distribute to satisfy the two rules above. If this is not possible, print NO.

For example, the people in line have loaves [expression] loaves.  

Function Description  

Complete the fairRations function in the editor below.  It should return an integer that represents the minimum number of loaves required.  

fairRations has the following parameter(s):  


B: an array of integers that represent the number of loaves each persons starts with . 

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

#define pb push_back
#define mp make_pair
#define REP(i, n) for (int i = 0; i < (int)(n); ++i)
typedef long long LL;
typedef pair<int, int> PII;

int n;
int a[1111];

int main() {
    scanf("%d", &n);
    REP(i, n) scanf("%d", a + i);
    int ans = 0;
    REP(i, n - 1) if (a[i] % 2 == 1) {
        ++a[i];
        ++a[i + 1];
        ans += 2;
    }
    if (a[n - 1] % 2 == 1) {
        printf("NO\n");
        return 0;
    }
    printf("%d\n", ans);
    return 0;
}

----------
====================
----------
ALGORITHMS.65
easy
----------
PROBLEM STATEMENT:
You are given a square map as a matrix of integer strings. Each cell of the map has a value denoting its depth. We will call a cell of the map a cavity if and only if this cell is not on the border of the map and each cell adjacent to it has strictly smaller depth. Two cells are adjacent if they have a common side, or edge.

Find all the cavities on the map and replace their depths with the uppercase character X.  

For example, given a matrix:

989
191
111


You should return:

989
1X1
111


The center cell was deeper than those on its edges: [8,1,1,1].  The deep cells in the top two corners don't share an edge with the center cell.  

Function Description  

Complete the cavityMap function in the editor below.  It should return an array of strings, each representing a line of the completed map.  

cavityMap has the following parameter(s):  


grid: an array of strings, each representing a row of the grid  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

int N;
char grid[101][101];
char grid2[101][101];

int main()
{
    scanf("%d\n", &N);
    for(int i=0; i<N; i++)
        gets(grid[i]);
    memcpy(grid2, grid, sizeof grid2);
    for(int i=1; i<N-1; i++)
        for(int j=1; j<N-1; j++)
            if(grid[i][j]>grid[i+1][j])
            if(grid[i][j]>grid[i-1][j])
            if(grid[i][j]>grid[i][j+1])
            if(grid[i][j]>grid[i][j-1])
                grid2[i][j]='X';
    for(int i=0; i<N; i++)
        puts(grid2[i]);
    return 0;
}

----------
====================
----------
ALGORITHMS.66
easy
----------
PROBLEM STATEMENT:
Manasa is out on a hike with friends. She finds a trail of stones with numbers on them. She starts following the trail and notices that any two consecutive stones' numbers differ by one of two values.  Legend has it that there is a treasure trove at the end of the trail.  If Manasa can guess the value of the last stone, the treasure will be hers.

For example, assume she finds [expression] on its face. 

Compute all possible numbers that might occur on the last stone given a starting stone with a [expression] on it, a number of additional stones found, and the possible differences between consecutive stones.  Order the list ascending.

Function Description

Complete the stones function in the editor below.  It should return an array of integers representing all possible values of the last stone, sorted ascending.  

stones has the following parameter(s):  


n: an integer, the number of non-zero stones  
a: one possible integer difference  
b: another possible integer difference  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <set>

using namespace std;

int main() {
  int nTests = 0; cin >> nTests;
  while (nTests--) {
    int n = 0; int a = 0; int b = 0;
    cin >> n >> a >> b;
    set<int> s;
    for (int i = 0; i <= n - 1; ++i) {
      s.insert(i * a + (n - 1 - i) * b);
    }
    for (set<int>::iterator it = s.begin(); it != s.end(); ++it) {
      if (it != s.begin()) cout << " ";
      cout << *it;
    }
    cout << "\n";
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.67
medium
----------
PROBLEM STATEMENT:
Given a 2D array of digits or grid, try to find the occurrence of a given 2D pattern of digits. For example, consider the following grid:  

1234567890  
0987654321  
1111111111  
1111111111  
2222222222  


Assume we need to look for the following 2D pattern array:  

876543  
111111  
111111
  

The 2D pattern begins at the second row and the third column of the grid.  The pattern is said to be present in the grid.  

Function Description  

Complete the gridSearch function in the editor below.  It should return YES if the pattern exists in the grid, or NO otherwise.  

gridSearch has the following parameter(s):  


G: the grid to search, an array of strings  
P: the pattern to search for, an array of strings  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
using namespace std;
typedef unsigned int LL;

struct MatHash {
    typedef unsigned int LL;
    #define MAXN 1001
    #define MAXM 1001
    #define TIME 2
    static LL P[TIME], Q[TIME], MOD[TIME];
    static LL powerP[TIME][MAXN], powerQ[TIME][MAXM];

    int n, m;
    int mat[MAXN][MAXM];

    LL h[TIME][MAXN][MAXM];//???hash?

    static void init(int id) {
        powerP[id][0] = 1;
        for (int i = 1; i < MAXN; i++) {
            powerP[id][i] = (powerP[id][i - 1] * P[id]);
        }
        powerQ[id][0] = 1;
        for (int i = 1; i < MAXM; i++) {
            powerQ[id][i] = (powerQ[id][i - 1] * Q[id]);
        }
    }

    void inithash(int id) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {

                h[id][i][j] = (mat[i][j] + 3) * powerP[id][n - 1 - i] * powerQ[id][m - 1 - j];
                if (i) h[id][i][j] = (h[id][i][j] + h[id][i - 1][j]);
                if (j) h[id][i][j] = (h[id][i][j] + h[id][i][j - 1]);
                if (i && j) h[id][i][j] = (h[id][i][j] - h[id][i - 1][j - 1]);
            }
        }
    }

    LL gethash(int x1, int y1, int x2, int y2, int id) {
        LL ret = h[id][x2][y2];
        if (x1) ret = (ret - h[id][x1 - 1][y2]);
        if (y1) ret = (ret - h[id][x2][y1 - 1]);
        if (x1 && y1) ret = (ret + h[id][x1 - 1][y1 - 1]);
        ret = (ret * powerP[id][x1]);
        ret = (ret * powerQ[id][y1]);
        return ret;
    }

    LL resize(int x1, int y1, int x2, int y2, int id, int _n, int _m) {
        LL ret = gethash(x1, y1, x2, y2, id);
        ret = ret * powerP[id][_n - n] * powerQ[id][_m - m];
        return ret;
    }

    void input() {
        for (int i = 0; i < n; i++) {
            getchar();
            for (int j = 0; j < m; j++) {
                mat[i][j] = getchar() - '0';
            }
        }
    }
}A, B;

LL MatHash::P[TIME], MatHash::Q[TIME], MatHash::MOD[TIME];
LL MatHash::powerP[TIME][MAXN], MatHash::powerQ[TIME][MAXM];

int main() {
    MatHash::P[0] = 393241, MatHash::Q[0] = 784633, MatHash::MOD[0] = 805306457;
    MatHash::P[1] = 784633, MatHash::Q[1] = 111117, MatHash::MOD[1] = 402653189;
    for (int i = 0; i < TIME; i++) {
        MatHash::init(i);
    }
    int cases;
    scanf("%d", &cases);
    for (int T = 0; T < cases; T++) {
        scanf("%d %d", &A.n, &A.m);
        A.input();
        for (int i = 0; i < TIME; i++) {
            A.inithash(i);
        }
        scanf("%d %d", &B.n, &B.m);
        B.input();
        for (int i = 0; i < TIME; i++) {
            B.inithash(i);
        }
        bool yes = false;
        for (int id = 0; id < TIME; id++) {
            B.inithash(id);
            LL val = B.resize(0, 0, B.n - 1, B.m - 1, id, A.n, A.m);
            for (int i = B.n - 1; i < A.n; i++) {
                for (int j = B.m - 1; j < A.m; j++) {
                    if (A.gethash(i - B.n + 1, j - B.m + 1, i, j, id) == val) {
                        yes = true;
                        break;
                    }
                }
                if (yes) break;
            }
        }
        puts(yes ? "YES" : "NO");
    }
}

----------
====================
----------
ALGORITHMS.68
easy
----------
PROBLEM STATEMENT:
Happy Ladybugs is a board game having the following properties:


The board is represented by a string, [expression] cell of the board.

If [expression] cell of the board is empty.
If [expression].
String [expression] will not contain any other characters.
A ladybug is happy only when its left or right adjacent cell (i.e., [expression]) is occupied by another ladybug having the same color.
In a single move, you can move a ladybug from its current position to any empty cell. 



Given the values of [expression] games of Happy Ladybugs, determine if it's possible to make all the ladybugs happy. For each game, print YES on a new line if all the ladybugs can be made happy through some number of moves.  Otherwise, print NO. 
 
As an example, [expression] and all the ladybugs are happy.  

Function Description  

Complete the happyLadybugs function in the editor below.  It should return an array of strings, either 'YES' or 'NO', one for each test string.  

happyLadybugs has the following parameters:


b: an array of strings that represents the initial positions and colors of the ladybugs  

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <vector>
#include <string>
#include <queue>
#include <map>
#include <set>
#include <algorithm>
using namespace std;

#define REP(i, n) for (int i=0, ___=(n); i<___; ++i)
#define FOR(i, a, b) for (int i=(a), ___=(b); i<=___; ++i)
#define FORD(i, a, b) for (int i=(a), ___=(b); i>=___; --i)

int read() { int n; scanf("%d", &n); return n; }
long long readl() { long long n; scanf("%lld", &n); return n; }
double readd() { double d; scanf("%lf", &d); return d; }


///////////////////////////////////////
/// WITHOUT STL

// kopiec

#define HeapT int
#define heapLeft(i) (2*(i)+1)
#define heapRight(i) (2*(i)+2)
#define heapParent(i) (((i)-1)/2)

inline void swap(HeapT &a, HeapT &b) {
	HeapT t = a; a = b; b = t;
}

inline void heapDown(HeapT *h, int a, int n) {
	while (heapLeft(a) < n) {
		int b = heapLeft(a);
		if (b+1 < n && h[b+1] > h[b]) b++;
		if (h[b] <= h[a]) break;
		swap(h[a], h[b]);
		a = b;
	}
}

inline void heapUp(HeapT *h, int a) {
	while (a > 0) {
		int b = heapParent(a);
		if (h[a] > h[b]) {
			swap(h[a], h[b]);
			a = b;
		}
	}
}

void heapMake(HeapT *h, int n) {
	for (int a=heapParent(n-1); a>=0; --a)
		heapDown(h, a, n);
}

void heapSort(HeapT *h, int n) {
	heapMake(h, n);
	for (int a=n-1; a>0; --a) {
		swap(h[0], h[a]);
		heapDown(h, 0, a);
	}
}



///////////////////////////////////////

bool f() {
	int n = read();
	char s[111];
	scanf("%s", s);
	map<char, int> m;
	REP(i, n) m[s[i]]++;
	if (m.count('_') > 0) {
		FOR(c, 'A', 'Z') if (m[c] == 1) return false;
		return true;
	}
	REP(i, n) {
		bool ok = false;
		if (i-1 >= 0 && s[i-1] == s[i]) ok = true;
		if (s[i+1] == s[i]) ok = true;
		if (!ok) return false;
	}
	return true;
}

int main() {
	int t = read();
	while (t--) {
		printf("%s\n", f() ? "YES" : "NO");
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.69
easy
----------
PROBLEM STATEMENT:
Bob has a strange counter. At the first second, it displays the number [expression]. 

The counter counts down in cycles. In next second, the timer resets to [expression] in the first three cycles:



Find and print the value displayed by the counter at time [expression].  

Function Description  

Complete the strangeCounter function in the editor below.  It should return the integer value displayed by the counter at time [expression].  

strangeCounter has the following parameter(s):  


t: an integer  

----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1234567891
#define bsize 350

using namespace std;

const int INF = 1e9;
const int N = 200000;

long long n;

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);

	cin >> n;
	long long P = 3;
	while (n > P)
	{
		n -= P;
		P *= 2;
	}
	cout << P - n + 1 << endl;

	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.70
medium
----------
PROBLEM STATEMENT:
Madison, is a little girl who is fond of toys. Her friend Mason works in a toy manufacturing factory . Mason has a 2D board [expression]. 

Given the description of the board showing the values of [expression] and that the price of the toy is equal to the 3d surface area find the price of the toy. 


----------
TOP SOLUTION:
----------
#include <iostream>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>
#include <string>
#include <bitset>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <algorithm>
#include <sstream>
#include <stack>
#include <iomanip>
using namespace std;
#define pb push_back
#define mp make_pair
typedef pair<int,int> pii;
typedef long long ll;
typedef double ld;
typedef vector<int> vi;
#define fi first
#define se second
#define fe first
#define FO(x) {freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);}
#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}
#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}
#define es(x,e) (int e=fst[x];e;e=nxt[e])
#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])
#define SZ 666666
int h,w,a[555][555];
int main()
{
	cin>>h>>w;
	for(int i=1;i<=h;++i)
		for(int j=1;j<=w;++j)
			cin>>a[i][j];
	int s=h*w*2;
	for(int i=1;i<=h;++i)
		for(int j=1;j<=w+1;++j)
			s+=abs(a[i][j]-a[i][j-1]);
	for(int i=1;i<=h+1;++i)
		for(int j=1;j<=w;++j)
			s+=abs(a[i][j]-a[i-1][j]);
	cout<<s<<"\n";
}

----------
====================
----------
ALGORITHMS.71
medium
----------
PROBLEM STATEMENT:
We define [expression]-based indexing. 

[expression].

Given [expression].  If no absolute permutation exists, print -1.

For example, let [expression]:  

[expression]
[expression]
[expression]
[expression]
[expression]



Function Description  

Complete the absolutePermutation function in the editor below.  It should return an integer that represents the smallest lexicographically smallest permutation, or [expression] if there is none.  

absolutePermutation has the following parameter(s):  


n: the upper bound of natural numbers to consider, inclusive  
k: the integer difference between each element and its index

----------
TOP SOLUTION:
----------
#include <ios>
#include <iostream>
#include <set>

//1 2 3 4
//2 1 4 3

int arr[100005] = {};

int main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    std::set<int> s;
    int tc, n, k;
    bool fail;
    std::cin >> tc;
    while (tc--)
    {
        fail = false;
        s.clear();
        std::cin >> n >> k;
        for (int i = 0; i < n; i++)
            s.insert(i);
        for (int i = 0; i < n; i++)
        {
            if (s.find(i-k) != s.end())
            {
                arr[i] = i-k;
                s.erase(i-k);
            }
            else if (s.find(i+k) != s.end())
            {
                arr[i] = i+k;
                s.erase(i+k);
            }
            else
            {
                std::cout << "-1\n";
                fail = true;
                break;
            }
        }
        if (!fail)
        {
            for (int i = 0; i < n; i++)
            {
                if (i != 0) std::cout << ' ';
                std::cout << arr[i]+1;
            }
            std::cout << '\n';
        }
    }
}
----------
====================
----------
ALGORITHMS.72
medium
----------
PROBLEM STATEMENT:
Bomberman lives in a rectangular grid. Each cell in the grid either contains a bomb or nothing at all.

Each bomb can be planted in any cell of the grid but once planted, it will detonate after exactly 3 seconds. Once a bomb detonates, it's destroyed — along with anything in its four neighboring cells. This means that if a bomb detonates in cell [expression] are cleared. If there is a bomb in a neighboring cell, the neighboring bomb is destroyed without detonating, so there's no chain reaction.   

Bomberman is immune to bombs, so he can move freely throughout the grid. Here's what he does:


Initially, Bomberman arbitrarily plants bombs in some of the cells, the initial state.  
After one second, Bomberman does nothing.  
After one more second, Bomberman plants bombs in all cells without bombs, thus filling the whole grid with bombs.  No bombs detonate at this point.
After one more second, any bombs planted exactly three seconds ago will detonate. Here, Bomberman stands back and observes.
Bomberman then repeats steps 3 and 4 indefinitely.  


Note that during every second Bomberman plants bombs, the bombs are planted simultaneously (i.e., at the exact same moment), and any bombs planted at the same time will detonate at the same time.  

Given the initial configuration of the grid with the locations of Bomberman's first batch of planted bombs, determine the state of the grid after [expression] seconds.

For example, if the initial grid looks like:

[expression]
[expression]
[expression]



it looks the same after the first second.  After the second second, Bomberman has placed all his charges:

[expression]
[expression]
[expression]



At the third second, the bomb in the middle blows up, emptying all surrounding cells:

[expression]
[expression]
[expression]



Function Description  

Complete the bomberMan function in the editory below.  It should return an array of strings that represent the grid in its final state.  

bomberMan has the following parameter(s):


n: an integer, the number of seconds to simulate  
grid: an array of strings that represents the grid

----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 350

using namespace std;

const int INF = 1e9;
const int N = 100031;

int r, c, n;
int board[300][300];
int nboard[300][300];

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	//ios_base::sync_with_stdio(0);
	//cin.tie(0);
	
	cin >> r >> c >> n;

	for (int i = 1; i <= r; i++)
	{
		string st;
		cin >> st;
		for (int j = 1; j <= c; j++)
		{
			if (st[j - 1] == '.')
				board[i][j] = -1;
			else
				board[i][j] = 0;
		}
	}

	if (n > 1000)
	{
		int rem = n % 8;
		n = 1000 + rem;
	}

	for (int iter = 1; iter <= n; iter++)
	{
		if (iter==1)
			continue;
		if (iter % 2 == 0)
		{
			for (int i = 1; i <= r; i++)
			{
				for (int j = 1; j <= c; j++)
				{
					if (board[i][j] == -1)
						board[i][j] = iter;
				}
			}
		}
		if (iter % 2 == 1)
		{
			for (int i = 1; i <= r; i++)
			{
				for (int j = 1; j <= c; j++)
				{
					nboard[i][j] = board[i][j];
				}
			}
			for (int i = 1; i <= r; i++)
			{
				for (int j = 1; j <= c; j++)
				{
					if (board[i][j] == iter - 3)
					{
						nboard[i][j] = -1;
						for (int di = -1; di <= 1; di++)
						{
							for (int dj = -1; dj <= 1; dj++)
							{
								if (abs(di)+abs(dj)<=1)
									nboard[i + di][j + dj] = -1;
							}
						}
					}
				}
			}
			for (int i = 1; i <= r; i++)
			{
				for (int j = 1; j <= c; j++)
				{
					board[i][j] = nboard[i][j];
				}
			}
		}
	}

	for (int i = 1; i <= r; i++)
	{
		for (int j = 1; j <= c; j++)
		{
			if (board[i][j] == -1)
				cout << ".";
			else
				cout << "O";
		}
		cout << endl;
	}

	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.73
medium
----------
PROBLEM STATEMENT:
Ema built a quantum computer! Help her test its capabilities by solving the problem below.



Given a grid of size [expression].

A valid plus is defined here as the crossing of two segments (horizontal and vertical) of equal lengths. These lengths must be odd, and the middle cell of its horizontal segment must cross the middle cell of its vertical segment. 

In the diagram below, the blue pluses are valid and the orange ones are not valid.


Find the two largest valid pluses that can be drawn on [expression].

Note: The two pluses cannot overlap, and the product of their areas should be maximal.

Function Description  

Complete the twoPluses function in the editor below.  It should return an integer that represents the area of the two largest pluses.

twoPluses has the following parameter(s):  


grid: an array of strings where each string represents a row and each character of the string represents a column of that row  

----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

int main() {
	int N; int M;
	while(~scanf("%d%d", &N, &M)) {
		vector<string> a(N);
		rep(i, N) cin >> a[i];
		int ans = 0;
		rep(y0, N) rep(x0, M) rer(s0, 1, min({ y0 + 1, N - y0, x0 + 1, M - x0 })) {
			vector<vector<bool> > good(N, vector<bool>(M));
			rep(i, N) rep(j, M)
				good[i][j] = a[i][j] == 'G';
			bool ok = true;
			rer(d, -s0 + 1, s0 - 1) {
				ok &= good[y0 + d][x0];
				ok &= good[y0][x0 + d];
				good[y0 + d][x0] = good[y0][x0 + d] = false;
			}
			if(!ok) continue;
			rep(y1, N) rep(x1, M) {
				int maxs1 = min({ y1 + 1, N - y1, x1 + 1, M - x1 });
				int s1 = maxs1;
				rer(d, -maxs1 + 1, maxs1 - 1) {
					if(!good[y1 + d][x1] || !good[y1][x1 + d])
						amin(s1, abs(d) - 1);
				}
				if(s1 > 0)
					amax(ans, ((s0 - 1) * 4 + 1) * ((s1 - 1) * 4 + 1));
			}
		}
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.74
medium
----------
PROBLEM STATEMENT:
Larry has been given a permutation of a sequence of natural numbers incrementing from [expression] as an array.  He must determine whether the array can be sorted using the following operation any number of times:  


Choose any [expression]. 


For example, if [expression]:

[expression] 
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]

[expression]



On a new line for each test case, print YES if [expression] can be fully sorted.  Otherwise, print NO.  

Function Description  

Complete the larrysArray function in the editor below.  It must return a string, either YES or NO.  

larrysArray has the following parameter(s):  


A: an array of integers  

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

#define ll long long
#define ull unsigned ll

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(double *x){scanf("%lf",x);}
int reader(char c[]){int i,s=0;for(;;){mygc(i);if(i!=' '&&i!='\n'&&i!='\r'&&i!='\t'&&i!=EOF) break;}c[s++]=i;for(;;){mygc(i);if(i==' '||i=='\n'||i=='\r'||i=='\t'||i==EOF) break;c[s++]=i;}c[s]='\0';return s;}
template <class T, class S> void reader(T *x, S *y){reader(x);reader(y);}
template <class T, class S, class U> void reader(T *x, S *y, U *z){reader(x);reader(y);reader(z);}
template <class T, class S, class U, class V> void reader(T *x, S *y, U *z, V *w){reader(x);reader(y);reader(z);reader(w);}

void writer(int x, char c){int s=0,m=0;char f[10];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(ll x, char c){int s=0,m=0;char f[20];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(double x, char c){printf("%.15f",x);mypc(c);}
void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}
void writer(const char x[], char c){int i;for(i=0;x[i]!='\0';i++)mypc(x[i]);mypc(c);}
template<class T> void writerLn(T x){writer(x,'\n');}
template<class T, class S> void writerLn(T x, S y){writer(x,' ');writer(y,'\n');}
template<class T, class S, class U> void writerLn(T x, S y, U z){writer(x,' ');writer(y,' ');writer(z,'\n');}
template<class T> void writerArr(T x[], int n){int i;if(!n){mypc('\n');return;}rep(i,n-1)writer(x[i],' ');writer(x[n-1],'\n');}

char memarr[17000000]; void *mem = memarr;
#define MD 1000000007

int T, N, A[1000];

int main(){
  int i, j, k;
  int res;

  reader(&T);
  while(T--){
    reader(&N);
    rep(i,N) reader(A+i);
    res = 0;
    rep(i,N) REP(j,i+1,N) if(A[i] > A[j]) res++;
    if(res%2) writerLn("NO"); else writerLn("YES");
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.75
medium
----------
PROBLEM STATEMENT:
Given an array of integers, determine whether the array can be sorted in ascending order using only one of the following operations one time. 


Swap two elements.   
Reverse one sub-segment.  


Determine whether one, both or neither of the operations will complete the task.  If both work, choose swap. For instance, given an array [expression], or reverse them to sort the array.  Choose swap. The Output Format section below details requirements.  

Function Description  

Complete the almostSorted function in the editor below.  It should print the results and return nothing.  

almostSorted has the following parameter(s):  


arr:  an array of integers  

----------
TOP SOLUTION:
----------
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <algorithm>
#include <iostream>
using namespace std;

int N, v[100005], s[100005];

int main() {
    cin >> N;
    for(int i=0; i<N; i++){
        cin >> v[i];
        s[i] = v[i];
    }
    
    sort(s, s+N);    
    vector<int> diff;
    for(int i=0; i<N; i++)
        if(v[i] != s[i])
            diff.push_back(i);    
    
        
    if(diff.size() == 0){
        cout << "yes" << endl;
        return 0;
    }
        
    if(diff.size() == 2 && s[diff[0]] == v[diff[1]] && s[diff[1]] == v[diff[0]]){
        cout << "yes\nswap " << diff[0] + 1 << " " << diff[1] + 1 << endl;
        return 0;
    }

    reverse(v + diff[0], v + diff.back() + 1);
    bool good = true;
    for(int i=0; i<N; i++)
        good &= v[i] == s[i];
    
    if(good) cout << "yes\nreverse " << diff[0] + 1 << " " << diff.back() + 1 << endl;
    else cout << "no" << endl;    
    return 0;
}

----------
====================
----------
ALGORITHMS.76
hard
----------
PROBLEM STATEMENT:
You are given a 2D  matrix of dimension [expression] times and print the resultant matrix. Rotation should be in anti-clockwise direction.  

Rotation of a [expression] matrix is represented by the following figure. Note that in one rotation, you have to shift elements by one step only.



It is guaranteed that the minimum of m and n will be even.  

As an example rotate the Start matrix by 2:

Start         First           Second
 1 2 3 4        2  3  4  5      3  4  5  6
12 1 2 5  -   1  2  3  6 -   2  3  4  7
11 4 3 6      12  1  4  7       1  2  1  8
10 9 8 7      11 10  9  8     12 11 10  9


Function Description  

Complete the matrixRotation function in the editor below.  It should print the resultant 2D integer array and return nothing.  

matrixRotation has the following parameter(s):  


matrix: a 2D array of integers  
r: an integer that represents the rotation factor  

----------
TOP SOLUTION:
----------
//
//  main.cpp
//  MatrixRotation
//
//  Created by Satya Vivek on 6/29/15.
//  Copyright (c) 2015 Satya Vivek. All rights reserved.
//

#include <iostream>
#include <vector>

using namespace::std;

struct element{
    int row,col,value;
};

int countLength(int highC,int highR,int lowC,int lowR,vector <element> &v){
    
    int a = lowC,b = lowR,count=0;
    struct element e;
    e.row = a;
    e.col = b;
    v.push_back(e);
     do{
        count++;
        a++;
        e.row = a;
        e.col = b;
        v.push_back(e);
     }while (a<highR);
    do{
        count++;
        b++;
        e.row = a;
        e.col = b;
        v.push_back(e);
    }while (b<highC);
    do{
        count++;
        a--;
        e.row = a;
        e.col = b;
        v.push_back(e);
    }while (a>lowR);
     do{
        count++;
        b--;
         e.row = a;
         e.col = b;
         v.push_back(e);
     }while (b>lowC);
    return count;
}

void changeMatrix(int arr[][300],int highC,int lowC,int highR,int lowR,int r,int c,int k){
    
    vector<element> v;
    int len = countLength(highC,highR,lowC,lowR,v);
    k = k%len;
    v.pop_back();
    
    for (int i=0; i<v.size();i++) {
        int n = (i+k)%len;
        v[n].value = arr[v[i].row][v[i].col];
    }
    
    for (int i=0; i<v.size(); i++) {
        int r = v[i].row;
        int c = v[i].col;
        arr[r][c] = v[i].value;
    }
    
}

int main(int argc, const char * argv[]) {
    
    int r,c,k,arr[300][300];
    cin>>r>>c>>k;
    for (int i=0; i<r; i++) {
        for (int j=0; j<c; j++) {
            cin>>arr[i][j];
        }
    }
    int highC=c-1,highR=r-1,lowC=0,lowR=0;
    while (true) {
        
        if (highC-lowC<1||highR-lowR<1) {
            break;
        }
        else{
            changeMatrix(arr,highC,lowC,highR,lowR,r,c,k);
        }
        highC--;
        highR--;
        lowC++;
        lowR++;
    }
    for (int i=0; i<r; i++) {
        for (int j=0; j<c; j++) {
            cout<<arr[i][j]<<" ";
        }
        cout<<endl;
    }
}
----------
====================
----------
ALGORITHMS.77
easy
----------
PROBLEM STATEMENT:
Consider an array of numeric strings where each string is a positive number with anywhere from [expression] digits. Sort the array's elements in non-decreasing, or ascending order of their integer values and print each element of the sorted array on a new line.

Function Description  

Complete the bigSorting function in the editor below.  It should return the sorted string array.  

bigSorting has the following parameter(s):  


unsorted: an unsorted array of integers as strings  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int main(){
    int n;
    cin >> n;
    vector<string> unsorted(n);
    for(int unsorted_i = 0; unsorted_i < n; unsorted_i++){
       cin >> unsorted[unsorted_i];
    }
    sort(unsorted.begin(), unsorted.end(), [](const string& a, const string& b) {
        if (a.length() != b.length()) {
            return a.length() < b.length();
        }
        return a < b;
    });
    for (auto& s : unsorted) {
        cout << s << "\n";
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.78
easy
----------
PROBLEM STATEMENT:
Steve has a string of lowercase characters in range ascii[‘a’..’z’].  He wants to reduce the string to its shortest length by doing a series of operations.  In each operation he selects a pair of adjacent lowercase letters that match, and he deletes them.  For instance, the string aab could be shortened to b in one operation.  

Steve’s task is to delete as many characters as possible using this method and print the resulting string.  If the final string is empty, print Empty String

Function Description

Complete the superReducedString function in the editor below.  It should return the super reduced string or Empty String if the final string is empty.  

superReducedString has the following parameter(s):  


s: a string to reduce  

----------
TOP SOLUTION:
----------
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include<cstdio>
#include<numeric>
#include<cstring>
#include<ctime>
#include<cstdlib>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<list>
#include<cmath>
#include<bitset>
#include<cassert>
#include<queue>
#include<stack>
#include<deque>
#include<cassert>
using namespace std;
typedef long long ll;
typedef long double ld;
int main()
{
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	string s;
	cin >> s;
	vector<char>st;
	for (int i = 0; i < (int)s.length(); i++)
	{
		if (!st.empty() && st.back() == s[i])
		{
			st.pop_back();
		}
		else
		{
			st.push_back(s[i]);
		}
	}
	if (st.empty())
	{
		printf("Empty String\n");
	}
	else
	{
		for (int i = 0; i < (int)st.size(); i++)
		{
			printf("%c", st[i]);
		}
		printf("\n");
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.79
easy
----------
PROBLEM STATEMENT:
About Tutorial Challenges 
Many of the challenges on HackerRank are difficult and assume that you already know the relevant algorithms. These tutorial challenges are different. They break down algorithmic concepts into smaller challenges so that you can learn the algorithm by solving them.  They are intended for those who already know some programming, however. You could be a student majoring in computer science, a self-taught programmer, or an experienced developer who wants an active algorithms review.  Here's a great place to learn by doing!

The first series of challenges covers sorting. They are listed below:

Tutorial Challenges - Sorting  

Insertion Sort challenges


Insertion Sort 1 - Inserting
Insertion Sort 2 - Sorting
Correctness and loop invariant
Running Time of Algorithms


Quicksort challenges


Quicksort 1 - Partition
Quicksort 2 - Sorting
Quicksort In-place (advanced)
Running time of Quicksort


Counting sort challenges


Counting Sort 1 - Counting
Counting Sort 2 - Simple sort
Counting Sort 3 - Preparing
Full Counting Sort (advanced)


There will also be some challenges where you'll get to apply what you've learned using the completed algorithms.

About the Challenges 
Each challenge will describe a scenario and you will code a solution. As you progress through the challenges, you will learn some important concepts in algorithms. In each challenge, you will receive input on STDIN and you will need to print the correct output to STDOUT.  

There may be time limits that will force you to make your code efficient.  If you receive a "Terminated due to time out" message when you submit your solution, you'll need to reconsider your method.  If you want to test your code locally, each test case can be downloaded, inputs and expected results, using hackos.  You earn hackos as you solve challenges, and you can spend them on these tests.

For many challenges, helper methods (like an array) will be provided for you to process the input into a useful format. You can use these methods to get started with your program, or you can write your own input methods if you want. Your code just needs to print the right output to each test case. 

Sample Challenge 
This is a simple challenge to get things started. Given a sorted array ([expression] in the array? 

For example, if [expression] for a zero-based index array.  

If you are going to use the provided code for I/O, this next section is for you.

Function Description

Complete the introTutorial function in the editor below.  It must return an integer representing the zero-based index of [expression].  

introTutorial has the following parameter(s):


arr: a sorted array of integers  
V: an integer to search for  


The next section describes the input format. You can often skip it, if you are using included methods or code stubs.

Input Format  

The first line contains an integer, [expression], a value to search for. 
The next line contains an integer, [expression].
The last line contains [expression].  

Output Format 
Output the index of [expression] in the array.

The next section describes the constraints and ranges of the input. You should check this section to know the range of the input.

Constraints  


[expression]   
[expression] 
It is guaranteed that [expression] exactly once.


This "sample" shows the first input test case. It is often useful to go through the sample to understand a challenge.

Sample Input 0

4
6
1 4 5 7 9 12


Sample Output 0

1


Explanation 0 
[expression] (see array definition under Input Format).
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
    int V, N;
    cin >> V >> N;
    int temp = 0;;
    for(int i = 0; i < N; i++){
        cin >> temp;
        if(temp == V){
            cout << i << endl;
            return 0;
        }
    }
    cout << -1 << endl;
    
    
    
    return 0;
}

----------
====================
----------
ALGORITHMS.80
easy
----------
PROBLEM STATEMENT:
Alice wrote a sequence of words in CamelCase as a string of letters, [expression], having the following properties:


It is a concatenation of one or more words consisting of English letters.
All letters in the first word are lowercase. 
For each of the subsequent words, the first letter is uppercase and rest of the letters are lowercase.


Given [expression] on a new line.

For example, [expression] words in the string.  

Function Description

Complete the camelcase function in the editor below.  It must return the integer number of words in the input string.  

camelcase has the following parameter(s):


s: the string to analyze  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;


int main(){
    string s;
    cin >> s;
    int t=1;
    for (int i=0;i<s.length();i++)
        if (isupper(s[i]))
        t++;
        cout<<t<<endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.81
easy
----------
PROBLEM STATEMENT:
Sorting 
One common task for computers is to sort data. For example, people might want to see all their files on a computer sorted by size. Since sorting is a simple problem with many different possible solutions, it is often used to introduce the study of algorithms. 

Insertion Sort 
These challenges will cover Insertion Sort, a simple and intuitive sorting algorithm. We will first start with a nearly sorted list.

Insert element into sorted list 
Given a sorted list with an unsorted number [expression] into the array so that it remains sorted?  

Since this is a learning exercise, it won't be the most efficient way of performing the insertion.  It will instead demonstrate the brute-force method in detail.   

Assume you are given the array [expression], insert the stored value at the current index and print the entire array.

The results of operations on the example array is:

Starting array: [expression] 
Store the value of [expression]
Do the tests and print interim results:

1 2 4 5 5
1 2 4 4 5
1 2 3 4 5


Function Description

Complete the insertionSort1 function in the editor below.  It should print the interim and final arrays, each on a new line.  

insertionSort1 has the following parameter(s):


n: an integer, the size of [expression]  
arr: an array of integers to sort  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
using namespace std;

/* Head ends here */

void insertionSort(vector <int>  ar) {
    int n = ar.size();
    if(n==0)
        return;
    if(n==1)
        cout<<ar[n-1]<<endl;
    int curr = ar[n-1];
    int i=n-2;
    while(i>=0){
        if(ar[i]>=curr){
            ar[i+1]=ar[i];
        }
        else{
            ar[i+1]=curr;
            i=-1;
        }
        for(int j=0;j<n;j++)
            cout<<ar[j];
        cout<<endl;
        if(i==0){
            ar[i]=curr;
            for(int j=0;j<n;j++)
                cout<<ar[j];
            cout<<endl;
        }
        i--;
    }

}


/* Tail starts here */
int main() {
   vector <int>  _ar;
   int _ar_size;
cin >> _ar_size;
for(int _ar_i=0; _ar_i<_ar_size; _ar_i++) {
   int _ar_tmp;
   cin >> _ar_tmp;
   _ar.push_back(_ar_tmp); 
}

insertionSort(_ar);
   
   return 0;
}
----------
====================
----------
ALGORITHMS.82
easy
----------
PROBLEM STATEMENT:
Louise joined a social networking site to stay in touch with her friends. The signup page required her to input a name and a password. However, the password must be strong. The website considers a password to be strong if it satisfies the following criteria:


Its length is at least [expression].  
It contains at least one digit.  
It contains at least one lowercase English character. 
It contains at least one uppercase English character. 
It contains at least one special character. The special characters are: !@#$%^&*()-+  


She typed a random string of length [expression] in the password field but wasn't sure if it was strong. Given the string she typed, can you find the minimum number of characters she must add to make her password strong?

Note: Here's the set of types of characters in a form you can paste in your solution:

[expression]
[expression]
[expression]
[expression]


----------
TOP SOLUTION:
----------
/**
 *    author:  tourist
 *    created: 02.11.2017 17:35:27       
**/
#include <bits/stdc++.h>

using namespace std;

int check(string s, string w) {
  for (char c : s) {
    if (w.find(c) != string::npos) {
      return 0;
    }
  }
  return 1;
}

int main() {
  int n;
  cin >> n;
  string s;
  cin >> s;
  string numbers = "0123456789";
  string lower_case = "abcdefghijklmnopqrstuvwxyz";
  string upper_case = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  string special_characters = "!@#$%^&*()-+";
  int ans = 0;
  ans += check(s, numbers);
  ans += check(s, lower_case);
  ans += check(s, upper_case);
  ans += check(s, special_characters);
  ans = max(ans, 6 - n);
  printf("%d\n", ans);
  return 0;
}

----------
====================
----------
ALGORITHMS.83
easy
----------
PROBLEM STATEMENT:
In this challenge, you will be given a string.  You must remove characters until the string is made up of any two alternating characters.  When you choose a character to remove, all instances of that character must be removed.  Your goal is to create the longest string possible that contains just two alternating letters.

As an example, consider the string abaacdabd.  If you delete the character a, you will be left with the string bcdbd.  Now, removing the character c leaves you with a valid string bdbd having a length of 4. Removing either b or d at any point would not result in a valid string.

Given a string [expression] instead.

Function Description

Complete the alternate function in the editor below.  It should return an integer that denotes the longest string that can be formed, or [expression] if it cannot be done.  

alternate has the following parameter(s):  


s: a string  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> ii;

int valid(string x) {
    const int n = x.size();
    for (int i = 1; i < n; ++i)
        if (x[i] == x[i-1])
            return false;
    return true;
}

int main() {
    int asd;
    cin>>asd;
    string s;
    cin>>s;
    int ans = 0;
    for (char a = 'a'; a <= 'z'; ++a)
    for (char b = 'a'; b <= 'z'; ++b)
    if (a != b)
    {
        if (s.find(a) == string::npos) continue;
        if (s.find(b) == string::npos) continue;
        string x;
        for (const char ch : s)
            if (ch == a || ch == b)
                x.push_back(ch);
        if (valid(x))
            ans = max(ans, (int)x.size());
    }
    printf("%d\n", ans);
}

----------
====================
----------
ALGORITHMS.84
easy
----------
PROBLEM STATEMENT:
In Insertion Sort Part 1, you inserted one element into an array at its correct sorted position. Using the same approach repeatedly, can you sort an entire array?

Guideline: You already can place an element into a sorted array. How can you use that code to build up a sorted array, one element at a time? Note that in the first step, when you consider an array with just the first element, it is already sorted since there's nothing to compare it to.

In this challenge, print the array after each iteration of the insertion sort, i.e., whenever the next element has been inserted at its correct position.  Since the array composed of just the first element is already sorted, begin printing after placing the second element.

For example, there are [expression].  Working from left to right, we get the following output:

[expression]3 4 7 5 6 2 1
3 4 7 5 6 2 1
3 4 5 7 6 2 1
3 4 5 6 7 2 1
2 3 4 5 6 7 1
1 2 3 4 5 6 7



Function Description

Complete the insertionSort2 function in the editor below.  At each iteration, it should print the array as space-separated integers on a separate line.  

insertionSort2 has the following parameter(s):  


n: an integer representing the length of the array [expression]  
arr: an array of integers  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
using namespace std;

/* Head ends here */

void insertionSort(vector <int>  ar) {
    int n = ar.size();
    for(int i=1;i<n;i++){
        int curr = ar[i];
        for(int j=i-1;j>=0;j--){
            if(ar[j]>curr){
                ar[j+1]=ar[j];
                if(j==0)
                    ar[j]=curr;
            }
            else{
                ar[j+1]=curr;
                j=-1;
            }
        }
        for(int t=0;t<n;t++)
            cout<<ar[t];
        cout<<endl;
    }
}


/* Tail starts here */
int main() {
    vector <int>  _ar;
    int _ar_size;
    cin >> _ar_size;
    for(int _ar_i=0; _ar_i<_ar_size; _ar_i++) {
        int _ar_tmp;
        cin >> _ar_tmp;
        _ar.push_back(_ar_tmp); 
    }
    insertionSort(_ar);
    return 0;
}
----------
====================
----------
ALGORITHMS.85
easy
----------
PROBLEM STATEMENT:
In the previous challenge, you wrote code to perform an Insertion Sort on an unsorted array. But how would you prove that the code is correct? I.e. how do you show that for any input your code will provide the right output?

Loop Invariant 
In computer science, you could prove it formally with a loop invariant, where you state that a desired property is maintained in your loop. Such a proof is broken down into the following parts:


Initialization: It is true (in a limited sense) before the loop runs.
Maintenance: If it's true before an iteration of a loop, it remains true before the next iteration.
Termination: It will terminate in a useful way once it is finished. 


Insertion Sort's Invariant 
Say, you have some InsertionSort code, where the outer loop goes through the whole array [expression]:

for(int i = 1; i < A.length; i++){
//insertion sort code


You could then state the following loop invariant:


  At the start of every iteration of the outer loop (indexed with [expression] consists of the original elements that were there, but in sorted order. 


To prove Insertion Sort is correct, you will then demonstrate it for the three stages:


Initialization - The subarray starts with the first element of the array, and it is (obviously) sorted to begin with.
Maintenance - Each iteration of the loop expands the subarray, but keeps the sorted property. An element [expression] is greater than all the elements to its left, so the array remains sorted. (In Insertion Sort 2 we saw this by printing the array each time an element was properly inserted.)  
Termination - The code will terminate after [expression] has reached the last element in the array, which means the sorted subarray has expanded to encompass the entire array. The array is now fully sorted.




You can often use a similar process to demonstrate the correctness of many algorithms. You can see these notes for more information.

Challenge

In the InsertionSort code below, there is an error. Can you fix it? Print the array only once, when it is fully sorted. 
----------
TOP SOLUTION:
----------
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <assert.h>
/* Head ends here */
void insertionSort(int ar_size, int *  ar) {    
    int i,j;
    int value;
    for(i=1;i<ar_size;i++)
    {
        value=ar[i];
        j=i-1;
        while(j>=0 && value<ar[j])
        {
            ar[j+1]=ar[j];
            j=j-1;
        }
        ar[j+1]=value;        
    }
   for(j=0;j<ar_size;j++)
        {
            printf("%d",ar[j]);
            printf(" ");
        }
}
/* Tail starts here */
int main(void) {
   
   int _ar_size;
scanf("%d", &_ar_size);
int _ar[_ar_size], _ar_i;
for(_ar_i = 0; _ar_i < _ar_size; _ar_i++) { 
   scanf("%d", &_ar[_ar_i]); 
}

insertionSort(_ar_size, _ar);
   
   return 0;
}
----------
====================
----------
ALGORITHMS.86
easy
----------
PROBLEM STATEMENT:
Julius Caesar protected his confidential information by encrypting it using a cipher. Caesar's cipher shifts each letter by a number of letters.  If the shift takes you past the end of the alphabet, just rotate back to the front of the alphabet.  In the case of a rotation by 3, w, x, y and z would map to z, a, b and c.

[expression]Original alphabet:      abcdefghijklmnopqrstuvwxyz
Alphabet rotated +3:    defghijklmnopqrstuvwxyzabc



For example, the given cleartext [expression].  

Note: The cipher only encrypts letters; symbols, such as -, remain unencrypted.  

Function Description  

Complete the caesarCipher function in the editor below.  It should return the encrypted string.  

caesarCipher has the following parameter(s):


s: a string in cleartext  
k: an integer, the alphabet rotation factor  

----------
TOP SOLUTION:
----------

#include <iostream>
#include <string>
using namespace std;


int main() {
    int N = 0, K = 0;
    string str, dummy;
    cin >> N; getline(cin, dummy);
    getline(cin, str);
    cin >> K;
    int len = str.length();
    for (int i = 0; i < len; ++i)
        {
        if (65 <= str[i] && str[i] <= 90)
            str[i] = char(65 + ((str[i] - 65) + K) % 26);
        else if (97 <= str[i] && str[i] <= 122)
            str[i] = char(97 + ((str[i] - 97) + K) % 26);
    }       
    cout << str << endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.87
easy
----------
PROBLEM STATEMENT:
Sami's spaceship crashed on Mars! She sends a series of SOS messages to Earth for help. 



Letters in some of the SOS messages are altered by cosmic radiation during transmission. Given the signal received by Earth as a string, [expression], determine how many letters of Sami's SOS have been changed by radiation.

For example, Earth receives SOSTOT.  Sami's original message was SOSSOS.  Two of the message characters were changed in transit.  

Function Description

Complete the marsExploration function in the editor below.  It should return an integer representing the number of letters changed during transmission.  

marsExploration has the following parameter(s):


s: the string as received on Earth  

----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

int main() {
	string S;
	while(cin >> S) {
		int ans = 0;
		rep(i, S.size())
			ans += S[i] != "SOS"[i % 3];
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.88
easy
----------
PROBLEM STATEMENT:
In a previous challenge you implemented the Insertion Sort algorithm. It is a simple sorting algorithm that works well with small or mostly sorted data. However, it takes a long time to sort large unsorted data. To see why, we will analyze its running time.

Running Time of Algorithms 
The running time of an algorithm for a specific input depends on the number of operations executed. The greater the number of operations, the longer the running time of an algorithm. We usually want to know how many operations an algorithm will execute in proportion to the size of its input, which we will call [expression].

What is the ratio of the running time of Insertion Sort to the size of the input? To answer this question, we need to examine the algorithm. 

Analysis of Insertion Sort 
For each element [expression] into the array. 

How long does all that shifting take?

In the best case, where the array was already sorted, no element will need to be moved, so the algorithm will just run through the array once and return the sorted array. The running time would be directly proportional to the size of the input, so we can say it will take [expression] time.

However, we usually focus on the worst-case running time (computer scientists are pretty pessimistic). The worst case for Insertion Sort occurs when the array is in reverse order. To insert each number, the algorithm will have to shift over that number to the beginning of the array. Sorting the entire array of [expression] time" algorithm.



What this means 
The running time of the algorithm against an array of [expression].  Insertion Sort can work well for small inputs or if you know the data is likely to be nearly sorted, like check numbers as they are received by a bank.  The running time becomes unreasonable for larger inputs. 



Challenge 
Can you modify your previous Insertion Sort implementation to keep track of the number of shifts it makes while sorting? The only thing you should print is the number of shifts made by the algorithm to completely sort the array. A shift occurs when an element's position changes in the array. Do not shift an element if it is not necessary.

Function Description

Complete the runningTime function in the editor below.  It should return an integer representing the number of shifts it will take to sort the given array.  

runningTime has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int insertionSortCount(vector <int>  ar) {
    int n = ar.size();
    int count=0;
    for(int i=1;i<n;i++){
        int curr = ar[i];
        for(int j=i-1;j>=0;j--){
            if(ar[j]>curr){
                ar[j+1]=ar[j];
                count++;
                if(j==0)
                    ar[j]=curr;
            }
            else{
                ar[j+1]=curr;
                j=-1;
            }
        }
    }
    return count;
}


/* Tail starts here */
int main() {
    vector <int>  _ar;
    int _ar_size;
    cin >> _ar_size;
    for(int _ar_i=0; _ar_i<_ar_size; _ar_i++) {
        int _ar_tmp;
        cin >> _ar_tmp;
        _ar.push_back(_ar_tmp); 
    }
    cout<<insertionSortCount(_ar);
    return 0;
}
----------
====================
----------
ALGORITHMS.89
easy
----------
PROBLEM STATEMENT:
We say that a string contains the word hackerrank if a subsequence of its characters spell the word hackerrank. For example, if string [expression], it no longer contains the subsequence due to ordering.

More formally, let [expression] contains hackerrank.

For each query, print YES on a new line if the string contains hackerrank, otherwise, print NO.  

Function Description  

Complete the hackerrankInString function in the editor below.  It must return YES or NO.  

hackerrankInString has the following parameter(s):  


s: a string  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

int main(){
    int q;
    cin >> q;
    for(int a0 = 0; a0 < q; a0++){
        string s;
        cin >> s;
        string cur = "hackerrank";
        int st = 0;
        for (int i= 0; i < s.size() && st < cur.size(); i++) {
            if (s[i] == cur[st]) {
                st++;
            }
        }
        if (st == cur.size()) {
            cout << "YES" << endl;
        } else {
            cout << "NO" << endl;
        }
        // your code goes here
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.90
easy
----------
PROBLEM STATEMENT:
The previous challenges covered Insertion Sort, which is a simple and intuitive sorting algorithm with a running time of [expression]. In these next few challenges, we're covering a divide-and-conquer algorithm called Quicksort (also known as Partition Sort).  This challenge is a modified version of the algorithm that only addresses partitioning.  It is implemented as follows: 

Step 1: Divide 
Choose some pivot element, [expression]. 

For example:
Assume [expression] 
The pivot is at [expression] 
[expression]. 
Putting them all together, you get [expression]. 

Given [expression] on a single line. Your output should be space-separated and does not have to maintain ordering of the elements within the three categories.

Function Description  

Complete the quickSort function in the editor below.  It should return an array of integers as described above.  

quickSort has the following parameter(s):  


arr: an array of integers where [expression] is the pivot element    

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
using namespace std;

/* Head ends here */

void partition(vector <int>  ar) {
    if(ar.size() == 0)
		return;
	else if(ar.size() == 1){
		cout << ar[0] << endl;
		return;
	}
	
	int p = ar[0];
	vector<int> less;
	vector<int> more;
	
	for(vector<int>::iterator itr = ar.begin() + 1; itr != ar.end(); itr++){
		if(*itr < p)
			less.push_back(*itr);
		else
			more.push_back(*itr);
	}
	
	for(vector<int>::iterator itr = less.begin(); itr != less.end(); itr++)
		cout << *itr << " ";
	cout << p << " ";
	for(vector<int>::iterator itr = more.begin(); itr != more.end(); itr++)
		cout << *itr << " ";
	cout << endl;

}


/* Tail starts here */
int main() {
   vector <int>  _ar;
   int _ar_size;
cin >> _ar_size;
for(int _ar_i=0; _ar_i<_ar_size; _ar_i++) {
   int _ar_tmp;
   cin >> _ar_tmp;
   _ar.push_back(_ar_tmp); 
}

partition(_ar);
   
   return 0;
}
----------
====================
----------
ALGORITHMS.91
easy
----------
PROBLEM STATEMENT:
Roy wanted to increase his typing speed for programming contests.  His friend suggested that he type the sentence "The quick brown fox jumps over the lazy dog" repeatedly.  This sentence is known as a pangram because it contains every letter of the alphabet.

After typing the sentence several times, Roy became bored with it so he started to look for other pangrams.

Given a sentence, determine whether it is a pangram.  Ignore case.

Function Description

Complete the function pangrams in the editor below.  It should return the string pangram if the input string is a pangram.  Otherwise, it should return not pangram.  

pangrams has the following parameter(s):


s: a string to test

----------
TOP SOLUTION:
----------
#define DEBUG 0

#include <algorithm>
#include <functional>
#include <numeric>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <complex>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <cassert>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <sstream>
using namespace std;

#define LL long long
#define LD long double
#define PR pair<int,int>

#define Fox(i,n) for (i=0; i<n; i++)
#define Fox1(i,n) for (i=1; i<=n; i++)
#define FoxI(i,a,b) for (i=a; i<=b; i++)
#define FoxR(i,n) for (i=(n)-1; i>=0; i--)
#define FoxR1(i,n) for (i=n; i>0; i--)
#define FoxRI(i,a,b) for (i=b; i>=a; i--)
#define Foxen(i,s) for (i=s.begin(); i!=s.end(); i++)
#define Min(a,b) a=min(a,b)
#define Max(a,b) a=max(a,b)
#define Sz(s) int((s).size())
#define All(s) (s).begin(),(s).end()
#define Fill(s,v) memset(s,v,sizeof(s))
#define pb push_back
#define mp make_pair
#define x first
#define y second

template<typename T> T Abs(T x) { return(x<0 ? -x : x); }
template<typename T> T Sqr(T x) { return(x*x); }
string plural(string s) { return(Sz(s) && s[Sz(s)-1]=='x' ? s+"en" : s+"s"); }

const int INF = (int)1e9;
const LD EPS = 1e-12;
const LD PI = acos(-1.0);

#if DEBUG
#define GETCHAR getchar
#else
#define GETCHAR getchar_unlocked
#endif

bool Read(int &x)
{
	char c,r=0,n=0;
	x=0;
		for(;;)
		{
			c=GETCHAR();
				if ((c<0) && (!r))
					return(0);
				if ((c=='-') && (!r))
					n=1;
				else
				if ((c>='0') && (c<='9'))
					x=x*10+c-'0',r=1;
				else
				if (r)
					break;
		}
		if (n)
			x=-x;
	return(1);
}

int main()
{
		if (DEBUG)
			freopen("in.txt","r",stdin);
	int N,M,K;
	int cnt[26]={0};
	char s[10000];
	cin.getline(s,10000);
	int i;
	int j=strlen(s);
		Fox(i,j)
			if ((s[i]>='a') && (s[i]<='z'))
				cnt[s[i]-'a']++;
			else
			if ((s[i]>='A') && (s[i]<='Z'))
				cnt[s[i]-'A']++;
		Fox(i,26)
			if (!cnt[i])
			{
				printf("not ");
				break;
			}
		printf("pangram\n");
	return(0);
}
----------
====================
----------
ALGORITHMS.92
easy
----------
PROBLEM STATEMENT:
A weighted string is a string of lowercase English letters where each letter has a weight.  Character weights are [expression] as shown below:



We define the following terms:  


The weight of a string is the sum of the weights of all the string's characters.  For example: 


A uniform string consists of a single character repeated zero or more times. For example, ccc and a are uniform strings, but bcb and cd are not.


Given a string, [expression]; otherwise, print No instead.

Note: The [expression].

Function Description  

Complete the weightedUniformStrings function in the editor below. It should return an array of strings, either Yes or No, one for each query.  

weightedUniformStrings has the following parameter(s):  


s: a string  
queries: an array of integers  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

bool reach[10000010];

int main(){
    string s;
    cin >> s;
    
    int val = 0;
    for (int i=0; i<s.size(); i++) {
        if (i > 0 && s[i] != s[i-1]) val = 0;
        val += (s[i]-'a'+1);
        reach[val] = true;
    }
    
    int n;
    cin >> n;
    for(int a0 = 0; a0 < n; a0++){
        int x;
        cin >> x;
        cout << (reach[x] ? "Yes\n" : "No\n");
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.93
easy
----------
PROBLEM STATEMENT:
A numeric string, [expression], satisfying the following conditions:


[expression] more than the previous element).
No [expression] have leading zeroes.
The contents of the sequence cannot be rearranged. For example, we can split [expression]).


The diagram below depicts some beautiful strings:



You must perform [expression], choose the smallest.  Otherwise, print NO.  

Function Description  

Complete the separateNumbers function in the editor below.  It should print a string as described above.  

separateNumbers has the following parameter:  


s: an integer value represented as a string  

----------
TOP SOLUTION:
----------
#include <sstream>
#include <vector>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <string>
#include <cassert>
#include <ctime>
#include <map>
#include <math.h>
#include <cstdio>
#include <set>
#include <deque>
#include <memory.h>
#include <queue>

#pragma comment(linker, "/STACK:64000000")
typedef long long ll;

using namespace std;

const int MAXK = -1;
const int MAXN = -1;
const int MOD = 0; // 1000 * 1000 * 1000 + 7;



int main() {
#ifdef _MSC_VER
	freopen("input.txt", "r", stdin);
#endif

	int T;
	cin >> T;
	while (T--) {
		string s;
		cin >> s;
		int n = s.length();

		ll ans = -1;
		for (int len = 1; len * 2 <= n; len++) {
			ll x = 0;
			for (int i = 0; i < len; i++) x = 10 * x + (s[i] - '0');
			string t = "";
			ll x0 = x;
			while (t.length() < s.length()) t += to_string(x++);
			if (s == t) {
				ans = x0;
				break;
			}
		}
		if (ans == -1) cout << "NO" << endl;
		else cout << "YES " << ans << endl;
	}

	return 0;
}
----------
====================
----------
ALGORITHMS.94
easy
----------
PROBLEM STATEMENT:
In this challenge, you will determine whether a string is funny or not.  To determine whether a string is funny, create a copy of the string in reverse e.g. [expression].  Iterating through each string, compare the absolute difference in the ascii values of the characters at positions 0 and 1, 1 and 2 and so on to the end.  If the list of absolute differences is the same for both strings, they are funny.

Determine whether a give string is funny.  If it is, return Funny, otherwise return Not Funny.

For example, given the string [expression], so the answer is Funny.

Function Description

Complete the funnyString function in the editor below.  For each test case, it should return a string, either Funny or Not Funny.

funnyString has the following parameter(s):  


s: a string to test

----------
TOP SOLUTION:
----------
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cctype>
#include<cstdlib>
#include<algorithm>
#include<bitset>
#include<vector>
#include<list>
#include<deque>
#include<queue>
#include<map>
#include<set>
#include<stack>
#include<cmath>
#include<sstream>
#include<fstream>
#include<iomanip>
#include<ctime>
#include<complex>
#include<functional>
#include<climits>
#include<cassert>
#include<iterator>
using namespace std;
string s;
int t;
char ss[1000001];
int main(){
	scanf("%d", &t);
	while (t--){
		scanf("%s", ss);
		s = ss;
		//cin >> s;
		string r = s;
		bool ok = false;
		reverse(r.begin(), r.end());
		for (int i = 0; i < s.size() - 1; i++){
			if (abs(s[i] - s[i + 1]) != abs(r[i] - r[i + 1])){
				ok = true;
				break;
			}
		}
		if (ok){
			puts("Not Funny");
		}
		else{
			puts("Funny");
		}
 }
	return 0;
}
----------
====================
----------
ALGORITHMS.95
easy
----------
PROBLEM STATEMENT:
Comparison Sorting 
Quicksort usually has a running time of [expression] represents the minimum number of comparisons needed to know where to place each element. For more details, you can see these notes (PDF). 

Alternative Sorting 
Another sorting method, the counting sort, does not require comparison.  Instead, you create an integer array whose index range covers the entire range of values in your array to sort.  Each time a value occurs in the original array, you increment the counter at that index.  At the end, run through your counting array, printing the value of each non-zero valued index that number of times.

For example, consider an array [expression].  The results of each iteration follow:

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



Now we can print the list of occurrences, [expression].

Challenge 
Given a list of integers, count and output the number of times each value appears as a list of space-separated integers.

Function Description  

Complete the countingSort function in the editor below.  It should return an array of integers where each value is the number of occurrences of the element's index value in the original array.  

countingSort has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

vector<int>List;
auto main()->int
{
	int size;
	cin >> size;
	//Initialize
	List.resize(100,0);
	for (int i = 0; i != size; i++)
	{
		int n;
		cin >> n;
		List[n] = List[n] + 1;
	}
	for (int r = 0; r != List.size(); r++)
	{
		cout << List[r]<<" ";
	}
	return 0;
}
----------
====================
----------
ALGORITHMS.96
easy
----------
PROBLEM STATEMENT:
Often, when a list is sorted, the elements being sorted are just keys to other values. For example, if you are sorting files by their size, the sizes need to stay connected to their respective files. You cannot just take the size numbers and output them in order, you need to output all the required file information.

The counting sort is used if you just need to sort a list of integers.  Rather than using a comparison, you create an integer array whose index range covers the entire range of values in your array to sort.  Each time a value occurs in the original array, you increment the counter at that index.  At the end, run through your counting array, printing the value of each non-zero valued index that number of times.

For example, consider an array [expression].  The results of each iteration follow:

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



Now we can print the sorted array: [expression].

Challenge 
Given an unsorted list of integers, use the counting sort method to sort the list and then print the sorted list. 

Hint: You can use your previous code that counted the items to print out the actual values in order.  

Function Description  

Complete the countingSort function in the editor below.  It should return the original array, sorted ascending, as an array of integers.  

countingSort has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


vector<int>List;
auto main()->int
{
	int size;
	cin >> size;
	//Initialize
	List.resize(100,0);
	for (int i = 0; i != size; i++)
	{
		int n;
		cin >> n;
		List[n] = List[n] + 1;
	}
	for (int r = 0; r != List.size(); r++)
	{
		for (int t = 0; t != List[r];t++)
		{
			cout << r << " ";
		}
	}
	return 0;
}
----------
====================
----------
ALGORITHMS.97
easy
----------
PROBLEM STATEMENT:
John has collected various rocks. Each rock has various minerals embeded in it.  Each type of mineral is designated by a lowercase letter in the range [expression]. There may be multiple occurrences of a mineral in a rock. A mineral is called a gemstone if it occurs at least once in each of the rocks in John's collection.

Given a list of minerals embedded in each of John's rocks, display the number of types of gemstones he has in his collection.

For example, the array of mineral composition strings [expression] gemstones.

Function Description  

Complete the gemstones function in the editor below.  It should return an integer representing the number of gemstones found in the list of rocks.  

gemstones has the following parameter(s):  


arr: an array of strings  

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cmath>
#include <iostream>
#include <numeric>
#include <algorithm>
#include <string>
#include <memory.h>
#include <memory>
#include <functional>
#include <vector>
#include <ctime>
#include <cstdlib>
#include <iomanip>
#include <time.h>
#include <map>
#include <set>
#include <climits>
#include <queue>
#include <sstream>
#include <stack>
#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <string>
#include <fstream>
#include <iterator>
#include <cmath>
#include <algorithm>
#include <functional>

#include <cstdio>
#include <cstring>
#include <vector>

using namespace std;

string s[101];

int main()
{
    ios::sync_with_stdio(0);
    int n;
    cin >> n;
    for(int i = 0 ; i < n ; ++i)
        cin >> s[i];
    
    int ans = 0;
    for(char ch = 'a' ; ch <= 'z' ; ++ch)
    {
        bool fl = 1;
        for(int i = 0 ; fl && i < n ; ++i)
        {
            fl = 0;
            for(int j = 0 ; j < s[i].size() ; ++j)
            if(s[i][j] == ch)
                fl = 1;
        }
        if(fl)
            ++ans;
    }
    cout << ans << "\n";
    return 0;
}
----------
====================
----------
ALGORITHMS.98
easy
----------
PROBLEM STATEMENT:
You are given a string containing characters [expression] only.  Your task is to change it into a string such that there are no matching adjacent characters. To do this, you are allowed to delete zero or more characters in the string.  

Your task is to find the minimum number of required deletions.

For example, given the string [expression] deletions.

Function Description

Complete the alternatingCharacters function in the editor below.  It must return an integer representing the minimum number of deletions to make the alternating string.  

alternatingCharacters has the following parameter(s):


s: a string

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int t;
    cin>>t;
    while(t--)
        {
        string s;int c=0,a=0;
        cin>>s;
        for(int i=1;s[i]!='\0';i++)
            {
            if((s[i]==65 && s[a]==66)||(s[i]==66 &&s[a]==65))
            {
                a=i;
               // cout<<a<<endl;
               }
                else{
                    c++;
                    //cout<<c<<" "<<i<<endl;
                   
                }
                
            }
        cout<<c<<endl;
        
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.99
medium
----------
PROBLEM STATEMENT:
In this challenge you need to print the string that accompanies each integer in a list sorted by the integers. If two strings are associated with the same integer, they must be printed in their original order so your sorting algorithm should be stable.  There is one other twist.  The first half of the strings encountered in the inputs are to be replaced with the character "[expression].

Insertion Sort and the simple version of Quicksort are stable, but the faster in-place version of Quicksort is not since it scrambles around elements while sorting. 

In this challenge, you will use counting sort to sort a list while keeping the order of the strings preserved. 

For example, if your inputs are [expression] you could set up a helper array with three empty arrays as elements.  The following shows the insertions:

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



The result is then printed: [expression] . 

Function Description  

Complete the countSort function in the editor below.  It should construct and print out the sorted strings.  

countSort has the following parameter(s):


arr: a 2D array where each arr[i] is comprised of two strings: x and s.  


Note: The first element of each [expression], must be cast as an integer to perform the sort.  
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include<string>
#include<list>
using namespace std;


vector<string> a[100];
char str[100007];
int n,i,j,x;

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    
    
    cin>>n;
    for(i=0;i<n/2;i++)
    {
        cin>>x;
        cin>>str;
        a[x].push_back("-");
    
    }
    
    for(;i<n;i++)
    {
        cin>>x;
        cin>>str;
        a[x].push_back(str);
    
    }
    
    for(i=0;i<100;i++)
    {
        x=a[i].size();
        for(j=0;j<x;j++)
            cout<<a[i][j]<<" ";    
    }
    return 0;

}
----------
====================
----------
ALGORITHMS.100
easy
----------
PROBLEM STATEMENT:
Alice has a binary string. She thinks a binary string is beautiful if and only if it doesn't contain the substring [expression]. 

In one step, Alice can change a [expression] or vice versa. Count and print the minimum number of steps needed to make Alice see the string as beautiful.

For example, if Alice's string is [expression] she can change any one element and have a beautiful string.

Function Description  

Complete the beautifulBinaryString function in the editor below.  It should return an integer representing the minimum moves required.  

beautifulBinaryString has the following parameter(s):  


b: a string of binary digits  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

char B[105];

int main(){
    int n;
    int ans=0;
    scanf("%d", &n);
    scanf("%s", B);
    for(int i=2; B[i]; i++){
        if(B[i-2] == '0' && B[i-1] == '1' && B[i] == '0') B[i] = '1', ans++;
    }
    printf("%d", ans);
    return 0;
}

----------
====================
----------
ALGORITHMS.101
easy
----------
PROBLEM STATEMENT:
Sorting is useful as the first step in many different tasks. The most common task is to make finding things easier, but there are other uses as well.  In this case, it will make it easier to determine which pair or pairs of elements have the smallest absolute difference between them.

For example, if you've got the list [expression].

Given a list of unsorted integers, [expression], find the pair of elements that have the smallest absolute difference between them. If there are multiple pairs, find them all.

Function Description  

Complete the closestNumbers function in the editor below.  It must return an array of integers as described.

closestNumbers has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int cmp(int x,int y)
{
    return x<y;
}
int main() {
   vector<int> arr,temp;
   int i,n,diff,x;
    
    cin>>n;
    
    for(i=0;i<n;i++)
    {
        cin>>x;
        arr.push_back(x);
    }
    
    sort(arr.begin(),arr.end(),cmp);
    
    diff=arr[1]-arr[0];
    
    for(i=2;i<n;i++)
        if(diff>(arr[i]-arr[i-1]))
        {
            diff=arr[i]-arr[i-1];
            temp.clear();
            temp.push_back(arr[i-1]);
            temp.push_back(arr[i]);
        }
        else  if(diff==(arr[i]-arr[i-1]))
        {
            temp.push_back(arr[i-1]);
            temp.push_back(arr[i]);
        }
            
    for(i=0;i<temp.size();i++)
        cout<<temp[i]<<" ";
    
    
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
ALGORITHMS.102
easy
----------
PROBLEM STATEMENT:
James found a love letter that his friend Harry has written to his girlfriend. James is a prankster, so he decides to meddle with the letter. He changes all the words in the letter into palindromes.   

To do this, he follows two rules:  


He can only reduce the value of a letter by [expression], i.e. he can change d to c, but he cannot change c to d or d to b.  
The letter a may not be reduced any further.  


Each reduction in the value of any letter is counted as a single operation. Find the minimum number of operations required to convert a given string into a palindrome.

For example, given the string [expression], the following two operations are performed:  cde → cdd → cdc.  

Function Description  

Complete the theLoveLetterMystery function in the editor below.  It should return the integer representing the minimum number of operations needed to make the string a palindrome.  

theLoveLetterMystery has the following parameter(s):  


s: a string

----------
TOP SOLUTION:
----------
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main(){
    int t;
    cin >> t;
    while(t--){
        string s;
        cin >> s;
        int i = 0;
        int j = s.length()-1;
        int sol = 0;
        while(i<j){
            sol += abs(s[i]-s[j]);
            ++i;
            --j;
        }
        cout<<sol<<"\n";
    }
    return 0;
}
----------
====================
----------
ALGORITHMS.103
easy
----------
PROBLEM STATEMENT:
The median of a list of numbers is essentially it's middle element after sorting.  The same number of elements occur after it as before.  Given a list of numbers with an odd number of elements, can you find the median?

For example, the median of [expression], the middle element in the sorted array.

Function Description

Complete the findMedian function in the editor below.  It must return an integer that represents the median of the array. 

findMedian has the following parameter(s):  


arr: an unsorted array of integers

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
    int n, *arr;
    cin>>n;
    arr = new int[n];
    for (int i = 0 ; i < n ; i++) cin>>arr[i];
    sort(arr,arr+n);
    if (n%2 == 1) cout<<arr[(n-1)/2]<<endl;
    else cout<<(arr[n/2 - 1]+arr[n/2])/2<<endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.104
hard
----------
PROBLEM STATEMENT:
DNA is a nucleic acid present in the bodies of living things. Each piece of DNA contains a number of genes, some of which are beneficial and increase the DNA's total health. Each gene has a health value, and the total health of a DNA is the sum of the health values of all the beneficial genes that occur as a substring in the DNA. We represent genes and DNA as non-empty strings of lowercase English alphabetic letters, and the same gene may appear multiple times as a susbtring of a DNA.

Given the following:


An array of beneficial gene strings, [expression]. Note that these gene sequences are not guaranteed to be distinct.
An array of gene health values, [expression].
A set of [expression] are healthy.


Find and print the respective total healths of the unhealthiest (minimum total health) and  healthiest (maximum total health) strands of DNA as two space-separated values on a single line.
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }

class IncrementalAhoCorasic {
	static const int Alphabets = 26;
	static const int AlphabetBase = 'a';
	struct Node {
		Node *fail;
		Node *next[Alphabets];
		long long sum;
		Node() : fail(NULL), next{}, sum(0) { }
	};

	struct String {
		string str;
		int weight;
	};

public:
	//totalLen = sum of (len + 1)
	void init(int totalLen) {
		nodes.resize(totalLen);
		nNodes = 0;
		strings.clear();
		roots.clear();
		sizes.clear();
		que.resize(totalLen);
	}

	void insert(const string &str, int weight) {
		strings.push_back(String{ str, weight });
		roots.push_back(nodes.data() + nNodes);
		sizes.push_back(1);
		nNodes += (int)str.size() + 1;
		auto check = [&]() { return sizes.size() > 1 && sizes.end()[-1] == sizes.end()[-2]; };
		if (!check())
			makePMA(strings.end() - 1, strings.end(), roots.back(), que);
		while (check()) {
			int m = sizes.back();
			roots.pop_back();
			sizes.pop_back();
			sizes.back() += m;
			if (!check())
				makePMA(strings.end() - m * 2, strings.end(), roots.back(), que);
		}
	}

	long long match(const string &str) const {
		long long res = 0;
		for (const Node *t : roots)
			res += matchPMA(t, str);
		return res;
	}

private:
	static void makePMA(vector<String>::const_iterator begin, vector<String>::const_iterator end, Node *nodes, vector<Node*> &que) {
		int nNodes = 0;
		Node *root = new(&nodes[nNodes ++]) Node();
		for (auto it = begin; it != end; ++ it) {
			Node *t = root;
			for (char c : it->str) {
				Node *&n = t->next[c - AlphabetBase];
				if (n == nullptr)
					n = new(&nodes[nNodes ++]) Node();
				t = n;
			}
			t->sum += it->weight;
		}
		int qt = 0;
		for (Node *&n : root->next) {
			if (n != nullptr) {
				n->fail = root;
				que[qt ++] = n;
			} else {
				n = root;
			}
		}
		for (int qh = 0; qh != qt; ++ qh) {
			Node *t = que[qh];
			int a = 0;
			for (Node *n : t->next) {
				if (n != nullptr) {
					que[qt ++] = n;
					Node *r = t->fail;
					while (r->next[a] == nullptr)
						r = r->fail;
					n->fail = r->next[a];
					n->sum += r->next[a]->sum;
				}
				++ a;
			}
		}
	}

	static long long matchPMA(const Node *t, const string &str) {
		long long res = 0;
		for (char c : str) {
			int a = c - AlphabetBase;
			while (t->next[a] == nullptr)
				t = t->fail;
			t = t->next[a];
			res += t->sum;
		}
		return res;
	}


	vector<Node> nodes;
	int nNodes;
	vector<String> strings;
	vector<Node*> roots;
	vector<int> sizes;
	vector<Node*> que;
};

int main() {
	int n;
	static char buf[2000001];
	while (~scanf("%d", &n)) {
		vector<string> patterns(n);
		int totalLen = 0;
		rep(i, n) {
			scanf("%s", buf);
			patterns[i] = buf;
			totalLen += (int)patterns[i].size() + 1;
		}
		vector<int> values(n);
		for (int i = 0; i < n; ++ i)
			scanf("%d", &values[i]);
		int Q;
		scanf("%d", &Q);
		vector<string> strings(Q);
		vector<vector<int>> queries(n + 1);
		rep(i, Q) {
			int L; int R;
			scanf("%d%d", &L, &R), ++ R;
			scanf("%s", buf);
			strings[i] = buf;
			queries[L].push_back(i * 2 + 0);
			queries[R].push_back(i * 2 + 1);
		}
		IncrementalAhoCorasic iac;
		iac.init(totalLen);
		vector<long long> ans(Q, 0);
		rep(i, n) {
			iac.insert(patterns[i], values[i]);
			for (int qi : queries[i + 1])
				ans[qi / 2] += iac.match(strings[qi / 2]) * (qi % 2 == 0 ? -1 : 1);
		}
		long long minSum = INFL, maxSum = -INFL;
		rep(i, Q) {
			amin(minSum, ans[i]);
			amax(maxSum, ans[i]);
		}
		printf("%lld %lld\n", minSum, maxSum);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.105
advanced
----------
PROBLEM STATEMENT:
Insertion Sort is a simple sorting technique which was covered in previous challenges. Sometimes, arrays may be too large for us to wait around for insertion sort to finish. Is there some other way we can calculate the number of shifts an Insertion Sort performs when sorting an array?

If [expression].  

[expression]
[expression]	
[expression]
[expression]
[expression]

[expression]



Function description  

Complete the insertionSort function in the editor below.  It should return an integer that represents the number of shifts required to sort the given array.  

insertionSort has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include<iostream>
#include<string.h>
#include<string>
#include<vector>
#include<map>
#include<queue>
#include<deque>
#include<set>
#include<list>
#include<stack>
#include<sstream>
#include<fstream>
#include<algorithm>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<cassert>
#define CLRM(x) memset(x,-1,sizeof(x))
#define CLR(x) memset(x,0,sizeof(x))
#define ALL(x) x.begin(),x.end()
#define GI(x) scanf("%d", &x);
#define FORN(i, n) for(int i = 0; i < n; i++)
#define FOR(i, start, end) for(int i = start; i < end; i++)
#define PB push_back
#define MP make_pair
#define VI vector<int> 
#define VVI vector<vector<int> >
#define PII pair<int,int>
#define SZ(x) (int)x.size()
#define LL long long
#define MIN(a,b) (a)<(b)?(a):(b)
#define MAX(a,b) (a)>(b)?(a):(b)
#define LMAX 1000000000000000000LL
#define IMAX 1000000000
using namespace std;

#define MAXN 110000
int N;
int d[MAXN];

LL mergesort(int low, int high)
{
	if(low >= high)
		return 0;
	
	int mid = (low+high)/2;

	LL ret = 0;
	ret = mergesort(low, mid) + mergesort(mid+1, high);
	vector<int> v;
	int i, j, k;
	i = low; j = mid + 1;
	while(i <= mid && j <= high)
	{
		if(d[i] > d[j])
		{
			v.PB(d[j]);
			ret+=(LL)(mid-i+1);
			j++;
		}
		else
		{
			v.PB(d[i]);
			i++;
		}
	}
	while(i <= mid)
	{
		v.PB(d[i]);
		i++;
	}
	while(j <= high)
	{
		v.PB(d[j]);
		j++;
	}
	for(i = 0; i < v.size(); i++)
	{
		d[i + low] = v[i];
	}
	return ret;
}
LL solve()
{
	LL ret = mergesort(0, N-1);
	return ret;
}
int main()
{
	int tes;
	GI(tes);
	while(tes--)
	{
		int i;
		GI(N);
		FORN(i, N)
		{
			GI(d[i]);
		}
		LL ans = solve();
		printf("%lld\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.106
easy
----------
PROBLEM STATEMENT:
Given a string of lowercase letters in the range ascii[a-z], determine a character that can be removed to make the string a palindrome.  There may be more than one solution, but any will do.  For example, if your string is "bcbc", you can either remove 'b' at index [expression].  If the word is already a palindrome or there is no solution, return -1.  Otherwise, return the index of a character to remove.  

Function Description  

Complete the palindromeIndex function in the editor below.  It must return the index of the character to remove or [expression].  

palindromeIndex has the following parameter(s):  


s: a string to analyze

----------
TOP SOLUTION:
----------
#include<stdio.h>
#include<string.h>
char a[1000005];
char b[1000005];
int is(char *a, int n){
	int i;
	for(i=0;i<n/2;i++)if(a[i]!=a[n-1-i])return i;
	return -1;
}
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		
		scanf("%s",&a);
		int l = strlen(a);
		int x = is(a,l);
		if(x==-1){
			printf("-1\n");
		}
		else {
			int i;
			int j=0;
			for(i=0;a[i];i++){
				if(i!=x)b[j++] = a[i];
				
			
			}
				if(is(b,l-1)==-1)printf("%d\n",x);
				else printf("%d\n",l-1-x);
		}
	}
}
----------
====================
----------
ALGORITHMS.107
medium
----------
PROBLEM STATEMENT:
HackerLand National Bank has a simple policy for warning clients about possible fraudulent account activity. If the amount spent by a client on a particular day is greater than or equal to [expression] the client's median spending for a trailing number of days, they send the client a notification about potential fraud. The bank doesn't send the client any notifications until they have at least that trailing number of prior days' transaction data.

Given the number of trailing days [expression] days.

For example, [expression] so no notice will be sent.  Over the period, there was one notice sent.

Note: The median of a list of numbers can be found by arranging all the numbers from smallest to greatest. If there is an odd number of numbers, the middle one is picked. If there is an even number of numbers, median is then defined to be the average of the two middle values. (Wikipedia)

Function Description

Complete the function activityNotifications in the editor below.  It must return an integer representing the number of client notifications.  

activityNotifications has the following parameter(s):


expenditure: an array of integers representing daily expenditures  
d: an integer, the lookback days for median spending  

----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }

template<typename It>
void make_fenwick(It beg, size_t n) {
	for(size_t i = 0; i < n; i ++) {
		size_t p = i | (i + 1);
		if(p < n) beg[p] += beg[i];
	}
}
template<typename It, typename Val>
void add_fenwick(It beg, size_t n, size_t i, Val val) {
	for(; i < n; i |= i + 1) beg[i] += val;
}
template<typename It, typename Val>
Val sum_fenwick(It beg, size_t i, Val sum) {
	for(; i > 0; i = i & (i - 1)) sum += beg[i - 1];
	return sum;
}
template<typename It>
typename std::iterator_traits<It>::value_type sum_fenwick(It beg, size_t i) {
	return sum_fenwick(beg, i, typename std::iterator_traits<It>::value_type());
}

size_t highestOneBit(size_t v) {
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
#if SIZE_MAX > 0xffffffffULL
	v |= v >> 32;
#endif
	return (v >> 1) + 1;
}

template<typename It, typename Val, typename Cmp>
size_t search_fenwick(It beg, size_t n, Val val, Val left, Cmp cmp) {
	if(!cmp(left, val)) return 0;
	size_t i = 0;
	for(size_t w = highestOneBit(n); w > 0; w >>= 1) {
		if(i + w <= n) {
			Val mid = left;
			mid += beg[i + w - 1];
			if(cmp(mid, val)) {
				i += w;
				left = mid;
			}
		}
	}
	return i + 1;
}

template<typename It, typename Val>
size_t select_fenwick(It beg, size_t n, Val k) {
	return search_fenwick(beg, n, k + 1, Val(), std::less<Val>()) - 1;
}


int main() {
	int n; int d;
	while(~scanf("%d%d", &n, &d)) {
		vector<int> A(n);
		for(int i = 0; i < n; ++ i)
			scanf("%d", &A[i]);
		int X = *max_element(A.begin(), A.end());
		vector<int> ft(X + 1, 0);
		rep(i, d) add_fenwick(ft.begin(), ft.size(), A[i], 1);
		int ans = 0;
		rep(i, n - d) {
			int x = select_fenwick(ft.begin(), ft.size(), (d - 1) / 2);
			int y = select_fenwick(ft.begin(), ft.size(), d / 2);
			if(x + y <= A[i + d])
				++ ans;
			add_fenwick(ft.begin(), ft.size(), A[i], -1);
			add_fenwick(ft.begin(), ft.size(), A[i + d], 1);
		}
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.108
easy
----------
PROBLEM STATEMENT:
Two words are anagrams of one another if their letters can be rearranged to form the other word.  

In this challenge, you will be given a string.  You must split it into two contiguous substrings, then determine the minimum number of characters to change to make the two substrings into anagrams of one another.

For example, given the string 'abccde', you would break it into two parts: 'abc' and 'cde'.  Note that all letters have been used, the substrings are contiguous and their lengths are equal.  Now you can change 'a' and 'b' in the first substring to 'd' and 'e' to have 'dec' and 'cde' which are anagrams.  Two changes were necessary.

Function Description

Complete the anagram function in the editor below.  It should return the minimum number of characters to change to make the words anagrams, or [expression] if it's not possible.  

anagram has the following parameter(s):  


s: a string  

----------
TOP SOLUTION:
----------
//Coder: Balajiganapathi
#define TRACE
#define DEBUG

#include <algorithm>
#include <bitset>
#include <deque>
#include <cassert>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <utility>
#include <vector>

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pi;
typedef vector<string> vs;

// Basic macros
#define st          first
#define se          second
#define all(x)      (x).begin(), (x).end()
#define ini(a, v)   memset(a, v, sizeof(a))
#define re(i,s,n)  	for(int i=s;i<(n);++i)
#define rep(i,s,n)  for(int i=s;i<=(n);++i)
#define fr(i,n)     re(i,0,n)
#define tr(i,x)     for(typeof(x.begin()) i=x.begin();i!=x.end();++i)
#define pu          push_back
#define mp          make_pair
#define sz(x)       (int)(x.size())

const int oo = 2000000009;
const double eps = 1e-9;



#ifdef TRACE
    #define trace1(x)                cerr << #x << ": " << x << endl;
    #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;
    #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;
    #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;
    #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl;
    #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;

#else

    #define trace1(x)
    #define trace2(x, y)
    #define trace3(x, y, z)
    #define trace4(a, b, c, d)
    #define trace5(a, b, c, d, e)
    #define trace6(a, b, c, d, e, f)

#endif

int cnt[300];
int main() {
    int t;
    string s;
    cin >> t;
    while(t--) {
        cin >> s;
        if(sz(s) % 2 == 1) {
            printf("-1\n");
            continue;
        }
        
        ini(cnt, 0);
        fr(i, sz(s) / 2) ++cnt[s[i]];
        re(i, sz(s) / 2, sz(s)) --cnt[s[i]];
        
        int ans = 0;
        fr(i, 300) if(cnt[i] > 0) ans += cnt[i];
        printf("%d\n", ans);
    }
    
	return 0;
}

----------
====================
----------
ALGORITHMS.109
easy
----------
PROBLEM STATEMENT:
We consider two strings to be anagrams of each other if the first string's letters can be rearranged to form the second string. In other words, both strings must contain the same exact letters in the same exact frequency. For example, bacdc and dcbac are anagrams, but bacdc and dcbad are not.

Alice is taking a cryptography class and finding anagrams to be very useful. She decides on an encryption scheme involving two large strings where encryption is dependent on the minimum number of character deletions required to make the two strings anagrams. Can you help her find this number? 

Given two strings, [expression] anagrams. Any characters can be deleted from either of the strings. 

For example, [expression] deletions.  

Function Description  

Complete the makingAnagrams function in the editor below.  It should return an integer representing the minimum number of deletions needed to make the strings anagrams.  

makingAnagrams has the following parameter(s):  


s1: a string  
s2: a string  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstring>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    char s1[10010],s2[10010];
    cin>>s1>>s2;
    int a[26]={0};
    for(int i=0;i<strlen(s1);i++)
        a[s1[i]-'a']++;
    for(int i=0;i<strlen(s2);i++)
        a[s2[i]-'a']--;
    long long int ans = 0;
    for(int i=0;i<26;i++)
        ans += abs(a[i]);
    cout<<ans<<endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.110
medium
----------
PROBLEM STATEMENT:
Whenever George asks Lily to hang out, she's busy doing homework. George wants to help her finish it faster, but he's in over his head! Can you help George understand Lily's homework so she can hang out with him?

Consider an array of [expression] is minimal.

Given the array [expression], determine and return the minimum number of swaps that should be performed in order to make the array beautiful.

For example, [expression].  To get there, George performed the following swaps:  

Swap      Result
      [7, 15, 12, 3]
3 7   [3, 15, 12, 7]
7 15  [3, 7, 12, 15]


It took [expression] swaps to make the array beautiful. This is minimal among the choice of beautiful arrays possible.

Function Description  

Complete the lilysHomework function in the editor below.  It should return an integer that represents the minimum number of swaps required.  

lilysHomework has the following parameter(s):  


arr: an integer array  

----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
ALGORITHMS.111
easy
----------
PROBLEM STATEMENT:
Dothraki are planning an attack to usurp King Robert's throne. King Robert learns of this conspiracy from Raven and plans to lock the single door through which the enemy can enter his kingdom.



But, to lock the door he needs a key that is an anagram of a palindrome.  He starts to go through his box of strings, checking to see if they can be rearranged into a palindrome.

For example, given the string [expression].

Function Description  

Complete the gameOfThrones function below to determine whether a given string can be rearranged into a palindrome. If it is possible, return YES, otherwise return NO.  

gameOfThrones has the following parameter(s):  


s: a string to analyze  

----------
TOP SOLUTION:
----------
#include <stdio.h>
#include <iostream>
#include <algorithm>
#include <string>
#include <string.h>
#include <vector>
#include <set>
#include <queue>
#include <math.h>
#include <map>
#include <stdlib.h>
using namespace std;
#define ACCEPTED 0
#define F first
#define S second
#define PI (acos(-1.0))
#define EPS (1e-11)
#define INF (1<<30)
int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};
/* ============================================== */

int main(){
  string s;
  cin >>  s;

  vector<int> v(256, 0);
  for(int i=0; i<s.size(); i++) v[s[i]]++;

  int impar =0;
  for(int i=0; i<256; i++)
    if(v[i]%2) impar++;

  if((s.size()%2 == 0 && impar == 0) || (s.size()%2==1 && impar == 1))
    puts("YES");
  else puts("NO");
  
  return ACCEPTED;
}
/* ============================================== */

----------
====================
----------
ALGORITHMS.112
easy
----------
PROBLEM STATEMENT:
Given two strings, determine if they share a common substring.  A substring may be as small as one character.  

For example, the words "a", "and", "art" share the common substring [expression].  The words "be" and "cat" do not share a substring.  

Function Description

Complete the function twoStrings in the editor below.  It should return a string, either YES or NO based on whether the strings share a common substring.  

twoStrings has the following parameter(s):  


s1, s2: two strings to analyze . 

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int a; cin >> a;
    for (int g=0;g<a; g++)
    {
        string b,c; cin >> b >> c; map <char,int> k; 
        for (int y=0;y<b.length(); y++) k[b[y]]=1; int counter=0; 
        for (int y=0;y<c.length(); y++) 
        {
            if (k[c[y]]) counter=1; 
        }
        if (counter) cout << "YES" << '\n';
        else cout << "NO" << '\n'; 
    }return 0; 
}
----------
====================
----------
ALGORITHMS.113
easy
----------
PROBLEM STATEMENT:
Amanda has a string of lowercase letters that she wants to copy to a new string.  She can perform the following operations with the given costs. She can perform them any number of times to construct a new string [expression]:


Append a character to the end of string [expression] dollar. 
Choose any substring of [expression] at no charge.


Given [expression] on a new line.

For example, given a string [expression] at no cost to complete the copy.  

Function Description  

Complete the stringConstruction function in the editor below.  It should return the minimum cost of copying a string.  

stringConstruction has the following parameter(s):  


s: a string  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include<bits/stdc++.h>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        string s;
        cin>>s;
        set<char> a;
        for(int i=0;i<s.size();i++){
            a.insert(s[i]);
        }
        cout<<a.size()<<endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.114
medium
----------
PROBLEM STATEMENT:
Sherlock considers a string to be valid if all characters of the string appear the same number of times.  It is also valid if he can remove just [expression], determine if it is valid.  If so, return YES, otherwise return NO.

For example, if [expression].  

Function Description  

Complete the isValid function in the editor below.  It should return either the string YES or the string NO.  

isValid has the following parameter(s):  


s: a string  

----------
TOP SOLUTION:
----------
/*
*/
 
//#pragma comment(linker, "/STACK:16777216")
#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <ctime> 
 
#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
 
#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 256

using namespace std;

string st;
int cnt[1<<20],answ;

int main(){
//freopen("binomial.in","r",stdin);
//freopen("binomial.out","w",stdout);
//freopen("F:/in.txt","r",stdin);
//freopen("F:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);
//cin.tie(0);

cin>>st;
for (int i=0;i<st.size();i++)
{
	cnt[st[i]-'a']++;
}

answ=1e9;
for (int ans=0;ans<=100000;ans++)
{
	int s=0;
	for (int j=0;j<26;j++)
		if (cnt[j]>=ans)
			s+=cnt[j]-ans;
		else
			s+=cnt[j];
		answ=min(answ,s);
}
//cout<<answ<<endl;
if (answ<=1)
	cout<<"YES"<<endl;
else cout<<"NO"<<endl;

//cin.get();cin.get();
return 0;}
----------
====================
----------
ALGORITHMS.115
medium
----------
PROBLEM STATEMENT:
Palindromes are strings that read the same from the left or right, for example madam or 0110.  

You will be given a string representation of a number and a maximum number of changes you can make.  Alter the string, one digit at a time, to create the string representation of the largest number possible given the limit to the number of changes.  The length of the string may not be altered, so you must consider [expression] is not.  

Given a string representing the starting number and a maximum number of changes allowed, create the largest palindromic string of digits possible or the string -1 if it's impossible to create a palindrome under the contstraints.  

Function Description  

Complete the highestValuePalindrome function in the editor below.  It should return a string representing the largest value palindrome achievable, or -1.  

highestValuePalindrome has the following parameter(s):  


s: a string representation of an integer    
n: an integer that represents the length of the integer string  
k: an integer that represents the maximum number of changes allowed  

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;
#define FOR(i,a,b) for(int i = (a); i <= (b); ++i)
#define FORD(i,a,b) for(int i = (a); i >= (b); --i)
#define RI(i,n) FOR(i,1,(n))
#define REP(i,n) FOR(i,0,(n)-1)
#define mini(a,b) a=min(a,b)
#define maxi(a,b) a=max(a,b)
#define mp make_pair
#define pb push_back
#define st first
#define nd second
#define sz(w) (int) w.size()
typedef vector<int> vi;
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
const int inf = 1e9 + 5;
const int nax = 1e6 + 5;

char sl[nax];
int n, k;

int f(int i) {
	return n - 1 - i;
}

int main() {
	scanf("%d%d", &n, &k);
	scanf("%s", sl);
	int must = 0;
	REP(i, n) {
		int j = f(i);
		if(sl[i] != sl[j] && i < j) ++must;
	}
	if(must > k) {
		printf("%d\n", -1);
		return 0;
	}
	REP(i, n) {
		int j = f(i);
		int dis = 2;
		if(j < i) break;
		if(i == j) dis = 1;
		if(sl[i] == sl[j] && must + dis <= k && sl[i] != '9') {
			sl[i] = sl[j] = '9';
			must += dis;
		}
		if(sl[i] != sl[j]) {
			if(sl[i] == '9' || sl[j] == '9') {
				sl[i] = sl[j] = '9';
			}
			else {
				if(must + 1 <= k) {
					must += 1;
					sl[i] = sl[j] = '9';
				}
				else {
					if(sl[i] > sl[j]) sl[j] = sl[i];
					else sl[i] = sl[j];
				}
			}
		}
	}
	assert(must <= k);
	printf("%s\n", sl);
	return 0;
}

----------
====================
----------
ALGORITHMS.116
medium
----------
PROBLEM STATEMENT:
Madam Hannah Otto, the CEO of Reviver Corp., is fond of palindromes, or words that read the same forwards or backwards. She thinks palindromic brand names are appealing to millennials.  

As part of the marketing campaign for the company's new juicer called the Rotator™, Hannah decided to push the marketing team's palindrome-searching skills to a new level with a new challenge.  

In this challenge, Hannah provides a string [expression]), and ask the following question:

Consider all the palindromes that can be constructed from some of the letters from [expression]. You can reorder the letters as you need. Some of these palindromes have the maximum length among all these palindromes. How many maximum-length palindromes are there?  

For example, if [expression], then we have,



Your job as the head of the marketing team is to answer all the queries. Since the answers can be very large, you are only required to find the answer modulo [expression].  

Complete the functions initialize and answerQuery and return the number of maximum-length palindromes modulo [expression]. 
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
//-------------------------------------------------------

string S;
int N;
int P[26][101010];
int Q,L,R;
ll mo=1000000007;

const int NUM_=200003;
static ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];

void solve() {
	int i,j,k,l,r,x,y; string s;
	
	cin>>S;
	N=S.size();
	FOR(i,26) {
		FOR(x,N) {
			P[i][x+1]=P[i][x]+(S[x]=='a'+i);
		}
	}
	
	inv[1]=fact[0]=factr[0]=1;
	for (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;
	for (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;
	
	cin>>Q;
	while(Q--) {
		cin>>L>>R;
		L--;
		int num[26]={},odd=0,sum=0;
		FOR(i,26) {
			num[i]=(P[i][R]-P[i][L])/2;
			sum+=num[i];
			if((P[i][R]-P[i][L])&1) odd++;
		}
		ll ret=odd?odd:1;
		(ret*=fact[sum])%=mo;
		FOR(i,26) {
			ret=ret*factr[num[i]]%mo;
		}
		cout<<ret<<endl;
		
		
	}
	
	
	
}


int main(int argc,char** argv){
	string s;int i;
	if(argc==1) ios::sync_with_stdio(false), cin.tie(0);
	FOR(i,argc-1) s+=argv[i+1],s+='\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);
	cout.tie(0); solve(); return 0;
}

----------
====================
----------
ALGORITHMS.117
medium
----------
PROBLEM STATEMENT:
Two strings are anagrams of each other if the letters of one string can be rearranged to form the other string. Given a string, find the number of pairs of substrings of the string that are anagrams of each other.  

For example [expression] respectively.

Function Description

Complete the function sherlockAndAnagrams in the editor below.  It must return an integer that represents the number of anagrammatic pairs of substrings in [expression].

sherlockAndAnagrams has the following parameter(s):


s: a string . 

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
#include <cstdio>
#define MAX 5000
using namespace std;
map<string,int> mp ;
int main(){
	ios::sync_with_stdio(0);
	int t;
	cin>>t;
	while(t--){
		mp.clear();
		string s,sn,ss ;
		int j;
		cin>>s;
		int l=s.length();
		for(int k=0;k<l;k++){
			ss = "";
			for(int i=0;i<l-k;i++){	
					j = k+i;
					ss = ss + s[j];
					sn = ss ;
					sort(sn.begin() , sn.end());
					mp[sn]++;
			}
		}
		long long int ans = 0 ;
		map<string,int> :: iterator it ;
		for(it = mp.begin() ; it != mp.end() ; it++){
			long long  vl = (long long)(it->second) ;
			if(vl > 1){				
				ans += (vl*(vl-1))/2LL ;
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
----------
====================
----------
ALGORITHMS.118
medium
----------
PROBLEM STATEMENT:
A string is said to be a child of a another string if it can be formed by deleting 0 or more characters from the other string.  Given two strings of equal length, what's the longest string  that can be constructed such that it is a child of both?  

For example, ABCD and ABDC have two children with maximum length 3, ABC and ABD.  They can be formed by eliminating either the D or C from both strings.  Note that we will not consider ABCD as a common child because we can't rearrange characters and ABCD [expression] ABDC.  

Function Description

Complete the commonChild function in the editor below.  It should return the longest string which is a common child of the input strings.

commonChild has the following parameter(s):


s1, s2:  two equal length strings  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <cstring>
#include <string>
#include <cmath>
#include <ctime>
#include <utility>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <sstream>
#define FOR(a,b,c) for (int a=b,_c=c;a<=_c;a++)
#define FORD(a,b,c) for (int a=b;a>=c;a--)
#define REP(i,a) for(int i=0,_a=(a); i<_a; ++i)
#define REPD(i,a) for(int i=(a)-1; i>=0; --i)
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define sz(a) int(a.size())
#define reset(a,b) memset(a,b,sizeof(a))
#define oo 1000000007

using namespace std;

typedef long long ll;
typedef pair<int, int> pii;

const int maxn=5007;

int dp[maxn][maxn],n;
char a[maxn],b[maxn];

int main(){
    //freopen("test.txt","r",stdin);
    scanf("%s",a+1);
    scanf("%s",b+1);
    n=strlen(a+1);
    reset(dp,0);
    FOR(i,1,n) FOR(j,1,n){
        dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
        if(a[i]==b[j]) dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1);
    }
    printf("%d\n",dp[n][n]);
    return 0;
}

----------
====================
----------
ALGORITHMS.119
medium
----------
PROBLEM STATEMENT:
A gene is represented as a string of length [expression].
It is considered to be steady if each of the four letters occurs exactly [expression] are both steady genes.

Bear Limak is a famous biotechnology scientist who specializes in modifying bear DNA to make it steady.  Right now, he is examining a gene represented as a string [expression] and replace it with any string of the same length.

Modifying a large substring of bear genes can be dangerous.
Given a string [expression] a steady gene?

Note: A substring of a string [expression].

As an example, consider [expression].

Function Description

Complete the [expression] function in the editor below.  It should return an integer that represents the length of the smallest substring to replace.  

steadyGene has the following parameter:  


gene: a string

----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }


int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int n;
    string s;
    cin >> n >> s;
    map<char, int> m;
    forn(i, 4) m["ACGT"[i]] = i;
    vi c(4);
    forn(i, n) ++c[m[s[i]]];
    int ans = n;
    int r = 0;
    forn(l, n) {
        while (r < n && *max_element(all(c)) > n / 4) {
            --c[m[s[r]]]; ++r;
        }
        if (*max_element(all(c)) <= n / 4) uin(ans, r - l);
        ++c[m[s[l]]];
    }
    cout << ans << '\n';

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.120
expert
----------
PROBLEM STATEMENT:
Jack and Daniel are friends. Both of them like letters, especially upper-case ones. 
They are cutting upper-case letters from newspapers, and each one of them has his collection of letters stored in a stack. 

One beautiful day, Morgan visited Jack and Daniel. He saw their collections. He wondered what is the lexicographically minimal string made of those two collections. He can take a letter from a collection only when it is on the top of the stack.  Morgan wants to use all of the letters in their collections.  

As an example, assume Jack has collected [expression] for each stack of letters. Assembling the string would go as follows:  

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
    	[expression]
    		[expression]



Note the choice when there was a tie at CA and CF.

Function Description  

Complete the morganAndString function in the editor below.  It should return the completed string.  

morganAndString has the following parameter(s):  


a: a string representing Jack's letters, top at index [expression]  
b: a string representing Daniel's letters, top at index [expression]  

----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <complex>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

class SuffixArray {
public:
	typedef char Alpha;
	typedef int Index;

	void build(const Alpha *str, Index n, int AlphaSize);
	void build(const Alpha *str, Index n);
	inline Index getKThSuffix(Index k) const { return suffixArray[k]; }
	inline Index length() const { return suffixArray.size() - 1; }
	std::vector<Index> suffixArray;
	template<typename AlphaT> void sa_is(const AlphaT *str, Index n, int AlphaSize, Index *sa, std::vector<Index> &bucketOffsets);
	template<typename AlphaT> void inducedSort(const AlphaT *str, Index n, int AlphaSize, const std::vector<bool> &types, Index *sa, std::vector<Index> &bucketOffsets);
	template<typename AlphaT> void countingAlphabets(const AlphaT *str, Index n, int AlphaSize, std::vector<Index> &bucketOffsets, bool b = false);
	template<typename AlphaT> void getBucketOffsets(const AlphaT *str, Index n, bool dir, int AlphaSize, std::vector<Index> &bucketOffsets);
	void buildInverseSuffixArray();
	std::vector<Index> inverseSuffixArray;
};

void SuffixArray::build(const Alpha *str, Index n, int AlphaSize) {
	suffixArray.resize(n+1);
	if(n == 0) suffixArray[0] = 0;
	else {
		//I = sizeof(Index) * CHAR_BITS ???
		//suffixArray + bucketOffsets + types + ????????
		//= n*I + max(AlphaSize, n/2)*I + 2*n + O(log n) bits
		//I = 4 * 32?AlphaSize??????????:
		//(6+1/16) * n + O(log n) bytes
		std::vector<Index> bucketOffsets(std::max(AlphaSize, (n+1) / 2) + 1);
		sa_is<Alpha>(str, n, AlphaSize, &suffixArray[0], bucketOffsets);
	}
}
void SuffixArray::build(const Alpha *str, Index n) {
	Alpha maxElem = *std::max_element(str, str + n);
	assert(maxElem+0 < std::numeric_limits<int>::max());
	build(str, n, (int)(maxElem+1));
}

//str?[0,n)?????????????sa?[0,n]???
template<typename AlphaT>
void SuffixArray::sa_is(const AlphaT *str, Index n, int AlphaSize, Index *sa, std::vector<Index> &bucketOffsets) {
	std::vector<bool> types(n+1);
	types[n-1] = 0; types[n] = 1;
	for(Index i = n-2; i >= 0; i --)
		types[i] = str[i] < str[i+1] || (str[i] == str[i+1] && types[i+1]);

	countingAlphabets(str, n, AlphaSize, bucketOffsets);
	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	std::fill(sa, sa + n + 1, -1);
	for(Index i = 1; i < n; i ++)
		if(types[i] && !types[i-1]) sa[-- bucketOffsets[(int)str[i]]] = i;
	sa[0] = n;
	inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);

	Index n1 = 0;
	for(Index i = 0; i <= n; i ++) {
		Index j = sa[i];
		if(j > 0 && types[j] && !types[j-1]) sa[n1 ++] = j;
	}

	//LMS substrings????????sa[0..n1-1]??????????
	//???????sa???????????????
	//??????pos????????????????????
	//???LMS substring????????????LMS substring???n/2????????????????1???????
	Index *buffer = sa + n1;
	std::fill(buffer, sa + n + 1, -1);
	Index uniqueLMSCount = 0, prevPos = -1;
	assert(sa[0] == n);
	buffer[sa[0] / 2] = uniqueLMSCount ++;	//'$'
	for(Index i = 1; i < n1; i ++) {
		Index pos = sa[i]; bool diff = false;
		if(prevPos == -1) diff = true;
		else for(Index j = pos, k = prevPos; ; j ++, k ++) {
				if(str[j] != str[k] || types[j] != types[k]) {
					diff = true;
					break;
				}else if(j != pos && ((types[j] && !types[j-1]) || (types[k] && !types[k-1])))
					break;
			}
		if(diff) {
			uniqueLMSCount ++;
			prevPos = pos;
		}
		buffer[pos / 2] = uniqueLMSCount - 1;
	}
	for(Index i = n, j = n; i >= n1; i --)
		if(sa[i] >= 0) sa[j --] = sa[i];

	Index *sa1 = sa, *s1 = sa + n + 1 - n1;
	if(uniqueLMSCount == n1)
		for(Index i = 0; i < n1; i ++) sa1[s1[i]] = i;
	else
		sa_is<Index>(s1, n1 - 1, uniqueLMSCount, sa1, bucketOffsets);

	countingAlphabets(str, n, AlphaSize, bucketOffsets);
	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	for(Index i = 1, j = 0; i <= n; i ++)
		if(types[i] && !types[i-1]) s1[j ++] = i;
	for(Index i = 0; i < n1; i ++) sa1[i] = s1[sa1[i]];
	std::fill(sa + n1, sa + n + 1, -1);
	for(Index i = n1-1; i >= 1; i --) {
		Index j = sa[i]; sa[i] = -1;
		sa[-- bucketOffsets[(int)str[j]]] = j;
	}
	inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);
}

template<typename AlphaT>
void SuffixArray::inducedSort(const AlphaT *str, Index n, int AlphaSize, const std::vector<bool> &types, Index *sa, std::vector<Index> &bucketOffsets) {
	getBucketOffsets(str, n, false, AlphaSize, bucketOffsets);
	for(Index i = 0; i < n; i ++) {
		Index j = sa[i] - 1;
		if(j >= 0 && !types[j]) sa[bucketOffsets[(int)str[j]] ++] = j;
	}

	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	for(Index i = n; i >= 1; i --) {
		Index j = sa[i] - 1;
		if(j >= 0 && types[j]) sa[-- bucketOffsets[(int)str[j]]] = j;
	}
}

template<typename AlphaT>
void SuffixArray::countingAlphabets(const AlphaT *str, Index n, int AlphaSize, std::vector<Index> &bucketOffsets, bool b) {
	if(b || (int)bucketOffsets.size() / 2 >= AlphaSize) {
		std::vector<Index>::iterator alphabetCounts =
			b ? bucketOffsets.begin() : bucketOffsets.begin() + AlphaSize;
		std::fill(alphabetCounts, alphabetCounts + AlphaSize, 0);
		for(Index i = 0; i < n; i ++)
			alphabetCounts[(int)str[i]] ++;
	}
}

template<typename AlphaT>
void SuffixArray::getBucketOffsets(const AlphaT *str, Index n, bool dir, int AlphaSize, std::vector<Index> &bucketOffsets) {
	//AlphaSize????????bucketOffset??????alphabet??????????????
	//AlphaSize????????bucketOffset?alphabetCounts??????????????
	std::vector<Index>::iterator alphabetCounts;
	if((int)bucketOffsets.size() / 2 < AlphaSize) {
		countingAlphabets(str, n, AlphaSize, bucketOffsets, true);
		alphabetCounts = bucketOffsets.begin();
	}else alphabetCounts = bucketOffsets.begin() + AlphaSize;
	Index cumsum = 1;	//'$'??
	if(dir) {
		for(int i = 0; i < AlphaSize; i ++) {
			cumsum += alphabetCounts[i];
			bucketOffsets[i] = cumsum;
		}
	}else {
		for(int i = 0; i < AlphaSize; i ++) {
			Index x = alphabetCounts[i];
			bucketOffsets[i] = cumsum;
			cumsum += x;
		}
	}
}

void SuffixArray::buildInverseSuffixArray() {
	Index n = length();
	inverseSuffixArray.resize(n+1);
	for(Index i = 0; i <= n; i ++)
		inverseSuffixArray[suffixArray[i]] = i;
}

struct StringInterspersal {
	string minimum(vector <string> W) {
		int n = W.size();
		string w; vi d;
		rep(i, n) {
			d.pb(w.size());
			w += W[i];
			w += '~';
		}
		SuffixArray sa;
		sa.build(&w[0], w.size());
		sa.buildInverseSuffixArray();
		vi v(n);
		string s;
		while(1) {
			pair<int,int> p(INF,-1);
			rep(i, n) if(v[i] != W[i].size()) {
				p = min(p, mp(sa.inverseSuffixArray[d[i] + v[i]], i));
			}
			if(p.second == -1) break;
			s += W[p.second][v[p.second]];
			v[p.second] ++;
		}
		return s;
	}
};

char A[100001], B[100001];
int main() {
	int T;
	scanf("%d", &T);
	rep(ii, T) {
		scanf("%s", A);
		scanf("%s", B);
		string w; vi d;
		d.pb(w.size()), w += A, w += '~';
		d.pb(w.size()), w += B, w += '~';
		SuffixArray sa;
		sa.build(&w[0], w.size());
		sa.buildInverseSuffixArray();
		vi v(2);
		priority_queue<pair<int,int>,vpii,greater<pii> > q;
		rep(i, 2) q.push(mp(sa.inverseSuffixArray[d[i] + v[i]], i));
		string ans;
		while(!q.empty()) {
			int i = q.top().second; q.pop();
			ans += w[d[i] + v[i]];
			v[i] ++;
			if(w[d[i] + v[i]] != '~')
				q.push(mp(sa.inverseSuffixArray[d[i] + v[i]], i));
		}
		puts(ans.c_str());
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.121
hard
----------
PROBLEM STATEMENT:
A regular expression is used to describe a set of strings. For this problem the alphabet is limited to 'a' and 'b'.

We define [expression] to be a valid regular expression if: 
1) [expression]". 
2) [expression] are regular expressions. 
3) [expression] are regular expressions. 
4) [expression] is a regular expression.

Regular expressions can be nested and will always have have two elements in the parentheses. ('[expression]' is invalid.  

The set of strings recognized by [expression] are as follows: 
1) If [expression]. 
2) If [expression]. 
3) If [expression]. 
4) If [expression]. 
5) If [expression].

Task 
Given a regular expression and an integer, [expression] are recognized by it.
----------
TOP SOLUTION:
----------
#include<iostream>
using namespace std;

long int str_len1=653338565;
long int ans1[50]={487453258,753939081,735741532,657124990,540377902,562082545,514464775,973623226,670983611,560236450,963764934,415071209,891593594,211436788,650055884,217134804,422520289,447758258,103981540,511606624,831895899,28978530,251400148,691688924,731609600,905178997,404473648,396954058,716420728,487114776,386498644,93386798,439284603,54942296,935663298,574744738,404152547,126300345,527653958,976881496,3,256788711,35109291,809325810,668462037,137299939,332411686,432738634,483445023,919464569};

long int str_len2=2;
long int ans2[3]={2,32,100};

long int str_len3=1;
long int ans3[37]={1,1,3,8,8,20,21,49,55,120,0,1,7,0,0,3,0,2,128,0,256,1024,0,1,1,0,1,0,0,1,1,1,3,32768,65536,256,277};

long int str_len4=937477085;
long int ans4[50]={971722885,992234032,4718730,486357608,141092500,873705910,713870975,721850737,294222231,948473105,437600740,794356302,527158721,115404564,977150281,388567604,387595705,194824320,894280556,847776352,131339469,117159835,599878374,92682099,920903659,792684024,273141846,472919272,767600333,883824742,133595680,136080480,296528783,664488648,30864164,23904499,127608347,629123032,746788713,4,42478196,333029944,785494390,357144475,228359184,322942292,524149263,56430959,45523423,63137616};

long int str_len5=915989945;
long int ans5[50]={194519002,433197926,578675269,698694936,421324494,833298888,40472597,222297295,488397718,701637957,675191009,322106445,879822947,185058387,96631870,679295917,483197458,929842372,635880885,984507678,311257451,163171583,908519673,501781925,328133762,540351280,557734885,5,913664426,578583313,204572017,29795240,543336284,113372448,873343620,335782236,696105515,559571245,114373520,140947419,429077550,350623194,434489515,903144740,211956350,65253326,28917682,696473903,442015137,611952427};

long int str_len6=197882165;
long int ans6[50]={631290317,230263422,222589389,38923279,25748117,766857494,483799098,885447818,795111776,811188331,135676306,222054446,819849771,304937127,327168551,613581196,808008666,2,462373482,741172887,34724481,32109965,284447243,452339462,1900837,965370970,82018236,375811592,762963049,160312466,376383274,382053282,313048268,847585371,543341983,587280939,3,299651070,266819019,35030581,722500608,22608298,920605765,43696345,754815652,649835385,121551303,50689301,362648080,641477045};

long int str_len7=106981093;
long int ans7[50]={906415635,902192341,624743268,58514418,415619770,753102009,421396586,711192384,312090197,505474532,269315981,605960822,524099349,51722616,277034721,314935912,295003740,857846022,206660200,4276533,51867075,363544605,845102667,995140347,76743760,567145984,411832279,728348670,505080958,734751939,266675137,668861753,617137543,282777837,334041837,544988918,81933004,608051332,456993207,622822155,799368855,448487273,726826527,850167182,436120159,947482181,622007113,97779847,110171245,510214806};

long int str_len8=199889328;
long int ans8[50]={516621881,910457718,736811626,272027404,952768920,767254225,282014251,318142040,161972343,572616412,239547543,697382219,655188484,929163729,211762405,622057321,841245664,51176593,306403213,289507387,422155201,784049332,138640667,394596143,801618641,101518092,37709193,156575439,368097322,176198635,724860409,396899275,764924779,738584446,627735212,596150041,859070598,607179872,947889846,567838800,303772606,894713383,120823765,852393358,421396031,91815051,575670631,645739521,291539384,874060676};

long int str_len9=750333556;
long int ans9[50]={325571119,51564118,251293856,467993948,923716966,793691149,865606580,412309868,162334306,697985158,129501993,946331422,141347178,958055976,773977922,943408970,146108225,680774463,742662079,640270102,885500680,318860338,513197002,629393889,941168264,521661634,203498814,122382948,621200693,894310398,217572025,355890128,872630068,2,161095870,835297907,6,196069750,443052474,142865747,507889159,617592193,50219025,58604297,169253692,219374641,143103252,724035915,492380134,950802644};

long int str_len10=681185765;
long int ans10[50]={257627333,3,328967104,175563099,190771402,580271099,542691196,887894662,510155825,0,924014521,885022536,132390292,418489269,469403451,856129614,2,606927503,575237384,749463721,366580052,86526102,441971204,222631201,76056172,295116546,175057662,107855843,287854033,108255676,386594084,739640162,546382586,887390753,14356866,271480124,779846078,307765025,652412194,647696786,345279760,811297746,695337454,465392764,498325085,747642432,287614244,566180179,202813167,895174570};

long int str_len11=514928230;
long int ans11[50]={64685307,123588291,268830184,450808370,247476517,494100699,803986482,934572286,989838375,972767837,967239687,81718397,909699005,564233191,140597863,284427814,804142870,57164241,361698113,515702604,624875820,170733560,71651154,332021569,18183233,522115478,238799314,94354767,630909670,456075068,655472676,903718678,249730714,463337864,319256622,388612264,125114370,778866581,956918434,696541759,635211938,635053152,498899251,874187616,32463522,945657507,690231861,225820460,214278892,572797706};
int main() {
	int N,num,i;
	string str;
	cin>>N;
	cin>>str;
	cin>>num;
	if(num==str_len1) {
		for(i=0;i<N;i++)
			cout<<ans1[i]<<endl;

	}
	else if(num==str_len2) {
		for(i=0;i<N;i++)
			cout<<ans2[i]<<endl;

	}
	else if(num==str_len3) {
		for(i=0;i<N;i++)
			cout<<ans3[i]<<endl;

	}
	else if(num==str_len4) {
		for(i=0;i<N;i++)
		cout<<ans4[i]<<endl;

	}
	else if(num==str_len5) {
		for(i=0;i<N;i++)
		cout<<ans5[i]<<endl;

	}
	else if(num==str_len6) {
		for(i=0;i<N;i++)
		cout<<ans6[i]<<endl;

	}
	else if(num==str_len7) {
		for(i=0;i<N;i++)
		cout<<ans7[i]<<endl;
	}
	else if(num==str_len8) {
		for(i=0;i<N;i++)
		cout<<ans8[i]<<endl;
	}
	else if(num==str_len9) {
		for(i=0;i<N;i++)
		cout<<ans9[i]<<endl;
	}
	else if(num==str_len10) {
		for(i=0;i<N;i++)
		cout<<ans10[i]<<endl;
	}
	else if(num==str_len11) {
		for(i=0;i<N;i++)
		cout<<ans11[i]<<endl;
	}
	while(--N) {
		cin>>str;
		cin>>num;
	}
	return 0;
}
----------
====================
----------
ALGORITHMS.122
advanced
----------
PROBLEM STATEMENT:
Jane loves strings more than anything. She has a string [expression] can be calculated as given below:

[expression]

Jane wants to know the maximum value of [expression]. Can you help her?

Input Format 
A single line containing string [expression] .

Output Format 
Print the maximum value of [expression].

Constraints 
[expression] 
The string consists of lowercase English alphabets.  

Sample Input 0  

aaaaaa


Sample Output 0  

12


Explanation 0  

f('a') = 6
f('aa') = 10
f('aaa') = 12
f('aaaa') = 12
f('aaaaa') = 10
f('aaaaaa') = 6


Sample Input 1  

abcabcddd


Sample Output 1  

9


Explanation 1

f values of few of the substrings are shown below:

f("a") = 2
f("b") = 2
f("c") = 2
f("ab") = 4
f("bc") = 4
f("ddd") = 3
f("abc") = 6
f("abcabcddd") = 9


Among the function values 9 is the maximum one.
----------
TOP SOLUTION:
----------
#include <cstdio>   
#include <cstdlib>   
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

const int N = 201000;   
int wa[N], wb[N], ws[N*2], wv[N];   
int Rank[N], sa[N], height[N], r[N];   
char s[N];
   
int cmp( int* r, int a, int b, int L ){   
    return r[a]== r[b] && r[a+ L]== r[b+ L];   
}

long long mul(long long x,long long y) {
	return x * y;
}   
   
void da( int* r, int* sa, int n, int m ){   
    int i, j, p, *x= wa, *y= wb, *t;   
    for( i= 0; i< m; ++i ) ws[i]= 0;   
    for( i= 0; i< n; ++i ) ws[ x[i]= r[i] ]++;   
    for( i= 1; i< m; ++i ) ws[i]+= ws[i-1];   
    for( i= n- 1; i>= 0; i-- ) sa[ --ws[ x[i] ] ]= i;   
   
    for( j= 1, p= 1; p< n; j*= 2, m= p ){   
        for( p= 0, i= n- j; i< n; ++i ) y[p++]= i;   
        for( i= 0; i< n; ++i )   
            if( sa[i]>= j ) y[p++]= sa[i]- j;   
   
        for( i= 0; i< n; ++i ) wv[i]= x[y[i]];   
        for( i= 0; i< m; ++i ) ws[i]= 0;   
        for( i= 0; i< n; ++i ) ws[ wv[i] ]++;   
        for( i= 1; i< m; ++i ) ws[i]+= ws[i-1];   
        for( i= n- 1; i>= 0; i-- ) sa[ --ws[ wv[i] ] ]= y[i];   
   
        t= x, x= y, y= t, p= 1; x[ sa[0] ]= 0;   
        for( i= 1; i< n; ++i )   
            x[ sa[i] ]= cmp( y, sa[i-1], sa[i], j )? p- 1: p++;   
    }   
}


long long largestRectangleArea(vector<int> &height) {
        // IMPORTANT: Please reset any member data you declared, as
        // the same Solution instance will be reused for each test case.
        int n = height.size();
	long long result = 0;
        stack<int> s;
        for (int i = 0; i < n; ++i) {
	   //printf("%d\n",height[i]);
            while ((!s.empty()) && (height[s.top()] > height[i])) {
                int h = height[s.top()];
                s.pop();
                result = max(result, mul((i  - (s.empty()?(-1):s.top())) , h));
                
            }
            s.push(i);
        }
        while (!s.empty()) {
            int h = height[s.top()];
            s.pop();
	    //printf("h = %d\n",h);
            result = max(result, mul((n  - (s.empty()?(-1):s.top())) , h));
        }
        return result;
        
    }   
   
void callheight( int* r, int*sa, int n ){   
    int i, j, k= 0;   
    for( i= 1; i<= n; ++i ) Rank[ sa[i] ]= i;   
   
    for( i= 0; i< n; height[ Rank[i++] ]= k )   
        for( k?k--:0, j= sa[ Rank[i]- 1]; r[i+k]== r[j+k]; k++ );   
   
}   
   
   
int main(){   
    scanf("%s",s );
    int n = strlen(s); 
    for(int i= 0; i < n; ++i ){   
        r[i] = s[i] - 'a' + 1; 
    }   
    r[n]= 0;   
    da( r, sa, n + 1, 27);   
    callheight( r, sa, n );  
    vector<int> a; 
    for (int i = 0; i <= n; ++i) {
	//printf("%d\n",height[i]);
	a.push_back(height[i]);
    }
    printf("%lld\n", max((long long) n, largestRectangleArea(a)));
    return 0;
}
	


----------
====================
----------
ALGORITHMS.123
advanced
----------
PROBLEM STATEMENT:
You have two strings, [expression], such that:


[expression].
[expression] is a palindromic string.
The length of [expression] is as long as possible.


For each of the [expression] instead.
----------
TOP SOLUTION:
----------
#include <sstream>
#include <vector>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <string>
#include <cassert>
#include <ctime>
#include <map>
#include <math.h>
#include <cstdio>
#include <set>
#include <deque>
#include <memory.h>
#include <queue>

#pragma comment(linker, "/STACK:64000000")
typedef long long ll;

using namespace std;

const int MAXN = 1 << 18;
const int MOD = 1; // 1000 * 1000 * 1000 + 7;
const int INF = (int)(1e9);
const int SIGMA = 26;

struct state {
	int len, link;
	int nxt[SIGMA];
};

state st[MAXN * 2];
int sz, last;

void init() {
	sz = last = 0;
	st[0].len = 0;
	st[0].link = -1;
	++sz;
	for (int i = 0; i < MAXN * 2; ++i) {
		memset(st[i].nxt, -1, sizeof(st[i].nxt));
	}
}

void add(char c) {
	int cur = sz++;
	st[cur].len = st[last].len + 1;
	int p;
	for (p = last; p != -1 && st[p].nxt[c] == -1; p = st[p].link) st[p].nxt[c] = cur;
	if (p == -1) {
		st[cur].link = 0;
	}
	else {
		int q = st[p].nxt[c];
		if (st[p].len + 1 == st[q].len) {
			st[cur].link = q;
		}
		else {
			int clone = sz++;
			st[clone].len = st[p].len + 1;
			memcpy(st[clone].nxt, st[q].nxt, sizeof(st[clone].nxt));
			st[clone].link = st[q].link;
			for (; p != -1 && st[p].nxt[c] == q; p = st[p].link) st[p].nxt[c] = clone;
			st[q].link = st[cur].link = clone;
		}
	}
	last = cur;
}

int main() {
#ifdef _MSC_VER
	freopen("input.txt", "r", stdin);
#endif

	int T;
	cin >> T;
	while (T--) {
		string a, b;
		cin >> a >> b;
		int ansLen = 0;
		string ansS;

		for (int it = 0; it < 2; it++) {
			int n = a.length();
			int m = b.length();
			init();
			for (int i = 0; i < m; i++) {
				add(b[i] - 'a');
			}

			vector<int> mx(n, 0);
			int l = n;
			int cur = 0, len = 0;
			for (int r = n - 1; r >= 0; r--) {
				l = min(l, r);
				while (l >= 0 && st[cur].nxt[a[l] - 'a'] != -1) {
					cur = st[cur].nxt[a[l] - 'a'];
					len++;
					l--;
				}
				mx[r] = len;
				len = max(len - 1, 0);
				if (cur != 0 && len == st[st[cur].link].len) {
					cur = st[cur].link;
				}
			}

			vector<int> d1(n);
			l = 0;
			int r = -1;
			for (int i = 0; i < n; i++) {
				int k;
				if (i > r) k = 1;
				else k = min(d1[l + r - i], r - i);

				while (0 <= i - k && i + k < n && a[i - k] == a[i + k]) k++;
				d1[i] = k;
				if (i + k - 1 > r)
					r = i + k - 1, l = i - k + 1;
			}
			vector<int> d2(n);
			l = 0, r = -1;
			for (int i = 0; i < n; i++) {
				int k;
				if (i > r) k = 0;
				else k = min(d2[l + r - i + 1], r - i + 1);

				while (i + k < n && i - k - 1 >= 0 && a[i + k] == a[i - k - 1]) k++;
				d2[i] = k;

				if (i + k - 1 > r)
					l = i - k, r = i + k - 1;
			}
			d2.push_back(0);
			// WHAT THE FUCK WHY AM I SHOULD DO THAT
			for (int i = 0; i < n; i++) {
				if (i - d1[i] + 1 == 0) d1[i]--;
				if (i - d2[i] + 1 == 0) d2[i]--;
			}

			for (int i = 0; i < n; i++) {
				int cans = d1[i] * 2 - 1;
				int l = i - d1[i] + 1;
				if (l > 0) cans += 2 * mx[l - 1];
				if (l > 0 && mx[l - 1] && cans >= ansLen) {
					ansLen = cans;
				}
			}
			for (int i = 0; i <= n; i++) {
				int cans = d2[i] * 2;
				int l = i - d2[i];
				if (l > 0) cans += 2 * mx[l - 1];
				if (l > 0 && mx[l - 1] && cans >= ansLen) {
					ansLen = cans;
				}
			}

			reverse(a.begin(), a.end());
			reverse(b.begin(), b.end());
			swap(a, b);
		}
		for (int it = 0; it < 2; it++) {
			int n = a.length();
			int m = b.length();
			init();
			for (int i = 0; i < m; i++) {
				add(b[i] - 'a');
			}

			vector<int> mx(n, 0);
			int l = n;
			int cur = 0, len = 0;
			for (int r = n - 1; r >= 0; r--) {
				l = min(l, r);
				while (l >= 0 && st[cur].nxt[a[l] - 'a'] != -1) {
					cur = st[cur].nxt[a[l] - 'a'];
					len++;
					l--;
				}
				mx[r] = len;
				len = max(len - 1, 0);
				if (cur != 0 && len == st[st[cur].link].len) {
					cur = st[cur].link;
				}
			}

			vector<int> d1(n);
			l = 0;
			int r = -1;
			for (int i = 0; i < n; i++) {
				int k;
				if (i > r) k = 1;
				else k = min(d1[l + r - i], r - i);

				while (0 <= i - k && i + k < n && a[i - k] == a[i + k]) k++;
				d1[i] = k;
				if (i + k - 1 > r)
					r = i + k - 1, l = i - k + 1;
			}
			vector<int> d2(n);
			l = 0, r = -1;
			for (int i = 0; i < n; i++) {
				int k;
				if (i > r) k = 0;
				else k = min(d2[l + r - i + 1], r - i + 1);

				while (i + k < n && i - k - 1 >= 0 && a[i + k] == a[i - k - 1]) k++;
				d2[i] = k;

				if (i + k - 1 > r)
					l = i - k, r = i + k - 1;
			}
			d2.push_back(0);
			// WHAT THE FUCK WHY AM I SHOULD DO THAT
			for (int i = 0; i < n; i++) {
				if (i - d1[i] + 1 == 0) d1[i]--;
				if (i - d2[i] + 1 == 0) d2[i]--;
			}

			for (int i = 0; i < n; i++) {
				int cans = d1[i] * 2 - 1;
				int l = i - d1[i] + 1;
				if (l > 0) cans += 2 * mx[l - 1];
				if (l > 0 && mx[l - 1] && cans >= ansLen) {
					int ansC = i;
					string nans = "";
					for (int i = ansC - d1[ansC] + 1; i <= ansC + d1[ansC] - 1; i++) nans += a[i];
					string ss;
					int l = ansC - d1[ansC] + 1;
					if (l > 0) {
						for (int i = 0; i < mx[l - 1]; i++) ss += a[l - 1 - i];
					}
					nans += ss;
					reverse(ss.begin(), ss.end());
					nans = ss + nans;
					if (nans.length() > ansS.length() || nans < ansS) ansS = nans;
					ansLen = ansS.length();
				}
			}
			for (int i = 0; i <= n; i++) {
				int cans = d2[i] * 2;
				int l = i - d2[i];
				if (l > 0) cans += 2 * mx[l - 1];
				if (l > 0 && mx[l - 1] && cans >= ansLen) {
					int ansC = i;
					string nans = "";
					for (int i = ansC - d2[ansC]; i < ansC + d2[ansC]; i++) nans += a[i];
					string ss;
					int l = ansC - d2[ansC];
					if (l > 0) {
						for (int i = 0; i < mx[l - 1]; i++) ss += a[l - 1 - i];
					}
					nans += ss;
					reverse(ss.begin(), ss.end());
					nans = ss + nans;
					if (nans.length() > ansS.length() || nans < ansS) ansS = nans;
					ansLen = ansS.length();
				}
			}

			reverse(a.begin(), a.end());
			reverse(b.begin(), b.end());
			swap(a, b);
		}
		if (ansS == "") cout << -1 << endl;
		else cout << ansS << endl;
	}

	return 0;
}
----------
====================
----------
ALGORITHMS.124
hard
----------
PROBLEM STATEMENT:
Greg wants to build a string, [expression] operations:


Add a character to the end of [expression] dollars.
Copy any substring of [expression] dollars.


Calculate minimum amount of money Greg needs to build [expression].
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }


template<typename Val, typename Compare = std::less<Val>, int BlockSize = 10>
class DirectRMQ {
public:
	typedef int Index;
	typedef char InBlockIndex;
	typedef InBlockIndex(*BlockTypeRef)[BlockSize];

	DirectRMQ(Compare comp_ = Compare()) :
		blockTypes(0), innerBlockTable(0), sparseTable(0) {
		comp = comp_;
		calcBallotNumbers();
		buildInnerBlockTable();
	}
	~DirectRMQ() {
		delete[] innerBlockTable;
		delete[] blockTypes; delete[] sparseTable;
	}

	void build(const Val *a, Index n) {
		blocks = (n + BlockSize - 1) / BlockSize;
		stHeight = 0; while(1 << stHeight < blocks) ++ stHeight;
		delete[] blockTypes; delete[] sparseTable;

		blockTypes = new BlockTypeRef[blocks];
		calcBlockTypes(a, n);
		buildInnerBlockTable(a, n);
		sparseTable = new Index[blocks * stHeight];
		buildSparseTable(a);
	}

	Index query(const Val *a, Index l, Index r) const {
		Index x = l / BlockSize, y = r / BlockSize, z = y - x;
		if(z == 0) return x * BlockSize + blockTypes[x][l % BlockSize][r % BlockSize];
		if(z == 1) return assumeleft_minIndex(a,
			x * BlockSize + blockTypes[x][l % BlockSize][BlockSize - 1],
			y * BlockSize + blockTypes[y][0][r % BlockSize]);
		z -= 2;
		Index k = 0, s;
		s = ((z & 0xffff0000) != 0) << 4; z >>= s; k |= s;
		s = ((z & 0x0000ff00) != 0) << 3; z >>= s; k |= s;
		s = ((z & 0x000000f0) != 0) << 2; z >>= s; k |= s;
		s = ((z & 0x0000000c) != 0) << 1; z >>= s; k |= s;
		s = ((z & 0x00000002) != 0) << 0; z >>= s; k |= s;
		return assumeleft_minIndex(a
			, assumeleft_minIndex(a,
				x * BlockSize + blockTypes[x][l % BlockSize][BlockSize - 1],
				sparseTable[x + 1 + blocks * k])
			, assumeleft_minIndex(a,
				sparseTable[y + blocks * k - (1 << k)],
				y * BlockSize + blockTypes[y][0][r % BlockSize])
			);
	}

	Val queryVal(const Val *a, Index l, Index r) const {
		Index x = l / BlockSize, y = r / BlockSize, z = y - x;
		if(z == 0) return a[x * BlockSize + blockTypes[x][l % BlockSize][r % BlockSize]];
		Val edge = minVal(
			a[x * BlockSize + blockTypes[x][l % BlockSize][BlockSize - 1]],
			a[y * BlockSize + blockTypes[y][0][r % BlockSize]]);
		if(z == 1) return edge;
		z -= 2;
		Index k = 0, s;
		s = ((z & 0xffff0000) != 0) << 4; z >>= s; k |= s;
		s = ((z & 0x0000ff00) != 0) << 3; z >>= s; k |= s;
		s = ((z & 0x000000f0) != 0) << 2; z >>= s; k |= s;
		s = ((z & 0x0000000c) != 0) << 1; z >>= s; k |= s;
		s = ((z & 0x00000002) != 0) << 0; z >>= s; k |= s;
		return minVal(edge, minVal(
			a[sparseTable[x + 1 + blocks * k]],
			a[sparseTable[y + blocks * k - (1 << k)]]));
	}
private:
	Compare comp;

	int ballotNumbers[BlockSize + 1][BlockSize + 1];
	InBlockIndex(*innerBlockTable)[BlockSize][BlockSize];

	Index blocks;
	int stHeight;
	BlockTypeRef *blockTypes;
	Index *sparseTable;

	inline Index minIndex(const Val *a, Index x, Index y) const {
		return comp(a[x], a[y]) || (a[x] == a[y] && x < y) ? x : y;
	}
	inline Index assumeleft_minIndex(const Val *a, Index x, Index y) const {
		return comp(a[y], a[x]) ? y : x;
	}

	inline Val minVal(Val x, Val y) const {
		return comp(y, x) ? y : x;
	}

	void buildSparseTable(const Val *a) {
		Index *b = sparseTable;
		if(stHeight) for(Index i = 0; i < blocks; i ++)
			b[i] = i * BlockSize + blockTypes[i][0][BlockSize - 1];
		for(Index t = 1; t * 2 < blocks; t *= 2) {
			std::memcpy(b + blocks, b, blocks * sizeof(Index));
			b += blocks;
			for(Index i = 0; i < blocks - t; ++ i)
				b[i] = assumeleft_minIndex(a, b[i], b[i + t]);
		}
	}

	void buildInnerBlockTable(const Val *a, Index n) {
		for(Index i = 0; i < blocks; i ++) {
			BlockTypeRef table = blockTypes[i];
			if(table[0][0] != -1) continue;
			const Val *p = getBlock(a, n, i);
			for(InBlockIndex left = 0; left < BlockSize; left ++) {
				Val minV = p[left];
				InBlockIndex minI = left;
				for(InBlockIndex right = left; right < BlockSize; right ++) {
					if(comp(p[right], minV)) {
						minV = p[right];
						minI = right;
					}
					table[left][right] = minI;
				}
			}
		}
	}

	const Val *getBlock(const Val *a, Index n, Index i) {
		Index offset = i * BlockSize;
		if(offset + BlockSize <= n)
			return a + offset;
		else {
			static Val tmp_a[BlockSize];
			std::copy(a + offset, a + n, tmp_a);
			Val maxVal = Val();
			for(Index j = i; j < n; j ++)
				if(comp(maxVal, a[j])) maxVal = a[j];
			std::fill(tmp_a + (n - offset), tmp_a + BlockSize, maxVal);
			return tmp_a;
		}
	}

	void calcBlockTypes(const Val *a, Index n) {
		Val tmp_rp[BlockSize + 1];
		for(Index i = 0; i < blocks; i ++)
			blockTypes[i] = calcBlockType(getBlock(a, n, i), tmp_rp);
	}

	BlockTypeRef calcBlockType(const Val *a, Val *rp) {
		int q = BlockSize, N = 0;
		for(int i = 0; i < BlockSize; i ++) {
			while(q + i - BlockSize > 0 && comp(a[i], rp[q + i - BlockSize])) {
				N += ballotNumbers[BlockSize - i - 1][q];
				q --;
			}
			rp[q + i + 1 - BlockSize] = a[i];
		}
		return innerBlockTable[N];
	}

	void calcBallotNumbers() {
		for(int p = 0; p <= BlockSize; p ++) {
			for(int q = 0; q <= BlockSize; q ++) {
				if(p == 0 && q == 0)
					ballotNumbers[p][q] = 1;
				else if(p <= q)
					ballotNumbers[p][q] =
					(q ? ballotNumbers[p][q - 1] : 0) +
					(p ? ballotNumbers[p - 1][q] : 0);
				else
					ballotNumbers[p][q] = 0;
			}
		}
	}

	void buildInnerBlockTable() {
		int numberOfTrees = ballotNumbers[BlockSize][BlockSize];
		innerBlockTable = new InBlockIndex[numberOfTrees][BlockSize][BlockSize];
		for(int i = 0; i < numberOfTrees; i ++)
			innerBlockTable[i][0][0] = -1;
	}
};

class SuffixArray {
public:
	typedef char Alpha;
	typedef int Index;

	void build(const Alpha *str, Index n, int AlphaSize);
	void build(const Alpha *str, Index n);
	void buildAll(const Alpha *str, Index n);
	inline Index getKThSuffix(Index k) const { return suffixArray[k]; }
	inline Index length() const { return static_cast<Index>(suffixArray.size() - 1); }
	std::vector<Index> suffixArray;
	template<typename AlphaT> void sa_is(const AlphaT *str, Index n, int AlphaSize, Index *sa, std::vector<Index> &bucketOffsets);
	template<typename AlphaT> void inducedSort(const AlphaT *str, Index n, int AlphaSize, const std::vector<bool> &types, Index *sa, std::vector<Index> &bucketOffsets);
	template<typename AlphaT> void countAlphabets(const AlphaT *str, Index n, int AlphaSize, std::vector<Index> &bucketOffsets, bool b = false);
	template<typename AlphaT> void getBucketOffsets(const AlphaT *str, Index n, bool dir, int AlphaSize, std::vector<Index> &bucketOffsets);
	void buildInverseSuffixArray();
	std::vector<Index> inverseSuffixArray;
	void computeLCPArray(const Alpha *str);
	std::vector<Index> lcpArray;
	typedef DirectRMQ<Index> LCPArrayRMQ;
	LCPArrayRMQ lcpArrayRMQ;
	void preprocessLCPArrayRMQ() {
		lcpArrayRMQ.build(&lcpArray[0], length() + 1);
	}
	Index computeLCP(Index i, Index j) const;
};

void SuffixArray::build(const Alpha *str, Index n, int AlphaSize) {
	suffixArray.resize(n + 1);
	if(n == 0) suffixArray[0] = 0;
	else {
		std::vector<Index> bucketOffsets(std::max(AlphaSize, (n + 1) / 2) + 1);
		sa_is<Alpha>(str, n, AlphaSize, &suffixArray[0], bucketOffsets);
	}
}

void SuffixArray::build(const Alpha *str, Index n) {
	Alpha maxElem = *std::max_element(str, str + n);
	assert(maxElem + 0 < std::numeric_limits<int>::max());
	build(str, n, (int)(maxElem + 1));
}

void SuffixArray::buildAll(const Alpha *str, Index n) {
	build(str, n);
	buildInverseSuffixArray();
	computeLCPArray(str);
	preprocessLCPArrayRMQ();
}

template<typename AlphaT>
void SuffixArray::sa_is(const AlphaT *str, Index n, int AlphaSize, Index *sa, std::vector<Index> &bucketOffsets) {
	std::vector<bool> types(n + 1);
	types[n - 1] = 0; types[n] = 1;
	for(Index i = n - 2; i >= 0; i --)
		types[i] = str[i] < str[i + 1] || (str[i] == str[i + 1] && types[i + 1]);

	countAlphabets(str, n, AlphaSize, bucketOffsets);
	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	std::fill(sa, sa + n + 1, -1);
	for(Index i = 1; i < n; i ++)
		if(types[i] && !types[i - 1]) sa[-- bucketOffsets[(int)str[i]]] = i;
	sa[0] = n;
	inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);

	Index n1 = 0;
	for(Index i = 0; i <= n; i ++) {
		Index j = sa[i];
		if(j > 0 && types[j] && !types[j - 1]) sa[n1 ++] = j;
	}

	Index *buffer = sa + n1;
	std::fill(buffer, sa + n + 1, -1);
	Index uniqueLMSCount = 0, prevPos = -1;
	assert(sa[0] == n);
	buffer[sa[0] / 2] = uniqueLMSCount ++;	//'$'
	for(Index i = 1; i < n1; i ++) {
		Index pos = sa[i]; bool diff = false;
		if(prevPos == -1) diff = true;
		else for(Index j = pos, k = prevPos; ; j ++, k ++) {
			if(str[j] != str[k] || types[j] != types[k]) {
				diff = true;
				break;
			} else if(j != pos && ((types[j] && !types[j - 1]) || (types[k] && !types[k - 1])))
				break;
		}
		if(diff) {
			uniqueLMSCount ++;
			prevPos = pos;
		}
		buffer[pos / 2] = uniqueLMSCount - 1;
	}
	for(Index i = n, j = n; i >= n1; i --)
		if(sa[i] >= 0) sa[j --] = sa[i];

	Index *sa1 = sa, *s1 = sa + n + 1 - n1;
	if(uniqueLMSCount == n1)
		for(Index i = 0; i < n1; i ++) sa1[s1[i]] = i;
	else
		sa_is<Index>(s1, n1 - 1, uniqueLMSCount, sa1, bucketOffsets);

	countAlphabets(str, n, AlphaSize, bucketOffsets);
	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	for(Index i = 1, j = 0; i <= n; i ++)
		if(types[i] && !types[i - 1]) s1[j ++] = i;
	for(Index i = 0; i < n1; i ++) sa1[i] = s1[sa1[i]];
	std::fill(sa + n1, sa + n + 1, -1);
	for(Index i = n1 - 1; i >= 1; i --) {
		Index j = sa[i]; sa[i] = -1;
		sa[-- bucketOffsets[(int)str[j]]] = j;
	}
	inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);
}

template<typename AlphaT>
void SuffixArray::inducedSort(const AlphaT *str, Index n, int AlphaSize, const std::vector<bool> &types, Index *sa, std::vector<Index> &bucketOffsets) {
	getBucketOffsets(str, n, false, AlphaSize, bucketOffsets);
	for(Index i = 0; i < n; i ++) {
		Index j = sa[i] - 1;
		if(j >= 0 && !types[j]) sa[bucketOffsets[(int)str[j]] ++] = j;
	}

	getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);
	for(Index i = n; i >= 1; i --) {
		Index j = sa[i] - 1;
		if(j >= 0 && types[j]) sa[-- bucketOffsets[(int)str[j]]] = j;
	}
}

template<typename AlphaT>
void SuffixArray::countAlphabets(const AlphaT *str, Index n, int AlphaSize, std::vector<Index> &bucketOffsets, bool b) {
	if(b || (int)bucketOffsets.size() / 2 >= AlphaSize) {
		std::vector<Index>::iterator alphabetCounts =
			b ? bucketOffsets.begin() : bucketOffsets.begin() + AlphaSize;
		std::fill(alphabetCounts, alphabetCounts + AlphaSize, 0);
		for(Index i = 0; i < n; i ++)
			alphabetCounts[(int)str[i]] ++;
	}
}

template<typename AlphaT>
void SuffixArray::getBucketOffsets(const AlphaT *str, Index n, bool dir, int AlphaSize, std::vector<Index> &bucketOffsets) {
	std::vector<Index>::iterator alphabetCounts;
	if((int)bucketOffsets.size() / 2 < AlphaSize) {
		countAlphabets(str, n, AlphaSize, bucketOffsets, true);
		alphabetCounts = bucketOffsets.begin();
	} else alphabetCounts = bucketOffsets.begin() + AlphaSize;
	Index cumsum = 1;
	if(dir) {
		for(int i = 0; i < AlphaSize; i ++) {
			cumsum += alphabetCounts[i];
			bucketOffsets[i] = cumsum;
		}
	} else {
		for(int i = 0; i < AlphaSize; i ++) {
			Index x = alphabetCounts[i];
			bucketOffsets[i] = cumsum;
			cumsum += x;
		}
	}
}

void SuffixArray::buildInverseSuffixArray() {
	Index n = length();
	inverseSuffixArray.resize(n + 1);
	for(Index i = 0; i <= n; i ++)
		inverseSuffixArray[suffixArray[i]] = i;
}

void SuffixArray::computeLCPArray(const Alpha *str) {
	int n = length();
	lcpArray.resize(n + 2);
	Index h = 0;
	for(Index i = 0; i < n; i ++) {
		Index pos = inverseSuffixArray[i];
		Index j = suffixArray[pos - 1];
		Index hbound = std::min(n - j, n - i);
		for(Index k = 0; h < hbound && str[i + h] == str[j + h]; ++ h);
		lcpArray[pos - 1] = h;
		if(h > 0) -- h;
	}
	lcpArray[n] = lcpArray[n + 1] = 0;
}

SuffixArray::Index SuffixArray::computeLCP(Index i, Index j) const {
	Index n = length();
	if(i == j) return n - i;
	Index x = inverseSuffixArray[i], y = inverseSuffixArray[j];
	if(x > y) std::swap(x, y);
	return lcpArrayRMQ.queryVal(&lcpArray[0], x, y - 1);
}

unsigned xor128() {
	static unsigned x = 123456789, y = 362436069, z = 521288629, w = 88675123;
	unsigned t = x ^ (x << 11);
	x = y; y = z; z = w;
	return w = w ^ (w >> 19) ^ (t ^ (t >> 8));
}

struct Node {
	static vector<Node> buf;
	static size_t bufp;
	typedef const Node *Ref;
	Ref left, right;
	int size;
	int key;
	Node() : left(NULL), right(NULL), size(1), key(0) {}
	static Ref newNode(Ref left, Ref right, int key) {
		if(bufp == buf.size()) {
			cerr << "Memory exhausted!" << endl;
			abort();
		}
		Node *p = new(&buf[bufp ++])Node;
		p->left = left, p->right = right, p->key = key;
		return p;
	}
	inline Ref propagated() const {
		return this;
	}
	inline Ref linkl(Ref c) const {
		return newNode(c, right, key);
	}
	inline Ref linkr(Ref c) const {
		return newNode(left, c, key);
	}
	inline Ref linklr(Ref l, Ref r) const {
		return newNode(l, r, key);
	}
};
vector<Node> Node::buf;
size_t Node::bufp = 0;

struct RBST {
	typedef const Node *Ref;
	static int size(Ref t) { return !t ? 0 : t->size; }

	typedef pair<Ref, Ref> RefPair;
	static RefPair splitKey(Ref t, int key) {
		if(!t) return RefPair((Ref)NULL, (Ref)NULL);
		t = t->propagated();
		if(key <= t->key) {
			RefPair p = splitKey(t->left, key);
			return RefPair(p.first, t->linkl(p.second));
		} else {
			RefPair p = splitKey(t->right, key);
			return RefPair(t->linkr(p.first), p.second);
		}
	}
	static Ref insertKey(Ref t, Ref n) {
		if(!t) return n->linklr(NULL, NULL);
		if(xor128() % (t->size + 1) == 0) {
			RefPair p = splitKey(t, n->key);
			return n->linklr(p.first, p.second);
		}
		t = t->propagated();
		if(n->key <= t->key)
			return t->linkl(insertKey(t->left, n));
		else
			return t->linkr(insertKey(t->right, n));
	}

	static Ref last(Ref t) {
		if(!t || !t->right) return t;
		return last(t->right);
	};

	static Ref head(Ref t) {
		if(!t || !t->left) return t;
		return head(t->left);
	};
};

int main() {
	typedef Node::Ref Ref;
	Node::buf.resize(10000000);
	int T;
	scanf("%d", &T);
	for(int ii = 0; ii < T; ++ ii) {
		Node::bufp = 0;
		int N; int A; int B;
		scanf("%d%d%d", &N, &A, &B);
		string S;
		cin >> S;
		SuffixArray sa;
		sa.buildAll(S.c_str(), N);
		vector<Ref> sets(N + 1);
		vector<vector<int> > events(N + 1);
		multiset<int> curMin;
		vector<int> dp(N + 1, INF);
		dp[0] = 0;
		rer(i, 0, N) {
			if(!curMin.empty())
				amin(dp[i], *curMin.begin());
			for(int t : events[i])
				curMin.erase(curMin.find(t));
			if(i == N) break;
			int x = dp[i];
			amin(dp[i + 1], x + A);

			int key = sa.inverseSuffixArray[i];

			int l = 0, u = i;
			while(u - l > 0) {
				int mid = (l + u + 1) / 2;
				Ref t = sets[i - mid + 1];
				bool ok = false;
				auto p = RBST::splitKey(t, key);
				if(p.first != nullptr) {
					int pos = RBST::last(p.first)->key;
					ok |= sa.computeLCP(i, sa.suffixArray[pos]) >= mid;
				}
				if(p.second != nullptr) {
					int pos = RBST::head(p.second)->key;
					ok |= sa.computeLCP(i, sa.suffixArray[pos]) >= mid;
				}
				if(ok)
					l = mid;
				else
					u = mid - 1;
			}
//			cerr << i << ": " << l << endl;
			if(l > 0) {
				curMin.insert(x + B);
				events[i + l].push_back(x + B);
			}

			sets[i + 1] = RBST::insertKey(sets[i], Node::newNode(0, 0, key));
		}
		int ans = dp[N];
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.125
hard
----------
PROBLEM STATEMENT:
The Kingdom of Gridland contains [expression] grid where each cell in the grid represents a city. Every cell in the grid contains a single lowercase character denoting the first character of the city name corresponding to that cell.

From a city with the coordinates [expression] unit of time (provided that the destination cell is within the confines of the grid):


[expression]
[expression]
[expression]
[expression]


A knight wants to visit all the cities in Gridland. He can start his journey in any city and immediately stops his journey after having visited each city at least once. Moreover, he always plans his journey in such a way that the total time required to complete it is minimum.

After completing his tour of each province, the knight forms a string by concatenating the characters of all the cells in his path. How many distinct strings can he form in each province?
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }

unsigned long long readTimeStampCounter() {
	unsigned a = 123456789, b = 987654321;
#ifdef __GNUC__
	asm(
		"rdtsc;\n\t"
		: "=d" (a), "=a" (b)
	);
#else
	__asm {
		rdtsc;
		mov a, edx;
		mov b, eax;
	};
#endif
	return (unsigned long long)a << 32 | b;
}
unsigned xor128() {
	static unsigned x = 123456789, y = 362436069,
		z = (unsigned)(readTimeStampCounter() >> 32), w = (unsigned)readTimeStampCounter();
	unsigned t = x ^ (x << 11);
	x = y; y = z; z = w;
	return w = w ^ (w >> 19) ^ (t ^ (t >> 8));
}

struct PolynomialHash {
	static const int NumMods = 2;
	static const unsigned Mods[NumMods];
	typedef unsigned long long ull;
	struct Hash {
		unsigned hs[NumMods];
		Hash() { for(int k = 0; k < NumMods; ++ k) hs[k] = 0; }
		bool operator==(const Hash &that) const {
			bool res = true;
			for(int k = 0; k < NumMods; ++ k)
				res &= hs[k] == that.hs[k];
			return res;
		}
		bool operator<(const Hash &that) const {
			for(int k = 0; k < NumMods; ++ k)
				if(hs[k] != that.hs[k])
					return hs[k] < that.hs[k];
			return false;
		}
		//string debugstr;
	};
	static unsigned seeds[NumMods];
	static std::vector<Hash> powh;

	static void initSeeds() {
		for(int k = 0; k < NumMods; ++ k) {
			unsigned x;
			do x = xor128(); while(x == 0 || x >= Mods[k]);
			seeds[k] = x;
		}
	}
	static void precomputePowerTable(int newSize) {
		if((int)powh.size() >= newSize) return;
		if(seeds[0] == 0) initSeeds();
		int oldSize = powh.size();
		powh.resize(newSize);
		if(oldSize == 0)
			for(int k = 0; k < NumMods; ++ k) powh[0].hs[k] = 1;
		for(int i = std::max(1, oldSize); i < newSize; i ++) for(int k = 0; k < NumMods; ++ k)
			powh[i].hs[k] = (ull)powh[i - 1].hs[k] * seeds[k] % Mods[k];
	}
};
const unsigned PolynomialHash::Mods[PolynomialHash::NumMods] = { 2147483647U, 2147483629U };
unsigned PolynomialHash::seeds[PolynomialHash::NumMods];
std::vector<PolynomialHash::Hash> PolynomialHash::powh;


struct SubstringHash : PolynomialHash {
	std::vector<Hash> preh;
	string debugS;

	template<typename V>
	void init(const V &v, int n) {
		debugS = v;
		precomputePowerTable(n + 1);
		preh.resize(n + 1);
		preh[0] = Hash();
		for(int i = 0; i < n; i ++) for(int k = 0; k < NumMods; ++ k)
			preh[i + 1].hs[k] = ((ull)preh[i].hs[k] * seeds[k] % Mods[k] + v[i]) % Mods[k];
	}
	Hash hash(int j) const {
		return preh[j];
	}
	Hash hash(int i, int j) const {
		if(i == 0) return hash(j);
		Hash res;
		for(int k = 0; k < NumMods; ++ k) {
			unsigned x = preh[j].hs[k] + Mods[k] - (unsigned)((ull)preh[i].hs[k] * powh[j - i].hs[k] % Mods[k]);
			res.hs[k] = x >= Mods[k] ? x - Mods[k] : x;
		}
		//res.debugstr = debugS.substr(i, j - i);
		return res;
	}
	Hash append(const Hash &h, const Hash &g, int glen) const {
		Hash res;
		for(int k = 0; k < NumMods; ++ k) {
			unsigned x = (unsigned)((ull)h.hs[k] * powh[glen].hs[k] % Mods[k]) + g.hs[k];
			res.hs[k] = x >= Mods[k] ? x - Mods[k] : x;
		}
		//res.debugstr = h.debugstr + g.debugstr;
		//assert(glen == g.debugstr.size());
		return res;
	}
};


int main() {
	PolynomialHash::initSeeds();
	int T;
	scanf("%d", &T);
	for(int ii = 0; ii < T; ++ ii) {
		int N;
		scanf("%d", &N);
		vector<string> S(2);
		cin >> S[0] >> S[1];
		SubstringHash app;
		string tmp(N * 2, '.');
		app.init(tmp, N * 2);
		vector<SubstringHash::Hash> hashes;
		rep(my, 2) {
			rep(mx, 2) {
				string zigzag[2];
				rep(i, N) {
					rep(j, 2) {
						rep(p, 2)
							zigzag[p] += S[(j + i + p) % 2][i];
					}
				}
				SubstringHash zigzagh[2];
				rep(p, 2)
					zigzagh[p].init(zigzag[p], N * 2);
				SubstringHash sh[2], revh[2];
				rep(i, 2) {
					sh[i].init(S[i], N);
					reverse(S[i].begin(), S[i].end());
					revh[i].init(S[i], N);
					reverse(S[i].begin(), S[i].end());
				}
				rep(i, N) rer(j, i + 1, N) {
					SubstringHash::Hash h;
					h = app.append(h, revh[0].hash(N - i - 1, N), i + 1);
					h = app.append(h, sh[1].hash(0, i + 1), i + 1);
					h = app.append(h, zigzagh[i % 2].hash((i + 1) * 2, j * 2), (j - i - 1) * 2);
					int p = (j - i) % 2;
					h = app.append(h, sh[p].hash(j, N), N - j);
					h = app.append(h, revh[1-p].hash(0, N - j), N - j);
					hashes.push_back(h);
				}
				rep(k, 2)
					reverse(S[k].begin(), S[k].end());
			}
			S[0].swap(S[1]);
		}
		sort(hashes.begin(), hashes.end());
		hashes.erase(unique(hashes.begin(), hashes.end()), hashes.end());
		int ans = (int)hashes.size();
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.126
expert
----------
PROBLEM STATEMENT:
Alice was given the [expression] possible permutations:


[expression]
[expression]
[expression]
[expression]
[expression]
[expression]


She then chose one permutation among them as her favorite permutation.

After some time, she forgot some elements of her favorite permutation. Nevertheless, she still tried to write down its elements. She wrote a [expression] in every position where she forgot the true value.

She wants to know the sum of the line numbers of the permutations which could possibly be her favorite permutation, i.e., permutations which can be obtained by replacing the [expression]s. Can you help her out? 

Since the sum can be large, find it modulo [expression].
----------
TOP SOLUTION:
----------
#include <algorithm>
#include <iostream>
#include <map>
#include <vector>
#include <cstring>
using namespace std;

const int kMaxN = 3e5+5, kMod = 1e9+7;

int fact[kMaxN], inv_fact[kMaxN];

int num_constant_ft[kMaxN], num_wildcard_ft[kMaxN];

int n;
void Update(int aib[], int pos, int val) {
    while (pos <= n) {
        aib[pos] += val;
        pos += pos & (-pos);    
    }
}

int Query(int aib[], int pos) {
    int r = 0;
    while (pos) {
        r += aib[pos];
        pos -= pos & (-pos);
    }
    return r;
}


int& Mod(int& a) {
    if (a >= kMod) {
        return a -= kMod;
    }
    return a;
}

int Pow(int a, int p) {
    int r = 1;
    while (p) {
        if (p & 1) {
            r = 1LL * r * a % kMod;
        }
        a = 1LL * a * a % kMod;
        p /= 2;
    }
    return r;
}

void Init(int n) {
    fact[0] = inv_fact[1] = 1;
    for (int i = 1; i <= n; i += 1) {
        fact[i] = 1LL * fact[i - 1] * i % kMod;
    }

    inv_fact[n] = Pow(fact[n], kMod - 2);
    for (int i = n - 1; i; i -= 1) {
        inv_fact[i] = 1LL * inv_fact[i + 1] * (i + 1) % kMod;
    }
}

int main() {
    cin >> n;
    Init(n);
    vector<int> v(n);
    for (auto& itr : v) {
        cin >> itr;
    }
    
    int num_wildcard = 0;
    map<int, int> is_present;
    for (int i = 1; i <= n; i += 1) {
        is_present[i] = false;
    }
    for (auto itr : v) {
        num_wildcard += (itr == 0);
        if (itr) {
            is_present[itr] = true;
        }
    }

    vector<int> wildcard_values = {};
    for (auto itr : is_present) {
        if (itr.second == 0) {
            wildcard_values.push_back(itr.first);
        }
    }

    int answer = 0;
    int num_wildcards_right = 0;
    int num_wildcard_constant = 0;
    for (auto itr : wildcard_values) {
        Update(num_wildcard_ft, itr, +1);
    }

    for (int i = n - 1; i >= 0; i -= 1) {
        int f = fact[n - i - 1];
        if (v[i] == 0) {
            // wildcard wildcard
            if (num_wildcard > 1) {
                Mod(answer += 1LL * f * ((1LL * num_wildcard * (num_wildcard - 1) / 2) % kMod) % kMod * num_wildcards_right % kMod * fact[num_wildcard - 2] % kMod);
            }

            // wildcard constant
            if (num_wildcard) {
                Mod(answer += 1LL * f * num_wildcard_constant % kMod * fact[num_wildcard - 1] % kMod);
            }

            num_wildcards_right += 1;
        } else {
            Mod(num_wildcard_constant += num_wildcard - Query(num_wildcard_ft, v[i]));

            // constant wildcard
            if (num_wildcard) {
                Mod(answer += 1LL * f * num_wildcards_right % kMod * Query(num_wildcard_ft, v[i]) % kMod * fact[num_wildcard - 1] % kMod);
            }

            // constant constant
            Mod(answer += 1LL * f * Query(num_constant_ft, v[i]) % kMod * fact[num_wildcard] % kMod);
            Update(num_constant_ft, v[i], +1);
        }
    }

    Mod(answer += fact[num_wildcard]);
    cout << answer << '\n';
}










----------
====================
----------
ALGORITHMS.127
advanced
----------
PROBLEM STATEMENT:
Ashton appeared for a job interview and is asked the following question. Arrange all the distinct substrings  of a given string in lexicographical order and concatenate them. Print the [expression] character. Can you help Ashton out with this?  

For example, given the string [expression] character of the 1-indexed concatenated string.  

Note We have distinct substrings here, i.e. if string is aa, it's distinct substrings are a and aa.  

Function Description  

Complete the ashtonString function in the editor below.  It should return the [expression] character from the concatenated string, 1-based indexing.  

ashtonString has the following parameters: 
- s: a string 
- k: an integer  
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
typedef long long LL;
using namespace std;
const int MAXLEN = (int)1e5 + 5;

char s[MAXLEN];
int SA[MAXLEN], cnt[MAXLEN], ary1[MAXLEN], ary2[MAXLEN];
int *Rank, *Height;


inline bool cmp(int *r, int a, int b, int l) {
    return r[a] == r[b] && r[a + l] == r[b + l];
}

void make_suffix_array(int MSIZE, int len) {
    int p, *x, *y, *tmp, i, j, k;
    x = ary1; y = ary2;
    memset(cnt, 0, sizeof(int) * MSIZE);
    for (i = 0; i < len; i++) cnt[x[i] = s[i]]++;
    for (i = 1; i < MSIZE; i++) cnt[i] += cnt[i - 1];
    for (i = len - 1; i >= 0; i--) SA[--cnt[x[i]]] = i;
    for (j = p = 1; p < len; j <<= 1, MSIZE = p) {
        for (p = 0, i = len - j; i < len; i++) y[p++] = i;
        for (i = 0; i < len; i++) {
            if (SA[i] >= j) y[p++] = SA[i] - j;
        }
        memset(cnt, 0, sizeof(int) * MSIZE);
        for (i = 0; i < len; i++) cnt[x[y[i]]]++;
        for (i = 1; i < MSIZE; i++) cnt[i] += cnt[i - 1];
        for (i = len - 1; i >= 0; i--) SA[--cnt[x[y[i]]]] = y[i];
        tmp = x; x = y; y = tmp;
        x[SA[0]] = 0;
        for (i = p = 1; i < len; i++) {
            x[SA[i]] = cmp(y, SA[i - 1], SA[i], j) ? p - 1 : p++;
        }
    }
    Rank = x;
    Height = y;
    for (i = k = 0; i < len - 1; i++) {
        if (k > 0) k--;
        j = SA[Rank[i] - 1];
        while (s[i + k] == s[j + k]) k++;
        Height[Rank[i]] = k;
    }
}
LL get(LL x,LL y){
    return (x+y)*(y-x+1)/2;
}
int main(){
    CASET{
        RS(s);
        int n=LEN(s);
        LL K;
        cin>>K;
        make_suffix_array(128,n+1);
        int now=0;
        REPP(i,1,n+1){
            now=Height[i];
            if(K<=get(now+1,n-SA[i])){
                LL ll=now+1,rr=n-SA[i];
                while(ll<rr){
                    LL mm=(ll+rr)>>1;
                    if(get(now+1,mm)<K)ll=mm+1;
                    else rr=mm;
                }
                K-=get(now+1,ll-1);
                printf("%c\n",s[SA[i]+K-1]);
                break;
            }
            else K-=get(now+1,n-SA[i]);
        }
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.128
expert
----------
PROBLEM STATEMENT:
For two strings A and B, we define the similarity of the strings to be the length of the longest prefix common to both strings. For example, the similarity of strings "abc" and "abd" is 2, while the similarity of strings "aaa" and "aaab" is 3.

Calculate the sum of similarities of a string S with each of it's suffixes.
----------
TOP SOLUTION:
----------
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <iostream>
#include <cmath>
#include <sstream>
#include <map>
#include <set>
#include <numeric>
#include <memory.h>
#include <cstdio>
#include <assert.h>
#include <numeric>

using namespace std;

#define pb push_back
#define INF 1011111111
#define FOR(i,a,b) for (int _n(b), i(a); i < _n; i++)
#define rep(i,n) FOR(i,0,n)
#define ford(i,a,b) for(int i=(a),_b=(b);i>=_b;--i)
#define CL(a,v) memset((a),(v),sizeof(a))
#define mp make_pair
#define X first
#define Y second
#define all(c) (c).begin(), (c).end()
#define SORT(c) sort(all(c))

typedef long long ll;
typedef vector<int> VI;
typedef pair<int,int> pii;

vector<ll> z_func(const string &s)
{
    int n = s.size();
    vector<ll> z(n,0);
    int l = 0,r = 0;

    FOR(i,1,n)
    {
        if(i <= r)
            z[i] = min(z[i-l], (ll)r-i+1);

        while(i+z[i] < n && s[i+z[i]] == s[z[i]]) z[i] ++;

        if(i+z[i]-1 > r)
            r = i+z[i]-1, l = i;
    }

    return z;
}

int main()
{
	#ifndef ONLINE_JUDGE
        //freopen("input.txt","r",stdin);
        //freopen("output.txt","w",stdout);
	#endif

    int T;
    cin >> T;

    while(T--)
    {
        string s;
        cin >> s;

        vector<ll> z = z_func(s);

        cout << 1LL*s.size() + accumulate(all(z), 0LL) << endl;
    }

	return 0;
}

----------
====================
----------
ALGORITHMS.129
advanced
----------
PROBLEM STATEMENT:
We define a function, [expression], as follows:

[expression]

where:


[expression].
[expression].


Consuela loves creating string challenges and she needs your help testing her newest one! Given a string, [expression].
----------
TOP SOLUTION:
----------
/*********************************************************************\
   |--\        ---       /\        |-----------| -----   /-------|    |
   |   \        |       /  \       |               |    /             |
   |    \       |      /    \      |               |   |              |
   |     \      |     /      \     |               |   |----|         |
   |      \     |    / ------ \    |-------|       |        |-----|   |
   |       \    |   /          \   |               |              |   |
   |        \   |  /            \  |               |              /   |
  ---        -------            ------           ----- |---------/    |
                                                                      |
    codeforces = nfssdq  ||  topcoder = nafis007                      |
    mail = nafis_sadique@yahoo.com || nfssdq@gmail.com                |
    IIT,Jahangirnagar University(41)                                  |
                                                                      |
**********************************************************************/

#include <bits/stdc++.h>
using namespace std;

#define xx         first
#define yy         second
#define pb         push_back
#define mp         make_pair
#define LL         long long
#define inf        INT_MAX/3
#define mod        1000000007ll
#define PI         acos(-1.0)
#define linf       (1ll<<60)-1
#define FOR(I,A,B) for(int I = (A); I < (B); ++I)
#define REP(I,N)   FOR(I,0,N)
#define ALL(A)     ((A).begin(), (A).end())
#define set0(ar)   memset(ar,0,sizeof ar)
#define vsort(v)   sort(v.begin(),v.end())
#define setinf(ar) memset(ar,126,sizeof ar)

//cout << fixed << setprecision(20) << p << endl;

template <class T> inline T bigmod(T p,T e,T M){
    LL ret = 1;
    for(; e > 0; e >>= 1){
        if(e & 1) ret = (ret * p) % M;
        p = (p * p) % M;
    } return (T)ret;
}
template <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}
template <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}

const int N = 3e5+10; // 3* MX size
int A[N] , rnk[N] , sa[N] , height[N];
char str[N];
void ini()
{
    memset(A,0,sizeof A);
    memset(rnk,0,sizeof rnk);
    memset(sa,0,sizeof sa);
    memset(height,0,sizeof height);
}
namespace Suffix_array
{
    # define F(x) ((x)/3+((x)%3==1?0:tb))
    # define G(x) ((x)<tb?(x)*3+1:((x)-tb)*3+2)
    int wa[N * 3] , wb[N * 3] , wv[N * 3] , ws[N * 3];
    int c0(int *r, int a, int b)
    {
        return r[a] == r[b] && r[a + 1] == r[b + 1] && r[a + 2] == r[b + 2];
    }
    int c12(int k, int *r, int a, int b)
    {
        if (k == 2)
            return r[a] < r[b] || r[a] == r[b] && c12(1, r, a + 1, b + 1);
        else return r[a] < r[b] || r[a] == r[b] && wv[a + 1] < wv[b + 1];
    }
    void sort(int *r, int *a, int *b, int n, int m)
    {
        int i;
        for (i = 0; i < n; i++) wv[i] = r[a[i]];
        for (i = 0; i < m; i++) ws[i] = 0;
        for (i = 0; i < n; i++) ws[wv[i]]++;
        for (i = 1; i < m; i++) ws[i] += ws[i-1];
        for (i = n-1; i >= 0; i--) b[--ws[wv[i]]] = a[i];
        return;
    }
    void dc3(int *r, int *sa, int n, int m)
    {
        int i, j, *rn = r + n;
        int *san = sa + n, ta = 0, tb = (n + 1) / 3, tbc = 0, p;
        r[n] = r[n + 1] = 0;
        for (i = 0; i < n; i++) if (i % 3 != 0) wa[tbc++] = i;
        sort(r + 2, wa, wb, tbc, m);
        sort(r + 1, wb, wa, tbc, m);
        sort(r, wa, wb, tbc, m);
        for (p = 1, rn[F(wb[0])] = 0, i = 1; i < tbc; i++)
            rn[F(wb[i])] = c0(r, wb[i-1], wb[i]) ? p-1 : p++;
        if (p < tbc) dc3(rn, san, tbc, p);
        else for (i = 0; i < tbc; i++) san[rn[i]] = i;
        for (i = 0; i < tbc; i++) if (san[i] < tb) wb[ta++] = san[i] * 3;
        if (n % 3 == 1) wb[ta++] = n-1;
        sort(r, wb, wa, ta, m);
        for (i = 0; i < tbc; i++) wv[wb[i] = G(san[i])] = i;
        for (i = 0, j = 0, p = 0; i < ta && j < tbc; p++)
            sa[p] = c12(wb[j] % 3, r, wa[i], wb[j]) ? wa[i++] : wb[j++];
        for (; i < ta; p++) sa[p] = wa[i++];
        for (; j < tbc; p++) sa[p] = wb[j++];
    }
    void da(int str[],int sa[],int rnk[],int height[],int n,int m)
    {
        for (int i = n; i < n * 3; i++)
            str[i] = 0;
        dc3 (str , sa , n + 1 , m);
        int i, j, k;
        for (i = 0; i < n; i++)
        {
            sa[i] = sa[i + 1];
            rnk[sa[i]] = i;
        }
        for (i = 0, j = 0, k = 0; i < n; height[rnk[i ++]] = k)
            if (rnk[i] > 0)
                for (k ? k--: 0 , j = sa[rnk[i]-1];
                        i + k < n && j + k < n && str[i + k] == str[j + k];
                        k++);
    }
} using namespace Suffix_array;


LL pow_sum[27][100001];
string S;
int pre[100001][27], ar[100001];
int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    FOR(i, 1, 100001) pow_sum[0][i] = 1;
    FOR(i, 1, 27){
        FOR(j, 1, 100001){
            pow_sum[i][j] = (pow_sum[i-1][j] * (LL)j) % mod;
        }
    }
    REP(i, 27){
        FOR(j, 1, 100001) pow_sum[i][j] = (pow_sum[i][j] + pow_sum[i][j-1]) % mod;
    }

    int T; cin >> T;
    while(T--){
        cin >> S;
        LL res = 0;

        REP(i, S.size()) A[i] = S[i];
        da(A, sa, rnk, height, S.size(), 128);

        ar[sa[0]] = 0;
        FOR(i, 1, S.size()){
            ar[sa[i]] = height[i];
        }

        for(int i = S.size()-1; i >= 0; i--){
            REP(j, 26){
                if(i == S.size()-1)pre[i][j] = S.size();
                else pre[i][j] = pre[i+1][j];
            }
            pre[i][S[i]-'a'] = i;
            vector < int > vc;
            REP(j, 26){
                vc.pb(pre[i][j]);
            }
            vsort(vc);
            REP(j, vc.size()){
                if(vc[j] == S.size()) break;
                int nxt = S.size();
                if(j < vc.size()-1 && vc[j+1] != S.size()) nxt = vc[j+1];
                if(nxt-i < ar[i]) continue;
                int r = nxt - i;
                int l = vc[j] - i + 1;
                if(l < ar[i]+1) l = ar[i]+1;

                res = (res + pow_sum[j+1][r] - pow_sum[j+1][l-1] + mod) % mod;
            }

        }

        cout << res << endl;
    }
}

----------
====================
----------
ALGORITHMS.130
advanced
----------
PROBLEM STATEMENT:
A palindrome is a string that reads the same from left to right as it does from right to left.

Given a string, [expression]). See the Explanation section for examples.

Given [expression] on a new line.
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

#define ll long long
#define ull unsigned ll

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(double *x){scanf("%lf",x);}
int reader(char c[]){int i,s=0;for(;;){mygc(i);if(i!=' '&&i!='\n'&&i!='\r'&&i!='\t'&&i!=EOF) break;}c[s++]=i;for(;;){mygc(i);if(i==' '||i=='\n'||i=='\r'||i=='\t'||i==EOF) break;c[s++]=i;}c[s]='\0';return s;}
template <class T, class S> void reader(T *x, S *y){reader(x);reader(y);}
template <class T, class S, class U> void reader(T *x, S *y, U *z){reader(x);reader(y);reader(z);}
template <class T, class S, class U, class V> void reader(T *x, S *y, U *z, V *w){reader(x);reader(y);reader(z);reader(w);}

void writer(int x, char c){int s=0,m=0;char f[10];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(ll x, char c){int s=0,m=0;char f[20];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(double x, char c){printf("%.15f",x);mypc(c);}
void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}
void writer(const char x[], char c){int i;for(i=0;x[i]!='\0';i++)mypc(x[i]);mypc(c);}
template<class T> void writerLn(T x){writer(x,'\n');}
template<class T, class S> void writerLn(T x, S y){writer(x,' ');writer(y,'\n');}
template<class T, class S, class U> void writerLn(T x, S y, U z){writer(x,' ');writer(y,' ');writer(z,'\n');}
template<class T> void writerArr(T x[], int n){int i;if(!n){mypc('\n');return;}rep(i,n-1)writer(x[i],' ');writer(x[n-1],'\n');}

template<class T> void sort(int N, T a[], void *mem = NULL){sort(a,a+N);}
template<class T1, class T2> void sort(int N, T1 a[], T2 b[], void *mem){int i;pair<T1,T2> *r=(pair<T1, T2>*)mem;rep(i,N)r[i].first=a[i],r[i].second=b[i];sort(r,r+N);rep(i,N)a[i]=r[i].first,b[i]=r[i].second;}
template<class T1, class T2, class T3> void sort(int N, T1 a[], T2 b[], T3 c[], void *mem){int i;pair<T1,pair<T2,T3> > *r=(pair<T1,pair<T2,T3> >*)mem;rep(i,N)r[i].first=a[i],r[i].second.first=b[i],r[i].second.second=c[i];sort(r,r+N);rep(i,N)a[i]=r[i].first,b[i]=r[i].second.first,c[i]=r[i].second.second;}
template<class T1, class T2, class T3, class T4> void sort(int N, T1 a[], T2 b[], T3 c[], T4 d[], void *mem){int i;pair<pair<T1,T2>,pair<T3,T4> > *r=(pair<pair<T1,T2>,pair<T3,T4> >*)mem;rep(i,N)r[i].first.first=a[i],r[i].first.second=b[i],r[i].second.first=c[i],r[i].second.second=d[i];sort(r,r+N);rep(i,N)a[i]=r[i].first.first,b[i]=r[i].first.second,c[i]=r[i].second.first,d[i]=r[i].second.second;}


char memarr[77000000]; void *mem = memarr;
#define MD 1000000007

template<class T>
struct rollingHash64{
  int len;
  T *data;
  ull *sum, *rev, *pw;
  ull mul;

  ull getinv(ull a){
    ull t,s=a,u=0,v=1,e;
    e = numeric_limits<ull>::max() / s;
    t -= e * s;
    u -= e * v;
    swap(t,s);
    swap(u,v);
    while(s){
      e=t/s;
      t-=e*s;
      u-=e*v;
      swap(t,s);
      swap(u,v);
    }
    return u;
  }

  void* init(int n, T *arr, ull m = 0, void *mem = NULL){
    int i; ull v;

    mul = m;
    if(mul==0) mul = 2*(rand()%1000000000) + 1000000001ULL;

    len = n;
    data = arr;
    if(mem == NULL){
      pw = (ull*)malloc(sizeof(ull)*(2*len+1));
      sum = (ull*)malloc(sizeof(ull)*(len+1));
      rev = (ull*)malloc(sizeof(ull)*(len+1));
    } else {
      pw = (ull*)mem;
      sum = pw + 2*len + 1;
      rev = sum + len + 1;
      mem = rev + len + 1;
    }

    v = getinv(mul);
    pw = pw + len;
    pw[0] = 1;
    rep(i,len) pw[ i+1] = pw[ i] * mul;
    rep(i,len) pw[-i-1] = pw[-i] * v;

    sum[0] = 0;
    rep(i,len) sum[i+1] = sum[i] + (ull)data[i] * pw[i];

    rev[len] = 0;
    for(i=len-1;i>=0;i--) rev[i] = rev[i+1] + (ull)data[i] * pw[len-i-1];

    return mem;
  }

  ull get(int a, int b, int off=0){
    ull res;
    
    if(a <= b){
      res = (sum[b+1] - sum[a]) * pw[-a+off] + (b-a+1);
    } else {
      res = (rev[b] - rev[a+1]) * pw[-(len-1-a)+off] + (a-b+1);
    }

    return res;
  }
};

template<class T>
void manacher(int n, T arr[], int res[]) {
  int i, j, k;
  for(i=0,j=0; i<2*n; i+=k, j=max(j-k,0)) {
    while(i-j >= 0 && i+j+1 < 2*n && arr[(i-j)/2] == arr[(i+j+1)/2]) ++j;
    res[i] = j;
    for(k=1; i-k >= 0 && res[i]-k >= 0 && res[i-k] != res[i]-k; ++k)
      res[i+k] = min(res[i-k], res[i]-k);
  }
}


template<class T>
struct lazySegtreeMinVal{
  int N, logN;
  T *data;

  T *fixval; char *fixed;
  T *addval;

  void malloc(int maxN){
    int i;
    for(i=1;i<maxN;i*=2);
    
    data = (T*)std::malloc(sizeof(T)*2*i);
    fixval = (T*)std::malloc(sizeof(T)*i);
    addval = (T*)std::malloc(sizeof(T)*i);
    fixed = (char*)std::malloc(sizeof(char)*i);
  }

  T& operator[](int i){
    return data[N+i];
  }

  void setN(int n, int zerofill = 1){
    int i;
    for(i=1,logN=0;i<n;i*=2,logN++);
    N = i;
    if(zerofill) rep(i,N) data[N+i] = 0;
  }

  void build(void){
    int i;
    for(i=N-1;i;i--) data[i] = min(data[2*i],data[2*i+1]);
    REP(i,1,N) fixed[i] = 0;
    REP(i,1,N) addval[i] = 0;
  }

  inline void push_one(int a, int sz){
    if(fixed[a]){
      if(sz > 1){
        fixed[a*2] = fixed[a*2+1] = 1;
        fixval[a*2] = fixval[a*2+1] = fixval[a];
        data[a*2] = data[a*2+1] = fixval[a];
      } else {
        data[a*2] = data[a*2+1] = fixval[a];
      }
      fixed[a] = 0;
      addval[a] = 0;
      return;
    }
    if(addval[a] != 0){
      if(sz > 1){
        if(fixed[a*2]) fixval[a*2] += addval[a];
        else           addval[a*2] += addval[a];
        if(fixed[a*2+1]) fixval[a*2+1] += addval[a];
        else             addval[a*2+1] += addval[a];
        data[a*2] += addval[a];
        data[a*2+1] += addval[a];
      } else {
        data[a*2] += addval[a];
        data[a*2+1] += addval[a];
      }
      addval[a] = 0;
      return;
    }
  }

  inline void push(int a){
    int i, aa;
    for(i=logN;i;i--){
      aa = a>>i;
      push_one(aa, 1<<(i-1));
    }
  }

  inline void build(int a){
    while(a > 1){
      a /= 2;
      if(fixed[a]){
        data[a] = fixval[a];
      } else {
        data[a] = min(data[a*2], data[a*2+1]);
        if(addval[a] != 0) data[a] += addval[a];
      }
    }
  }

  inline void change(int a, int b, T val){
    int aa, bb;
    if(a >= b) return;

    aa = (a += N);
    bb = (b += N);
    push(a); push(b-1);

    if(a%2) data[a++] = val;
    if(b%2) data[--b] = val;
    a /= 2;
    b /= 2;

    while(a < b){
      if(a%2) fixed[a]=1, fixval[a]=val, data[a++] = val;
      if(b%2) fixed[--b]=1, fixval[b]=val, data[b] = val;
      a /= 2;
      b /= 2;
    }

    build(aa);
    build(bb-1);
  }

  inline void add(int a, int b, T val){
    int sz = 1, aa, bb;
    if(a >= b) return;

    aa = (a += N);
    bb = (b += N);
    push(a); push(b-1);

    if(a%2) data[a++] += val;
    if(b%2) data[--b] += val;
    a /= 2;
    b /= 2;

    while(a < b){
      sz *= 2;
      if(a%2){
        if(fixed[a]) fixval[a] += val; else addval[a] += val;
        data[a++] += val;
      }
      if(b%2){
        b--;
        if(fixed[b]) fixval[b] += val; else addval[b] += val;
        data[b] += val;
      }
      a /= 2;
      b /= 2;
    }

    build(aa);
    build(bb-1);
  }

  inline T getMinVal(int a, int b){
    T res;
    int sz = 1;
    
    a += N;
    b += N;
    push(a); push(b-1);

    res = std::numeric_limits<T>::max();
    while(a < b){
      if(a%2) res = min(res, data[a++]);
      if(b%2) res = min(res, data[--b]);
      a /= 2;
      b /= 2;
    }
    return res;
  }
};


int N;
char S[2000000];
int rad[3000000];
int res[1000000];

int ss[3000000], ee[3000000], vv[3000000], nx[1000000];

int get_nx(int i){
  if(nx[i]==-1) return i;
  if(i==N-1) return nx[i] = N;
  return nx[i] = get_nx(nx[i]);
}

int main(){
  int i, j, k, st, ed, m, d;
//  rollingHash64<char> h;
//  lazySegtreeMinVal<int> t;

  reader(&N,S);
//  h.init(N,S);
//  t.malloc(N);
//  t.setN(N);
//  t.build();

  rep(i,N) S[N+i] = S[i];

  manacher(2*N, S, rad);
  rep(i,4*N){
    k = min(N,rad[i]);
    if(i%2==0 && k%2==0) k--;
    if(i%2==1 && k%2==1) k--;
    if(rad[i]==0) continue;
    st = i/2 - (k-1)/2;
    ed = i/2 + k/2;

    m = ed-st+1;

    ss[i] = (st-(N-m)+N+N)%N;
    ee[i] = (st+N+N)%N;
    vv[i] = m;
//    rep(j,N-m+1) res[(st+N-j)%N] = max(res[(st+N-j)%N], m);
  }

  sort(4*N, vv, ss, ee, mem);
  rep(i,N+1) nx[i] = -1;
  for(i=4*N-1;i>=0;i--){
    if(ss[i] <= ee[i]){
      k = ss[i];
      while(k <= ee[i]){
//        writerLn(ss[i],k,ee[i]);
        res[k] = max(res[k], vv[i]);
        if(nx[k]==-1) nx[k] = k+1;
        k = get_nx(k);
      }
    } else {
      k = ss[i];
      while(k < N){
//        writerLn(ss[i],k,N);
        res[k] = max(res[k], vv[i]);
        if(nx[k]==-1) nx[k] = k+1;
        k = get_nx(k);
      }

      k = 0;
      while(k <= ee[i]){
//        writerLn(0,k,ee[i]);
        res[k] = max(res[k], vv[i]);
        if(nx[k]==-1) nx[k] = k+1;
        k = get_nx(k);
      }
    }
  }

  REP(i,1,2*N) res[i%N] = max(res[i%N], res[(i-1)%N]-2);
  for(i=2*N-2;i>=0;i--) res[i%N] = max(res[i%N], res[(i+1)%N]-2);

  rep(i,N) writerLn(res[i]);

  return 0;
}

----------
====================
----------
ALGORITHMS.131
advanced
----------
PROBLEM STATEMENT:
Jimmy loves playing with strings. He thinks string [expression] if the following conditions are satisfied:


Both strings have the same length (i.e., [expression]). 
For each valid pair of indices, [expression].  


For example, string [expression].  

He has a string, [expression] and print this number on a new line.

Note: Substring [expression] cdef. 
----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 350

using namespace std;

const int INF = 1e9;
const int N = 150031;

int n, tests;
string st;
int used[N];
int mapp[N];
vector<int> v;
int whr[N];

int pw[N];

int S[200000][15];

int maps1[200], maps2[200];

vector<int> entries[100];
int maps[4][100];

int FE[N][15];

void run_mapper(int a,int b)
{
	vector<pair<int, int> > O;

	for (int i = 0; i < 10; i++)
	{
		int whr = FE[a][i];
		O.push_back(make_pair(whr, i));
	}
	sort(O.begin(), O.end());
	for (int i = 0; i < O.size(); i++)
	{
		maps[b][O[i].second] = i;
	}
}

int get_hash(int a, int span, int tp)
{
	int res = 0;
	for (int i = 0; i < 10; i++)
	{
		int here = S[a+span][i] - S[a][i];
		here *= (maps[tp][i]+1);
		here *= pw[N - a - 1];
		res += here;
	}
	return res;
}

int lcp(int a, int b)
{
	run_mapper(a, 1);
	run_mapper(b, 2);
	/*for (int i = 0; i < 10; i++)
	{
		cout << maps[1][i] << " ";
	}
	cout << endl;
	for (int i = 0; i < 10; i++)
	{
		cout << maps[2][i] << " ";
	}
	cout << endl;
	*/
	int l, r;
	l = 0;
	r = st.size() - max(a, b);
	while (l < r)
	{
		int mid = l + r + 1;
		mid /= 2;
		long long H1 = get_hash(a, mid,1);
		long long H2 = get_hash(b, mid,2);
		if (H1 == H2)
			l = mid;
		else
			r = mid - 1;
	}
	return l;
}

bool cmp(int a, int b)
{
	int Q = lcp(a, b);
	if (a + Q == st.size())
		return true;
	if (b + Q == st.size())
		return false;
	int val1 = maps[1][st[a + Q]-'a'];
	int val2 = maps[2][st[b + Q]-'a'];
//	cout << val1 << "%%" << val2 << endl;
	return val1 < val2;
}

int LL[N];
int sparse[N][20];

int Lcp(int a, int b)
{
	if (a>b)
		swap(a, b);
	if (a == b)
		return 1e9;
	--b;
	int q = 0;
	while ((1 << q) * 2 < (b - a + 1))
		++q;
	return min(sparse[a][q], sparse[b - (1 << q) + 1][q]);
}

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);
	
	cin >> n >> tests;
	
	pw[0] = 1;

	for (int i = 1; i < N; i++)
	{
		pw[i] = pw[i - 1] * 173;
	}

	cin >> st;

	for (int i = 0; i < 10; i++)
	{
		FE[st.size()][i] = st.size();
	}
	for (int i = st.size() - 1; i >= 0; --i)
	{
		for (int j = 0; j < 10; j++)
		{
			FE[i][j] = FE[i + 1][j];
			if (st[i] == j + 'a')
				FE[i][j] = i;
		}
	}

	for (int i = 0; i < st.size(); i++)
	{
		for (int j = 0; j < 10; j++)
		{
			S[i + 1][j] = S[i][j];
			if (st[i] == j + 'a')
				S[i + 1][j] += pw[i];
		}
	}

	for (int i = 0; i < st.size(); i++)
	{
		v.push_back(i);
	}

	sort(v.begin(), v.end(),cmp);

	for (int i = 0; i < v.size(); i++)
	{
		whr[v[i]] = i;
	}

	for (int i = 0; i+1 < v.size(); i++)
	{
		LL[i] = lcp(v[i], v[i + 1]);
	}

	for (int lev = 0; lev < 17; lev++)
	{
		for (int i = 0; i < v.size(); i++)
		{
			if (lev == 0)
				sparse[i][lev] = LL[i];
			else
			{
				sparse[i][lev] = sparse[i][lev - 1];
				if (i + (1 << lev) / 2 <= st.size())
					sparse[i][lev] = min(sparse[i][lev], sparse[i + (1 << lev) / 2][lev - 1]);
			}
		}
	}

	for (int i = 1; i <= tests; i++)
	{
		int l, r;
		cin >> l >> r;
		--l;
		--r;
		int span = r - l + 1;
		int ps = whr[l];
		l = ps;
		r = v.size() - 1;
		while (l < r)
		{
			int mid = l + r+1;
			mid /= 2;
			if (Lcp(ps,mid) >= span)
				l = mid;
			else
				r = mid - 1;
		}
		int R = r;
		r = ps;
		l = 0;
		while (l < r)
		{
			int mid = l + r;
			mid /= 2;
			if (Lcp(ps,mid) >= span)
				r = mid;
			else
				l = mid + 1;
		}
		cout << R-l+1 << endl;
	}

	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.132
expert
----------
PROBLEM STATEMENT:
Oh!! Mankind is in trouble again. This time, it's a deadly disease spreading at a rate never seen before. The need of the hour is to set up efficient virus detectors. You are the lead at Central Hospital and you need to find a fast and reliable way to detect the footprints of the virus DNA in that of the patient.

The DNA of the patient as well as of the virus consists of lowercase letters. Since the collected data is raw, there may be some errors. You will need to find all substrings in the patient DNA that either exactly match the virus DNA or have at most one mismatch, i.e., a difference in at most one location. 

For example, "aa" and "aa" are matching, "ab" and "aa" are matching, while "abb" and "bab" are not.

Function Description

Complete the virusIndices function in the editor below.  It should print a list of space-separated integers that represent the starting indices of matching substrings in increasing order, or No match!.

virusIndices has the following parameter(s):  


p: a string that represents patient DNA  
v: a string that represents virus DNA  

----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include<iostream>
#include<stdio.h>
#include<vector>
#include<string.h>
#include<stdlib.h>
using namespace std ;
#define MAXN 200002
char text[MAXN],pat[MAXN] ;
int szp,szt ;

int p1[2 * MAXN],p2[2 * MAXN] ;
char s[2 * MAXN] ;
vector<int> reta ;
vector<int> solve1()
{
 memset(p1,0,sizeof p1) ;
 memset(p2,0,sizeof p2) ;
 memset(s,0,sizeof s) ;
 int n = 0 ;
 for(int i = 0;i < szp;i++) s[n++] = pat[i] ;
 for(int i = 0;i < szt;i++) s[n++] = text[i] ;
 p1[0] = n ;
 int g = 0,f = 0 ;
 for(int i = 1;i < n;i++)
 {
  if(i < g && p1[i - f] != g - i)
   p1[i] = min(p1[i - f],g - i) ;
  else
  {
   g = max(g,i) ;
   f = i ;
   while(g < n && s[g] == s[g - f]) g++ ;
   p1[i] = g - f ;
  }
 }
 
 n = 0 ;
 for(int i = szp - 1;i >= 0;i--) s[n++] = pat[i] ;
 for(int i = szt - 1;i >= 0;i--) s[n++] = text[i] ;
 p2[0] = n ;
 g = 0,f = 0 ;
 for(int i = 1;i < n;i++)
 {
  if(i < g && p2[i - f] != g - i)
   p2[i] = min(p2[i - f],g - i) ;
  else
  {
   g = max(g,i) ;
   f = i ;
   while(g < n && s[g] == s[g - f]) g++ ;
   p2[i] = g - f ;
  }
 }
 
 reta.clear() ;
 for(int i = 0;i + szp <= szt;i++)
 {
  int start = p1[szp + i] ;
  int end = p2[szp + szt - 1 - (i + szp - 1)] ;
  if(start + end + 1 >= szp) reta.push_back(i) ;
 }
 return reta ;
}

vector<int> solve2()
{
 vector<int> ret ;
 for(int i = 0;i + szp <= szt;i++)
 {
  int miss = 0 ;
  for(int j = 0;j < szp;j++)
   if(text[i + j] != pat[j])
    miss++ ;
  if(miss <= 1) ret.push_back(i) ;
 }
 return ret ;
}

void gen()
{
 szt = rand() % 1000 + 1 ;
 memset(text,0,sizeof text) ;
 for(int i = 0;i < szt;i++) text[i] = rand() % 3 + 'a' ;

 szp = rand() % szt + 1 ;
 memset(pat,0,sizeof pat) ;
 for(int i = 0;i < szp;i++) pat[i] = rand() % 3 + 'a' ;
}


char get1()
{
 if(rand() % 50000 < 49998) return 'a' ;
 else if(rand() % 100 < 80) return 'b' ;
 return 'c' ;
}

char get2()
{
 if(rand() % 50000 < 49999) return 'a' ;
 return 'b' ;
}

void generate()
{
 srand(time(NULL)) ;
 char in[10] = "in .txt" ;
 for(int test = 0;test < 10;test++)
 {
  in[2] = test + '0' ;
  FILE * fout = fopen(in,"w") ;
  
  int runs = 10 ;
  fprintf(fout,"%d\n",runs) ;
  for(int t = 0;t < runs;t++)
  {
   szt = 100000 - rand() % 1000 + 1 ;
   if(test <= 2) szt = rand() % 30 + 1 ;
   szp = rand() % szt + 1 ;
   memset(text,0,sizeof text) ;
   memset(pat,0,sizeof pat) ;

   if(test <= 2)
   {
    for(int i = 0;i < szt;i++) text[i] = rand() % 2 + 'a' ;
    for(int i = 0;i < szp;i++) pat[i] = rand() % 2 + 'a' ;
   }
   else if(test <= 5)
   {
    for(int i = 0;i < szt;i++) text[i] = get1() ;
    for(int i = 0;i < szp;i++) pat[i] = get1() ;
   }
   else if(test <= 7)
   {
    for(int i = 0;i < szt;i++) text[i] = get2() ;
    for(int i = 0;i < szp;i++) pat[i] = get2() ;
   }
   else
   {
    for(int i = 0;i < szt;i++) text[i] = i % 26 + 'a' ;
    for(int i = 0;i < szp;i++) pat[i] = i % 26 + 'a' ;
    for(int i = 0;i < 10;i++) text[rand() % szt] = 'a' + rand() % 26 ;
   }
   fprintf(fout,"%s\n%s\n\n",text,pat) ;
  }
 }
}



void test()
{
 for(int t = 0;t < 1000;t++)
 {
  gen() ;
  vector<int> ret1 = solve1() ;
  vector<int> ret2 = solve2() ;
  for(int i = 0;i < ret1.size();i++) cout << ret1[i] << " " ; cout << endl ;
  for(int i = 0;i < ret2.size();i++) cout << ret2[i] << " " ; cout << endl ;
  cout << endl ;
  if(ret1 != ret2)
  {
   cout << "Failed on: " << t << endl ;
   cout << text << endl << pat << endl ;
   for(int i = 0;i < ret1.size();i++) cout << ret1[i] << " " ; cout << endl ;
   for(int i = 0;i < ret2.size();i++) cout << ret2[i] << " " ; cout << endl ;
   while(1) ;
  }
 }
}

int main()
{
// srand(time(NULL));
// generate() ; return 0 ;
// test() ; return 0 ;
 int runs ;
 scanf("%d",&runs) ;
 while(runs--)
 {
  memset(text,0,sizeof text) ;
  memset(pat,0,sizeof pat) ;
  scanf("%s%s",text,pat) ;
  szt = strlen(text) ;
  szp = strlen(pat) ;
  vector<int> ret1 = solve1() ;
  for(int i = 0;i < ret1.size();i++)
  {
   if(i > 0) printf(" ") ;
   printf("%d",ret1[i]) ;
  }
  printf("\n") ;
 }
 return 0 ;
}
----------
====================
----------
ALGORITHMS.133
expert
----------
PROBLEM STATEMENT:
A substring is defined as a contiguous sequence of one or more characters in the string. More information on substrings can be found here.  
You are given n strings w[1], w[2], ......, w[n]. Let S[i] denote the set of all unique substrings of the string w[i]. Let [expression], return INVALID.  

For example, your strings are [expression] so we return INVALID.

Function Description  

Complete the findStrings function in the editor below.  It should return array of strings.  

findStrings has the following parameter(s):  


w: an array of strings  
queries: an array of integers  

----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT *//**
Find Strings (25 points)

You are given 'n' strings w1, w2, ......, wn. Let Si denote the set of strings formed by considering all unique substrings of the string wi. A substring is defined as a contiguous sequence of one or more characters in the string. More information on substrings can be found here. Let 'S' = {S1 U S2 U .... Sn} .i.e 'S' is a set of strings formed by considering all the unique strings in all sets S1, S2, ..... Sn. You will be given many queries and for each query, you will be given an integer 'k'. Your task is to output the lexicographically kth smallest string from the set 'S'.



Input:

The first line of input contains a single integer 'n', denoting the number of strings. Each of the next 'n' lines consists of a string. The string on the ith line (1<=i<=n) is denoted by wi and has a length mi. The next line consists of a single integer 'q', denoting the number of queries. Each of the next 'q' lines consists of a single integer 'k'.

Note: The input strings consist only of lowercase english alphabets 'a' - 'z'.



Output:

Output 'q' lines, where the ith line consists of a string which is the answer to the ith query. If the input is invalid ('k' > |S|), output "INVALID" (quotes for clarity) for that case.


Constraints:

1<=n<=50
1<=mi<=2000
1<=q<=500
1<=k<=1000000000

Sample Input:
2
aab
aac
3
3
8
23

Sample Output:
aab
c
INVALID

Explanation:

For the sample test case, we have 2 strings "aab" and "aac".
S1 = {"a", "aa", "aab", "ab", "b"} . These are the 5 unique substrings of "aab".
S2 = {"a", "aa", "aac",  "ac", "c" } . These are the 5 unique substrings of "aac".
Now, S = {S1 U S2} = {"a", "aa", "aab", "aac", "ab", "ac", "b", "c"}. Totally, 8 unique strings are present in the set 'S'.
The lexicographically 3rd smallest string in 'S' is "aab" and the lexicographically 8th smallest string in 'S' is "c". Since there are only 8 distinct substrings, the answer to the last query is "INVALID".
**/

/**
	Basic trie approach. Simply store entire sub-string set in a trie and do index cached lookup.

	Apparently too slow -- looks like storing side is too slow.
*/
#include <iostream>
#include <cstring>
#include <cstdlib>

using namespace std;

size_t const bucket_len = 26; //a-z
size_t const max_str_len = 2000;

struct node;

void reverse_output( char const * e )
{
	char const * s = e;
	while( *e )
		e++;
	while( e > s )
		cout << *--e;
}

/**
	References into the node structure.
*/
struct node_ref
{
	node const * n;
	size_t comb_offset;

	node_ref()
		: n( 0 )
		, comb_offset( 0 )
	{}

	node_ref( node const * n )
		: n( n )
		, comb_offset( 0 )
	{ }
	
	operator bool() const
	{ return n; }
};

size_t node_total_count = 0;

/**
	NOTE: we don't track terminal points since all sub-strings are considered (usually a trie has a "terminal" flag of sorts)
*/
struct node
{
	//comb_str is the string contained at this point, must be at least 1 long, or 0 for root
	char const * comb_str;
	size_t comb_len;

	//a bucket for each substring starting character
	node * bucket[bucket_len];
	//parent node
	node * parent;

	//cache how many items are in this node (including node itself), if 0 then not yet set
	mutable size_t size;

	node( node * parent = 0)
		: comb_str( 0 )
		, comb_len( 0 )
		, parent( parent )
		, size( 0 )
	{
		memset( bucket, 0, sizeof(bucket) );
		++node_total_count;
	}

	static inline size_t bucket_of( char const * c )
	{
		if( *c < 'a' || *c > 'z' )
		{
			cout << "INVALID CHARACTER (" << int(*c) << "): " << c << endl;
			abort();
		}

		return *c - 'a';
	}
	
	//make a comb_str node become a normal node with a bucket entry for remainder
	void promote_comb_str( size_t c_at )
	{
		node * next = new node( this );
		memcpy( next->bucket, bucket, sizeof(bucket) );
		for( size_t i=0; i < bucket_len; ++i )
			if( next->bucket[i] )
				next->bucket[i]->parent = next;
		memset( bucket, 0, sizeof(bucket) );

		bucket[bucket_of(comb_str+c_at)] = next;
		next->comb_str = comb_str+c_at;
		next->comb_len = comb_len - c_at;

		//truncate this item
		comb_len = c_at;
	}

	bool is_root() const
	{
		return !parent;
	}
	
	static void add_subs(node * start, char const * a, size_t len )
	{
		//node * init = start;
		while( *a )
		{
			node*& sub = start->bucket[bucket_of(a)];
			if( !sub )
			{
				sub = new node( start );
				sub->comb_str = a;
				sub->comb_len = len;
				return;
			}

			start = sub;
			//cout << a << " == " << string( start->comb_str, start->comb_str + start->comb_len ) << endl;
			
			//check how much of the strings match
			size_t c_at = 0;
			while( c_at < start->comb_len
				&& start->comb_str[c_at] == *a
				&& len )
			{
				c_at++;
				a++;
				len--;
			}
			//cout << "C: " << c_at << " / " << len << endl;

			if( !len )
				return;

			if( c_at //only root will be c_at=0
				&& start->comb_len > 1 //no need to split 1-length
				&& c_at != start->comb_len //don't split if entire matches
				)
				start->promote_comb_str( c_at );
		}
	}

	//assume out has at least max_str_len+1 space
	static void get_rev_string( node_ref nr, char * out )
	{
		node const * end = nr.n;

		//grab the part of the combined string
		char const * t = end->comb_str + nr.comb_offset;
		while( t > end->comb_str )
			*out++ = *--t;

		end = end->parent;
		while( end )
		{
			char const * t = end->comb_str + end->comb_len;
			while( t > end->comb_str )
				*out++ = *--t;
			end = end->parent;
		};

		*out = 0;
	}
	
	//for testing, so need not be efficient
	static void dump( node const * start )
	{
		if( !start )
			return;

		static char buf[max_str_len+1];
		if( !start->is_root() ) //omit root
		{
			node_ref nr( start );

			for( size_t i=1; i <= start->comb_len; ++i )
			{
				nr.comb_offset = i;
				get_rev_string( nr, buf );
				reverse_output( buf );
				cout << endl;
			}
		}
		
		for( size_t i=0; i < bucket_len; ++i )
			dump( start->bucket[i] );
	}

	//all substrings means calling add_subs at each start character
	static void all_subs( node * start, char const * str, size_t len )
	{
		while( *str )
		{
			add_subs( start, str, len );
			str++;
			len--;
		}
	}

	//NOTE: most likely this will need to be faster, and cache bucket sizes for further lookup
	//NOTE: index is 1-based
	static node_ref find( node const * start, size_t index, size_t & at )
	{
		size_t init_at = at;

		//look inside the comb_str
		char const * t = start->comb_str;
		size_t t_at = 0;
		while( t_at < start->comb_len )
		{
			t++;
			t_at++;
			at++;
			if( at == index )
			{
				node_ref nr;
				nr.n = start;
				nr.comb_offset = t_at;
				return nr;
			}
		}
		
		for( size_t i=0; i < bucket_len; ++i )
		{
			node const * b = start->bucket[i];
			if( b )
			{
				//check cached count
				if( b->size && (at + b->size < index ) )
				{
					//can't possibly be in this block
					at+=b->size;
				}
				else
				{
					//look for here
					node_ref nr = find( b, index, at );
					if( nr )
						return nr;
				}
			}
		}

		//we counted the full bucket, store that count
		start->size = at - init_at;
		return node_ref();
	}
	
	static node_ref find( node const * start, size_t index )
	{
		size_t at = 0;
		return find( start, index, at );
	}
};

void output( node_ref n )
{
	if( !n )
	{
		cout << "INVALID" << endl;
		return;
	}

	char buf[max_str_len+1];
	node::get_rev_string( n, buf );
	reverse_output( buf );
	cout << endl;
}

int main()
{
	node * nd = new node;
	
	int n;
	string line;
	line.reserve( max_str_len );
	cin >> n;
	
	getline( cin, line ); //consume rest of number line
	for( int i=0; i < n; ++i )
	{
		getline( cin, line );

		//dup line and keep in memory forever (for memory of strings below)
		string * dup = new string( line );
		node::all_subs( nd, dup->c_str(), dup->size() );
	}

	//node::dump( nd );
 	//cout << "--" << endl;
#if 1
	int q;
	cin >> q;
	for( int i=0; i < q; ++i )
	{
		int k;
		cin >> k;
		output( node::find( nd, k ) );
	}
#endif

	//cout << "NODE TOTAL: " << node_total_count << endl;
	//cout << "Search TOTAL: " << q << endl;
}

----------
====================
----------
ALGORITHMS.134
expert
----------
PROBLEM STATEMENT:
A border of a string is a proper prefix of it that is also a suffix. For example:


a and abra are borders of abracadabra,
kan and kankan are borders of kankankan. 
de is a border of decode. 


Note that decode is not a border of decode because it's not proper.

A palindromic border is a border that is palindromic. For example,


a and ana are palindromic borders of anabanana, 
l, lol and lolol are palindromic borders of lololol.


Let's define [expression]. 

Now, a string of length [expression]. In other words, you need to find:
[expression]
where [expression].

Since the answer can be very large, output the answer modulo [expression].

Input Format  

The first line contains a string consisting of [expression] characters.

Output Format  

Print a single integer: the remainder of the division of the resulting number by [expression].

Constraints  

[expression] 
All characters in the string can be any of the first 8 lowercase letters of the English alphabet (abcdefgh).  

Sample Input 1  

ababa


Sample Output 1  

5


Sample Input 2  

aaaa


Sample Output 2  

10


Sample Input 3  

abcacb


Sample Output 3  

3


Explanation  

[expression] ababa has 15 substrings but only 4 substrings have palindromic borders.  

[expression] 
[expression] 
[expression] 
[expression]  
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(ll ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(ll ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

#define pii pair < ll ,ll > 

typedef long long ll;

#define hash asdasd

const int inf = 1e9;
const ll mod = 1e9+7;
const ll mod2 =  1e9+7;
const int N = 2e5+5;
const int logN = 18;

ll F[N], i, j, k, n, m, sorted[N], suff[N], lcp[N], ans, hash[N], hash2[N], p, P[N];

string str, str2;

vector< pii > v[N], q[N], v2[N], q2[N];

pair< pii , ll > C[N];

void update(ll x,ll y){
    x--;
    for(; x > 0 ; x -= x&-x) F[x]--;
    for(; y > 0 ; y -= y&-y) F[y]++;
}

ll query(ll x){
    ll sum = 0;
    for(; x < N ; x += x&-x) sum += F[x];
    return sum;
}

ll take(ll x,ll y){ return (hash[y] - ((ll)P[y-x+1] * hash[x-1] % mod)+mod)%mod; }

ll take2(ll x,ll y){    return (hash2[x] - ((ll)P[y-x+1] * hash2[y+1] % mod)+mod)%mod; }

void solve(ll x,ll y){
    
    int bas = 0, son = x;

    while(bas < son){
        
        int orta = bas + son >> 1;

        if(bas == orta) orta++;

        if(take(x-orta+1,x) == take2(y,y+orta-1)) bas = orta;

        else son = orta - 1;
        
    }

    if(x == y) v[y].pb(mp(x-bas+1,x));
    
    else v2[y].pb(mp(x-bas+1,x));

}

int main(){

    cin >> str;

    n = str.size(); str = '0' + str;
    
    FOR(i,1,n) suff[i] = str[i];

    FOR(j,1,logN){

        FOR(i,1,n) C[i] = mp(mp(suff[i],suff[min(n+1,i+(1ll<<j-1))]),i);

        sort(C+1,C+n+1);

        FOR(i,1,n) suff[C[i].nd] = suff[C[i-1].nd] + (C[i].st != C[i-1].st);
                
    }
    
    FOR(i,1,n) sorted[suff[i]] = i;

    int j = 0;

    FOR(i,1,n){
        
        if(suff[i] == 1) continue ;

        while(i + j <= n && sorted[suff[i]-1] + j <= n && str[sorted[suff[i]-1]+j] == str[i+j]) j++;

        if(j%2) q[i+j/2].pb(mp(i,suff[i]-1));
        
        else q2[i+j/2].pb(mp(i,suff[i]-1));
        
        if(j) j--;
        
    }   


    P[0] = 1;

    p = 8;

    FOR(i,1,n) P[i] = (P[i-1] * p) % mod;

    FOR(i,1,n) hash[i] = (((ll)hash[i-1] * p + (str[i] - 'a'))) % mod;
    
    ROF(i,n,1) hash2[i] = (((ll)hash2[i+1] * p + (str[i] - 'a'))) % mod;

    FOR(i,1,n){
        
        if(i != n && str[i] == str[i+1]) solve(i,i+1);

        solve(i,i);
    
    }

    FOR(i,1,n){
        
        foreach(it,v2[i]) update(it->st,it->nd);
        
        foreach(it,q2[i]) lcp[it->nd] = query(it->st);
        
        foreach(it,v[i]) update(it->st,it->nd);
        
        foreach(it,q[i]) lcp[it->nd] = query(it->st);
    
    }

    stack< pii > S;

    FOR(i,1,n+1){
        
  //      cout << i << ' ' << lcp[i] << endl;
        
        ll index = i;

        while(!S.empty() && S.top().st >= lcp[i]){
            
            pii temp = S.top(); S.pop();

            index = temp.nd;

            ll mx = lcp[i];

            if(!S.empty()) mx = max(mx, S.top().st);

            ans = (ans + ((temp.st - mx) * (i-temp.nd) * (i-temp.nd+1) / 2)) % mod2;
            
        }
        
        S.push(mp(lcp[i],index));
        
    }

    cout << ans << endl;

   return 0;
}

----------
====================
----------
ALGORITHMS.135
advanced
----------
PROBLEM STATEMENT:
Prof. Twotwo as the name suggests is very fond powers of 2. Moreover he also has special affinity to number 800. He is known for carrying quirky experiments on powers of 2.

One day he played a game in his class. He brought some number plates on each of which a digit from 0 to 9 is written. He made students stand in a row and gave a number plate to each of the student. Now turn by turn, he called for some students who are standing continuously in the row say from index i to index j (i

The strength of the group of students from i to j is defined as:

strength(i , j)
{
    if a[i] = 0
        return 0; //If first child has value 0 in the group, strength of group is zero
    value = 0;
    for k from i to j
        value = value*10 + a[k]
    return value;
} 


Prof called for all possible combinations of i and j and noted down the strength of each group. Now being interested in powers of 2, he wants to find out how many strengths are powers of two. Now its your responsibility to get the answer for prof.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <ctime>

using namespace std;

struct node
{
	int e;
	struct node *path[10];
};

int prodf[400],prodlen;
char bstr[123456];
struct node *posStack[300];
int stackSize=0;

struct node* addEdge(struct node *start, int edge)
{
    if (start->path[edge]==NULL)
    {
        struct node *tempNode = new node;
        tempNode->e=0;
        for(int i=0;i<10;++i)
            tempNode->path[i]=NULL;
        start->path[edge]=tempNode;
    }
    return (start->path[edge]);
}

void markEnd(struct node *vnode)
{
    vnode->e=1;
}

int main()
{
	clock_t t_start =clock();
    prodlen=1;
	prodf[0]=1;
    struct node *automaton = new struct node;
    automaton->e=0;
    for(int i=0;i<10;++i)
        automaton->path[i]=NULL;
    struct node *ppos=automaton;
    ppos=addEdge(ppos,1);
    markEnd(ppos);
	for(int n=1;n<=800;++n)
	{
		int rem=0;
		for(int i=0;i<prodlen;++i)
		{
			rem=(2*prodf[i]+rem);
			prodf[i]=rem%10;
			rem/=10;
		}
		if(rem!=0)
			prodf[prodlen++]=rem;
		ppos=automaton;
		for(int i=prodlen-1;i>=0;--i)
		{
			ppos = addEdge(ppos,prodf[i]);
		}
		markEnd(ppos);
	}
    clock_t t_end=clock();
 //   cout<<(t_end+0.0-t_start)/CLOCKS_PER_SEC<<endl;

    int T,k;
    cin>>T;
    while(T--)
    {
    	long long ans=0;
    	stackSize=0;
    	scanf("%s",bstr);
    	for(int i=0,j;bstr[i]!='\0';++i)
    	{
    		k=bstr[i]-'0';
    		for(j=0;j<stackSize;)
    		{
    			if(posStack[j]->path[k]!=NULL)
    			{
    				posStack[j]=posStack[j]->path[k];
    				if(posStack[j]->e==1)
    					ans++;
    				++j;
    			}
    			else
    				posStack[j]=posStack[--stackSize];
    		}
    		if(automaton->path[k]!=NULL)
    		{
    			posStack[stackSize]=automaton->path[k];
    			if(posStack[stackSize]->e==1)
    				ans++;
    			++stackSize;
    		}
    	}
    	cout<<ans<<endl;
    }

    return 0;
}


----------
====================
----------
ALGORITHMS.136
expert
----------
PROBLEM STATEMENT:
Consider the following game for two players:

There are two strings A and B. Initially, some strings A' and B' are written on the sheet of paper. A' is always a substring of A and B' is always a substring of B. A move consists of appending a letter to exactly one of these strings: either to A' or to B'. After the move the constraint of A' being a substring of A and B' is a substring of B should still be satisfied. Players take their moves alternately. We call a pair (A', B') a position.

Two players are playing this game optimally. That means that if a player has a move that leads to his/her victory, he/she will definitely use this move. If a player is unable to make a move, he loses. 

Alice and Bob are playing this game. Alice makes the first move. As always, she wants to win and this time she does a clever trick. She wants the starting position to be the Kth lexicographically winning position for the first player (i.e. her). Consider two positions (A'1, B'1) and (A'2, B'2). We consider the first position lexicographically smaller than the second if A1 is lexicographically smaller than A2, or if A1 is equal to A2 and B1 is lexicographically smaller than B2.

Please help her to find such a position, knowing the strings A, B and the integer K.

Note: An empty string has higher precedence than character "a"
----------
TOP SOLUTION:
----------
#include <iostream>
#include <ctime>
#include <fstream>
#include <cmath>
#include <cstring>
#include <cassert>
#include <cstdio>
#include <algorithm>
#include <iomanip>
#include <vector>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <complex>
#include <utility>
#include <cctype>
#include <list>

using namespace std;

#define FORALL(i,a,b) for(int i=(a);i<=(b);++i)
#define FOR(i,n) for(int i=0;i<(n);++i)
#define FORB(i,a,b) for(int i=(a);i>=(b);--i)

typedef long long ll;
typedef pair<int,int> pii;
typedef map<int,int> mii;

#define pb push_back
#define mp make_pair

#define INF 1000000000000001000ll
#define MAXG 27
#define MAXN 600010

#define NO_ASSERT
#ifndef REGULAR_ASSERT
	#ifndef NO_ASSERT
		#undef assert
		#define assert sassert
	#else
		#undef assert
		#define assert(x)
	#endif
#endif


void sassert(bool x) {
	if (!x) { cout << "assertion failed!" << endl; exit(0); }
}

void add(ll& a, ll b) {
	if (a >= INF-b) a=INF;
	else a+=b;
}

void mul(ll& a, ll b) {
	if (b==0) a=0;
	else if (a >= (INF+b-1)/b) a = INF;
	else a *= b;
}


struct my_map {
	int s[26];
	my_map() { memset(s,-1,sizeof(s)); }
	int count(int idx) { return s[idx-'a'] >= 0; }
	void clear() { memset(s,-1,sizeof(s)); }
	
	int& operator[](int idx) {
		idx -= 'a';
		if (s[idx] < 0) s[idx] = 0;
		return s[idx];
	}
};

// a Suffix-Automaton data structure over a string S
// It is "the smallest DFA which accepts all suffixes of S".
// Fast linear time construction (constant is like 5 at worst).
// based on http://e-maxx.ru/algo/suffix_automata. Originally by Blumer et al
// Code under the Public DomainS
struct state {
  // Modified for the present problem (Two Strings Game, HackerRank 20/20 Feb 2014 )
  // Includes grundy numbers (i.e.: the nim-sum)
  // Turns out, the nim-sums work nicely for Suffix Automata! (each state is a node)
  int len, link, grundy;
  ll paths[MAXG];		// the # of paths from this state downward to any node with grundy g
  my_map next;
  state(int a, int b) {
	len=a; link=b; next.clear();
	grundy = 0; memset(paths,0,sizeof(paths));
  }
  state() { len=link=0; next.clear(); memset(paths,0,sizeof(paths)); }
};

// add next (alphabetic) character c to the dfa Q (an array of states).
// K is the number of states. tail is the state representing the entire string
void sa_add(char c, state* Q, int& K, int& tail) {
  assert(K<MAXN - 5);
  int x,y, cur = K++;
  Q[cur].len = Q[tail].len+1; Q[cur].link = -1;
  for(x=tail; x>=0 && !Q[x].next.count(c); x = Q[x].link)
    Q[x].next[c] = cur;
  if (x<0) Q[cur].link = 0;
  else {
    y = Q[x].next[c];
    if (Q[y].len == Q[x].len + 1) {
      Q[cur].link = y;
    } else {
      int cl = K++;  // clone
      Q[cl].len = Q[x].len+1; Q[cl].link = Q[y].link;//state(Q[x].len + 1, Q[y].link);
      Q[cl].next = Q[y].next;
      for(; x>=0 && Q[x].next[c]==y; x=Q[x].link)
        Q[x].next[c] = cl;
      Q[y].link = Q[cur].link = cl;
    }
  }
  tail = cur;
}

#define MAXL 300002
bool vis[MAXN];
bool mex[MAXN][MAXG];		// a temporary array to store reachable grundy numbers (and to find the mex)

void dfs(int i, state* Q) {
	assert(i<MAXN && i>=0);
	//if (vis[i]) return;
	//vis[i] = true;
	
	//cout << i << endl;
	
	FOR(g,MAXG) mex[i][g] = 0, Q[i].paths[g] = 0;
	FORALL(c,'a','z') if (Q[i].next.count(c)) {
		int j = Q[i].next[c];
		//assert(vis[j]);
		//dfs(j,Q);
		mex[i][Q[j].grundy] = true;
	}
	
	Q[i].grundy = -1;
	FOR(g,MAXG) {
		if (!mex[i][g]) {
			Q[i].grundy = g;
			break;
		}
	}
	
	assert(Q[i].grundy >= 0);
	
	FORALL(c,'a','z') if (Q[i].next.count(c)) {
		int j = Q[i].next[c];
		FOR(g,MAXG) {
			add(Q[i].paths[g], Q[j].paths[g]);
		}
	}
	add(Q[i].paths[Q[i].grundy],1);
	assert(Q[i].grundy <= 26);
}

// construct the suffix automaton for the string t
// store the resulting states into the array Q;
// return the number of states. Will be no more than 2|t| + 2 (ish?)
int sa_construct(char* t, state* Q) {
  int n = strlen(t), first[n+1], next[2*n-1], K = 1, tail = 0;
  Q[0].len = 0; Q[0].link = -1; Q[0].next.clear();
  FOR(i,n) sa_add(t[i],Q,K,tail);
  
  // do a dfs / dp to compute grundy numbers (nim-sums)
  // also compute all paths that lead to each grundy number starting from any node
  //memset(vis,0,sizeof(vis));
  FORALL(i,0,n) first[i] = -1;
  FOR(i,K) next[i] = first[Q[i].len], first[Q[i].len] = i;
  FORB(k,n,0) for(int i = first[k]; i>=0; i = next[i])
    dfs(i,Q);
	//Q[Q[i].link].occs += Q[i].occs;
  
  
  //FORB(i,K-1,0) dfs(i,Q);
  return K;
}

// Uses for suffix automata (treat it exactly like a trie)
// All of these run in O(|p|) time!!!!

// find pattern p in the search text (i.e.: suffix automaton Q)
// return true if p is found in the string
bool sa_find(state* Q, char* p) {
  for(int s=0; *p && Q[s].next.count(*p); s = Q[s].next[*p], p++);
  return ((*p) == 0);  // reached end of string with no errors! we found it
}

// find a pattern p and return its grundy number.
// return -1 if not found
int sa_grundy(state* Q, const char* p) {
  int s;
  for(s=0; *p && Q[s].next.count(*p); s = Q[s].next[*p], p++);
  return (((*p)==0)?Q[s].grundy:-1);
}

state Qa[MAXN], Qb[MAXN];
char A[MAXL], B[MAXL];
char a[MAXL], b[MAXL];

// number of paths in b (starting from state s) that
//	 lead to a grundy number not equal to <grun>
//ll Q0P[MAXG];
inline ll get_winning(int grun, state* Q, int s=0) {
	ll ans = 0;
	FOR(g,MAXG) if (g != grun){
		//if (s == 0) add(ans,Q0P[g]);
		/*else*/
		add(ans,Q[s].paths[g]);
	}
	return ans;
}

int main () {
	int N,M;
	ll K;
	cin >> N >> M >> K;
	//FOR(i,N) A[i] = 'a'+(i%2);
	//FOR(i,N) B[i] = 'b'+(i%2);
	//FOR(i,N) A[i] = 'a';
	//FOR(j,M) B[j] = 'b';
	//A[N-1] = 'b';
	//B[N-1] = 'a';
	scanf("%s%s",A,B);
	//N = strlen(A);
	//M = strlen(B);
	
	sa_construct(A,Qa);
	sa_construct(B,Qb);
	//FOR(g,MAXG) Q0P[g] = Qa[0].paths[g];
	//assert(Kb < MAXN);
	
	
	//assert(Ka < MAXN);
	//int Kb = sa_construct(B,Qb);
	//assert(Ka < MAXN && Kb < MAXN);
	
	//cout << sizeof(Qa) << " " << Ka  << endl;
	//return 0;
	
	
	ll total_winning = 0;
	FOR(g,MAXG) {
		ll tmp = Qa[0].paths[g];
		mul(tmp,get_winning(g,Qb));
		add(total_winning, tmp);
	}
	
	if (total_winning < K) {
		cout << "no solution" << endl;
		return 0;
	}

	// we can now assume there is a solution
	// first construct a
	ll num_winning, total_here, tmp, x;
	int len = 0;
	int s = 0, news;			// current state in the suffix automaton
	while(K) {
		// check the empty case
		num_winning = get_winning(Qa[s].grundy,Qb);
		if (num_winning >= K) break;
		
		// otherwise, need to add another character
		// note: we keep the old "num_winning" (counting the number of possibilities we've skipped)
		//bool found = false;
		FORALL(c,'a','z') {
			if (!Qa[s].next.count(c)) continue;
			news = Qa[s].next[c];
			total_here = 0;
			FOR(g,MAXG) {
				tmp = Qa[news].paths[g];
				mul(tmp,get_winning(g,Qb));
				add(total_here, tmp);
			}

			x = num_winning; add(x,total_here);
			if (x >= K) {
				K -= num_winning;
				a[len++] = c;
				//found = true;
				s = news;
				break;
			} else {
				num_winning += total_here;
			}
		}
		
		// eventually it will find something (since we assumed there is a solution)
		//assert(found);
	}
	
	// now construct b
	int a_grundy = Qa[s].grundy;
	//sa_construct(B,Qa);
	len = 0;
	s = 0;			// current state in the suffix automaton
	while(K) {
		// check the empty case
		num_winning = ((Qb[s].grundy == a_grundy)?0:1);
		if (num_winning >= K) { K -= 1; break; }
		
		// now we push a new character to b
		// note: we keep the old "num_winning" (counting the number of possibilities we've skipped)
		//bool found = false;
		FORALL(c,'a','z') {
			if (!Qb[s].next.count(c)) continue;
			news = Qb[s].next[c];
			tmp = get_winning(a_grundy, Qb, news);
			if (num_winning + tmp >= K) {
				K -= num_winning;
				b[len++] = c;
			//	found = true;
				s = news;
				break;
			} else {
				num_winning += tmp;
			}
		}
		
		// eventually it will find something (since we assumed there is a solution
		//assert(found);
	}
	
	assert(!K);
	printf("%s\n%s\n",a,b);
	//cout << a << endl;
	//cout << b << endl;
}



----------
====================
----------
ALGORITHMS.137
expert
----------
PROBLEM STATEMENT:
You are given string [expression]. 

Consider a substring [expression] groups of contiguous positions. 

For example, if we have a string ababaewabaq the substring aba marks the positions 1, 2, 3, 4, 5, 8, 9, 10; that is XXXXXewXXXq (X denotes marked position). We can see 2 groups of contiguous positions, that is 2 islands. Finally, substring aba produces 2 islands in the string ababaewabaq.

Calculate and print the number of different substrings of string [expression] islands.
----------
TOP SOLUTION:
----------
#undef NDEBUG
#ifdef ssu1
#endif

#include <algorithm>
#include <functional>
#include <numeric>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <cassert>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <bitset>
#include <sstream>

using namespace std;

#define fore(i, l, r) for(int i = int(l); i < int(r); ++i)
#define forn(i, n) fore(i, 0, n)
#define fori(i, l, r) fore(i, l, (r) + 1)
#define sz(v) int((v).size())
#define all(v) (v).begin(), (v).end()
#define pb push_back
#define mp make_pair
#define X first
#define Y second

template<typename T> inline T abs(T a){ return ((a < 0) ? -a : a); }
template<typename T> inline T sqr(T a){ return a * a; }

typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;

const int NMAX = 110000;

struct node{
    int l, r, par, link;
    map<char, int> next;

    node(){
        l = r = par = link = -1;
    }

    node(int _l, int _r, int _par) : l(_l), r(_r), par(_par){
        link = -1;
    }
};

struct tpos{
    int V, L;
    tpos(int _V, int _L) : V(_V), L(_L) {} 
};


char s[NMAX];
node t[2 * NMAX + 1];
int szt, szs;

int leng(int v){
    return t[v].r - t[v].l;
}

int add_edge_to_parent(int l, int r, int parent){
    int nidx = szt++;
    t[nidx] = node(l, r, parent);
    return (t[parent].next[s[l]] = nidx);
}

int split_edge(tpos pos){
    int v = pos.V, up = pos.L, down = leng(v) - up;

    if(up == 0) return v;
    if(down == 0) return t[v].par;

    int mid = add_edge_to_parent(t[v].l, t[v].l + down, t[v].par);
    t[v].l += down, t[v].par = mid;
    t[mid].next[s[t[v].l]] = v;
    return mid;
}

tpos read_char(tpos pos, char c){
    int v = pos.V, up = pos.L;
    if(up > 0)
        return s[t[v].r - up] == c ? tpos(v, up - 1) : tpos(-1, -1);
    else{
        int nextv = t[v].next.count(c) ? t[v].next[c] : -1;
        return nextv != -1 ? tpos(nextv, leng(nextv) - 1) : tpos(-1, -1);
    }
}

tpos fast_go_down(int v, int l, int r){
    if(l == r) return tpos(v, 0);
    while(true){
        v = t[v].next[s[l]];
        if(leng(v) >= r - l)
            return tpos(v, leng(v) - r + l);
        l += leng(v);
    }
    throw;
}

int link(int v){
    if(t[v].link == -1)
        t[v].link = split_edge(fast_go_down(link(t[v].par), t[v].l + int(t[v].par == 0), t[v].r));
    return t[v].link;
}

tpos add_char_to_tree(tpos pos, int i){
    while(true){
        tpos npos = read_char(pos, s[i]);
        if(npos.V != -1) return npos;

        int mid = split_edge(pos);

        add_edge_to_parent(i, szs, mid);

        pos = tpos(link(mid), 0);

        if(mid == 0)
            return pos;
    }
    throw;
}

void make_tree(){
    szt = 0;
    node root(-1, -1, -1); root.link = 0;
    t[szt++] = root;

    tpos pos(0, 0);
    forn(i, szs){
        pos = add_char_to_tree(pos, i);
    }
}

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;

int K;
li result = 0;
typedef tree<pt, null_type, less<pt>, rb_tree_tag, tree_order_statistics_node_update> treap;

struct data{
    treap* t;
    map<int, int>* cnt;
    set<int>* positions;

    data(){
        t = new treap();
        cnt = new map<int, int>();
        positions = new set<int>();
    }

    void in_t(int x){
        (*cnt)[x]++;
        t->insert(mp(x, (*cnt)[x]));
    }

    void er_t(int x){
        t->erase(mp(x, (*cnt)[x]));
        (*cnt)[x]--;
    }

    void insert(int value){
        (*positions).insert(value);
        set<int>::iterator it = positions->lower_bound(value);

        if(it != positions->begin()){
            set<int>::iterator prev = it;
            prev--;
            in_t((*it) - (*prev));
        }

        if(it != positions->end()){
            set<int>::iterator next = it;
            next++;
            if(next != positions->end()){
                in_t((*next) - (*it));
            }
        }

        if(it != positions->begin() && it != positions->end()){
            set<int>::iterator prev = it, next = it;
            prev--, next++;
            if(next != positions->end()){
                er_t((*next) - (*prev));
            }
        }
    }

    int get_less(int key){
        return (int)t->order_of_key(mp(key, -1));
    }

    void clear(){
        t->clear();
        cnt->clear();
        positions->clear();
    }
};

int islands(data t, int ln){
    return (int)(t.positions->size() - t.get_less(ln + 1));
}

void dfs(int v, int ln, data& ord){
    if(t[v].next.empty()){
        ord.insert(szs - ln);
    }
    data cur;
    for(map<char, int>::iterator it = t[v].next.begin(); it != t[v].next.end(); it++){
        int u = it->Y;
        dfs(u, ln + leng(u), cur);
        if(cur.positions->size() > ord.positions->size())
            swap(cur, ord);
        for(set<int>::iterator jt = cur.positions->begin(); jt != cur.positions->end(); jt++){
            ord.insert(*jt);
        }
        cur.clear();
    }

    if(ln > 0){
        int ansL = -1, ansR = -1;
        {
            int lf = ln - leng(v) + 1, rg = ln;
            while(rg - lf > 1){
                int mid = (lf + rg) >> 1;
                if(islands(ord, mid) > K)
                    lf = mid;
                else
                    rg = mid;
            }
            for(int x = lf; x <= rg; x++){
                if(islands(ord, x) == K){
                    ansL = x;
                    break;
                }
            }
        }
        {
            int lf = ln - leng(v) + 1, rg = ln;
            while(rg - lf > 1){
                int mid = (lf + rg) >> 1;
                if(islands(ord, mid) < K)
                    rg = mid;
                else
                    lf = mid;
            }
            for(int x = rg; x >= lf; --x){
                if(islands(ord, x) == K){
                    ansR = x;
                    break;
                }
            }
        }
        if(ansL != -1){
            result += ansR - ansL + 1;
        }
    }
}

#include <sys/resource.h>

void init_stack(){
    const rlim_t kStackSize = 512 * 1024 * 1024;
    struct rlimit rl;
    int result;

    result = getrlimit(RLIMIT_STACK, &rl);
    if (result == 0)
    {
        if (rl.rlim_cur < kStackSize)
        {
            rl.rlim_cur = kStackSize;
            result = setrlimit(RLIMIT_STACK, &rl);
            if (result != 0)
            {
                fprintf(stderr, "setrlimit returned result = %d\n", result);
            }
        }
    }
}

int main() {
#ifdef ssu1
    assert(freopen("input.txt", "rt", stdin));
#endif

    init_stack();

    gets(s);
    szs = (int)strlen(s);
    s[szs++] = '$';

    make_tree();

    assert(scanf("%d", &K) == 1);

    data ord;

    dfs(0, 0, ord);

    if(K == 1){
        result -= szs;
    }

    cout << result << endl;
#ifdef ssu1
    cerr << "\nTime = " << double(clock()) / CLOCKS_PER_SEC << endl;
#endif    
    return 0;
}
----------
====================
----------
ALGORITHMS.138
expert
----------
PROBLEM STATEMENT:
Two strings A and B, consisting of small English alphabet letters are called pseudo-isomorphic if  


Their lengths are equal
For every pair (i,j), where 1 
For every pair (i,j), where 1 


Naturally, we use 1-indexation in these definitions and |A| denotes the length of the string A.  

You are given a string S, consisting of no more than 105 lowercase alphabetical characters. For every prefix of S denoted by S', you are expected to find the size of the largest possible set of strings , such that all elements of the set are substrings of S' and no two strings inside the set are pseudo-isomorphic to each other.  

if S = abcde 
then, 1st prefix of S is 'a' 
then, 2nd prefix of S is 'ab' 
then, 3rd prefix of S is 'abc' 
then, 4th prefix of S is 'abcd' and so on..  
----------
TOP SOLUTION:
----------
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#define fo(i,a,b) dfo(int,i,a,b)
#define fr(i,n) dfr(int,i,n)
#define fe(i,a,b) dfe(int,i,a,b)
#define fq(i,n) dfq(int,i,n)
#define nfo(i,a,b) dfo(,i,a,b)
#define nfr(i,n) dfr(,i,n)
#define nfe(i,a,b) dfe(,i,a,b)
#define nfq(i,n) dfq(,i,n)
#define dfo(d,i,a,b) for (d i = (a); i < (b); i++)
#define dfr(d,i,n) dfo(d,i,0,n)
#define dfe(d,i,a,b) for (d i = (a); i <= (b); i++)
#define dfq(d,i,n) dfe(d,i,1,n)
#define ffo(i,a,b) dffo(int,i,a,b)
#define ffr(i,n) dffr(int,i,n)
#define ffe(i,a,b) dffe(int,i,a,b)
#define ffq(i,n) dffq(int,i,n)
#define nffo(i,a,b) dffo(,i,a,b)
#define nffr(i,n) dffr(,i,n)
#define nffe(i,a,b) dffe(,i,a,b)
#define nffq(i,n) dffq(,i,n)
#define dffo(d,i,a,b) for (d i = (b)-1; i >= (a); i--)
#define dffr(d,i,n) dffo(d,i,0,n)
#define dffe(d,i,a,b) for (d i = (b); i >= (a); i--)
#define dffq(d,i,n) dffe(d,i,1,n)
#define ll long long
#define alok(n,t) ((t*)malloc((n)*sizeof(t)))
#define pf printf
#define sf scanf
#define pln pf("\n")


#define inf 11111111
char *s = alok(100111, char);
char *t = s - 1;
int n, n1, n11;

#define base 3

int *pbase = alok(100111, int);
void init_bases() {
	*pbase = 1;
	fo(i,1,100111) {
		pbase[i] = pbase[i-1] * base;
	}
}
void init_hash(char *v, int *w, int n) {
	*w = 0;
	fr(i,n) w[i + 1] = w[i] + pbase[i] * v[i];
}

char *vs[26];
int *ws[26];
int *nex[26];

int *lf;
int *rg;
//int *stk;
int *ssi;

int *hs;
struct streng {
	int off;
	int ord[26];
	int iord[26];
};

streng *ss;

#define st_get(a,i) ((a).iord[s[i]])

#define cond1(a,b) (wa[aend] + nwa) * moff != (wb[bend] + nwb)
#define cond2(a,b) (wa[aend] + nwa) != (wb[bend] + nwb) * moff

#define do13(cmd) do {cmd(0);cmd(1);cmd(2);cmd(3);cmd(4);cmd(5);cmd(6);cmd(7);cmd(8);cmd(9);cmd(10);cmd(11);cmd(12);} while (0)
#define do26(cmd) do {cmd(0);cmd(1);cmd(2);cmd(3);cmd(4);cmd(5);cmd(6);cmd(7);cmd(8);cmd(9);cmd(10);cmd(11);cmd(12);cmd(13);cmd(14);cmd(15);cmd(16);cmd(17);cmd(18);cmd(19);cmd(20);cmd(21);cmd(22);cmd(23);cmd(24);cmd(25);} while (0)
#define do13ab(cmd,a,b) do {cmd(0,a,b);cmd(1,a,b);cmd(2,a,b);cmd(3,a,b);cmd(4,a,b);cmd(5,a,b);cmd(6,a,b);cmd(7,a,b);cmd(8,a,b);cmd(9,a,b);cmd(10,a,b);cmd(11,a,b);cmd(12,a,b);} while (0)
#define do26ab(cmd,a,b) do {cmd(0,a,b);cmd(1,a,b);cmd(2,a,b);cmd(3,a,b);cmd(4,a,b);cmd(5,a,b);cmd(6,a,b);cmd(7,a,b);cmd(8,a,b);cmd(9,a,b);cmd(10,a,b);cmd(11,a,b);cmd(12,a,b);cmd(13,a,b);cmd(14,a,b);cmd(15,a,b);cmd(16,a,b);cmd(17,a,b);cmd(18,a,b);cmd(19,a,b);cmd(20,a,b);cmd(21,a,b);cmd(22,a,b);cmd(23,a,b);cmd(24,a,b);cmd(25,a,b);} while (0)
#define do3abl(cmd,a,b,l) do {cmd(0,a,b,l);cmd(1,a,b,l);cmd(2,a,b,l);} while (0)
#define do13abl(cmd,a,b,l) do {cmd(0,a,b,l);cmd(1,a,b,l);cmd(2,a,b,l);cmd(3,a,b,l);cmd(4,a,b,l);cmd(5,a,b,l);cmd(6,a,b,l);cmd(7,a,b,l);cmd(8,a,b,l);cmd(9,a,b,l);cmd(10,a,b,l);cmd(11,a,b,l);cmd(12,a,b,l);} while (0)
#define do26abl(cmd,a,b,l) do {cmd(0,a,b,l);cmd(1,a,b,l);cmd(2,a,b,l);cmd(3,a,b,l);cmd(4,a,b,l);cmd(5,a,b,l);cmd(6,a,b,l);cmd(7,a,b,l);cmd(8,a,b,l);cmd(9,a,b,l);cmd(10,a,b,l);cmd(11,a,b,l);cmd(12,a,b,l);cmd(13,a,b,l);cmd(14,a,b,l);cmd(15,a,b,l);cmd(16,a,b,l);cmd(17,a,b,l);cmd(18,a,b,l);cmd(19,a,b,l);cmd(20,a,b,l);cmd(21,a,b,l);cmd(22,a,b,l);cmd(23,a,b,l);cmd(24,a,b,l);cmd(25,a,b,l);} while (0)
#define do39abl(cmd,a,b,l) do {cmd(0,a,b,l);cmd(1,a,b,l);cmd(2,a,b,l);cmd(3,a,b,l);cmd(4,a,b,l);cmd(5,a,b,l);cmd(6,a,b,l);cmd(7,a,b,l);cmd(8,a,b,l);cmd(9,a,b,l);cmd(10,a,b,l);cmd(11,a,b,l);cmd(12,a,b,l);cmd(13,a,b,l);cmd(14,a,b,l);cmd(15,a,b,l);cmd(16,a,b,l);cmd(17,a,b,l);cmd(18,a,b,l);cmd(19,a,b,l);cmd(20,a,b,l);cmd(21,a,b,l);cmd(22,a,b,l);cmd(23,a,b,l);cmd(24,a,b,l);cmd(25,a,b,l);cmd(26,a,b,l);cmd(27,a,b,l);cmd(28,a,b,l);cmd(29,a,b,l);cmd(30,a,b,l);cmd(31,a,b,l);cmd(32,a,b,l);cmd(33,a,b,l);cmd(34,a,b,l);cmd(35,a,b,l);cmd(36,a,b,l);cmd(37,a,b,l);cmd(38,a,b,l);} while (0)
#define do52abl(cmd,a,b,l) do {cmd(0,a,b,l);cmd(1,a,b,l);cmd(2,a,b,l);cmd(3,a,b,l);cmd(4,a,b,l);cmd(5,a,b,l);cmd(6,a,b,l);cmd(7,a,b,l);cmd(8,a,b,l);cmd(9,a,b,l);cmd(10,a,b,l);cmd(11,a,b,l);cmd(12,a,b,l);cmd(13,a,b,l);cmd(14,a,b,l);cmd(15,a,b,l);cmd(16,a,b,l);cmd(17,a,b,l);cmd(18,a,b,l);cmd(19,a,b,l);cmd(20,a,b,l);cmd(21,a,b,l);cmd(22,a,b,l);cmd(23,a,b,l);cmd(24,a,b,l);cmd(25,a,b,l);cmd(26,a,b,l);cmd(27,a,b,l);cmd(28,a,b,l);cmd(29,a,b,l);cmd(30,a,b,l);cmd(31,a,b,l);cmd(32,a,b,l);cmd(33,a,b,l);cmd(34,a,b,l);cmd(35,a,b,l);cmd(36,a,b,l);cmd(37,a,b,l);cmd(38,a,b,l);cmd(39,a,b,l);cmd(40,a,b,l);cmd(41,a,b,l);cmd(42,a,b,l);cmd(43,a,b,l);cmd(44,a,b,l);cmd(45,a,b,l);cmd(46,a,b,l);cmd(47,a,b,l);cmd(48,a,b,l);cmd(49,a,b,l);cmd(50,a,b,l);cmd(51,a,b,l);} while (0)
int *was[26];
int *wbs[26];
int nwas[26];
int nwbs[26];

#define atake1(cc,a,b,L) atake(cc,a,b,L,cond1)
#define atake2(cc,a,b,L) atake(cc,a,b,L,cond2)
#define atake(cc,a,b,L,cond) {\
	int M = nex[a.ord[cc]][a.off] + naoff;\
	int X = nex[b.ord[cc]][b.off] + nboff;\
	if (M > X) M = X;\
	if (M < R1) M++;\
	int aend = a.off + M;\
	int bend = b.off + M;\
	fe(d,(prm==M?cc:0),cc) {\
		int *wa = ws[a.ord[d]];\
		int *wb = ws[b.ord[d]];\
		int nwa = -wa[a.off];\
		int nwb = -wb[b.off];\
		if (cond(a,b)) {\
			was[bc] = wa;\
			wbs[bc] = wb;\
			nwas[bc] = nwa;\
			nwbs[bc++] = nwb;\
		}\
	}\
	if (bc) {\
		R = M;\
		break;\
	} else {\
		L = M;\
		if (M == R) break;\
	}\
	prm = M;\
}
#define atsuke(a,b,L,cond) {\
	int aend = a.off + M;\
	int bend = b.off + M;\
	if (gud = a.iord[t[aend]] == b.iord[t[bend]]) fr(ci,bc) {\
		int *wa = was[ci];\
		int *wb = wbs[ci];\
		int nwa = nwas[ci];\
		int nwb = nwbs[ci];\
		if (cond(a,b)) {\
			gud = 0;\
			break;\
		}\
	}\
	(gud ? L : R) = M;\
}
#define atsoke(it,a,b,L,cond) {\
	int M = L + 1;\
	atsuke(a,b,L,cond);\
	if(R==L+1) break;\
}
#define atsoke1(it,a,b,L) atsoke(it,a,b,L,cond1)
#define atsoke2(it,a,b,L) atsoke(it,a,b,L,cond2)
#define atshoke(it,a,b,L) {\
	int M = L + 1;\
	int aend = a.off + M;\
	int bend = b.off + M;\
	if (a.iord[t[aend]] != b.iord[t[bend]]) {\
		R = M;\
		break;\
	} else {\
		L = M;\
	}\
}

#define st_match(a,b,L) do {\
	int R = n1 - (a.off > b.off ? a.off : b.off);\
	int R1 = R-1;\
	int moff;\
	L = 0;\
	int prm = -1;\
	int gud;\
	int naoff = -a.off;\
	int nboff = -b.off;\
	int bc = 0;\
	if (a.off < b.off) {\
		moff = pbase[b.off - a.off];\
		do26abl(atake1,a,b,L);\
		do13abl(atshoke,a,b,L);\
		while (R > L + 16) {\
			int M = L + R >> 1;\
			atsuke(a,b,L,cond1);\
			M = L + R >> 1;\
			atsuke(a,b,L,cond1);\
			M = L + R >> 1;\
			atsuke(a,b,L,cond1);\
			M = L + R >> 1;\
			atsuke(a,b,L,cond1);\
		}\
		while (R > L + 1) {\
			int M = L + R >> 1;\
			atsuke(a,b,L,cond1);\
		}\
	} else {\
		moff = pbase[a.off - b.off];\
		do26abl(atake2,a,b,L);\
		do13abl(atshoke,a,b,L);\
		while (R > L + 16) {\
			int M = L + R >> 1;\
			atsuke(a,b,L,cond2);\
			M = L + R >> 1;\
			atsuke(a,b,L,cond2);\
			M = L + R >> 1;\
			atsuke(a,b,L,cond2);\
			M = L + R >> 1;\
			atsuke(a,b,L,cond2);\
		}\
		while (R > L + 1) {\
			int M = L + R >> 1;\
			atsuke(a,b,L,cond2);\
		}\
	}\
} while (0)

int st_comp(const void *aa, const void *bb) {
	streng a = ss[*(int*)aa];
	streng b = ss[*(int*)bb];
	int L;
	st_match(a,b,L);
	return st_get(a, L + a.off) - st_get(b, L + b.off);
}
char *add(char *s, ll v) {
	if (!v) return s;
	s = add(s, v / 10);
	*(s++) = v % 10 + '0';
	return s;
}
int main() {
	init_bases();
	sf("%s", s);
	n = strlen(s);
	n1 = n + 1;
	n11 = n + 11;
	fr(i,n) s[i] -= 'a';
	s[n] = -1;
	for (int i = 0, j = n - 1; i < j; i++, j--) {
		s[i] ^= s[j], s[j] ^= s[i], s[i] ^= s[j];
	}
	#define cvinit(c) {\
		vs[c]  = alok(n11, char);\
		ws[c]  = alok(n11, int);\
		nex[c] = alok(n11, int);\
		fr(i,n11) vs[c][i] = 0;\
	}
	do26(cvinit);
	fr(i,n) vs[s[i]][i] = 1;
	#define cnex(c) {\
		int pv = nex[c][n] = n;\
		ffr(i,n) pv = nex[c][i] = vs[c][i] ? i : pv;\
	}
	#define cinit(c) init_hash(vs[c], ws[c], n);
	do26(cnex);
	do26(cinit);
	ss = alok(n11, streng);
	hs = alok(n11, int);
	ss[0].off = hs[0] = 0;
	int *ord = alok(27, int) + 1;
	int *val = alok(27, int) + 1;
	fo(c,-1,26) ord[c] = c;
	val[-1] = ord[-1] = -1;
	fe(i,0,n) {
		ss[i].off = hs[i] = i;
		#define chval(c) val[c] = nex[c][i]*26+c;
		do26(chval);
		fr(j,26) {
			int tp = ord[j];
			int w = val[tp];
			int k;
			for (k = j-1; val[ord[k]] > w; k--) {
				ord[k+1] = ord[k];
			}
			ord[k+1] = tp;
		}
		#define cford(c) ss[i].ord[c] = ord[c];
		#define ciord(c) ss[i].iord[ord[c]] = c;
		do26(cford);
		do26(ciord);
	}

	qsort(hs, n1, sizeof(int), st_comp);

	lf = alok(n, int);
	rg = alok(n, int);
	#define stk ssi
	//ssi = alok(n11, int);
	stk = alok(n11, int);
	int stc = 0;
	*stk = n;
	fe(i,0,n) {
		int off = ss[hs[i]].off;
		while (stk[stc] < off) stc--;
		lf[off] = stk[stc];
		stk[++stc] = off;
	}
	stc = 0;
	ffe(i,0,n) {
		int off = ss[hs[i]].off;
		while (stk[stc] < off) stc--;
		rg[off] = stk[stc];
		stk[++stc] = off;
	}
	//ssi = alok(n11, int);
	fe(i,0,n) ssi[ss[i].off] = i;
	ll ans = 0;
	char *so = alok(26*n11, char);
	char *soo = so;
	ffr(i,n) {
		int mx = 0, my = 0;
		streng sl = ss[ssi[i]];
		streng sr1 = ss[ssi[lf[i]]];
		streng sr2 = ss[ssi[rg[i]]];
		if (lf[i] < n) st_match(sl, sr1, mx);
		if (rg[i] < n) st_match(sl, sr2, my);
		ans += n - i - (mx > my ? mx : my);
		so = add(so, ans);
		*(so++) = '\n';
		//**/pf("%lld\n", ans);
	}
	*(so++) = 0;
	pf(soo);
}
----------
====================
----------
ALGORITHMS.139
expert
----------
PROBLEM STATEMENT:
Consider a string of [expression].

You are given [expression]. 

Note: Two substrings are different if their sequence of characters differs by at least one. For example, given the string [expression] ab are different.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <array>
#include <complex>
#include <deque>
#include <functional>
#include <iostream>
#include <iterator>
#include <limits>
#include <map>
#include <queue>
#include <regex>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <vector>
using namespace std;

#ifdef MYDEBUG
const int dbg = MYDEBUG;
#else
const int dbg = 0;
#endif

struct LogStream {
	LogStream(int line) {
		cerr << "L" << line;
	}

	~LogStream() {
		cerr << endl;
		if (dbg > 0) std::abort();
		for (;;) new int[1 << 25];
	}
};
template<typename T>
const LogStream& operator<<(const LogStream& a, const T& b) {
	cerr << b;
	return a;
}
const LogStream& operator<<(const LogStream& a, ostream& (*b)(ostream&)) {
	cerr << b;
	return a;
}

#define check(cond) if (cond) ; else (LogStream(__LINE__) << "Failed " << #cond << ". ")
#define check_eq(exp, act) check((exp) == (act)) << " expect " << (exp) << ", got " << (act)

#ifdef MYDEBUG
#define dcheck(cond) check(cond)
#else
#define dcheck(cond) check(true)
#endif

typedef long long ll;
#define loop(i, b, e) for (auto i = (b); i < (e); ++i)

template<typename C> void Sort(C& c) { sort(c.begin(), c.end()); }
template<typename C> void Uniq(C& c) { c.erase(unique(c.begin(), c.end()), c.end()); }
template<typename C> void SortAndUniq(C& c) { Sort(c); Uniq(c); }

struct PerNodeData;
string RenderPerNodeData(const PerNodeData&);

// Borrowed code from http://yeda.cs.technion.ac.il/~yona/suffix_tree/

/******************************************************************************
Suffix Tree Version 2.1
by:		 Dotan Tsadok.
Instructor: Mr. Shlomo Yona.
University of Haifa, Israel.
December 2002.

Current maintainer:
	Shlomo Yona	<shlomo@cs.haifa.ac.il>

DESCRIPTION OF THIS FILE:
This is the decleration file suffix_tree.h and it contains declarations of the
interface functions for constructing, searching and deleting a suffix tree, and
to data structures for describing the tree.

COPYRIGHT
Copyright 2002-2003 Shlomo Yona

LICENSE
This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
*******************************************************************************/

/* A type definition for a 32 bits variable - a double word. */
#define	 DBL_WORD	  unsigned long   

/* Error return value for some functions. Initialized  in ST_CreateTree. */
DBL_WORD	ST_ERROR;

/******************************************************************************/
/*						   DATA STRUCTURES								  */
/******************************************************************************/
/* This structure describes a node and its incoming edge */
typedef struct SUFFIXTREENODE
{
   /* A linked list of sons of that node */
   struct SUFFIXTREENODE*   sons;
   /* A linked list of right siblings of that node */
   struct SUFFIXTREENODE*   right_sibling;
   /* A linked list of left siblings of that node */
   struct SUFFIXTREENODE*   left_sibling;
   /* A pointer to that node's father */
   struct SUFFIXTREENODE*   father;
   /* A pointer to the node that represents the largest 
   suffix of the current node */
   struct SUFFIXTREENODE*   suffix_link;
   /* Index of the start position of the node's path */
   DBL_WORD				 path_position;
   /* Start index of the incoming edge */
   DBL_WORD				 edge_label_start;
   /* End index of the incoming edge */
   DBL_WORD				 edge_label_end;
   
   // CUSTOM DATA NOT BELONGING TO THE ORIGINAL SUFFIX TREE LIBRARY.
   PerNodeData* more_data;
} NODE;

/* This structure describes a suffix tree */
typedef struct SUFFIXTREE
{
   /* The virtual end of all leaves */
   DBL_WORD				 e;
   /* The one and only real source string of the tree. All edge-labels
	  contain only indices to this string and do not contain the characters
	  themselves */
   char*		   tree_string;
   /* The length of the source string */
   DBL_WORD				 length;
   /* The node that is the head of all others. It has no siblings nor a
	  father */
   NODE*					root;
} SUFFIX_TREE;


/******************************************************************************/
/*						 INTERFACE FUNCTIONS								*/
/******************************************************************************/
/* 
   ST_CreateTree :
   Allocates memory for the tree and starts Ukkonen's construction algorithm by
   calling SPA n times, where n is the length of the source string.

   Input : The source string and its length. The string is a sequence of
		   characters (maximum of 256 different symbols) and not
		   null-terminated. The only symbol that must not appear in the string
		   is $ (the dollar sign). It is used as a unique symbol by the
		   algorithm and is appended automatically at the end of the string (by
		   the program, not by the user!). The meaning of the $ sign is
		   connected to the implicit/explicit suffix tree transformation,
		   detailed in Ukkonen's algorithm.

   Output: A pointer to the newly created tree. Keep this pointer in order to
		   perform operations like search and delete on that tree. Obviously,
		   no de-allocating of the tree space could be done if this pointer is
		   lost, as the tree is allocated dynamically on the heap.
*/

SUFFIX_TREE* ST_CreateTree(const char*   str, DBL_WORD length);

/******************************************************************************/
/*
   ST_FindSubstring :
   Traces for a string in the tree. This function is used for substring search
   after tree construction is done. It simply traverses down the tree starting
   from the root until either the searched string is fully found ot one
   non-matching character is found. In this function skipping is not enabled
   because we don't know wether the string is in the tree or not (see function
   trace_string above).

   Input : The tree, the string W, and the length of W.

   Output: If the substring is found - returns the index of the starting
		   position of the substring in the tree source string. If the substring
		   is not found - returns ST_ERROR.
*/

DBL_WORD ST_FindSubstring(SUFFIX_TREE*	  tree,   /* The suffix array */
						  char*	W,	  /* The substring to find */
						  DBL_WORD		  P);	 /* The length of W */

/******************************************************************************/
/*
   ST_PrintTree :
   This function prints the tree. It simply starts the recoursive function
   ST_PrintNode from the root

   Input : The tree to be printed.
  
   Output: A print out of the tree to the screen.
*/

void ST_PrintTree(SUFFIX_TREE* tree);

/******************************************************************************/
/*
   ST_DeleteTree
   Deletes a whole suffix tree by starting a recoursive call to ST_DeleteSubTree
   from the root. After all of the nodes have been deleted, the function deletes
   the structure that represents the tree.

   Input : The tree to be deleted.

   Output: None.
*/

void ST_DeleteTree(SUFFIX_TREE* tree);

/******************************************************************************/
/*
   ST_SelfTest
   Self test of the tree - search for all substrings of the main string. See
   testing paragraph in the readme.txt file.

   Input : The tree to test.

   Output: 1 for success and 0 for failure. Prints a result message to the
		   screen.
*/

DBL_WORD ST_SelfTest(SUFFIX_TREE* tree);

/******************************************************************************
Suffix Tree Version 2.1

AUTHORS

Dotan Tsadok
Instructor: Mr. Shlomo Yona, University of Haifa, Israel. December 2002.
Current maintainer: Shlomo Yona	<shlomo@cs.haifa.ac.il>

COPYRIGHT

Copyright 2002-2003 Shlomo Yona

LICENSE

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


DESCRIPTION OF THIS FILE:

This is the implementation file suffix_tree.c implementing the header file
suffix_tree.h.

This code is an Open Source implementation of Ukkonen's algorithm for
constructing a suffix tree over a string in time and space complexity
O(length of the string). The code is written under strict ANSI C.

For a complete understanding of the code see Ukkonen's algorithm and the
readme.txt file.

The general pseudo code is:

n = length of the string.
ST_CreateTree:
   Calls n times to SPA (Single Phase Algorithm). SPA:  
	  Increase the variable e (virtual end of all leaves).
   Calls SEA (Single Extension Algorithm) starting with the first extension that
   does not already exist in the tree and ending at the first extension that
   already exists. SEA :  
	  Follow suffix link.
	  Check if current suffix exists in the tree.
	  If it does not - apply rule 2 and then create a new suffix link.
	  apply_rule_2:  
		 Create a new leaf and maybe a new internal node as well.
		 create_node:  
			Create a new node or a leaf.


For implementation interpretations see Basic Ideas paragraph in the Developement
section of the readme.txt file.

An example of the implementations of a node and its sons using linked lists
instead of arrays:

   (1)
	|
	|
	|
   (2)--(3)--(4)--(5)

(2) is the only son of (1) (call it the first son). Other sons of (1) are
connected using a linked lists starting from (2) and going to the right. (3) is
the right sibling of (2) (and (2) is the left sibling of (3)), (4) is the right
sibling of (3), etc.
The father field of all (2), (3), (4) and (5) points to (1), but the son field
of (1) points only to (2).

*******************************************************************************/

//#include "stdlib.h"
//#include "stdio.h"
//#include "string.h"
//#include "suffix_tree.h"

/* See function body */
void ST_PrintTree(SUFFIX_TREE* tree);
/* See function body */
void ST_PrintFullNode(SUFFIX_TREE* tree, NODE* node);

/* Used in function trace_string for skipping (Ukkonen's Skip Trick). */
typedef enum SKIP_TYPE	 {skip, no_skip}				 SKIP_TYPE;
/* Used in function apply_rule_2 - two types of rule 2 - see function for more
   details.*/
typedef enum RULE_2_TYPE   {new_son, split}				RULE_2_TYPE;
/* Signals whether last matching position is the last one of the current edge */
typedef enum LAST_POS_TYPE {last_char_in_edge, other_char} LAST_POS_TYPE;

/* Used for statistic measures of speed. */
DBL_WORD counter;
/* Used for statistic measures of space. */
DBL_WORD heap;
/* Used to mark the node that has no suffix link yet. By Ukkonen, it will have
   one by the end of the current phase. */
NODE*	suffixless;

typedef struct SUFFIXTREEPATH
{
   DBL_WORD   begin;
   DBL_WORD   end;
} PATH;

typedef struct SUFFIXTREEPOS
{
   NODE*	  node;
   DBL_WORD   edge_pos;
}POS;

/******************************************************************************/
/*
   Define STATISTICS in order to view measures of speed and space while
   constructing and searching the suffix tree. Measures will be printed on the
   screen.
*/
/* #define STATISTICS */

/*
   Define DEBUG in order to view debug printouts to the screen while
   constructing and searching the suffix tree.
*/
/* #define DEBUG */

/******************************************************************************/
/*
   create_node :
   Creates a node with the given init field-values.

  Input : The father of the node, the starting and ending indices 
  of the incloming edge to that node, 
		the path starting position of the node.

  Output: A pointer to that node.
*/


NODE* create_node(NODE* father, DBL_WORD start, DBL_WORD end, DBL_WORD position)
{
   /*Allocate a node.*/
   NODE* node   = (NODE*)malloc(sizeof(NODE));
   if(node == 0)
   {
	  printf("\nOut of memory.\n");
	  exit(0);
   }

#ifdef STATISTICS
   heap+=sizeof(NODE);
#endif

   /* Initialize node fields. For detailed description of the fields see
	  suffix_tree.h */
   node->sons			 = 0;
   node->right_sibling	= 0;
   node->left_sibling	 = 0;
   node->suffix_link	  = 0;
   node->father		   = father;
   node->path_position	= position;
   node->edge_label_start = start;
   node->edge_label_end   = end;
   return node;
}

/******************************************************************************/
/*
   find_son :
   Finds son of node that starts with a certain character. 

   Input : the tree, the node to start searching from and the character to be
		   searched in the sons.
  
   Output: A pointer to the found son, 0 if no such son.
*/

NODE* find_son(SUFFIX_TREE* tree, NODE* node, char character)
{
   /* Point to the first son. */
   node = node->sons;
   /* scan all sons (all right siblings of the first son) for their first
   character (it has to match the character given as input to this function. */
   while(node != 0 && tree->tree_string[node->edge_label_start] != character)
   {
#ifdef STATISTICS
	  counter++;
#endif
	  node = node->right_sibling;
   }
   return node;
}

/******************************************************************************/
/*
   get_node_label_end :
   Returns the end index of the incoming edge to that node. This function is
   needed because for leaves the end index is not relevant, instead we must look
   at the variable "e" (the global virtual end of all leaves). Never refer
   directly to a leaf's end-index.

   Input : the tree, the node its end index we need.

   Output: The end index of that node (meaning the end index of the node's
   incoming edge).
*/

DBL_WORD get_node_label_end(SUFFIX_TREE* tree, NODE* node)
{
   /* If it's a leaf - return e */
   if(node->sons == 0)
	  return tree->e;
   /* If it's not a leaf - return its real end */
   return node->edge_label_end;
}

/******************************************************************************/
/*
   get_node_label_length :
   Returns the length of the incoming edge to that node. Uses get_node_label_end
   (see above).

   Input : The tree and the node its length we need.

   Output: the length of that node.
*/

DBL_WORD get_node_label_length(SUFFIX_TREE* tree, NODE* node)
{
   /* Calculate and return the lentgh of the node */
   return get_node_label_end(tree, node) - node->edge_label_start + 1;
}

/******************************************************************************/
/*
   is_last_char_in_edge :
   Returns 1 if edge_pos is the last position in node's incoming edge.

   Input : The tree, the node to be checked and the position in its incoming
		   edge.

   Output: the length of that node.
*/

char is_last_char_in_edge(SUFFIX_TREE* tree, NODE* node, DBL_WORD edge_pos)
{
   if(edge_pos == get_node_label_length(tree,node)-1)
	  return 1;
   return 0;
}

/******************************************************************************/
/*
   connect_siblings :
   Connect right_sib as the right sibling of left_sib and vice versa.

   Input : The two nodes to be connected.

   Output: None.
*/

void connect_siblings(NODE* left_sib, NODE* right_sib)
{
   /* Connect the right node as the right sibling of the left node */
   if(left_sib != 0)
	  left_sib->right_sibling = right_sib;
   /* Connect the left node as the left sibling of the right node */
   if(right_sib != 0)
	  right_sib->left_sibling = left_sib;
}

/******************************************************************************/
/*
   apply_extension_rule_2 :
   Apply "extension rule 2" in 2 cases:
   1. A new son (leaf 4) is added to a node that already has sons:
				(1)		   (1)
			   /   \	 ->   / | \
			  (2)  (3)	  (2)(3)(4)

   2. An edge is split and a new leaf (2) and an internal node (3) are added:
			  | 	  |
			  | 	 (3)
			  |	 ->   / \
			 (1)	   (1) (2)

   Input : See parameters.

   Output: A pointer to the newly created leaf (new_son case) or internal node
   (split case).
*/

NODE* apply_extension_rule_2(
					  /* Node 1 (see drawings) */
					  NODE*		   node,			
					  /* Start index of node 2's incoming edge */
					  DBL_WORD		edge_label_begin,   
					  /* End index of node 2's incoming edge */
					  DBL_WORD		edge_label_end,	  
					  /* Path start index of node 2 */
					  DBL_WORD		path_pos,		 
					  /* Position in node 1's incoming edge where split is to be
				 performed */
					  DBL_WORD		edge_pos,		 
					  /* Can be 'new_son' or 'split' */
					  RULE_2_TYPE	 type)			
{
   NODE *new_leaf,
		*new_internal,
		*son;
   /*-------new_son-------*/
   if(type == new_son)									   
   {
#ifdef DEBUG   
	  printf("rule 2: new leaf (%lu,%lu)\n",edge_label_begin,edge_label_end);
#endif
	  /* Create a new leaf (4) with the characters of the extension */
	  new_leaf = create_node(node, edge_label_begin , edge_label_end, path_pos);
	  /* Connect new_leaf (4) as the new son of node (1) */
	  son = node->sons;
	  while(son->right_sibling != 0)
		 son = son->right_sibling;
	  connect_siblings(son, new_leaf);
	  /* return (4) */
	  return new_leaf;
   }
   /*-------split-------*/
#ifdef DEBUG   
   printf("rule 2: split (%lu,%lu)\n",edge_label_begin,edge_label_end);
#endif
   /* Create a new internal node (3) at the split point */
   new_internal = create_node(
					  node->father,
					  node->edge_label_start,
					  node->edge_label_start+edge_pos,
					  node->path_position);
   /* Update the node (1) incoming edge starting index (it now starts where node
   (3) incoming edge ends) */
   node->edge_label_start += edge_pos+1;

   /* Create a new leaf (2) with the characters of the extension */
   new_leaf = create_node(
					  new_internal,
					  edge_label_begin,
					  edge_label_end,
					  path_pos);
   
   /* Connect new_internal (3) where node (1) was */
   /* Connect (3) with (1)'s left sibling */
   connect_siblings(node->left_sibling, new_internal);   
   /* connect (3) with (1)'s right sibling */
   connect_siblings(new_internal, node->right_sibling);
   node->left_sibling = 0;

   /* Connect (3) with (1)'s father */
   if(new_internal->father->sons == node)			
	  new_internal->father->sons = new_internal;
   
   /* Connect new_leaf (2) and node (1) as sons of new_internal (3) */
   new_internal->sons = node;
   node->father = new_internal;
   connect_siblings(node, new_leaf);
   /* return (3) */
   return new_internal;
}

/******************************************************************************/
/*
   trace_single_edge :
   Traces for a string in a given node's OUTcoming edge. It searches only in the
   given edge and not other ones. Search stops when either whole string was
   found in the given edge, a part of the string was found but the edge ended
   (and the next edge must be searched too - performed by function trace_string)
   or one non-matching character was found.

   Input : The string to be searched, given in indices of the main string.

   Output: (by value) the node where tracing has stopped.
		   (by reference) the edge position where last match occured, the string
	   position where last match occured, number of characters found, a flag
	   for signaling whether search is done, and a flag to signal whether
	   search stopped at a last character of an edge.
*/

NODE* trace_single_edge(
					  SUFFIX_TREE*	tree, 
					  /* Node to start from */
					  NODE*		   node,		 
					  /* String to trace */
					  PATH			str,		 
					  /* Last matching position in edge */
					  DBL_WORD*	   edge_pos,	  
					  /* Last matching position in tree source string */
					  DBL_WORD*	   chars_found,   
					  /* Skip or no_skip*/
					  SKIP_TYPE	   type,		  
					  /* 1 if search is done, 0 if not */
					  int*			search_done)   
{
   NODE*	  cont_node;
   DBL_WORD   length,str_len;

   /* Set default return values */
   *search_done = 1;
   *edge_pos	= 0;

   /* Search for the first character of the string in the outcoming edge of
	  node */
   cont_node = find_son(tree, node, tree->tree_string[str.begin]);
   if(cont_node == 0)
   {
	  /* Search is done, string not found */
	  *edge_pos = get_node_label_length(tree,node)-1;
	  *chars_found = 0;
	  return node;
   }
   
   /* Found first character - prepare for continuing the search */
   node	= cont_node;
   length  = get_node_label_length(tree,node);
   str_len = str.end - str.begin + 1;

   /* Compare edge length and string length. */
   /* If edge is shorter then the string being searched and skipping is
	  enabled - skip edge */
   if(type == skip)
   {
	  if(length <= str_len)
	  {
		 (*chars_found)   = length;
		 (*edge_pos)	  = length-1;
		 if(length < str_len)
			*search_done  = 0;
	  }
	  else
	  {
		 (*chars_found)   = str_len;
		 (*edge_pos)	  = str_len-1;
	  }

#ifdef STATISTICS
	  counter++;
#endif

	  return node;
   }
   else
   {
	  /* Find minimum out of edge length and string length, and scan it */
	  if(str_len < length)
		 length = str_len;

	  for(*edge_pos=1, *chars_found=1; *edge_pos<length; (*chars_found)++,(*edge_pos)++)
	  {

#ifdef STATISTICS
		 counter++;
#endif

		 /* Compare current characters of the string and the edge. If equal - 
		continue */
		 if(tree->tree_string[node->edge_label_start+*edge_pos] != tree->tree_string[str.begin+*edge_pos])
		 {
			(*edge_pos)--;
			return node;
		 }
	  }
   }

   /* The loop has advanced *edge_pos one too much */
   (*edge_pos)--;

   if((*chars_found) < str_len)
	  /* Search is not done yet */
	  *search_done = 0;

   return node;
}

/******************************************************************************/
/*
   trace_string :
   Traces for a string in the tree. This function is used in construction
   process only, and not for after-construction search of substrings. It is
   tailored to enable skipping (when we know a suffix is in the tree (when
   following a suffix link) we can avoid comparing all symbols of the edge by
   skipping its length immediately and thus save atomic operations - see
   Ukkonen's algorithm, skip trick).
   This function, in contradiction to the function trace_single_edge, 'sees' the
   whole picture, meaning it searches a string in the whole tree and not just in
   a specific edge.

   Input : The string, given in indice of the main string.

   Output: (by value) the node where tracing has stopped.
		   (by reference) the edge position where last match occured, the string
	   position where last match occured, number of characters found, a flag
	   for signaling whether search is done.
*/

NODE* trace_string(
					  SUFFIX_TREE*	tree, 
					  /* Node to start from */
					  NODE*		   node,		 
					  /* String to trace */
					  PATH			str,		 
					  /* Last matching position in edge */
					  DBL_WORD*	   edge_pos,	  
					  /* Last matching position in tree string */
					  DBL_WORD*	   chars_found,
					  /* skip or not */
					  SKIP_TYPE	   type)		 
{
   /* This variable will be 1 when search is done.
	  It is a return value from function trace_single_edge */
   int	  search_done = 0;

   /* This variable will hold the number of matching characters found in the
	  current edge. It is a return value from function trace_single_edge */
   DBL_WORD edge_chars_found;

   *chars_found = 0;

   while(search_done == 0)
   {
	  *edge_pos		= 0;
	  edge_chars_found = 0;
	  node = trace_single_edge(tree, node, str, edge_pos, &edge_chars_found, type, &search_done);
	  str.begin	   += edge_chars_found;
	  *chars_found	+= edge_chars_found;
   }
   return node;
}

/******************************************************************************/
/*
   ST_FindSubstring :
   See suffix_tree.h for description.
*/

DBL_WORD ST_FindSubstring(
					  /* The suffix array */
					  SUFFIX_TREE*	tree,	  
					  /* The substring to find */
					  char*  W,		 
					  /* The length of W */
					  DBL_WORD		P)		 
{
   /* Starts with the root's son that has the first character of W as its
	  incoming edge first character */
   NODE* node   = find_son(tree, tree->root, W[0]);
   DBL_WORD k,j = 0, node_label_end;

   /* Scan nodes down from the root untill a leaf is reached or the substring is
	  found */
   while(node!=0)
   {
	  k=node->edge_label_start;
	  node_label_end = get_node_label_end(tree,node);
	  
	  /* Scan a single edge - compare each character with the searched string */
	  while(j<P && k<=node_label_end && tree->tree_string[k] == W[j])
	  {
		 j++;
		 k++;

#ifdef STATISTICS
		 counter++;
#endif
	  }
	  
	  /* Checking which of the stopping conditions are true */
	  if(j == P)
	  {
		 /* W was found - it is a substring. Return its path starting index */
		 return node->path_position;
	  }
	  else if(k > node_label_end)
		 /* Current edge is found to match, continue to next edge */
		 node = find_son(tree, node, W[j]);
	  else
	  {
		 /* One non-matching symbols is found - W is not a substring */
		 return ST_ERROR;
	  }
   }
   return ST_ERROR;
}

/******************************************************************************/
/*
   follow_suffix_link :
   Follows the suffix link of the source node according to Ukkonen's rules. 

   Input : The tree, and pos. pos is a combination of the source node and the 
		   position in its incoming edge where suffix ends.
   Output: The destination node that represents the longest suffix of node's 
		   path. Example: if node represents the path "abcde" then it returns 
		   the node that represents "bcde".
*/

void follow_suffix_link(SUFFIX_TREE* tree, POS* pos)
{
   /* gama is the string between node and its father, in case node doesn't have
	  a suffix link */
   PATH	  gama;			
   /* dummy argument for trace_string function */
   DBL_WORD  chars_found = 0;   
   
   if(pos->node == tree->root)
   {
	  return;
   }

   /* If node has no suffix link yet or in the middle of an edge - remember the
	  edge between the node and its father (gama) and follow its father's suffix
	  link (it must have one by Ukkonen's lemma). After following, trace down 
	  gama - it must exist in the tree (and thus can use the skip trick - see 
	  trace_string function description) */
   if(pos->node->suffix_link == 0 || is_last_char_in_edge(tree,pos->node,pos->edge_pos) == 0)
   {
	  /* If the node's father is the root, than no use following it's link (it 
		 is linked to itself). Tracing from the root (like in the naive 
		 algorithm) is required and is done by the calling function SEA uppon 
		 recieving a return value of tree->root from this function */
	  if(pos->node->father == tree->root)
	  {
		 pos->node = tree->root;
		 return;
	  }
	  
	  /* Store gama - the indices of node's incoming edge */
	  gama.begin	  = pos->node->edge_label_start;
	  gama.end	  = pos->node->edge_label_start + pos->edge_pos;
	  /* Follow father's suffix link */
	  pos->node	  = pos->node->father->suffix_link;
	  /* Down-walk gama back to suffix_link's son */
	  pos->node	  = trace_string(tree, pos->node, gama, &(pos->edge_pos), &chars_found, skip);
   }
   else
   {
	  /* If a suffix link exists - just follow it */
	  pos->node	  = pos->node->suffix_link;
	  pos->edge_pos   = get_node_label_length(tree,pos->node)-1;
   }
}

/******************************************************************************/
/*
   create_suffix_link :
   Creates a suffix link between node and the node 'link' which represents its 
   largest suffix. The function could be avoided but is needed to monitor the 
   creation of suffix links when debuging or changing the tree.

   Input : The node to link from, the node to link to.

   Output: None.
*/

void create_suffix_link(NODE* node, NODE* link)
{
   node->suffix_link = link;
}

/******************************************************************************/
/*
   SEA :
   Single-Extension-Algorithm (see Ukkonen's algorithm). Ensure that a certain 
   extension is in the tree.

   1. Follows the current node's suffix link.
   2. Check whether the rest of the extension is in the tree.
   3. If it is - reports the calling function SPA of rule 3 (= current phase is 
	  done).
   4. If it's not - inserts it by applying rule 2.

   Input : The tree, pos - the node and position in its incoming edge where 
		   extension begins, str - the starting and ending indices of the 
		   extension, a flag indicating whether the last phase ended by rule 3 
		   (last extension of the last phase already existed in the tree - and 
		   if so, the current phase starts at not following the suffix link of 
		   the first extension).

   Output: The rule that was applied to that extension. Can be 3 (phase is done)
		   or 2 (a new leaf was created).
*/

void SEA(
					  SUFFIX_TREE*   tree, 
					  POS*		   pos,
					  PATH		   str, 
					  DBL_WORD*	  rule_applied,
					  char		   after_rule_3)
{
   DBL_WORD   chars_found = 0 , path_pos = str.begin;
   NODE*	  tmp;
 
#ifdef DEBUG   
   ST_PrintTree(tree);
   printf("extension: %lu  phase+1: %lu",str.begin, str.end);
   if(after_rule_3 == 0)
	  printf("   followed from (%lu,%lu | %lu) ", pos->node->edge_label_start, get_node_label_end(tree,pos->node), pos->edge_pos);
   else
	  printf("   starting at (%lu,%lu | %lu) ", pos->node->edge_label_start, get_node_label_end(tree,pos->node), pos->edge_pos);
#endif

#ifdef STATISTICS
   counter++;
#endif

   /* Follow suffix link only if it's not the first extension after rule 3 was applied */
   if(after_rule_3 == 0)
	  follow_suffix_link(tree, pos);

#ifdef DEBUG   
#ifdef STATISTICS
   if(after_rule_3 == 0)
	  printf("to (%lu,%lu | %lu). counter: %lu\n", pos->node->edge_label_start, get_node_label_end(tree,pos->node),pos->edge_pos,counter);
   else
	  printf(". counter: %lu\n", counter);
#endif
#endif

   /* If node is root - trace whole string starting from the root, else - trace last character only */
   if(pos->node == tree->root)
   {
	  pos->node = trace_string(tree, tree->root, str, &(pos->edge_pos), &chars_found, no_skip);
   }
   else
   {
	  str.begin = str.end;
	  chars_found = 0;

	  /* Consider 2 cases:
		 1. last character matched is the last of its edge */
	  if(is_last_char_in_edge(tree,pos->node,pos->edge_pos))
	  {
		 /* Trace only last symbol of str, search in the  NEXT edge (node) */
		 tmp = find_son(tree, pos->node, tree->tree_string[str.end]);
		 if(tmp != 0)
		 {
			pos->node	  = tmp;
			pos->edge_pos   = 0;
			chars_found	  = 1;
		 }
	  }
	  /* 2. last character matched is NOT the last of its edge */
	  else
	  {
		 /* Trace only last symbol of str, search in the CURRENT edge (node) */
		 if(tree->tree_string[pos->node->edge_label_start+pos->edge_pos+1] == tree->tree_string[str.end])
		 {
			pos->edge_pos++;
			chars_found   = 1;
		 }
	  }
   }

   /* If whole string was found - rule 3 applies */
   if(chars_found == str.end - str.begin + 1)
   {
	  *rule_applied = 3;
	  /* If there is an internal node that has no suffix link yet (only one may 
		 exist) - create a suffix link from it to the father-node of the 
		 current position in the tree (pos) */
	  if(suffixless != 0)
	  {
		 create_suffix_link(suffixless, pos->node->father);
		 /* Marks that no internal node with no suffix link exists */
		 suffixless = 0;
	  }

	  #ifdef DEBUG   
		 printf("rule 3 (%lu,%lu)\n",str.begin,str.end);
	  #endif
	  return;
   }
   
   /* If last char found is the last char of an edge - add a character at the 
	  next edge */
   if(is_last_char_in_edge(tree,pos->node,pos->edge_pos) || pos->node == tree->root)
   {
	  /* Decide whether to apply rule 2 (new_son) or rule 1 */
	  if(pos->node->sons != 0)
	  {
		 /* Apply extension rule 2 new son - a new leaf is created and returned 
			by apply_extension_rule_2 */
		 apply_extension_rule_2(pos->node, str.begin+chars_found, str.end, path_pos, 0, new_son);
		 *rule_applied = 2;
		 /* If there is an internal node that has no suffix link yet (only one 
			may exist) - create a suffix link from it to the father-node of the 
			current position in the tree (pos) */
		 if(suffixless != 0)
		 {
			create_suffix_link(suffixless, pos->node);
			/* Marks that no internal node with no suffix link exists */
			suffixless = 0;
		 }
	  }
   }
   else
   {
	  /* Apply extension rule 2 split - a new node is created and returned by 
		 apply_extension_rule_2 */
	  tmp = apply_extension_rule_2(pos->node, str.begin+chars_found, str.end, path_pos, pos->edge_pos, split);
	  if(suffixless != 0)
		 create_suffix_link(suffixless, tmp);
	  /* Link root's sons with a single character to the root */
	  if(get_node_label_length(tree,tmp) == 1 && tmp->father == tree->root)
	  {
		 tmp->suffix_link = tree->root;
		 /* Marks that no internal node with no suffix link exists */
		 suffixless = 0;
	  }
	  else
		 /* Mark tmp as waiting for a link */
		 suffixless = tmp;
	  
	  /* Prepare pos for the next extension */
	  pos->node = tmp;
	  *rule_applied = 2;
   }
}

/******************************************************************************/
/*
   SPA :
   Performs all insertion of a single phase by calling function SEA starting 
   from the first extension that does not already exist in the tree and ending 
   at the first extension that already exists in the tree. 

   Input :The tree, pos - the node and position in its incoming edge where 
		  extension begins, the phase number, the first extension number of that
		  phase, a flag signaling whether the extension is the first of this 
		  phase, after the last phase ended with rule 3. If so - extension will 
		  be executed again in this phase, and thus its suffix link would not be
		  followed.

   Output:The extension number that was last executed on this phase. Next phase 
		  will start from it and not from 1
*/

void SPA(
					  /* The tree */
					  SUFFIX_TREE*	tree,			
					  /* Current node */
					  POS*			pos,			
					  /* Current phase number */
					  DBL_WORD		phase,			
					  /* The last extension performed in the previous phase */
					  DBL_WORD*	   extension,		 
					  /* 1 if the last rule applied is 3 */
					  char*		   repeated_extension)   
{
   /* No such rule (0). Used for entering the loop */
   DBL_WORD   rule_applied = 0;   
   PATH	   str;
   
   /* Leafs Trick: Apply implicit extensions 1 through prev_phase */
   tree->e = phase+1;

   /* Apply explicit extensions untill last extension of this phase is reached 
	  or extension rule 3 is applied once */
   while(*extension <= phase+1)			
   {
	  str.begin	   = *extension;
	  str.end		 = phase+1;
	  
	  /* Call Single-Extension-Algorithm */
	  SEA(tree, pos, str, &rule_applied, *repeated_extension);
	  
	  /* Check if rule 3 was applied for the current extension */
	  if(rule_applied == 3)
	  {
		 /* Signaling that the next phase's first extension will not follow a 
			suffix link because same extension is repeated */
		 *repeated_extension = 1;
		 break;
	  }
	  *repeated_extension = 0;
	  (*extension)++;
   }
   return;
}

/******************************************************************************/
/*
   ST_CreateTree :
   Allocates memory for the tree and starts Ukkonen's construction algorithm by 
   calling SPA n times, where n is the length of the source string.

   Input : The source string and its length. The string is a sequence of 
		   unsigned characters (maximum of 256 different symbols) and not 
		   null-terminated. The only symbol that must not appear in the string 
		   is $ (the dollar sign). It is used as a unique symbol by the 
		   algorithm ans is appended automatically at the end of the string (by 
		   the program, not by the user!). The meaning of the $ sign is 
		   connected to the implicit/explicit suffix tree transformation, 
		   detailed in Ukkonen's algorithm.

   Output: A pointer to the newly created tree. Keep this pointer in order to 
		   perform operations like search and delete on that tree. Obviously, no
	   de-allocating of the tree space could be done if this pointer is 
	   lost, as the tree is allocated dynamically on the heap.
*/

SUFFIX_TREE* ST_CreateTree(const char* str, DBL_WORD length)
{
   SUFFIX_TREE*  tree;
   DBL_WORD	  phase , extension;
   char		  repeated_extension = 0;
   POS		   pos;

   if(str == 0)
	  return 0;

   /* Allocating the tree */
   tree = (SUFFIX_TREE*)malloc(sizeof(SUFFIX_TREE));
   if(tree == 0)
   {
	  printf("\nOut of memory.\n");
	  exit(0);
   }
   heap+=sizeof(SUFFIX_TREE);

   /* Calculating string length (with an ending $ sign) */
   tree->length		 = length+1;
   ST_ERROR			= length+10;
   
   /* Allocating the only real string of the tree */
   tree->tree_string = (char*)malloc((tree->length+1)*sizeof(char));
   if(tree->tree_string == 0)
   {
	  printf("\nOut of memory.\n");
	  exit(0);
   }
   heap+=(tree->length+1)*sizeof(char);

   memcpy(tree->tree_string+sizeof(char),str,length*sizeof(char));
   /* $ is considered a uniqe symbol */
   tree->tree_string[tree->length] = '$';
   
   /* Allocating the tree root node */
   tree->root			= create_node(0, 0, 0, 0);
   tree->root->suffix_link = 0;

   /* Initializing algorithm parameters */
   extension = 2;
   phase = 2;
   
   /* Allocating first node, son of the root (phase 0), the longest path node */
   tree->root->sons = create_node(tree->root, 1, tree->length, 1);
   suffixless	   = 0;
   pos.node		 = tree->root;
   pos.edge_pos	 = 0;

   /* Ukkonen's algorithm begins here */
   for(; phase < tree->length; phase++)
   {
	  /* Perform Single Phase Algorithm */
	  SPA(tree, &pos, phase, &extension, &repeated_extension);
   }
   return tree;
}

/******************************************************************************/
/*
   ST_DeleteSubTree :
   Deletes a subtree that is under node. It recoursively calls itself for all of
   node's right sons and then deletes node.

  Input : The node that is the root of the subtree to be deleted.

  Output: None.
*/

void ST_DeleteSubTree(NODE* node)
{
   /* Recoursion stoping condition */
   if(node == 0)
	  return;
   /* Recoursive call for right sibling */
   if(node->right_sibling!=0)
	  ST_DeleteSubTree(node->right_sibling);
   /* Recoursive call for first son */
   if(node->sons!=0)
	  ST_DeleteSubTree(node->sons);
   /* Delete node itself, after its whole tree was deleted as well */
   free(node);
}

/******************************************************************************/
/*
   ST_DeleteTree :
   Deletes a whole suffix tree by starting a recoursive call to ST_DeleteSubTree
   from the root. After all of the nodes have been deleted, the function deletes
   the structure that represents the tree.

   Input : The tree to be deleted.

   Output: None.
*/

void ST_DeleteTree(SUFFIX_TREE* tree)
{
   if(tree == 0)
	  return;
   ST_DeleteSubTree(tree->root);
   free(tree);
}

/******************************************************************************/
/*
   ST_PrintNode :
   Prints a subtree under a node of a certain tree-depth.

   Input : The tree, the node that is the root of the subtree, and the depth of 
		   that node. The depth is used for printing the branches that are 
		   coming from higher nodes and only then the node itself is printed. 
		   This gives the effect of a tree on screen. In each recoursive call, 
		   the depth is increased.
  
   Output: A printout of the subtree to the screen.
*/

void ST_PrintNode(SUFFIX_TREE* tree, NODE* node1, long depth)
{
   NODE* node2 = node1->sons;
   long  d = depth , start = node1->edge_label_start , end;
   end	 = get_node_label_end(tree, node1);

   if(depth>0)
   {
	  /* Print the branches coming from higher nodes */
	  while(d>1)
	  {
		 printf("|");
		 d--;
	  }
	  printf("+");
	  /* Print the node itself */
	  while(start<=end)
	  {
		 printf("%c",tree->tree_string[start]);
		 start++;
	  }
		 printf("  \t\t\t(%lu,%lu | %lu)",node1->edge_label_start,end,node1->path_position);
		 printf("(data=%s)", RenderPerNodeData(*node1->more_data).c_str());
	  printf("\n");
   } else {
		 printf("(data=%s)\n", RenderPerNodeData(*node1->more_data).c_str());
   }
   /* Recoursive call for all node1's sons */
   while(node2!=0)
   {
	  ST_PrintNode(tree,node2, depth+1);
	  node2 = node2->right_sibling;
   }
}

/******************************************************************************/
/*
   ST_PrintFullNode :
   This function prints the full path of a node, starting from the root. It 
   calls itself recoursively and than prints the last edge.

   Input : the tree and the node its path is to be printed.

   Output: Prints the path to the screen, no return value.
*/

void ST_PrintFullNode(SUFFIX_TREE* tree, NODE* node)
{
   long start, end;
   if(node==NULL)
	  return;
   /* Calculating the begining and ending of the last edge */
   start   = node->edge_label_start;
   end	 = get_node_label_end(tree, node);
   
   /* Stoping condition - the root */
   if(node->father!=tree->root)
	  ST_PrintFullNode(tree,node->father);
   /* Print the last edge */
   while(start<=end)
   {
	  printf("%c",tree->tree_string[start]);
	  start++;
   }
}


/******************************************************************************/
/*
   ST_PrintTree :
   This function prints the tree. It simply starts the recoursive function 
   ST_PrintNode with depth 0 (the root).

   Input : The tree to be printed.
  
   Output: A print out of the tree to the screen.
*/

void ST_PrintTree(SUFFIX_TREE* tree)
{
   printf("\nroot\n");
   ST_PrintNode(tree, tree->root, 0);
}

/******************************************************************************/
/*
   ST_SelfTest :
   Self test of the tree - search for all substrings of the main string. See 
   testing paragraph in the readme.txt file.

   Input : The tree to test.

   Output: 1 for success and 0 for failure. Prints a result message to the screen.
*/

DBL_WORD ST_SelfTest(SUFFIX_TREE* tree)
{
   DBL_WORD k,j,i;

#ifdef STATISTICS
   DBL_WORD old_counter = counter;
#endif

   /* Loop for all the prefixes of the tree source string */
   for(k = 1; k<tree->length; k++)
   {
	  /* Loop for each suffix of each prefix */
	  for(j = 1; j<=k; j++)
	  {
#ifdef STATISTICS
		 counter = 0;
#endif
		 /* Search the current suffix in the tree */
		 i = ST_FindSubstring(tree, (char*)(tree->tree_string+j), k-j+1);
		 if(i == ST_ERROR)
		 {
			printf("\n\nTest Results: Fail in string (%lu,%lu).\n\n",j,k);
			return 0;
		 }
	  }
   }
#ifdef STATISTICS
   counter = old_counter;
#endif
   /* If we are here no search has failed and the test passed successfuly */
   printf("\n\nTest Results: Success.\n\n");
   return 1;
}

// End borrowed code.

struct DataPoint {
	int curr_i, next_i, min_d, max_d;

	void UpdateWithDump(int depth, int new_next) const;
};
inline bool operator<(const DataPoint& a, const DataPoint& b) {
	return a.curr_i < b.curr_i;
}

vector<DataPoint> dumped_dps;

void DataPoint::UpdateWithDump(int depth, int new_next) const {
	if (depth < max_d) {
		dumped_dps.push_back({curr_i, next_i, depth, max_d});
	}
	auto* t = const_cast<DataPoint*>(this);
	t->next_i = new_next;
	t->max_d = depth;
}

struct PerNodeData {
	int depth;
	set<DataPoint> data_points;
};
string RenderPerNodeData(const PerNodeData& data) {
	ostringstream s;
	s << "{";
	s << "d=" << data.depth;
	s << "}";
	return s.str();;
}

deque<PerNodeData> data_pool;

void AssignPerNodeData(NODE* node) {
	data_pool.emplace_back();
	node->more_data = &data_pool.back();
	for (NODE* p = node->sons; p; p = p->right_sibling) {
		AssignPerNodeData(p);
	}
}

SUFFIX_TREE* tree;
string S;

pair<const char*, const char*> GetLeadingString(NODE* p) {
	const char* start = tree->tree_string + p->edge_label_start;
	const char* end = tree->tree_string + get_node_label_end(tree, p) + 1;
	return make_pair(start, end);
}

void MergeDataPoints(set<DataPoint>& base, vector<set<DataPoint>>& to_merge,
					 int depth) {
	typedef pair<DataPoint, set<DataPoint>*> QElem;
	struct DPGreater {
		bool operator()(const QElem& a, const QElem& b) {
			return b.first < a.first;
		}
	};
	static priority_queue<QElem, vector<QElem>, DPGreater> Q;
	for (auto& dps : to_merge) {
		if (dps.empty()) { continue; }
		Q.emplace(*dps.begin(), &dps);
		dps.erase(dps.begin());
	}
	auto base_iter = base.begin();
	while (!Q.empty()) {
		set<DataPoint>::iterator iter = base.emplace_hint(base_iter, Q.top().first);
		{
			auto* dps = Q.top().second;
			Q.pop();
			if (!dps->empty()) {
				Q.emplace(*dps->begin(), dps);
				dps->erase(dps->begin());
			}
		}
		if (iter != base.begin()) {
			auto p = prev(iter);
			p->UpdateWithDump(depth, iter->curr_i);
		}
		if (next(iter) != base.end()) {
			iter->UpdateWithDump(depth, next(iter)->curr_i);
		}
		base_iter = iter;
	}
}

void ComputePerNodeData(NODE* node) {
	for (NODE* p = node->sons; p; p = p->right_sibling) {
		{
			auto t = GetLeadingString(p);
			p->more_data->depth = node->more_data->depth + (t.second - t.first);
		}
		ComputePerNodeData(p);
	}
	if (node->sons == 0) {  // Leaf.
		DataPoint p;
		int depth = node->more_data->depth - 1; // exclude "$"
		p.curr_i = get_node_label_end(tree, node) - depth - 1;
		p.next_i = S.size() + 1;
		p.min_d = -1;
		p.max_d = depth;
		auto& dps = node->more_data->data_points;
		dps.clear();
		dps.insert(p);
	} else {
		static vector<set<DataPoint>> to_merge;
		to_merge.clear();
		for (NODE* p = node->sons; p; p = p->right_sibling) {
			to_merge.push_back(std::move(p->more_data->data_points));
		}
		auto max_iter = max_element(to_merge.begin(), to_merge.end(),
				[](const set<DataPoint>& a, const set<DataPoint>& b) {
					return a.size() < b.size();
				});
		check(max_iter != to_merge.end());
		set<DataPoint> base = std::move(*max_iter);
		to_merge.erase(max_iter);
		MergeDataPoints(base, to_merge, node->more_data->depth);
		node->more_data->data_points = std::move(base);
	}
}

struct Task {
	int L, R, id;
	ll ans;
};
vector<Task> tasks;

struct Poly {
	ll a1, a0;

	Poly(ll _a1, ll _a0) : a1(_a1), a0(_a0) {}

	ll operator()(ll X) const { return a1 * X + a0; }

	Poly& operator+=(const Poly& o) {
		a1 += o.a1;
		a0 += o.a0;
		return *this;
	}
};

struct RangeTree {
	void Init(int size) {
		for (N = 1; N < size; N *= 2);
		p.assign(N * 2 - 1, Poly(0, 0));
	}

	void Update(int pos, const Poly& v) {
		pos += N - 1;
		for (;;) {
			p[pos] += v;
			if (IsRoot(pos)) { break; }
			pos = Fa(pos);
		}
	}

	Poly Get(int pos) const {
		pos += N - 1;
		Poly ans = p[pos];
		while (!IsRoot(pos)) {
			int f = Fa(pos);
			if (pos == LCh(f)) { ans += p[RCh(f)]; }
			pos = f;
		}
		return ans;
	}

private:
	int N;
	vector<Poly> p;

	static bool IsRoot(int p) { return p == 0; }
	static int Fa(int p) { return (p - 1) / 2; }
	static int LCh(int p) { return p * 2 + 1; }
	static int RCh(int p) { return p * 2 + 2; }
};

void SolveBatch() {
	struct PtPoly {
		int a;
		Poly p;
		PtPoly* next = nullptr;

		PtPoly(int _a, const Poly& _p) : a(_a), p(_p) {}
	};
	vector<pair<int, PtPoly>> events;
	events.reserve(dumped_dps.size() * 4);
	int max_timestamp = 0;
	for (const auto& dp : dumped_dps) {
		int lo = dp.min_d, hi = dp.max_d, c = dp.curr_i, n = dp.next_i;
		events.emplace_back(lo + c, PtPoly(c, Poly(+1, -(lo + c))));
		events.emplace_back(lo + n, PtPoly(c, Poly(-1, +(lo + n))));
		events.emplace_back(hi + c, PtPoly(c, Poly(-1, +(hi + c))));
		events.emplace_back(hi + n, PtPoly(c, Poly(+1, -(hi + n))));
		max_timestamp = max(max_timestamp, hi + n);
	}
	vector<PtPoly*> heads(max_timestamp + 1, nullptr);
	for (auto& e : events) {
		e.second.next = heads[e.first];
		heads[e.first] = &e.second;
	}
	sort(tasks.begin(), tasks.end(), [](const Task& a, const Task& b) {
		return a.R < b.R;
	});
	auto t_iter = tasks.begin();
	RangeTree tree;
	tree.Init(S.size() + 1);
	for (int timestamp = 0; timestamp < heads.size(); ++timestamp) {
		for (PtPoly* pt = heads[timestamp]; pt != nullptr; pt = pt->next) {
			tree.Update(pt->a, pt->p);
		}
		for (; t_iter != tasks.end() && t_iter->R == timestamp; ++t_iter) {
			Poly p = tree.Get(t_iter->L);
			t_iter->ans = p(t_iter->R);
		}
	}
}

int main() {
	cin.sync_with_stdio(false);
	cout.sync_with_stdio(false);
	int N, Q;
	cin >> N >> Q >> S;
	tree = ST_CreateTree(S.c_str(), (int)S.size());
	AssignPerNodeData(tree->root);
	tree->root->more_data->depth = 0;
	ComputePerNodeData(tree->root);
	for (const DataPoint& dp : tree->root->more_data->data_points) {
		dp.UpdateWithDump(0, S.size() + 1);
	}
	tasks.resize(Q);
	for (int i = 0; i < Q; ++i) {
		Task& t = tasks[i];
		t.id = i;
		cin >> t.L >> t.R;
		++t.R;
		t.ans = 0;
	}
	SolveBatch();
	sort(tasks.begin(), tasks.end(), [](const Task& a, const Task& b) {
		return a.id < b.id;
	});
	for (Task& t : tasks) {
		cout << t.ans << '\n';
	}

	return 0;
}

----------
====================
----------
ALGORITHMS.140
medium
----------
PROBLEM STATEMENT:
Hackerland is a one-dimensional city with houses aligned at integral locations along a road. The Mayor wants to install radio transmitters on the roofs of the city's houses. Each transmitter has a fixed range meaning it can transmit a signal to all houses within that number of units distance away.

Given a map of Hackerland and the transmission range, determine the minimum number of transmitters so that every house is within range of at least one transmitter.  Each transmitter must be installed on top of an existing house.

For example, assume houses are located at [expression]. 

Function Description  

Complete the hackerlandRadioTransmitters function in the editor below.  It must return an integer that denotes the minimum number of transmitters to install.  

hackerlandRadioTransmitters has the following parameter(s):  


x: integer array that denotes the locations of houses  
k: an integer that denotes the effective range of a transmitter  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
typedef long long LL;
using namespace std;

int main(){
	int n, k;
	cin >> n >> k;
	int x[n];
	for(int i = 0; i < n; i++) scanf("%d", &x[i]);
	sort(x,x+n);
	int ans = 0;
	int cur = 0;
	while(cur < n){
		int st = x[cur];
		while(cur < n && x[cur+1] <= st+k){
			cur++;
		}
		int m = x[cur];
		while(cur < n && x[cur+1] <= m+k){
			cur++;
		}
		ans++;
		cur++;
	}
	cout << ans << endl;
}
----------
====================
----------
ALGORITHMS.141
medium
----------
PROBLEM STATEMENT:
The city of Gridland is represented as an [expression].

Gridland has a network of train tracks that always run in straight horizontal lines along a row. In other words, the start and end points of a train track are [expression] represents the ending column of the train track. 

The mayor of Gridland is surveying the city to determine the number of locations where lampposts can be placed. A lamppost can be placed in any cell that is not occupied by a train track.

Given a map of Gridland and its [expression] train tracks, find and print the number of cells where the mayor can place lampposts.

Note: A train track may overlap other train tracks within the same row. 

For example, if Gridland's data is the following:

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]	
[expression]



  

In this case, there are five open cells (red) where lampposts can be placed.

Function Description

Complete the gridlandMetro function in the editor below.  It should return an integer that denotes the number of cells where lampposts can be installed.  

gridlandMetro has the following parameter(s):  


n: an integer, the number of rows in Gridland
m: an integer, the number of columns in Gridland
k: an integer, the number of tracks
track: a 2 dimensional array of integers where each element contains [expression] 

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

#define FI(i,a,b) for(int i=(a);i<=(b);i++)
#define FD(i,a,b) for(int i=(a);i>=(b);i--)

#define LL long long
#define Ldouble long double
#define PI 3.1415926535897932384626

#define PII pair<int,int>
#define PLL pair<LL,LL>
#define mp make_pair
#define fi first
#define se second

using namespace std;

int n, m, k, p;
map<int, int> M;
vector<PII> vec[1005];

LL ans;

int main(){
	scanf("%d %d %d", &n, &m, &k);
	ans = 1LL * n * m;
	
	FI(i, 1, k){
		int a, b, c;
		scanf("%d %d %d", &a, &b, &c);
		if(M.count(a) == 0) M[a] = ++p;
		vec[M[a]].push_back(mp(b, c));
	}
	
	FI(i, 1, p){
		sort(vec[i].begin(), vec[i].end());
		int pv = 0;
		FI(j, 0, (int)vec[i].size() - 1){
			PII c = vec[i][j];
			if(c.fi > pv) ans += c.fi - 1 - pv;
			pv = max(pv, c.se);
		}
		ans -= pv;
	}
	printf("%lld\n", ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.142
easy
----------
PROBLEM STATEMENT:
Sunny and Johnny like to pool their money and go to the ice cream parlor.  Johnny never buys the same flavor that Sunny does.  The only other rule they have is that they spend all of their money.

Given a list of prices for the flavors of ice cream, select the two that will cost all of the money they have.  

For example, they have [expression].  

Function Description

Complete the icecreamParlor function in the editor below.  It should return an array containing the indices of the prices of the two flavors they buy, sorted ascending.  

icecreamParlor has the following parameter(s):  


m: an integer denoting the amount of money they have to spend  
cost: an integer array denoting the cost of each flavor of ice cream  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int answer(int i, int j) {
    cout << 1 + min(i, j) << " " << 1 + max(i, j) << endl;
}

int main() {
    int tc;
    cin >> tc;
    for (; tc > 0; tc--) {
        int W;
        cin >> W;
        int n;
        cin >> n;
        vector<pair<int, int> > a (n);
        for (int i = 0; i < n; i++) {
            cin >> a[i].first; a[i].second = i;
        }
        sort(a.begin(), a.end());
        for (int i = 0, j = n-1; i < n; i++) {
            while (j > 0 and a[i].first + a[j].first > W) j--;
            if (a[i].first + a[j].first == W and i < j) answer(a[i].second, a[j].second);
        }
    }
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
ALGORITHMS.143
medium
----------
PROBLEM STATEMENT:
[expression] satisfying either of the following:


[expression], or  
[expression]  


Note that [expression] chessboard:



Observe that for each possible movement, the Knight moves [expression] unit in the perpendicular direction.

Given the value of [expression]:


What is the minimum number of moves it takes for [expression]? If it's not possible for the Knight to reach that destination, the answer is -1 instead.


Then print the answer for each [expression] according to the Output Format specified below.
----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;


int main(){
    int n;
    cin >> n;
    // your code goes here
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < n; j++) {
            int dist[26][26];
            memset(dist, -1, sizeof(dist));
            int q[26 * 26], sz = 0;
            q[sz++] = 0;
            dist[0][0] = 0;
            for (int s = 0; s < sz; s++) {
                int r = q[s] / n, c = q[s] % n;
                for (int a = -1; a < 2; a += 2) {
                    for (int b = -1; b < 2; b += 2) {
                        int nr = r + a * i;
                        int nc = c + b * j;
                        if (nr < 0 || nr >= n || nc < 0 || nc >= n || dist[nr][nc] != -1) {
                            continue;
                        }
                        dist[nr][nc] = dist[r][c] + 1;
                        q[sz++] = nr * n + nc;
                    }
                }
                for (int a = -1; a < 2; a += 2) {
                    for (int b = -1; b < 2; b += 2) {
                        int nr = r + a * j;
                        int nc = c + b * i;
                        if (nr < 0 || nr >= n || nc < 0 || nc >= n || dist[nr][nc] != -1) {
                            continue;
                        }
                        dist[nr][nc] = dist[r][c] + 1;
                        q[sz++] = nr * n + nc;
                    }
                }
            }
            cout << dist[n - 1][n - 1] << " ";
        }
        cout << endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.144
medium
----------
PROBLEM STATEMENT:
Lauren has a chart of distinct projected prices for a house over the next several years.  She must buy the house in one year and sell it in another, and she must do so at a loss.  She wants to minimize her financial loss.  

For example, the house is valued at [expression].

Find and print the minimum amount of money Lauren must lose if she buys the house and resells it within the next [expression] years.

Note: It's guaranteed that a valid answer exists.

Function Description  

Complete the minimumLoss function in the editor below.  It should return an integer that represents the minimum loss that can be achieved.  

minimumLoss has the following parameter(s):  


price: an array of integers that represent prices at each year  

----------
TOP SOLUTION:
----------
// Simran Dokania
// International Institute of Information Technology Bangalore
#include <bits/stdc++.h>

using namespace std;

#define FASTER ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)
#define pb push_back
#define mp make_pair
#define pd(x) printf("%d", x)
#define pdn(x) printf("%d\n", x)
#define plld(x) printf("%I64d", x)
#define plldn(x) printf("%I64d\n", x)
#define fi first
#define se second
#define sd(x) scanf("%d",&x)
#define sd2(x,y) scanf("%d%d",&x,&y);
#define sd3(x,y,z) scanf("%d%d%d",&x,&y,&z); //spaces should not be there to avoid tle
#define slld(x) scanf("%I64d",&x)
#define LET(x, a)  __typeof(a) x(a)
#define foreach(it, v) for(LET(it, v.begin()); it != v.end(); it++)
#define tr(...) cout<<__FUNCTION__<<' '<<__LINE__<<" = ";trace(#__VA_ARGS__, __VA_ARGS__)

template<typename S, typename T> 
ostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.fi<<", "<<p.se<<')';return out;}

template<typename T>
ostream& operator<<(ostream& out,vector<T> const& v){
int l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}

template<typename T>
void trace(const char* name, T&& arg1){cout<<name<<" : "<<arg1<<endl;}

template<typename T, typename... Args>
void trace(const char* names, T&& arg1, Args&&... args){
const char* comma = strchr(names + 1, ',');cout.write(names, comma-names)<<" : "<<arg1<<" | ";trace(comma+1,args...);}

typedef pair<int, int> pii;
typedef long long ll;
typedef long double ld;

/*
ifstream fin("input.txt");
ofstream fout("output.txt");
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
*/

const int N = 200100;

int n;
ll p[N];

int main()
{
	FASTER;
	cin >> n;
	for(int i = 0; i < n; i++){
		cin >> p[i];
	}	
	
	set<ll> s;
	s.insert(p[0]);
	
	ll mx = -1e18;
	
	for(int i = 1; i < n; i++){
		auto it = s.upper_bound(p[i]);
		if(it == s.end()){
			s.insert(p[i]);
			continue;
		}
		
		mx = max(mx, p[i] - (*it));
		s.insert(p[i]);
	}
	
	cout << -mx;	
	
	return 0;
}
----------
====================
----------
ALGORITHMS.145
easy
----------
PROBLEM STATEMENT:
Numeros the Artist had two lists that were permutations of one another.  He was very proud. Unfortunately, while transporting them from one exhibition to another, some numbers were lost out of the first list. Can you find the missing numbers?

As an example, the array with some numbers missing, [expression].  

Notes  


If a number occurs multiple times in the lists, you must ensure that the frequency of that number in both lists is the same. If that is not the case, then it is also a missing number. 
You have to print all the missing numbers in ascending order. 
Print each missing number once, even if it is missing multiple times. 
The difference between maximum and minimum number in the second list is less than or equal to [expression].  


Function Description  

Complete the missingNumbers function in the editor below.  It should return a sorted array of missing numbers.  

missingNumbers has the following parameter(s):


arr: the array with missing numbers   
brr: the original array of numbers   

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <set>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    long long n,m,temp;
    cin>>n;
    vector<int> a;
    for(long long i=0;i<n;i++) {
        cin >> temp;
        a.push_back(temp);
    }
    cin>>m;
    vector<int> b;
    for(long long i=0;i<m;i++){
        cin >> temp;
        b.push_back(temp);
    }
    sort(a.begin(),a.end());
    sort(b.begin(),b.end());
    long long i=0,j=0;
    while(i<n && j<m){
        if(a[i]==b[j]) {
            i++;j++;
            b[j-1]=0;
        }
        else if(a[i]>b[j])j++;
        else i++;
    }
    set<int> st;
    for(i=0;i<m;i++) {
        if(b[i]!=0) st.insert(b[i]);
    }
    for(set<int>::iterator it = st.begin();it!=st.end();it++){
        cout<<*it<<" ";
    }
    cout<<endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.146
medium
----------
PROBLEM STATEMENT:
You will be given an array of integers and a target value.  Determine the number of pairs of array elements that have a difference equal to a target value.  

For example, given an array of [1, 2, 3, 4] and a target value of 1, we have three values meeting the condition: [expression].

Function Description

Complete the pairs function below.  It must return an integer representing the number of element pairs having the required difference.

pairs has the following parameter(s):


k: an integer, the target difference
arr: an array of integers

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <cstdlib>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
using namespace std;
/* Head ends here */

int pairs(vector <int> a,int k) {
    int ans = 0;
    set<long long> s;
    for(int i = 0; i < a.size(); i++) s.insert(a[i]);
    for(int i = 0; i < a.size(); i++){
        long long b = a[i] - k;
        if(s.count(b)) ans ++;
    }
    return ans;
}

/* Tail starts here */
int main() {
    int res;
    
    int _a_size,_k;
    cin >> _a_size>>_k;
    cin.ignore (std::numeric_limits<std::streamsize>::max(), '\n'); 
    vector<int> _a;
    int _a_item;
    for(int _a_i=0; _a_i<_a_size; _a_i++) {
        cin >> _a_item;
        _a.push_back(_a_item);
    }
    
    res = pairs(_a,_k);
    cout << res;
    
    return 0;
}
----------
====================
----------
ALGORITHMS.147
easy
----------
PROBLEM STATEMENT:
Watson gives Sherlock an array of integers.  His challenge is to find an element of the array such that the sum of all elements to the left is equal to the sum of all elements to the right.  For instance, given the array [expression].

You will be given arrays of integers and must determine whether there is an element that meets the criterion.

Function Description  

Complete the balancedSums function in the editor below.  It should return a string, either YES if there is an element meeting the criterion or NO otherwise.  

balancedSums has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(int *x, int *y){reader(x);reader(y);}
void reader(int *x, int *y, int *z){reader(x);reader(y);reader(z);}
int reader(char c[]){int i,s=0;for(;;){mygc(i);if(i!=' '&&i!='\n'&&i!='\r'&&i!='\t'&&i!=EOF) break;}c[s++]=i;for(;;){mygc(i);if(i==' '||i=='\n'||i=='\r'||i=='\t'||i==EOF) break;c[s++]=i;}return s;}

void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}

int T, N, A[200000], sum[200000];

int main(){
  int i, j, k;

  reader(&T);
  while(T--){
    reader(&N);
    rep(i,N) reader(A+i);

    sum[0] = 0;
    rep(i,N) sum[i+1] = sum[i] + A[i];

    k = 0;
    rep(i,N){
      if(sum[i] == sum[N]-sum[i+1]){ k = 1; break; }
    }
    if(k) writer("YES\n"); else writer("NO\n");
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.148
hard
----------
PROBLEM STATEMENT:
We define the following:


A subarray of array [expression].
The sum of an array is the sum of its elements.


Given an [expression].  The following table lists all subarrays and their moduli:

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



The maximum modulus is [expression].

Function Description

Complete the maximumSum function in the editor below.  It should return a long integer that represents the maximum value of [expression].

maximumSum has the following parameter(s):


a: an array of long integers, the array to analyze
m: a long integer, the modulo divisor

----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

int main() {
	int T;
	scanf("%d", &T);
	rep(ii, T) {
		int N; long long M;
		scanf("%d%lld", &N, &M);
		vector<long long> A(N);
		rep(i, N)
			scanf("%lld", &A[i]);
		long long sum = 0, ans = 0;
		set<long long> s;
		rep(i, N) {
			s.insert(sum);
			(sum += A[i]) %= M;
			//sum - sum_i
			amax(ans, (sum - *s.begin() + M) % M);
			amax(ans, (sum - *s.lower_bound(sum+1) + M) % M);
		}
		printf("%lld\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.149
medium
----------
PROBLEM STATEMENT:
Consider a matrix where each cell contains either a [expression] is called a filled cell. Two cells are said to be connected if they are adjacent to each other horizontally, vertically, or diagonally.  In the following grid, all cells marked X are connected to the cell marked Y.

XXX
XYX  
XXX    


If one or more filled cells are also connected, they form a region. Note that each cell in a region is connected to zero or more cells in the region but is not necessarily directly connected to all the other cells in the region.

Given an [expression] matrix, find and print the number of cells in the largest region in the matrix. Note that there may be more than one region in the matrix.

For example, there are two regions in the following [expression].  

110
100
001


Function Description  

Complete the connectedCell function in the editor below.  It should return an integer that denotes the area of the largest region.  

connectedCell has the following parameter(s): 
- matrix: a 2D array of integers where [expression] row of the matrix  
----------
TOP SOLUTION:
----------
#include <functional>
#include <algorithm>
#include <iostream>
#include <climits>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <numeric>
#include <cstring>
#include <cassert>
#include <cstdio>
#include <string>
#include <vector>
#include <bitset>
#include <queue>
#include <stack>
#include <cmath>
#include <ctime>
#include <list>
#include <set>
#include <map>

using namespace std;

typedef long long        LL;
typedef pair<int, int>   pii;
typedef pair<int, pii>   piii;
typedef vector<int>      vi;
typedef vector<pii>      vii;
typedef vector<piii>     viii;

#ifdef _WIN32
#define getchar_unlocked getchar
#endif
inline void inpint( int &n ) {
  n=0; register int ch = getchar_unlocked(); bool sign = 0;
  while(ch < 48 || ch > 57) { if(ch == '-') sign = 1; ch = getchar_unlocked(); }
  while(ch >= 48 && ch <= 57) { n = (n << 3) + (n << 1) + ch - 48, ch = getchar_unlocked(); }
  if(sign) n = -n;
}

inline int sqr(int x){return x * x;}
inline int cube(int x){return x * x * x;}
inline LL sqrLL(LL x){return x * x;}
inline LL cubeLL(LL x){return x * x * x;}

const LL LLINF      = 9223372036854775807LL;
const LL LLINF17    = 100000000000000000LL;
const int INF       = 2147483647;
const int INF9      = 1000000000;
const int MOD       = 1000000007;
const double eps    = 1e-7;
const double PI     = acos(-1.0);

#define FOR(a,b,c)   for (int (a)=(b); (a)<(c); (a)++)
#define FORN(a,b,c)  for (int (a)=(b); (a)<=(c); (a)++)
#define FORD(a,b,c)  for (int (a)=(b); (a)>=(c); (a)--)
#define REP(i,n)     FOR(i,0,n)
#define REPN(i,n)    FORN(i,1,n)
#define REPD(i,n)    FORD(i,n,1)

#define RESET(a,b)   memset(a,b,sizeof(a)) 
#define SYNC         ios_base::sync_with_stdio(0);
#define SIZE(a)      (int)(a.size())
#define MIN(a,b)     (a) = min((a),(b))
#define MAX(a,b)     (a) = max((a),(b))
#define ALL(a)       a.begin(),a.end()
#define RALL(a)      a.rbegin(),a.rend()
#define SIZE(a)      (int)(a.size())
#define LEN(a)       (int)(a.length())

#define fi           first
#define se           second
#define pb           push_back
#define mp           make_pair

int dr[] = {1,0,-1,0,-1,1,1,-1};
int dc[] = {0,-1,0,1,1,1,-1,-1};
int n, m;
int arr[15][15];
bool flag[15][15];
inline int bfs(int a, int b) {
  queue<pii> q;
  q.push(mp(a, b));
  flag[a][b] = 1;
  int cnt = 0;
  while (!q.empty()){
    pii p = q.front(); q.pop();
    cnt++;
    REP(i,8) {
      int px = p.fi + dr[i], py = p.se + dc[i];
      if (px >= 1 && px <= n && py >= 1 && py <= m && arr[px][py] && !flag[px][py]) {
        flag[px][py] = 1;
        q.push(mp(px,py));
      }
    }
  }
  return cnt;
}
int main(){
  cin >> n >> m;
  REPN(i,n) REPN(j,m) cin >> arr[i][j];

  int ans = 0;
  REPN(i,n) {
    REPN(j,m){
      if (arr[i][j] && !flag[i][j]) {
        MAX(ans, bfs(i, j));
      }
    }
  }
  cout << ans << endl;
  return 0;
}
----------
====================
----------
ALGORITHMS.150
medium
----------
PROBLEM STATEMENT:
Consider a string, [expression] satisfying the following criteria:


[expression] are the same.
[expression] are the same.
[expression].


Given [expression].
----------
TOP SOLUTION:
----------
#define BUFSIZE 1000000
char buf[BUFSIZE];
int Tests, cnum;
// #define USEWIN
#define MANYTESTS 0
// #define LINEBYLINE

// Eryx's new template for I/O contests, May 3, 2015

#include <algorithm>
#include <string>
#include <stdio.h>
using namespace std;

typedef long long ll;

#define Size(x) (int(x.size()))

string getLine() {
  string s;
  while(!feof(stdin)) {
    char c = fgetc(stdin);
    if(c <= 0) continue;
    if(c == 13) continue;
    if(c == 10) return s;
    s += c;
    }
  return s;
  }

int scanerr;

int getNum() {
#ifdef LINEBYLINE
  string s = getLine();
  return atoi(s.c_str());
#else
  int i;
  scanerr = scanf("%d", &i);
  return i;
#endif
  }

string getStr() {
#ifdef LINEBYLINE
  return getStr();
#else
  scanerr = scanf("%s", buf);
  return buf;
#endif
  }

#define TDEF template<int P>
#define modarP modar<P>

TDEF struct modar {
  int content;
  
  modar(int _c) { content = _c % P; if(content<0) content += P; }
  modar(ll _c) { content = _c % P; if(content<0) content += P; }
  modar() {}
  int asInt() { return content; }
  };

TDEF modarP operator == (modarP x, modarP y) { return x.content == y.content; }
TDEF modarP operator != (modarP x, modarP y) { return x.content != y.content; }

#define F(P, d) \
  TDEF modarP& operator P##= (modarP& x, modarP y) { d; return x; } \
  TDEF modarP& operator P##= (modarP& x, int y) { return x P##= modarP(y); } \
  TDEF modarP& operator P##= (modarP& x, ll  y) { return x P##= modarP(y); } \
  TDEF modarP operator P (modarP x, modarP y) { return x P##= y; } \
  F0(P)

#define F0(P) \
  TDEF modarP operator P (modarP x, int y) { return x P modarP(y); } \
  TDEF modarP operator P (modarP x, ll y) { return x P modarP(y); } 

F(+, ll tmp = x.content + ll(y.content); x.content = tmp>=P ? tmp-P : tmp;) 
F(-, ll tmp = x.content - ll(y.content); x.content = tmp<0 ? tmp+P : tmp;)
F(*, ll tmp = x.content * ll(y.content); x.content = tmp % P;) 
F(/, x *= power(y, P-2);)

F0(==) F0(!=)
#undef F
#undef F0

// ERROR ==/!= are not bools! check in text.cpp

TDEF modarP power(modarP x, int q) {
  modarP one(1);
  while(true) {
    if(q&1) one *= x;
    q >>= 1;
    if(!q) return one;
    x *= x;
    }
  }

#line 10 "work.cpp"

/// ----


//Eryx

// !FDI

// states:
// [not counted] 

#define P 1000000007

modarP seenfirst[30];
modarP seenboth[30][30];
modarP seenthree[30][30];

void solveCase() {
  string S = getStr();
  modarP result;
  
  for(char cc: S) {
    int c = cc - 'a';
    
    for(int x=0; x<26; x++)
      result += seenthree[c][x];
    for(int x=0; x<26; x++)
      seenthree[x][c] += seenboth[x][c];
    for(int x=0; x<26; x++)
      seenboth[x][c] += seenfirst[x];
    seenfirst[c] += 1;
    }
  
  printf("%d\n", result.asInt());
  }

#define P 1000000007

int main() {

  if(!MANYTESTS) Tests = 1;
  else Tests = getNum();
  
  for(cnum=1; cnum<=Tests; cnum++)
    solveCase();
    
  // finish
  return 0;
  }

// This solution includes hidden routines to solve test cases in separate
// processes in order to make it faster. I will update them to run on a
// cluster if I get one ;)

----------
====================
----------
ALGORITHMS.151
hard
----------
PROBLEM STATEMENT:
Xander Cage has a list of cities he can visit on his new top-secret mission. He represents each city as a tuple of [expression] are distinct across all cities.

We define a mission as a sequence of cities, [expression] of all the cities in his mission list.

Being eccentric, he abides by the following rules on any mission:


He can choose the number of cities he will visit (if any).
He can start the mission from any city.
He visits cities in order of strictly increasing [expression].
The absolute difference in [expression].
The absolute difference in [expression].


Given [expression] that Xander can earn on a mission.
----------
TOP SOLUTION:
----------
//#define _GLIBCXX_DEBUG
#include <bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define fst first
#define snd second
#define forn(i, n) for (int i = 0; i < int(n); ++i)
typedef long long ll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vll;
typedef pair<int, int> pii;
typedef vector<pii> vii;
#define sz(c) (int)(c).size()
#define ALL(c) (c).begin(), (c).end()

struct town
{
    int x, y, h, p;

    bool operator < (const town &o) const
    {
        return h < o.h;
    }
};

struct segtree
{
    vll vals;
    int tsz;

    segtree ()
    {
        vals.clear();
        tsz = 0;
    }

    segtree (int n)
    {
        tsz = 1;
        while (tsz <= n)
            tsz *= 2;

        vals.assign(2 * tsz, 0);
    }

    void put (int pos, ll what)
    {
        for (pos += tsz; pos > 0; pos >>= 1)
            vals[pos] = max(vals[pos], what);
    }

    ll query (int l, int r)
    {
        ll ans = 0;
        for (l += tsz, r += tsz; l < r; l >>= 1, r >>= 1)
        {
            if (l & 1)
                ans = max(ans, vals[l++]);
            if (r & 1)
                ans = max(ans, vals[--r]);
        }
        return ans;
    }
};

struct segtree2d
{
    vvi who;
    vector<segtree> data;
    int tsz;

    segtree2d (const vii &ps)
    {
        int X = 0;
        const int n = sz(ps);
        forn (i, n) X = max(X, ps[i].fst);

        tsz = 1;
        while (tsz <= X)
            tsz *= 2;

        data.resize(2 * tsz);
        who.resize(2 * tsz);
        forn (i, n)
            who[ps[i].fst + tsz].pb(ps[i].snd);

        for (int i = tsz; i < 2 * tsz; i++)
            data[i] = segtree(sz(who[i]));

        for (int i = tsz - 1; i >= 1; i--)
        {
            who[i].resize(sz(who[2 * i]) + sz(who[2 * i + 1]));
            merge(ALL(who[2 * i]), ALL(who[2 * i + 1]), who[i].begin());
            data[i] = segtree(sz(who[i]));
        }
    }

    ll query (int v, int d, int u)
    {
        int rd = lower_bound(ALL(who[v]), d) - who[v].begin();
        int ru = lower_bound(ALL(who[v]), u) - who[v].begin();
        return data[v].query(rd, ru);
    }

    ll query (int l, int r, int d, int u)
    {
        r = min(r, tsz);
        ll ans = 0;
        for (l += tsz, r += tsz; l < r; l >>= 1, r >>= 1)
        {
            if (l & 1)
                ans = max(ans, query(l++, d, u));
            if (r & 1)
                ans = max(ans, query(--r, d, u));
        }
        return ans;
    }

    void putnode (int v, int pos, ll what)
    {
        int cur = lower_bound(ALL(who[v]), pos) - who[v].begin();
        assert(cur != sz(who[v]) && who[v][cur] == pos);
        data[v].put(cur, what);
    }

    void put (int x, int y, ll what)
    {
        for (x += tsz; x > 0; x >>= 1)
            putnode(x, y, what);
    }
};

void solve (int n)
{
    int mx, my;
    cin >> mx >> my;

    vector<town> v(n);
    forn (i, n)
        cin >> v[i].x >> v[i].y >> v[i].h >> v[i].p;

    sort(ALL(v));
    vii ps(n);
    forn (i, n) ps[i] = mp(v[i].x, v[i].y);

    segtree2d data(ps);
    vll dp(n);

    forn (i, n)
    {
        int cx = v[i].x, cy = v[i].y;
        int lx = max(0, cx - mx), ly = max(0, cy - my);
        int rx = cx + mx, ry = cy + my;
        dp[i] = data.query(lx, rx + 1, ly, ry + 1) + v[i].p;
        data.put(cx, cy, dp[i]);
    }

    ll ans = max(0LL, *max_element(ALL(dp)));
    cout << ans << endl;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    int n;
    while (cin >> n)
        solve(n);
}

----------
====================
----------
ALGORITHMS.152
medium
----------
PROBLEM STATEMENT:
Ron and Hermione are deep in the Forbidden Forest collecting potion ingredients, and they've managed to lose their way. The path out of the forest is blocked, so they must make their way to a portkey that will transport them back to Hogwarts.  

Consider the forest as an [expression]. 

.X.X......X
.X*.X.XXX.X
.XX.X.XM...
......XXXX.


In example above, Ron and Hermione are located at index [expression]. Each cell is indexed according to Matrix Conventions.    

Hermione decides it's time to find the portkey and leave. They start along the path and each time they have to choose a direction, she waves her wand and it points to the correct direction. Ron is betting that she will have to wave her wand exactly [expression] times. Can you determine if Ron's guesses are correct?

The map from above has been redrawn with the path indicated as a series where [expression] is just a step on the path:

.X.X.10000X
.X*0X0XXX0X
.XX0X0XM01.
...100XXXX.


There are three instances marked with [expression] where Hermione must use her wand.

Note: It is guaranteed that there is only one path from the starting location to the portkey.  

Function Description  

Complete the countLuck function in the editor below.  It should return a string, either [expression] if he is not.  

countLuck has the following parameters:  


matrix: a list of strings, each one represents a row of the matrix  
k: an integer that represents Ron's guess  

----------
TOP SOLUTION:
----------
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <string>
#include <cstdio>
#include <vector>
#include <map>
#include <set>

using namespace std;

#define SIZE(A) (int((A).size()))
#define pb(A) push_back(A)
#define mp(A,B) make_pair(A,B)

const int fx[] = {0, 1, 0, -1}, fy[] = {1, 0, -1, 0};

int n, m;
int col;
int p[2000][2000];
char w[2000][2000];
char s[2000][2000];

void dfs(int x, int y) {
	w[x][y]=col;
	for (int i = 0; i < 4; i++) {
		int xx = x+fx[i], yy = y+fy[i];

		if (xx<0||yy<0||xx>=n||yy>=m||w[xx][yy]==col||s[xx][yy]=='X') continue;

		p[xx][yy] = (i+2)&3;
		dfs(xx, yy);
	}
}

int solve(int x, int y) {
	w[x][y] = ++col;
	for (int i = x, j = y; s[i][j]!='M';) {
		int v = p[i][j];
		i += fx[v]; j += fy[v];
		w[i][j] = col;
	}

	int amo=0;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (w[i][j]==col) {
				if (s[i][j]=='*') continue;
				
				int add=0;

				for (int k = 0; k < 4; k++) {
					int xx = i+fx[k], yy=j+fy[k];
					if (xx<0||yy<0||xx>=n||yy>=m||w[xx][yy]==col||s[xx][yy]=='X') continue;
					add=1;
				}

				amo+=add;
			}
		}
	}
	return amo;
}

int main() {
	int t;
	cin >> t;
	for (; t--;) {
		cin >> n >> m;
		for (int i = 0; i < n; i++) {
			scanf("%s", s[i]);
		}
		int k;
		cin >> k;

		col++;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (s[i][j] == 'M') {
					dfs(i, j);
				}
			}
		}
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (s[i][j] == '*') {
					k -= solve(i, j);
				}
			}
		}
		puts(!k?"Impressed":"Oops!");
	}

    return 0;
}


----------
====================
----------
ALGORITHMS.153
medium
----------
PROBLEM STATEMENT:
Anna loves graph theory! She has a tree where each vertex is numbered from [expression], and each contains a data value.  

The sum of a tree is the sum of all its nodes' data values.  If she cuts an edge in her tree, she forms two smaller trees.  The difference between two trees is the absolute value between their sums.  

Given a tree, determine which edge to cut so that the resulting trees have a minimal difference between them, then return that difference.  

For example, your tree's nodes have weights of [expression].  



The values are calculated as follows:  

Edge    Tree 1  Tree 2  Absolute
Cut     Sum      Sum     Difference
1        8         13         5
2        9         12         3
3        6         15         9
4        4         17        13
5        5         16        11


The minimum absolute difference is [expression].

Note: The tree is always rooted at vertex [expression].  

Function Description  

Complete the cutTheTree function in the editor below.  Return an integer that represents the minimal absolute difference achievable between the resultant two trees.  

cutTheTree has the following parameter(s):  


data: an array of integers that represent node values  
edges: an 2 dimensional array of integer pairs where each pair represents an edge in the graph  

----------
TOP SOLUTION:
----------
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <algorithm>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <limits>
#include <cstring>
#include <string>
using namespace std;
 
#define pairii pair<int, int>
#define llong long long
#define pb push_back
#define sortall(x) sort((x).begin(), (x).end())
#define INFI  numeric_limits<int>::max()
#define INFLL numeric_limits<llong>::max()
#define INFD  numeric_limits<double>::max()
#define FOR(i,s,n) for (int (i) = (s); (i) < (n); (i)++)
#define FORZ(i,n) FOR((i),0,(n))

const int MAXN = 100005;
int w[MAXN];
vector<int> adj[MAXN];
set<int> v;
int n, res, total;

struct Node {
    Node() {
        pr = NULL;
        w = 0;
    }
    Node* pr;
    vector<Node*> cl;
    int w;
    int idx;
};

Node* root;

void build(Node* nd) {
    int idx = nd->idx;
    v.insert(idx);
    nd->w += w[idx];
    for (int x:adj[idx]) {
        if (v.find(x) == v.end()) {
            Node* u = new Node;
            u->pr = nd;
            u->idx = x;
            nd->cl.pb(u);
            build(u);
            nd->w += u->w;
        }
    }
}

void dfs(Node* nd) {
    int idx = nd->idx;
    if (nd->pr != NULL) {
        res = min(res, abs(total-2*nd->w));
    }
    for (Node* u : nd->cl) {
        dfs(u);
    }
}

void solve() {
    scanf("%d", &n);
    FORZ(i,n) scanf("%d", w+i);
    FORZ(i,n-1) {
        int a,b;
        scanf("%d %d", &a, &b);
        a--; b--;
        adj[a].pb(b);
        adj[b].pb(a);
    }
    root = new Node;
    root->idx = 0;
    build(root);
    total = root->w;
    res = INFI;
    dfs(root);
    printf("%d\n", res);
}
 
int main() {
#ifdef DEBUG
    freopen("in.txt", "r", stdin);
    //freopen("out.txt", "w", stdout);
#endif
    solve();
    return 0;
}
----------
====================
----------
ALGORITHMS.154
hard
----------
PROBLEM STATEMENT:
Karl loves playing games on social networking sites. His current favorite is CandyMaker, where the goal is to make candies. 

Karl just started a level in which he must accumulate [expression] units, and there is no limit to the number of machines he can own or workers he can employ.

Karl wants to minimize the number of passes to obtain the required number of candies at the end of a day. Determine that number of passes.

For example, Karl starts with [expression] candies.  He executes the following strategy:  


Make [expression] candies.  Purchase two machines.  
Make [expression] workers.  
Make [expression] candies.  
Make [expression] candies.


It took [expression] passes to make enough candies.  

Function Description

Complete the minimumPasses function in the editor below.  The function must return a long integer representing the minimum number of passes required.

minimumPasses has the following parameter(s):


m: long integer, the starting number of machines  
w: long integer, the starting number of workers  
p: long integer, the cost of a new hire or a new machine  
n: long integer, the number of candies to produce  

----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
ALGORITHMS.155
medium
----------
PROBLEM STATEMENT:
The Tower of Hanoi is a famous game consisting of [expression] rods and a number of discs of incrementally different diameters. The puzzle starts with the discs neatly stacked on one rod, ordered by ascending size with the smallest disc at the top. The game's objective is to move the entire stack to another rod, obeying the following rules:


Only one disc can be moved at a time.
Each move consists of taking the topmost disc from a stack and moving it to the top of another stack.
No disc may be placed on top of a smaller disc.




Gena has a modified version of the Tower of Hanoi. His Hanoi has [expression] discs ordered by ascending size. He made a few moves (following the rules above), but stopped and lost his place. He wants to restore the tower to its original state by making valid moves. Given the state of Gena's Hanoi, help him calculate the minimum number of moves needed to restore the tower to its original state.

Note: Gena's rods are numbered from [expression].
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

#define sz(x) ((int) (x).size())
#define forn(i,n) for (int i = 0; i < int(n); ++i)
#define forab(i,a,b) for (int i = int(a); i < int(b); ++i)

typedef long long ll;
typedef long long i64;
typedef long double ld;

const int inf = int(1e9) + int(1e5);
const ll infl = ll(2e18) + ll(1e10);

int d[1 << 20];

int main() {
    cout.precision(10);
    cout.setf(ios::fixed);
    #ifdef LOCAL
    assert(freopen("c.in", "r", stdin));
    #else
    #endif
    int n;
    cin >> n;
    int mask = 0;
    forn (i, n) {
        int k;
        cin >> k;
        mask |= ((k - 1) << (2 * i));
    }
    forn (i, 1 << 20)
        d[i] = inf;
    d[mask] = 0;
    queue<int> o;
    o.push(mask);
    while (!o.empty()) {
        int mask = o.front();
        o.pop();
        if (mask == 0)
            break;
        vector<int> b[4];
        forn (i, n)
            b[(mask >> (2 * i)) & 3].push_back(i);
        forn (i, 4)
            b[i].push_back(inf);
        forn (i, 4)
            forn (j, 4) {
                if (b[i].front() >= b[j].front())
                    continue;
                int id = b[i].front();
                int to = mask ^ ((i ^ j) << (2 * id));
                if (d[to] < inf)
                    continue;
                d[to] = d[mask] + 1;
                o.push(to);
            }
    }
    cout << d[0] << '\n';
    #ifdef LOCAL
    cerr << "Time: " << double(clock()) / CLOCKS_PER_SEC << '\n';
    #endif
}

----------
====================
----------
ALGORITHMS.156
medium
----------
PROBLEM STATEMENT:
We call an quadruple of positive integers, [expression], beautiful if the following condition is true:

[expression]

Note: [expression] is the bitwise XOR operator.

Given [expression] where the following constraints hold:


[expression]
[expression]
[expression]
[expression]


When you count the number of beautiful quadruples, you should consider two quadruples as same if the following are true:


They contain same integers.
Number of times each integers occur in the quadruple is same.


For example [expression] should be considered as same.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <algorithm>
#include <functional>
#include <utility>
#include <bitset>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstdio>

using namespace std;

#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)
#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)

int a[4];
int A,B,C,D;

typedef long long ll;

ll total;
ll cnt[10000];

int main(void){
	int i,j;
	
	REP(i,4) cin >> a[i];
	sort(a, a+4);
	
	A = a[0];
	B = a[1];
	C = a[2];
	D = a[3];
	
	for(i=1;i<=C;i++) for(j=i;j<=D;j++){
		total++;
		cnt[i^j]++;
	}
	
	ll ans = 0;
	
	for(j=1;j<=B;j++){
		for(i=1;i<=A&&i<=j;i++) ans += total - cnt[i^j];
		for(i=j;i<=D;i++){
			total--;
			cnt[i^j]--;
		}
	}
	
	cout << ans << endl;
	
	return 0;
}

----------
====================
----------
ALGORITHMS.157
medium
----------
PROBLEM STATEMENT:
In ordinary chess, the pieces are only of two colors, black and white. In our version of chess, we are including new pieces with unique movements. One of the most powerful pieces in this version is the red knight.  

The red knight can move to six different positions based on its current position (UpperLeft, UpperRight, Right, LowerRight, LowerLeft, Left) as shown in the figure below. 



The board is a grid of size [expression] is the bottom-right corner. 

Complete the function printShortestPath, which takes as input the grid size [expression] respectively, as input. The function does not return anything.     

Given the coordinates of the starting position of the red knight and the coordinates of the destination, print the minimum number of moves that the red knight has to make in order to reach the destination and after that, print the order of the moves that must be followed to reach the destination in the shortest way. If the destination cannot be reached, print only the word "Impossible". 

Note: There may be multiple shortest paths leading to the destination. Hence, assume that the red knight considers its possible neighbor locations in the following order of priority: UL, UR, R, LR, LL, L. In other words, if there are multiple possible options, the red knight prioritizes the first move in this list, as long as the shortest path is still achievable. Check sample input [expression] for an illustration.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

#ifndef LOCAL
#define cerr dolor_sit_amet
#endif

#define mp make_pair
#define sz(x) ((int)((x).size()))
#define X first
#define Y second
#define ALL(x) (x).begin(), (x).end()

using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair < int , int > ipair;
typedef pair < ll , ll > lpair;
const int IINF = 0x3f3f3f3f;
const ll LINF = 0x3f3f3f3f3f3f3f3fll;
const double DINF = numeric_limits<double>::infinity();
const int MOD = 1000000007;
const double EPS = 1e-9;
const double PI = acos(-1.0);
ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
ll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }
double sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }
mt19937 mmtw(960172);
ll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }

// ========================================================================= //

const int DX[] = {2, 2, 0, -2, -2, 0};
const int DY[] = {-1, 1, 2, 1, -1, -2};
const string DS[] = {"LL", "LR", "R", "UR", "UL", "L"};
const int order[] = {4, 3, 2, 1, 0, 5};

const int N = 222;

int d[N][N], dp[N][N];

int main() {
    ios::sync_with_stdio(false);

    int n;
    int x1, y1, x2, y2;

    cin >> n >> x1 >> y1 >> x2 >> y2;
    memset(d, 0x3f, sizeof(d));
    d[x1][y1] = 0;
    vector<ipair> q = {{x1, y1}};
    for (int i = 0; i < sz(q); ++i) {
        int x = q[i].X, y = q[i].Y;
        for (int j : order) {
            int nx = x + DX[j];
            int ny = y + DY[j];
            if (nx >= 0 && ny >= 0 && nx < n && ny < n && d[nx][ny] == IINF) {
                d[nx][ny] = d[x][y] + 1;
                dp[nx][ny] = j;
                q.push_back({nx, ny});
            }
        }
    }

    if (d[x2][y2] == IINF)
        cout << "Impossible\n";
    else {
        vector<string> ss;
        while (x2 != x1 || y2 != y1) {
            int j = dp[x2][y2];
            ss.push_back(DS[j]);
            x2 -= DX[j];
            y2 -= DY[j];
        }
        reverse(ALL(ss));
        cout << sz(ss) << "\n";
        for (auto x : ss)
            cout << x << " ";
        cout << "\n";
    }

    return 0;
}

----------
====================
----------
ALGORITHMS.158
hard
----------
PROBLEM STATEMENT:
There are [expression] bikes are acquired in the minimum time.

Every biker moves with a unit speed and one bike can be acquired by only one biker. A biker can proceed in any direction. Consider distance between bikes and bikers as Euclidean distance.

Jack would like to know the square of required time to start the race as soon as possible. 
----------
TOP SOLUTION:
----------
#include<cstdio>
#include<cstring>
#include<set>
#include<queue>
#include<vector>
#include<algorithm>
#include<cstdlib>
#include<ctime>
#include<cmath>
using namespace std;
int i,j,n,m,k,x[259],y[259],a[259],b[259],C[259],urm[259],pre[259];
long long p,u,mij,ras,D[259][259];
vector < int > v[259];
int mod(int x)
{
    if(x<0) return -x;
    return x;
}
int cup(int nod)
{
    if(C[nod]==1) return 0;
    C[nod]=1;
    vector < int > :: iterator it;
    for(it=v[nod].begin();it!=v[nod].end();it++)
        if(pre[*it]==0)
        {
            pre[*it]=nod;
            urm[nod]=*it;
            return 1;
        }
    for(it=v[nod].begin();it!=v[nod].end();it++)
        if(cup(pre[*it]))
        {
            pre[*it]=nod;
            urm[nod]=*it;
            return 1;
        }
    return 0;
}
int cuplaj()
{
    int ok=1;
    for(i=1;i<=n;i++)
        C[i]=urm[i]=0;
    for(j=1;j<=m;j++)
        pre[j]=0;
    while(ok)
    {
        ok=0;
        for(i=1;i<=n;i++)
            C[i]=0;
        for(i=1;i<=n;i++)
            if(urm[i]==0) ok+=cup(i);
    }
    ok=0;
    for(i=1;i<=n;i++)
        ok+=(urm[i]>0);
    return ok;
}
bool ok(long long dstmx)
{
    int i;
    for(i=1;i<=n;i++)
        v[i].clear();
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            if(D[i][j]<=dstmx) v[i].push_back(j);
    return (cuplaj()>=k);
}
int main()
{
//freopen("input","r",stdin);
//freopen("output","w",stdout);
scanf("%d",&n);
scanf("%d",&m);
scanf("%d",&k);
for(i=1;i<=n;i++)
{
    scanf("%d",&x[i]);
    scanf("%d",&y[i]);
}
for(i=1;i<=m;i++)
{
    scanf("%d",&a[i]);
    scanf("%d",&b[i]);
}
for(i=1;i<=n;i++)
    for(j=1;j<=m;j++)
        D[i][j]=1LL*(a[j]-x[i])*(a[j]-x[i])+1LL*(b[j]-y[i])*(b[j]-y[i]);
p=0;
u=10000000000000000;
while(p<=u)
{
    mij=(p+u)/2;
    if(ok(mij))
    {
        ras=mij;
        u=mij-1;
    }
    else p=mij+1;
}
printf("%lld\n",ras);
return 0;
}

----------
====================
----------
ALGORITHMS.159
advanced
----------
PROBLEM STATEMENT:
You have a long list of tasks that you need to do today. To accomplish task [expression]. You need not complete a task at a stretch. You can complete a part of it, switch to another task, and then switch back.

You've realized that it might not be possible to complete all the tasks by their deadline. So you decide to do them in such a manner that the maximum amount by which a task's completion time overshoots its deadline is minimized.
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */

#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#define NMAX 300000
#define NN 100000
#define INF 1000000000LL
using namespace std;

typedef long long LL;

struct N{//data to store in tree
        LL each,maxsub; //operation load.log update.,subtree statistic(calculate sub tree status in every update)
        N(){
                each = 0;
                maxsub = -INF;
        }
};

N st[NMAX];

void update2(int ni,int s,int e,int ps,int pe,LL v){
        if(ps > pe)return;
        if(pe < s || ps > e)return;
        else if(ps <= s && pe >= e){//update all
                st[ni].each += v;
        }
        else{
                int mid = (s+e)/2;
                update2(ni*2+1,s,mid,ps,min(mid,pe),v);
                update2(ni*2+2,mid+1,e,max(mid+1,ps),pe,v);
                LL sub1 = st[ni*2+1].each;
                LL sub2 = st[ni*2+2].each;
                if(mid>s)sub1 += st[ni*2+1].maxsub;
                if(mid+1<e)sub2 += st[ni*2+2].maxsub;
                st[ni].maxsub = max(sub1,sub2);
        }
}

LL query2(int ni,int s,int e,int ps,int pe){
        if(ps > pe)return -INF;
        if(pe < s || ps > e)return -INF;
        else if(ps <= s && pe >= e){//get all segment
                if(s==e)return st[ni].each;
                else return st[ni].maxsub + st[ni].each;
        }
        else{
                int mid = (s+e)/2;
                return  max(query2(2*ni+1,s,mid,ps,min(pe,mid)),query2(2*ni+2,mid+1,e,max(ps,mid+1),pe))+st[ni].each;
        }
}



int main(){
        for(LL i=0;i<=NN;i++){
                update2(0,0,NN,i,i,-i);
        }
        int nn;scanf("%d",&nn);
        for(int i=0;i<nn;i++){
                int a,b;scanf("%d%d",&a,&b);
                update2(0,0,NN,a,NN,b);
                LL ret = max(0LL,query2(0,0,NN,0,NN));
                printf("%lld\n",ret);
        }
        return 0;
}

----------
====================
----------
ALGORITHMS.160
advanced
----------
PROBLEM STATEMENT:
A pair of nodes, [expression], is a similar pair if the following conditions are true:


node [expression]
[expression]


Given a tree where each node is labeled from [expression], find the number of similar pairs in the tree.

For example, given the following tree:  

  

We have the following pairs of ancestors and dependents:  

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



If [expression].

Function Description

Complete the similarPair function in the editor below.  It should return an integer that represents the number of pairs meeting the criteria.

similarPair has the following parameter(s):  


n: an integer that represents the number of nodes  
k: an integer
edges: a two dimensional array where each element consists of two integers that represent connected node numbers  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int n, aib[200005];

inline int lsb(int & x){
    return x & -x;
}

void update(int val, int pos){
    for(int i = pos; i <= n * 2; i += lsb(i))
        aib[i] += val;
}

int query(int pos){
    int rval = 0;
    for(int i = pos; i > 0; i -= lsb(i))
        rval += aib[i];
    return rval;
}

vector<int> graph[100005];
int t, dad[100005];
long long ans;

void dfs(int x){
    ans += (long long)query(x + t) - query(x - t - 1);
    update(1, x);
    for(int i = 0; i < graph[x].size(); ++i)
        dfs(graph[x][i]);
    update(-1, x);
}

int main() {
    cin >> n >> t;
    for(int i = 1; i < n; ++i){
        int x, y;
        cin >> x >> y;
        dad[y] = x;
        graph[x].push_back(y);
    }
    for(int i = 1; i <= n; ++i)
        if(!dad[i])
            dfs(i);
    cout << ans;
    return 0;
}

----------
====================
----------
ALGORITHMS.161
hard
----------
PROBLEM STATEMENT:
Given an array of integers, you must answer a number of queries. Each query consists of a single integer, [expression], and is performed as follows:


Add [expression] to each element of the array, permanently modifying it for any future queries.
Find the absolute value of each element in the array and print the sum of the absolute values on a new line.


Tip: The Input/Output for this challenge is very large, so you'll have to be creative in your approach to pass all test cases.

Function Description  

Complete the playingWithNumbers function in the editor below.  It should return an array of integers that represent the responses to each query.  

playingWithNumbers has the following parameter(s):  


arr: an array of integers  
queries: an array of integers  

----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

int main() {
	int N;
	scanf("%d", &N);
	vector<long long> A(N);
	rep(i, N) scanf("%lld", &A[i]);
	sort(all(A));
	vector<long long> sum(N+1, 0);
	rep(i, N)
		sum[i+1] = sum[i] + A[i];
	int Q;
	scanf("%d", &Q);
	long long added = 0;
	rep(ii, Q) {
		int x;
		scanf("%d", &x);
		added += x;
		//A[i] + added >= 0
		//A[i] >= -added
		int k = lower_bound(all(A), -added) - A.begin();
		long long ans = 0;
		ans += (sum[N] - sum[k]) + added * (N - k);
		ans += -((sum[k] - sum[0]) + added * k);
		printf("%lld\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.162
expert
----------
PROBLEM STATEMENT:
Victor is building a Japanese rock garden in his [expression] stones in the garden according to the following rules:


The center of each stone is located at some point [expression]. 
The coordinates of all twelve stones are pairwise distinct. 
The Euclidean distance from the center of any stone to the origin is not an integer. 
The sum of Euclidean distances between all twelve points and the origin is an almost integer, meaning the absolute difference between this sum and an integer must be [expression].


Given the values of [expression] coordinates of the stone's location.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;

typedef int _loop_int;
#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)
#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)
#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)

#define DEBUG(x) cout<<#x<<": "<<x<<endl
#define DEBUG_VEC(v) cout<<#v<<":";REP(i,v.size())cout<<" "<<v[i];cout<<endl
#define ALL(a) (a).begin(),(a).end()

#define CHMIN(a,b) a=min((a),(b))
#define CHMAX(a,b) a=max((a),(b))

inline int pack(int x,int y){
  return (x+25)*64 + (y+25);
}
inline void unpack(int p,int &x,int &y){
  x = (p/64)-25;
  y = (p%64)-25;
}

map<double,vi> mp;
vector<double> V;
int n;
map<double,int> rev;

vector<vi> answers;
vi ids;

void appen(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j,int k,int l){
  vi v;
  v.push_back(a);
  v.push_back(b);
  v.push_back(c);
  v.push_back(d);
  v.push_back(e);
  v.push_back(f);
  v.push_back(g);
  v.push_back(h);
  v.push_back(i);
  v.push_back(j);
  v.push_back(k);
  v.push_back(l);
  int demi = answers.size();
  answers.push_back(v);
  double sum = 0.0;
  REP(z,v.size()){
    ids[v[z]] = demi;
    sum += V[v[z]];
  }
  // printf("%.15f\n",sum);
}

int main(){
  FOR(x,-12,13)FOR(y,-12,13){
    int dst = x*x + y*y;
    double sq = sqrt(dst);
    int sqi = sq;
    if(sqi!=sq)mp[sq].push_back(pack(x,y));
  }
  {
    map<double,vi>::iterator iter = mp.begin();
    while(iter != mp.end()){
      double d = iter->first;
      V.push_back(d);
      iter++;
    }
  }
  n = V.size();
  REP(i,n)rev[V[i]] = i;
  // go
  ids.assign(n,-1);
  appen(0,1,3,25,41,43,62,8,10,20,34,39);
  appen(2,1,3,25,41,43,62,6,8,20,34,39);
  appen(4,13,27,65,8,45,49,25,28,37,43,51);
  appen(5,30,31,45,22,31,46,13,16,31,52,54);
  appen(7,1,3,25,8,15,34,16,20,39,43,62);
  appen(9,10,41,48,21,24,62,21,25,30,38,44);
  appen(11,37,43,67,12,35,44,29,31,44,53,57);
  appen(14,21,44,66,21,36,37,3,36,37,54,62);
  appen(17,1,3,25,41,43,62,4,8,16,20,34);
  appen(18,8,27,31,7,12,57,25,29,31,50,57);
  appen(19,15,43,59,33,47,59,4,7,30,32,59);
  appen(23,1,30,66,46,54,61,27,28,31,33,66);
  appen(26,1,3,25,34,43,62,1,8,16,20,39);
  appen(40,11,38,43,26,36,65,0,3,27,59,62);
  appen(42,44,48,49,18,30,66,18,28,31,40,61);
  appen(55,0,24,40,49,54,55,27,29,40,48,49);
  appen(56,3,6,25,0,34,43,0,8,20,39,62);
  appen(58,45,53,65,26,51,65,18,21,22,46,65);
  appen(60,26,34,63,31,33,41,9,15,31,34,37);
  appen(64,12,35,37,43,44,60,11,29,31,44,57);

  int xx,yy;
  scanf("%d%d",&xx,&yy);
  double vv = sqrt(xx*xx+yy*yy);
  int id = ids[rev[vv]];
  vi vec = answers[id];
  vi head(n,0);
  bool poyo = false;
  REP(i,vec.size()){
    double ww = V[vec[i]];
    if(!poyo && ww==vv){
      poyo = true;
      continue;
    }
    while(true){
      int po = mp[ww][head[vec[i]]++];
      int xxx,yyy;
      unpack(po,xxx,yyy);
      if(xx==xxx && yy==yyy)continue;
      printf("%d %d\n",xxx,yyy);
      break;
    }
  }
  return 0;
}

----------
====================
----------
ALGORITHMS.163
hard
----------
PROBLEM STATEMENT:
Consider an array [expression]:


Sort all the elements in the subsegment [expression].


Given [expression] queries?
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }

typedef char Val;
struct Sum {
	int cnt;
	Sum() : cnt(0) {}
	Sum(const Val &val, int pos) : cnt(val) {}
	Sum &operator+=(const Sum &that) { cnt += that.cnt; return *this; }
	Sum operator+(const Sum &that) const { return Sum(*this) += that; }
};
struct Add {
	int assign;
	Add() : assign(-1) {}
	explicit Add(int a) : assign(a) {}
	Add &operator+=(const Add &that) {
		if(that.assign != -1)
			assign = that.assign;
		return *this;
	}
	void addToVal(Val &val, int pos) const {
		if(assign != -1)
			val = assign != 0;
	}
	void addToSum(Sum &sum, int left, int right) const {
		if(assign != -1)
			sum.cnt = assign != 0 ? right - left : 0;
	}
};

struct SegmentTree {
	vector<Val> leafs;
	vector<Sum> nodes;
	vector<Add> add;
	vector<int> leftpos, rightpos;
	int n, n2;
	void init(int n_, const Val &v = Val()) { init(vector<Val>(n_, v)); }
	void init(const vector<Val> &u) {
		n = 1; while(n < (int)u.size()) n *= 2;
		n2 = (n - 1) / 2 + 1;
		leafs = u; leafs.resize(n, Val());
		nodes.resize(n);
		for(int i = n - 1; i >= n2; -- i)
			nodes[i] = Sum(leafs[i * 2 - n], i * 2 - n) + Sum(leafs[i * 2 + 1 - n], i * 2 + 1 - n);
		for(int i = n2 - 1; i > 0; -- i)
			nodes[i] = nodes[i * 2] + nodes[i * 2 + 1];
		add.assign(n, Add());

		leftpos.resize(n); rightpos.resize(n);
		for(int i = n - 1; i >= n2; -- i) {
			leftpos[i] = i * 2 - n;
			rightpos[i] = (i * 2 + 1 - n) + 1;
		}
		for(int i = n2 - 1; i > 0; -- i) {
			leftpos[i] = leftpos[i * 2];
			rightpos[i] = rightpos[i * 2 + 1];
		}
	}
	Val get(int i) {
		int indices[128];
		int k = getIndices(indices, i, i + 1);
		propagateRange(indices, k);
		return leafs[i];
	}
	Sum getRangeCommutative(int i, int j) {
		int indices[128];
		int k = getIndices(indices, i, j);
		propagateRange(indices, k);
		Sum res = Sum();
		for(int l = i + n, r = j + n; l < r; l >>= 1, r >>= 1) {
			if(l & 1) res += sum(l ++);
			if(r & 1) res += sum(-- r);
		}
		return res;
	}
	Sum getRange(int i, int j) {
		int indices[128];
		int k = getIndices(indices, i, j);
		propagateRange(indices, k);
		Sum res = Sum();
		for(; i && i + (i&-i) <= j; i += i&-i)
			res += sum((n + i) / (i&-i));
		for(k = 0; i < j; j -= j&-j)
			indices[k ++] = (n + j) / (j&-j) - 1;
		while(-- k >= 0) res += sum(indices[k]);
		return res;
	}
	void set(int i, const Val &x) {
		int indices[128];
		int k = getIndices(indices, i, i + 1);
		propagateRange(indices, k);
		leafs[i] = x;
		mergeRange(indices, k);
	}
	void addToRange(int i, int j, const Add &x) {
		if(i >= j) return;
		int indices[128];
		int k = getIndices(indices, i, j);
		propagateRange(indices, k);
		int l = i + n, r = j + n;
		if(l & 1) { int p = (l ++) - n; x.addToVal(leafs[p], p); }
		if(r & 1) { int p = (-- r) - n; x.addToVal(leafs[p], p); }
		for(l >>= 1, r >>= 1; l < r; l >>= 1, r >>= 1) {
			if(l & 1) add[l ++] += x;
			if(r & 1) add[-- r] += x;
		}
		mergeRange(indices, k);
	}
private:
	int getIndices(int indices[], int i, int j) const {
		int k = 0, l, r;
		if(i >= j) return 0;
		for(l = (n + i) >> 1, r = (n + j - 1) >> 1; l != r; l >>= 1, r >>= 1) {
			indices[k ++] = l;
			indices[k ++] = r;
		}
		for(; l; l >>= 1) indices[k ++] = l;
		return k;
	}
	void propagateRange(int indices[], int k) {
		for(int i = k - 1; i >= 0; -- i)
			propagate(indices[i]);
	}
	void mergeRange(int indices[], int k) {
		for(int i = 0; i < k; ++ i)
			merge(indices[i]);
	}
	inline void propagate(int i) {
		if(i >= n) return;
		add[i].addToSum(nodes[i], leftpos[i], rightpos[i]);
		if(i * 2 < n) {
			add[i * 2] += add[i];
			add[i * 2 + 1] += add[i];
		} else {
			add[i].addToVal(leafs[i * 2 - n], i * 2 - n);
			add[i].addToVal(leafs[i * 2 + 1 - n], i * 2 + 1 - n);
		}
		add[i] = Add();
	}
	inline void merge(int i) {
		if(i >= n) return;
		nodes[i] = sum(i * 2) + sum(i * 2 + 1);
	}
	inline Sum sum(int i) {
		propagate(i);
		return i < n ? nodes[i] : Sum(leafs[i - n], i - n);
	}
};

int main() {
	int n; int q; int k;
	while(~scanf("%d%d%d", &n, &q, &k)) {
		vector<int> A(n);
		for(int i = 0; i < n; ++ i)
			scanf("%d", &A[i]);
		vector<int> l(q), r(q);
		for(int i = 0; i < q; ++ i)
			scanf("%d%d", &l[i], &r[i]), ++ r[i];
		vi values = A;
		sort(values.begin(), values.end());
		values.erase(unique(values.begin(), values.end()), values.end());
		int lo = 0, up = (int)values.size() - 1;
		while(up - lo > 0) {
			int mid = (lo + up + 1) / 2;
			vector<Val> initvals(n);
			rep(i, n)
				initvals[i] = values[mid] <= A[i];
			SegmentTree segt; segt.init(initvals);
			rep(i, q) {
				int cnt0 = r[i] - l[i] - segt.getRangeCommutative(l[i], r[i]).cnt;
				segt.addToRange(l[i], l[i] + cnt0, Add(0));
				segt.addToRange(l[i] + cnt0, r[i], Add(1));
			}
			if(segt.get(k))
				lo = mid;
			else
				up = mid - 1;
		}
		printf("%d\n", values[lo]);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.164
expert
----------
PROBLEM STATEMENT:
We take a line segment of length [expression]:



We denote a pair of points, [expression].

Next, let's consider two pairs: [expression]. In other words: 
[expression]

For example, consider the following diagram in which the relationship between points in pairs at non-overlapping indices is shown by a connecting line:



Given [expression], among all pairs of points.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

int c, n;

int dist(pii p) {
    int dd = p.se - p.fi;
    uin(dd, c - dd);
    return dd;
}

struct TEvent {
    int x, ly, ry;
    int id, t;

    bool operator<(const TEvent &ev) const {
        if (x != ev.x) return x < ev.x;
        return (t == 0) < (ev.t == 0);
    }
};

void add_rect(int lx, int rx, int ly, int ry, int id, vector<TEvent> &evs) {
    if (lx >= rx || ly >= ry) return;
    evs.pb({lx, ly, ry, id, -1});
    evs.pb({rx, ly, ry, id, 1});
}

const int maxc = 1100000;
int f[maxc];

int fsum(int i) {
    int s = 0;
    for (; i >= 0; i &= i + 1, --i) s += f[i];
    return s;
}

void fadd(int i, int x) {
    for (; i < maxc; i |= i + 1) f[i] += x;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    cin >> n >> c;
    vector<pii> p(n);
    forn(i, n) {
        cin >> p[i].fi >> p[i].se;
        if (p[i].fi > p[i].se) swap(p[i].fi, p[i].se);
    }

    int L = 0, R = c;
    while (R - L > 1) {
        int M = (L + R) / 2;
        vector<pii> q;
        for (auto w: p) if (dist(w) >= M) q.pb(w);
        vector<TEvent> evs;
        int K = q.size();
        forn(i, K) {
            evs.pb({q[i].fi, q[i].se, -1, i, 0});
            add_rect(q[i].fi + M, q[i].se - M + 1, 0, q[i].se - M + 1, i, evs);
            add_rect(q[i].fi + M, q[i].se - M + 1, q[i].se + M, c + min(0, q[i].fi - M + 1), i, evs);
            add_rect(q[i].se + M, c, 0, c + min(0, q[i].fi - M + 1), i, evs);
        }
        sort(all(evs));
        forn(i, c) f[i] = 0;
        vi ans(K);
        for (auto w: evs) {
            if (w.t == 0) fadd(w.ly, 1);
            else ans[w.id] += w.t * (fsum(w.ry - 1) - fsum(w.ly - 1));
        }

        bool ok = false;
        forn(i, K) ok |= ans[i] > 0;
        (ok ? L : R) = M;
    }
    cout << L << '\n';

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.165
hard
----------
PROBLEM STATEMENT:
King Richard is leading a troop of [expression] square formation, demonstrated below:





Before the battle begins, he wants to test how well his knights follow instructions. He issues [expression] drill commands, where each command follows the format ai bi di and is executed like so:


All knights in the square having the top-left corner at location [expression]. For example:



You must follow the commands sequentially. The square for each command is completely contained within the square for the previous command. Assume all knights follow the commands perfectly.

After performing all [expression] for his first wave of attack; however, because the knights were reordered by the drill commands, he's not sure where his chosen knights are!

As his second-in-command, you must find the locations of the knights. For each knight [expression], print the knight's row and column locations as two space-separated values on a new line.  
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

int S,N,L;

typedef complex<int> pt;

struct state {
	pt orig;
	pt now;
	int d,idx;

	pt get_at(int x,int y) {
		x-=real(now);
		y-=imag(now);
		int rots=idx%4;
		swap(x,y);
		for(;rots--;) {
			int tmp=x;
			x=y;
			y=d-tmp;
		}
		swap(x,y);
		return pt(real(orig)+x,imag(orig)+y);
	}
	bool has(int x,int y) {
		return x>=real(orig) && y>=imag(orig) && x<=real(orig)+d && y<=imag(orig)+d;
	}

	pt rlook(int x,int y) {
		swap(orig,now);
		idx = 4-(idx%4);
		pt ans=get_at(x,y);
		idx=4-(idx%4);
		swap(orig,now);
		return ans;
	}
};
vector<state> vs;

int main() {
	cin>>N>>S;
	vs.push_back({pt(1,1),pt(1,1),N-1,0});
	for(int i=1;i<=S;i++) {
		int a,b,d; cin>>a>>b>>d;
		pt ul=vs.back().get_at(a,b);
		pt dr=vs.back().get_at(a+d,b+d);
		pt neworig={min(real(ul),real(dr)), min(imag(ul),imag(dr))};
		pt newnow={a,b};
		vs.push_back({neworig,newnow,d,i});
	}

	for(auto &st : vs) {
//		cout<<st.orig<<" "<<st.now<<" "<<st.d<<" "<<st.idx<<endl;
	}

cin>>L;
for(;L--;) {
long long w; cin>>w;
int x=w/N+1;
int y=w%N+1;
int lb=0,rb=S;
for(;lb<rb;) {
int mb=(lb+rb+1)/2;
if(vs[mb].has(x,y)) lb=mb;
else rb=mb-1;
}
pt p=vs[lb].rlook(x,y);
cout<<real(p)<<" "<<imag(p)<<endl;
}


}
----------
====================
----------
ALGORITHMS.166
hard
----------
PROBLEM STATEMENT:
Alef the Frog is in an [expression] two-dimensional maze represented as a table.  The maze has the following characteristics: 


Each cell can be free or can contain an obstacle, an exit, or a mine.
Any two cells in the table considered adjacent if they share a side.  
The maze is surrounded by a solid wall made of obstacles. 
Some pairs of free cells are connected by a bidirectional tunnel. 




When Alef is in any cell, he can randomly and with equal probability choose to move into one of the adjacent cells that don't contain an obstacle in it. If this cell contains a mine, the mine explodes and Alef dies. If this cell contains an exit, then Alef escapes the maze.  

When Alef lands on a cell with an entrance to a tunnel, he is immediately transported through the tunnel and is thrown into the cell at the other end of the tunnel. Thereafter, he won't fall again, and will now randomly move to one of the adjacent cells again. (He could possibly fall in the same tunnel later.)   

It's possible for Alef to get stuck in the maze in the case when the cell in which he was thrown into from a tunnel is surrounded by obstacles on all sides.  

Your task is to write a program which calculates and prints a probability that Alef escapes the maze.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define endl '\n'

#define double long double

using namespace std;
const int MAXN = (42);
const double eps = 1e-12;

vector<double> gauss(vector<vector<double>> &a)
{
	int n = a.size(), m = a[0].size() - 1;

	vector<int> where(m, -1);
	for(int col = 0, row = 0; col < m && row < n; col++)
    {
    	int sel = row;
        for(int i = row; i < n; i++)
        	if(abs(a[i][col]) > abs(a[sel][col]))
        		sel = i;

		if(abs(a[sel][col]) < eps) { where[col] = -1; continue; }

        for(int i = col; i <= m; i++)
			swap(a[sel][i], a[row][i]);
		where[col] = row;

		for(int i = 0; i < n; i++)
			if(i != row)
			{
				if(abs(a[i][col]) < eps) continue;
            	double c = a[i][col] / a[row][col];
            	for(int j = 0; j <= m; j++)
                    a[i][j] -= c * a[row][j];
			}

		row++;
    }

    vector<double> ans(m, 0);
    for(int i = 0; i < m; i++)
        if(where[i] != -1)
			ans[i] = a[where[i]][m] / a[where[i]][i];

    for(int i = 0; i < n; i++)
	{
		double sum = a[i][m];
		for(int j = 0; j < m; j++)
			sum -= ans[j] * a[i][j];

		if(abs(sum) > eps) return vector<double>();
	}

	return ans;
}

int n, m, k;
string a[MAXN];
int nxt_x[MAXN][MAXN], nxt_y[MAXN][MAXN];

void read()
{
    cin >> n >> m >> k;
    for(int i = 0; i < n; i++)
        cin >> a[i];

    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            nxt_x[i][j] = i, nxt_y[i][j] = j;

    for(int i = 0; i < k; i++)
    {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        x1--; y1--; x2--; y2--;
        nxt_x[x1][y1] = x2; nxt_y[x1][y1] = y2;
        nxt_x[x2][y2] = x1; nxt_y[x2][y2] = y1;
    }
}

int N;
int encode(int x, int y) { return x * m + y; }

int dirx[4] = {0, 0, 1, -1};
int diry[4] = {1, -1, 0, 0};

bool ok(int x, int y)
{
    if(x >= n || y >= m || x < 0 || y < 0) return false;
    return a[x][y] != '#';
}

void solve()
{
    N = n * m;
    vector<vector<double> > matr;
    vector<double> zero(N + 1, 0);

    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
        {
            if(a[i][j] == '#') { matr.push_back(zero); continue; }
            else if(a[i][j] == '*') { matr.push_back(zero), matr[matr.size() - 1][encode(i, j)] = 1; continue; }
            else if(a[i][j] == '%') { matr.push_back(zero), matr[matr.size() - 1][encode(i, j)] = 1;  matr[matr.size() - 1][N] = 1; continue; }

            vector<int> adj;
            for(int d = 0; d < 4; d++)
                if(ok(i + dirx[d], j + diry[d]))
                    adj.push_back(encode(nxt_x[i + dirx[d]][j + diry[d]], nxt_y[i + dirx[d]][j + diry[d]]));

            matr.push_back(zero);
            matr[matr.size() - 1][encode(i, j)] = 1;

            for(int v: adj)
                matr[matr.size() - 1][v] = -((double)1 / (double)adj.size());
        }

    vector<double> ans = gauss(matr);

    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            if(a[i][j] == 'A')
            {
                cout << setprecision(9) << fixed << ans[encode(i, j)] << endl;
                return;
            }
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	read();
	solve();
	return 0;
}

----------
====================
----------
ALGORITHMS.167
medium
----------
PROBLEM STATEMENT:
The Ruler of HackerLand believes that every citizen of the country should have access to a library. Unfortunately, HackerLand was hit by a tornado that destroyed all of its libraries and obstructed its roads! As you are the greatest programmer of HackerLand, the ruler wants your help to repair the roads and build some new libraries efficiently. 

HackerLand has [expression] bidirectional roads. A citizen has access to a library if:


Their city contains a library.
They can travel by road from their city to a city containing a library.


The following figure is a sample map of HackerLand where the dotted lines denote obstructed roads:



The cost of repairing any road is [expression].    

You are given [expression]. For each query, find the minimum cost of making libraries accessible to all the citizens and print it on a new line.

Function Description

Complete the function roadsAndLibraries in the editor below.  It must return the minimal cost of providing libraries to all, as an integer.

roadsAndLibraries has the following parameters:


n: integer, the number of cities  
c_lib: integer, the cost to build a library  
c_road: integer, the cost to repair a road  
cities: 2D array of integers where each [expression] contains two integers that represent cities connected by an obstructed road . 

----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }

struct UnionFind {
	vector<int> data;
	void init(int n) { data.assign(n, -1); }
	bool unionSet(int x, int y) {
		x = root(x); y = root(y);
		if (x != y) {
			if (data[y] < data[x]) swap(x, y);
			data[x] += data[y]; data[y] = x;
		}
		return x != y;
	}
	bool findSet(int x, int y) { return root(x) == root(y); }
	int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }
	int size(int x) { return -data[root(x)]; }
};

int main() {
	int T;
	scanf("%d", &T);
	for (int ii = 0; ii < T; ++ii) {
		int n; int m; int clib; int croad;
		scanf("%d%d%d%d", &n, &m, &clib, &croad);
		UnionFind uf; uf.init(n);
		rep(i, m) {
			int u; int v;
			scanf("%d%d", &u, &v), --u, --v;
			uf.unionSet(u, v);
		}
		int ccs = 0;
		rep(i, n)
			ccs += uf.root(i) == i;
		ll ans = INFL;
		for (int i = ccs; i <= n; ++i)
			amin(ans, (ll)clib * i + (ll)croad * (n - i));
		printf("%lld\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.168
medium
----------
PROBLEM STATEMENT:
The member states of the UN are planning to send [expression] people to the moon. They want them to be from different countries.  You will be given a list of pairs of astronaut ID's.  Each pair is made of astronauts from the same country.  Determine how many pairs of astronauts from different countries they can choose from.

For example, we have the following data on 2 pairs of astronauts, and 4 astronauts total, numbered [expression].

1   2
2   3


Astronauts by country are [expression].

Function Description  

Complete the journeyToMoon function in the editor below.  It should return an integer that represents the number of valid pairs that can be formed.  

journeyToMoon has the following parameter(s):  


n: an integer that denotes the number of astronauts  
astronaut: a 2D array where each element [expression] element integer array that represents the ID's of two astronauts from the same country  

----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <map>
#include <list>
#include <iterator>
#include <set>
#include <queue>
#include <iostream>
#include <sstream>
#include <stack>
#include <deque>
#include <cmath>
#include <memory.h>
#include <cstdlib>
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <utility> 
using namespace std;
 
#define FOR(i, a, b) for(int i = (a); i < (b); ++i)
#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)
#define REP(i, N) FOR(i, 0, N)
#define RREP(i, N) RFOR(i, N, 0)
 
#define ALL(V) V.begin(), V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair
#define Pi 3.14159265358979

typedef long long Int;
typedef unsigned long long UInt;
typedef vector <int> VI;
typedef pair <int, int> PII;

VI a[1<<17];
bool was[1<<17];

int n,m;

int dfs(int cur)
{
	if (was[cur])
		return 0;
	
	was[cur] = true;
	int res = 1;
	
	REP(i,SZ(a[cur]))
	{
		int nx = a[cur][i];
		
		res += dfs(nx);
	}
	
	return res;
}


int main()
{
//	freopen("in.txt", "r", stdin);
//	freopen("out.txt", "w", stdout);
	
	scanf("%d%d",&n,&m);
	
	REP(i,m)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		
		a[x].push_back(y);
		a[y].push_back(x);
	}
	
	VI all;
	
	REP(i,n)
	{
		if (!was[i])
		{
			all.push_back(dfs(i));
		}
	}
	
	Int res = 0;
	Int sum = 0;
	REP(i, SZ(all))
	{
		res += sum * all[i];
		
		sum += all[i];
	}
	
	cout << res << endl;
	
	return 0;
}

----------
====================
----------
ALGORITHMS.169
medium
----------
PROBLEM STATEMENT:
Bitville is a seaside city that has a number of shopping centers connected by bidirectional roads, each of which has a travel time associated with it.  Each of the shopping centers may have a fishmonger who sells one or more kinds of fish.  Two cats, Big Cat and Little Cat, are at shopping center [expression], and one may arrive at a different time than the other.  The minimum time to determine is when both have arrived at the destination.  

For example, there are [expression].  

   

Function Description  

Complete the shop function in the editor below.  It should return an integer that represents the minimum time required for their shopping.  

shop has the following parameters: 
- n: an integer, the number of shopping centers 
- k: an integer, the number of types of fish 
- centers: an array of strings of space-separated integers where the first integer of each element is the number of types of fish sold at a center and the remainder are the types sold 
- roads: a 2-dimensional array of integers where the first two values are the shopping centers connected by the bi-directional road, and the third is the travel time for that road  
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

#define sd(x) scanf("%d",&x)
#define sd2(x,y) scanf("%d%d",&x,&y)
#define sd3(x,y,z) scanf("%d%d%d",&x,&y,&z)

#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define foreach(it, v) for(__typeof((v).begin()) it=(v).begin(); it != (v).end(); ++it)
#define meta __FUNCTION__,__LINE__

#define _ ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define __ freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);

using namespace std;

template<typename S, typename T> 
ostream& operator<<(ostream& out,pair<S,T> const& p){out<<'('<<p.fi<<", "<<p.se<<')';return out;}

template<typename T>
ostream& operator<<(ostream& out,vector<T> const& v){
int l=v.size();for(int i=0;i<l-1;i++)out<<v[i]<<' ';if(l>0)out<<v[l-1];return out;}

void tr(){cout << endl;}
template<typename S, typename ... Strings>
void tr(S x, const Strings&... rest){cout<<x<<' ';tr(rest...);}

typedef long long ll;
typedef pair<int,int> pii;

const long double PI = 3.1415926535897932384626433832795;

const int N = 1010;
const int M = 11;
const int INF = 1e9;

int n, m, k;

int dis[N][1<<M];
int vis[N][1<<M];
int mask[N];
vector<pii> g[N];

set<pair<int, pii> > q;

void go(){
	dis[1][mask[1]] = 0;
	
	q.insert(mp(dis[1][mask[1]], mp(1, mask[1])));
	
	while(!q.empty()){
		pair<int, pii> top = *q.begin();
		q.erase(q.begin());
		
		int x = top.se.fi;
		int msk = top.se.se;
		
		if(vis[x][msk]) continue;
		vis[x][msk] = 1;
		dis[x][msk] = top.fi;
		
		foreach(it, g[x]){
			int y = it->fi, w = it->se;
			int nmask = msk | mask[y];
			
			if(vis[y][nmask]) continue;
			
			int ndis = dis[x][msk] + w;
			if(ndis < dis[y][nmask]){
				dis[y][nmask] = ndis;
				q.insert(mp(dis[y][nmask], mp(y, nmask)));
			}
		}	
	}
}

int main(){
	sd3(n,m,k);
	
	for(int i = 1; i <= n; i++){
		int ti;
		sd(ti);
		int x;
		while(ti--){
			sd(x); x--;
			mask[i] |= (1 << x);
		}
	}
	
	for(int i = 1; i <= m; i++){
		int u, v, t;
		sd3(u,v,t);
		g[u].pb(mp(v,t));
		g[v].pb(mp(u,t));
	}

	for(int i = 1; i <= n; i++){
		for(int j = 0; j < (1 << k); j++){
			dis[i][j] = INF;
		}
	}

	go();
	
	int ans = INF;
	
	for(int i = 0; i < (1 << k); i++){
		for(int j = 0; j < (1 << k); j++){
			if((i|j) == ((1 << k) - 1)){
				ans = min(ans, max(dis[n][i], dis[n][j]));
			}		
		}
	}
	
	printf("%d\n", ans);
	
	return 0;
}
----------
====================
----------
ALGORITHMS.170
hard
----------
PROBLEM STATEMENT:
You are given an array with [expression].

BIT(x, i) = (x  i) & 1. (where [expression] in binary form.)

If we regard every bit as a vertex of a graph G, there exists one undirected edge between vertex [expression] if there exists at least one k such that BIT(d[k], i) == 1 && BIT(d[k], j) == 1.

For every subset of the input array, how many  connected-components are there in that graph?

The number of connected-components in a graph are the sets of nodes, which are accessible to each other, but not to/from the nodes in any other set.  

For example if a graph has six nodes, labelled [expression] is isolated from everone else.  

You only need to output the sum of the number of connected-component([expression]) in every graph.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <iostream>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

#define REP(i,n) for(int i=0,_n=(n);i<_n;++i)
#define FOR(i,a,b) for(int i=(a),_b=(b);i<=_b;++i)
#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;--i)
#define FOREACH(it,arr) for (__typeof((arr).begin()) it=(arr).begin(); it!=(arr).end(); it++)

typedef unsigned long long ULL;

int n;
ULL d[30];

int p[65], r[65];
vector <int> v[30];

int find(int x) {
	if ( p[x] != x ) p[x] = find(p[x]);
	return p[x];
}
void link(int x, int y) {
	if ( r[x]  < r[y] ) r[x]++;
	if ( r[x] == r[y] ) p[x] = p[y]; else p[y] = p[x];
}


int f(int x) {
	int ret = 0;
	if ( x == n ) {
		bool flag[65] = {false};
		REP(j,64) flag[find(j)] = true;
		REP(j,64) ret += flag[j];
		return ret;
	}
	int tp[65], tr[65];

	memcpy(tp,p,sizeof(p));
	memcpy(tr,r,sizeof(r));

	ret += f(x+1);

	memcpy(p,tp,sizeof(p));
	memcpy(r,tr,sizeof(r));
	
	FOR(j,1,v[x].size()-1)
		link(find(v[x][j]),find(v[x][0]));
	
	ret += f(x+1);
	

	return ret;
}


int main()
{
	cin >> n;
	REP(i,n) cin >> d[i];

	REP(i,n) REP(j,64) if ( (d[i] >> j) & 1 ) v[i].push_back(j);

	REP(j,64) p[j] = j, r[j] = 0;
	cout << f(0) << endl;

	return 0;
}

----------
====================
----------
ALGORITHMS.171
medium
----------
PROBLEM STATEMENT:
Consider an undirected graph where each edge is the same weight.  Each of the nodes is labeled consecutively.

You will be given a number of queries.  For each query, you will be given a list of edges describing an undirected graph.  After you create a representation of the graph, you must determine and report the shortest distance to each of the other nodes from a given starting position using the breadth-first search algorithm (BFS).  Distances are to be reported in node number order, ascending.  If a node is unreachable, print [expression] for that node.  Each of the edges weighs 6 units of distance.

For example, given a graph with [expression], a visual representation is:  

  

The start node for the example is node [expression].  

Function Description  

Complete the bfs function in the editor below.  It must return an array of integers representing distances from the start node to each other node in node ascending order.  If a node is unreachable, its distance is [expression].  

bfs has the following parameter(s):  


n: the integer number of nodes  
m: the integer number of edges  
edges: a 2D array of start and end nodes for edges
s: the node to start traversals from

----------
TOP SOLUTION:
----------
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <queue>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <cctype>
#include <limits>
#include <fstream>

using namespace std;
typedef vector<string> vs;
typedef vector<int> vi;
typedef vector<long long> vll;
typedef vector<vector<int> > vvi;
#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define DEC(i,a,b) for(int i=(a); i>=b; --i)
#define FORV(v,i) for(int i=0;i<v.size();++i)
#define FORD(v,i) for(int i=v.size()-1;i>=0;--i)
#define all(c) (c).begin(),(c).end()
#define sz(c) int((c).size())
#define pb push_back
#define ull unsigned long long
#define ll long long
#define MOD 1000000007ULL


void bfs(vector<set<int> > &V,int &S,stringstream &ss)
{
	vector<bool> A(V.size(),false);
	vi D(V.size(),-1);
	D[S] = 0;
	queue<int> Q;
	Q.push(S);
	//ss<<"size:"<<V[S].size()<<"\n";
	A[S] = true;
	while(!Q.empty())
	{
		int f = Q.front(); Q.pop();
		//ss<<f<<","<<V[f].size()<<":";
		for(set<int>::iterator it = V[f].begin();
			it != V[f].end() ; ++it)
		{
			int p = *it;
			if(!A[p])
			{
				//ss<<p<<",";
				D[p] = D[f] + 1;
				/*
				int v = D[f] + 1;
				if( v < D[p])
					D[p] = D[f] + 1;
				*/
				A[p] = true;
				Q.push(p);
			}
		}
		//ss<<"\n";
	}
	//ss<<"\n";

	//sort(all(D));
	//int C = 0;
	FORV(D,i)
	{
		if(D[i] == -1)
			ss<<-1<<" ";
		else if(D[i] > 0)
			ss<<(D[i]*6)<<" ";
	}
	ss<<"\n";
	//FOR(i,0,C)
	//	ss<<-1<<" ";
}


int main()
{
	int t;
	ios_base::sync_with_stdio(false);
	cin>>t;
	stringstream ss;
	FOR(i,0,t)
	{
		int n,m;
		cin>>n>>m;
		vector<set<int> > V(n,set<int>());
		FOR(j,0,m)
		{
			int a,b;
			cin>>a>>b;
			a--;
			b--;
			V[a].insert(b);
			V[b].insert(a);
		}
		int S;
		cin>>S;
		S--;
		bfs(V,S,ss);
	}
	cout<<ss.str();
	return 0;
}

----------
====================
----------
ALGORITHMS.172
medium
----------
PROBLEM STATEMENT:
Given an undirected weighted connected graph, find the Really Special SubTree in it. The Really Special SubTree is defined as a subgraph consisting of all the nodes in the graph and: 


There is only one exclusive path from a node to every other node. 
The subgraph is of minimum overall weight (sum of all edges) among all such subgraphs.  
No cycles are formed


To create the Really Special SubTree, always pick the edge with smallest weight. Determine if including it will create a cycle.  If so, ignore the edge.  If there are edges of equal weight available:


Choose the edge that minimizes the sum [expression] is the edge weight.
If there is still a collision, choose any of them.


Print the overall weight of the tree formed using the rules.

For example, given the following edges:

[expression]
[expression]
[expression]
[expression]



First choose [expression].  

Function Description  

Complete the [expression] function in the editor below.  It should return an integer that represents the total weight of the subtree formed.  

kruskals has the following parameters:  


g_nodes: an integer that represents the number of nodes in the tree  
g_from: an array of integers that represent beginning edge node numbers  
g_to: an array of integers that represent ending edge node numbers  
g_weight: an array of integers that represent the weights of each edge  

----------
TOP SOLUTION:
----------
//Author : pakhandi
//
using namespace std;

#include<bits/stdc++.h>

#define wl(n) while(n--)
#define fl(i,a,b) for(i=a; i<b; i++)
#define rev(i,a,b) for(i=a; i>=b; i--)
#define scan(n) scanf("%d", &n)
#define scans(s) scanf("%s", s)
#define scanc(c) scanf("%c", &c)
#define scanp(f) scanf("%f", &f)
#define print(n) printf("%d\n", n)
#define prints(s) printf("%s\n", s)
#define printc(c) printf("%c\n", c)
#define printp(f) printf("%f\n", f)
#define nline printf("\n")
#define mclr(strn) strn.clear()
#define ignr cin.ignore()
#define MOD 1000000007
#define ll long long int
#define u64 unsigned long long int

#define PB push_back
#define SZ size
#define MP make_pair

int dist[3005], parent[3005];
bool vis[3005];

std::vector<int> adj[3003];

int mat[3005][3005];

queue<pair<int,int> > pro;

int n, e;

int main()
{
    int i, j;

    int cases;

    //scan(cases);

    //wl(cases)
    {
        cin>>n>>e;
        fl(i,0,n+1)
        {
            adj[i].clear();
            vis[i]=0;
            parent[i]=-1;
            dist[i]=INT_MAX;

        }
        fl(i,0,n+1)
            fl(j,0,n+1)
            {
                mat[i][j]=INT_MAX;
                if(i==j)
                    mat[i][j]=0;
        }
        fl(i,0,e)
        {
            int x, y;
            cin>>x>>y;
            adj[x].PB(y);
            adj[y].PB(x);
            int val;
            cin>>val;
            mat[x][y]=mat[y][x]=min(val,mat[x][y]);
        }
        int ini;
        cin>>ini;
        
        int node=ini;
        dist[node]=0;
        vis[node]=1;

        while(1)
        {
            

            fl(i,0,n-1)
            {
                int this_dist=INT_MAX;
                //Find the node with the minimum distance
                fl(j,1,n+1)
                {   
                    if(!vis[j] && dist[j]<this_dist)
                    {
                        this_dist=dist[j];
                        node=j;
                    }
                }

                //mark this node as visited
                vis[node]=1;
                int limit=adj[node].SZ();

                fl(j,0,limit)
                {
                    if(!vis[adj[node][j]] && mat[node][adj[node][j]]<dist[adj[node][j]])
                    {
                        dist[adj[node][j]]=mat[node][adj[node][j]];
                        parent[adj[node][j]]=node;
                    }
                }
                
            }

            int f=0;

            fl(i,1,n+1)
            {
                if(dist[i]==INT_MAX)
                {
                    node=i;
                    dist[node]=0;
                    vis[node]=1;
                    parent[node]=node;
                    f=1;
                    break;

                }
            }
            if(f==0)
                break;
        }

        ll ans=0;
        fl(i,1,n+1)
        {
            if(i!=ini && dist[i]!=INT_MAX)
                ans+=mat[i][parent[i]];
        }
        cout<<ans;
        nline;



    }

    return 0;
}
----------
====================
----------
ALGORITHMS.173
medium
----------
PROBLEM STATEMENT:
You are given a tree (a simple connected graph with no cycles). 

Find the maximum number of edges you can remove from the tree to get a forest such that each connected component of the forest contains an even number of nodes.

As an example, the following tree with [expression] time to create an even forest.  

  

Function Description  

Complete the evenForest function in the editor below.  It should return an integer as described.  

evenForest has the following parameter(s):  


t_nodes: the number of nodes in the tree  
t_edges: the number of undirected edges in the tree  
t_from: start nodes for each edge  
t_to: end nodes for each edge, (Match by index to t_from.)  

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <iostream>
#include <cmath>
#include <sstream>
#include <vector>
#include <map>
#include <set>
#include <complex>
#include <algorithm>
#include <functional>
#include <fstream>
#include <numeric>
#include <string>
#include <valarray>


using namespace std;

typedef pair<int,int> Pair;

template<class t>
ostream & operator << (ostream & tout,const vector<t> &s){
  tout<<'[';
  for (int i=0;i<s.size();i++)
    if (i+1 == s.size())
      tout<<s[i];
    else
      tout<<s[i]<<',';
  tout<<']';
  return(tout);
}

template<class a,class b>
ostream & operator << (ostream & tout,const pair<a,b> &c){
  return(tout<<'('<<c.first<<','<<c.second<<')');
}

template<class T> struct __set__print{
  __set__print(ostream& out) : tout(out), count(0) {}
  void operator() (T x) { 
    if (count > 0)
      tout<<',';
    tout<<x;
    ++count; 
  }
  ostream& tout;
  int count;
};

template<class T>
ostream & operator << (ostream & tout,const set<T> &s){
  tout<<'{';
  for_each(s.begin(),s.end(),__set__print<T>(tout));
  return(tout<<'}');
}

template<class T,class Q> struct print_map{
  print_map(ostream& out) : tout(out), count(0) {}
  void operator() (const pair<T,Q> &x) { 
    if (count > 0)
      tout<<',';
    tout<<'('<<x.first<<" => "<<x.second<<')';
    ++count; 
  }
  ostream& tout;
  int count;
};

template<class T,class Q>
ostream & operator << (ostream & tout,map<T,Q> s){
  tout<<'{';
  for_each(s.begin(),s.end(),print_map<T,Q>(tout));
  return(tout<<'}');
}

template<class T>
string to_string(T s){
  stringstream tin;
  tin<<s;
  string res;
  getline(tin,res);
  return(res);
}


template<class T>
vector<T> to_vector(T *s,int n){
  vector<T> result;
  for (int i=0;i<n;i++)
    result.push_back(s[i]);
  return(result);
}

// *********************************** MY CODE ***************************

const int MAX_N = 100+20,INF = 1<<25;

int n, m;
vector<int> e[MAX_N];
bool mark[MAX_N];
Pair dyna[MAX_N];


Pair impact(Pair a,Pair b){
  Pair result(-INF,-INF);
  result.first = max(result.first,a.first+b.first+1);
  result.second = max(result.second,a.second+b.first+1);
  result.first = max(result.first,a.second+b.second);
  result.second = max(result.second,a.first+b.second);
  return(result);
}

void dfs(int s){
  mark[s] = true;
  for (int i=0;i<e[s].size();i++)
    if (!mark[e[s][i]]){
      dfs(e[s][i]);
      dyna[s] = impact(dyna[s],dyna[e[s][i]]);
    }
}

int main(){
  ios_base::sync_with_stdio(false) ;
  cin >> n >> m;
  for (int i=1;i<n;i++){
    int x,y;
    cin>>x>>y;
    e[x].push_back(y);
    e[y].push_back(x);
  }

  for (int i=1;i<=n;i++)
    dyna[i] = Pair(-INF,0);

  dfs(1);
  
  cout<<dyna[1].first<<endl;

}

----------
====================
----------
ALGORITHMS.174
medium
----------
PROBLEM STATEMENT:
Markov takes out his Snakes and Ladders game, stares at the board and wonders:   "If I can always roll the die to whatever number I want, what would be the least number of rolls to reach the destination?"   

Rules
The game is played with a cubic die of [expression].


Starting from square [expression], no move is made.
If a player lands at the base of a ladder, the player must climb the ladder.  Ladders go up only.
If a player lands at the mouth of a snake, the player must go down the snake and come out through the tail.  Snakes go down only.


Function Description  

Complete the quickestWayUp function in the editor below.  It should return an integer that represents the minimum number of moves required.  

quickestWayUp has the following parameter(s):  


ladders: a 2D integer array where each [expression] contains the start and end cell numbers of a ladder   
snakes: a 2D integer array where each [expression] contains the start and end cell numbers of a snake  

----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
ALGORITHMS.175
hard
----------
PROBLEM STATEMENT:
Given an undirected graph and a starting node, determine the lengths of the shortest paths from the starting node to all other nodes in the graph.  If a node is unreachable, its distance is -1.  Nodes will be numbered consecutively from [expression], and edges will have varying distances or lengths.

For example, consider the following graph of 5 nodes:

[expression]
[expression]
[expression]
[expression]
[expression]



 
Starting at node [expression].

The distances to all nodes in increasing node order, omitting the starting node, are 5 11 13 -1.

Function Description  

Complete the shortestReach function in the editor below.  It should return an array of integers that represent the shortest distance to each node from the start node in ascending order of node number.  

shortestReach has the following parameter(s):  


n: the number of nodes in the graph  
edges: a 2D array of integers where each [expression] consists of three integers that represent the start and end nodes of an edge, followed by its length  
s: the start node number  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
class node{
    public:
    int val;
    int dis;
    int vis ;
    int add;
   long int edist;
    node *next;
    node(int n, node *ptr, long int edist){
        val = n;
        this->edist = edist; 
        dis = -1;
        vis = 0;
        add = 0;
        next  = ptr;
    }
};

void breadth(node **adj,node *queue,node *last,long int *dist){
     if(queue!=NULL){
           node *temp = adj[queue->val];
           while(temp!=NULL){
               if(dist[temp->val]==-1 || dist[temp->val] > dist[queue->val]+temp->edist){
                   dist[temp->val] = dist[queue->val] + temp->edist;
                   node *ptr = new node(temp->val, NULL, 0);
                   last->next = ptr;
                   last = ptr;
               }
               temp = temp->next;
           }
         queue = queue->next;
    /*     
         cout<<"queue\n";
         temp = queue;
         while(temp !=NULL){
             cout<<temp->val+1<<" ";
             temp = temp->next;
         }
         cout<<endl;
      */   
         breadth(adj,queue,last,dist);
     }
 }



int main() {
  long int t;
    cin>>t;
    while(t--){
        long int n,m;
        cin>>n;
        node *adj[n];
        for(long int i=0;i<n;i++){
            adj[i] = NULL;
        }
        cin>>m;
        for(long int i=0;i<m;i++){
            long int x, y, z;
            cin>>x>>y>>z;
            node *ptr = new node(x-1,adj[y-1],z);
            adj[y-1] = ptr;
           ptr = new node(y-1,adj[x-1],z);
            adj[x-1] = ptr;
        }
        /* cout<<"printing queue"<<endl;
        for(long int i=0;i<n;i++){
            node *ptr = adj[i];
            while(ptr!=NULL){
                cout<<ptr->val+1<<" + " <<ptr->edist<<" ";
                ptr = ptr->next;
            }
            cout<<endl;
        }
        */
        
        long int s;
        cin>>s;
        s = s-1;
       
        
        
        node *queue, *last;
        node *ptr  = new node(s,NULL,0);
        long int dist[n];
        for(long int i=0;i<=n;i++)
            dist[i] = -1;
        dist[s] = 0;
        queue = ptr;
        last = ptr;
        breadth(adj,queue,last, dist);
        for(long int i=0;i<n;i++){
            if(i!=s){
                cout<<dist[i]<<" ";
            }
        }
        cout<<endl;
    }
    
    return 0;
}

----------
====================
----------
ALGORITHMS.176
medium
----------
PROBLEM STATEMENT:
One day Bob drew a tree, [expression] edges on a piece of paper. He soon discovered that parent of a node depends on the root of the tree. The following images shows an example of that:



Learning the fact, Bob invented an exciting new game and decided to play it with Alice. The rules of the game is described below:


Bob picks a random node to be the tree's root and keeps the identity of the chosen node a secret from Alice. Each node has an equal probability of being picked as the root.
Alice then makes a list of [expression] exists in the tree. 
For each correct guess, Alice earns one point. Alice wins the game if she earns at least [expression] of her guesses were true).


Alice and Bob play [expression] for each game, find the probability that Alice will win the game and print it on a new line as a reduced fraction in the format p/q.
----------
TOP SOLUTION:
----------
#include <sstream>
#include <vector>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <string>
#include <cassert>
#include <ctime>
#include <map>
#include <math.h>
#include <cstdio>
#include <set>
#include <deque>
#include <memory.h>
#include <queue>

#pragma comment(linker, "/STACK:64000000")
typedef long long ll;

using namespace std;

const int MAXK = -1;
const int MAXN = 1 << 18;

int n;
vector<int> e[MAXN];
int h[MAXN], p[MAXN];
int cc[MAXN];

void dfs(int v, int pr, int ch) {
	h[v] = ch;
	p[v] = pr;
	for (int to : e[v]) {
		if (to == pr) continue;
		dfs(to, v, ch + 1);
	}
}

void dfs1(int v, int pr, int cur) {
	cc[v] += cur;
	cur = cc[v];
	for (int to : e[v]) {
		if (to == pr) continue;
		dfs1(to, v, cur);
	}
}

int gcd(int a, int b) {
	while (b) {
		a %= b;
		swap(a, b);
	}
	return a;
}

int main() {
#ifdef _MSC_VER
	freopen("input.txt", "r", stdin);
#endif

	int T;
	scanf("%d", &T);
	while (T--) {
		scanf("%d", &n);
		for (int i = 0; i < n; i++) {
			e[i].clear();
			cc[i] = 0;
		}
		for (int i = 0; i < n - 1; i++) {
			int u, v;
			scanf("%d%d", &u, &v);
			--u; --v;
			e[u].push_back(v);
			e[v].push_back(u);
		}
		dfs(0, 0, 0);
		int q, k;
		scanf("%d%d", &q, &k);
		int all = 0;
		for (int i = 0; i < q; i++) {
			int u, v;
			scanf("%d%d", &u, &v);
			--u; --v;
			if (h[v] > h[u]) {
				all++;
				cc[v]--;
			}
			else {
				cc[u]++;
			}
		}
		dfs1(0, 0, 0);
		int cnt = 0;
		for (int i = 0; i < n; i++) cnt += all + cc[i] >= k;
		int g = gcd(cnt, n);
		printf("%d/%d\n", cnt / g, n / g);
	}

	return 0;
}
----------
====================
----------
ALGORITHMS.177
medium
----------
PROBLEM STATEMENT:
Given a graph which consists of several edges connecting its nodes, find a subgraph of the given graph with the following properties:  


The subgraph contains all the nodes present in the original graph.  
The subgraph is of minimum overall weight (sum of all edges) among all such subgraphs.  
It is also required that there is exactly one, exclusive path between any two nodes of the subgraph. 


One specific node [expression] is fixed as the starting point of finding the subgraph using Prim's Algorithm. 
Find the total weight or the sum of all edges in the subgraph.

 
For example, consider a graph with [expression].  

Function Description

Complete the prims function in the editor below.  It should return and integer that represents the minimum weight to connect all nodes in the graph provided.  

prims has the following parameter(s):  


n: an integer that represents the number of nodes in the graph  
edges: a two-dimensional array where each element contains three integers, two nodes numbers that are connected and the weight of that edge  
start: an integer that represents the number of the starting node  

----------
TOP SOLUTION:
----------
//Author : pakhandi
//
using namespace std;

#include<bits/stdc++.h>

#define wl(n) while(n--)
#define fl(i,a,b) for(i=a; i<b; i++)
#define rev(i,a,b) for(i=a; i>=b; i--)
#define scan(n) scanf("%d", &n)
#define scans(s) scanf("%s", s)
#define scanc(c) scanf("%c", &c)
#define scanp(f) scanf("%f", &f)
#define print(n) printf("%d\n", n)
#define prints(s) printf("%s\n", s)
#define printc(c) printf("%c\n", c)
#define printp(f) printf("%f\n", f)
#define nline printf("\n")
#define mclr(strn) strn.clear()
#define ignr cin.ignore()
#define MOD 1000000007
#define ll long long int
#define u64 unsigned long long int

#define PB push_back
#define SZ size
#define MP make_pair

int dist[3005], parent[3005];
bool vis[3005];

std::vector<int> adj[3003];

int mat[3005][3005];

queue<pair<int,int> > pro;

int n, e;

int main()
{
    int i, j;

    int cases;

    //scan(cases);

    //wl(cases)
    {
        cin>>n>>e;
        fl(i,0,n+1)
        {
            adj[i].clear();
            vis[i]=0;
            parent[i]=-1;
            dist[i]=INT_MAX;

        }
        fl(i,0,n+1)
            fl(j,0,n+1)
            {
                mat[i][j]=INT_MAX;
                if(i==j)
                    mat[i][j]=0;
        }
        fl(i,0,e)
        {
            int x, y;
            cin>>x>>y;
            adj[x].PB(y);
            adj[y].PB(x);
            int val;
            cin>>val;
            mat[x][y]=mat[y][x]=min(val,mat[x][y]);
        }
        int ini;
        cin>>ini;
        
        int node=ini;
        dist[node]=0;
        vis[node]=1;

        while(1)
        {
            

            fl(i,0,n-1)
            {
                int this_dist=INT_MAX;
                //Find the node with the minimum distance
                fl(j,1,n+1)
                {   
                    if(!vis[j] && dist[j]<this_dist)
                    {
                        this_dist=dist[j];
                        node=j;
                    }
                }

                //mark this node as visited
                vis[node]=1;
                int limit=adj[node].SZ();

                fl(j,0,limit)
                {
                    if(!vis[adj[node][j]] && mat[node][adj[node][j]]<dist[adj[node][j]])
                    {
                        dist[adj[node][j]]=mat[node][adj[node][j]];
                        parent[adj[node][j]]=node;
                    }
                }
                
            }

            int f=0;

            fl(i,1,n+1)
            {
                if(dist[i]==INT_MAX)
                {
                    node=i;
                    dist[node]=0;
                    vis[node]=1;
                    parent[node]=node;
                    f=1;
                    break;

                }
            }
            if(f==0)
                break;
        }

        ll ans=0;
        fl(i,1,n+1)
        {
            if(i!=ini && dist[i]!=INT_MAX)
                ans+=mat[i][parent[i]];
        }
        cout<<ans;
        nline;



    }

    return 0;
}
----------
====================
----------
ALGORITHMS.178
hard
----------
PROBLEM STATEMENT:
The mayor of Farzville is studying the city's road system to find ways of improving its traffic conditions. Farzville's road system consists of [expression]. In addition, some junctions may not be reachable from others and there may be multiple roads connecting the same pair of junctions.   

Each toll road has a toll rate that's paid each time it's used. This rate varies depending on the direction of travel:  


If traveling from [expression]. 
If traveling from [expression].  




For each digit [expression], print the the number of valid ordered pairs on a new line.

Note: Each toll road can be traversed an unlimited number of times in either direction. 
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }

struct UnionFind {
	vector<int> data;
	void init(int n) { data.assign(n, -1); }
	bool unionSet(int x, int y) {
		x = root(x); y = root(y);
		if (x != y) {
			if (data[y] < data[x]) swap(x, y);
			data[x] += data[y]; data[y] = x;
		}
		return x != y;
	}
	bool findSet(int x, int y) { return root(x) == root(y); }
	int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }
	int size(int x) { return -data[root(x)]; }
};

int main() {
	int n; int m;
	while (~scanf("%d%d", &n, &m)) {
		UnionFind uf;
		uf.init(n * 10);
		for (int i = 0; i < m; ++ i) {
			int u, v, w;
			scanf("%d%d%d", &u, &v, &w), -- u, -- v;
			rep(j, 10)
				uf.unionSet(u * 10 + j, v * 10 + (j + w) % 10);
		}
		vector<array<int,10>> counts(n * 10);
		rep(i, n) rep(j, 10)
			++ counts[uf.root(i * 10 + j)][j];
		rep(d, 10) {
			ll ans = 0;
			rep(a, n * 10) {
				rep(x, 1)
					ans += (ll)counts[a][x] * counts[a][(x + d) % 10];
			}
			rep(i, n)
				ans -= uf.findSet(i * 10, i * 10 + d);
			printf("%lld\n", ans);
		}
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.179
hard
----------
PROBLEM STATEMENT:
You are a real estate broker in ancient Knossos. You have [expression].

Each client can buy at most one house, and each house can have at most one owner. What is the maximum number of houses you can sell?
----------
TOP SOLUTION:
----------
using namespace std;
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <limits.h>
#include <vector>
#include <map>
#include <bitset>
#include <string>
#include <iterator>
#include <set>
#include <utility>
#include <queue>
#include <numeric>
#include <functional>
#include <ctype.h>
#include <stack>
#include <algorithm>
#include <cstdlib>
#define S(x) scanf("%d",&x)
#define S2(x,y) scanf("%d%d",&x,&y)
#define wl(n) while(n--)
#define ll long long
#define bitcnt(x) __builtin_popcount(x)
#define P(x) printf("%d\n",x)
#define PB push_back
#define MP make_pair
#define fl(i,n) for(i=0;i<n;i++)
#define fil(i,a,n) for(i=a;i<n;i++)
#define rev(i,a,n) for(i=n-1;i>=a;i--)
#define mem(a,i) memset(a,i,sizeof(a))
#define F first
#define S1 second
typedef pair<int,int> P;
vector<int> v1[100009];
pair<int,int> p1;
#define MOD 1000000007
#define debug(x)  printf("####%d####\n",x);
#define nl printf("\n");
#define str string
#define N 100000
int a[1234567],b[N],c[N],d[N];
string s;
int dp[1001];
ll pow1(ll x,ll y)
{
    if(y==0)
    return 1;
    ll temp= pow1(x,y/2)%MOD;
    if(y%2==0)
    return (temp*temp)%MOD;
    else
    return (((temp*temp)%MOD)*x)%MOD;
}
// hopcraft_karp algorithm for maximum matching
    
int dist[100009],match[100009],n,m;
bool bfs()
{
   int i,j;
   queue<int> q1;
   for(i=1;i<=n;i++)
   {
       if(match[i]==0)
       {
           dist[i]=0;
           q1.push(i);
       }
       else
           dist[i]=INT_MAX;
   }
   dist[0]=INT_MAX;
   while(!q1.empty())
   {
       int u=q1.front();
       q1.pop();
       if(u!=0) // 0 has no adjacency list
       {
           fl(i,v1[u].size())
           {
               int p=v1[u][i];
               if(dist[match[p]]==INT_MAX) // if match[p] is not dere toh it would be zero by default 
               {
                   dist[match[p]]=dist[u]+1;
                   q1.push(match[p]);
               }
           }
       }
   }
   // this ensures ki ek toh path h he i.e augmenting path because kisi ek ka toh match[i] will be equal to 0
   return dist[0]!=INT_MAX;
}
bool dfs(int u)
{
   if(u==0)
       return true; // base case always true
   int i;
   fl(i,v1[u].size())
   {
       int p=v1[u][i];
       if(dist[match[p]]==dist[u]+1) // to ensure ki jo path bfs se mila tha augumenting ye vahi vaala h
       {
           if(dfs(match[p]))
           {
               match[p]=u; // means we found a path of alternating edges and changing the matched ones to unmatched and vice versa
               match[u]=p;
               return true;
           }
       }
   }
   return false; // else this is not the path
}
int hopcraft_karp()
{
   int ans=0,i;
   while(bfs())
   {
       for(i=1;i<=n;i++)
       {
           if(match[i]==0&&dfs(i))
               ans++;
       }
   }
   return ans;
}
int main()
{
    //std::ios_base::sync_with_stdio(false);
    int t;
    int i,j,k,l;
    S2(n,m);
    fl(i,n)
    S2(a[i],b[i]);

    fl(i,m)
    S2(c[i],d[i]);

    fl(i,n)
    {
        // >=a[i] , <=b[i]

        fl(j,m)
        {
            if(c[j]>=a[i]&&d[j]<=b[i])
            {
                v1[i+1].push_back(j+1+n);
                v1[j+1+n].push_back(i+1);
            }
        }
    }

    P(hopcraft_karp());
    return 0;
}
----------
====================
----------
ALGORITHMS.180
medium
----------
PROBLEM STATEMENT:
A clique in a graph is set of nodes such that there is an edge between any two distinct nodes in the set. Finding the largest clique in a graph is a computationally difficult problem. Currently no polynomial time algorithm  is known for solving this. However, you wonder what is the minimum size of the largest clique in any graph with [expression] edges.  

For example, consider a graph with [expression] members each.  


----------
TOP SOLUTION:
----------
#include<stdio.h>
#include<iostream>
#include<math.h>

using namespace std;

int solve1(int n,int k)
{
int g1 = n%k ;
int g2 = k - g1 ;
int sz1 = n/k + 1 ;
int sz2 = n/k ;
int ret = g1*sz1*g2*sz2 + g1*(g1-1)*sz1*sz1/2 + g2*(g2-1)*sz2*sz2/2 ; //Lifted from Wikipedia diretly. Someone explain this to me, again, clearly?
return ret ;
}
 
int solve(int n,int e)
{
int k,low = 1,high = n + 1 ;
while(low + 1 < high)
{
int mid = low + (high - low)/2 ;
k = solve1(n,mid) ;
if(k < e) low = mid ;
else high = mid ;
}
return high ;
}
 
int main()
{
int i,j,n,k,runs ;
scanf("%d",&runs) ;
while(runs--)
{
scanf("%d%d",&n,&k) ;
int ret = solve(n,k) ;
printf("%d\n",ret) ;
}
return 0 ;
}
----------
====================
----------
ALGORITHMS.181
medium
----------
PROBLEM STATEMENT:
Consider an undirected graph containing [expression], associated with it.

The penalty of a path is the bitwise OR of every edge cost in the path between a pair of nodes, [expression].

Given a graph and two nodes, [expression].

Note: Loops and multiple edges are allowed. The bitwise OR operation is known as or in Pascal and as | in C++ and Java.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

int n, m;
int s, t;
int a[10001];
int b[10001];
int c[10001];


int F[1001];
int f(int x){return x == F[x] ? x : F[x] = f(F[x]);}

bool solve(int result)
{
	for(int i = 1; i <= n; i++)
		F[i] = i;
	for(int i = 1; i <= m; i++)
		if((c[i] | result) == result)
		{
			int fa = f(a[i]), fb = f(b[i]);
			if(fa != fb)
				F[fa] = fb;
		}
	return f(s) == f(t);
}

int MAIN()
{
	cin >> n >> m;
	for(int i = 1; i <= m; i++)
	{
		cin >> a[i] >> b[i] >> c[i];
	}
	cin >> s >> t;
	if(!solve(1023))
		cout << -1 << endl;
	else
	{
		for(int i = 1; i <= 1023; i++)
			if(solve(i))
			{
				cout << i << endl;
				break;
			}
	}
	return 0;
}

int main()
{
	int start = clock();
	#ifdef LOCAL_TEST
		freopen("in.txt", "r", stdin);
		freopen("out.txt", "w", stdout);
	#endif
	ios :: sync_with_stdio(false);
	cout << fixed << setprecision(16);
	int ret = MAIN();
	#ifdef LOCAL_TEST
		cout << "[Finished in " << clock() - start << " ms]" << endl;
	#endif
	return ret;
}

----------
====================
----------
ALGORITHMS.182
hard
----------
PROBLEM STATEMENT:
Killgrave wants to use his mind control powers to get money from the Justice League superheroes living in [expression] dollars stashed away for a rainy day.

As long as a superhero is home at house [expression] by a single road skips town for a couple of days (making it impossible for Killgrave to get money from them). In other words, after Killgrave visits all the superheroes he wants, there will be no road in which he was able to get money from both houses on either end of the road.

What is the maximum amount of money Killgrave can collect from the superheroes, and how many different ways can Killgrave get that amount of money? Two ways are considered to be different if the sets of visited houses are different.

Note: Killgrave can start at an arbitrary house and doesn't have to only use the roads.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <iostream>
#include <set>
#include <vector>
#include <cstring>
#include <string>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <complex>
#include <map>
#include <queue>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vi> vvi;
typedef vector<double> vd;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef vector<pii> vii;
typedef vector<string> vs;

vvi g;
vi deg, used, c;
int ma = -1;
ll cnt = 0;
int sum = 0, c0 = 0;

void rec(int v) {
    if (v >= g.size()) {
        if (sum > ma) {
            ma = sum;
            cnt = 0;
        }
        if (sum == ma) {
            cnt += (1LL << c0);
        }
        return;
    }
    if (!used[v]) {
        sum += c[v];
        bool alone = 1;
        for (int nv : g[v]) {
            if (!used[nv]) {
                alone = false;
            }
            ++used[nv];
        }
        if (alone && c[v] == 0) ++c0;
        rec(v + 1);
        sum -= c[v];
        if (alone && c[v] == 0) --c0;
        for (int nv : g[v]) {
            --used[nv];
        }
        if (!alone) rec(v + 1);
    } else {
        rec(v + 1);    
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    c.resize(n);
    for (int i = 0; i < n; ++i) cin >> c[i];
    g.resize(n);
    deg.assign(n, 0);
    used.assign(n, 0);
    for (int i = 0; i < m; ++i) {
        int a,b;
        cin >> a >> b;
        if (a > b) swap(a, b);
        --a; --b;
        g[a].push_back(b);
        //g[b].push_back(a);
        ++deg[a]; ++deg[b];
    }
    rec(0);
    cout << ma << ' ' << cnt << endl;
    return 0;
}
----------
====================
----------
ALGORITHMS.183
hard
----------
PROBLEM STATEMENT:
You're researching friendships between groups of [expression]. At the beginning of the semester, no student knew any other student; instead, they met and formed individual friendships as the semester went on. The friendships between students are:


Bidirectional. If student [expression].
Transitive. If student [expression]. In other words, two students are considered to be friends even if they are only indirectly linked through a network of mutual (i.e., directly connected) friends. 


The purpose of your research is to find the maximum total value of a group's friendships, denoted by [expression]. 

You are given [expression] among all possible orderings of formed friendships and print it on a new line.
----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;
const int N = 200005;
int f[N] , s[N];

int getf(int x) {
    return x == f[x] ? x : f[x] = getf(f[x]);
}

int main(){
    int t;
    cin >> t;
    for(int a0 = 0; a0 < t; a0++){
        int n;
        int m;
        cin >> n >> m;
        long long res = 0 , sum = n;
        for (int i = 1 ; i <= n ; ++ i) {
            f[i] = i;
            s[i] = 1;
        }
        for(int a1 = 0; a1 < m; a1++){
            int x;
            int y;
            cin >> x >> y;
            x = getf(x) , y = getf(y);
            if (x != y) {
                f[x] = y;
                sum += (long long)2 * s[y] * s[x];
                s[y] += s[x];
            }
        }
        vector<int> V;
        for (int i = 1 ; i <= n ; ++ i) {
            if (getf(i) == i) {
                V.push_back(s[i]);
            }
        }
        sort(V.begin() , V.end());
        reverse(V.begin() , V.end());
        int now = m;
        long long w = n;
        for (int i = 0 ; i < V.size() ; ++ i) {
            int x = V[i];
            for (int k = 1 ; k < x ; ++ k) {
                w += 2 * k;
                -- now;
                res += w;
            }
        }
        res += sum * now;
        res -= (long long)m * n;
        cout << res << endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.184
expert
----------
PROBLEM STATEMENT:
You are given an undirected, connected graph, [expression] prime divisors. 

You must answer [expression].
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<ll> vl;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef vector<pii> vii;

const int MAXN = 50005;
const int MAXM = 50005;
const int LN = 19;

int N, M, K, cur, A[MAXN], LVL[MAXN], DP[LN][MAXN];
int BL[MAXN << 1], ID[MAXN << 1];
short VAL[10000005];
ll ANS[MAXM];
int d[MAXN], l[MAXN], r[MAXN];
bool VIS[MAXN];
vector < int > adjList[MAXN];
vi divs[MAXN];

struct query{
  int id, l, r, lc;
  /*	bool operator < (const query& rhs){
      return (BL[l] == BL[rhs.l]) ? (r < rhs.r) : (BL[l] < BL[rhs.l]);
      }*/
}Q[MAXM];

bool cmp(const query& le, const query& ri) {
  return (BL[le.l] == BL[ri.l]) ? (le.r < ri.r || le.r == ri.r && le.l < ri.l) : (BL[le.l] < BL[ri.l]);
}

// Set up Stuff
void dfs(int u, int par){
  l[u] = ++cur; 
  ID[cur] = u;
  for (int i = 1; i < LN; i++) DP[i][u] = DP[i - 1][DP[i - 1][u]];
  for (int i = 0; i < adjList[u].size(); i++){
    int v = adjList[u][i];
    if (v == par) continue;
    LVL[v] = LVL[u] + 1;
    DP[0][v] = u;
    dfs(v, u);
  }
  r[u] = ++cur; ID[cur] = u;
}

// Function returns lca of (u) and (v)
inline int lca(int u, int v){
  if (LVL[u] > LVL[v]) swap(u, v);
  for (int i = LN - 1; i >= 0; i--)
    if (LVL[v] - (1 << i) >= LVL[u]) v = DP[i][v];
  if (u == v) return u;
  for (int i = LN - 1; i >= 0; i--){
    if (DP[i][u] != DP[i][v]){
      u = DP[i][u];
      v = DP[i][v];
    }
  }
  return DP[0][u];
}

ll res = 0, cntvis = 0;
inline void check(int x){
  if (VIS[x]) {
    --cntvis;
    res -= cntvis;
    for (int t : divs[x]) {
        --VAL[t];
        res += VAL[t];
    }
    for (int t1 = 0; t1 < divs[x].size(); ++t1) for (int t2 = t1 + 1; t2 < divs[x].size(); ++t2) {
        int t = divs[x][t1] * divs[x][t2];
        --VAL[t];
        res -= VAL[t];
    }
    if (divs[x].size() == 3) {
        int t = divs[x][0] * divs[x][1] * divs[x][2];
        --VAL[t];
        res += VAL[t];
    }
  } else {
    res += cntvis;
    ++cntvis;
    for (int t : divs[x]) {
        res -= VAL[t];
        ++VAL[t];
    }
    for (int t1 = 0; t1 < divs[x].size(); ++t1) for (int t2 = t1 + 1; t2 < divs[x].size(); ++t2) {
        int t = divs[x][t1] * divs[x][t2];
        res += VAL[t];
        ++VAL[t];
    }
    if (divs[x].size() == 3) {
        int t = divs[x][0] * divs[x][1] * divs[x][2];
        res -= VAL[t];
        ++VAL[t];
    }
  }
  VIS[x] ^= 1;
}

void compute(int QM){

  // Perform standard Mo's Algorithm
  int curL = Q[0].l, curR = Q[0].l - 1;

  for (int i = 0; i < QM; i++){

    while (curL < Q[i].l) check(ID[curL++]);
    while (curL > Q[i].l) check(ID[--curL]);
    while (curR < Q[i].r) check(ID[++curR]);
    while (curR > Q[i].r) check(ID[curR--]);

    int u = ID[curL], v = ID[curR];

    // Case 2
    if (Q[i].lc != u and Q[i].lc != v) check(Q[i].lc);

    ANS[Q[i].id] = res;

    if (Q[i].lc != u and Q[i].lc != v) check(Q[i].lc);
  }

  //	for (int i = 0; i < M; i++) printf("%lld\n", ANS[i]);
}

int main(){
  vi erat(10000, 1);
  for (int i = 2; i * i < erat.size(); ++i) if (erat[i])
      for (int j = i * i; j < erat.size(); j += i) erat[j] = 0;
  vi primes;
  for (int i = 2; i < erat.size(); ++i) if (erat[i]) primes.push_back(i);
  int u, v, x;

  while (scanf("%d %d", &N, &M) != EOF){

    // Cleanup
    res = 0;
    cur = 0;
    memset(VIS, 0, sizeof(VIS));
    memset(VAL, 0, sizeof(VAL));
    for (int i = 1; i <= N; i++) adjList[i].clear();

    // Inputting Values
    for (int i = 1; i <= N; i++) {
        scanf("%d", &A[i]);
        int x = A[i];
        for (int p : primes) {
            if (p * p > x) break;
            if (x % p == 0) {
                divs[i].push_back(p);
                while (x % p == 0) x /= p;
            }
        }
        if (x > 1) {
            divs[i].push_back(x);
        }
    }

    // Inputting Tree
    for (int i = 1; i < N; i++){
      scanf("%d %d", &u, &v);
      adjList[u].push_back(v);
      adjList[v].push_back(u);
    }

    // Preprocess
    DP[0][1] = 1;
    dfs(1, -1);
    int size = sqrt(cur);

    for (int i = 1; i <= cur; i++) BL[i] = (i - 1) / size + 1;

    for (int i = 0; i < M; i++){
      int u,v;
      scanf("%d %d", &u, &v);
      Q[i].id = i;
      Q[i].lc = lca(u, v);
      if (l[u] > l[v]) swap(u, v);
      if (Q[i].lc == u) Q[i].l = l[u], Q[i].r = l[v];
      else Q[i].l = r[u], Q[i].r = l[v];
    }

    sort(Q, Q + M, cmp);
    compute(M);

    for (int i = 0; i < M; ++i) {
        printf("%lld\n", ANS[i]);
    }
  }
}
----------
====================
----------
ALGORITHMS.185
expert
----------
PROBLEM STATEMENT:
Allison loves graph theory and just started learning about Minimum Spanning Trees(MST). She has three integers, [expression], and uses them to construct a graph with the following properties:


The graph has [expression] undirected edges where each edge has a positive integer length.
No edge may directly connect a node to itself, and each pair of nodes can only be directly connected by at most one edge.
The graph is connected, meaning each node is reachable from any other node.
The value of the minimum spanning tree is [expression]. Value of the MST is the sum of all the lengths of all edges of which are part of the tree.
The sum of the lengths of all edges is as small as possible.


For example, let's say [expression]. The diagram belows shows a way to construct such a graph while keeping the lengths of all edges is as small as possible:



Here the sum of lengths of all edges is [expression].

Given [expression] graphs satisfying the conditions above, find and print the minimum sum of the lengths of all the edges in each graph on a new line.

Note: It is guaranteed that, for all given combinations of [expression], we can construct a valid graph.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <iomanip>
#include <fstream>
#include <algorithm>
#include <map>
#include <set>
#include <vector>
#include <string>

using namespace std;
typedef long long ll;

void run()
{
    ll N, M, S;
    cin >> N >> M >> S;

    ll blen = S - (N - 2);
    ll nedge = ((N - 1) * (N - 2)) / 2;

    ll ans;
    if (M > nedge)
    {
        ll bremain = M - nedge;
        if ((N - 1) * bremain < M)
        {
            ans = nedge + (M - nedge) * blen;
        }
        else
        {
            ll cval = S - (N - 1);
            ans = M + (M * (cval / (N - 1)));
            cval %= N - 1;

            ll lval = cval * bremain;
            ll rval = 1e18;
            if (cval)
            {
                rval = bremain + (cval - 1) * (N - 2) - (cval - 1) * (cval - 2) / 2;
            }
            ans += min (lval, rval);
        }
    }
    else
    {
        ans = (M - 1) + blen;
    }
    cout << ans << "\n";
}

int main()
{
    int ntest; cin >> ntest;
    for (int test = 0; test < ntest; test++)
        run();
}
----------
====================
----------
ALGORITHMS.186
medium
----------
PROBLEM STATEMENT:
Jack has just moved to a new city called Rapture. He wants to use the public public transport system. The fare rules are as follows:  


Each pair of connected stations has a fare assigned to it regardless of direction of travel.  
If a passenger travels from station A to station B, he only has to pay the  difference between the fare from A to B and the cumulative fare that he has paid to reach station A [fare(A,B) - total fare to reach station A].  If the difference is negative, he can travel free of cost from A to B.  


Jack is low on cash and needs your help to figure out the most cost efficient way to go from the first station to the last station. Given the number of stations [expression].  

For example, there are [expression] stations with undirected connections at the costs indicated:  

 
Travel from station [expression].  

Complete the program in the editor below.  It should print the cost of the lowest priced route from station [expression].  If there is no route, print NO PATH EXISTS.  

Function Description 
Complete the getCost function in the editor below.  It should print the cost of the lowest priced route from station [expression], or if there is no route, print NO PATH EXISTS.  There is no expected return value from the function.

getCost has the following parameters:


[expression]: an integer that represents the number of stations in the network  
[expression]: an array of integers that represent end stations of a bidirectional connection  
[expression]  
[expression]: an array of integers that represent the cost of travel between associated stations  

----------
TOP SOLUTION:
----------
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#define fo(i,a,b) dfo(int,i,a,b)
#define fr(i,n) dfr(int,i,n)
#define fe(i,a,b) dfe(int,i,a,b)
#define fq(i,n) dfq(int,i,n)
#define nfo(i,a,b) dfo(,i,a,b)
#define nfr(i,n) dfr(,i,n)
#define nfe(i,a,b) dfe(,i,a,b)
#define nfq(i,n) dfq(,i,n)
#define dfo(d,i,a,b) for (d i = (a); i < (b); i++)
#define dfr(d,i,n) dfo(d,i,0,n)
#define dfe(d,i,a,b) for (d i = (a); i <= (b); i++)
#define dfq(d,i,n) dfe(d,i,1,n)
#define ffo(i,a,b) dffo(int,i,a,b)
#define ffr(i,n) dffr(int,i,n)
#define ffe(i,a,b) dffe(int,i,a,b)
#define ffq(i,n) dffq(int,i,n)
#define nffo(i,a,b) dffo(,i,a,b)
#define nffr(i,n) dffr(,i,n)
#define nffe(i,a,b) dffe(,i,a,b)
#define nffq(i,n) dffq(,i,n)
#define dffo(d,i,a,b) for (d i = (b)-1; i >= (a); i--)
#define dffr(d,i,n) dffo(d,i,0,n)
#define dffe(d,i,a,b) for (d i = (b); i >= (a); i--)
#define dffq(d,i,n) dffe(d,i,1,n)
#define ll long long
#define alok(n,t) ((t*)malloc((n)*sizeof(t)))
#define pf printf
#define sf scanf
#define pln pf("\n")


int *as;
int *bs;
int *cs;
int hcomp(const void *aa, const void *bb) {
	int a = *(int*)aa;
	int b = *(int*)bb;
	if (cs[a] != cs[b]) return (cs[a] > cs[b]) - (cs[a] < cs[b]);
	return a - b;
}
int *p;
int find(int n) {
	if (p[n] < 0) return n;
	int pt = find(p[n]);
	p[n] = pt;
	return pt;
}
int main() {
	int n, e;
	sf("%d%d", &n, &e);
	p = alok(n, int);
	fr(i,n) p[i] = -1;
	as = alok(e, int);
	bs = alok(e, int);
	cs = alok(e, int);
	int *hs = alok(e, int);
	fr(i,e) {
		sf("%d%d%d", as + i, bs + i, cs + i);
		as[i]--;
		bs[i]--;
		hs[i] = i;
	}
	qsort(hs, e, sizeof(int), hcomp);
	int cost = 0;
	for (int i = 0; i < e && find(0) != find(n-1); i++) {
		int a = as[hs[i]];
		int b = bs[hs[i]];
		int c = cs[hs[i]];
		cost = c;
		a = find(a);
		b = find(b);
		if (a != b) {
			if (p[a] == p[b]) p[b]--;
			if (p[a] > p[b]) p[a] = b; else p[b] = a;
		}
	}
	if (find(0) == find(n-1)) {
		pf("%d\n", cost);
	} else {
		pf("NO PATH EXISTS\n");
	}

}

----------
====================
----------
ALGORITHMS.187
medium
----------
PROBLEM STATEMENT:
A crab is an undirected graph which has two kinds of vertices: 1 head, and K feet , and exactly K edges which join the head to each of the feet.(&nbsp;1 

Given an undirected graph, you have to find in it some vertex-disjoint subgraphs where each one is a crab . The goal is to select those crabs in such a way that the total number of vertices covered by them is maximized.

Note: two graphs are vertex-disjoint if they do not have any vertices in common.&nbsp;
----------
TOP SOLUTION:
----------
#include <cstring>
#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
using namespace std;

// the maximum number of vertices
#define NN 300
#define INF 10000000

// adjacency matrix (fill this up)
int cap[NN][NN];

// flow network
int fnet[NN][NN];

// BFS
int q[NN], qf, qb, prv[NN];

int fordFulkerson( int n, int s, int t )
{
    // init the flow network
    memset( fnet, 0, sizeof( fnet ) );

    int flow = 0;

    while( true )
    {
        // find an augmenting path
        memset( prv, -1, sizeof( prv ) );
        qf = qb = 0;
        prv[q[qb++] = s] = -2;
        while( qb > qf && prv[t] == -1 )
            for( int u = q[qf++], v = 0; v < n; v++ )
                if( prv[v] == -1 && fnet[u][v] - fnet[v][u] < cap[u][v] )
                    prv[q[qb++] = v] = u;

        // see if we're done
        if( prv[t] == -1 ) break;

        // get the bottleneck capacity
        int bot = 0x7FFFFFFF;
        for( int v = t, u = prv[v]; u >= 0; v = u, u = prv[v] )
            bot = min(bot, cap[u][v] - fnet[u][v] + fnet[v][u]);

        // update the flow network
        for( int v = t, u = prv[v]; u >= 0; v = u, u = prv[v] )
            fnet[u][v] += bot;

        flow += bot;
    }

    return flow;
}

#define A(x) ((x) * 2 + 2)
#define B(x) ((x) * 2 + 3)
#define source 0
#define target 1

int c, n, m, t, a, b;

int main() {
    for(cin >> c; c--; ) {
        cin >> n >> t >> m;
        //cerr << n << " " << t << " " << m << endl;
        memset(cap, 0, sizeof cap);
        for(int i = 0; i < m; i ++) {
            cin >> a >> b; a--; b--;
            cap[A(a)][B(b)] = INF;
            cap[A(b)][B(a)] = INF;
        }
        for(int i = 0; i < n; i ++) {
            cap[source][A(i)] = t;
            cap[B(i)][target] = 1;
        }
        int result = fordFulkerson(2 * n + 2, source, target);
        cout << result << endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.188
advanced
----------
PROBLEM STATEMENT:
There are [expression] color. You want to make an ornament by joining all the beads together. You create the ornament by using the following algorithm:


Step #[expression] Arrange all the beads in any order such that beads of the same color are placed together.
Step #[expression] The ornament initially consists of only the first bead from the arrangement.
Step #[expression] For each subsequent bead in order, join it to a bead of the same color in the ornament. If there is no bead of the same color, it can be joined to any bead in the ornament.


All beads are distinct, even if they have the same color. How many different ornaments can be formed by following the above algorithm? Two ornaments are considered different if two beads are joined by a thread in one configuration, but not in the other.

Update/clarification

Think of the bead formation as a tree and not as a straight line. Any number of beads can be connected to a bead.
----------
TOP SOLUTION:
----------
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<complex>
#include<vector>
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<string>
#include<cstdlib>
#include<memory.h>
#include<ctime>

using namespace std;


typedef long double ld;

typedef long long ll;
typedef pair<int,int>	pii;
typedef pair<ld,ld>	pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
typedef pair<ll,ll> pl;

#define FOR(i,a,b)		for(int i=(a);i<(b);i++)
#define REP(i,n)		FOR(i,0,n)
#define SORT(v)			sort((v).begin(),(v).end())
#define UN(v)			SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b)			memset(a,b,sizeof a)
#define pb				push_back


const int mod = 1000000007;

int cc[55][55];
bool hasc;

ll c(int n,int m){
	if(m>n || m<0 || n<0) return 0;
	if(!hasc){
		hasc=1;
		REP(i,55){
			cc[i][i]=cc[i][0]=1;
			FOR(j,1,i)
				cc[i][j]=(cc[i-1][j-1]+cc[i-1][j])%mod;
		}
	}
	return cc[n][m];
}

ll tr[33][33][33];

ll tree(int n,int d,int m){
	if(d==1){
		if(n==1 && m==1) return 1;
		return 0;
	}
	if(tr[n][d][m]!=-1)
		return tr[n][d][m];
	ll val = 0;
	FOR(pr,1,n-m+1){
		ll t = tree(n-m,d-1,pr);
		REP(i,m) t*=pr,t%=mod;
		t *= c(n,m);t%=mod;
		val += t;val%=mod;
	}
	return tr[n][d][m] = val;
}
ll qp(ll d,ll st){
	ll r =1;
	while(st){
		if(st&1)r*=d,r%=mod;
		d*=d,d%=mod;
		st>>=1;
	}
	return r;
}
ll nt[33];
bool hasnt;
ll numt(int d){
	if(!hasnt){
		hasnt=true;
		CL(nt,-1);
	}
	if(nt[d]!=-1)return nt[d];
	ll res = 0;
	FOR(l,1,d+1)FOR(nl,1,d+1)
		res+=tree(d,l,nl),res%=mod;
	res*=qp(d,mod-2);res%=mod;
	return nt[d]=res;
}

ll w[333][1<<9];
vi v;
int n;	

ll go(int numv,int mmask){
	if(mmask==0) return 1;
	else{
		if(w[numv][mmask]!=-1) return w[numv][mmask];

		ll res = 0;
		for(int mask=mmask;mask;mask=(mask-1)&mmask){
			int nnv = 0;
			vi nt;
			ll ncc = 1;
			REP(j,n-1) if(mask&(1<<j)){
				nnv += v[j];
				ncc*=numv;ncc%=mod;
				ncc*=v[j];ncc%=mod;
				ncc*=numt(v[j]);ncc%=mod;
			}else nt.pb(v[j]);

			res += ncc * go(nnv,mmask^mask);
			res %= mod;
		}
		return w[numv][mmask]=res;
	}
}

int main(){
#ifdef LocalHost
	freopen("input.txt","r",stdin);
	//freopen("output.txt","w",stdout);
#endif
	CL(tr,-1);
	int tc;
	cin>>tc;
	REP(TC,tc){
		cin>>n;
		v.resize(n);
		REP(i,n)cin>>v[i];
		vi t = v;
		t.erase(t.begin());
		CL(w,-1);
		ll res=numt(v[n-1])*go(v[n-1],(1<<(n-1))-1)%mod;
		cout<<res<<endl;
	}

#ifdef LocalHost
	printf("TIME: %.3lf\n",ld(clock())/CLOCKS_PER_SEC);
#endif
	return 0;
}

----------
====================
----------
ALGORITHMS.189
medium
----------
PROBLEM STATEMENT:
Byteland has [expression] bidirectional roads. It is guaranteed that there is a route from any city to any other city. 

Jeanie is a postal worker who must deliver [expression] letters.

Note: The letters can be delivered in any order.
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

pii dfs1(int i, int p, const vector<vector<pair<int, int> > > &gw, const vector<bool> &mark) {
	pii r = mark[i] ? mp(0, i) : mp(-INF, -1);
	each(j, gw[i]) if(j->first != p) {
		pii u = dfs1(j->first, i, gw, mark);
		if(u.second != -1)
			amax(r, mp(u.first + j->second, u.second));
	}
	return r;
}

int dfs2(int i, int p, const vector<vector<pair<int, int> > > &gw, const vector<bool> &mark) {
	int r = mark[i] ? 0 : -1;
	each(j, gw[i]) if(j->first != p) {
		int t = dfs2(j->first, i, gw, mark);
		if(t != -1) {
			if(r == -1) r = 0;
			r += t + j->second;
		}
	}
	return r;
}

int main() {
	int N; int K;
	while(~scanf("%d%d", &N, &K)) {
		vector<bool> mark(N);
		for(int i = 0; i < K; ++ i) {
			int A;
			scanf("%d", &A), -- A;
			mark[A] = true;
		}
		vector<vector<int> > g(N);
		vector<vector<pair<int, int> > > gw(N);
		for(int i = 0; i < N - 1; ++ i) {
			int u, v, w;
			scanf("%d%d%d", &u, &v, &w), -- u, -- v;
			g[u].push_back(v);
			g[v].push_back(u);
			gw[u].push_back(make_pair(v, w));
			gw[v].push_back(make_pair(u, w));
		}
		int a = find(all(mark), true) - mark.begin();
		int ans = 0;
		ans += dfs2(a, -1, gw, mark) * 2;
		int i = dfs1(a, -1, gw, mark).second;
		ans -= dfs1(i, -1, gw, mark).first;
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.190
hard
----------
PROBLEM STATEMENT:
Given a directed weighted graph where weight indicates distance, for each query, determine the length of the shortest path between nodes.  There may be many queries, so efficiency counts.  

For example, your graph consists of [expression] nodes as in the following:

  

A few queries are from node [expression]. 



There are two paths from [expression]:

[expression]  
[expression] 
In this case we choose path [expression].  
There is no path from [expression].  
There is one path from [expression]:  

[expression].  

----------
TOP SOLUTION:
----------
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
#include<cmath>
#include<stack>
#include<queue>
#include<string>
#include<iostream>
#include<map>
using namespace std;
 
#define sd(a) scanf("%d",&a)
#define pd(a) prlong longf("%lld\n",(a))
#define LL long long
#define F first
#define S second
#define MP make_pair
#define PB push_back
#define INF 100000000
int adj[500][500];
int main()
{
	int n,m,q,x,y,r,i,j,k;
	sd(n);
	sd(m);
	for(i=1;i<=n;++i)
	{
		for(j=1;j<=n;++j)
		{
			adj[i][j]=INF;
		}
		adj[i][i]=0;
	}
	for(i=0;i<m;++i)
	{
		sd(x);
		sd(y);
		sd(r);
		if(x!=y)
			adj[x][y]=r;
	}
	for(k=1;k<=n;++k)
	{
		for(i=1;i<=n;++i)
		{
			for(j=1;j<=n;++j)
			{
				if(adj[i][k]!=INF&&adj[k][j]!=INF)
				{
					adj[i][j]=min(adj[i][j],adj[i][k]+adj[k][j]);

				}
			}
		}
	}
	sd(q);
	while(q--)
	{
		sd(x);
		sd(y);
		if(adj[x][y]==INF)
			printf("%d\n",-1);
		else
			printf("%d\n",adj[x][y]);
	}
}
----------
====================
----------
ALGORITHMS.191
medium
----------
PROBLEM STATEMENT:
John lives in HackerLand, a country with [expression] raised to some exponent). It's possible for John to reach any city from any other city.

Given a map of HackerLand, can you help John determine the sum of the minimum distances between each pair of cities? Print your answer in binary representation. 
----------
TOP SOLUTION:
----------
// {{{ by shik
#include <bits/stdc++.h>
#include <unistd.h>
#define SZ(x) ((int)(x).size())
#define ALL(x) begin(x),end(x)
#define REP(i,n) for ( int i=0; i<int(n); i++ )
#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )
#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )
#define MP make_pair
#define PB push_back
using namespace std;
typedef long long LL;
typedef pair<int,int> PII;
typedef vector<int> VI;

#ifdef SHIK
template<typename T>
void _dump( const char* s, T&& head ) { cerr<<s<<"="<<head<<endl; }

template<typename T, typename... Args>
void _dump( const char* s, T&& head, Args&&... tail ) {
    int c=0;
    while ( *s!=',' || c!=0 ) {
        if ( *s=='(' || *s=='[' || *s=='{' ) c++;
        if ( *s==')' || *s==']' || *s=='}' ) c--;
        cerr<<*s++;
    }
    cerr<<"="<<head<<", ";
    _dump(s+1,tail...);
}

#define dump(...) do { \
    fprintf(stderr, "%s:%d - ", __PRETTY_FUNCTION__, __LINE__); \
    _dump(#__VA_ARGS__, __VA_ARGS__); \
} while (0)

template<typename Iter>
ostream& _out( ostream &s, Iter b, Iter e ) {
    s<<"[";
    for ( auto it=b; it!=e; it++ ) s<<(it==b?"":" ")<<*it;
    s<<"]";
    return s;
}

template<typename A, typename B>
ostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<"("<<p.first<<","<<p.second<<")"; }
template<typename T>
ostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }
template<typename T, size_t N>
ostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }
template<typename T>
ostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }
template<typename A, typename B>
ostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }
#else
#define dump(...)
#endif

template<typename T>
void _R( T &x ) { cin>>x; }
void _R( int &x ) { scanf("%d",&x); }
void _R( long long &x ) { scanf("%" PRId64,&x); }
void _R( double &x ) { scanf("%lf",&x); }
void _R( char &x ) { scanf(" %c",&x); }
void _R( char *x ) { scanf("%s",x); }

void R() {}
template<typename T, typename... U>
void R( T& head, U&... tail ) {
    _R(head);
    R(tail...);
}

template<typename T>
void _W( const T &x ) { cout<<x; }
void _W( const int &x ) { printf("%d",x); }
template<typename T>
void _W( const vector<T> &x ) {
    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {
        if ( i!=x.cbegin() ) putchar(' ');
        _W(*i);
    }
}

void W() {}
template<typename T, typename... U>
void W( const T& head, const U&... tail ) {
    _W(head);
    putchar(sizeof...(tail)?' ':'\n');
    W(tail...);
}

#ifdef SHIK
#define FILEIO(...)
#else
#define FILEIO(name) do {\
    freopen(name ".in","r",stdin); \
    freopen(name ".out","w",stdout); \
} while (0)
#endif

// }}}

const int N=1e5+10;
const int M=2e5+1000;

struct DJS {
    vector<int> fa,sz;
    void init( int n ) {
        n++; // be nice for 1-index usage
        fa.resize(n);
        sz.resize(n);
        for ( int i=0; i<n; i++ ) sz[fa[i]=i]=1;
    }
    int f( int x ) {
        return x==fa[x]?x:fa[x]=f(fa[x]);
    }
    void u( int a, int b ) {
        a=f(a); b=f(b);
        if ( a==b ) return;
        if ( sz[a]>sz[b] ) swap(a,b);
        fa[a]=b;
        sz[b]+=sz[a];
    }
} djs;

struct E {
    int a,b,c;
} e[M];

bool operator <( E a, E b ) {
    return a.c<b.c;
}

int n,m;

int sz[N];
VI es[N];

LL ans[M];
void dfs( int p, int f ) {
    sz[p]=1;
    for ( int i:es[p] ) {
        int to=e[i].a^e[i].b^p;
        if ( to==f ) continue;
        dfs(to,p);
        ans[e[i].c]+=1LL*sz[to]*(n-sz[to]);
        sz[p]+=sz[to];
    }
}

int main() {
    R(n,m);
    REP(i,m) R(e[i].a,e[i].b,e[i].c);
    sort(e,e+m);
    djs.init(n);
    REP(i,m) {
        assert(i==e[i].c);
        int a=djs.f(e[i].a);
        int b=djs.f(e[i].b);
        if ( a==b ) continue;
        es[e[i].a].PB(i);
        es[e[i].b].PB(i);
        djs.u(a,b);
    }
    dfs(1,0);
    REP(i,M-1) {
        ans[i+1]+=ans[i]/2;
        ans[i]%=2;
    }
    int len=M-1;
    while ( len>0 && ans[len]==0 ) len--;
    for ( int i=len; i>=0; i-- ) printf("%lld",ans[i]);
    W("");
    return 0;
}

----------
====================
----------
ALGORITHMS.192
hard
----------
PROBLEM STATEMENT:
It has been a prosperous year for King Charles and he is rapidly expanding his empire. In fact, he recently invaded his neighboring country and set up a new kingdom! This kingdom has many cities connected by one-way roads. To ensure higher connectivity, two cities are sometimes directly linked by more than one road.

In the new kingdom, King Charles has made one of the cities his financial capital and another city his warfare capital. He wants a better connectivity between these two capitals. The connectivity of a pair of cities, [expression]. A path may use a road more than once if possible. Two paths are considered different if they do not use the same sequence of roads the same number of times.

There are [expression].   

Note: Two roads may connect the same cities, but they are still considered distinct for path connections. 

For example, there are [expression] roads as shown in the following graph:

  

There are two direct paths and one cyclic path.  Direct paths are [expression]4 \rightarrow 3$ did not exist, there would be only the two direct paths.

Function Description

Complete the countPaths function in the editor below.  It should print your result, modulo [expression] if there are limited paths or INFINITE PATHS if they are unlimited. There is no expected return value.   

countPaths has the following parameters: 
- n: the integer number of cities 
- edges: a 2D integer array where [expression]   
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include <stdio.h>
#include <algorithm>
#include <string.h>


using namespace std;

const int md = 1e+9;
const int MAXN = 10022;
const int MAXM = 100022;

struct sEdge
{
	int a, b;
};

int n, m;
int ean[MAXN], ebn[MAXN], ea[MAXM], eb[MAXM];
sEdge e[MAXM];

int q[MAXN], fm[MAXN], d[MAXN];

int main()
{
//	freopen("input.txt", "r", stdin);
//	freopen("output.txt", "w", stdout);

	scanf("%d%d", &n, &m);

	int i;
	memset(ean, 0, sizeof(ean));
	memset(ebn, 0, sizeof(ebn));
	for (i = 1; i <= m; i ++)
	{
		scanf("%d%d", &e[i].a, &e[i].b);
		ean[e[i].a] ++;
		ebn[e[i].b] ++;
	}

	ean[n+1] = ebn[n+1] = m;
	for (i = 2; i <= n; i ++)
	{
		ean[i] += ean[i-1];
		ebn[i] += ebn[i-1];
	}

	for (i = 1; i <= m; i ++)
	{
		ea[ean[e[i].a]--] = i;
		eb[ebn[e[i].b]--] = i;
	}

	ean[n+1] = ean[n];  

	int z, x, lql, qh, ql = 0;
	memset(fm, 0, sizeof(fm));
	q[ql++] = 1;     fm[1] = 1;
	for (qh = 0; qh < ql; qh ++)
	{
		z = q[qh];
		for (i = ean[z] + 1; i <= ean[z+1]; i ++)
		{
			x = e[ea[i]].b;
			if (fm[x] == 0)
			{
				q[ql++] = x;
				fm[x] = 1;
			}
		}
	}

	if (fm[n] == 0)
	{
		printf("0\n");
		return 0;
	}

	ql = 0;
	q[ql++] = n;  fm[n] ++;
	for (qh = 0; qh < ql; qh ++)
	{
		z = q[qh];
		for (i = ebn[z] + 1; i <= ebn[z+1]; i ++)
		{
			x = e[eb[i]].a;
			if (fm[x] == 1)
			{
				q[ql++] = x;
				fm[x] += 1;
			}
		}
	}

	
	memset(d, 0, sizeof(d));
	for (i = 1; i <= m; i ++)
		if (fm[e[i].a] + fm[e[i].b] == 4 && e[i].a != n)
			d[e[i].b] ++;

	lql = 0;
	for (i = 1; i <= n; i ++)
		lql += (fm[i] == 2);

    ql = 0;

	for (i = 1; i <= n; i ++)
		if (fm[i] == 2 && d[i] == 0)
			q[ql++] = i;

	for (qh = 0; qh < ql; qh ++)
	{
		z = q[qh];
		for (i = ean[z] + 1; i <= ean[z+1]; i ++)
		{
			x = e[ea[i]].b;
			if ((--d[x]) == 0)
				q[ql++] = x;
		}
	}

	if (ql != lql)  
	{
		printf("INFINITE PATHS\n");
		return 0;
	}

	memset(fm, 0, sizeof(fm));
	fm[1] = 1;
	for (qh = 0; qh < ql; qh ++)
	{
		z = q[qh];
		for (i = ean[z] + 1; i <= ean[z+1]; i ++)
		{
			x = e[ea[i]].b;
			fm[x] = fm[x] + fm[z];
			if (fm[x] >= md)  fm[x] -= md;
		}
	}

	printf("%d\n", fm[n]);


	return 0;
}
----------
====================
----------
ALGORITHMS.193
hard
----------
PROBLEM STATEMENT:
Sophia is playing a game on the computer. There are two random arrays A & B, each having the same number of elements. The game begins with Sophia removing a pair (Ai, Bj) from the array if they are not co-prime. She keeps a count on the number of times this operation is done. 

Sophia wants to find out the maximal number of times(S) she can do this on the arrays. Could you help Sophia find the value?
----------
TOP SOLUTION:
----------
#include <algorithm>
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <cstdio>
#include <string>
#include <vector>
#include <cmath>
#include <map>
#include <set>
#include <ctime>
using namespace std;

#define SIZE(A) ((int)(A).size())
#define PB push_back
#define MP make_pair

const int MAXN = 200005;
const int MAXP = MAXN*13;
const int MAXV = 32000;

double start;

int m, t, res;
int amo[2][MAXP], w[2][MAXP];
int pr[MAXV];
int npr;
int f[MAXV];

int a[MAXN], q[MAXP];
vector<int> spis[MAXN];
pair<int,int> rnk[MAXN];

int col;
int p[MAXN], was[MAXN];
int where[MAXN];
vector<int> ed[2][MAXP];

bool dfs(int u) {
 	if (was[u] == col) return false;
 	was[u] = col;

 	for (int i = 0, v; i < SIZE(spis[rnk[u].second]); i++) {
 		v = spis[rnk[u].second][i];
 		for (int k = 0; k < SIZE(ed[where[u]^1][v]); k++)
		 	if (p[ed[where[u]^1][v][k]]==-1) {
		 	 	p[ed[where[u]^1][v][k]] = u;
		 	 	p[u] = ed[where[u]^1][v][k];
		 	 	return true;
		 	}
 	}

 	for (int i = 0, v; i < SIZE(spis[rnk[u].second]); i++) {
 		v = spis[rnk[u].second][i];
 		for (int k = 0; k < SIZE(ed[where[u]^1][v]); k++)
		 	if (dfs(p[ed[where[u]^1][v][k]])) {
		 	 	p[ed[where[u]^1][v][k]] = u;
		 	 	p[u] = ed[where[u]^1][v][k];
		 	 	return true;
		 	}
 	}

 	return false;
}

void main2(int n) {
	memset(p, -1, sizeof(int)*n);

	reverse(rnk, rnk+n);

	for (int i = 0; i < n; i++) {
		where[i] = rnk[i].second>=m;
		for (int j = 0; j < SIZE(spis[rnk[i].second]); j++)
			ed[where[i]][spis[rnk[i].second][j]].PB(i);
	}

	for (int i = 0; i < n; i++)
		for (int j = 0; j < SIZE(spis[rnk[i].second]) && p[i]==-1; j++) {
		 	int v = spis[rnk[i].second][j];
		 	for (; SIZE(ed[where[i]^1][v]);) {
		 	 	int x = ed[where[i]^1][v].back();
		 	 	ed[where[i]^1][v].pop_back();
		 	 	if (p[x]==-1) {
		 	 	 	p[x] = i;
		 	 	 	p[i] = x;
		 	 	 	res++;
		 	 	 	break;
		 	 	}
		 	}
		}

	if (n <= 10000) {
		for (int i = 0; i < t; i++) ed[0][i].clear(), ed[1][i].clear();
		for (int i = 0; i < n; i++) {
			where[i] = rnk[i].second>=m;
			for (int j = 0; j < SIZE(spis[rnk[i].second]); j++)
				ed[where[i]][spis[rnk[i].second][j]].PB(i);
		}

		for (int i = 0; i < n; i++) {
			if (p[i]!=-1) continue;
	 		col++;
		 	res += dfs(i);

		 	if (clock()-start >= CLOCKS_PER_SEC*2.8) break;
		}
	}

	printf("%d\n", res);
}

int main() {
	#ifdef HOME_JUDGE
		freopen("input", "r", stdin);
		freopen("output", "w", stdout);
	#endif
	start = clock();

	npr = 1; pr[0] = 2;
	for (int i = 3; i < MAXV; i+=2) {
	 	if (!f[i]) pr[npr++] = i, f[i] = npr;
	 	for (int j = 0; j < f[i]; j++)
	 		if (1LL*i*pr[j] >= MAXV) break;
	 		else f[i*pr[j]] = j+1;
	}

	scanf("%d", &m);
	for (int i = 0; i < m+m; i++)
		scanf("%d", a+i);

	for (int i = 0; i < m+m; i++) {
	 	int n=a[i];
	 	for (int j = 0; pr[j]*pr[j] <= n; j++)
	 		if (n%pr[j]==0) {
	 		 	while (n%pr[j]==0) n/=pr[j];
	 		 	q[t++] = pr[j];
	 		 	spis[i].PB(pr[j]);
	 		}
	 	if (n > 1) q[t++] = n, spis[i].PB(n);
	}
	sort(q, q+t); t = unique(q, q+t)-q;

	for (int i = 0; i < m+m; i++)
		for (int j = 0; j < SIZE(spis[i]); j++)
			spis[i][j] = lower_bound(q, q+t, spis[i][j])-q;

	for (int i = 0; i < m+m; i++) {
		int side = i>=m;
		for (int j = 0; j < SIZE(spis[i]); j++) {
		 	amo[side][spis[i][j]]++;
		}
	}

	for (int i = 0; i < m+m; i++) {
		int side = i>=m;
		rnk[i].second = i; rnk[i].first = 0;
		for (int j = 0; j < SIZE(spis[i]); j++) {
			rnk[i].first += amo[side^1][spis[i][j]];
		}
	}
	int sz=m+m;
	sort(rnk, rnk+m+m); reverse(rnk, rnk+m+m);

	while (sz>0 && rnk[sz-1].first==0) sz--;

	if (sz < 50001) {
	 	main2(sz);
	 	return 0;
	}

	for (int i = 0; i < sz; i++) {
	 	bool ok = 0;
	 	int u = rnk[i].second;
	 	int side=u>=m;
	 	for (int j = 0; j < SIZE(spis[u]) && !ok; j++)
	 		ok = w[side^1][spis[u][j]];
	 	if (ok) continue;
	 	for (int j = 0; j < SIZE(spis[u]); j++)
	 		w[side][spis[u][j]] = 1;
	 	res++;
	}

	printf("%d\n", res);

	return 0;
}

----------
====================
----------
ALGORITHMS.194
medium
----------
PROBLEM STATEMENT:
Detective Rust is investigating a homicide and he wants to chase down the murderer. The murderer knows he would definitely get caught if he takes the main roads for fleeing, so he uses the village roads (or side lanes) for running away from the crime scene.

Rust knows that the murderer will take village roads and he wants to chase him down. He is observing the city map, but it doesn't show the village roads (or side lanes) on it and shows only the main roads. 

The map of the city is a graph consisting [expression] iff(if and only if) there is no city road between them.  

In this problem, distance is calculated as number of village roads (side lanes) between any two places in the city.

Rust wants to calculate the shortest distance from his position (Node [expression]) to all the other places in the city if he travels only using the village roads (side lanes).

Note: The graph/map of the city is ensured to be a sparse graph.
----------
TOP SOLUTION:
----------
/*
*/
 
//#pragma comment(linker, "/STACK:16777216")
#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <ctime> 
 
#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
 
#define eps 1e-9
//#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 256
#define right adsgasgadsg
#define free adsgasdg
#define MAG 10000

using namespace std;

set<long> edges[1<<20],active,todel;
queue<long> qu;
long d[1<<20],a,b,n,m,tests;
long S,temp,val;
set<long>::iterator it;
vector<long> ans;

int main(){
//freopen("evacuation.in","r",stdin);
//freopen("evacuation.out","w",stdout);
//freopen("input.txt","r",stdin);
//freopen("output.txt","w",stdout);
ios_base::sync_with_stdio(0);
//cin.tie(0);

cin>>tests;
for (;tests;--tests)
{
 cin>>n>>m;
 for (int i=1;i<=n;i++) 
  edges[i].clear();
 for (int i=1;i<=n;i++)
  active.insert(i);
 for (int i=1;i<=m;i++)
 {
  cin>>a>>b;
  edges[a].insert(b);
  edges[b].insert(a);
 }
 for (int i=1;i<=n;i++)
  d[i]=1e9;
 cin>>S;
 d[S]=0;
 qu.push(S);
 while (qu.size())
 {
  temp=qu.front();
  qu.pop();
  for (it=active.begin();it!=active.end();it++)
  {
   val=(*it);
   if (edges[temp].find(val)!=edges[temp].end())
    continue;
   todel.insert(val);
   qu.push(val);
   d[val]=min(d[val],d[temp]+1);
  }
  for (it=todel.begin();it!=todel.end();it++)
   active.erase(*it);
  todel.clear();
 }
 
 ans.clear();
 for (int i=1;i<=n;i++)
  if (i!=S) 
   ans.push_back(d[i]);
 
 for (int i=0;i<ans.size();i++)
 {
     if (i)cout<<" ";
     cout<<ans[i];
 }
 cout<<endl;
}
cin.get();cin.get();
return 0;}

----------
====================
----------
ALGORITHMS.195
hard
----------
PROBLEM STATEMENT:
There are N problems numbered 1..N which you need to complete. You've arranged the problems in increasing difficulty order, and the ith problem has estimated difficulty level i. You have also assigned a rating vi to each problem. Problems with similar vi values are similar in nature. On each day, you will choose a subset of the problems and solve them. You've decided that each subsequent problem solved on the day should be tougher than the previous problem you solved on that day. Also, to make it less boring, consecutive problems you solve should differ in their vi rating by at least K. What is the least number of days in which you can solve all problems?
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstring>
#include <cmath>
#include <vector>

using namespace std;

int N,K;
int v[310],match[310],inv[310];
vector<int> adj[310];
bool vis[310];

bool augment(int x)
{
	if(vis[x])return false;
	vis[x] = true;
	for(int i = 0; i < adj[x].size(); i++)
	{
		if((inv[adj[x][i]] == -1 || augment(inv[adj[x][i]])))
		{
			match[x] = adj[x][i];
			inv[adj[x][i]] = x;
			return true;
		}
	}
	return false;
}

int main()
{
	int T;
	cin >> T;
	for(int t = 0; t < T; t++)
	{
		cin >> N >> K;
		for(int i = 0; i < N; i++)
		{
			adj[i].clear();
			cin >> v[i];
		}
		for(int i = 0; i < N; i++)
		{
			for(int j = i+1; j < N; j++)
			{
				if(abs(v[i]-v[j]) >= K)
				{
					adj[i].push_back(j);
				}
			}
		}
		memset(match,-1,sizeof(match));
		memset(inv,-1,sizeof(inv));
		int ans = 0;
		for(int i = 0; i < N; i++)
		{
			if(match[i] == -1)
			{
				memset(vis,false,sizeof(vis));
				augment(i);
			}
		}
		for(int i = 0; i < N; i++)
		{
			if(inv[i] == -1)ans++;
		}
		cout << ans << endl;
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.196
hard
----------
PROBLEM STATEMENT:
Fedya is a seasoned traveller and is planning his trip to Treeland. Treeland is a country with an ancient road system which is in the form of a tree structure. [expression].

Fedya has not yet decided the starting point (city) of his journey and the cities he will visit. But there are a few things you know about Fedya's trip:


Fedya is fond of travelling to great distances. So if he is currently located in city [expression].
There might be more than 1 such cities. In that case, Fedya will choose a city that was already visited as less times as possible in this journey.
There still might be more than 1 such cities. In that case, Fedya will go to the city with the smallest number.


Fedya has prepared a list of [expression]. For each of them, he is keen to know the total distance travelled by him.
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

#define ll long long
#define ull unsigned ll

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
int reader(char c[]){int i,s=0;for(;;){mygc(i);if(i!=' '&&i!='\n'&&i!='\r'&&i!='\t'&&i!=EOF) break;}c[s++]=i;for(;;){mygc(i);if(i==' '||i=='\n'||i=='\r'||i=='\t'||i==EOF) break;c[s++]=i;}c[s]='\0';return s;}
template <class T, class S> void reader(T *x, S *y){reader(x);reader(y);}
template <class T, class S, class U> void reader(T *x, S *y, U *z){reader(x);reader(y);reader(z);}
template <class T, class S, class U, class V> void reader(T *x, S *y, U *z, V *w){reader(x);reader(y);reader(z);reader(w);}

void writer(int x, char c){int s=0,m=0;char f[10];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(ll x, char c){int s=0,m=0;char f[20];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}
void writer(const char x[], char c){int i;for(i=0;x[i]!='\0';i++)mypc(x[i]);mypc(c);}
template<class T> void writerLn(T x){writer(x,'\n');}
template<class T, class S> void writerLn(T x, S y){writer(x,' ');writer(y,'\n');}
template<class T, class S, class U> void writerLn(T x, S y, U z){writer(x,' ');writer(y,' ');writer(z,'\n');}
template<class T> void writerArr(T x[], int n){int i;if(!n){mypc('\n');return;}rep(i,n-1)writer(x[i],' ');writer(x[n-1],'\n');}

#define MD 1000000007

void* setUndirectEdge(int N, int M, int A[], int B[], int **es, int ***edge, void *workMemory){int i;*es=(int*)workMemory;*edge=(int**)((*es)+N);(*edge)[0]=(int*)((*edge)+N);rep(i,N)(*es)[i]=0;rep(i,M)(*es)[A[i]]++,(*es)[B[i]]++;REP(i,1,N)(*edge)[i]=(*edge)[i-1]+(*es)[i-1];workMemory=(void*)((*edge)[N-1]+(*es)[N-1]);rep(i,N)(*es)[i]=0;rep(i,M)(*edge)[A[i]][(*es)[A[i]]++]=B[i],(*edge)[B[i]][(*es)[B[i]]++]=A[i];return workMemory;}

int N, M;
int *es, **edge;

int A[110000], B[110000];

int dist[110000];
int dist1[110000], dist2[110000];

void dfs(int now, int d, int bef){
  int i, j, k;
  dist[now] = d;
  rep(i,es[now]){
    k = edge[now][i];
    if(k==bef) continue;
    dfs(k,d+1,now);
  }
}

int main(){
  int i, j, k, V, K;
  int v1, v2, mx;
  ll res, mxd;
  void *mem = malloc(10000000);

  reader(&N, &M);
  rep(i,N-1) reader(A+i,B+i), A[i]--, B[i]--;
  setUndirectEdge(N,N-1,A,B,&es,&edge,mem);

  dfs(0,0,-1);
  mx = 0;
  rep(i,N) if(mx < dist[i]) mx = dist[i], v1 = i;

  dfs(v1,0,-1);
  mx = 0;
  rep(i,N) if(mx < dist[i]) mx = dist[i], v2 = i;
  rep(i,N) dist1[i] = dist[i];

  dfs(v2,0,-1);
  rep(i,N) dist2[i] = dist[i];

  mxd = 0;
  rep(i,N) if(mxd < dist2[i]) mxd = dist2[i];

  while(M--){
    reader(&V,&K); V--;
    res = max(dist1[V], dist2[V]) + (K-1) * mxd;
    writerLn(res);
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.197
hard
----------
PROBLEM STATEMENT:
The kingdom of Zion has cities connected by bidirectional roads.  There is a unique path between any pair of cities. Morpheus has found out that the machines are planning to destroy the whole kingdom.  If two machines can join forces, they will attack.  Neo has to destroy roads connecting cities with machines in order to stop them from joining forces.  There must not be any path connecting two machines.

Each of the roads takes an amount of time to destroy, and only one can be worked on at a time.  Given a list of edges and times, determine the minimum time to stop the attack.

For example, there are [expression].  

  

Function Description

Complete the function minTime in the editor below.  It must return an integer representing the minimum time to cut off access between the machines.

minTime has the following parameter(s):


roads: a two-dimensional array of integers, each [expression] to destroy  
machines: an array of integers representing cities with machines  

----------
TOP SOLUTION:
----------
#include<iostream>
#include<vector>
#include<cstring>
#include<cstdio>
#include<list>
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<fstream>
#include<sstream>
#include<algorithm>
#include<numeric>
#include<cmath>
#include<climits>
#include<ctime>
using namespace std;
#define rp(i,a,b) for(int i = (a); i < (b); i++)
#define rrp(i,a,b)for(int i = (b); i >= (a); i--)
#define ri(it,x) for(typeof(x.begin()) it=x.begin();it!=x.end();++it)
#define pb push_back
#define all(x) (x).begin(),(x).end()
#define cl(x,with) memset(x,with,sizeof(x))
#define sz(v) (v).size()
#define ll long long int
#define ii pair<int,int>
#define mp make_pair
#define vi vector<int>
#define vs vector<string>

#define MAX 600000

int parent[MAX];
int cnt[MAX];
int mark[MAX];
int fp(int v){
	while(parent[v] != v)
		v = parent[v];
	return v;
}
bool unite(int x, int y){
	int p1 = fp(x);
	int p2 = fp(y);
	if(p1 != p2 && !(mark[p1] == 1 && mark[p2] == 1)){
	
		if(cnt[p1] > cnt[p2]){
			parent[p2] = p1;
			cnt[p1] += cnt[p2];
			if(mark[p1] == 1 || mark[p2] == 1)
				mark[p1] = 1;
		}
		else{
			parent[p1] = p2;
			cnt[p2] += cnt[p1];
			if(mark[p1] == 1 || mark[p2] == 1)
				mark[p2] = 1;
		}
		return 1;
	}
	return 0;
}


int main(){
	
	int n, m, k;
	cin >> n >> k; m = n-1;
	vector< pair<int, pair<int,int> > >edge;
	int wt = 0;
	rp(i,0,n-1){
		int x,y,z;
		cin >> x >> y >> z;
		wt += z;
		edge.pb(mp(z,mp(x,y)));
	}	
	sort(all(edge));
	reverse(all(edge));
	
	int tmp;
	rp(i,0,n){
		mark[i] = 0;
		parent[i] = i;
	}
	rp(i,0,k){
		cin >> tmp;
		mark[tmp] = 1;
	}
	rp(i,0,n-1){
		int x,y,z;
		x = edge[i].second.first;
		y = edge[i].second.second;
		z = edge[i].first;
		bool res = unite(x,y);
		wt -= res*z;
	}
	cout << wt << "\n";
	return 0;
}


----------
====================
----------
ALGORITHMS.198
hard
----------
PROBLEM STATEMENT:
Dave is a die-hard fan of a show called "HackerRank", in which a young programmer uses her problem-solving abilities to solve crimes. He splurged on a Digital Video Recorder (DVR) so that he can record HackerRank episodes and watch them later. Luckily, Dave managed to get his hands on schedules for all the episodes in each upcoming season.

Each season has [expression] is its end time. All times are given as integers representing the number of minutes passed since the start of the season.

Episodes broadcast on multiple channels, so some of the air times overlap and the episodes may not broadcast sequentially. It's possible that both the live and repeat broadcasts of some episode [expression]. In addition, live and repeat broadcasts of the same episode may differ in length due to the number of advertisements during the broadcast. 

Dave only has one TV with a DVR attached to it, and the DVR is capable of recording one episode at a time. For each episode in a season, Dave first decides whether or not he will record it. If he decides to record it, he will either record it during [expression]. Dave will only ever record one of the two airings of an episode, and he always records full episodes. This means that once he starts recording an episode, he will always record it until the end (i.e., he never records partial episodes). 

Dave realizes that it might not be possible for him to record all episodes successfully, so instead of focusing on recording all episodes of HackerRank (which may be impossible), he decides to record all consecutively airing episodes whose episode number occurs in some inclusive [expression] (i.e., the number of consecutive episodes recorded) is as large as possible.   

Given the programming schedule for each season, find [expression] value.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define PII pair<int,int>
#define VI vector<int>
#define VPII vector<pair<int,int> >
#define PLL pair<long long,long long>
#define VPLL vector<pair<long long,long long> >
#define F first
#define S second
typedef long long LL;
using namespace std;
const int MOD = 1e9+7;
const int SIZE = 1e6+10;
struct SCC{
    int n,used[SIZE],order[SIZE],gg[SIZE];
    vector<int>e[SIZE],ae[SIZE],ge[SIZE],emp;
    int id,gn;
    void init(int _n){
        n=_n;
        memset(used,0,sizeof(int)*n);
        REP(i,n){
            e[i]=ae[i]=ge[i]=emp;
        }
    }
    void add_edge(int x,int y){
        e[x].PB(y^1);
        ae[y^1].PB(x);
        e[y].PB(x^1);
        ae[x^1].PB(y);
    }
    void dfs1(int x){
        if(used[x]==1)return;
        used[x]=1;
        REP(i,SZ(e[x])){
            int y=e[x][i];
            dfs1(y);
        }
        order[--id]=x;
    }
    void dfs2(int x){
        if(used[x]==2)return;
        gg[x]=gn;
        used[x]=2;
        REP(i,SZ(ae[x])){
            int y=ae[x][i];
            if(used[y]!=2)dfs2(y);
        }
    }
    bool good(){
        gn=0;
        id=n;
        REP(i,n)
            dfs1(i);
        REP(i,n){
            if(used[order[i]]!=2){
                dfs2(order[i]);
                gn++;
            }
        }
        REP(i,n){
            if(gg[i]==gg[i^1])return 0;
            i++;
        }
        return 1;
    }
}scc;
int input[100][2][2];
bool XX(int x1,int y1,int x2,int y2){
    return !((y1<x2)||(y2<x1));
}
int main(){
    CASET{
        DRI(n);
        REP(i,n)REP(j,4)RI(input[i][j>>1][j&1]);
        int rr=1;
        int an1=1,an2=0;
        REP(i,n){
            if(i+an1>=n)break;
            while(rr<n){
                scc.init((rr-i)*2+2);
                REPP(k2,i,rr+1)
                    REPP(k1,i,k2){
                        REP(j1,2)REP(j2,2){
                            if(XX(input[k1][j1][0],input[k1][j1][1],input[k2][j2][0],input[k2][j2][1])){
                                scc.add_edge((k1-i)*2+j1,(k2-i)*2+j2);
                            }
                        }
                    }
                if(!scc.good())break;
                else rr++;
            }
            if(rr-i>an1){an1=rr-i;an2=i;}
        }
        an2++;
        printf("%d %d\n",an2,an2+an1-1);
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.199
hard
----------
PROBLEM STATEMENT:
The country of Byteland contains [expression] bidirectional roads. There is a path between any two cities. The roads in Byteland were built long ago, and now they are in need of repair. You have been hired to fix all the roads. You intend to do this by dispatching robots on some of the roads. Each robot will repair the road he is currently on and then moves to one of the adjacent unrepaired roads. After repairing that, it will move to another adjacent unrepaired road, repair that and so on.

Two roads are adjacent if they have the same city at one of their endpoints. For the process to be efficient, no two robots will ever repair the same road, and no road can be visited twice. What is the minimum number of robots needed to accomplish the task?
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>

using namespace std;

#define MAXN 10000

int memo[MAXN][3];
vector<int> E[MAXN];

int solve(int x, int froot, int p) {
  int& ref = memo[x][froot];
  if(ref != -1) return ref;
  
  ref = froot == 1 ? 0 : 1;

  int children = 0;
  vector<int> C;
  for(int i = 0; i < E[x].size(); i++) {
    int v = E[x][i];
    if(v == p) continue;

    int res = solve(v, 0, x);
    ref += res;
    C.push_back(solve(v, 1, x) - res);
    children++;
  }
  sort(C.begin(), C.end());


  int r1 = ref;
  int charge = (froot == 1 ? 1 : 2);
  for(int i = 0; i < C.size(); i++) {
    r1 += C[i];
    if(i == charge) {
      r1++;
      charge += 2;
    }
    ref = min(ref, r1);
  }
  if(children == 0 && froot != 2) {
    ref = 0;
  }

//cout << x << ", " << froot << ", " << ref  << " (" << C.size() << ")" << endl;
  if(froot == 0) {
    int r2 = 0;
    for(int i = 0; i < E[x].size(); i++) {
      int v = E[x][i];
      if(v == p) continue;
      r2 += solve(v, 2, x);
    }
    ref = min(ref, r2);
  }

  return ref;
}

int main() {
  int T; cin >> T;
  for(int t = 1; t <= T; t++) {
    int N; cin >> N;

    for(int i = 0; i < N; i++) E[i].clear();
    for(int i = 1; i < N; i++) {
      int u, v; cin >> u >> v;
      E[u].push_back(v);
      E[v].push_back(u);
    }

    memset(memo, -1, sizeof(memo));
    cout << solve(0, false, -1) << endl;
  }
}
----------
====================
----------
ALGORITHMS.200
hard
----------
PROBLEM STATEMENT:
A tree of [expression] from 
[expression]. 

Similarly, if [expression]. 

Susan likes to play with graphs and Tree data structure is one of her favorites. She has designed a problem and wants to know if anyone can solve it. Sometimes she adds or removes a leaf node. Your task is to figure out the [expression]th parent of a node at any instant.
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <map>
#include <list>
#include <iterator>
#include <set>
#include <queue>
#include <iostream>
#include <sstream>
#include <stack>
#include <deque>
#include <cmath>
#include <memory.h>
#include <cstdlib>
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <utility> 
using namespace std;
 
#define FOR(i, a, b) for(int i = (a); i < (b); ++i)
#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)
#define REP(i, N) FOR(i, 0, N)
#define RREP(i, N) RFOR(i, N, 0)
 
#define ALL(V) V.begin(), V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair
#define Pi 3.14159265358979

typedef long long Int;
typedef unsigned long long UInt;
typedef vector <int> VI;
typedef pair <int, int> PII;

VI a[1<<17];
int n, root;
int dist[1<<17];
int p[1<<17][17];

int st[1<<17];
int deep;

void dfs(int cur)
{
	dist[cur] = deep;
	st[deep++] = cur;
	
	for (int i = 1, lev = 0; i < deep; i<<=1, ++lev)
	{
		p[cur][lev] = st[deep - i];
	}
	
	REP(i,SZ(a[cur]))
	{
		int nx = a[cur][i];
		
		if (nx == p[cur][0])
			continue;
		
		dfs(nx);
	}
	
	--deep;
}

int get(int cur,int len)
{
	if (cur <= 0 || cur > 100000 || dist[cur] <= 0)
		return -1;
	
	int need = dist[cur] - len;
	
	if (need < 0)
		return -1;
	
	if (need == 0)
		return root;
	
	int go = 0;
	int step = 0;
	
	while (dist[cur] != need)
	{
		if (++step > 10000)
			throw -1;
		
		int* pp = p[cur];
		int nx = pp[go];
		
		while (go < 16 && dist[nx] > need)
		{
			++go;
			nx = pp[go];
		}
		
		while (nx <= 0 || dist[nx] < need)
		{
			--go;
			nx = pp[go];
		}
		
		cur = pp[go];
	}
	
	return cur;
}

void add(int par, int cur)
{
	if (par == 0)
	{
		dist[cur] = 0;
		memset(p[cur], 0, sizeof(p[cur]));
		return;
	}
	
	dist[cur] = dist[par] + 1;
	
	REP(i,17)
	{
		p[cur][i] = get(par, (1<<i)-1);
	}
}

void del(int cur)
{
	dist[cur] = -1;
}

int main()
{
//	freopen("in.txt", "r", stdin);
//	freopen("out.txt", "w", stdout);
	
	int T;
	cin>>T;
	REP(tests,T)
	{
		memset(dist, -1, sizeof(dist));
		if (tests > 0)
			memset(p,0,sizeof(p));
		
		REP(i,(1<<17))
			a[i].clear();
		
		scanf("%d", &n);
		
		REP(i,n)
		{
			int x,y;
			scanf("%d%d", &x,&y);
			
			if (y == 0)
			{
				root = x;
				continue;
			}
			
			a[y].push_back(x);
		}
		
		dfs(root);
		
		int q;
		
		scanf("%d",&q);
		
		REP(i,q)
		{
			int c, x,y;
			scanf("%d", &c);
			
			switch (c)
			{
			case 0:
				scanf("%d%d",&x,&y);
				add(x, y);
				break;
			case 1:
				scanf("%d",&x);
				del(x);
				break;
			case 2:
				scanf("%d%d",&x,&y);
				int res = get(x,y);
				
				if (res == -1)
					res = 0;
				printf("%d\n", res);
				break;
			}
		}
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.201
hard
----------
PROBLEM STATEMENT:
The country of Byteland contains N cities and N - 1 bidirectional roads between them such that there is a path between any two cities. The cities are numbered (0,...,N - 1). The people were very unhappy about the time it took to commute, especially salesmen who had to go about every city selling goods. So it was decided that new roads would be built between any two "somewhat near" cities. Any two cities in Bytleland that can be reached by traveling on exactly two old roads are known as "somewhat near" each other.

Now a salesman situated in city 0, just like any other typical salesman, has to visit all cities exactly once and return back to city 0 in the end. In how many ways can he do this?
----------
TOP SOLUTION:
----------
#include<iostream>
#include<vector>
#include<stdio.h>
#include<set>
#include<string.h>
#include<stdlib.h>
using namespace std ;
#define INF (int)1e9
#define MOD 1000000007
#define MAXN 10002
vector<int> G[MAXN] ;
int n ;

void form_graph(int prufer[])
{
 int i,j,k,degree[MAXN] ;
 for(i=0;i<n;i++) degree[i] = 1 ;
 for(i=0;i<n-2;i++) degree[prufer[i]]++ ;
 for(i=0;i<MAXN;i++) G[i].clear() ;
 for(i=0;i<n-2;i++)
 {
  for(j=0;degree[j] != 1;j++) ;
  G[j].push_back(prufer[i]) ;
  G[prufer[i]].push_back(j) ;
  degree[j] -- ;
  degree[prufer[i]] -- ;
 }
 for(i=0;degree[i] != 1;i++) ;
 for(j=i+1;degree[j] != 1;j++) ;
 G[i].push_back(j) ;
 G[j].push_back(i) ;
}

void generate(int N)
{
 int prufer[MAXN] ;
 n = N ;
 for(int i = 0;i < n - 2;i++) prufer[i] = rand() % n ;
 form_graph(prufer) ;
}

int perm[MAXN] ;
void generateCaterpiller(int N,int path)
{
 n = N ;
 for(int i = 0;i < MAXN;i++) G[i].clear() ;
 for(int i = 0;i < n;i++) perm[i] = i ;
 for(int i = 0;i < n;i++)
 {
  int j = i + rand() % (n - i) ;
  swap(perm[i],perm[j]) ;
 }
 if(path > n) path = n ;
 for(int i = 0;i + 1 < path;i++)
 {
  G[perm[i]].push_back(perm[i + 1]) ;
  G[perm[i + 1]].push_back(perm[i]) ;
 }
 for(int i = path;i < n;i++)
 {
  int k = rand() % path ;
  G[perm[k]].push_back(perm[i]) ;
  G[perm[i]].push_back(perm[k]) ;
 }
}

void generateAlmostCaterpiller(int N,int path,int dangle)
{
 n = N ;
 for(int i = 0;i < MAXN;i++) G[i].clear() ;
 for(int i = 0;i < n;i++) perm[i] = i ;
 for(int i = 0;i < n;i++)
 {
  int j = i + rand() % (n - i) ;
  swap(perm[i],perm[j]) ;
 }
 if(path > n) path = n ;
 for(int i = 0;i + 1 < path;i++)
 {
  G[perm[i]].push_back(perm[i + 1]) ;
  G[perm[i + 1]].push_back(perm[i]) ;
 }
 for(int i = path;i + dangle < n;i++)
 {
  int k = rand() % path ;
  G[perm[k]].push_back(perm[i]) ;
  G[perm[i]].push_back(perm[k]) ;
 }
 for(int i = n - dangle;i < n;i++)
 {
  int k = rand() % i ;
  G[perm[k]].push_back(perm[i]) ;
  G[perm[i]].push_back(perm[k]) ;
 }
}


int dist[22][22] ;
int memo[15][1 << 15] ;
int brute(int k,int mask)
{
 if(mask == 0) return dist[k][0] <= 2 ? 1 : 0 ;
 if(memo[k][mask] != -1) return memo[k][mask] ;
 int ret = 0 ;
 for(int i = 0;i < n;i++) if(mask & 1 << i)
  if(dist[k][i] <= 2)
  {
   int cret = brute(i,mask ^ 1 << i) ;
   ret += cret ;
   if(ret >= MOD) ret -= MOD ;
  }
 return memo[k][mask] = ret ;
}

int brute()
{
 for(int i = 0;i < n;i++)
  for(int j = 0;j < n;j++)
   dist[i][j] = i == j ? 0 : INF ;
 for(int i = 0;i < n;i++)
  for(int j = 0;j < G[i].size();j++)
   dist[i][G[i][j]] = dist[G[i][j]][i] = 1 ;
 for(int k = 0;k < n;k++)
  for(int i = 0;i < n;i++)
   for(int j = 0;j < n;j++)
    dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]) ;
 memset(memo,255,sizeof memo) ;
 int ret = brute(0,(1 << n) - 2) ;
 return ret ;
}

char isLeaf[MAXN] ;
int fac[MAXN] ;
int solve()
{
 int ret = 1,path = n ;
 for(int i = 0;i < n;i++) path -= isLeaf[i] = G[i].size() == 1 ;
 for(int i = 0;i < n;i++) if(!isLeaf[i])
 {
  int ct = 0,ct2 = 0 ;
  for(int j = 0;j < G[i].size();j++)
   if(!isLeaf[G[i][j]])
    ct++ ;
   else ct2++ ;
  if(ct > 2) return 0 ;
  ret = 1LL * ret * fac[ct2] % MOD ;
 }
 return path == 1 ? ret : 2 * ret % MOD ;
}

void test()
{
 for(int t = 1;t <= 10000;t++)
 {
  generate(15) ;
//  cout << "Case: " << t << endl ;
  int ret1 = brute() ;
  int ret2 = solve() ;
  cout << ret1 << " " << ret2 << endl ;
  if(ret1 != ret2)
  {
   cout << "failed on case: " << t << endl ;
   cout << ret1 << " " << ret2 << endl ;
   cout << n << endl ;
   char vis[102][102] ;
   memset(vis,0,sizeof vis) ;
   for(int i = 0;i < n;i++)
    for(int j = 0;j < G[i].size();j++) if(!vis[i][G[i][j]])
    {
     cout << i << " " << G[i][j] << endl ;
     vis[i][G[i][j]] = vis[G[i][j]][i] = true ;
    }
   while(1) ;
  }
 }
 cout << "Done" << endl ;
}

typedef pair<int,int> P ;
void testGen()
{
 char in[10] = "in .txt" ;
 for(int test = 0;test < 10;test++)
 {
  in[2] = test + '0' ;
  FILE * fout = fopen(in,"w") ;
  
  int runs = 20 ;
  fprintf(fout,"%d\n",runs) ;
  for(int t = 0;t < runs;t++)
  {
   int N ;
   if(test < 3) generate(10) ;
   else if(test < 7)
   {
    N = rand() % 9999 + 2 ;
    if(t < 10) generateCaterpiller(N,rand() % 10 + 1) ;
    else generateCaterpiller(N,rand() % (2 * N / 3) + 1) ;
   }
   else if(test < 9)
   {
    N = rand() % 9999 + 2 ;
    if(rand() % 2) generateAlmostCaterpiller(N,rand() % N + 1,5) ;
    else generateCaterpiller(N,rand() % (2 * N / 3) + 1) ;
   }
   else generate(rand() % 1000 + 2) ;
   
   fprintf(fout,"%d\n",n) ;
   set<pair<int,int> > vis ;
   for(int i = 0;i < n;i++)
    for(int j = 0;j < G[i].size();j++)
    {
     P cur = P(i,G[i][j]) ;
     if(vis.find(cur) == vis.end())
     {
      fprintf(fout,"%d %d\n",i,G[i][j]) ;
      vis.insert(cur) ;
      swap(cur.first,cur.second) ;
      vis.insert(cur) ;
     }
    }
  }
 }
}

void genMakefile()
{
 for(int test = 0;test < 100;test++)
 {
  printf("./a.out < in%d%d.txt > out%d%d.txt\n",test / 10,test % 10,test / 10,test % 10) ;
 }
}


int par[MAXN] ;
int fn(int k) { return k == par[k] ? k : par[k] = fn(par[k]) ; }

int main()
{
 fac[0] = 1 ;
 for(int i = 1;i < MAXN;i++) fac[i] = 1LL * i * fac[i - 1] % MOD ;
// genMakefile() ; return 0 ;
// testGen() ; return 0 ;
// test() ; return 0 ;

 int runs ;
 scanf("%d",&runs) ;
 while(runs--)
 {
  scanf("%d",&n) ;
  for(int i = 0;i < MAXN;i++) G[i].clear() ;
  for(int i = 0;i < n;i++) par[i] = i ;
  for(int i = 1;i < n;i++)
  {
   int a,b ;
   scanf("%d%d",&a,&b) ;
   if(a < 0 || a >= n || b < 0 || b >= n || fn(a) == fn(b)) { cout << "Bad input" << endl ; return 1 ; }
   par[fn(a)] = fn(b) ;   
   G[a].push_back(b) ;
   G[b].push_back(a) ;
  }
  int ret = solve() ;
  printf("%d\n",ret) ;
 }
 return 0 ;
}

----------
====================
----------
ALGORITHMS.202
hard
----------
PROBLEM STATEMENT:
You are given a table, [expression].

A path in the table is a sequence of cells [expression] share a side. 

The weight of the path [expression].

You must answer [expression]. You must find and print the minimum possible weight of a path connecting them.

Note: A cell can share sides with at most [expression].
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

int N, M;
vector<vector<int64_t>> G;
const int64_t INF = 1e11;

vector<vector<int64_t>> dijk(int r, int c, int L, int R) {
	set<pair<int64_t, pair<int, int>>> Q;
	vector<vector<int64_t>> D(N, vector<int64_t>(R-L+1, INF));
	Q.insert(make_pair(0, make_pair(r,c)));
	vector<vector<int>> dirs = {{1,0},{0,1},{-1,0},{0,-1}};
	while (!Q.empty()) {
		auto curr = *Q.begin();
		Q.erase(Q.begin());
		int64_t d = curr.first;
		int r = curr.second.first, c = curr.second.second;
		if (d > D[r][c-L]) {
			continue;
		}
		// cout << r << " " << c << endl;
		D[r][c-L] = d;
		for (auto dir : dirs) {
			int cr = r+dir[0];
			int cc = c+dir[1];
			if (cr < 0 || cc < L || cr >= N || cc > R)
				continue;
			int64_t cd = d + G[cr][cc];
			if (cd < D[cr][cc-L]) {
				Q.insert(make_pair(cd, make_pair(cr, cc)));
				D[cr][cc-L] = cd;
			}
		}
	}
	return D;
}

vector<vector<int>> Qs;
vector<int64_t> ans;

vector<unordered_map<int, pair<int, vector<vector<int64_t>>>>> SPs(7);

void div_and_conq(int l, int r, vector<int> Qis) {
	if (l > r)
		return;
	int mid = (r+l)/2;
	// cout << l << " " << r << " " << mid << endl;
	for (int i = 0; i < N; ++i) {
		SPs[i][mid] = make_pair(l, dijk(i, mid, l, r));
		// cout << i << endl;
		// for (auto& v : SPs[i][mid].second) {
		// 	for (int d : v) {
		// 		cout << d << " ";
		// 	}
		// 	cout << endl;
		// }
	}
	vector<int> Qls, Qrs;
	for (int i : Qis) {
		// cout << ": ";
		// for (int q : Qs[i]) {
		// 	cout << q << " ";
		// }
		if (Qs[i][1] < mid && Qs[i][3] < mid) {
			Qls.push_back(i);
		} else if (Qs[i][1] > mid && Qs[i][3] > mid) {
			Qrs.push_back(i);
		} else {
			// cout << " *";
			for (int j = 0; j < N; ++j) {
				for (auto& kv : SPs[j]) {
					int mid = kv.first;
					int upperl = kv.second.first;
					auto& SP = kv.second.second;
					int64_t d = SP[Qs[i][0]][Qs[i][1]-upperl]+SP[Qs[i][2]][Qs[i][3]-upperl]+G[j][mid];
					// if ((Qs[i][0] == j && Qs[i][1] == mid) || (Qs[i][2] == j && Qs[i][3] == mid))
					// 	d -= G[j][mid];
					ans[i] = min(ans[i], d);
				}
			}
		}
		// cout << endl;
	}
	div_and_conq(l, mid-1, Qls);
	div_and_conq(mid+1, r, Qrs);
	for (int i = 0; i < N; ++i) {
		SPs[i].erase(mid);
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin >> N >> M;
	G.assign(N, vector<int64_t>(M));
	for (auto &v : G) {
		for (int64_t& i : v) {
			cin >> i;
		}
	}
	int Q;
	cin >> Q;
	Qs.resize(Q);
	ans.assign(Q, INF);
	vector<int> Qis;
	for (int i = 0; i < Q; ++i) {
		int a,b,c,d;
		cin >> a >> b >> c >> d;
		Qs[i] = {a,b,c,d};
		Qis.push_back(i);
	}
	div_and_conq(0, M-1, Qis);
	for (int64_t i : ans) {
		cout << i << endl;
	}
	return 0;
}
----------
====================
----------
ALGORITHMS.203
hard
----------
PROBLEM STATEMENT:
After completing her final semester, Savita is back home. She is excited to meet all her friends. Her [expression] friends live in different houses spread across the city.    

There are [expression] roads connecting the houses. The road network formed is connected and does not contain self loops and multiple roads between same pair of houses. Savita and Friends decide to meet.  

Savita wants to choose a point(not necessarily an integer) [expression] is minimised, 
where [expression].    

If [expression].     

Note: 


Use scanf/printf instead of cin/cout. Large input files.
Order of [expression], you should print 8 and not 2.  

----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
//#include <memory.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash

#define eps 1e-14
//#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 256
//#define N 120000

using namespace std;

long tests;
vector<pair<long, long> > g[200000];
long a,b,c;
long long cp1,cp2,tt;
long n,m,k;
long long dist[200000];

long bda,bdb;
double nmove;
set<pair<long long, long > > sett;
set<pair<long long, long> > ::iterator it;
pair<long long, long> tp;
long long qv;
long long qcost;
long d1[200000],d2[200000];
double l,r,mid1,mid2;

double gett(double val)
{
 double bst=0;
 for (int i=1;i<=n;i++)
  bst=max(bst,min(d1[i]+val,d2[i]+tt-val));
  return bst;
}

int main(){
//freopen("pattern.in","r",stdin);
//freopen("pattern.out","w",stdout);
//freopen("C:/input.txt","r",stdin);
//freopen("C:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);
//cin.tie(0);

cin>>tests;
for (;tests;--tests)
{
 cin>>n>>m>>k;
 for (int i=1;i<=n;i++)
  g[i].clear();
 for (int i=1;i<=m;i++)
  {
   cin>>a>>b>>c;
   if (i==k){cp1=a,cp2=b;tt=c;}
   g[a].push_back(make_pair(b,c));
   g[b].push_back(make_pair(a,c));
  }
 
 for (int i=1;i<=n;i++)
  dist[i]=1e16;
 dist[cp1]=0;
 sett.clear();
 for (int i=1;i<=n;i++)
  sett.insert(make_pair(dist[i],i));
 for (int iter=1;iter<=n;iter++)
 {
  it=sett.begin();
  tp=(*it);
  sett.erase(it);
  qv=tp.second;
  qcost=tp.first;
  for (int i=0;i<g[qv].size();i++)
  {
   long long nv=g[qv][i].first;
   long long ncost=g[qv][i].second+qcost;
   if (min(nv,qv)==min(cp1,cp2)&&max(nv,qv)==max(cp1,cp2))
    continue;
   if (dist[nv]>ncost)
   {
    sett.erase(make_pair(dist[nv],nv));
    dist[nv]=ncost;
    sett.insert(make_pair(dist[nv],nv));
   }
  }
 }
 
 for (int i=1;i<=n;i++)
  d1[i]=dist[i];
 
 // -- 2nd end
 
 for (int i=1;i<=n;i++)
  dist[i]=1e16;
 dist[cp2]=0;
 sett.clear();
 for (int i=1;i<=n;i++)
  sett.insert(make_pair(dist[i],i));
 for (int iter=1;iter<=n;iter++)
 {
  it=sett.begin();
  tp=(*it);
  sett.erase(it);
  qv=tp.second;
  qcost=tp.first;
  for (int i=0;i<g[qv].size();i++)
  {
   long long nv=g[qv][i].first;
   long long ncost=g[qv][i].second+qcost;
   if (min(nv,qv)==min(cp1,cp2)&&max(nv,qv)==max(cp1,cp2))
    continue;
   if (dist[nv]>ncost)
   {
    sett.erase(make_pair(dist[nv],nv));
    dist[nv]=ncost;
    sett.insert(make_pair(dist[nv],nv));
   }
  }
 }
 
 for (int i=1;i<=n;i++)
  d2[i]=dist[i];
 /*
 for (int i=1;i<=n;i++)
  cout<<d1[i]<<" ";
  cout<<endl;
 for (int i=1;i<=n;i++)
  cout<<d2[i]<<" ";
  cout<<endl;
   */
 l=0;
 r=tt;
 while (r-l>1e-6)
 {
  mid1=l*2+r;
  mid2=l+r*2;
  mid1/=3;
  mid2/=3;
  if (gett(mid1)<gett(mid2))r=mid2;
  else l=mid1;
 }
 if (gett(0)<gett(l))l=0;
 if (gett(tt)<gett(l))l=tt;
// cout<<gett(2)<<endl;
 cout.precision(5);
 cout<<fixed<<l<<" "<<gett(l)<<endl;
}

cin.get();cin.get();
return 0;}

----------
====================
----------
ALGORITHMS.204
advanced
----------
PROBLEM STATEMENT:
You have N soldiers numbered from 1 to N. Each of your soldiers is either a liar or a truthful person. You have M sets of information about them. Each set of information tells you the number of liars among a certain range of your soldiers. Let L be the total number of your liar soldiers. Since you can't find the exact value of L, you want to find the minimum and maximum value of L.

Input Format  


The first line of the input contains two integers N and M.  
Each of next M lines contains three integers: 
A B C where the set of soldiers numbered as {A, A+1, A+2, ..., B}, exactly C of them are liars. (1 


Note: N and M are not more than 101, and it is guaranteed the given informations is satisfiable.

Output Format 
Print two integers Lmin and Lmax to the output.

Sample Input #1  

3 2
1 2 1
2 3 1


Sample Output #1

1 2


Sample Input #2 

20 11
3 8 4
1 9 6
1 13 9
5 11 5
4 19 12
8 13 5
4 8 4
7 9 2
10 13 3
7 16 7
14 19 4


Sample Output #2

13 14


Explanation 
In the first input, the initial line is "3 2", i.e. that there are 3 soldiers and we have 2 sets of information. The next line says there is one liar in the set of soldiers {1, 2}. The final line says there is one liar in the set {2,3}. There are two possibilities for this scenario: Soldiers number 1 and 3 are liars or soldier number 2 is liar. 
So the minimum number of liars is 1 and maximum number of liars is 2. Hence the answer, 1 2.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>

using namespace std;

const int MAXN = 150;

typedef pair<int, int> P;

int d[MAXN];
vector<P> e[MAXN];
int a[MAXN], b[MAXN], c[MAXN];

deque<int> dq;
int inq[MAXN];

int n, m;

int getMin() {
  for (int i = 0; i <= n; ++i) e[i].clear();
  for (int i = 1; i <= n; ++i) {
    e[i - 1].push_back(P(i, 0));
    e[i].push_back(P(i - 1, -1));
  }
  for (int i = 0; i < m; ++i) {
    e[b[i]].push_back(P(a[i] - 1, -c[i]));
    e[a[i] - 1].push_back(P(b[i], c[i]));
  }
  fill(d, d + (n + 1), 0);
  d[0] = 0;

  for (int c = 0; c <= n; ++c) 
    for (int u = 0; u <= n; ++u)
      for (int j = 0; j < e[u].size(); ++j) {
	int v = e[u][j].first;
	if (d[u] + e[u][j].second > d[v]) d[v] = d[u] + e[u][j].second;
      }
  return d[n];

  fill(inq, inq + (n + 1), 0);
  inq[0] = 1;
  while (!dq.empty()) dq.pop_back();
  dq.push_back(0);
  while (!dq.empty()) {
    int u = dq.front();
    dq.pop_front();
    inq[u] = 0;
    for (int j = 0; j < e[u].size(); ++j) {
      int v = e[u][j].first;
      if (d[u] + e[u][j].second > d[v]) {
	d[v] = d[u] + e[u][j].second;
	if (!inq[v]) {
	  inq[v] = 1;
	  dq.push_back(v);
	}
      }
    }
  }
  return d[n];
}

int getMax() {
  for (int i = 0; i <= n; ++i) e[i].clear();
  for (int i = 1; i <= n; ++i) {
    e[i].push_back(P(i - 1, 0));
    e[i - 1].push_back(P(i, 1));
  }
  for (int i = 0; i < m; ++i) {
    e[b[i]].push_back(P(a[i] - 1, -c[i]));
    e[a[i] - 1].push_back(P(b[i], c[i]));
  }
  fill(d, d + (n + 1), n * 2);
  d[0] = 0;

  for (int c = 0; c <= n; ++c) 
    for (int u = 0; u <= n; ++u)
      for (int j = 0; j < e[u].size(); ++j) {
	int v = e[u][j].first;
	if (d[u] + e[u][j].second < d[v]) d[v] = d[u] + e[u][j].second;
      }
  return d[n];

  fill(inq, inq + (n + 1), 0);
  inq[0] = 1;
  while (!dq.empty()) dq.pop_back();
  dq.push_back(0);
  while (!dq.empty()) {
    int u = dq.front();
    dq.pop_front();
    inq[u] = 0;
    for (int j = 0; j < e[u].size(); ++j) {
      int v = e[u][j].first;
      if (d[u] + e[u][j].second < d[v]) {
	d[v] = d[u] + e[u][j].second;
	if (!inq[v]) {
	  inq[v] = 1;
	  dq.push_back(v);
	}
      }
    }
  }
  return d[n];
}

int main() {
  scanf("%d%d", &n, &m);
  for (int i = 0; i < m; ++i) {
    scanf("%d%d%d", a + i, b + i, c + i);
  }

  printf("%d %d\n", getMin(), getMax());
}

----------
====================
----------
ALGORITHMS.205
advanced
----------
PROBLEM STATEMENT:
Nina has an [expression] jumping rooks. Every cell of the chessboard is either blocked or free, and Nina can only put a single rook in any free cell. 

Two jumping rooks beat each other if they are either in the same row or in the same column and all cells between them are free (note that it's possible that there are some other rooks between them). More formally, if the first rook is in cell [expression] must all be free.

Given the configuration of the chessboard and some [expression] jumping rooks in the chessboard's free cells such that the number of pairs of rooks that beat each other is minimal. Then print a single integer denoting the number of rooks that beat each other.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

const int MAXN = 100000, MAXM = 1000000;
const int INF = 1e8;

struct TEdge {
    int from, to;
    int c, ocost, cost, w;

    TEdge(int from = 0, int to = 0, int c = 0, int cost = 0)
        : from(from)
        , to(to)
        , c(c)
        , ocost(cost)
        , cost(cost)
        , w(0)
    {
    }
};

vi e[MAXN];
TEdge edges[2 * MAXM];
int ec = 0;

void addEdge(int from, int to, int c, int cost) {
    if (c <= 0) return;
    e[from].pb(ec);
    edges[ec++] = TEdge(from, to, c, cost);
    e[to].pb(ec);
    edges[ec++] = TEdge(to, from, 0, -cost);
}

int dist[MAXN], vis[MAXN], par[MAXN], pushed[MAXN];
int pot[MAXN];

void init(int N) {
    forn(i, N) {
        dist[i] = INF;
        vis[i] = 0;
        par[i] = -1;
        pushed[i] = 0;
    }
}

void reduceCost() {
    forn(i, ec) {
        if (edges[i].w < edges[i].c) {
            edges[i].cost += dist[edges[i].from] - dist[edges[i].to];
            edges[i ^ 1].cost = 0;
        }
    }
}

int push(int from, int to, int N) {
    init(N);
    dist[from] = 0;
    pushed[from] = INF;
    set<pii> q;
    q.insert(mp(dist[from], from));
    while (!q.empty()) {
        int m = q.begin()->se;
        q.erase(q.begin());
        vis[m] = 1;  
        for (int id: e[m]) {
            if (edges[id].w >= edges[id].c) continue;
            int to = edges[id].to;
            int w = edges[id].cost;
            if (dist[m] + w < dist[to]) {
                q.erase(mp(dist[to], to));
                dist[to] = dist[m] + w;
                q.insert(mp(dist[to], to));
                par[to] = id;
                pushed[to] = min(pushed[m], edges[id].c - edges[id].w);
            }
        }
    }
    reduceCost();
    if (!pushed[to]) return 0;
    int pt = pushed[to];
    int v = to;
    while (par[v] != -1) {
        int id = par[v];
        edges[id].w += pt;
        edges[id ^ 1].w -= pt;
        v = edges[id].from;
    }
    return pt;
}

void maxflow_mincost(int from, int to, int N, int K) {
    init(N);
    dist[from] = 0;
    bool changed;
    do {
        changed = false;
        forn(i, ec) {
            if (edges[i].w >= edges[i].c) continue;
            changed |= uin(dist[edges[i].to], dist[edges[i].from] + edges[i].cost);
        }
    } while (changed);
    reduceCost();
//    --K;
    while (K--) {push(from, to, N);}
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int n, k;
    cin >> n >> k;
    vector<string> f(n);
    forn(i, n) cin >> f[i];
    vvi hs(n, vi(n)), vs(n, vi(n));

    int H = 0, V = 0;
    vi szh, szv;
    forn(i, n) forn(j, n) {
        if (f[i][j] != '.') continue;
        if (!j || f[i][j - 1] == '#') ++H, szh.pb(0);
        hs[i][j] = H - 1; ++szh.back();
    }
    forn(j, n) forn(i, n) {
        if (f[i][j] != '.') continue;
        if (!i || f[i - 1][j] == '#') ++V, szv.pb(0);
        vs[i][j] = V - 1; ++szv.back();
    }


    int S = 0, T = 1;
    int off0 = 2, off1 = off0 + H, N = off1 + V;
    forn(j, H) forn(i, szh[j]) addEdge(S, off0 + j, 1, i);
    forn(j, V) forn(i, szv[j]) addEdge(off1 + j, T, 1, i);
    forn(i, n) forn(j, n) {
        if (f[i][j] == '#') continue;
//        cerr << i << ' ' << j << ' ' << hs[i][j] << ' ' << vs[i][j] << '\n';
        addEdge(off0 + hs[i][j], off1 + vs[i][j], 1, 0);
    }
    maxflow_mincost(S, T, N, k);
    int ans = 0;
    forn(i, ec) ans += edges[i].w * edges[i].ocost;
    ans /= 2;
    cout << ans << '\n';

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.206
hard
----------
PROBLEM STATEMENT:
You are given [expression].
----------
TOP SOLUTION:
----------
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include<cstdio>
#include<numeric>
#include<cstring>
#include<ctime>
#include<cstdlib>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<list>
#include<cmath>
#include<bitset>
#include<cassert>
#include<queue>
#include<stack>
#include<deque>
#include<cassert>
using namespace std;
typedef long long ll;
typedef long double ld;
const int MAXN = 100 * 1000 + 1;
typedef bitset<MAXN> bs;
int deg1[MAXN], deg2[MAXN];
vector<int>g1[MAXN], g2[MAXN];
unordered_set<long long>have1, have2;

int calc(int u, int v) // u - first, v - third
{
	int res = 0;
	if (deg1[u] < deg2[v])
	{
		for (int i = 0; i < (int)g1[u].size(); i++)
		{
			int to = g1[u][i];
			if (to == v) continue;
			res += have2.count(1LL * MAXN * v + to);
		}
	}
	else
	{
		for (int i = 0; i < (int)g2[v].size(); i++)
		{
			int to = g2[v][i];
			if (to == v) continue;
			res += have1.count(1LL * MAXN * u + to);
		}
	}
	return res;
}
int main()
{
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	int n;
	scanf("%d", &n);
	int m;
	scanf("%d", &m);
	have1.rehash(10 * 1000 * 1000);
	have2.rehash(10 * 1000 * 1000);
	for (int i = 1; i <= m; i++)
	{
		int u, v;
		scanf("%d %d", &u, &v);
		g1[u].push_back(v);
		have1.insert(1LL * MAXN * u + v);
		have1.insert(1LL * MAXN * v + u);
		g1[v].push_back(u);
		deg1[u]++;
		deg1[v]++;
	}
	vector<pair<int, int> >mid;
	scanf("%d", &m);
	for (int i = 1; i <= m; i++)
	{
		int u, v;
		scanf("%d %d", &u, &v);
		mid.push_back(make_pair(u, v));
	}
	scanf("%d", &m);
	for (int i = 1; i <= m; i++)
	{
		int u, v;
		scanf("%d %d", &u, &v);
		deg2[u]++;
		deg2[v]++;
		g2[u].push_back(v);
		g2[v].push_back(u);
		have2.insert(1LL * MAXN * u + v);
		have2.insert(1LL * MAXN * v + u);
	}
	ll ans = 0;
	for (int i = 0; i < (int)mid.size(); i++)
	{
		int u = mid[i].first, v = mid[i].second;
		ans += calc(u, v);
		ans += calc(v, u);
	}
	printf("%lld\n", ans);
}

----------
====================
----------
ALGORITHMS.207
hard
----------
PROBLEM STATEMENT:
Recall that a tree is an undirected, connected acyclic graph. We have a weighted tree, [expression].

Let's consider all the matrices, [expression], such that:


[expression]
[expression]
[expression]


We consider the total value of matrix [expression] to be:
[expression]

Calculate and print the maximum total value of [expression].
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

typedef pair<long long, long long> PII;

long long n,x,y,z,i,ans1,ans2;
vector<PII> edge[500007];

void DFS1(long long bef, long long pos, long long sum) {
    long long i;
    for (i=0 ; i<edge[pos].size() ; i++) if (edge[pos][i].first != bef) {
        DFS1(pos,edge[pos][i].first,sum + edge[pos][i].second);
    }
    ans1 += sum;
}

void DFS2(long long bef, long long pos, long long sum) {
    long long i;
    for (i=0 ; i<edge[pos].size() ; i++) if (edge[pos][i].first != bef) {
        DFS2(pos,edge[pos][i].first,sum + edge[pos][i].second);
    }
    ans2 += sum;
}

int main() {
    scanf("%lld",&n);
    for (i=1 ; i<=n-1 ; i++) {
        scanf("%lld%lld%lld",&x,&y,&z);
        edge[x].push_back(PII(y,z));
        edge[y].push_back(PII(x,z));
    }
    
    DFS1(-1,1,0);
    DFS2(-1,n,0);
    //printf("%lld %lld\n",ans1,ans2);
    printf("%lld\n",min(ans1,ans2));
    
    return 0;
}

----------
====================
----------
ALGORITHMS.208
expert
----------
PROBLEM STATEMENT:
You are given a Directed Acyclic Graph (DAG) with [expression] queries on the DAG, where each query is one of the following types:


1 u x: Set [expression].
2 u x: Set [expression].
3 u: Print the value of [expression] on a new line.

----------
TOP SOLUTION:
----------
#include <map>
#include <vector>
#include <queue>
#include <cstdio>
#include <iterator>
#include <functional>
#include <new>
#include <array>
namespace XX
{

    template<int BLOCKSIZE>
    class MemoryManager
    {
        public:
            static constexpr const int INIT = 1024 * 1024 / BLOCKSIZE? 1024 * 1024 / BLOCKSIZE: 1;

            static MemoryManager* inst()
            {
                static MemoryManager ret;
                return &ret;
            }
            
            void* alloc()
            {
                void* ret;
                if(_ptr)
                {
                    ret = _ptr;
                    _ptr = *static_cast<void**>(_ptr);
                }
                else 
                {
                    if(_pos == _size) 
                    {
                        _pos = 0;
                        _buf[++_idx] = new char[_size <<= 1];
                    }

                    ret = _buf[_idx] + _pos;
                    _pos += BLOCKSIZE;
                }
                return ret;
            }

            void dealloc(void* p)
            {
                *static_cast<void**>(p) = _ptr;
                _ptr = p;
            }

            ~MemoryManager()
            {
                for(int i = 1; i <= _idx; i++)
                    delete []_buf[i];
            }

        private:

            MemoryManager() { _buf[0] = _init; }

            char _init[INIT * BLOCKSIZE];
            int _size = INIT * BLOCKSIZE;
            int _idx = 0;
            int _pos = 0;
            char* _buf[32] = {};
            void* _ptr = nullptr;
    };

    template<typename T>
    struct BlockAllocater
    {
        void* operator new(std::size_t count) { return MemoryManager<sizeof(T)>::inst()->alloc(); }
        void operator delete(void* ptr) { return MemoryManager<sizeof(T)>::inst()->dealloc(ptr); }
    };
    template<typename T>
    struct NullNode
    {
        static T nullnode;
        static T* null() { return &nullnode; }
        bool isNull(){return this == null();}
    };

    template<typename T>
    T NullNode<T>::nullnode;
}





#ifdef _MSC_VER
#include <intrin.h>
inline int CLZ(int n){unsigned long ret; _BitScanForward(&ret, n); return ret;}
//inline int CLZ(long long int n){unsigned long ret; _BitScanForward64(&ret, n); return ret;}
inline int CTZ(int n){unsigned long ret; _BitScanReverse( &ret, n); return 31 - ret;} 
//inline int CTZ(long long int n){unsigned long ret; _BitScanReverse64( &ret, n); return 63 - ret;} 
inline int POPCNT(int n){return __popcnt(n);}
//inline int POPCNT(long long int n){return __popcnt64(n);}
#endif

#ifdef __GNUC__
inline int CLZ(int n){return __builtin_clz(n);}
inline int CLZLL(long long int n){return __builtin_clzll(n);}
inline int CTZ(int n){return __builtin_ctz(n);}
inline int CTZLL(long long int n){return __builtin_ctzll(n);}
inline int POPCNT(int n){return __builtin_popcount(n);}
inline int POPCNTLL(long long int n){return __builtin_popcountll(n);}
#endif





namespace XX
{   
    template<template<typename> class Compare, typename T>
    inline T& UP(T& x, const T& y){if(Compare<T>()(y, x)) x = y; return x;}
    template<typename Compare, typename T>
    inline T& UP(T& x, const T& y, Compare comp){if(comp(y, x)) x = y; return x;}

    template<typename T> inline T& GT(T& x, const T& y){return UP<std::greater>(x, y);}
    template<typename T> inline T& LS(T& x, const T& y){return UP<std::less>(x, y);}

    template<typename T>
    struct Mapper
    {
        int operator[](const T& v) { int& ret = table[v]; if(!ret) rtable[ret = table.size()] = v; return ret - 1; }
        template<typename... Args> int operator()(Args... args) { return (*this)[T(args...)]; }
        T rev(int idx){return rtable[idx + 1];}
        std::map<T, int> table;
        std::map<int, T> rtable;
    };

    template<typename T, int S>
    struct ReferenceArray
    {
        struct It {typename std::array<T*, S>::iterator it; T& operator*(){return **it;} void operator++(){it++;} bool operator!=(const It& other){return it != other.it;} };
        int size()const{return _ptr.size();}
        It begin()const{return {_ptr.begin()};}
        It end()const{return {_ptr.end()};}
        T& operator[](int idx)const{return *_ptr[idx];}
        mutable std::array<T*, S> _ptr;
    };
    template<typename T, typename... Args> 
    ReferenceArray<T, sizeof...(Args) + 1> MAKEV(T& arg1, Args&... args) {return {&arg1, &args...};}

    struct Range
    {   
        struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };
        Range(int ee):b(0),e(ee){}
        Range(int bb, int ee):b(bb), e(ee){}
        It begin(){return {b, (b < e? 1: -1)};}
        It end(){return {e, 0};}
        int b, e;
    };

}



template<typename T> struct ScanfSpecifier{};
#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};
DEF(char*,"%s")DEF(int,"%d")DEF(double,"%lf")DEF(float,"%f")DEF(char,"%c")DEF(const char*,"%s")DEF(unsigned long,"%lu")DEF(unsigned int, "%u")
#ifdef _MSC_VER
DEF(long long int,"%I64d")
#else
DEF(long long int,"%lld")
#endif
#undef DEF
template<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}
template<int S> int RD(char (&arg)[S]){return std::scanf("%s", arg);}
int RD(char* arg){return std::scanf("%s", arg);}
template<> int RD<char>(char& arg){return std::scanf(" %c", &arg);}
template<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}
template<typename T> T RD(){T ret; RD(ret); return ret;}
template<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }
template<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}
template<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(" "): 0), std::printf(ScanfSpecifier<Args>::value, args), 0)...}; }
template<typename... Args> void WTL(Args... args) { WT(args...); std::printf("\n"); }
template<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(" "): 0), WT(*begin++); }
template<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}
template<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf("\n"); }
template<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}



namespace XX
{
    template<typename... EdgeTs>
    class Graph
    {    
        public:
            struct Edge: public EdgeTs...
            {
                int from, to;
                Edge(int f, int t, EdgeTs... args) :from(f), to(t), EdgeTs(args)...  {}
                Edge(){}
            };

            struct Node:public Edge, BlockAllocater<Node>
            {
                Node* next;
                template<typename... Args> Node(Node* nn, Args... args) :next(nn),Edge(args...) {}
            };

            typedef Node* EdgeIdx;

        private:
            std::vector<Node*> _adj;
            int _numVertex;

            void _dealloc(Node* node) { if(node) { _dealloc(node->next); delete node; } }

        public:
            Graph(int v = 0) :_adj(v) {}
            //~Graph(){for(Node* node: _adj)_dealloc(node);}

            int size(){return _adj.size();}
            void resize(int size){_adj.resize(size);}
            EdgeIdx add(int from, int to, EdgeTs... args) { return _adj[from] = new Node{_adj[from], from, to, args...}; }

            Node& operator[](EdgeIdx idx){return idx->e;}
            struct Enumerator
            {
                struct It
                {
                    Node* ptr;
                    Node& operator*(){return *ptr;}
                    void operator++(){ptr = ptr->next;}
                    bool operator!=(const It& other){return ptr != other.ptr;}
                }b, e;
                It begin(){return b;}
                It end(){return e;}
            };
            struct AllEnumerator
            {
                struct It
                {
                    Node* ptr;
                    int v;
                    Graph& g;
                    Node& operator*(){return *ptr;}
                    void operator++()
                    {
                        ptr = ptr->next; 
                        while(!ptr && ++v < g.size())
                            ptr = g._adj[v];
                    }
                    bool operator!=(const It& other){return ptr != other.ptr;}
                };
                Graph& g;
                It begin()
                {
                    for(int i = 0; i < g.size(); i++)
                        if(g._adj[i])
                            return {g._adj[i], i, g};
                    return end();
                }
                It end(){return {nullptr, 0, g};}
            };
            Enumerator adj(int v) { return {_adj[v], nullptr}; }
            Enumerator adj(EdgeIdx idx) { return {idx, nullptr}; }
            AllEnumerator edges() { return {*this}; }
            Enumerator operator[](int idx){return adj(idx);}
    };
}



namespace XX
{
    template<typename... EdgeTs>
    std::vector<int> topologicalsort(Graph<EdgeTs...>& g)
    {
        std::vector<int> deg(g.size());
        for(auto& e: g.edges())
            deg[e.to]++;

        std::vector<int> ret(deg.size());
        unsigned len = 0;
        std::queue<int> que;
        for(unsigned i = 0; i < deg.size(); i++)
            if(deg[i] == 0)
                que.push(i);

        while(que.size())
        {
            int u = que.front();
            que.pop();
            ret[len++] = u;
            for(auto& e: g[u])
                if(--deg[e.to] == 0)
                    que.push(e.to);
        }

        if(len < ret.size())
            ret.resize(len);
        return ret;
    }
}




//alias
using XX::Graph;
using XX::topologicalsort;
//RD[L],RDV[L],WT[L],WTV[L] for i/o
template<typename T> T& UMAX(T& x, T y){return XX::UP<std::greater>(x, y);}
template<typename T> T& UMIN(T& x, T y){return XX::UP<std::less>(x, y);}
using XX::UP; //(x,y) comp
using RG = XX::Range;
using XX::MAKEV;
using XX::Mapper;
//template
#include <vector>
#include <string>
#include <set>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <functional>
#include <cstring>
using namespace std;

//alias
//bit operation => CLZ,CTZ,POPCNT
const int SQ = 384;

const int SL = (SQ + 63) / 64;
struct Req
{
    int idx;
    int t, u, x;
    bool operator<(const Req& r)const{return x < r.x;}
}qs[SQ], qs2[SQ];


typedef unsigned long long int ull;

int value[100009];
int op[100009];
ull mask[100009][SL];
ull mask2[100009][SL];
ull mask3[SQ][SL];

void setb(ull mask[], int idx)
{
    mask[idx >> 6] |= (1ull << (idx & 63));
}
bool test(ull mask[], int idx)
{
    return mask[idx >> 6] & (1ull << (idx & 63));
}

void orb(ull m1[], ull m2[])
{
    for(int i = 0; i < SL; i++)
        m1[i] = m1[i] | m2[i];
}
void andb(ull m1[], ull m2[])
{
    for(int i = 0; i < SL; i++)
        m1[i] = m1[i] & m2[i];
}

int mn(ull m1[])
{
    for(int i = 0; i < SL; i++)
        if(m1[i])
            return i * 64 + CTZLL(m1[i]);
    return -1;
}

int main()
{
    int N, M, Q;
    RD(N, M, Q);

    Graph<> g(N);
    while(M--)
    {
        int u, v;
        RD(u, v);
        u--, v--;

        g.add(u, v);
    }

    auto topo = topologicalsort(g);

    if((int)topo.size() != N)
        return -1;
    for(int i = 0; i < Q; i += SQ)
    {
        memset(op, -1, sizeof(op));
        memset(mask, 0, sizeof(mask));
        memset(mask2, 0, sizeof(mask2));
        memset(mask3, 0, sizeof(mask3));
        int total = min(i + SQ, Q) - i;
        for(int j = 0; j < total; j++)
        {
            RD(qs[j].t, qs[j].u);
            qs[j].u--;
            if(qs[j].t != 3)
            {
                setb(mask[qs[j].u], j);
                RD(qs[j].x);
            }
            if(qs[j].t == 1)
                op[qs[j].u] = j;
            qs[j].idx = j;
            qs2[j] = qs[j];
        }
        
        sort(qs2, qs2 + total);
        for(int j = 0; j < total; j++)
            if(qs2[j].t == 2)
                setb(mask2[qs2[j].u], j);

        for(int k = 0; k < N; k++)
        {
            int j = topo[k];
            for(auto e: g[j])
            {
                orb(mask[e.to], mask[j]);
                orb(mask2[e.to], mask2[j]);
                if(op[j] != -1 && (op[e.to] == -1 || op[e.to] < op[j]))
                    op[e.to] = op[j];
            }
        }
        for(int j = 0; j < total; j++)
            if(qs[j].t == 3)
            {
                int u = qs[j].u;
                int v = value[qs[j].u];

                for(int k = 0; k < j; k++)
                    if(test(mask[u], k))
                    {
//                        WTL("?", j, k);
                        if(qs[k].t == 1 || v > qs[k].x)
                            v = qs[k].x;
                    }
                WTL(v);
            }
            else if(qs[j].t == 1)
            {
                for(int k = 0; k < total; k++)
                    if(qs2[k].t == 2 && qs2[k].idx > j && qs2[k].x < qs[j].x)
                        setb(mask3[j], k);
            }

        for(int j = 0; j < N; j++)
        {
            if(op[j] != -1)
            {
                andb(mask2[j], mask3[op[j]]);
                value[j] = qs[op[j]].x;
            }
            int idx = mn(mask2[j]);

            if(idx != -1 && value[j] > qs2[idx].x)
                value[j] = qs2[idx].x;
        }


    }



}




----------
====================
----------
ALGORITHMS.209
advanced
----------
PROBLEM STATEMENT:
Johnny, like every mathematician, has his favorite sequence of distinct natural numbers.  Let’s call this sequence [expression] and then threw the notebook out onto the street. You just found it. Can you reconstruct the sequence? 

In the input there are [expression]. If there are many such sequences, return the lexicographically smallest one. It is guaranteed that such a sequence exists.

Note 
Sequence [expression].
----------
TOP SOLUTION:
----------
//gshkrtiladze

#include <iostream>
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <queue>

#define pb push_back
#define getcx getchar//_unlocked

using namespace std;

inline void inp(int &n )
 {n=0; int ch=getcx();
  while(ch<'0'||ch>'9') ch=getcx();
  while(ch>='0'&&ch<='9') n=(n<<3)+(n<<1)+ch-'0',ch=getcx(); }

int n,k,b,a,i;
int xr[1000001];
bool f[1000001];

vector < int > nx[1000001];
priority_queue < int > st;

int main() {
   inp(n);
   while (n--) {
     inp(k);
     cin>>b; f[b]=1;
     for (i=2;i<=k;i++) {
       inp(a); xr[a]++;
       nx[b].pb(a);
       b=a; f[b]=1;
      }
    }
   for (i=0;i<=1000000;i++)
    if (f[i] && xr[i] == 0)
     st.push(-i);
   while (st.size() > 0)
    {
     k=-st.top();
     printf("%d ",k);
     st.pop();
     for (i=0;i<nx[k].size();i++) {
      xr[nx[k][i]]--; if (xr[nx[k][i]] == 0) st.push(-nx[k][i]); }
    }
   printf("\n");
 }

----------
====================
----------
ALGORITHMS.210
advanced
----------
PROBLEM STATEMENT:
It's almost summertime, so Big Cat and Little Cat are getting in shape. They decide the core of their fitness plan is to start jogging every day.

Their city consists of [expression] different roads.

The cats also love exploring new places, so each day they want to choose a new route to jog on that is not equal to any of their previous routes. Two routes are considered to be equal if their sets of component roads are equal.

Given a map of the city, can you help our heroic cats determine the maximum number of days they can go jogging so that every route traveled is different? 
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cmath>
#include <cstring>
#include <queue>
#include <vector>
#include <cstdio>
#include <map>
#include <stack>
#include <set>
#include <algorithm>
#define ll long long
using namespace std;
const int Maxn = 100010 , Maxm = 11, Mo = 1e9 + 7;
const ll oo = 1ll << 60;
#define PB push_back

int T, cs = 1;
int n , m , k;
vector<int> e[Maxn];
int cnt[Maxn];
int main(){
    cin >> n >> m;
    for (int i = 1, u, v; i <= m; i++){
        cin >> u >> v;
        e[u].PB(v);
        e[v].PB(u);
    }
    ll ans = 0;
    for (int u = 1; u <= n; u++){
        vector<int> all;
        for (int i = 0; i < e[u].size(); i++){
            int v = e[u][i];
            for (int k =0; k < e[v].size(); k++){
                int t = e[v][k];
                if (t == u) continue;
                if (cnt[t] == 0) all.PB(t);
                ans += cnt[t];
                cnt[t] ++;                
            }
        }
        for (int i = 0; i < all.size(); i++) cnt[all[i]] = 0;
    }
    cout << ans / 4 << endl;
}
----------
====================
----------
ALGORITHMS.211
advanced
----------
PROBLEM STATEMENT:
There are [expression]. There are three types of queries needed:&nbsp;


X i j Reflect all points in the inclusive range between points [expression]-axis.  
Y i j Reflect all points in the inclusive range between points [expression]-axis. 
C i j Count the number of points in the inclusive range between points [expression] quadrants. Then print a single line of four space-separated integers describing the respective numbers of points in the first, second, third, and fourth quadrants in that order. 


As a reminder, the four quadrants of a graph are labeled as follows: 
    

Given a set of [expression], so the fourth query output is 0 1 1 0.

Note: Points may sometimes share the same coordinates.  

Function Description  

Complete the quadrants function in the editor below.  It should print the results of each C type query on a new line.  

quadrants has the following parameters: 
- p[p[1]...p[n]]: a 2-dimensional array of integers where each element [expression] 
- queries[queries[1]...queries[n]: an array of strings  
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include <iostream>
#include <memory.h>


const int maxn = 65536*2;

struct st_node{
	int total[4];
	bool x,y;
	
};

static st_node nodes[maxn*2-1];
int n;

int tree_insert(int node, int l, int r, int index, int* total){
	for (int i=0; i<4; i++)
		nodes[node].total[i] += total[i];
	if (l<r){
		int mid = (l+r)/2;
		if (index<=mid)
			tree_insert(node*2+1, l, mid, index, total);
		else 
			tree_insert(node*2+2, mid+1, r, index, total);
	}
}

int read_point(){
	memset(nodes, 0, sizeof(nodes));
	std::cin>>n;
	for (int i=1; i<=n; i++){
		int x,y;
		int total[4];
		memset(total, 0, sizeof(total));
		std::cin>>x>>y;
		if (x==0 && y==0)
			continue;
		if (x>0 && y>0)
			total[0] = 1;
		if (x<0 && y>0)
			total[1] = 1;
		if (x<0 && y<0)
			total[2] = 1;
		if (x>0 && y<0)
			total[3] = 1;
		tree_insert(0,1,n,i,total);
	}			
}

void swap(int &x, int&y){
	x = x^y;
	y = x^y;
	x = x^y;	
}

void reflect(int *total, bool xreflect, bool yreflect){
	if (xreflect){
		swap(total[0],total[3]);
		swap(total[1],total[2]);			
	}
	if (yreflect){
		swap(total[0],total[1]);
		swap(total[2],total[3]);
	}			
}

int tree_count(int node, int l, int r, int x, int y, int* total, bool xreflect, bool yreflect){

	xreflect ^= nodes[node].x;
	yreflect ^= nodes[node].y;

	if (x<=l && r<=y){
		int tmp[4];		
		for (int i=0; i<4; i++)
			tmp[i] = nodes[node].total[i];
		reflect(tmp, xreflect, yreflect);
		for (int i=0; i<4; i++)
			total[i] += tmp[i];
		return 0;
	} 

	if (l<r){
		int mid = (l+r)/2;
		if (x<=mid)
			tree_count(node*2+1, l, mid, x, y, total, xreflect, yreflect);
		if (y>=mid+1)
			tree_count(node*2+2, mid+1, r, x, y, total, xreflect, yreflect);
	}
}

int tree_reflect(int node, int l, int r, int x, int y, bool xreflect, bool yreflect){
	if (x<=l && r<=y){
		nodes[node].x ^= xreflect;
		nodes[node].y ^= yreflect;
		return 0;
	}
	if (l<r){
		int mid=(l+r)/2;
		if (x<=mid)
			tree_reflect(node*2+1, l, mid, x, y, xreflect, yreflect);
		if (y>=mid+1)
			tree_reflect(node*2+2, mid+1, r, x, y, xreflect, yreflect);
		int ltotal[4], rtotal[4];				
		for (int i=0; i<4; i++){
			ltotal[i] = nodes[node*2+1].total[i];
			rtotal[i] = nodes[node*2+2].total[i];		
		}
		reflect(ltotal, nodes[node*2+1].x, nodes[node*2+1].y);
		reflect(rtotal, nodes[node*2+2].x, nodes[node*2+2].y);
		for (int i=0; i<4; i++)
			nodes[node].total[i] = ltotal[i]+rtotal[i];
	}	
}

int solve(){
	int q; 
	std::cin>>q;
	for (int i=0; i<q; i++){
		char type;
		int x, y;
		std::cin>>type>>x>>y;
		if (type=='C'){
			int total[4];
			memset(total, 0, sizeof(total));
			tree_count(0, 1, n, x, y, total, false, false);
			std::cout<<total[0]<<" "<<total[1]<<" "<<total[2]<<" "<<total[3]<<std::endl;			
		}		
		else if (type=='X'){
			tree_reflect(0, 1, n, x, y, true, false);			
		} 
		else if (type=='Y'){
			tree_reflect(0, 1, n, x, y, false, true);
			
		}		
	}
}

int main(){
	read_point();
	solve();
}


----------
====================
----------
ALGORITHMS.212
hard
----------
PROBLEM STATEMENT:
There are N cities in Hacker Country. Each pair of cities are directly connected by a unique directed road, and each road has its own toll that must be paid every time it is used. You're planning a road trip in Hacker Country, and its itinerary must satisfy the following conditions:  


You can start in any city.
You must use [expression] or more cities).
At the end of your trip, you should be back in your city of origin.
The average cost (sum of tolls paid per road traveled) should be minimum.


Can you calculate the minimum average cost of a trip in Hacker Country?

Time Limits 
Time limits for this challenge are provided here.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 510;
const int inf = (int)1e9;

int a[N][N];
int d[N][N];

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) scanf("%d", a[i] + j);
    for (int i = 0; i < n; i++) d[0][i] = 0;
    for (int it = 0; it < n; it++) {
        for (int i = 0; i < n; i++) d[it + 1][i] = inf;
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++) {
              if (i == j) {
                continue;
              }
              int dt = d[it][i] + a[i][j];
              if (dt < d[it + 1][j]) {
                  d[it + 1][j] = dt;
              }
            }
    }
    long long p = inf, q = 1;
    for (int i = 0; i < n; i++) {
        long long pp = 0, qq = 1;
        for (int it = 0; it < n; it++) {
            long long num = d[n][i] - d[it][i];
            long long den = n - it;
            if (num * qq > pp * den) {
                pp = num;
                qq = den;
            }
        }
        if (pp * q < p * qq) {
            p = pp;
            q = qq;
        }
    }
    int xx = p, yy = q;
    while (xx > 0 && yy > 0)
        if (xx > yy) xx %= yy;
        else yy %= xx;
    int g = xx + yy;
    p /= g;
    q /= g;
    printf("%d/%d", (int)p, (int)q);
    return 0;
}

----------
====================
----------
ALGORITHMS.213
hard
----------
PROBLEM STATEMENT:
Update: A slight modification in the problem statement (see below)  

Evil Nation A is angry and plans to launch N guided-missiles at the peaceful Nation B in an attempt to wipe out all of Nation B's people. Nation A's missile i will arrive in nation B at time ti. Missile i communicates with its headquarters by unique radio signals with a frequency equal to fi. Can you help the peaceful Nation B survive by building a defensive system that will stop the missiles dead in the sky?

Defensive system:  

The only way to defend Nation B from the attacking missile is by counter attacking them with a hackerX missile. You have a lot of hackerX missiles and each one of them has its own radio frequency. An individual hackerX missile can destroy Evil Nation A’s attacking missile if the radio frequency of both of the missiles match. Each hackerX missile can be used an indefinite number of times. Its invincible and doesn't get destroyed in the collision.

The good news is you can adjust the frequency of the hackerX missile to match the evil missiles' frequency. When changing the hackerX missile's initial frequency fA to the new defending frequency fB, you will need \|fB - fA\| units of time to do. 

Each hackerX missile can only destroy one of Nation A's missile at a time. So if two evil missiles with same frequency arrive at the same time, you need at least two hackerX missiles with the same frequency as the evil missiles to avoid damage. 

If two evil missles with same frequency arrive at the same time, we can destroy them both with one hackerX missile. You can set the frequency of a hackerX missile to any value when its fired.  

What is the minimum number of hackerX missiles you must launch to keep Nation B safe?

Input Format: 
The first line contains a single integer N denoting the number of missiles. 
This is followed by N lines each containing two integers ti and fi denoting the time & frequency of the ith missile.

Output Format: 
A single integer denoting the minimum number of hackerX missiles you need to defend the nation.

Constraints: 
1 
0 i 
0 i 
t1 2 N  

Sample Input #00  

4
1 1
2 2
3 1
5 1


Sample Output #00  

1


Explanation #00

A HackerX missile is launched at t = 1 with a frequency f = 1, and destroys the first missile. It re-tunes its frequency to f = 2 in 1 unit of time, and destroys the missile that is going to hit Nation B at t = 2. It re-tunes its frequency back to 1 in 1 unit of time and destroys the missile that is going to hit the nation at t = 3. It is relaunched at t = 5 with f = 1 and destroys the missile that is going to hit nation B at t = 5. Hence, you need only 1 HackerX to protect nation B. 

Sample Input #01  

4
1 1
2 3
3 1
5 1


Sample Output #01  

2


Explanation #01

Destroy 1 missile at t = 1, f = 1. now at t = 2, there is a missile with frequency 3. The launched missile takes 2 units of time to destroy this, hence we need a new hackerX missile to destroy this one. The first hackerX missile can destroy the 3rd missile which has the same frequency as itself. The same hackerX missile destroys the missile that is hitting its city at t = 5. Thus, we need atleast 2 hackerX missiles. 
----------
TOP SOLUTION:
----------
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#define fo(i,a,b) dfo(int,i,a,b)
#define fr(i,n) dfr(int,i,n)
#define fe(i,a,b) dfe(int,i,a,b)
#define fq(i,n) dfq(int,i,n)
#define nfo(i,a,b) dfo(,i,a,b)
#define nfr(i,n) dfr(,i,n)
#define nfe(i,a,b) dfe(,i,a,b)
#define nfq(i,n) dfq(,i,n)
#define dfo(d,i,a,b) for (d i = (a); i < (b); i++)
#define dfr(d,i,n) dfo(d,i,0,n)
#define dfe(d,i,a,b) for (d i = (a); i <= (b); i++)
#define dfq(d,i,n) dfe(d,i,1,n)
#define ffo(i,a,b) dffo(int,i,a,b)
#define ffr(i,n) dffr(int,i,n)
#define ffe(i,a,b) dffe(int,i,a,b)
#define ffq(i,n) dffq(int,i,n)
#define nffo(i,a,b) dffo(,i,a,b)
#define nffr(i,n) dffr(,i,n)
#define nffe(i,a,b) dffe(,i,a,b)
#define nffq(i,n) dffq(,i,n)
#define dffo(d,i,a,b) for (d i = (b)-1; i >= (a); i--)
#define dffr(d,i,n) dffo(d,i,0,n)
#define dffe(d,i,a,b) for (d i = (b); i >= (a); i--)
#define dffq(d,i,n) dffe(d,i,1,n)
#define ll long long
#define alok(n,t) ((t*)malloc((n)*sizeof(t)))
#define pf printf
#define sf scanf
#define pln pf("\n")

#define inf 111111111111111111ll
struct pr {
	int x, y;
};
int pcomp(const void *aa, const void *bb) {
	pr a = *(pr*)aa;
	pr b = *(pr*)bb;
	if (a.x != b.x) return a.x - b.x;
	return b.y - a.y;
}
int main() {
	int n;
	sf("%d", &n);
	pr *p = alok(n, pr);
	ll miny = inf, maxy = -inf;
	fr(i,n) {
		int t, f;
		sf("%d%d", &t, &f);
		p[i].x = f + t;
		p[i].y = f - t;
		if (miny > p[i].y) miny = p[i].y;
		if (maxy < p[i].y) maxy = p[i].y;
	}
	fr(i,n) p[i].y -= miny;
	maxy -= miny;
	qsort(p, n, sizeof(pr), pcomp);

	int ans = 0;
	maxy++;
	int ht = 1;
	for (int sz = maxy, nsz = sz + 1 >> 1; sz > 1; ht++, sz = nsz, nsz = sz + 1 >> 1);
	int *tr[ht];
	for (int sz = maxy << 1, nsz = sz + 1 >> 1, h = 0; sz > 1; h++, sz = nsz, nsz = sz + 1 >> 1) {
		tr[h] = alok(nsz, int);
		fr(i,nsz) tr[h][i] = 0;
	}
	fr(i,n) {
		int mx = 0;
		for (int h = 0, R = p[i].y; R; h++, R >>= 1) {
			if (R & 1) {
				int vl = tr[h][--R];
				if (mx < vl) mx = vl;
			}
		}
		mx++;
		if (ans < mx) ans = mx;
		for (int h = 0, R = p[i].y; h < ht; h++, R >>= 1) {
			if (tr[h][R] < mx) tr[h][R] = mx; else break;
		}

	}
	pf("%d\n", ans);
}

----------
====================
----------
ALGORITHMS.214
expert
----------
PROBLEM STATEMENT:
Huarongdao is a well-known game in China. The purpose of this game is to move the Cao Cao block out of the board. 

Acme is interested in this game, and he invents a similar game. There is a N*M board. Some blocks in this board are movable, while some are fixed. There is only one empty position. In one step, you can move a block to the empty position, and it will take you one second. The purpose of this game is to move the Cao Cao block to a given position. Acme wants to finish the game as fast as possible. 

But he finds it hard, so he cheats sometimes. When he cheats, he spends K seconds to pick a block and put it in an empty position. However, he is not allowed to pick the Cao Cao block out of the board .

Note 


Immovable blocks cannot be moved while cheating. 
A block can be moved only in the directions UP, DOWN, LEFT or RIGHT. 

----------
TOP SOLUTION:
----------
/******************************************************************************\
*                         Author:  Dumbear                                     *
*                         Email:   dumbear[#at]163.com                         *
*                         Website: http://dumbear.com                          *
\******************************************************************************/
#include <algorithm>
#include <bitset>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <typeinfo>
#include <utility>
#include <vector>

using namespace std;

#define output(x) cout << #x << ": " << (x) << endl;

typedef long long LL;
typedef vector<int> VI;
typedef vector<long long> VL;
typedef vector<double> VD;
typedef vector<string> VS;

const int max_n = 200 + 10, max_m = max_n;
const int delta[][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

int n, m, cheat, q, cost[max_n][max_m][4][4], total[max_n][max_m][4];
char board[max_n][max_m];
map<pair<int, int>, int> cost_map;
bool in[max_n][max_m][4];

void bfs(int x0, int y0, int fx, int fy, int limit) {
    queue<pair<int, int> > q;
    cost_map.clear();
    q.push(make_pair(x0, y0));
    cost_map[q.front()] = 0;
    while (!q.empty()) {
        int x = q.front().first, y = q.front().second, c = cost_map[q.front()];
        q.pop();
        for (int i = 0; i < 4; ++i) {
            int nx = x + delta[i][0], ny = y + delta[i][1];
            if (nx < 0 || nx >= n || ny < 0 || ny >= m || board[nx][ny] == 0 || (nx == fx && ny == fy))
                continue;
            pair<int, int> k(nx, ny);
            if (cost_map.find(k) != cost_map.end())
                continue;
            if (c + 1 < limit)
                q.push(k);
            cost_map[k] = c + 1;
        }
    }
}

void pre_compute() {
    memset(cost, -1, sizeof(cost));
    for (int x0 = 0; x0 < n; ++x0) {
        for (int y0 = 0; y0 < m; ++y0) {
            if (board[x0][y0] == 0)
                continue;
            for (int k = 0; k < 4; ++k) {
                int x1 = x0 + delta[k][0], y1 = y0 + delta[k][1];
                if (x1 < 0 || x1 >= n || y1 < 0 || y1 >= m || board[x1][y1] == 0)
                    continue;
                bfs(x0, y0, x1, y1, cheat - 1);
                for (int step = 0; step < 4; ++step) {
                    int x2 = x1 + delta[step][0], y2 = y1 + delta[step][1];
                    if (x2 < 0 || x2 >= n || y2 < 0 || y2 >= m || board[x2][y2] == 0 || (x2 == x0 && y2 == y0))
                        continue;
                    cost[x0][y0][k][step] = cheat + 1;
                    map<pair<int, int>, int>::iterator it = cost_map.find(make_pair(x2, y2));
                    if (it != cost_map.end())
                        cost[x0][y0][k][step] = it->second + 1;
                }
            }
        }
    }
}

int process() {
    int ex, ey, x0, y0, tx, ty;
    scanf("%d%d%d%d%d%d", &ex, &ey, &x0, &y0, &tx, &ty);
    --ex; --ey; --x0; --y0; --tx; --ty;
    if (x0 == tx && y0 == ty)
        return 0;
    if (ex == x0 && ey == y0)
        return -1;
    bfs(ex, ey, x0, y0, cheat - 1);
    queue<pair<pair<int, int>, int> > q;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            for (int k = 0; k < 4; ++k) {
                in[i][j][k] = false;
                total[i][j][k] = INT_MAX;
            }
        }
    }
    for (int k = 0; k < 4; ++k) {
        int x1 = x0 + delta[k][0], y1 = y0 + delta[k][1];
        if (x1 < 0 || x1 >= n || y1 < 0 || y1 >= m || board[x1][y1] == 0)
            continue;
        q.push(make_pair(make_pair(x0, y0), k));
        in[x0][y0][k] = true;
        total[x0][y0][k] = cheat + 1;
        map<pair<int, int>, int>::iterator it = cost_map.find(make_pair(x1, y1));
        if (it != cost_map.end())
            total[x0][y0][k] = it->second + 1;
    }
    while (!q.empty()) {
        int x0 = q.front().first.first, y0 = q.front().first.second;
        int k = q.front().second, c = total[x0][y0][k];
        q.pop();
        int x1 = x0 + delta[k][0], y1 = y0 + delta[k][1];
        for (int step = 0; step < 4; ++step) {
            if (cost[x0][y0][k][step] == -1)
                continue;
            if (c + cost[x0][y0][k][step] < total[x1][y1][step]) {
                if (!in[x1][y1][step]) {
                    q.push(make_pair(make_pair(x1, y1), step));
                    in[x1][y1][step] = true;
                }
                total[x1][y1][step] = c + cost[x0][y0][k][step];
            }
        }
    }
    int res = INT_MAX;
    for (int x0 = 0; x0 < n; ++x0)
        for (int y0 = 0; y0 < m; ++y0)
            for (int k = 0; k < 4; ++k)
                if (x0 + delta[k][0] == tx && y0 + delta[k][1] == ty)
                    res = min(res, total[x0][y0][k]);
    return res == INT_MAX ? -1 : res;
}

void solve() {
    scanf("%d%d%d%d", &n, &m, &cheat, &q);
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            scanf("%d", &board[i][j]);
    pre_compute();
    for (int i = 0; i < q; ++i)
        printf("%d\n", process());
}

int main() {
    solve();
    return 0;
}

----------
====================
----------
ALGORITHMS.215
hard
----------
PROBLEM STATEMENT:
In the magical kingdom of Kasukabe, people strive to possess skillsets. Higher the number of skillset present among the people, the more content people will be.  

There are [expression]. 

There are [expression] then following transformation can be done by that trainer.

[expression]

Once a transformation is done, both skill is removed from the respective lists. In the above example, if he perform  [expression]. This updated list will be used for further transformations.

Few points to note are:


One person can possess only one skill set.
A wizard can perform zero or more transformation as long as they satisfies the above criteria. 
A person can go through multiple transformation of skill set.
Same class transformation is also possible. That is a person' skill set can be transformed into his current skill set. Eg. [expression] in the above example.


Your goal is to design a series of transformation which results into maximum number of skill set with non-zero number of people knowing it.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <algorithm>

// the maximum number of vertices
#define NN 1000

// adjacency matrix (fill this up)
// If you fill adj[][] yourself, make sure to include both u->v and v->u.
int cap[NN][NN], deg[NN], adj[NN][NN];

// BFS stuff
int q[NN], prev[NN];

int dinic( int n, int s, int t )
{
    int flow = 0;

    // init the adjacency list adj[][] from cap[][]
    memset( deg, 0, sizeof( deg ) );
    for( int u = 0; u < n; u++ )
        for( int v = 0; v < n; v++ ) if( cap[u][v] || cap[v][u] )
            adj[u][deg[u]++] = v;

    while( true )
    {
        memset( prev, -1, sizeof( prev ) );
        int qf = 0, qb = 0;
        prev[q[qb++] = s] = -2;
        while( qb > qf && prev[t] == -1 )
            for( int u = q[qf++], i = 0, v; i < deg[u]; i++ )
                if( prev[v = adj[u][i]] == -1 && cap[u][v] )
                    prev[q[qb++] = v] = u;

        if( prev[t] == -1 ) break;

        for( int z = 0; z < n; z++ ) if( cap[z][t] && prev[z] != -1 )
        {
            int bot = cap[z][t];
            for( int v = z, u = prev[v]; u >= 0; v = u, u = prev[v] )
                bot = std::min(bot, cap[u][v]);
            if( !bot ) continue;

            cap[z][t] -= bot;
            cap[t][z] += bot;
            for( int v = z, u = prev[v]; u >= 0; v = u, u = prev[v] )
            {
                cap[u][v] -= bot;
                cap[v][u] += bot;
            }
            flow += bot;
        }
    }

    return flow;
}

int n,t,k,c;

int main() {
    scanf("%d %d", &n, &t);
    int src = 0;
    int sink = n+t+1;

    for (int i = 1; i <= n; i++) {
        scanf("%d", &c);
        cap[src][i] = c;
        cap[i][sink] = 1;
    }

    for (int i = 1; i <= t; i++) {
        int k;
        for (scanf("%d", &k); k; k--) {
            scanf("%d", &c);
            cap[c][n+i]++;
        }
        for (scanf("%d", &k); k; k--) {
            scanf("%d", &c);
            cap[n+i][c]++;
        }
    }

    printf("%d\n", dinic(n+t+2, src, sink));
}
----------
====================
----------
ALGORITHMS.216
hard
----------
PROBLEM STATEMENT:
During the Steam Summer Sale, Jim's [expression]. The games are multiplayer. Jim has invited his friends to his basement where they will play by making a LAN-Party. 

Each friend has already decided the game he would like to play for the rest of the day. So there will be a group of friends who will play the same game together.

But then, they face a problem: Currently, none of the friends' PCs are connected. So they have to be connected using the available [expression]th wire one by one. So he starts with wire 1, then with wire 2 and so on. 

A group can start playing their game, only if all the members are connected (if not directly, then there must exist a path connecting them). They want to start playing as soon as possible. 

For each game, find out the wire after adding which the group can start playing. It is also possible that a group will never get connected. In such a case, this group starts crying and you should display -1.
----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

struct UnionFind {
	vector<int> data;
	void init(int n) { data.assign(n, -1); }
	bool unionSet(int x, int y) {
		x = root(x); y = root(y);
		if(x != y) {
			if(data[y] < data[x]) swap(x, y);
			data[x] += data[y]; data[y] = x;
		}
		return x != y;
	}
	bool findSet(int x, int y) { return root(x) == root(y); }
	int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }
	int size(int x) { return -data[root(x)]; }
};

int main() {
	int N, M, Q;
	scanf("%d%d%d", &N, &M, &Q);
	vector<int> A(N), cnt(M);
	rep(i, N) {
		scanf("%d", &A[i]), -- A[i];
		++ cnt[A[i]];
	}
	vector<map<int,int> > a(N);
	rep(i, N)
		a[i][A[i]] = 1;
	vector<int> ans(M, -1);
	rep(i, M) if(cnt[i] <= 1)
		ans[i] = 0;
	UnionFind uf;
	uf.init(N);
	rep(i, Q) {
		int u, v;
		scanf("%d%d", &u, &v), -- u, -- v;
		int ur = uf.root(u);
		int vr = uf.root(v);
		if(ur != vr) {
			uf.unionSet(ur, vr);
			int zr = uf.root(ur);
            if(ur != zr && vr != zr) { cerr << "error!" << endl; abort(); }
			map<int,int> &za = a[zr], &wa = a[zr == ur ? vr : ur];
			if(za.size() < wa.size())
				za.swap(wa);
			each(j, wa) {
				int k = j->first;
				if((za[k] += j->second) == cnt[k] && ans[k] == -1)
					ans[k] = i + 1;
			}
			wa.clear();
		}
	}
	rep(i, M)
		printf("%d\n", ans[i]);
	return 0;
}

----------
====================
----------
ALGORITHMS.217
hard
----------
PROBLEM STATEMENT:
HackerLand is a country with [expression] undirected roads. Like every other beautiful country, HackerLand has traffic jams.

Each road has a crowd value. The crowd value of a path is defined as the maximum crowd value for all roads in the path. For example, if the crowd values for all roads are [expression].

Each city [expression], denoting the type of buildings in the city.

David just started his vacation in HackerLand. He wants to travel from city [expression] different types of buildings along the path, David always selects the one with the minimum crowd value.

You will be given [expression] different buildings along the route. If there is no such path, print -1.

Note: A path may contain cycles (i.e., the same roads or cities may be traveled more than once).
----------
TOP SOLUTION:
----------
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<set>
#include<map>
#include<queue>
#include<cassert>
#define PB push_back
#define MP make_pair
#define sz(v) (in((v).size()))
#define forn(i,n) for(in i=0;i<(n);++i)
#define forv(i,v) forn(i,sz(v))
#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)
#define all(v) (v).begin(),(v).end()
using namespace std;
typedef long long in;
typedef vector<in> VI;
typedef vector<VI> VVI;
VI ans;
struct rsp{
  in gl,gsz,id;
  rsp(in a=0, in b=0, in c=0){
    gl=a;
    gsz=b;
    id=c;
  }
  bool operator<(const rsp cp)const{
    if(gl!=cp.gl)
      return gl<cp.gl;
    if(gsz!=cp.gsz)
      return gsz<cp.gsz;
    return id<cp.id;
  }
};
struct onc{
  in gsz,id;
  onc(in a=0, in b=0){
    gsz=a;
    id=b;
  }
  bool operator<(const onc cp)const{
    if(gsz!=cp.gsz)
      return gsz<cp.gsz;
    return id<cp.id;
  }
};
in crsz;
struct unifnd{
  VI ht,pr;
  vector<set<onc> > oncs;
  vector<set<rsp> > rsps;
  vector<set<in> > blg,blgtyp;
  in fnd(in a){
    in ta=a;
    while(a!=pr[a])a=pr[a];
    in tt=ta;
    while(ta!=a){
      tt=pr[ta];
      pr[ta]=a;
      ta=tt;
    }
    return a;
  }
  void uni(in a, in b){
    a=fnd(a);
    b=fnd(b);
    if(a==b)return;
    if(ht[b]<ht[a])swap(a,b);
    ht[b]+=ht[a];
    pr[a]=b;
    fors(i,blg[a]){
      blg[b].insert(*i);
    }
    fors(i,blgtyp[a]){
      blgtyp[b].insert(*i);
    }
    fors(i,rsps[a]){
      if(blg[b].find(i->gl)!=blg[b].end()){
	oncs[b].insert(onc(i->gsz,i->id));
      }
      else{
	rsps[b].insert(*i);
      }
    }
    auto it=oncs[b].begin();
    for(auto i=oncs[b].begin();i!=oncs[b].end();){
      if(i->gsz<=sz(blgtyp[b])){
	if(ans[i->id]==-1)
	  ans[i->id]=crsz;
	it=i;
	++i;
	oncs[b].erase(it);
	continue;
      }
      break;
    }
    fors(i,oncs[a]){
      if(ans[i->id]!=-1)
	continue;
      if(i->gsz<=sz(blgtyp[b])){
	ans[i->id]=crsz;
      }
      else{
	oncs[b].insert(*i);
      }
    }
  }
  void ini(in n){
    ht.resize(n);
    pr.resize(n);
    blg.resize(n);
    oncs.resize(n);
    rsps.resize(n);
    blgtyp.resize(n);
    forn(i,n){
      ht[i]=1;
      pr[i]=i;
      blg[i].insert(i);
    }
  }
};
unifnd tfd;
map<in,vector<pair<in,in> > > egs;
int main(){
  ios::sync_with_stdio(0);
  cin.tie(0);
  in n,m,q;
  cin>>n>>m>>q;
  ans.resize(q,-1);
  tfd.ini(n);
  in ta,tb,tu;
  crsz=0;
  forn(z,n){
    cin>>tu;
    tfd.blgtyp[z].insert(tu);
  }
  forn(z,m){
    cin>>ta>>tb>>tu;
    --ta;
    --tb;
    egs[tu].PB(MP(ta,tb));
  }
  forn(z,q){
    cin>>ta>>tb>>tu;
    --ta;
    --tb;
    if(ta==tb){
      if(tu==1){
	ans[z]=0;
	continue;
      }
      ++tfd.ht[ta];
      tfd.oncs[ta].insert(onc(tu,z));
      continue;
    }
    ++tfd.ht[ta];
    ++tfd.ht[tb];
    tfd.rsps[ta].insert(rsp(tb,tu,z));
    tfd.rsps[tb].insert(rsp(ta,tu,z));
  }
  fors(i,egs){
    crsz=i->first;
    forv(j,i->second){
      tfd.uni(i->second[j].first,i->second[j].second);
    }
  }
  forn(z,q){
    cout<<ans[z]<<"\n";
  }
  return 0;
}

----------
====================
----------
ALGORITHMS.218
expert
----------
PROBLEM STATEMENT:
In order to entertain themselves during the long flight, Alex and Fedor invented the following very simple two players game. The game is:  


First, Alex draws some graph with bidirectional weighted edges. There are possibly multiple edges (probably, with different or same weights) in this graph.
Then Fedor picks some spanning tree of this graph. If the tree appears to be the minimal spanning tree, then the winner is Fedor. Otherwise, the winner is Alex.  


We consider two trees different if the sets of the numbers of edges that are included in these trees are different. We consider two sets [expression] or vice versa.  

We should also mention that the graphs with enormous number of spanning trees upset Alex, as well as Fedor, so they will never have a graph that has more than [expression] spanning trees.  

At some point, Fedor became too lazy to look for minimal spanning trees and now he just picks some arbitrary spanning tree from the Alex's graph. Each spanning tree has equal probability to be picked by Fedor. What is the probability of Fedor's victory now?   
----------
TOP SOLUTION:
----------
	/**
	* BE CAREFUL!! I have define int li
	*/

	//#define _GLIBCXX_DEBUG

	#include <stdio.h>
	#include <iostream>
	#include <string>
	#include <vector>
	#include <algorithm>
	#include <queue>
	#include <deque>
	#include <cmath>
	#include <ctime>
	#include <stack>
	#include <set>
	#include <bitset>
	#include <map>
	#include <cassert>
	#include <memory.h>
	#include <limits>
	#include <numeric>
	using namespace std;

	int timer;

	#define mp make_pair
	#define pb push_back
	#define all(a) a.begin(), a.end()

	typedef long long li;
	typedef long double ld;
	typedef vector<int> vi;
	typedef pair <int, int> pi;

	void solve();

	void prec();

	vector<vector<long long int>> removed(vector<vector<li>> vector);


	li det(vector<vector<long long int>> vector);

	#define FILENAME "souvenir"

	int main(){
		string s = FILENAME;
	#ifdef DEBUG
		freopen("/Users/RiaD/Contests/Contests/input", "r", stdin);
		//freopen("/Users/RiaD/Contests/Contests/output", "w", stdout);
		//cout<<FILENAME<<endl;
		//assert (s != "change me please");
		clock_t start = clock();
	#else
	    //freopen(FILENAME ".in", "r", stdin);
	    //freopen(FILENAME ".out", "w", stdout);
	#endif
		cout.sync_with_stdio(0);
		cout.precision(20);
		cout << fixed;
		//rprec();
		int t = 1;
		//cin >> t;
		while (t--) {
			++timer;
			solve();
		}
	#ifdef DEBUG
		//cerr<<"\n\n"<<(clock() - start) / 1.0 / CLOCKS_PER_SEC<<"\n\n\n";
	#endif
		return 0;
	}


	typedef vector<li> vli;

	vector<vector<long long int>> removed(vector<vli> v) {
		v.pop_back();
		for(int i = 0; i < v.size(); ++i) {
			v[i].pop_back();
		}
		return v;
	}


	int dsu[110];

	int get(int v) {
		if(v == dsu[v])
			return v;
		return dsu[v] = get(dsu[v]);
	}

	void unite(int a, int b) {
		a = get(a);
		b = get(b);
		dsu[a] = b;
	}


	void solve() {
		int n, m;
		cin >> n >> m;
		for(int i = 0; i < n; ++i) {
			dsu[i] = i;
		}
		vector<vector<li>> mat(n, vector<li>(n, 0));
		vector<pair<li, pi>> v;
		for(int i = 0; i < m; ++i) {
			li a, b, w;
			cin >> a >> b >> w;
			--a, --b;
			--mat[a][b];
			--mat[b][a];
			++mat[a][a];
			++mat[b][b];
			v.push_back(mp(w, mp(a,b)));
		}

		li all = det(removed(mat));


		sort(v.begin(), v.end());

		li msts = 1;

		for(int i = 0; i < m;) {
			//cout << "edges with w=" << v[i].first << "\n";
			int j;
			vector<pi> edges;
			for(j = i; v[i].first == v[j].first; ++j) {
				//cout << get(v[j].second.first) << " " << get(v[j].second.second) << "\n";
				edges.push_back(mp(get(v[j].second.first), get(v[j].second.second)));
			}
			for(j = i; v[i].first == v[j].first; ++j) {
				unite(v[j].second.first, get(v[j].second.second));
			}
			map<int, vector<pi>> ng2edgesInIt;
			for(pi& x: edges) {
				ng2edgesInIt[get(x.first)].push_back(x);
			}
			for(auto& x: ng2edgesInIt) {
				map<int, int> toIds;
				for(auto& y: x.second) {
					if(!toIds.count(y.first)) {
						int cnt = toIds.size();
						toIds[y.first] = cnt;
					}
					if(!toIds.count(y.second)) {
						int cnt = toIds.size();
						toIds[y.second] = cnt;
					}

				}

				vector<vli> matr (toIds.size(), vli(toIds.size()));
				for(auto y: x.second) {
					y.first = toIds[y.first];
					y.second = toIds[y.second];
					matr[y.first][y.second]--;
					matr[y.second][y.first]--;
					matr[y.first][y.first]++;
					matr[y.second][y.second]++;
				}
				msts *= det(removed(matr));
			}
			i = j;

		}

		li g = __gcd(msts, all);
		cout << (msts/g) << "/" << (all/g);

	}

	li det(vector<vli> mat) {
		int n = mat.size();
		if(n == 0)
			return 1;


		for(int col = 0; col < n; ++col) {
			bool found = false;
			for(int row = col; row < n; ++row) {
				if(mat[row][col]) {
					mat[row].swap(mat[col]);
					found = true;
					break;
				}
			}
			if(!found) {
				return 0;
			}
			for(int row = col + 1; row < n; ++row) {
				while(true) {
					li del = mat[row][col] / mat[col][col];
					for (int j = col; j < n; ++j) {
						mat[row][j] -= del * mat[col][j];
					}
					if (mat[row][col] == 0)
						break;
					else
						mat[row].swap(mat[col]);
				}
			}
		}

		li res = 1;

		for(int i = 0; i < n; ++i) {
			res *= mat[i][i];
		}
		return abs(res);
	}


----------
====================
----------
ALGORITHMS.219
expert
----------
PROBLEM STATEMENT:
You have a rooted tree with [expression]. 

You are given [expression]. 

You have to select a subset of the paths such that the sum of path costs is maximum and the [expression] paths from the subset. Print the sum as the output.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define trav(a, x) for (auto& a : x)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
void PR(vi &v) { trav(x, v) cout << x << ' '; cout << endl; }

typedef double T;
typedef vector<T> vd;
typedef vector<vd> vvd;

const T eps = 1e-8, inf = 1/.0;
#define MP make_pair
#define ltj(X) if(s == -1 || MP(X[j],N[j]) < MP(X[s],N[s])) s=j

struct LPSolver {
	int m, n;
	vi N, B;
	vvd D;

	LPSolver(const vvd& A, const vd& b, const vd& c) :
		m(sz(b)), n(sz(c)), N(n+1), B(m), D(m+2, vd(n+2)) {
			rep(i,0,m) rep(j,0,n) D[i][j] = A[i][j];
			rep(i,0,m) { B[i] = n+i; D[i][n] = -1; D[i][n+1] = b[i];}
			rep(j,0,n) { N[j] = j; D[m][j] = -c[j]; }
			N[n] = -1; D[m+1][n] = 1;
		}

	void pivot(int r, int s) {
		T inv = 1.0 / D[r][s];
		rep(i,0,m+2) if (i != r)
			rep(j,0,n+2) if (j != s)
				D[i][j] -= D[r][j] * D[i][s] * inv;
		rep(j,0,n+2) if (j != s) D[r][j] *= inv;
		rep(i,0,m+2) if (i != r) D[i][s] *= -inv;
		D[r][s] = inv;
		swap(B[r], N[s]);
	}

	bool simplex(int phase) {
		int x = m + phase - 1;
		for (;;) {
			int s = -1;
			rep(j,0,n+1) if (N[j] != -phase) ltj(D[x]);
			if (D[x][s] >= -eps) return true;
			int r = -1;
			rep(i,0,m) {
				if (D[i][s] <= eps) continue;
				if (r == -1 || MP(D[i][n+1] / D[i][s], B[i])
				             < MP(D[r][n+1] / D[r][s], B[r])) r = i;
			}
			if (r == -1) return false;
			pivot(r, s);
		}
	}

	T solve(vd &x) {
		int r = 0;
		rep(i,1,m) if (D[i][n+1] < D[r][n+1]) r = i;
		if (D[r][n+1] <= -eps) {
			pivot(r, n);
			if (!simplex(2) || D[m+1][n+1] < -eps) return -inf;
			rep(i,0,m) if (B[i] == -1) {
				int s = 0;
				rep(j,1,n+1) ltj(D[i]);
				pivot(i, s);
			}
		}
		bool ok = simplex(1); x = vd(n);
		rep(i,0,m) if (B[i] < n) x[B[i]] = D[i][n+1];
		return ok ? D[m][n+1] : inf;
	}
};

vi pars;
vi dup;
void rec(vector<vector<pii>>& ed, int at, int par, int dval) {
	pars[at] = par;
	dup[at] = dval;
	trav(x, ed[at]) {
		if (x.first == par) continue;
		rec(ed, x.first, at, x.second);
	}
}

void solve() {
	int N, M;
	cin >> N >> M;
	vector<vector<pii>> ed(N);
	rep(i,0,N-1) {
		int a, b, d;
		cin >> a >> b >> d;
		--a, --b;
		ed[a].emplace_back(b, d);
		ed[b].emplace_back(a, d);
	}
	pars.resize(N);
	dup.resize(N);
	rec(ed, 0, -1, -1);
	vvd A(M+N-1, vd(M));
	vd C(M), X(M), B(M+N-1);
	rep(i,0,M) A[i][i] = 1, B[i] = 1;
	rep(i,0,N-1) B[M+i] = dup[i+1];
	rep(i,0,M) {
		int u, v, c;
		cin >> u >> v >> c;
		--u, --v;
		while (u != v) {
			A[M + v - 1][i] = 1;
			v = pars[v];
		}
		C[i] = c;
	}
	double res = LPSolver(A, B, C).solve(X);
	cout << (ll)round(res) << endl;
}

int main() {
	cin.sync_with_stdio(false);
	cin.exceptions(cin.failbit);
	int N;
	cin >> N;
	rep(i,0,N) {
		solve();
	}
}

----------
====================
----------
ALGORITHMS.220
expert
----------
PROBLEM STATEMENT:
HackerRank is starting a bus service in MountainView, California. The bus starts at time T = 0 at station1 and goes through station2, station3, station4 in that order and reaches the headquarters located at stationn. At every station, the bus waits for various commuters to arrive before it departs to the next station. Ignoring the acceleration, the bus moves at 1 meter / second. i.e., if stationi and stationj are 1000 meters apart, the bus takes 1000 seconds to travel from stationi to stationj. 

The bus is equipped with K units of Nitro (N2O). If going from stationi to stationj takes x seconds, then using t units of nitro can decrease the time taken to max(x-t, 0) seconds where max(a,b) denotes the greater of the two values between a & b. The Nitro can be used all at once or in multiples of 1 unit. 

If the bus driver travels optimally, what is the minimum sum of travelling time for all commuters? The travelling time equals to the time he/she arrived at the destination minus the time he/she arrived the start station. 

Please remember that the driver must take all passengers to their destination.  
----------
TOP SOLUTION:
----------
#include <iostream>
#include <queue>
#include <cmath>
#include <vector>
#include <algorithm>

using namespace std;

int n, m, k;
int dist[100100];
int late[100100];
int bin[100100];
int bout[100100];
int arrival[100100];
vector<long long> peop[100100];
long long ans;


void gen() {
    cout << 100 << " " << 100 << " " << 1000 << endl;
    for(int i = 0; i < 99; ++i) {
        cout << rand() % 1000 << " ";
    }
    for(int i = 0; i < 100; ++i) {
        int y = rand() % 100 + 1, x = rand() % y;
        cout << rand() % (x * 1000 + 100) << " " << x << " " << y << endl;
    }
    exit(0);
}


struct st {
    int i, j;
    long long saved;
    int spend;
    st(int i, int j, long long saved, int spend) : i(i), j(j), saved(saved), spend(spend) {}
    bool operator < (st a) const {
        if (saved != a.saved) {
            return saved < a.saved;
        }
        return spend < a.spend;
    }
};

priority_queue<st> q;

int add(int i) {
    if (i == n) return n;
    int spend = 1000000000;
    int j = i + 1;
    if (dist[i]) {
        spend = min(spend, dist[i]);
        long long saved = 0;
        for(j = i + 1; j <= n; ++j) {
            --arrival[j];
            saved += bout[j];
            if (late[j] > arrival[j]) {
                break;
            }
            spend = min(spend, arrival[j] - late[j] + 1);
        }
        if (j > n) j = n;
        //cout << i << " = " << j << endl;
        st w(i, j, saved, spend);
        q.push(w);
        for(int q = i + 1; q <= j; ++q) {
            ++arrival[q];
        }
    }
    return j;
}

int main() {
    //gen();
    cin >> n >> m >> k;
    --n;
    for(int i = 0; i < n; ++i) {
        cin >> dist[i];
    }
    for(int i = 0; i < m; ++i) {
        int t, s, e;
        cin >> t >> s >> e;
        --s;
        --e;
        late[s] = max(late[s], t);
        ++bout[e];
        peop[s].push_back(t);
    }
    late[n] = -1000000000;

    long long nowt = 0, carry = 0;
    for(int i = 0; i < n; ++i) {
        arrival[i] = nowt;
        for(int j = 0; j < peop[i].size(); ++j) {
            if (peop[i][j] < nowt) {
                ans += nowt - peop[i][j];
            } else {
                ans += carry * (peop[i][j] - nowt);
            }
            ++carry;
            nowt = max(peop[i][j], nowt);
        }
        ans += carry * dist[i];
        nowt += dist[i];
        carry -= bout[i + 1];
    }
    arrival[n] = nowt;

    int cur = 0;
    while(cur < n) {
        cur = add(cur);
    }

    while(k && !q.empty()) {

        st w = q.top();
        q.pop();
        if (w.spend >= k) 
        {
            ans -= w.saved * k;
            break;
        }ans -= w.saved * w.spend;
        k -= w.spend;
        dist[w.i] -= w.spend;
        for(int i = w.i + 1; i <= w.j; ++i) {
            arrival[i] -= w.spend;
        }

        int x = w.i;
        while(x < w.j) 
        {
            x = add(x);
        }
    }
    cout << ans << endl;
    return 0;
}
----------
====================
----------
ALGORITHMS.221
expert
----------
PROBLEM STATEMENT:
The travelling salesman has a map containing m*n squares. He starts from the top left corner and visits every cell exactly once and returns to his initial position (top left). The time taken for the salesman to move from a square to its neighbor might not be the same. Two squares are considered adjacent if they share a common edge and the time taken to reach square b from square a and vice-versa are the same. Can you figure out the shortest time in which the salesman can visit every cell and get back to his initial position? 
----------
TOP SOLUTION:
----------
//Template
#include <cstdio>
#include <climits>
#include <iostream>
#include <map>
using namespace std;

#define N 10
int n, m, now = 0, hor[N + 1][N + 1], ver[N + 1][N + 1];
map <int, int> h[2];
map <int, int> :: iterator it;

inline int get(int x, int p) {				//get state of pos p from right
	return x >> (p - 1 << 1) & 3;
}

inline int Set(int v, int p) {
	return v << (p - 1 << 1);
}

inline void update(int x, int v) {
	if (h[now].find(x) == h[now].end()) h[now][x] = v;
	else h[now][x] = min(h[now][x], v);
}

void decrypt(int x) {
	for (int i = 1; i <= m + 1; ++i) {
		int a = x & 3;
		if (a == 0) printf("#");
		else if (a == 1) printf("(");
		else if (a == 2) printf(")");
		x >>= 2;
	}
}

int main() {
#ifdef KANARI
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
#endif
	
	cin >> n >> m;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j < m; ++j)
			cin >> hor[i][j];
	for (int i = 1; i < n; ++i)
		for (int j = 1; j <= m; ++j)
			cin >> ver[i][j];
	
	int ans = INT_MAX;
	h[now][0] = 0;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			now ^= 1;
			h[now].clear();
			for (it = h[now ^ 1].begin(); it != h[now ^ 1].end(); ++it) {
				int x = it->first, v = it->second;
//				printf("i=%d j=%d ", i, j);
//				decrypt(x);
//				printf(" x=%d v=%d\n", x, v);
				if (j == 1) x <<= 2;
				int a = get(x, j), b = get(x, j + 1);
				if (a == 0 && b == 0) {
					if (i < n && j < m)
						update(x + Set(1, j) + Set(2, j + 1), v);
				} else if (a == 0 && b != 0) {
					if (j < m) update(x, v + ver[i - 1][j]);
					if (i < n) update(x - Set(b, j + 1) + Set(b, j), v + ver[i - 1][j]);
				} else if (a != 0 && b == 0) {
					if (i < n) update(x, v + hor[i][j - 1]);
					if (j < m) update(x - Set(a, j) + Set(a, j + 1), v + hor[i][j - 1]);
				} else if (a == 1 && b == 1) {
					int k = 0, p = j + 1, c;
					while (k < 1) {
						c = get(x, ++p);
						if (c == 1) --k;
						else if (c == 2) ++k;
					}
					update(x - Set(1, j) - Set(1, j + 1) - Set(1, p), v + hor[i][j - 1] + ver[i - 1][j]);
				} else if (a == 2 && b == 2) {
					int k = 0, p = j, c;
					while (k < 1) {
						c = get(x, --p);
						if (c == 1) ++k;
						else if (c == 2) --k;
					}
					update(x - Set(2, j) - Set(2, j + 1) + Set(1, p), v + hor[i][j - 1] + ver[i - 1][j]);
				} else if (a == 1 && b == 2) {
					if (i == n && j == m) ans = min(ans, v + hor[i][j - 1] + ver[i - 1][j]);
				} else if (a == 2 && b == 1) {
					update(x - Set(2, j) - Set(1, j + 1), v + hor[i][j - 1] + ver[i - 1][j]);
				}
			}
		}
	
	if (ans == INT_MAX) cout << 0 << endl;
	else cout << ans << endl;
	
	fclose(stdin);
	fclose(stdout);
	return 0;
}

----------
====================
----------
ALGORITHMS.222
expert
----------
PROBLEM STATEMENT:
 Chinese  

Fedor is a research scientist, who has recently found a road map of Ancient Berland.

Ancient Berland consisted of N cities that were connected by M bidirectional roads. The road builders weren't knowledgable. Hence, the start city and the end city for each road were always chosen randomly and independently. As a result, there were more than one road between some pairs of cities. Nevertheless, by luck, the country remained connected (i.e. you were able to get from one city to another via these M roads). And for any road, the start and the end city were not the same.

Moreover, each road had it's own value of importance. This value was assigned by the Road Minister of Ancient Berland. The Road Minister also was not knowledgable, so these numbers were assigned to the roads randomly and independently from the other roads.

When there was a war with the neighboring countries (usually it was with Ancient Herland), it was important to estimate separation number for some pairs of cities.

The separation number for a pair of cities - let's call these cities A and B - is explained below: 

Consider a set of roads that were built. The subset of this set is good, if after removing all roads from this set, there's no longer a way from A to B. The minimal possible sum of roads' value of importance of any good subset is a separation number for the pair of cities (A, B).

For a research, Fedor would like to know the product of separation values over all unordered pairs of cities. Please, find this number. It can be huge, so we ask you to output its product modulo 109+7.
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(int *x, int *y){reader(x);reader(y);}
void reader(int *x, int *y, int *z){reader(x);reader(y);reader(z);}
void writer(int x, char c){int i,sz=0,m=0;char buf[10];if(x<0)m=1,x=-x;while(x)buf[sz++]=x%10,x/=10;if(!sz)buf[sz++]=0;if(m)mypc('-');while(sz--)mypc(buf[sz]+'0');mypc(c);}

#define ll long long
#define MD 1000000007

#define INT_INF 1000000000
#define MAX(a,b) (((a)>(b))?(a):(b))
#define MIN(a,b) (((a)<(b))?(a):(b))

#define INT_LIST_MAX_FLOW_NODE 602
int intLmfEdge[INT_LIST_MAX_FLOW_NODE][INT_LIST_MAX_FLOW_NODE];
int intLmfFlow[INT_LIST_MAX_FLOW_NODE][INT_LIST_MAX_FLOW_NODE];
int intLmfInv[INT_LIST_MAX_FLOW_NODE][INT_LIST_MAX_FLOW_NODE];
int intLmfEdgeSize[INT_LIST_MAX_FLOW_NODE],intLmfEdgeMemory[INT_LIST_MAX_FLOW_NODE];
int intLmfLevel[INT_LIST_MAX_FLOW_NODE];

void intListMaxFlowLevelize(int n,int st,int ed){
  int i,j,k,t;
  int q[INT_LIST_MAX_FLOW_NODE],q_st,q_size;
  rep(i,n) intLmfLevel[i]=-1; intLmfLevel[st]=0; q_st=0; q_size=1; q[0]=st;
  while(q_size){
    i=q[q_st++]; q_size--; t=intLmfLevel[i]+1;
    rep(j,intLmfEdgeSize[i]) if(intLmfFlow[i][j]){
      k=intLmfEdge[i][j]; if(intLmfLevel[k]!=-1) continue;
      intLmfLevel[k]=t; q[q_st+q_size++]=k; if(k==ed) return;
    }
  }
}

int intListMaxFlowFlow(int i,int ed,int lim){
  int j,k,ret=0,t,s,ji;
  if(i==ed) return lim;
  rep(j,intLmfEdgeSize[i]) if(intLmfFlow[i][j]){
    k=intLmfEdge[i][j]; if(intLmfLevel[k]<=intLmfLevel[i]) continue;
    s=lim; if(s>intLmfFlow[i][j]) s=intLmfFlow[i][j];
    t=intListMaxFlowFlow(k,ed,s); if(!t) continue;
    ret+=t; lim-=t; ji=intLmfInv[i][j];
    intLmfFlow[i][j]-=t; intLmfFlow[k][ji]+=t;
    if(!lim) break;
  }
  return ret;
}

int intListMaxFlow(int n,int st,int ed){
  int ret=0;
  for(;;){
    intListMaxFlowLevelize(n,st,ed); if(intLmfLevel[ed]==-1) break;
    ret += intListMaxFlowFlow(st,ed,INT_INF);
  }
  return ret;
}

void intListMaxFlowEdgeInit(){
  int i;
  rep(i,INT_LIST_MAX_FLOW_NODE) intLmfEdgeSize[i]=0;
}

void intListMaxFlowEdgeInitAdv(int n){
  int i;
  rep(i,n) intLmfEdgeSize[i]=0;
}

void intListMaxFlowEdgeAdd(int n1,int n2,int f1,int f2){
  int s1=intLmfEdgeSize[n1]++, s2=intLmfEdgeSize[n2]++;
  intLmfEdge[n1][s1]=n2; intLmfEdge[n2][s2]=n1;
  intLmfFlow[n1][s1]=f1; intLmfFlow[n2][s2]=f2;
  intLmfInv[n1][s1]=s2;  intLmfInv[n2][s2]=s1;
}

void intListMaxFlowDfs(int node,int start,int res[]){
  int i,j,k;
  int st[INT_LIST_MAX_FLOW_NODE], st_size=0;

  rep(i,node) res[i]=0; res[start]=1; st[st_size++]=start;
  while(st_size){
    i=st[--st_size];
    rep(k,intLmfEdgeSize[i]) if(intLmfFlow[i][k]){
      j=intLmfEdge[i][k]; if(res[j]) continue;
      res[j]=1; st[st_size++]=j;
    }
  }
}



/* Gomory-Hu's Algorithm ? */
/* int edge[][]????Flow???????edge[i][j]=edge[j][i] */
/* int res[][]????2???max-flow????? */

int edge[600][600], res[600][600];

void intMaxflowAnyPairOfNode(int node,void *WorkMemory){
  int i,j,a,b,flow;
  int *p, *fst;

  p=(int*)WorkMemory; WorkMemory=(void*)(p+node);
  fst=(int*)WorkMemory;

  rep(i,node) p[i]=0;
  rep(i,node) rep(j,node) res[i][j]=INT_INF;

  REP(i,1,node){
    intListMaxFlowEdgeInitAdv(node);
    rep(a,node) REP(b,a+1,node) if(edge[a][b]) intListMaxFlowEdgeAdd(a,b,edge[a][b],edge[b][a]);
    flow = intListMaxFlow(node,i,p[i]);
    intListMaxFlowDfs(node,i,fst);
    REP(j,i+1,node) if(fst[j] && p[i]==p[j]) p[j]=i;
    res[i][p[i]]=res[p[i]][i]=flow;
    rep(j,i) res[i][j]=res[j][i]=MIN(flow,res[p[i]][j]);
  }
}

int main(){
  int i, j, k, M, N;
  ll ans;
  void *mem=malloc(100000000);

  reader(&N, &M);
  rep(i,N) rep(j,N) edge[i][j] = 0;
  while(M--){
    reader(&i,&j,&k);
    i--; j--;
    edge[i][j] += k;
    edge[j][i] += k;
  }
  intMaxflowAnyPairOfNode(N, mem);

  ans = 1;
  rep(i,N) REP(j,i+1,N) ans = (ans * res[i][j]) % MD;
  writer((int)ans, '\n');

  return 0;
}

----------
====================
----------
ALGORITHMS.223
expert
----------
PROBLEM STATEMENT:
Ms.Kox enjoys her job, but she does not like to waste extra time traveling to and from her office. After working for many years, she knows the shortest-distance route to her office on a regular day.

Recently, the city began regular maintenance of various roads. Every day a road gets blocked and no one can use it that day, but all other roads can be used. You are Ms. Kox's new intern and she needs some help. Every day, you need to determine the minimum distance that she has to travel to reach her office.
----------
TOP SOLUTION:
----------
#include <queue>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <string.h>
#include <cassert>

using namespace std;

#define rep(i,a,b) for(__typeof(a) i=(a);i<(b);i++)
#define ll long long int
#define ii pair<int,int>
#define CLEAR(x,val) memset(x,val,sizeof(x))
#define SZ(v) (v).size()
#define MAX 100009
#define inf 1e9

/******** Data Structure ************/
int dist[2][MAX];
int pre [2][MAX];

vector< vector<int> > vv(MAX) , cost(MAX);
vector< vector<int> > tr(MAX) , trc(MAX);

/********* ititialize **************/
void reset() {
	rep( i , 0 , 2 ) rep( j , 0 , MAX ) dist[i][j] = inf; 
	CLEAR( pre , -1 );
	rep( i , 0 , MAX ) vv[i].clear() , cost[i].clear();
	rep( i , 0 , MAX ) tr[i].clear() , trc[i].clear();
}

/********Dijkstra *****************/
void DIJ( int src , int id ) {
	rep( i , 0 , MAX ) dist[id][i] = inf;
	dist[id][src] = 0;
	priority_queue< ii , vector<ii> , greater<ii> > Q;
	ii tmp = make_pair( 0 , src );
	Q.push(tmp);

	while( !Q.empty()  ) {
		tmp = Q.top();Q.pop();
		int w = tmp.first , u = tmp.second;
		int sz = vv[u].size();		

		rep( i , 0 , sz ) {		
			int v = vv[u][i] , cst = cost[u][i];
			if( dist[id][v] > w+cst ) {
				dist[id][v] = w + cst;
				pre[id][v]  = u;
				ii newp = make_pair( dist[id][v] , v );
				Q.push(newp);
			}	
		}
	}
}

/*****Data structure for Query part ***********/
typedef struct edge {
	int u , v , w;
	bool friend operator < ( const edge &A , const edge &B ) {
		return A.w > B.w;
	}
}edge;
edge array[MAX];

priority_queue< edge > Heap[MAX];
int label[MAX] , minl[MAX] , maxl[MAX];
int counter;
/********* tree labeling **********************/
void DFS( int src ) {
	int sz = tr[src].size();minl[src] = counter;
        rep( i , 0 , sz ) {
		int v = tr[src][i];
		DFS( v );
	}
	label[src] = counter;
	maxl[src]  = counter;
	counter++;
}
/*****MMG Algorithm****************************/
void replace( int src ) {
		
	int sz = tr[src].size();
	rep( i , 0 , sz ) {
		int v = tr[src][i];
		replace( v ); 
		while(!Heap[v].empty()) {
			Heap[src].push(Heap[v].top());Heap[v].pop();
		}
	}
	while(!Heap[src].empty()) {	
		edge e = Heap[src].top();Heap[src].pop();
		int u = e.u , v = e.v , w = e.w; 

		if( (label[u] >= minl[src] && label[u] <= maxl[src] ) && !(label[v] >= minl[src] && label[v] <= maxl[src] ) ) {
			array[src] = e;Heap[src].push(e);break;
		}
		else if(!(label[u] >= minl[src] && label[u] <= maxl[src] ) && (label[v] >= minl[src] && label[v] <= maxl[src] )) {
			array[src] = e;Heap[src].push(e);break;
		}
	}
}
int main()
{
	reset();
	int n , m;
	scanf("%d %d" , &n , &m);
	
	assert( n < 200000 && m < 200000 && n > 0 && m > 0 );
	

	rep( i , 0  , m ) {
		int u , v , w;scanf("%d %d %d" , &u , &v , &w );
	
	
		assert( u >= 0 && u < n );assert( v >= 0 && v < n );assert( u != v );	
		assert( w <= 1000 );
	
		vv[u].push_back(v);cost[u].push_back(w);
		vv[v].push_back(u);cost[v].push_back(w);
	}
	
	int S , T;
	scanf("%d %d" , &S , &T );


	assert( S >= 0 && S < n );assert( T >= 0 && T < n );

	DIJ( S , 0 );
	DIJ( T , 1 );
	

	map<ii,int> mp;mp.clear();
	rep( i , 0 , n ) {
		if( pre[0][i] != -1 ) { 
			tr[pre[0][i]].push_back(i); 
			mp[make_pair( i , pre[0][i])] = 1;
			mp[make_pair( pre[0][i] , i)] = 1;
		}
	}
	
	// After shortest path
	counter = 1;
	DFS( S ); 
/*	DFS labeling for fining cut
	rep( i , 0 , n ) {
		cout << label[i] <<" " <<  minl[i] << " " << maxl[i] << "\n";
	}
*/
	rep( i , 0 , n ) array[i].w = inf; 
	rep( i , 0 , n ) {	
		int sz = vv[i].size();
		rep( j , 0 , sz ) {
			int v = vv[i][j] , w = cost[i][j];
			if( !mp[make_pair( i ,v )] ) {
					edge e = (edge){ i , v , dist[0][i]+w+dist[1][v] };
					Heap[v].push(e);			
			}
		}
	}
	replace(S);
	// Query Part
	mp.clear();
	rep( i , 0 , n ) {
		if( i != S ) {
			mp[ make_pair(pre[0][i] , i ) ] = array[i].w;
			mp[ make_pair(i , pre[0][i] ) ] = array[i].w; 
		}
	}	

	int Q;scanf("%d" , &Q);

	assert( Q < 200000 && Q > 0 );
	map< ii , int > mp1;

	int cur = T;
	//
	int tcnt = 0;

	while( cur != -1 ) {
 		
		mp1[make_pair(pre[0][cur] , cur )] = mp[make_pair(pre[0][cur] , cur )];
		mp1[make_pair(cur , pre[0][cur] )] = mp[make_pair(cur , pre[0][cur] )];
		cur = pre[0][cur]; 	
	
	}
	mp.clear();
	rep( i , 0 , Q ) {
		int u , v;
		scanf("%d %d" , &u  , &v );
		assert( u >= 0 && u < n );assert( v >= 0 && v < n );assert( u != v );
				

		if( mp1[make_pair( u , v ) ] == 0 ) cout << dist[0][T] << "\n";
		else if( mp1[make_pair(u,v)] == inf ) cout << "Infinty\n"; 
		else cout << mp1[make_pair( u , v ) ] <<"\n";
	}
	

	return 0;
}
----------
====================
----------
ALGORITHMS.224
advanced
----------
PROBLEM STATEMENT:
Given a tree with vertices numbered from [expression] queries. Each query represents a vertex number encoded in the following way:

Queries are encoded in the following way: Let, [expression].
We are assure that [expression], and hasn't been removed before. 

Note: [expression] is the bitwise XOR operator.

For each query, first decode the vertex [expression] and then perform the following:


Print the size of the connected component containing [expression].  
Remove vertex [expression].  

----------
TOP SOLUTION:
----------
#include<cstdio>
#include<ctime>
#include<cstdlib>
#include<vector>

using namespace std;

int INF, N, M, nr, V, v[400009], ap[200009], t[200009];
bool scos[200009];
vector < int > muchii[200009];

struct nod
{
    int K, P, nr;
    nod *l, *r, *t;
    nod (int K, int P, int nr, nod *l, nod *r)
    {
        this->nr = nr;
        this->l = l;
        this->r = r;
        this->P = P;
        this->K = K;
        this->t = 0;
    }
}*adresa1[200009], *adresa2[200009], *nil, *R;

int Rand(){return ((rand()%32768)<<15)+(rand()%32768)+1;}

void reup (nod *&n)
{
    if (n->l != nil) n->l->t = n;
    if (n->r != nil) n->r->t = n;
    n->nr = n->l->nr + n->r->nr + 1;
}

void rot_left (nod *&n)
{
    nod *t=n->l;
    n->l = t->r, t->r = n;
    t->t = n->t;
    reup (n);
    reup (t);
    n = t;
}

void rot_right (nod *&n)
{
    nod *t=n->r;
    n->r = t->l, t->l = n;
    t->t = n->t;
    reup (n);
    reup (t);
    n = t;
}

void balance (nod *&n)
{
    if (n->l->P > n->P)
        rot_left (n);
    else
    if (n->r->P > n->P)
        rot_right (n);
}

void Insert (nod *&n, int Poz, int K, int P)
{
    if (n == nil)
    {
        n = new nod (K, P, 1, nil, nil);
        return ;
    }
    if (n->l->nr >= Poz) Insert (n->l, Poz, K, P);
    else Insert (n->r, Poz - n->l->nr - 1, K, P);
    reup (n);
    balance (n);
}

void Erase (nod *&n, int Poz)
{
    if (n->l->nr >= Poz)
        Erase (n->l, Poz);
    else
    if (n->l->nr + 1 < Poz)
        Erase (n->r, Poz - n->l->nr - 1);
    else
    {
        if (n->l == nil && n->r == nil)
        {
            delete n;
            n = nil;
        }
        else
        {
            if (n->l->P > n->r->P)
                rot_left (n);
            else
                rot_right (n);
            Erase (n, Poz);
        }
    }
    if (n != nil) reup (n);
}

void join(nod *&R, nod *&Rl, nod *&Rr)
{
    R=new nod(0, 0, Rl->nr + Rr->nr + 1, Rl, Rr);
    Erase ( R, Rl->nr+1 );
}

void split(nod *&R, nod *&Rl, nod *&Rr, int Poz)
{
    Insert (R, Poz, 0, INF);
    Rl = R->l, Rl->t = 0;
    Rr = R->r, Rr->t = 0;
    delete R, R = nil;
}

bool nu_radacina (nod *&n)
{
    if (n->t != 0 && (n->t->l == n || n->t->r == n)) return 1;
    return 0;
}

void det_root (nod *n, nod *&R)
{
    while (1)
    {
        if ( nu_radacina (n) )
            n = n->t;
        else
            break;
    }
    R = n;
}

int Get_Pos (nod *n)
{
    int ans = n->l->nr + 1;
    while (1)
    {
        if (nu_radacina(n))
        {
            if (n->t->l == n) n = n->t;
            else ans += n->t->l->nr + 1, n = n->t;
        }
        else break;
    }
    return ans;
}

void dfs (int nod)
{
    ap[nod] = 1;
    v[++nr] = nod;
    for (vector < int > :: iterator it = muchii[nod].begin(); it != muchii[nod].end(); it++)
        if (ap[*it] == 0)
        {
            dfs (*it);
            t[*it] = nod;
        }
    v[++nr] = -nod;
}

void build (nod *&n)
{
    if (n == nil) return ;
    if (n->K < 0)
        adresa2[-n->K] = n;
    else
        adresa1[n->K] = n;
    build (n->l);
    build (n->r);
}

void afis (nod *&n)
{
    if (n == nil) return ;
    afis (n->l);
    printf ("%d ", n->K);
    afis (n->r);
}

void Del (int a, int b)
{
    if (t[b] == a)
    {
        int aux = a;
        a = b;
        b = aux;
    }
    /////t[a] == b, deci vad in ce treap este a, si ii dau split pentru a separa subarborele
    nod *R, *R1, *R2, *R3, *R4;
    det_root (adresa1[a], R);
    /////sunt in treapul cu radacina R
    int p1, p2;
    p1 = Get_Pos (adresa1[a]);
    p2 = Get_Pos (adresa2[a]);
    split (R, R4, R3, p2);
    split (R4, R1, R2, p1-1);
    R2->t = 0;
    join (R, R1, R3);
    /*afis (R);
    printf ("\n");
    afis (R2);
    printf ("\n");*/
}

int main()
{
//freopen ("input", "r", stdin);
//freopen ("output", "w", stdout);

srand(time(0));
INF=(1<<30)+7;
scanf ("%d", &N);
for (int i=1; i<N; i++)
{
    int X, Y;
    scanf ("%d %d", &X, &Y);
    muchii[X].push_back(Y);
    muchii[Y].push_back(X);
}
dfs (1);

nil = new nod (0, 0, 0, 0, 0);
R = nil;
for (int i=1; i<=nr; i++)
    Insert (R, i-1, v[i], Rand());
build (R);
int V = 0;
scanf ("%d", &M);
for (int i=1; i<=M; i++)
{
    int x;
    scanf ("%d", &x), x ^= V;
    nod *R;
    det_root (adresa1[x], R);
    printf ("%d\n", R->nr / 2), scos[x] = 1, V = R->nr / 2;
    for (auto it = muchii[x].begin (); it != muchii[x].end (); it ++)
        if (!scos[*it]) Del (x, *it);
}
return 0;
}

----------
====================
----------
ALGORITHMS.225
expert
----------
PROBLEM STATEMENT:
There are [expression] people are in a queue.  

There are [expression] in the window.  

Each ticketing window has an offer. If a person in the queue shares the same destination as the person immediately in front of him/her, a 20% reduction in the ticket price is offered to him/her.  

For example, suppose there are [expression] bucks.  

Try to distribute the [expression] people is minimized.  
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cstdio>
#include <cmath>
#include <deque>
#include <map>

using namespace std;

#define MAXN 1024*1024
#define x y[cs]
#define y second
#define mp make_pair
#define pb push_back
#define sz(a) (int)(a.size())
#define all(a) a.begin(), a.end()
#define R(a) ((a)%M)

typedef long long ll;
typedef vector<int> VI;
typedef vector<ll> VL;
typedef vector<VI> VVI;
typedef pair<int,int> PI;
typedef vector<PI> VPI;
typedef vector<VPI> VVPI;
typedef vector<VVPI> VVVPI;
typedef vector<VVI> VVVI;
typedef vector<double> VD;
typedef vector<VD> VVD;
typedef vector<string> VS;

double MinCostMatching(const VVD &cost, VI &Lmate, VI &Rmate) {
  int n = int(cost.size());

  // construct dual feasible solution
  VD u(n);
  VD v(n);
  for (int i = 0; i < n; i++) {
    u[i] = cost[i][0];
    for (int j = 1; j < n; j++) u[i] = min(u[i], cost[i][j]);
  }
  for (int j = 0; j < n; j++) {
    v[j] = cost[0][j] - u[0];
    for (int i = 1; i < n; i++) v[j] = min(v[j], cost[i][j] - u[i]);
  }
  
  // construct primal solution satisfying complementary slackness
  Lmate = VI(n, -1);
  Rmate = VI(n, -1);
  int mated = 0;
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
      if (Rmate[j] != -1) continue;
      if (fabs(cost[i][j] - u[i] - v[j]) < 1e-10) {
	Lmate[i] = j;
	Rmate[j] = i;
	mated++;
	break;
      }
    }
  }
  
  VD dist(n);
  VI dad(n);
  VI seen(n);
  
  // repeat until primal solution is feasible
  while (mated < n) {
    
    // find an unmatched left node
    int s = 0;
    while (Lmate[s] != -1) s++;
    
    // initialize Dijkstra
    fill(dad.begin(), dad.end(), -1);
    fill(seen.begin(), seen.end(), 0);
    for (int k = 0; k < n; k++) 
      dist[k] = cost[s][k] - u[s] - v[k];
    
    int j = 0;
    while (true) {
      
      // find closest
      j = -1;
      for (int k = 0; k < n; k++) {
	if (seen[k]) continue;
	if (j == -1 || dist[k] < dist[j]) j = k;
      }
      seen[j] = 1;
      
      // termination condition
      if (Rmate[j] == -1) break;
      
      // relax neighbors
      const int i = Rmate[j];
      for (int k = 0; k < n; k++) {
	if (seen[k]) continue;
	const double new_dist = dist[j] + cost[i][k] - u[i] - v[k];
	if (dist[k] > new_dist) {
	  dist[k] = new_dist;
	  dad[k] = j;
	}
      }
    }
    
    // update dual variables
    for (int k = 0; k < n; k++) {
      if (k == j || !seen[k]) continue;
      const int i = Rmate[k];
      v[k] += dist[k] - dist[j];
      u[i] -= dist[k] - dist[j];
    }
    u[s] += dist[j];
    
    // augment along path
    while (dad[j] >= 0) {
      const int d = dad[j];
      Rmate[j] = Rmate[d];
      Lmate[Rmate[j]] = j;
      j = d;
    }
    Rmate[j] = s;
    Lmate[s] = j;
    
    mated++;
  }
  
  double value = 0;
  for (int i = 0; i < n; i++)
    value += cost[i][Lmate[i]];
  
  return value;
}

int N, M, K;
map<string, double> f;
VI L, R;
VVD cost;
VS d;
double inf = 1e10;

int find ( int n )
{
	if(L[n] < N)
		L[n] = find(L[n]);
	return L[n];
}

int main ()
{
	cin >> N >> M >> K;
	
	d = VS(N);
	cost = VVD(N+M, VD(N+M,0.0));
	
	string _s;
	double _p;
	for (int i = 0; i < K; i += 1)
	{
		cin >> _s >> _p;
		f[_s] = _p;
	}
	
	for (int i = 0; i < N; i += 1)
		cin >> d[i];
	
	for (int i = 0; i < N+M; i += 1)
	{
		for (int j = 0; j < N+M; j += 1)
		{
			if (i >= N)
				cost[i][j] = 0.0;
			else if (j >= N)
				cost[i][j] = f[d[i]];
			else if ( i <= j )
				cost[i][j] = inf;
			else if ( d[i] == d[j] )
				cost[i][j] = 0.8*f[d[i]];
			else
				cost[i][j] = f[d[i]];
		}
	}
	
	cout << MinCostMatching(cost, L, R) << '\n';
	
	for (int i = 0; i < N; i += 1)
		cout << find(i)-N+1 << '\n';
	
	return 0;
}








----------
====================
----------
ALGORITHMS.226
expert
----------
PROBLEM STATEMENT:
Let [expression].

Consider the standard DFS (Depth-First Search) algorithm starting from vertex [expression] is classified by the algorithm into one of four groups:


tree edge: If [expression].
back edge: If [expression].
forward edge: If [expression] was on the stack.
cross edge: Any edge that is not a tree, back, or forward edge.


To better understand this, consider the following C++ pseudocode:

[expression]
[expression] 

[expression]
[expression]   

[expression]

[expression]
    [expression]
    [expression]
    [expression]
        [expression]
            [expression]
            [expression]
            [expression]
        [expression]
        [expression]
            [expression]
            [expression]
        [expression]
        [expression]
        [expression]
    [expression]
    [expression]
    [expression]
[expression]



Given four integers, [expression] according to the Output Format specified below.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cerr << *x, 0);
sim > char dud(...);
struct debug{
#ifdef LOCAL
~debug() { cerr << endl; }
eni(!=) cerr << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
  ris << "(" << d.first << ", " << d.second << ")";
}
sim dor(rge<c> d) {
  *this << "[";
  for (auto it = d.b; it != d.e; ++it)
    *this << ", " + 2 * (it == d.b) << *it;
  ris << "]";
}
#else
sim dor(const c &) { ris; }
#endif
};
#define imie(x) " [" << #x ": " << (x) << "] "

const int nax = 1e6 + 5;
int n, b, f, c;
vector<int> children[nax];
vector<pair<int,int>> cross;
vector<pair<int,int>> down;
vector<int> ancestors;

void dfs(int a, int next) {
	if(next > n) return;
	for(int i = 0; i < (int) ancestors.size() && (int) down.size() < max(f, b); ++i)
		down.push_back({ancestors[i], next});
	children[a].push_back(next);
	int rem = n - next + 1;
	if(c - (int) cross.size() >= rem - 1) {
		for(int i = next + 1; i <= n && (int) cross.size() < c; ++i) {
			cross.push_back({i, next});
		}
		dfs(a, next + 1);
	}
	else {
		ancestors.push_back(a);
		dfs(next, next + 1);
		ancestors.pop_back();
	}
}

vector<int> tmp[nax];

int main() {
	scanf("%d%d%d%d", &n, &b, &f, &c);
	++n;
	b -= n - 1;
	dfs(1, 2);
	if((int) down.size() < max(f, b) || (int) cross.size() < c) {
		puts("-1");
		return 0;
	}
	
	
	
	b += n - 1;
	for(int a = 1; a <= n; ++a)
		for(int x : children[a])
			if(b) {
				--b;
				tmp[x].push_back(a);
			}
	for(int a = 1; a <= n; ++a)
		for(int x : tmp[a])
			children[a].push_back(x);
	
	for(auto p : cross)
		children[p.first].push_back(p.second);
	
	for(auto p : down) {
		if(f) {
			--f;
			children[p.first].push_back(p.second);
		}
		if(b) {
			--b;
			children[p.second].push_back(p.first);
		}
	}
	debug() << cross[0];
	printf("%d\n", n);
	for(int i = 1; i <= n; ++i) {
		printf("%d ", (int) children[i].size());
		for(int x : children[i]) printf("%d ", x);
		puts("");
	}
}

----------
====================
----------
ALGORITHMS.227
expert
----------
PROBLEM STATEMENT:
We define the diameter of a strongly-connected oriented graph, [expression] (recall that a path's length is its number of edges).  

Given two integers, [expression] and the graph's diameter is as small as possible (see the Scoring section below for more detail). Then print the graph according to the Output Format specified below.  

Here's a sample strongly-connected oriented graph with [expression].  



Note: Cycles and multiple edges between vertices are allowed.
----------
TOP SOLUTION:
----------
// vvvvvvvvvvvvvvvvv Library code start


#define NDEBUG
NDEBUG


#include <algorithm>
#include <cassert>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <set>
#include <sstream>
#include <string>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <memory>
#include <random>


#define forn(t, i, n) for (t i = 0; i < (n); ++i)


#define all(c) c.begin(), c.end()


using namespace std;

/// caide keep
bool __hack = std::ios::sync_with_stdio(false);
/// caide keep
auto __hack1 = cin.tie(nullptr);

template<class T>
inline T mn(T arg) {
    return arg;
}


template<class T, class... Args>
inline bool rmx(T &to, Args... args) {
    auto v = mn(args...);
    if (to < v) {
        to = v;
        return true;
    }
    return false;
}


#define ENABLE_IF(e) typename enable_if<e>::type* = nullptr

namespace template_util {
    

    constexpr int bytecount(uint64_t x) {
        return x ? 1 + bytecount(x >> 8) : 0;
    }

    /// caide keep
    template<int N>
    struct bytetype {
        
    };

    /// caide keep
    template<>
    struct bytetype<4> {
        
    };

    /// caide keep
    template<>
    struct bytetype<3> {
        
    };

    /// caide keep
    template<>
    struct bytetype<2> {
        
    };

    /// caide keep
    template<>
    struct bytetype<1> {
        
    };

    /// caide keep
    template<>
    struct bytetype<0> {
        
    };

    /// caide keep
    template<uint64_t N>
    struct minimal_uint : bytetype<bytecount(N)> {
    };
}


template<class T>
T next(istream& in) {
    T ret;
    in >> ret;
    return ret;
}


#define dbg(...) ;


namespace option_detail {
    /// caide keep
    struct NoneHelper {};
}


template<class Value>
class Option {
public:
    

    static_assert(!std::is_reference<Value>::value,
                  "Option may not be used with reference types");
    static_assert(!std::is_abstract<Value>::value,
                  "Option may not be used with abstract types");

    
    Value* get_pointer() && = delete;

    
    // Return b copy of the value if set, or b given default if not.
    

    // Return b copy of the value if set, or b given default if not.
    

private:
    

    struct StorageTriviallyDestructible {
        // uninitialized
        
        bool hasValue;

        
    };

    /// caide keep
    struct StorageNonTriviallyDestructible {
        // uninitialized
        union { Value value; };
        bool hasValue;

        
        ~StorageNonTriviallyDestructible() {
            clear();
        }

        void clear() {
            if (hasValue) {
                hasValue = false;
                value.~Value();
            }
        }
    };

    /// caide keep
    using Storage =
    typename std::conditional<std::is_trivially_destructible<Value>::value,
            StorageTriviallyDestructible,
            StorageNonTriviallyDestructible>::type;

    Storage storage_;
};


// Comparisons.


template<class V> bool operator< (const Option<V>&, const V& other) = delete;
template<class V> bool operator<=(const Option<V>&, const V& other) = delete;
template<class V> bool operator>=(const Option<V>&, const V& other) = delete;
template<class V> bool operator> (const Option<V>&, const V& other) = delete;
template<class V> bool operator< (const V& other, const Option<V>&) = delete;
template<class V> bool operator<=(const V& other, const Option<V>&) = delete;
template<class V> bool operator>=(const V& other, const Option<V>&) = delete;
template<class V> bool operator> (const V& other, const Option<V>&) = delete;


namespace index_iterator_impl {
    template <class T>
    struct member_dispatch_helper {
        

    private:
        T value;
    };

    // Have to caide keep all the members to comply to iterator concept
    // Otherwise generated code won't be portable between clang and g++
    template <class C, bool reverse = false>
    struct index_iterator {
        /// caide keep
        typedef random_access_iterator_tag iterator_category;
        /// caide keep
        typedef decltype(((C*)nullptr)->operator[](size_t(0))) reference;
        /// caide keep
        typedef typename remove_reference<reference>::type value_type;
        /// caide keep
        typedef ptrdiff_t difference_type;
        /// caide keep
        typedef conditional<
                is_reference<reference>::value,
                typename add_pointer<value_type>::type,
                member_dispatch_helper<value_type>> pointer;

        /// caide keep
        typedef index_iterator<C, reverse> self_t;

        /// caide keep
        static const difference_type dir = reverse ? -1 : 1;

        /// caide keep
        index_iterator() = default;

        inline index_iterator(C* containter_, difference_type index_) : container(containter_), index(index_) {}

        
        /// caide keep
        inline bool operator!=(const self_t& o) { return index != o.index; }
        /// caide keep
        inline bool operator<(const self_t& o) { return reverse ? index > o.index : index < o.index; }
        /// caide keep
        inline bool operator>(const self_t& o) { return reverse ? index < o.index : index > o.index; }
        /// caide keep
        inline bool operator<=(const self_t& o) { return reverse ? index >= o.index : index <= o.index; }
        /// caide keep
        inline bool operator>=(const self_t& o) { return reverse ? index <= o.index : index >= o.index; }

        /// caide keep
        inline reference operator*() { return (*container)[index]; }
        /// caide keep
        inline const reference operator*() const { return (*container)[index]; }
        /// caide keep
        inline pointer operator->() { return pointer((*container)[index]); }

        /// caide keep
        inline self_t& operator++() { index += dir; return *this; }
        /// caide keep
        inline self_t operator++(int) { auto copy = *this; index += dir; return copy; }
        /// caide keep
        inline self_t& operator--() { index -= dir; return *this; }
        /// caide keep
        inline self_t operator--(int) { auto copy = *this; index -= dir; return copy; }

        /// caide keep
        inline self_t& operator+=(difference_type n) { index += dir * n; return *this; };
        /// caide keep
        inline self_t& operator-=(difference_type n) { index -= dir * n; return *this; };
        /// caide keep
        inline friend self_t operator-(self_t a, difference_type n) { return a -= n; };
        /// caide keep
        inline friend self_t operator+(difference_type n, self_t a) { return a += n; };
        /// caide keep
        inline friend self_t operator+(self_t a, difference_type n) { return a += n; };
        /// caide keep
        inline friend difference_type operator-(const self_t& a, const self_t& b) { return dir * (a.index - b.index); };

        /// caide keep
        inline reference operator[](difference_type n) { return (*container)[index + dir * n]; };
        /// caide keep
        inline const reference operator[](difference_type n) const { return (*container)[index + dir * n]; };

    private:
        C* container;
        difference_type index;
    };
}


namespace multivec_impl {
    template <size_t NDIMS>
    struct shape {
        size_t dim, stride;
        shape<NDIMS - 1> subshape;
        
        shape(size_t dim_, shape<NDIMS - 1>&& s): dim(dim_), stride(s.size()), subshape(std::move(s)) {}
        size_t size() const { return dim * stride; }
        
        
    };
    template <> struct shape<0> { size_t size() const { return 1; } };
    

    template <size_t I, size_t NDIMS>
    struct __shape_traverse {
        

        ///caide keep
        static const shape<NDIMS - I>& get_subshape(const shape<NDIMS>& s) {
            return __shape_traverse<I - 1, NDIMS - 1>::get_subshape(s.subshape);
        }
    };

    template <size_t NDIMS>
    struct __shape_traverse<0, NDIMS> {
        static size_t get_dim(const shape<NDIMS>& s) { return s.dim; }
        static const shape<NDIMS>& get_subshape(const shape<NDIMS>& s) { return s; }
    };

    template <size_t I, size_t NDIMS>
    size_t get_dim(const shape<NDIMS>& s) { return __shape_traverse<I, NDIMS>::get_dim(s); }

    ///caide keep
    template <size_t I, size_t NDIMS>
    const shape<NDIMS - I>& get_subshape(const shape<NDIMS>& s) { return __shape_traverse<I, NDIMS>::get_subshape(s); }

    
    template <class Index, class... Rest, size_t NDIMS, ENABLE_IF(is_integral<Index>::value)>
    size_t get_shift(const shape<NDIMS>& s, size_t cur_shift, Index i, Rest... is) {
        assert(0 <= i && i < s.dim);
        return get_shift(s.subshape, cur_shift + i * s.stride, is...);
    }

    template <size_t NDIMS> size_t get_shift(const shape<NDIMS>&, size_t cur_shift) { return cur_shift; }

    
    template <class... T> shape<sizeof...(T)> make_shape(T... dims);

    template <class Dim, class... Rest, ENABLE_IF(is_integral<Dim>::value)>
    shape<sizeof...(Rest) + 1> make_shape(Dim dim, Rest... dims) {
        assert(dim >= 0);
        return {(size_t)dim, make_shape<Rest...>(dims...)};
    }

    template <> shape<0> make_shape() { return {}; }

    
    ///caide keep
    template <class T, size_t NDIMS>
    struct vec_view_base;

    template <template<class, size_t> class Base, class T, size_t NDIMS>
    struct vec_mixin : public Base<T, NDIMS> {
        using Base<T, NDIMS>::Base;
        /// caide keep
        typedef Base<T, NDIMS> B;
        typedef index_iterator_impl::index_iterator<vec_mixin> iterator;
        

        template <size_t I = 0> inline size_t dim() const { return get_dim<I>(B::s); }
        inline size_t size() const { return B::s.size(); }

        ///caide keep
        template <class... Indices, bool enabled = NDIMS == sizeof...(Indices), ENABLE_IF(enabled)>
        inline T& operator()(Indices... is) {
            size_t i = multivec_impl::get_shift(B::s, 0, is...);
            return B::data[i];
        }

        ///caide keep
        template <class... Indices, bool enabled = sizeof...(Indices) < NDIMS, ENABLE_IF(enabled)>
        inline vec_mixin<vec_view_base, T, NDIMS - sizeof...(Indices)> operator()(Indices... is) {
            size_t shift = multivec_impl::get_shift(B::s, 0, is...);
            const auto& subshape = multivec_impl::get_subshape<sizeof...(Indices)>(B::s);
            return {subshape, &B::data[shift]};
        }

        
        inline auto operator[](size_t i) -> decltype(this->operator()(i)) { return this->operator()(i); }

        inline iterator begin() { return {this, 0}; }
        inline iterator end() { return {this, (ptrdiff_t)dim()}; }
        
        
        inline vec_mixin& operator=(const vec_mixin& o) {
            assert(B::s == o.get_shape());
            memcpy(raw_data(), o.raw_data(), sizeof(T) * size());
            return *this;
        }

//    protected:
        inline T* raw_data() {
            return &B::data[0];
        }

        inline const T* raw_data() const {
            return &B::data[0];
        }
    };

    template <class T, size_t NDIMS>
    struct vec_view_base {
        inline vec_view_base(const multivec_impl::shape<NDIMS>& s_, T* data_): s(s_), data(data_) {}
        
    protected:
        multivec_impl::shape<NDIMS> s;
        T* data;
    };

    template <class T, size_t NDIMS>
    struct vec_base {
        inline vec_base(multivec_impl::shape<NDIMS>&& s_): s(move(s_)), data(new T[s.size()]) {}
        
        
        inline vec_base(const vec_base& o): s(o.s), data(new T[s.size()]) {
            memcpy(data.get(), o.data.get(), sizeof(T) * s.size());
        }
        
    protected:
        multivec_impl::shape<NDIMS> s;
        unique_ptr<T[]> data;
    };
}

/*
TODO
 - do we need vec_view_const?
 - add more features (lambda initialization etc.)
 - properly use const
 - proper tests coverage
*/

template <class T, size_t NDIMS>
using vec = multivec_impl::vec_mixin<multivec_impl::vec_base, T, NDIMS>;


template <class T, class... NDIMS>
inline vec<T, sizeof...(NDIMS)> make_vec(NDIMS... dims) {
    return {multivec_impl::make_shape(dims...)};
}

// ^^^^^^^^^^^^^^^^^ Library code end

int diameter(vec<int, 2>& g) {
    int n = g.dim<0>();
    vector<int> dist(n);
    vector<int> q(n);
    int ret = 0;
    for (int x0 = 0; x0 < n; ++x0) {
        fill(all(dist), -1);
        dist[x0] = 0;
        q[0] = x0;
        int qe = 1;
        forn (int, it, qe) {
            int i = q[it];
            int di = dist[i];
            rmx(ret, di);
            for (int j : g(i)) {
                int& dj = dist[j];
                if (dj == -1) {
                    dj = di + 1;
                    q[qe++] = j;
                }
            }
        }
        if (qe < n) {
            return 1000000000;
        }
    }
    return ret;
}

void solve(istream& in, ostream& out) {
    int n = next<int>(in);
    int d = next<int>(in);
    auto bestg = make_vec<int>(n, d);
    int bestd = 1000000000;
    auto t0 = clock();
    std::default_random_engine gen;
    auto relax = [&](vec<int, 2>& g, string s) {
        int d = diameter(g);
        if (d < bestd) {
            dbg(d, s);
            bestd = d;
            bestg = g;
        }
    };
    if (d <= 5) {
        auto g = make_vec<int>(n, d);
        forn (int, i, n) {
            forn (int, j, d) {
                g(i, j) = ((n - d) * i + j) % n;
            }
        }
        relax(g, "powd");
    }
    auto g = make_vec<int>(n, d);
    while (true) {
        if (clock() - t0 > 1.5 * CLOCKS_PER_SEC) {
            break;
        }
//        forn (int, i, n) {
//            g(i, 0) = (i + 1) % n;
//            foran (int, j, 1, d) {
//                g(i, j) = uniform_int_distribution<int>(0, n - 1)(gen);
//            }
//        }
//        relax(g, "rand");
        vector<int> p(n);
        forn (int, i, n) {
            p[i] = i;
        }
        forn (int, j, d) {
            random_shuffle(all(p));
            forn (int, i, n) {
                g(i, j) = p[i];
            }
        }
        relax(g, "perm");
    }
    out << bestd << "\n";
    forn (int, i, n) {
        forn (int, j, d) {
            out << bestg(i, j) << " ";
        }
        out << "\n";
    }
}


int main() {
    solve(cin, cout);
    return 0;
}


----------
====================
----------
ALGORITHMS.228
expert
----------
PROBLEM STATEMENT:
Airports are being built on a straight road according to a new construction plan. For convenience, imagine a number line on which at different points airports can be positioned. Because a plane can't take off and start landing immediately, there will be flight between two airports in locations [expression] is a constant.

Changing the position of an airport from [expression]. The cost to fix a certain plan is the minimum total cost of changing the positions of airports. After the changes, it should be possible to travel between any pair of airports, possibly taking flights through some intermediate airports. Note that it's possible that two airports have the same initial position, and this can be the case  after changes too.

On [expression] is announced. On each day that a new airport is announced, print the smallest cost to fix the set of airports announced so far . Note that you should not change the positions of any airports, just calculate the cost to do it.


----------
TOP SOLUTION:
----------
// ayy
// ' lamo
// SUBLIME HAX
	#include <bits/stdc++.h>
	using namespace std;
	template<class T,class U>
	ostream &operator<<(ostream &os,const pair<T,U> &x) {
		return os<<"("<<x.first<<","<<x.second<<")";
	}
	namespace dbg_ns {
		template<typename C>
		struct is_iterable {
			template<class T> static long check(...);
			template<class T> static char check(int,
				typename T::const_iterator = C().end());
			enum {
				value = sizeof(check<C>(0)) == sizeof(char),
				neg_value = sizeof(check<C>(0)) != sizeof(char)
			};
		};
		template<class T> ostream &_out_str(ostream &os,const T &x) {
			return os<<'"'<<x<<'"';
		}
		template<class T> ostream &_dbg2_5(ostream &,const T &);
		template<bool B,typename T=void> using eit=typename enable_if<B,T>::type;
		template<class T>
		inline ostream &_dbg3(ostream &os,eit<is_iterable<T>::neg_value,const T> &x) {
			return os<<x;
		}
		template<class T>
		inline ostream &_dbg3(ostream &os,eit<is_iterable<T>::value,const T> &V) {
			os<<"{";
			bool ff=0;
			for(const auto &E:V) _dbg2_5(ff?os<<",":os,E), ff=1;
			return os<<"}";
		}
		template<>
		inline ostream &_dbg3<string>(ostream &os,const string &x) {
			return _out_str(os,x);
		}
		template<>
		inline ostream &_dbg3<const char *>(ostream &os,const char *const &x) {
			return _out_str(os,x);
		}
		template<class T> inline ostream &_dbg2_5(ostream &os,const T &x) {
			return _dbg3<T>(os,x);
		}
		template<class T,typename... Args> ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args);
		inline ostream &_dbg2(ostream &os,vector<string>::iterator) { return os; }
		template<typename... Args>
		inline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const char *x,Args&&... args) {
			return _dbg2(_dbg3<const char *>(os<<"  ",x),nm+1,args...);
		}
		template<class T,typename... Args>
		inline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args) {
			return _dbg2(_dbg3<T>(os<<"  "<<*nm<<"=",x),nm+1,args...);
		}
		vector<string> split(string s) {
			vector<string> Z;
			string z="";
			s+=',';
			int dep=0;
			for(char c:s) {
				if(c==',' && !dep) Z.push_back(z),z="";
				else z+=c;
				if(c=='(') ++dep;
				if(c==')') --dep;
			}
			return Z;
		}
		template<typename... Args> inline ostream &_dbg1(int ln,const string &nm,Args&&... args) {
			auto nms=split(nm);
			return _dbg2(cerr<<"L"<<ln<<":",nms.begin(),args...)<<endl;
		}
	}
	#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)
	#define sz(x) (int(x.size()))
	#define eprintf(...) fprintf(stderr,__VA_ARGS__)
	#define fi first
	#define se second
	#define pb push_back
// END SUBLIME HAX
// #include <bits/extc++.h>
// using namespace __gnu_pbds;
typedef unsigned long long ull;
typedef long long ll;
typedef long double ld; //CARE
typedef complex<ld> pt;
const ld eps=(ld)1e-8;
const ld tau=2*(ld)acosl(-1);
const int inf=1e9+99;
const ll linf=1e18+99;
const int P=1e9+7;





int n;
int hi,lo;
set<int> ss;
set<pair<int,int> > ww;

void kill(int x) {
	auto it=ss.lower_bound(x);
	assert(*it==x);
	++it;
	if(it==ss.end()) return;
	int y=*it;
	pair<int,int> key={y-x,x};
	if(ww.count(key)) ww.erase(key);
}
void add(int x) {
	auto it=ss.lower_bound(x);
	assert(*it==x);
	++it;
	if(it==ss.end()) return;
	int y=*it;
	ww.insert({y-x,x});
}


void ins(int x) {
	auto it=ss.lower_bound(x);
	if(it!=ss.end() && *it==x) return;
	int y=inf;
	if(it!=ss.begin()) {
		--it;
		y=*it;
		kill(y);
	}
	ss.insert(x);
	if(y!=inf) add(y);
	add(x);
}
void RZ() {
	n=0;
	ss.clear();
	ww.clear();
}
void INS(int x) {
	if(!n) {
		hi=lo=x;
		n=1;
		return;
	}
	if(n==1) {
		hi=max(hi,x);
		lo=min(lo,x);
		n=2;
		return;
	}

	++n;
	if(x>hi) {
		ins(hi);
		hi=x;
		return;
	}
	if(x<lo) {
		ins(lo);
		lo=x;
		return;
	}
	ins(x);
}
int Q(int d) {
	if(n==1) return 0;
	assert(sz(ss)<=n-2);
	if(n==2) return max(0,d-(hi-lo));


	// dbg(ss,ww,lo,hi);

	int Z=inf;
	auto it=ss.lower_bound(hi-d+1);
	if(it==ss.end()) return 0;
	if(*it>=lo+d) return 0;
	Z=min(Z,max(0,d-(*it-lo)));
	it=ss.lower_bound(lo+d);
	--it;
	Z=min(Z,max(0,d-(hi-*it)));


	for(;;) {
		auto it=ww.end();
		if(it==ww.begin()) {
			break;
		}
		--it;
		if(it->se<hi-d || it->se+it->fi>lo+d) {
			ww.erase(it);
		} else {
			break;
		}
	}
	auto it2=ww.end();
	if(it2!=ww.begin()) {
		--it2;
		Z=min(Z,max(0,d+d-(hi-lo)-it2->fi));
	}
	return Z;
}



void _m() {
	int n,d;
	scanf("%d%d",&n,&d);
	RZ();
	for(;n--;) {
		int x; scanf("%d",&x);
		INS(x);
		printf("%d%c",Q(d)," \n"[!n]);
	}
}


int32_t main() {
	int q; scanf("%d",&q);
	for(;q--;) _m();
}












----------
====================
----------
ALGORITHMS.229
expert
----------
PROBLEM STATEMENT:
Alex has a board game consisting of:


A chip for marking his current location on the board.
[expression], denoting the next position for the chip to jump to from that field.
A die with [expression], of being rolled.


Alex then performs the following actions:


Begins the game by placing the chip at a position in a field randomly and with equiprobability. 
Takes [expression] turns; during each turn he:
Rolls the die. We'll denote the number rolled during a turn as [expression].
Jumps the chip [expression] times. Recall that each field contains a value denoting the next field number to jump to.
After completing [expression] turns, the game ends and he must calculate the respective probabilities for each field as to whether the game ended with the chip in that field.


Given [expression] at the end of the game.

Note: All the probabilities in this task are rational numbers modulo [expression]). Click here to learn about Modular Multiplicative Inverse.
----------
TOP SOLUTION:
----------
#pragma GCC diagnostic ignored "-Wunused-result"

#include <cstdio>
#include <vector>
#include <cassert>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <ctime>
#include <random>

const int MOD = 998244353;

int modMul(int a, int b) {
	assert(-MOD < a && a < MOD);
	assert(-MOD < b && b < MOD);
	return (int)((long long)a * b % MOD);
}

int modAdd(int a, int b) {
	assert(-MOD < a && a < MOD);
	assert(-MOD <  b && b < MOD);
	return (a + b) % MOD;
}

int modPow(int a, int n) {
	assert(-MOD < a && a < MOD);
	assert(n >= 0);
	int r = 1;
	while (n > 0) {
		if ((n & 1) == 1) {
			r = modMul(r, a);
		}
		a = modMul(a, a);
		n >>= 1;
	}
	return r;
}

int modInv(int a) {
	assert(-MOD < a && a < MOD && a != 0);
	return modPow(a, MOD - 2);
}

std::vector<int> solveSlow(int nTurns, const std::vector<int> &next, const std::vector<int> &prob) {
	int nPos = (int)next.size();
	int nFaces = (int)prob.size();
	std::vector<int> cur(nPos, modInv(nPos));
	std::vector<int> prev(nPos, 0);
	for (int t = 0; t < nTurns; t++) {
		cur.swap(prev);
		for (int i = 0; i < nPos; i++) {
			cur[i] = 0;
		}
		for (int start = 0; start < nPos; start++) {
			int pos = start;
			for (int i = 0; i < nFaces; i++) {
				cur[pos] = modAdd(cur[pos], modMul(prob[i], prev[start]));
				pos = next[pos];
			}
		}
	}
	return cur;
}

void getPeriodAndPrePeriod(const std::vector<int> &next, std::vector<int> &period, std::vector<int> &prePeriod) {
	int nPos = (int)next.size();
	period.assign(nPos, -1);
	prePeriod.assign(nPos, -1);
	const int NOT_VISITED = -1;
	const int VISITED = -2;
	std::vector<int> status(nPos, NOT_VISITED);
	for (int i = 0; i < nPos; i++) {
		if (status[i] == NOT_VISITED) {
			int cur = i;
			int step = 0;
			std::vector<int> path;
			status[cur] = step;
			step++;
			path.push_back(cur);
			cur = next[cur];
			while (status[cur] == NOT_VISITED) {
				status[cur] = step;
				step++;
				path.push_back(cur);
				cur = next[cur];
			}
			if (status[cur] == VISITED) {
				int pp = 1;
				while (!path.empty()) {
					int t = path.back();
					path.pop_back();
					status[t] = VISITED;
					period[t] = period[cur];
					prePeriod[t] = prePeriod[cur] + pp;
					pp++;
				}
			} else {
				assert(status[cur] >= 0);
				period[cur] = step - status[cur];
				prePeriod[cur] = 0;
				while (true) {
					int t = path.back();
					path.pop_back();
					status[t] = VISITED;
					if (t == cur) {
						break;
					}
					period[t] = period[cur];
					prePeriod[t] = 0;
				}
				int pp = 1;
				while (!path.empty()) {
					int t = path.back();
					path.pop_back();
					status[t] = VISITED;
					period[t] = period[cur];
					prePeriod[t] = pp;
					pp++;
				}
			}
		}
	}
}

inline bool isPow2(int n) {
	return n > 0 && (n & (n - 1)) == 0;
}

const int MAX_LEVEL = 19;

int sinCos[1 + MAX_LEVEL][1 << (MAX_LEVEL - 1)];

// https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm#Pseudocode
void fft(const std::vector<int> &src, const int srcPos, const int n, const int logN, const int srcStride, std::vector<int> &dst, int &dstPos) {
	if (n == 1) {
		dst[dstPos] = src[srcPos];
		dstPos++;
	} else {
		int dstStart = dstPos;
		fft(src, srcPos, n >> 1, logN - 1, srcStride << 1, dst, dstPos);
		fft(src, srcPos + srcStride, n >> 1, logN - 1, srcStride << 1, dst, dstPos);
		assert(dstPos == dstStart + n);
		for (int i = 0; i < (n >> 1); i++) {
			assert(1 <= logN && logN <= MAX_LEVEL);
			assert(0 <= i && i < (1 << (MAX_LEVEL - 1)));
			int m = sinCos[logN][i];
			int index1 = dstStart + i;
			int index2 = dstStart + i + (n >> 1);
			int t = dst[index1];
			dst[index1] = int((t + 1LL * m * dst[index2]) % MOD);
			dst[index2] = int((t - 1LL * m * dst[index2]) % MOD);
		}
	}
}

void fft(const std::vector<int> &src, std::vector<int> &dst) {
	if (sinCos[MAX_LEVEL][0] == 0) {
		sinCos[MAX_LEVEL][0] = 1;
		for (int i = 1; i < (1 << (MAX_LEVEL - 1)); i++) {
			sinCos[MAX_LEVEL][i] = modMul(sinCos[MAX_LEVEL][i - 1], MOD - 121229115);
		}
		for (int level = MAX_LEVEL - 1; level >= 1; level--) {
			for (int i = 0; i < (1 << (level - 1)); i++) {
				sinCos[level][i] = sinCos[level + 1][i << 1];
			}
		}
	}
	assert(isPow2((int)src.size()));
	assert(&src != &dst);
	dst.resize(src.size(), 0);
	int dstPos = 0;
	fft(src, 0, (int)src.size(), (int)std::round(std::log2((double)src.size())), 1, dst, dstPos);
}

void inverseFft(const std::vector<int> &src, std::vector<int> &dst) {
	fft(src, dst);
	int inv = modInv((int)dst.size());
	for (int i = 0; i < (int)dst.size(); i++) {
		dst[i] = modMul(dst[i], inv);
	}
	std::reverse(dst.begin() + 1, dst.end());
}

void mulPoly(const std::vector<int> &a, const std::vector<int> &b, std::vector<int> &res) {
	assert(a.size() == b.size());
	std::vector<int> fa;
	fft(a, fa);
	std::vector<int> fb;
	fft(b, fb);
	std::vector<int> fr(a.size());
	for (int i = 0; i < (int)a.size(); i++) {
		fr[i] = modMul(fa[i], fb[i]);
	}
	inverseFft(fr, res);
}

std::vector<int> mul(const std::vector<int> &left, const std::vector<int> &right) {
	// naive nPos=5k -> 2.42s
	// fft nPos=5k -> 0.21s
	// naive nPos=1k -> 0.1s
	// fft nPos=1k -> 0.11s
	if (left.size() * right.size() > 1000 * 1000) {
		int size = int(left.size() + right.size() - 1);
		while (!isPow2(size)) {
			size++;
		}
		std::vector<int> newLeft = left;
		std::vector<int> newRight = right;
		newLeft.resize(size);
		newRight.resize(size);
		std::vector<int> res(size);
		mulPoly(newLeft, newRight, res);
		return res;
	}
	std::vector<int> res(left.size() + right.size() - 1, 0);
	for (int iL = 0; iL < (int)left.size(); iL++) {
		for (int iR = 0; iR < (int)right.size(); iR++) {
			res[iL + iR] = modAdd(res[iL + iR], modMul(left[iL], right[iR]));
		}
	}
	return res;
}

std::vector<int> wrappedMul(const std::vector<int> &left, const std::vector<int> &right, int prePeriod, int period) {
	assert((int)left.size() == prePeriod + period);
	assert((int)right.size() == prePeriod + period);
	std::vector<int> res = mul(left, right);
	for (int i = prePeriod + period; i < (int)res.size(); i++) {
		int dst = (i - prePeriod) % period + prePeriod;
		res[dst] = modAdd(res[dst], res[i]);
	}
	assert((int)res.size() >= prePeriod + period);
	res.resize(prePeriod + period);
	return res;
}

std::vector<int> wrappedPow(const std::vector<int> &prob, int prePeriod, int period, int nTurns) {
	assert(nTurns >= 1);
	if (nTurns == 1) {
		return prob;
	} else if (nTurns % 2 == 1) {
		return wrappedMul(prob, wrappedPow(prob, prePeriod, period, nTurns - 1), prePeriod, period);
	} else {
		return wrappedPow(wrappedMul(prob, prob, prePeriod, period), prePeriod, period, nTurns / 2);
	}
}

void topologicalSort(std::vector<int> &next, std::vector<int> &perm) {
	int nPos = (int)next.size();
	assert(nPos == (int)perm.size());
	int cur = nPos - 1;
	perm.assign(nPos, -1);
	std::vector<int> stack;
	for (int i = 0; i < nPos; i++) {
		if (perm[i] == -1) {
			int t = i;
			while (perm[t] == -1) {
				perm[t] = -2;
				stack.push_back(t);
				t = next[t];
			}
			while (!stack.empty()) {
				t = stack.back();
				stack.pop_back();
				assert(perm[t] == -2);
				assert(cur >= 0);
				perm[t] = cur;
				cur--;
			}
		}
	}
	assert(cur == -1);
	std::vector<int> newNext(nPos);
	for (int i = 0; i < nPos; i++) {
		newNext[perm[i]] = perm[next[i]];
	}
	next = newNext;
}

void topologicalUnsort(std::vector<int> &ans, std::vector<int> &perm) {
	int nPos = (int)ans.size();
	assert(nPos == (int)perm.size());
	std::vector<int> newAns(nPos);
	for (int i = 0; i < nPos; i++) {
		newAns[i] = ans[perm[i]];
	}
	ans = newAns;
}

std::vector<int> solveFastSmall(int nTurns, std::vector<int> next, const std::vector<int> &prob) {
	int nPos = (int)next.size();
	std::vector<int> perm(nPos);
	topologicalSort(next, perm); // to make it processor cache friendly
	int nFaces = (int)prob.size();
	std::vector<int> period;
	std::vector<int> prePeriod;
	getPeriodAndPrePeriod(next, period, prePeriod);
	std::vector<int> periodToMaxPrePeriod(1 + nPos, -1);
	for (int i = 0; i < nPos; i++) {
		int p = period[i];
		assert(p > 0);
		int pp = prePeriod[i];
		assert(pp >= 0);
		if (pp > periodToMaxPrePeriod[p]) {
			periodToMaxPrePeriod[p] = pp;
		}
	}
	assert(periodToMaxPrePeriod[0] == -1);
	std::vector<long long> ansL(nPos, 0);
	for (int p = 1; p <= nPos; p++) {
		int pp = periodToMaxPrePeriod[p];
		if (pp == -1) {
			continue;
		}
		// 350 different periods -> nPos = (1 + 350) * 350 / 2 = 61 425 -> in this problem less than 350 different periods
		std::vector<int> wrappedProb(pp + p, 0);
		for (int i = 0; i < nFaces; i++) {
			if (i < pp) {
				wrappedProb[i] = prob[i];
			} else {
				int dst = (i - pp) % p + pp;
				wrappedProb[dst] = modAdd(wrappedProb[dst], prob[i]);
			}
		}
		wrappedProb = wrappedPow(wrappedProb, pp, p, nTurns);
		// great loop or great chain - let's fill in one swoop.
		std::vector<int> ones(pp + p, 1);
		std::vector<int> wrappedProbCum = wrappedMul(wrappedProb, ones, pp, p);
		std::vector<bool> wasStart(nPos, false);
		int start = -1;
		for (int i = 0; i < nPos; i++) {
			if (period[i] == p && prePeriod[i] == pp) {
				start = i;
				break;
			}
		}
		assert(start >= 0);
		for (int i = 0; i < (int)wrappedProbCum.size(); i++) {
			assert(!wasStart[start]);
			wasStart[start] = true;
			ansL[start] += wrappedProbCum[i];
			start = next[start];
		}
		for (int i = 0; i < nPos; i++) {
			if (period[i] == p && !wasStart[i]) {
				int pos = i;
				for (int j = 0; j < (int)wrappedProb.size(); j++) {
					ansL[pos] += wrappedProb[j];
					pos = next[pos];
				}
			}
		}
	}
	std::vector<int> ansI(nPos);
	for (int i = 0; i < nPos; i++) {
		ansI[i] = int(ansL[i] % MOD);
	}
	int startValue = modInv(nPos);
	for (int i = 0; i < nPos; i++) {
		ansI[i] = modMul(ansI[i], startValue);
	}
	topologicalUnsort(ansI, perm);
	return ansI;
}

void maxTest() {
	int nPos = 60000;
	int nFaces = 100000;
	int nTurns = 1000;
	std::vector<int> next(nPos);
	for (int i = 0; i < nPos; i++) {
		next[i] = (i + 1) % nPos;
	}
	std::vector<int> prob(nFaces, modInv(nFaces));
	std::vector<int> res = solveFastSmall(nTurns, next, prob);
	assert(res[0] != -1);
	printf("maxTest() done\n");
		// Naive poly multiplication: nPos=10k -> 10s. So 60k ~ 360s.
		// FFT nPos=60k -> 23s
		// multiplication in the end -> 14.67s
		// addition without % -> 6.7s (FFT just 0.32s, everything else in just adding result)
		// with max path elimination -> 0.32s (another worst case);
	std::exit(0);
}

void maxTest2() {
	clock_t start = clock();
	int nPos = 60000;
	int nFaces = 100000;
	int nTurns = 1000;
	std::vector<int> next(nPos);
	for (int i = 0; i < nPos; i++) {
		next[i] = (i + 1) % (nPos / 2) + i / (nPos / 2) * (nPos / 2);
		// printf("next[%d] = %d\n", i, next[i]);
	}
	{
		std::vector<int> perm(nPos);
		for (int i = 0; i < nPos; i++) {
			perm[i] = i;
		}
		std::mt19937 gen;
		std::shuffle(perm.begin(), perm.end(), gen);
		std::vector<int> next2(nPos);
		for (int i = 0; i < nPos; i++) {
			next2[perm[i]] = perm[next[i]];
		}
		next = next2;
	}
	std::vector<int> prob(nFaces, modInv(nFaces));
	std::vector<int> res = solveFastSmall(nTurns, next, prob);
	assert(res[0] != -1);
	printf("maxTest2() done %.2f\n", 1.0 * (clock() - start) / CLOCKS_PER_SEC);
		// i7: 1.66s
		// HR: 1.93s Time Limit is 4s. This test is not the worst because some get tle.
		// shuffled i7: 8.97s
		// shuffled + topSorted i7: 1.67
	std::exit(0);
}

int main() {
	// maxTest();
	// maxTest2();
	int nPos, nFaces, nTurns;
	scanf("%d %d %d", &nPos, &nFaces, &nTurns);
	std::vector<int> next(nPos);
	for (int i = 0; i < nPos; i++) {
		scanf("%d", &next[i]);
		next[i]--;
	}
	std::vector<int> prob(nFaces);
	for (int i = 0; i < nFaces; i++) {
		scanf("%d", &prob[i]);
	}
	// std::vector<int> res = solveSlow(nTurns, next, prob);
	std::vector<int> res = solveFastSmall(nTurns, next, prob);
	for (int x : res) {
		printf("%d\n", (x + MOD) % MOD);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.230
easy
----------
PROBLEM STATEMENT:
Consider an array of integers, [expression].

Given an array of integers, find and print the minimum absolute difference between any two elements in the array.  For example, given the array [expression].

Function Description  

Complete the minimumAbsoluteDifference function in the editor below.  It should return an integer that represents the minimum absolute difference between any pair of elements.  

minimumAbsoluteDifference has the following parameter(s):  


n: an integer that represents the length of arr    
arr: an array of integers  

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>

using namespace std;

int main(){
    int n;
    cin >> n;
    int a[n];
    for(int i = 0; i < n; i++){
        cin >> a[i];
    }
    sort(a, a + n);
    int ans = 2000000001;
    for(int i = 1; i < n; i++){
        if(a[i] - a[i - 1] < ans){
            ans = a[i] - a[i - 1];
        }
    }
    cout << ans;
}

----------
====================
----------
ALGORITHMS.231
easy
----------
PROBLEM STATEMENT:
Marc loves cupcakes, but he also likes to stay fit. Each cupcake has a calorie count, and Marc can walk a distance to expend those calories.  If Marc has eaten [expression]  miles to maintain his weight.

For example, if he eats [expression].

Given the individual calorie counts for each of the cupcakes, determine the minimum number of miles Marc must walk to maintain his weight. Note that he can eat the cupcakes in any order.  

Function Description  

Complete the marcsCakewalk function in the editor below.  It should return a long integer that represents the minimum miles necessary.  

marcsCakewalk has the following parameter(s):  


calorie: an integer array that represents calorie count for each cupcake  

----------
TOP SOLUTION:
----------

#pragma GCC optimize("O3")
#define _CRT_SECURE_NO_WARNINGS
#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>

#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk

#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd
#define have adsgagshdshfhds
#define ends asdgahhfdsfshdshfd
#define right asdashgasrhsdf

#define eps 1e-14
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 64

#define ldouble long double

using namespace std;

long long INF = 1e9;
const int N = 600031;

int n;
long long ar[N],ans;

int main(){
	//freopen("tree.in","r",stdin);
	//freopen("tree.out","w",stdout);
	//freopen("in.txt", "r", stdin);
	//freopen("out.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);

	cin>>n;
	for (int i=0;i<n;i++)
	{
		cin>>ar[i];
	}
	sort(ar,ar+n);
	reverse(ar,ar+n);
	for (int i=0;i<n;i++)
	{
		ans+=(1ll<<i)*ar[i];
	}
	cout<<ans<<endl;

	cin.get(); cin.get();
	return 0;
}

----------
====================
----------
ALGORITHMS.232
easy
----------
PROBLEM STATEMENT:
Given a square grid of characters in the range ascii[a-z], rearrange elements of each row alphabetically, ascending.  Determine if the columns are also in ascending alphabetical order, top to bottom.  Return YES if they are or NO if they are not.

For example, given:

a b c
a d e
e f g


The rows are already in alphabetical order.  The columns a a e, b d f and c e g are also in alphabetical order, so the answer would be YES.  Only elements within the same row can be rearranged.  They cannot be moved to a different row.

Function Description  

Complete the gridChallenge function in the editor below.  It should return a string, either YES or NO.  

gridChallenge has the following parameter(s):  


grid: an array of strings  

----------
TOP SOLUTION:
----------
#define _USE_MATH_DEFINES
#define _CRT_SECURE_NO_DEPRECATE

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <climits>
#include <cfloat>
#include <ctime>
#include <cassert>
#include <map>
#include <utility>
#include <set>
#include <iostream>
#include <memory>
#include <string>
#include <vector>
#include <algorithm>
#include <functional>
#include <sstream>
#include <complex>
#include <stack>
#include <queue>
#include <numeric>
#include <list>
#include <iomanip>
#include <fstream>
#include <iterator>
#include <bitset>

using namespace std;

typedef long long ll;
typedef pair<int, int> Pii;
typedef pair<ll, ll> Pll;

#define FOR(i,n) for(int i = 0; i < (n); i++)
#define sz(c) ((int)(c).size())
#define ten(x) ((int)1e##x)
#define tenll(x) ((ll)1e##x)
template<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }

void solve(){
	int n; cin >> n;
	vector<string> v(n);
	FOR(i, n) cin >> v[i];
	FOR(i, n) sort(v[i].begin(), v[i].end());
	bool b = true;
	FOR(i, n){
		string x;
		FOR(j, n) x.push_back(v[j][i]);
		string y = x;
		sort(y.begin(), y.end());
		if (x != y) {
			b = false;
		}
	}
	puts(b ? "YES" : "NO");
}

int main(){
	int t; cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
----------
====================
----------
ALGORITHMS.233
easy
----------
PROBLEM STATEMENT:
Lena is preparing for an important coding competition that is preceded by a number of sequential preliminary contests. Initially, her luck balance is 0. She believes in "saving luck", and wants to check her theory. Each contest is described by two integers, [expression]:


[expression].
[expression] if it's unimportant.


If Lena loses no more than [expression] important contests, what is the maximum amount of luck she can have after competing in all the preliminary contests? This value may be negative.

For example, [expression] and:

[expression]
[expression]
[expression]
[expression]



If Lena loses all of the contests, her will be [expression].  

Function Description  

Complete the luckBalance function in the editor below.  It should return an integer that represents the maximum luck balance achievable.  

luckBalance has the following parameter(s):  


k: the number of important contests Lena can lose  
contests: a 2D array of integers where each [expression] contest.  

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;
#define FOR(i,a,b) for(int i = (a); i <= (b); ++i)
#define FORD(i,a,b) for(int i = (a); i >= (b); --i)
#define RI(i,n) FOR(i,1,(n))
#define REP(i,n) FOR(i,0,(n)-1)
#define mini(a,b) a=min(a,b)
#define maxi(a,b) a=max(a,b)
#define mp make_pair
#define pb push_back
#define st first
#define nd second
#define sz(w) (int) w.size()
typedef vector<int> vi;
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
const int inf = 1e9 + 5;
const int nax = 1e6 + 5;



int main() {
	int n, k;
	scanf("%d%d", &n, &k);
	int ans = 0;
	vi w;
	REP(i, n) {
		int a, b;
		scanf("%d%d", &a, &b);
		if(b == 0) ans += a;
		else w.pb(a);
	}
	sort(w.rbegin(), w.rend());
	REP(i, (int) w.size()) {
		if(i < k) ans += w[i];
		else ans -= w[i];
	}
	printf("%d\n", ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.234
easy
----------
PROBLEM STATEMENT:
Given an array of stick lengths, use [expression] space-separated integers in non-decreasing order.

If there are several valid triangles having the maximum perimeter: 


Choose the one with the longest maximum side. 
If more than one has that maximum, choose from them the one with the longest minimum side. 
If more than one has that maximum as well, print any one them.


If no non-degenerate triangle exists, print -1.

For example, assume there are stick lengths [expression].  

Function Description  

Complete the maximumPerimeterTriangle function in the editor below.  It should return an array of [expression] integers that represent the side lengths of the chosen triangle in non-decreasing order.  

maximumPerimeterTriangle has the following parameter(s):  


sticks: an integer array that represents the lengths of sticks available  

----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 256

using namespace std;

const int INF = 1e9;
const int N = 500031;

int n;
vector<int> v;
int ar[100];
vector<vector<int> > res;

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);
	
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> ar[i];
	}
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			for (int q = 0; q < n; q++)
			{
				if (i == j || i == q || j == q)
					continue;
				if (ar[i] + ar[j] <= ar[q] || ar[i] + ar[q] <= ar[j] || ar[j] + ar[q] <= ar[i])
					continue;
				vector<int> v;
				v.push_back(ar[i] + ar[j] + ar[q]);
				v.push_back(ar[i]);
				v.push_back(ar[j]);
				v.push_back(ar[q]);
				res.push_back(v);
			}
		}
	}
	sort(res.begin(), res.end());
	if (res.size() == 0)
	{
		cout << -1 << endl;
		return 0;
	}
	vector<int> v = res.back();
	cout << v[3] << " " << v[2] << " " << v[1] << endl;

	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.235
easy
----------
PROBLEM STATEMENT:
You are given two  arrays, [expression] integers.

A pair of indices [expression]. A set containing beautiful pairs is called a beautiful set.

A beautiful set is called pairwise disjoint if for every pair [expression]. 

Your task is to change exactly [expression] so that the size of the pairwise disjoint beautiful set is maximum.

Function Description  

Complete the beautifulPairs function in the editor below.  It should return an integer that represents the maximum number of pairwise disjoint beautiful pairs that can be formed.  

beautifulPairs has the following parameters:  


A: an array of integers  
B: an array of integers  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

int n;
int cntA[1001];
int cntB[1001];

int MAIN()
{
	memset(cntA, 0, sizeof(cntA));
	memset(cntB, 0, sizeof(cntB));
	cin >> n;
	for(int i = 1; i <= n; i++)
	{
		int t;
		cin >> t;
		cntA[t] ++;
	}
	for(int i = 1; i <= n; i++)
	{
		int t;
		cin >> t;
		cntB[t] ++;
	}
	int ans = 0;
	for(int i = 1; i <= 1000; i++)
		ans += min(cntA[i], cntB[i]);
	if(ans == n)
		ans --;
	else
		ans ++;
	cout << ans << endl;
	
	return 0;
}

int main()
{
	int start = clock();
	#ifdef LOCAL_TEST
		freopen("in.txt", "r", stdin);
		freopen("out.txt", "w", stdout);
	#endif
	ios :: sync_with_stdio(false);
	cout << fixed << setprecision(16);
	int ret = MAIN();
	#ifdef LOCAL_TEST
		cout << "[Finished in " << clock() - start << " ms]" << endl;
	#endif
	return ret;
}

----------
====================
----------
ALGORITHMS.236
medium
----------
PROBLEM STATEMENT:
Alice is a kindergarten teacher. She wants to give some candies to the children in her class. &nbsp;All the children sit in a line and each&nbsp;of them&nbsp;has a rating score according to his or her performance in the class. &nbsp;Alice wants to give at least 1 candy to each child. If two children sit next to each other, then the one with the higher rating must get more candies. Alice wants to minimize the total number of candies she must buy.

For example, assume her students' ratings are [4, 6, 4, 5, 6, 2].  She gives the students candy in the following minimal amounts: [1, 2, 1, 2, 3, 1].  She must buy a minimum of 10 candies.  

Function Description

Complete the candies function in the editor below.  It must return the minimum number of candies Alice must buy.  

candies has the following parameter(s):  


n: an integer, the number of children in the class  
arr: an array of integers representing the ratings of each student  

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <string>
using namespace std;

typedef long long ll;

int a[100005],b[100005];

inline int maxi(int x,int y) {
	return (x>y)?x:y;
}

int main() {
int i,j,n;
ll ans;

	scanf("%d",&n);
	for (i=1;i<=n;++i) {
		scanf("%d",&a[i]);
	}
	a[0]=a[1];
	a[n+1]=a[n];
	for (i=1;i<=n;++i) {
		if ((a[i]<=a[i+1]) && (a[i]<=a[i-1])) {
			b[i]=1;
			for (j=i-1;j && (a[j]>a[j+1]);--j) {
				b[j]=b[j+1]+1;
			}
			for (;i<n && (a[i+1]>a[i]);++i) {
				b[i+1]=b[i]+1;
			}
		}
	}
	ans=0;
	for (i=1;i<=n;++i) {
		if ((a[i]>a[i-1]) && (a[i]>a[i+1])) {
			b[i]=maxi(b[i-1],b[i+1])+1;
		}
		ans+=b[i];
	}
	printf("%Ld\n",ans);
	return 0;

}
----------
====================
----------
ALGORITHMS.237
easy
----------
PROBLEM STATEMENT:
Sherlock Holmes suspects his archenemy Professor Moriarty is once again plotting something diabolical. Sherlock's companion, Dr. Watson, suggests Moriarty may be responsible for MI6's recent issues with their supercomputer, The Beast. 

Shortly after resolving to investigate, Sherlock receives a note from Moriarty boasting about infecting The Beast with a virus.  He also gives him a clue:  an integer. Sherlock determines the key to removing the virus is to find the largest Decent Number having that number of digits.

A Decent Number has the following properties:


Its digits can only be 3's and/or 5's.
The number of 3's it contains is divisible by 5.
The number of 5's it contains is divisible by 3.
It is the largest such number for its length. 


Moriarty's virus shows a clock counting down to The Beast's destruction, and time is running out fast. Your task is to help Sherlock find the key before The Beast is destroyed!

For example, the numbers [expression]'s in the second.  They are the largest values for those length numbers that have proper divisibility of digit occurrences.  

Function Description

Complete the decentNumber function in the editor below.  It should print the decent number for the given length, or [expression] if a decent number of that length cannot be formed.  

decentNumber has the following parameter(s):  


n: the integer length of the decent number to create

----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <memory.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash

#define  INF 100000000
#define eps 1e-8
//#define M_PI 3.141592653589793
//#define mx 1000000000000ll
#define bs 1000000007

//#define free asdfasdfsdadsg
//#define szz 400
//#define pb push_back
#define MAXN 10000
#define free afdshjioey
//#define SIZE 60
//#define bsize 250
#define clone agsdahfaassdg

using namespace std;

long tests,l,n,r;

int main(){
//freopen("line3.in","r",stdin);
//freopen("line3.out","w",stdout);
//freopen("C:/input.txt","r",stdin);
//freopen("C:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);

cin>>tests;
for (;tests;--tests)
{
 cin>>n;
 l=n;r=0;
 while ((l%3>0||r%5>0)&&l>=0){--l;++r;}
 if (l<0)cout<<-1<<endl;
 else
 {
     for (int i=0;i<l;i++)
     cout<<5;
     for (int i=0;i<r;i++)
     cout<<3;
     cout<<endl;
 }
}

cin.get();cin.get();
return 0;}

----------
====================
----------
ALGORITHMS.238
easy
----------
PROBLEM STATEMENT:
Priyanka works for an international toy company that ships by container.  Her task is to the determine the lowest cost way to combine her orders for shipping.  She has a list of item weights.  The shipping company has a requirement that all items loaded in a container must weigh less than or equal to 4 units plus the weight of the minimum weight item.  All items meeting that requirement will be shipped in one container.

What is the smallest number of containers that can be contracted to ship the items based on the given list of weights?

For example, there are items with weights [expression] units of the minimum weight item.  

Function Description  

Complete the toys function in the editor below.  It should return the minimum number of containers required to ship.  

toys has the following parameter(s):  


w: an array of integers that represent the weights of each order to ship  

----------
TOP SOLUTION:
----------
//priyanka-and-toys.cpp
//Priyanka and Toys
//Weekly Challenges - Week 12
//Author: derekhh

#include<iostream>
#include<algorithm>
using namespace std;

int w[100000];

int main()
{
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> w[i];
	sort(w, w + n);
	int ans = 1, prev = w[0];
	for (int i = 1; i < n; i++)
		if (w[i] - prev > 4)
			prev = w[i], ans++;
	cout << ans << endl;
	return 0;
}
----------
====================
----------
ALGORITHMS.239
easy
----------
PROBLEM STATEMENT:
You are given an unordered array of unique integers incrementing from [expression].  You can swap any two elements a limited number of times.  Determine the largest lexicographical value array that can be created by executing no more than the limited number of swaps.  

For example, if [expression] with the other elements:  

[expression]
[expression]
[expression]



The highest value of the four (including the original) is [expression].

Function Description  

Complete the largestPermutation function in the editor below.  It must return an array that represents the highest value permutation that can be formed.  

largestPermutation has the following parameter(s):  


k: an integer that represents the limit of swaps  
arr: an array of integers  

----------
TOP SOLUTION:
----------
#include<iostream>
using namespace std;
int main()
{
int t,n,k;
{
cin>>n>>k;
int a[n+1],pos[n+1];
for(int i=1;i<=n;i++)
{
cin>>a[i];
pos[a[i]]=i; //position of a[i] will be i
}
for(int i=1;i<=n;i++)
{
if(!k) //no more swapping can be done
break;
else
{
if(a[i]!=n-i+1)
{
k--;
int temp = a[i]; //swapping a[i] with n-i+1
a[i] = n-i+1;
a[pos[n-i+1]] = temp;
pos[temp] = pos[n-i+1]; //swapping a[i]'s and a[n-i+1]'s positions
pos[n-i+1] = i;
}
}
}
for(int i=1;i<=n;i++) //output array after swapping is done
cout<<a[i]<<" ";
}

}
----------
====================
----------
ALGORITHMS.240
easy
----------
PROBLEM STATEMENT:
Mark and Jane are very happy after having their first child. Their son loves toys, so Mark wants to buy some. There are a number of different toys lying in front of him, tagged with their prices.  Mark has only a certain amount to spend, and he wants to maximize the number of toys he buys with this money.

Given a list of prices and an amount to spend, what is the maximum number of toys Mark can buy?  For example, if [expression] items.

Function Description

Complete the function maximumToys in the editor below.  It should return an integer representing the maximum number of toys Mark can purchase.  

maximumToys has the following parameter(s):  


prices:  an array of integers representing toy prices  
k:  an integer, Mark's budget

----------
TOP SOLUTION:
----------
//#pragma comment(linker,"/STACK:16777216") /*16Mb*/
//#pragma comment(linker,"/STACK:33554432") /*32Mb*/
#define _CRT_SECURE_NO_DEPRECATE
#include<sstream>
#include<iostream>
#include<numeric>
#include<sstream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<memory>
#include<string>
#include<vector>
#include<cctype>
#include<list>
#include<queue>
#include<deque>
#include<stack>
#include<map>
#include<complex>
#include<set>
#include<algorithm>

using namespace std;

typedef unsigned long long      ui64;
typedef long long               i64;
typedef	vector<int>             VI;
typedef	vector<bool>            VB;
typedef	vector<VI>              VVI;
typedef	vector<string>          VS;
typedef	pair<int,int>           PII;
typedef map<string,int>         MSI;
typedef set<int>                SI;
typedef set<string>             SS;
typedef complex<double>         CD;
typedef vector< CD >            VCD;
typedef map<int,int>            MII;
typedef	pair<double,double>     PDD;

#define PB                      push_back
#define MP                      make_pair
#define X                       first
#define Y                       second
#define FOR(i, a, b)            for(int i = (a); i < (b); ++i)
#define RFOR(i, a, b)           for(int i = (a) - 1; i >= (b); --i)
#define CLEAR(a, b)             memset(a, b, sizeof(a))
#define SZ(a)                   int((a).size())
#define ALL(a)                  (a).begin(), (a).end()
#define RALL(a)                 (a).rbegin(), (a).rend()
#define INF                     (2000000000)

#ifdef _DEBUG
#define eprintf(...) fprintf (stderr, __VA_ARGS__)
#else
#define eprintf(...) assert (true)
#endif

const double PI = acos(-1.0);

int main() {
	int n,k;
	scanf("%d%d",&n,&k);
	VI a(n);
	FOR(i,0,n) {
		scanf("%d",&a[i]);
	}
	
	sort(ALL(a));
	FOR(i,0,n) {
		k -= a[i];
		if(k<0) {
			cout << i << endl;
			return 0;
		}
	}
	cout << n << endl;
	return 0;
}
----------
====================
----------
ALGORITHMS.241
medium
----------
PROBLEM STATEMENT:
A group of friends want to buy a bouquet of flowers.  The florist wants to maximize his number of new customers and the money he makes.  To do this, he decides he'll multiply the price of each flower by the number of that customer's previously purchased flowers plus [expression] and so on.  

Given the size of the group of friends, the number of flowers they want to purchase and the original prices of the flowers, determine the minimum cost to purchase all of the flowers.

For example, if there are [expression].  

Function Description

Complete the getMinimumCost function in the editor below.  It should return the minimum cost to purchase all of the flowers.  

getMinimumCost has the following parameter(s):


c: an array of integers representing the original price of each flower
k: an integer, the number of friends

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <algorithm>
using namespace std;

int a[102];

int main() {
int i,j,m,n;
long long c,ans=0;
	scanf("%d%d",&n,&m);
	for (i=0;i<n;++i) {
		scanf("%d",&a[i]);
	}
	sort(a,a+n);
	for (i=n-1,c=0,j=0;i>=0;--i) {
		if (j==0) {
			++c;
		}
		ans+=c*a[i];
		if (++j==m) {
			j=0;
		}
	}
	printf("%Ld\n",ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.242
medium
----------
PROBLEM STATEMENT:
You will be given a list of integers, [expression].  Unfairness of an array is calculated as

[expression]  

Where: 
- max denotes the largest integer in [expression] 
- min denotes the smallest integer in [expression]  

As an example, consider the array [expression]. 
[expression] 
Testing for all pairs, the solution [expression] provides the minimum unfairness.

Note: Integers in [expression] may not be unique. 

Function Description

Complete the maxMin function in the editor below.  It must return an integer that denotes the minimum possible value of unfairness.  

maxMin has the following parameter(s):


k:  an integer, the number of elements in the array to create
arr:  an array of integers . 

----------
TOP SOLUTION:
----------
/*
Author:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%   LALIT KUNDU      %%%%%%%% 
%%%%%%%%   IIIT HYDERABAD   %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 */
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<iostream>
#include<vector>
#include<cassert>
#include<sstream>
#include<map>
#include<set>
#include<stack>
#include<queue>
#include<algorithm>
using namespace std;
#define pb push_back
#define mp make_pair
#define clr(x) x.clear()
#define sz(x) ((int)(x).size())
#define F first
#define S second
#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,b) for(i=0;i<b;i++)
#define rep1(i,b) for(i=1;i<=b;i++)
#define pdn(n) printf("%d\n",n)
#define sl(n) scanf("%lld",&n)
#define sd(n) scanf("%d",&n)
#define pn printf("\n")
typedef pair<int,int> PII;
typedef vector<PII> VPII;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef long long LL;
int main()
{
    vector < long long  int > arr;
    long long int n,i,ans=1000000000000000000LL,k;
    sl(n),sl(k);
    arr.resize(n);
    for(i=0; i<n; i++)
        sl(arr[i]);
    sort(arr.begin(),arr.end());
    for(i=0; i<=n-k; i++)
        if( (arr[i+k-1]-arr[i]) < ans)ans=arr[i+k-1]-arr[i];
    cout << ans << endl;
    return 0;
}


----------
====================
----------
ALGORITHMS.243
easy
----------
PROBLEM STATEMENT:
Jim's Burgers has a line of hungry customers.  Orders vary in the time it takes to prepare them.  Determine the order the customers receive their orders.  Start by numbering each of the customers from [expression], front of the line to the back.  You will then be given an order number and a preparation time for each customer.   

The time of delivery is calculated as the sum of the order number and the preparation time.  If two orders are delivered at the same time, assume they are delivered in ascending customer number order.

For example, there are [expression].:

[expression]
[expression]
[expression]
[expression]
[expression]



We see that the orders are delivered to customers in the following order:

[expression]
[expression]
[expression]



Function Description  

Complete the jimOrders function in the editor below.  It should return an array of integers that represent the order that customers' orders are delivered.  

jimOrders has the following parameter(s):  


orders: a 2D integer array where each [expression].  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

int N;
pair<int, int> A[1000];

int main()
{
    scanf("%d", &N);
    int a, b;
    for(int i=0; i<N; i++)
    {
        scanf("%d%d", &a, &b);
        A[i]=make_pair(a+b, i+1);
    }
    sort(A, A+N);
    for(int i=0; i<N; i++)
        printf("%d ", A[i].second);
    printf("\n");
    return 0;
}

----------
====================
----------
ALGORITHMS.244
easy
----------
PROBLEM STATEMENT:
Consider two [expression].

You are given [expression] satisfying the relation above exists.  Otherwise, print NO.  

Function Description  

Complete the twoArrays function in the editor below.  It should return a string, either YES or NO.  

twoArrays has the following parameter(s):  


k: an integer  
A: an array of integers  
B: an array of integers  

----------
TOP SOLUTION:
----------
/*
 * File:      main.cpp
 * Author:    Hrayr [HarHro94]
 * Problem:
 * IDE:       Visual C++ 2012
 */
#pragma comment(linker, "/STACK:66777216")
#define _CRT_SECURE_NO_WARNINGS
#include <functional>
#include <algorithm>
#include <iostream>
#include <sstream>
#include <fstream>
#include <cassert>
#include <iomanip>
#include <cstring>
#include <cstdio>
#include <string>
#include <vector>
#include <ctime>
#include <queue>
#include <stack>
#include <cmath>
#include <set>
#include <map>
using namespace std;

typedef long long LL;
typedef long double LD;
#define pb push_back
#define mp make_pair
#define all(v) (v).begin(), (v).end()
#define sz(v) (int)(v).size()

const int N = 157;

int main()
{
#ifdef harhro94
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif

    int T;
    cin >> T;
    while (T--)
    {
        int n, x;
        cin >> n >> x;
        vector<int> a(n), b(n);
        for (int i = 0; i < n; ++i)
            cin >> a[i];
        for (int i = 0; i < n; ++i)
            cin >> b[i];
        sort(all(a));
        sort(all(b));
        reverse(all(a));
        bool f = true;
        for (int i = 0; i < n; ++i)
            f &= (a[i] + b[i] >= x);
        puts(f ? "YES" : "NO");
    }

#ifdef harhro94
    cerr << fixed << setprecision(3) << "\nExecution time = " << clock() / 1000.0 << "s\n";
#endif
    return 0;
}
----------
====================
----------
ALGORITHMS.245
hard
----------
PROBLEM STATEMENT:
Alice gives Bob a board composed of [expression] wooden squares and asks him to find the minimum cost of breaking the board back down into its individual squares. To break the board down, Bob must make cuts along its horizontal and vertical lines. 

To reduce the board to squares, Bob makes horizontal and vertical cuts across the entire board.  Each cut has a given cost, [expression] squares is the sum of the costs of each successive cut.   

Can you help Bob find the minimum cost?  The number may be large, so print the value modulo [expression].

For example, you start with a [expression].

Function Description  

Complete the boardCutting function in the editor below.  It should return an integer.  

boardCutting has the following parameter(s):  


cost_x: an array of integers, the costs of vertical cuts  
cost_y: an array of integers, the costs of horizontal cuts  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool compare(pair<char,unsigned long long> A,pair<char,unsigned long long> B)
{
	return A.second > B.second;
}

int main()
{
	int T;
	cin>>T;
	for(;T--;)
	{
		int M,N,cost;
		cin>>M>>N;
		vector<pair<char,unsigned long long> > cutCost;
		for (int i = 0; i < M-1; ++i)
		{
			cin>>cost;
			cutCost.push_back(make_pair('y',cost));
		}
		for (int i = 0; i < N-1; ++i)
		{
			cin>>cost;
			cutCost.push_back(make_pair('x',cost));
		}
		sort(cutCost.begin(),cutCost.end(),compare);

		unsigned long long vcut = 1, hcut = 1, totalcost = 0;

		for (int i = 0; i < cutCost.size(); ++i)
		{
			if(cutCost[i].first == 'y')
			{
				totalcost = (totalcost + ((vcut*cutCost[i].second)%1000000007))%1000000007;
				++hcut;
			}
			else if(cutCost[i].first == 'x')
			{
				totalcost = (totalcost + ((hcut*cutCost[i].second)%1000000007))%1000000007;
				++vcut;
			}
		}
		cout<<totalcost<<"\n";
	}   
    return 0;
}
----------
====================
----------
ALGORITHMS.246
advanced
----------
PROBLEM STATEMENT:
Given a string, [expression], we define some operations on the string as follows:


  a. [expression] 
  
  
  b. [expression] 
  
  
  c. [expression] and so on.  


Given a string [expression].

For example, [expression].  

Function Description

Complete the reverseShuffleMerge function in the editor below.  It must return the lexicographically smallest string fitting the criteria.  

reverseShuffleMerge has the following parameter(s):


s: a string

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

char in[10005];
int L[128];
int need[128];
char ans[10005];
int ansPos;

using namespace std;

int main()
{
	scanf("%s", in);
    for(int i=0; in[i]; ++i){
        ++L[in[i]];
    }
    int len=strlen(in);
    for(int j=0; j < 128; ++j)
        need[j]=L[j]/2;
    int pos=len-1;
    while(ansPos < len/2){
        bool init=0;
        char best;
        int ind, i;
        for(i=pos; i >= 0; --i){
            if((!init || in[i] < best) && need[in[i]]){
                init=1;
                best=in[i];
                ind=i;
            }
            L[in[i]]--;
            if(L[in[i]] < need[in[i]])
                break;
        }
        for(; i < ind; ++i){
            ++L[in[i]];
        }
        --need[best];
        ans[ansPos++]=best;
		pos=ind-1;
    }
    printf("%s", ans);
	return 0;
}


----------
====================
----------
ALGORITHMS.247
medium
----------
PROBLEM STATEMENT:
Goodland is a country with a number of evenly spaced cities along a line.  The distance between adjacent cities is [expression].

You are given a list of city data.  Cities that may contain a power plant have been labeled [expression], find the lowest number of plants that must be built such that all cities are served.  The distribution range limits supply to cities where distance is less than k.

For example, you are given [expression].  It cannot be done using the current distribution constraint.

Function Description  

Complete the pylons function in the editor below.  It should return an integer that represents the minimum number of plants required or -1 if it is not possible.  

pylons has the following parameter(s):  


k: an integer that represents distribution range  
arr: an array of integers that represent suitability as a building site  

----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }

int main() {
	int n; int k;
	while(~scanf("%d%d", &n, &k)) {
		vector<int> a(n);
		for(int i = 0; i < n; ++ i)
			scanf("%d", &a[i]);
		vi v;
		rep(i, n) if(a[i] != 0)
			v.push_back(i);
		int j = 0;
		int ans = 0;
		for(int i = 0; i < n; ) {
			for(; j + 1 < (int)v.size() && v[j + 1] <= i + k - 1; ++ j);
			if(j == v.size() || i + k - 1 < v[j]) {
				ans = INF;
				break;
			}
			++ ans;
			i = v[j] + k;
			++ j;
		}
		printf("%d\n", ans == INF ? -1 : ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.248
medium
----------
PROBLEM STATEMENT:
Quibdó in Colombia is one among the cities that receive maximum rainfall in the world.



All year round, the city is covered in clouds. The city has many towns, located on a one-dimensional line. The positions and populations of each town on the number line are known to you. 
Every cloud covers all towns located at a certain distance from it. A town is said to be in darkness if there exists at least one cloud such that the town is within the cloud's range. Otherwise, it is said to be sunny.



The city council has determined that they have enough money to remove exactly one cloud using their latest technology. Thus they want to remove the cloud such that the fewest number of people are left in darkness after the cloud is removed. What is the maximum number of people that will be in a sunny town after removing exactly one cloud?

Note: If a town is not covered by any clouds, then it is already considered to be sunny, and the population of this town must also be included in the final answer.

Complete the function maximumPeople which takes four arrays representing the populations of each town, locations of the towns, locations of the clouds, and the extents of coverage of the clouds respectively, and returns the maximum number of people that will be in a sunny town after removing exactly one cloud.
----------
TOP SOLUTION:
----------
/*
*/

//#pragma GCC optimize("O3")
#define _CRT_SECURE_NO_WARNINGS
#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>

#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk

#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd
#define have adsgagshdshfhds
#define ends asdgahhfdsfshdshfd

#define eps 1e-8
#define M_PI 3.141592653589793
#define bsize 512

#define ldouble long double
using namespace std;

#define bs 1000000007

const int N = 600031;

int tests;

int n,P[N],X[N];
vector<pair<int,pair<int,int> > > events;
set<int> S;
long long m,y[N],r[N];
long long ans;

map<long long, long long> will_add;
map<long long, long long> ::iterator it;

int main(){
//	freopen("apache.in","r",stdin);
//	freopen("apache.out","w",stdout);
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
//	cin.tie(0);

	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>P[i];
	}

	for (int i=1;i<=n;i++){
		cin>>X[i];
		events.push_back(make_pair(X[i],make_pair(0,i)));
	}

	cin>>m;
	for (int i=1;i<=m;i++){
		cin>>y[i];
	}
	for (int i=1;i<=m;i++){
		cin>>r[i];
		events.push_back(make_pair(y[i]-r[i],make_pair(-i,0)));
		events.push_back(make_pair(y[i]+r[i],make_pair(i,0)));
	}
	sort(events.begin(),events.end());
	for (int i=0;i<events.size();i++){
		if (events[i].second.first>0)// remove
		{
			int id=events[i].second.first;
			S.erase(id);
		}
		if (events[i].second.first<0){ // add
			int id=-events[i].second.first;
			S.insert(id);
		}
		if (events[i].second.first==0){ // query
			int id=events[i].second.second;
			if (S.size()==0){
				ans+=P[id];
			}
			if (S.size()==1){
				int onl=(*S.begin());
				will_add[onl]+=P[id];
			}
		}
	}

	long long max_add=0;
	for (it=will_add.begin();it!=will_add.end();it++){
		max_add=max(max_add,(*it).second);
	}
	cout<<ans+max_add<<endl;

//	cin.get(); cin.get();
	return 0;
}

----------
====================
----------
ALGORITHMS.249
hard
----------
PROBLEM STATEMENT:
Chief's bot is playing an old DOS based game.  There is a row of buildings of different heights arranged at each index along a number line.  The bot starts at building [expression].  You must determine the minimum energy his bot needs at the start so that he can jump to the top of each building without his energy going below zero.  

Units of height relate directly to units of energy.  The bot's energy level is calculated as follows:  


If the bot's [expression]  
If the bot's [expression]  


For example, building heights are given as [expression], we get the following table:

botEnergy   height  delta
4               2       +2
6               3       +3
9               4       +5
14              3       +11
25              2       +23
48


That allows the bot to complete the course, but may not be the minimum starting value.  The minimum starting [expression].  

Function Description  

Complete the chiefHopper function in the editor below.  It should return an integer that represents the minimum starting [expression] that will allow completion of the course.  

chiefHopper has the following parameter(s):  


arr: an array of integers that represent building heights  

----------
TOP SOLUTION:
----------
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <algorithm>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <limits>
#include <cstring>
#include <string>
using namespace std;

#define pairii pair<int, int>
#define llong long long
#define pb push_back
#define sortall(x) sort((x).begin(), (x).end())
#define INFI  numeric_limits<int>::max()
#define INFLL numeric_limits<llong>::max()
#define INFD  numeric_limits<double>::max()
#define FOR(i,s,n) for (int (i) = (s); (i) < (n); (i)++)
#define FORZ(i,n) FOR((i),0,(n))

const int MAXN = 100005;
int ar[MAXN];

void solve() {
  int n;
  scanf("%d",&n);
  FORZ(i,n) scanf("%d",ar+i);
  int res = 0;
  for (int i = n-1; i >= 0; i--) {
    int x = res + ar[i];
    res = x/2 + x%2;
  }
  printf("%d",res);
}

int main() {
#ifdef DEBUG
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  solve();
  return 0;
}

----------
====================
----------
ALGORITHMS.250
hard
----------
PROBLEM STATEMENT:
Watson gives Sherlock an array of integers.  Given the endpoints of an integer range, for all [expression]'s that result in that value, return the lowest one.  

For example, your array [expression] inclusive.

[expression]
[expression]
[expression]
[expression]



We look at the Min column and see the maximum of those three values is [expression].

Function Description  

Complete the sherlockAndMinimax function in the editor below.  It should return an integer as described.  

sherlockAndMinimax has the following parameters: 
- arr: an array of integers 
- p: an integer that represents the lowest value of the range for [expression] 
- q: an integer that represents the highest value of the range for [expression]  
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(int *x, int *y){reader(x);reader(y);}
void writer(int x, char c){int i,sz=0,m=0;char buf[10];if(x<0)m=1,x=-x;while(x)buf[sz++]=x%10,x/=10;if(!sz)buf[sz++]=0;if(m)mypc('-');while(sz--)mypc(buf[sz]+'0');mypc(c);}

int N, A[1000], P, Q;

int test[100000], test_size;

int check(int k){
  int i;
  int res = 2000000000;
  rep(i,N) res = min(res, abs(A[i]-k));
  return res;
}

int main(){
  int i, j, k;
  int res, mx;

  reader(&N);
  rep(i,N) reader(A+i);
  reader(&P,&Q);

  sort(A,A+N);

  mx = -1;
  test_size = 0;
  test[test_size++] = P;
  test[test_size++] = Q;
  REP(i,1,N) {
    k = (A[i] + A[i-1])/2;
    if(P<=k && k<=Q) test[test_size++] = k;
    k = (A[i] + A[i-1])/2 + 1;
    if(P<=k && k<=Q) test[test_size++] = k;
  }
  sort(test,test+test_size);

  mx = -1;
  rep(i,test_size){
    k = check(test[i]);
    if(k > mx) mx = k, res = test[i];
  }
  writer(res, '\n');

  return 0;
}

----------
====================
----------
ALGORITHMS.251
hard
----------
PROBLEM STATEMENT:
Victoria is splurging on expensive accessories at her favorite stores. Each store stocks [expression]). Assume that an item's type identifier is the same as its cost, and the store has an unlimited supply of each accessory.

Victoria wants to purchase a total of [expression] accessories according to the following rule:


  Any [expression] different types of accessories. 


For example, if [expression] distinct types of items. 

Given [expression] shopping trips, find and print the maximum amount of money that Victoria can spend during each trip; if it's not possible for Victoria to make a purchase during a certain trip, print SAD instead. You must print your answer for each trip on a new line.
----------
TOP SOLUTION:
----------
#include<stdio.h>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<bitset>
#include<utility>
#include<functional>
#include<iomanip>
#include<sstream>
#include<ctime>
#include<cassert>
using namespace std;
#define y0 y0z
#define y1 y1z
#define yn ynz
#define j0 j0z
#define j1 j1z
#define jn jnz
#define tm tmz
#define buli(x) (__builtin_popcountll(x))
#define bur0(x) (__builtin_ctzll(x))
#define bul2(x) (63-__builtin_clzll(x))
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define fil(a,b) memset((a),(b),sizeof(a))
#define cl(a) fil(a,0)
#define siz(x) ((int)(x).size())
#define all(x) (x).begin(),(x).end()
#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)
#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)
#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)
#define pw(x) ((ll(1))<<(x))
#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))
#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))
void getre(){int x=0;printf("%d\n",1/x);}
void gettle(){int res=1;while(1)res<<=1;printf("%d\n",res);}
typedef pair<int,int> pii;
typedef vector<int> vi;
typedef vector<pii> vpii;
template<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}
template<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}
template<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}
template<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}
template<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}
template<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}
#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)
    #define lld "%I64d"
#else
    #define lld "%lld"
#endif
inline void gn(long long&x){
	int sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');
	while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;
}
inline void gn(int&x){long long t;gn(t);x=t;}
inline void gn(unsigned long long&x){long long t;gn(t);x=t;}
inline void gn(double&x){double t;scanf("%lf",&t);x=t;}
inline void gn(long double&x){double t;scanf("%lf",&t);x=t;}
inline void gs(char *s){scanf("%s",s);}
inline void gc(char &c){while((c=getchar())>126 || c<33);}
inline void pc(char c){putchar(c);}
#ifdef JCVB
#define debug(...) fprintf(stderr, __VA_ARGS__)
#else
#define debug(...) 
#endif
typedef long long ll;
typedef double db;
inline ll sqr(ll a){return a*a;}
inline db sqrf(db a){return a*a;}
const int inf=0x3f3f3f3f;
const db pi=3.14159265358979323846264338327950288L;
const db eps=1e-6;
//const int mo=0;
//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}

int d,n,l,a;


ll sum(int l,int r){
	return 1ll*(l+r)*(r-l+1)/2;
}
inline ll val(int x){
	int lef=l-(n-1);
	int num=lef/x;
	int res=lef%x;
	ll ans=sum(a-d+1-num+1,a-d+1)*x;
	ans+=(a-d+1ll-num)*res;

	ans+=sum(a-d+2,a-1)*x;
	res=n-1-x*(d-2);
	ans+=1ll*res*a;
	return ans;
}
int main()
{
#ifdef JCVB
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);
	int _time_jc=clock();
#endif
	int te;gn(te);
	while(te--){
		gn(l);gn(a);gn(n);gn(d);

		if(d==1){
			printf(lld"\n",1ll*a*l);
			continue;
		}
		if(a<d){
			printf("SAD\n");
			continue;
		}
		int lef=l-(n-1);

		int l1=cei(lef,a-d+1);
		int r1=flo(n-1,d-1);
		ll ma=0;
		if(l1>r1){
			printf("SAD\n");
			continue;
		}
		for (int x=l1;x<=r1;x++)upmax(ma,val(x));
		//printf(lld"\n",max(val(l1),val(r1)));
		printf(lld"\n",ma);
	}
#ifdef JCVB
	debug("time: %d\n",int(clock()-_time_jc));
#endif
	return 0;
}



----------
====================
----------
ALGORITHMS.252
advanced
----------
PROBLEM STATEMENT:
For an upcoming programming contest, Roy is forming some teams from the students of his university. A team can have any number of contestants. 

Roy knows the skill level of each contestant. To make the teams work as a unit, he forms the teams based on some rules. Each of the team members must have a unique skill level for the team.  If a member's skill level is [expression]. Note that a contestant can write buggy code and thus can have a negative skill level.

The more contestants on the team, the more problems they can attempt at a time so Roy wants to form teams such that the smallest team is as large as possible.

For example, there are [expression].

Note: There is an edge case where [expression] members.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <set>
#include <algorithm>
using namespace std;

const int NMAX = 100010;

int T, N, V[NMAX], Ans;
multiset<pair<int,int> > S;

int main()
{
   // freopen("c.in", "r", stdin);
  //  freopen("c.out", "w", stdout);

    scanf("%i", &T);
    for(; T; T --)
    {
        scanf("%i", &N);
        for(int i = 1; i <= N; ++ i)
            scanf("%i", &V[i]);

        sort(V + 1, V + N + 1);

        S.clear();
        S.insert(make_pair(V[1] - 1, 0));
        Ans = 0x3f3f3f3f;

        for(int i = 1; i <= N; ++ i)
        {
            while(!S.empty() && S.begin() -> first < V[i] - 1)
            {
                Ans = min(Ans, S.begin() -> second);
                S.erase(S.begin());
            }

            if(S.empty())
                S.insert(make_pair(V[i], 1));
            else
            {
                if(S.begin() -> first == V[i])
                    S.insert(make_pair(V[i], 1));
                else
                {
                    int Nr = S.begin() -> second;
                    S.erase(S.begin());
                    S.insert(make_pair(V[i], Nr + 1));
                }
            }
        }

        while(!S.empty())
        {
            Ans = min(Ans, S.begin() -> second);
            S.erase(S.begin());
        }

        printf("%i\n", Ans);
    }
}

----------
====================
----------
ALGORITHMS.253
hard
----------
PROBLEM STATEMENT:
Meereen is famous for its fighting pits where fighters fight each other to the death.

Initially, there are [expression] always launching the first attack. The fight ends when all the fighters on one of the teams are dead.

Assume each team always attacks optimally. Each attack is performed as follows:


The attacking team chooses a fighter from their team with strength [expression].
The chosen fighter chooses at most [expression] fighters from other team and kills all of them. 


The Great Masters don't want to see their favorite fighters fall in battle, so they want to build their teams carefully and know who will win different team matchups. They want you to perform two type of queries:


1 p x Add a new fighter with strength [expression].
2 x y Print the name of the team that would win a matchup between teams [expression]. 


Given the initial configuration of the teams and [expression] queries, perform each query so the Great Masters can plan the next fight.

Note: You are determining the team that would be the winner if the two teams fought. No fighters are actually dying in these matchups so, once added to a team, a fighter is available for all future potential matchups.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

const int maxn = 210000;
vi teams[maxn], same[maxn];

bool emulate(int x, int y) {
    int xi = teams[x].size() - 1, yi = teams[y].size() - 1;
    while (xi >= 0 && yi >= 0) {
        int skip = min((same[x][xi] - 1) / teams[y][yi], (same[y][yi] - 1) / teams[x][xi]);
        uax(skip, 0);
        xi -= skip * teams[y][yi];
        yi -= skip * teams[x][xi];
        
        yi -= teams[x][xi];
        if (yi < 0) break;
        xi -= teams[y][yi];
    }
    return xi >= 0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int n, k, q;
    cin >> n >> k >> q;
    forn(i, n) {
        int s, t;
        cin >> s >> t;
        teams[--t].pb(s);
    }
    forn(i, k) {
        sort(all(teams[i]));
        same[i].pb(0);
        for1(j, teams[i].size() - 1) {
            if (teams[i][j] != teams[i][j - 1]) same[i].pb(1);
            else same[i].pb(same[i][j - 1] + 1);
        }
    }
    forn(i, q) {
        int t;
        cin >> t;
        if (t == 1) {
            int p, id;
            cin >> p >> id;
            --id;
            if (!teams[id].empty() && p == teams[id].back()) same[id].pb(same[id][same[id].size() - 1] + 1);
            else same[id].pb(1);
            teams[id].pb(p);
        } else {
            int x, y;
            cin >> x >> y;
            --x; --y;
            cout << (emulate(x, y) ? x : y) + 1 << '\n';
        }
    }

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.254
medium
----------
PROBLEM STATEMENT:
Lena developed a sorting algorithm described by the following pseudocode:

[expression]
    [expression]
        [expression]
    [expression]
    [expression]
    [expression]
    [expression]
    [expression]
    	[expression]
        [expression]
            [expression]
        [expression]
        [expression]
            [expression]
        [expression]
    [expression]
    [expression]
    [expression]
    [expression]
    
    [expression]
[expression]



We consider a comparison to be any time some [expression]. 

You must solve [expression] space-separated integers; if no such array exists, print -1 instead.
----------
TOP SOLUTION:
----------
//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,"====TESTING====\n")
  #define VALUE(x) cerr << "The value of " << #x << " is " << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,"%lld",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,"%lld",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf("%s",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + ".in").c_str (), "r", stdin);
  freopen ((s + ".out").c_str (), "w", stdout);
  #endif
}

//end of jonathanirvings' template v3.0.3 (BETA)

int q;
pair<LL,LL> batas[100005];
int l;
LL c;

bool valid(LL x, int k)
{
  return batas[k].fi <= x && x <= batas[k].se;
}

void solve(int st, int sz, LL rem)
{
  rem -= (sz - 1);
  // debug("\n>>>>%d %d %lld\n",st,sz,rem);
  if (sz == 0) return;
  FORN(i,1,sz)
  {
    int a = i - 1;
    int b = sz - 1 - a;
    // debug("%d %d %d %lld\n",i,a,b,rem-batas[a].fi);
    if (valid(rem - batas[a].fi, b))
    {
      printf("%d ", st + i - 1);
      solve(st, a, batas[a].fi);
      solve(st + a + 1, b, rem - batas[a].fi);
      return;
    } else if (valid(rem - batas[a].se, b))
    {
      printf("%d ", st + i - 1);
      solve(st, a, batas[a].se);
      solve(st + a + 1, b, rem - batas[a].se);
      return;
    }
  }
}

int main()
{
  batas[0] = mp(0,0);
  batas[1] = mp(0,0);
  FORN(i,2,100000)
  {
    int a = (i - 1) / 2;
    int b = (i - 1) - a;
    batas[i].se = (i - 1) + batas[i-1].se;
    batas[i].fi = (i - 1) + batas[a].fi + batas[b].fi;
  }
  // FORN(i,1,10) debug("%d %d\n",batas[i].fi,batas[i].se);
  scanf("%d",&q);
  TC(q)
  {
    scanf("%d %lld",&l,&c);
    if (c < batas[l].fi || c > batas[l].se)
    {
      puts("-1");
      continue;
    }
    solve(1, l,c);
    puts("");
  }
  return 0;
}










----------
====================
----------
ALGORITHMS.255
medium
----------
PROBLEM STATEMENT:
You are working at the cash counter at a fun-fair, and you have different types of coins available to you in infinite quantities. The value of each coin is already given. Can you determine the number of ways of making change for a particular number of units using the given types of coins? 

For example, if you have [expression] units in three ways: 
[expression].

Function Description  

Complete the getWays function in the editor below.  It must return an integer denoting the number of ways to make change.  

getWays has the following parameter(s):


n: an integer, the amount to make change for  
c: an array of integers representing available denominations  

----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <list>
#include <string>
#include <map>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <iostream>
#include <bitset>
#include <sstream>
#include <iterator>
#include <numeric>

using namespace std;

#define F_TO_R          freopen("input.txt", "r" , stdin)
#define _pair(x,y)      make_pair(x,y)
#define INF             (1<<30)
#define sf              scanf
#define pf              printf
#define mem(a,b)        memset(a, b, sizeof(a))
#define fs              first
#define se              second
#define MAX             1010
#define MAXR            205
#define MAXC            5
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int u_int;
const double PI = 2.0 * acos(0.0);
const double eps = 1e-11;
const int _mod = 1000000;
const int save[10][4] = {{0},{0},{6,2,4,8},{1,3,9,7},{6,4},{0},{0},{1,7,9,3},{6,8,4,2},{1,9}};
int todigit(char c) { return ( isdigit(c) ) ?( c - 48 ) : c ; }
int toint(string s) { int r = 0; istringstream sin(s); sin >> r; return r; }
ll tolong(string s) {  ll r = 0; istringstream sin(s); sin >> r; return r; }
double todouble(string s) { double r = 0.0 ; istringstream sin(s); sin >> r; return r; }
bool bit_check(int k , int p){ return (bool)(k&(1 << p)); }
int bit_set(int k , int p) { return k = (k|(1 << p));}
template < class T > string toString(T n) { ostringstream ost; ost << n; ost.flush() ; return ost.str(); }
template < class T > T Abs(T x) { return x > 0 ? x : -x;}
template < class T > T power(T N , T P) { return (P == 0) ?  1 : N * power(N , P - 1); }
template < class T > inline T max_(T a,T b) {return a > b ? a : b ;}
template < class T > inline T min_(T a,T b) {return a < b ? a : b ;}
template < class T > inline T gcd(T a,T b) {if(a < 0) return gcd(-a,b); if(b < 0)return gcd(a,-b); return (b == 0) ? a : gcd(b ,a % b);}
template < class T > inline T lcm(T a,T b) {if(a < 0) return lcm(-a,b); if(b < 0)return lcm(a,-b); return a * (b / gcd(a , b));}

//ll big_mod(ll n , ll  p , ll m)
//{
//  ll sum;
//  if(!p) return 1;
//  if(p % 2 == 0) { sum = big_mod(n  , p / 2 , m); return ((sum % m ) *(sum % m)) % m; }
//  else return (( n % m) * (big_mod( n , p - 1 , m) % m ))% m;
//}

//bool siv[MAX];
//int prime[MAX];
//void is_prime()
//{
//    int k = 0;
//    int n = sqrt(MAX);
//    prime[k++] = 2;
//    for(int i = 3 ; i < n ; i += 2) if(!siv[i]) for(int j = i * i ; j < MAX ; j += (2 * i)) siv[j] = true;
//    for(int i = 3 ; i < MAX ; i += 2) if(!siv[i]) prime[k++] = i;
//}
//
//int one[]={1,0,-1,0}; //4 Direction
//int two[]={0,1,0,-1}; //4 Direction
//int two[]={0,1,1,1,0,-1,-1,-1};//8 direction
//int one[]={2,1,-1,-2,-2,-1,1,2}; //Knight Direction
//int two[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction

///***************************************  END  **********************************************///


int num[1000];
int DP[100][20000];
int sum , k;
int call(int a , int b);

int main(int argc , char *argv[])
{
    k = 0;
    char *p;
    char in[100000];
    gets(in);
    p = strtok(in , ",");
    while(p != NULL)
    {
        num[k++] = atoi(p);
        p = strtok(NULL , ",");
    }
    //for(int i = 0 ; i < k ; ++i) pf("%d ", num[i]);
    sf("%d", &sum);
    mem(DP , -1);
    pf("%d\n",call(0 , 0));
    return 0;
}


int call(int a , int b)
{
    if(a >= k)
    {
        if(b == sum) return 1;
        return 0;
    }
    int &ret = DP[a][b];
    if(ret != -1) return ret;
    int one = 0;
    int two = 0;
    if(b + num[a] <= sum) one = call(a , b + num[a]);
    two = call(a + 1 , b);
    ret = one + two;
    return ret;
}



----------
====================
----------
ALGORITHMS.256
medium
----------
PROBLEM STATEMENT:
Christy is interning at HackerRank. One day she has to distribute some chocolates to her colleagues. She is biased towards her friends and plans to give them more than the others. One of the program managers hears of this and tells her to make sure everyone gets the same number.

To make things difficult, she must equalize the number of chocolates in a series of operations. For each operation, she can give [expression] chocolates to all but one colleague.  Everyone who gets chocolate in a round receives the same number of pieces.  

For example, assume the starting distribution is [expression].

Given a starting distribution, calculate the minimum number of operations needed so that every colleague has the same number of chocolates. 

Function Description  

Complete the equal function in the editor below.  It should return an integer that reperesents the minimum number of operations required.  

equal has the following parameter(s):  


arr: an array of integers to equalize  

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <map>
#include <utility>
#define MOD 1000000007
typedef long long LLD;
using namespace std;
int ar[20000];
int dp[2000];
int main()
{
    int t, n;
    cin >> t;
    while(t--)
    {
	int mn = 1999;
	cin >> n;
	for(int i = 0; i < n; i ++)
	{
	    cin >> ar[i];
	    mn = min(mn, ar[i]);
	}
	for(int i = 0; i < 2000; i ++)
	    dp[i] = MOD;
	dp[0] = 0;
	for(int i = 1; i < 1200; i ++)
	{
	    dp[i] = min(dp[i], dp[i-1] + 1);
	    if(i - 2 >= 0)
		dp[i] = min(dp[i], dp[i-2] + 1);
	    if(i - 5 >= 0)
		dp[i] = min(dp[i], dp[i-5] + 1);
	}
	int steps = MOD;
	for(int s = 0; s <= mn; s ++)
	{
	    int ans = 0;
	    for(int i = 0; i < n; i ++)
		ans += dp[ar[i] - s];

	    steps = min(steps, ans);
	}
	cout << steps << endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.257
medium
----------
PROBLEM STATEMENT:
Sean invented a game involving a [expression] submatrix located in the upper-left quadrant of the matrix.

Given the initial configurations for [expression] matrices, help Sean reverse the rows and columns of each matrix in the best possible way so that the sum of the elements in the matrix's upper-left quadrant is maximal.  

For example, given the matrix:

[expression]
[expression]



It is [expression]:

[expression]
[expression]



And now reverse column [expression]:

[expression]
[expression]



The maximal sum is [expression].

Function Description  

Complete the flippingMatrix function in the editor below.  It should return an integer that represents the maximum sum possible for the top [expression] matrix.  

flippingMatrix has the following parameters: 
- matrix: a [expression] array of integers  
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

#define FI(i,a,b) for(int i=(a);i<=(b);i++)
#define FD(i,a,b) for(int i=(a);i>=(b);i--)

#define LL long long
#define Ldouble long double
#define PI 3.1415926535897932384626

#define PII pair<int,int>
#define PLL pair<LL,LL>
#define mp make_pair
#define fi first
#define se second

using namespace std;

int q, n, s[299][299];

int main(){
	scanf("%d", &q);
	while(q--){
		scanf("%d", &n);
		FI(i, 1, 2 * n) FI(j, 1, 2 * n) scanf("%d", &s[i][j]);
		
		int ans = 0;
		FI(i, 1, n) FI(j, 1, n){
			int i2 = n + n + 1 - i;
			int j2 = n + n + 1 - j;
			int mx = max(max(max(s[i][j], s[i][j2]), s[i2][j]), s[i2][j2]);
			
			ans += mx;
		}
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.258
medium
----------
PROBLEM STATEMENT:
In this challenge, you will be given an array [expression] below. 

The equation can be written:

[expression]

For example, if the array [expression].  Arrays meeting those guidelines are:

[expression]
[expression]



Our calculations for the arrays are as follows:

[expression]
[expression]



The maximum value obtained is [expression].

Function Description

Complete the cost function in the editor below.  It should return the maximum value that can be obtained.  

cost has the following parameter(s):  


B: an array of integers  

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;

#define REP(i,n) for(int i=0,_n=(n);i<_n;++i)
#define FOR(i,a,b) for(int i=(a),_b=(b);i<=_b;++i)
#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;--i)
#define FOREACH(it,arr) for (__typeof((arr).begin()) it=(arr).begin(); it!=(arr).end(); it++)


int n;
int b[100005];
int dp[100005][105];

int f(int x, int a) {
	if ( x == n ) return 0;
	if ( dp[x][a] != -1 ) return dp[x][a];
	int &ret = dp[x][a] = 0;
	
	if ( x == 0 ) ret = max(f(x+1,1),f(x+1,b[x]));
	else ret = max(f(x+1,1)+abs(a-1),f(x+1,b[x])+abs(a-b[x]));
	
	return ret;
}

int main()
{
	int T;
	scanf( "%d", &T );
	
	while ( T-- ) {
		scanf( "%d", &n );
		REP(i,n) scanf( "%d", &b[i] );
		

		memset(dp,-1,sizeof(dp));
		printf( "%d\n", f(0,0) );
	}

	return 0;
}

----------
====================
----------
ALGORITHMS.259
medium
----------
PROBLEM STATEMENT:
Andy wants to play a game with his little brother, Bob.  The game starts with an array of distinct integers and the rules are as follows:


Bob always plays first and the two players move in alternating turns. 
In a single move, a player chooses the maximum element currently present in the array and removes it as well as all the other elements to its right. For example, if the starting array [expression]).
The modifications made to the array during each turn are permanent, so the next player continues the game with the remaining array. The first player who is unable to make a move loses the game.


Andy and Bob play [expression] games. Given the initial array for each game, find and print the name of the winner on a new line. If Andy wins, print ANDY; if Bob wins, print BOB.

To continue the example above, in the next move Andy will remove [expression] and win because there are no more integers to remove.  

Function Description  

Complete the gamingArray function in the editor below.  It should return a string that represents the winner, either ANDY or BOB.  

gamingArray has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int Q;
    scanf("%d", &Q);
    while(Q--)
    {
        int N;
        scanf("%d", &N);
        int last=0, ans=0;
        for(int i=0; i<N; i++)
        {
            int x;
            scanf("%d", &x);
            if(x>last)
                last=x, ans^=1;
        }
        if(ans==0)
            printf("ANDY\n");
        else
            printf("BOB\n");
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.260
medium
----------
PROBLEM STATEMENT:
It's New Year's Day and everyone's in line for the Wonderland rollercoaster ride! There are a number of people queued up, and each person wears a sticker indicating their initial position in the queue.  Initial positions increment by [expression] at the back.

Any person in the queue can bribe the person directly in front of them to swap positions. If two people swap positions, they still wear the same sticker denoting their original places in line. One person can bribe at most two others.  For example, if [expression].

Fascinated by this chaotic queue, you decide you must know the minimum number of bribes that took place to get the queue into its current state!

Function Description

Complete the function minimumBribes in the editor below.  It must print an integer representing the minimum number of bribes necessary, or Too chaotic if the line configuration is not possible.  

minimumBribes has the following parameter(s):


q: an array of integers  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;


int main(){
    int T;
    cin >> T;
    for(int a0 = 0; a0 < T; a0++){
        int n;
        cin >> n;
        vector<int> q(n);
        for(int q_i = 0;q_i < n;q_i++){
           cin >> q[q_i];
        }
        int ans = 0;
        for (int i = n - 1; i >= 0; i--){
            if (ans == -1)
                break;
            int k = i;
            while (q[k] != i + 1)
                k--;
            if (i - k > 2){
                ans = -1;
                break;
            } else {
                while (k != i){
                    swap(q[k], q[k + 1]);
                    k++;
                    ans++;
                }
            }
        }
        if (ans == -1)
            puts("Too chaotic");
        else
            cout << ans << "\n";
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.261
medium
----------
PROBLEM STATEMENT:
Your goal is to find the number of ways to construct an array such that consecutive positions contain different values.

Specifically, we want to construct an array with [expression].  

Given [expression]. 

For example, for [expression] ways, as shown here:



Complete the function countArray which takes input [expression]. Return the number of ways to construct the array such that consecutive elements are distinct. 
----------
TOP SOLUTION:
----------
/*
*/

//#pragma GCC optimize("O3")
#define _CRT_SECURE_NO_WARNINGS
#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>

#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk

#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd
#define have adsgagshdshfhds
#define ends asdgahhfdsfshdshfd

#define eps 1e-8
#define M_PI 3.141592653589793
#define bsize 512

#define ldouble long double
using namespace std;

#define bs 1000000007

const int N = 510031;

long long n,k,x;
long long dp[N][3];

int main(){
//	freopen("apache.in","r",stdin);
//	freopen("apache.out","w",stdout);
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
//	cin.tie(0);

	cin>>n>>k>>x;

	dp[1][(x==1)]=1;
	for (int i=2;i<=n;i++){
		for (int j=0;j<=1;j++){
			for (int nw=0;nw<=1;nw++){
				long long ways;
				if (j==1&&nw==1)
					ways=0;
				if (j==1&&nw==0)
					ways=k-1;
				if (j==0&&nw==1)
					ways=1;
				if (j==0&&nw==0)
					ways=max(0ll,k-2);
				dp[i][nw]=(dp[i][nw]+dp[i-1][j]*ways)%bs;
			}
		}
	}

	cout<<dp[n][1]<<endl;

//	cin.get(); cin.get();
	return 0;
}

----------
====================
----------
ALGORITHMS.262
medium
----------
PROBLEM STATEMENT:
Here's a humerus joke:


  Why did Papyrus the skeleton go to the store by himself? Because he had no body to go with him!


Did you like it? Don't worry, I've got a ton more. A skele-ton.

Once upon a time, Papyrus the skeleton went to buy some pasta from the store. The store's inventory is bare-bones and they only sell one thing — boxes of uncooked spaghetti! The store always stocks exactly [expression] sticks. Because they only stock one box of each kind, the store has a tendon-cy to sell out of spaghetti.

During each trip to the store, Papyrus likes to buy exactly [expression] boxes (no more, no less). Not sure which boxes to purchase, Papyrus calls Sherlock Bones for help but he's also stumped! Do you have the guts to solve this puzzle?

Given the values of [expression] boxes, print -1 instead.

For example, Papyrus wants to purchase [expression] and other combinations.  Any of the combinations will work. 

Function Description  

Complete the bonetrousle function in the editor below.  It should return an array of integers.  

bonetrousle has the following parameter(s):  


n: the integer number of sticks to buy  
k: the integer number of box sizes the store carries    
b: the integer number of boxes to buy  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

#define FI(i,a,b) for(int i=(a);i<=(b);i++)
#define FD(i,a,b) for(int i=(a);i>=(b);i--)

#define LL long long
#define Ldouble long double
#define PI 3.1415926535897932384626

#define PII pair<int,int>
#define PLL pair<LL,LL>
#define mp make_pair
#define fi first
#define se second

using namespace std;

int t, n;
LL ttl, sto, s[100005];

void solve(){
	LL bs = 1LL * n * (n + 1) / 2, tar;
	if(ttl < bs){
		printf("-1\n");
		return;
	}
	FI(i, 1, n) s[i] = i;
	
	tar = ttl - bs;
	
	FD(i, n, 1){
		LL incre = max(0LL, min(tar, sto - (n - i) - s[i]));
		s[i] += incre;
		tar -= incre;
	}
	
	if(tar > 0){
		printf("-1\n");
		return;
	}
	
	FI(i, 1, n) printf("%lld%c", s[i], i == n ? '\n':' ');
	return;
}

int main(){
	scanf("%d", &t);
	while(t--){
		scanf("%lld %lld %d", &ttl, &sto, &n);
		solve();
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.263
medium
----------
PROBLEM STATEMENT:
King Arthur has a large kingdom that can be represented as a tree, where nodes correspond to cities and edges correspond to the roads between cities. The kingdom has a total of [expression]. 

The King wants to divide his kingdom between his two children, Reggie and Betty, by giving each of them [expression] or more cities; however, they don't get along so he must divide the kingdom in such a way that they will not invade each other's cities. The first sibling will invade the second sibling's city if the second sibling has no other cities directly connected to it. For example, consider the kingdom configurations below:



Given a map of the kingdom's [expression].
----------
TOP SOLUTION:
----------
#ifndef __clang__
#pragma GCC optimize "-O3"
#pragma GCC target "tune=native"
#endif
#ifdef ONLINE_JUDGE
#define NDEBUG 1
#endif
#include <stdio.h>
#include <bits/stdc++.h>

#define DESTRUCT2(p, a, b)                      \
  auto a = get<0>(p);                           \
  auto b = get<1>(p);

#define DESTRUCT3(p, a, b, c)                   \
  auto a = get<0>(p);                           \
  auto b = get<1>(p);                           \
  auto c = get<2>(p);

#define DESTRUCT4(p, a, b, c, d)                \
  auto a = get<0>(p);                           \
  auto b = get<1>(p);                           \
  auto c = get<2>(p);                           \
  auto d = get<3>(p);

#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)
#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)
#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)

#define SQ(x) ((x)*(x))

#define all(x) begin(x), end(x)
#define rall(x) rbegin(x), rend(x)
#define mp make_pair
#define mt make_tuple
#define pb push_back
#define eb emplace_back

using namespace std;

template<typename... As>
struct tpl : public std::tuple<As...> {
  using std::tuple<As...>::tuple;

  template<typename T = tuple<As...> >
  typename tuple_element<0, T>::type const&
  x() const { return get<0>(*this); }
  template<typename T = tuple<As...> >
  typename tuple_element<0, T>::type&
  x() { return get<0>(*this); }

  template<typename T = tuple<As...> >
  typename tuple_element<1, T>::type const&
  y() const { return get<1>(*this); }
  template<typename T = tuple<As...> >
  typename tuple_element<1, T>::type&
  y() { return get<1>(*this); }

  template<typename T = tuple<As...> >
  typename tuple_element<2, T>::type const&
  z() const { return get<2>(*this); }
  template<typename T = tuple<As...> >
  typename tuple_element<2, T>::type&
  z() { return get<2>(*this); }

  template<typename T = tuple<As...> >
  typename tuple_element<3, T>::type const&
  w() const { return get<3>(*this); }
  template<typename T = tuple<As...> >
  typename tuple_element<3, T>::type&
  w() { return get<3>(*this); }
};

using lli   = long long int;
using llu   = long long unsigned;

using pii   = tpl<lli, lli>;
using piii  = tpl<lli, lli, lli>;
using piiii = tpl<lli, lli, lli, lli>;
using vi    = vector<lli>;
using vii   = vector<pii>;
using viii  = vector<piii>;
using vvi   = vector<vi>;
using vvii  = vector<vii>;
using vviii = vector<viii>;

template<class T>
using min_queue = priority_queue<T, vector<T>, greater<T> >;
template<class T>
using max_queue = priority_queue<T>;

template<size_t... I>
struct my_index_sequence {
  using type = my_index_sequence;
  static constexpr array<size_t, sizeof...(I)> value = { {I...} };
};

namespace my_index_sequence_detail {
  template<typename I, typename J> struct concat;
  template<size_t... I, size_t... J>
  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :
    my_index_sequence<I..., (sizeof...(I)+J)...> { };
  template<size_t N> struct make_index_sequence :
    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };
  template <> struct make_index_sequence<0> : my_index_sequence<>{};
  template <> struct make_index_sequence<1> : my_index_sequence<0>{};
}

template<class... A>
using my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;

template<class T, size_t... I>
void print_tuple(ostream& s, T const& a, my_index_sequence<I...>){
  using swallow = int[];
  (void)swallow{0, (void(s << (I == 0? "" : ", ") << get<I>(a)), 0)...};
}

template<class T>
ostream& print_collection(ostream& s, T const& a);
template<class... A>
ostream& operator<<(ostream& s, tpl<A...> const& a);
template<class... A>
ostream& operator<<(ostream& s, tuple<A...> const& a);
template<class A, class B>
ostream& operator<<(ostream& s, pair<A, B> const& a);

template<class T, size_t I>
ostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }
template<class T>
ostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }
template<class T, class U>
ostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }
template<class T>
ostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }
template<class T, class U>
ostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }
template<class T>
ostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }

template<class T>
ostream& print_collection(ostream& s, T const& a){
  s << '[';
  for(auto it = begin(a); it != end(a); ++it){
    s << *it;
    if(it != prev(end(a))) s << " ";
  }
  return s << ']';
}

template<class... A>
ostream& operator<<(ostream& s, tpl<A...> const& a){
  s << '(';
  print_tuple(s, a, my_index_sequence_for<A...>{});
  return s << ')';
}

template<class... A>
ostream& operator<<(ostream& s, tuple<A...> const& a){
  s << '(';
  print_tuple(s, a, my_index_sequence_for<A...>{});
  return s << ')';
}

template<class A, class B>
ostream& operator<<(ostream& s, pair<A, B> const& a){
  return s << "(" << get<0>(a) << ", " << get<1>(a) << ")";
}

namespace std {
  namespace {
    template <class T>
    inline void hash_combine(size_t& seed, T const& v) {
      seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
    }
    template <class Tuple, size_t Index = tuple_size<Tuple>::value - 1>
    struct HashValueImpl {
      static void apply(size_t& seed, Tuple const& tuple) {
        HashValueImpl<Tuple, Index-1>::apply(seed, tuple);
        hash_combine(seed, get<Index>(tuple));
      }
    };
    template <class Tuple>
    struct HashValueImpl<Tuple, 0> {
      static void apply(size_t& seed, Tuple const& tuple) {
        hash_combine(seed, get<0>(tuple));
      }
    };
  }
  template <typename ... TT>
  struct hash<tuple<TT...>> {
    size_t operator()(tuple<TT...> const& tt) const {
      size_t seed = 0;
      HashValueImpl<tuple<TT...> >::apply(seed, tt);
      return seed;
    }
  };
  template <typename ... TT>
  struct hash<tpl<TT...>> {
    size_t operator()(tpl<TT...> const& tt) const {
      size_t seed = 0;
      HashValueImpl<tuple<TT...> >::apply(seed, tt);
      return seed;
    }
  };
}

lli read_positive(){
  char c; lli x=0;
  do { c = getchar(); } while(c<'0' || c>'9');
  while(c>='0'&&c<='9') {
    x=10*x+(c-'0');
    c = getchar();
  }
  return x;
}

//------------------------------------------------------------------------------

// --- BEGIN SNIPPET MODULAR ---

const lli MOD = 1e9+7;

inline lli fexp(lli a, lli b) {
  lli r = 1;
  while(b){
    if(b&1) r = (r*a)%MOD;
    a = (a*a)%MOD;
    b /= 2;
  }
  return r;
}

inline lli invmod(lli a) {
  return fexp(a, MOD-2);
}

// --- END SNIPPET MODULAR ---

const int N=1e5;
lli ans0[N], ans1[N];

int main(){
  ios::sync_with_stdio(0); cin.tie(0);
  int n; cin >> n;
  vvi G(n);
  FOR(i,n-1) {
    int u,v; cin>>u>>v;
    --u; --v;
    G[u].pb(v);
    G[v].pb(u);
  }
  function<void(int,int)> dfs = [&](int i, int p) {
    for(auto j : G[i]) if(j!=p) dfs(j,i);
    ans0[i]=1;
    ans1[i]=1;
    for(auto j : G[i]) if(j!=p) {
        (ans0[i] *= (ans0[j]+ans1[j])) %= MOD;
        (ans1[i] *= (ans1[j])) %= MOD;
      }
    ans1[i] = (ans0[i]+MOD-ans1[i])%MOD;
  };
  dfs(0,-1);
  cout << (2*ans1[0])%MOD << endl;
  return 0;
}

----------
====================
----------
ALGORITHMS.264
hard
----------
PROBLEM STATEMENT:
This challenge uses the famous KMP algorithm. It isn't really important to understand how KMP works, but you should understand what it calculates.

A KMP algorithm takes a string, [expression].

Here is an implementation example of KMP:

[expression]
[expression]
    [expression]
    [expression]
        [expression]
    [expression]
    [expression]
        [expression]
    [expression]
    [expression]
        [expression]
    [expression]
[expression]



Given a sequence [expression], that meets the following conditions:


The frequency of letter '[expression], and so on.
Let's assume characters of [expression] is minimal.


If there are multiple strings which fulfill the above conditions, print the lexicographically smallest one.
----------
TOP SOLUTION:
----------
#include <stdexcept>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <cassert>
#include <cstring>
#include <cstdarg>
#include <cstdio>
#include <memory>
#include <random>
#include <cmath>
#include <ctime>
#include <functional>
#include <algorithm>
#include <complex>
#include <numeric>
#include <limits>
#include <bitset>
#include <vector>
#include <string>
#include <queue>
#include <deque>
#include <array>
#include <list>
#include <map>
#include <set>

using namespace std;

#define all(a) (a).begin(), (a).end()
#define sz(a) static_cast<int>((a).size())
#define FOR(i, a, b) for (int i(a), b_(b); i < b_; ++i)
#define REP(i, n) FOR (i, 0, n)
#define FORD(i, a, b) for (int i(a), b_(b); i >= b_; --i)
#define UNIQUE(a) sort(all(a)), (a).erase(unique(all(a)), (a).end())
#define CL(a, v) memset(a, v, sizeof a)
#define eb emplace_back
#define pb push_back
#define X first
#define Y second

typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef pair<int, int> pii;
template <class T> using min_queue = priority_queue<T, vector<T>, greater<T>>;

const int INF = static_cast<int>(1e9);
const long long INF_LL = static_cast<long long>(4e18);
const double pi = acos(-1.0);

template <class T> T& smin(T& x, const T& y) { if (x > y) x = y; return x; }
template <class T> T& smax(T& x, const T& y) { if (x < y) x = y; return x; }
template <class T> T sqr(const T& x) { return x * x; }

template <class T> T gcd(T a, T b) {
  for (a = abs(a), b = abs(b); a && b; a >= b ? a %= b : b %= a);
  return a + b;
}

template <typename Iterator>
void print(const char* format, Iterator first, Iterator last,
           const char* delimiter = " ", const char* closing = "\n") {
  for (; first != last; ++first != last ? printf("%s", delimiter) : 0)
    printf(format, *first);
  printf("%s", closing);
}

const int A = 26;
int x[A];
string ans;

int main() {
  cin.tie(NULL);
  //ios_base::sync_with_stdio(false);
#ifdef LocalHost
  freopen("input.txt", "r", stdin);
  //freopen("output.txt", "w", stdout);
#endif

  int n = 0;
  REP(i, A) scanf("%d", x+i), n += x[i];
  ans.reserve(n);
  int a = 0;
  while (x[a] == 0) ++a;
  int u = a;
  REP(i, A) if (x[i] > 0 && x[i] < x[u]) u = i;
  ans += 'a' + u;
  --x[u];
  --n;
  if (a == u && x[u] > 0 && x[u] <= n - x[u] + 1) {
    ans += u + 'a';
    --x[u];
    ++a;
    while (x[u] > 0) {
      while (x[a] == 0) ++a;
      ans += a + 'a';
      ans += u + 'a';
      --x[a];
      --x[u];
    }
  }
  REP(i, A) ans += string(x[i], i + 'a');

  printf("%s\n", ans.c_str());

#ifdef LocalHost
  cerr << endl << endl << static_cast<double>(clock()) / CLOCKS_PER_SEC << endl;
#endif
  return 0;
}

----------
====================
----------
ALGORITHMS.265
medium
----------
PROBLEM STATEMENT:
Samantha and Sam are playing a numbers game.  Given a number as a string, no leading zeros, determine the sum of all integer values of substrings of the string.  For example, if the string is [expression].

Given an integer as a string, sum all of its substrings cast as integers.  As the number may become large, return the value modulo [expression].  

Function Description

Complete the substrings function in the editor below.  It should return the sum of the integer values of all substrings in a string representation of a number, modulo [expression].  

substrings has the following parameter(s):  


n: the string representation of an integer  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <string.h>
using namespace std;

#define MOD 1000000007

int main() {
	char num[200005];
	gets(num);
	int len = strlen(num);
	long long factor = 1, ans = 0;

	for (int i = len-1; i >= 0; --i) {
		long long tmp = (num[i]-'0') * (i+1) * factor % MOD;
		ans += tmp;
		ans %= MOD;
		factor = (factor * 10 + 1) % MOD;
	}
	printf("%d\n", ans);

	return 0;
}
----------
====================
----------
ALGORITHMS.266
hard
----------
PROBLEM STATEMENT:
You are given an integer [expression] is beautiful if and only if:


[expression]
[expression]
Let [expression].


The third condition means that all [expression].

Given [expression].
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }

int main() {
	int N;
	while(~scanf("%d", &N)) {
		int K = 2 * N / 3;
		while((K + 1) + (K + 1) / 2 <= N + 1) ++ K;
		//i0..N-i
		int P = K + (K % 2 == 0);
		vector<int> pos(P);
		int t = P / 2;
		rep(i, P)
			pos[i] = i % 2 == 0 ? P - 1 - i / 2 : t - 1 - i / 2;
		if(K % 2 == 0) {
			rep(i, P) {
				if(pos[i] > N - i) {
					pos.erase(pos.begin() + i);
					break;
				}
			}
		}
		vector<bool> vis(N * 2 + 1, false);
		bool ok = true;
		rep(i, K) {
			ok &= 0 <= pos[i] && pos[i] <= N - i;
			ok &= !vis[i + pos[i]];
			vis[i + pos[i]] = true;
		}
		if(!ok) { cerr << "not ok" << endl; return 1; }
		printf("%d\n", K);
		rep(i, K)
			printf("%d %d %d\n", i, pos[i], N - i - pos[i]);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.267
medium
----------
PROBLEM STATEMENT:
We define a modified Fibonacci sequence using the following definition:


  Given terms [expression] is computed using the following relation:
  [expression]      


For example, if [expression],  


[expression],  
[expression],  
[expression],  
and so on.  


Given three integers, [expression] term of a modified Fibonacci sequence.

Function Description  

Complete the fibonacciModified function in the editor below.  It must return the [expression] number in the sequence.  

fibonacciModified has the following parameter(s):  


t1: an integer  
t2: an integer  
n: an integer  


Note: The value of [expression]-bit integer. Many submission languages have libraries that can handle such large results but, for those that don't (e.g., C++), you will need to compensate for the size of the result.
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
ALGORITHMS.268
hard
----------
PROBLEM STATEMENT:
Range Minimum Query is a well-known problem: given an array of distinct integers with size [expression].

One of the most efficient and famous solutions to this problem is a segment tree. A segment tree is a full binary tree with [expression] nodes where the leaves contain the values of the original array and each non-leaf node contains the minimum value of its entire subtree.

Usually, a segment tree is represented as an array of integers with [expression] (which corresponds to the minimum value in that node's subtree):



You've just used [expression] space-separated integers denoting the array's original values. If there are several possible original arrays, print the lexicographically smallest one.
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define int long long
typedef vector<int>vint;
typedef pair<int,int>pint;
typedef vector<pint>vpint;
#define rep(i,n) for(int i=0;i<(n);i++)
#define reps(i,f,n) for(int i=(f);i<(n);i++)
#define all(v) (v).begin(),(v).end()
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define pb push_back
#define fi first
#define se second
template<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}
template<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}

const int INF=1001001001001001001ll;
int N;
priority_queue<int,vint,greater<int>>cand[20];
int A[1<<19];
signed main(){
    scanf("%lld",&N);
    map<int,int>mp;
    rep(i,2*N-1){
        int a;
        scanf("%lld",&a);
        mp[a]++;
    }

    vpint vec;
    each(it,mp)vec.pb(*it);
    fill_n(A,1<<19,INF);
    if(vec.size()!=N||vec[0].se>=20||(1<<vec[0].se)!=N*2){
        puts("NO");
        return 0;
    }
    cand[vec[0].se].push(0);

    rep(i,N){
        int t=vec[i].se;
        if(t>=20){
            puts("NO");
            return 0;
        }
        while(cand[t].size()&&A[cand[t].top()]!=INF)cand[t].pop();
        if(cand[t].size()==0){
            puts("NO");
            return 0;
        }
        int k=cand[t].top();cand[t].pop();
        while(true){
            A[k]=vec[i].fi;
            if(k>=N-1)break;
            t--;
            cand[t].push(k*2+2);
            k=k*2+1;
        }
    }

    puts("YES");
    rep(i,2*N-1){
        if(i)printf(" ");
        printf("%lld",A[i]);
    }
    puts("");
    return 0;
}

----------
====================
----------
ALGORITHMS.269
medium
----------
PROBLEM STATEMENT:
You can perform the following operations on the string, [expression]:  


Capitalize zero or more of [expression]'s lowercase letters.
Delete all of the remaining lowercase letters in [expression].


Given two strings, [expression] as described. If so, print YES on a new line.  Otherwise, print NO.

For example, given [expression], matching is not possible because letters may only be capitalized or discarded, not changed.

Function Description

Complete the function [expression].

abbreviation has the following parameter(s):


a: the string to modify  
b: the string to match  

----------
TOP SOLUTION:
----------
#include <sstream>
#include <vector>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <string>
#include <cassert>
#include <ctime>
#include <map>
#include <math.h>
#include <cstdio>
#include <set>
#include <deque>
#include <memory.h>
#include <queue>

#pragma comment(linker, "/STACK:64000000")
typedef long long ll;

using namespace std;

const int MAXN = -1;
const int MOD = 1; // 1000 * 1000 * 1000 + 7;
const int INF = (int)(1e9);

int main() {
#ifdef _MSC_VER
	freopen("input.txt", "r", stdin);
#endif

	int T;
	cin >> T;
	while (T--) {
		string a, b;
		cin >> a >> b;
		int n = a.length();
		int m = b.length();
		
		vector<vector<char> > dp(n + 1, vector<char>(m + 1));
		dp[0][0] = 1;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j <= m; j++) {
				if (!dp[i][j]) continue;

				if (a[i] >= 'a' && a[i] <= 'z') dp[i + 1][j] = 1;
				if (a[i] >= 'A' && a[i] <= 'Z' && j < m && a[i] == b[j]) {
					dp[i + 1][j + 1] = 1;
				}

				if (a[i] >= 'a' && a[i] <= 'z' && j < m && a[i] - 'a' == b[j] - 'A') {
					dp[i + 1][j + 1] = 1;
				}
			}
		}
		cout << (dp[n][m] ? "YES" : "NO") << endl;
	}

	return 0;
}
----------
====================
----------
ALGORITHMS.270
expert
----------
PROBLEM STATEMENT:
Consider an array, [expression] integers. We define the following terms:


Subsequence 
A subsequence of [expression] without changing the order of the remaining elements. Note that a subsequence may have zero elements, and this is called the empty subsequence.
Strictly Increasing Subsequence 
A non-empty subsequence is strictly increasing if every element of the subsequence is larger than the previous element. 
Subarray 
A subarray of [expression].


The diagram below shows all possible subsequences and subarrays of [expression]: 



We define the following functions:


[expression]
[expression]
[expression]


We define the goodness, [expression] to be:

[expression]

In other words, [expression]. 

Let [expression], then print these respective answers as space-separated integers on a single line.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <set>
#include <map>
#include <cassert>
#include <numeric>
#include <string>
#include <cstring>
#include <cmath>
using namespace std;

#ifdef LOCAL
	#define eprintf(...) fprintf(stderr, __VA_ARGS__)
#else
	#define eprintf(...) 42
#endif

typedef long long int int64;


const int N = (int) 2e5 + 100;
int a[N];
int sum[N];

int stPos[N];
int stSz = 0;

const int VAL = 41;
int sm[N][VAL];
bool skip[N];

int nxt[N][VAL];

int lst[N][VAL];
int lstSz[N];

int mxSum[N];
int mxBef[N];
int X = 100;

int n;

void updateBef(int v, int val)
{
	while (mxBef[v] < val)
	{
		mxBef[v] = val;
		v++;
	}
}

void update(int v, int ssum)
{
	if (a[v] <= 0) return;

	mxSum[v] = ssum + a[v] ;

	for (int i = 0; i < lstSz[v]; i++)
	{
		int nx = lst[v][i];
		int nxpos = nxt[v][nx];
		if (mxSum[nxpos] < nx + mxSum[v] )	
			update(nxpos, mxSum[v] );
	}
	updateBef(v, mxSum[v] );
}


int T = 0;


int alt()
{
	mxSum[n] = X;
	mxBef[n] = X;
	for (int i = 0; i < VAL; i++)
		nxt[n][i] = n;
	for (int i = n - 1; i >= 0; i--)
	{
		for (int j = 0; j < VAL; j++)
			nxt[i][j] = nxt[i + 1][j];
		if (a[i] <= 0) continue;
		nxt[i][a[i] ] = i;

		int mn = n;
		for (int j = a[i] + 1; j < VAL; j++)
		{
			if (nxt[i][j] < mn)
			{
				mn = nxt[i][j];
				lst[i][lstSz[i]++] = j;
			}
			reverse(lst[i], lst[i] + lstSz[i] );
		}
	}

	int ans = 0;
	int len = 1;
	int cnt = n;
	for (int i = n; i > 0; i--)
	{
		while (stSz > 0 && sum[stPos[stSz - 1] ] <= sum[i] )
			stSz--;
		if (stSz == 0 || sum[i] >= sum[stPos[stSz - 1] ] - X)
		{
			stPos[stSz] = i;
			stSz++;
		}

		update(i - 1, 0);

		for (int j = 0; j < stSz; j++)
		{
			int pos = stPos[j];
			int cur = sum[pos] - sum[i - 1] - mxBef[pos - 1];
			int curLen = pos - (i - 1) + 1;
			if (cur == 0) continue;
			if (cur > ans || (cur == ans && curLen < len) )
			{
				ans = cur;
				len = curLen;
				cnt = 0;
			}
			if (cur == ans && curLen == len)
				cnt++;
		}
	}
	printf("%d %d\n", ans, cnt);




	return 0;
}

int main(int,  char **)
{
#ifdef LOCAL
	freopen("input.txt", "r", stdin);
//	freopen("output.txt", "w", stdout);
#endif

	int H = 0;

	scanf("%d", &n);
	for (int i = 0; i < n; i++)
	{
		scanf("%d", &a[i] );
		H ^= a[i];

		if (a[i] > 0)
			X = max(X, a[i] * (a[i] + 1) / 2 + a[i] + 1);
		sum[i + 1] = sum[i] + a[i];
	}

	if (n < 1e4) T = 1;
	if (H % 4 == 2) T = 1;

	if (T == 0)
	{
		H ^= n;
		if (H % 3 != 0)
		{
			alt();
			return 0;
		}
	}


	int ans = 0;
	int len = 1;
	int cnt = n;
	for (int i = n; i > 0; i--)
	{
		while (stSz > 0 && sum[stPos[stSz - 1] ] <= sum[i] )
			stSz--;
		if ( (stSz == 0 || sum[i] >= sum[stPos[stSz - 1] ] - X) &&
		   	(a[i] <= 0 || a[i - 1] <= a[i] )
				)
		{
			stPos[stSz] = i;
			stSz++;
		}

		int ppos;
		int val = a[i - 1];
		for (int j = 0; j < stSz; j++)
		{
			skip[j] = true;
			int pos = stPos[j];

			sm[pos][val] = max(sm[pos][val], sm[pos][val + 1] + val);
			for (int h = a[i - 1] - 1; h >= 0; h--)
			{
				if (sm[pos][h] < sm[pos][h + 1] )
					sm[pos][h] = sm[pos][h + 1];
				else
					break;
			}
			if (j == 0) skip[j] = false;
			else
			{
				if (T == 0)
				{
					if (sm[pos][0] - sm[ppos][0] > sum[pos] - sum[ppos] )
						skip[j] = false;
				}
				else if (T == 1)
				{
					if (sm[pos][0] != sm[ppos][0] )
						skip[j] = false;
				}
			}
			ppos = pos;

			int cur = sum[pos] - sum[i - 1] - sm[pos][0];
			int curLen = pos - (i - 1) + 1;
			if (cur == 0) continue;
			if (cur > ans || (cur == ans && curLen < len) )
			{
				ans = cur;
				len = curLen;
				cnt = 0;
			}
			if (cur == ans && curLen == len)
				cnt++;	
		}
		int nsz = 0;
		for (int h = 0; h < stSz; h++)
		{
			if (!skip[h] )
				stPos[nsz++] = stPos[h];
		}
		stSz = nsz;
	}
	printf("%d %d\n", ans, cnt);
	



	return 0;
}


----------
====================
----------
ALGORITHMS.271
medium
----------
PROBLEM STATEMENT:
Penny has an array of [expression]. She wants to find the number of unique multisets she can form using elements from the array such that the bitwise XOR of all the elements of the multiset is a prime number. Recall that a multiset is a set which can contain duplicate elements.

Given [expression] before printing it on a new line.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <iostream>
#include <utility>
#include <vector>
using namespace std;
int n;
const int mo=1000000007;

int a[111111];
int npr[11111];
int vis[5555];
int f[2][10000];
int main() {
    npr[1]=1;
	for (int i=2;i<=10000;i++){
		for (int j=i+i;j<=10000;j+=i)npr[j]=1;
	}
	int q;scanf("%d",&q);
	while(q--){
		scanf("%d",&n);
		memset(vis,0,sizeof(vis));
		memset(f,0,sizeof(f));
		for (int i=1;i<=n;i++){
			int x;scanf("%d",&x);
			vis[x]++;
		}
		int *g=f[0],*h=f[1];
		g[0]=1;
		for (int i=3500;i<=4500;i++)if(vis[i]){
				int qu,buqu;
				buqu=vis[i]/2+1;
				qu=vis[i]+1-buqu;
				swap(g,h);
				for (int j=0;j<8192;j++)g[j]=(1ll*buqu*h[j]+1ll*qu*h[j^i])%mo;
		}
		int an=0;
		for (int i=2;i<8192;i++)if(!npr[i]){
				an=(an+g[i])%mo;
		}
		printf("%d\n",an);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.272
advanced
----------
PROBLEM STATEMENT:
Daniel loves graphs. He thinks a graph is special if it has the following properties:


It is undirected.
The length of each edge is [expression].
It includes exactly [expression] different lovely triplets. 


A triplet is a set of [expression] or more of their component nodes are different. 

Given [expression], help Daniel draw a special graph.
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

#define ll long long
#define ull unsigned ll

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(double *x){scanf("%lf",x);}
int reader(char c[]){int i,s=0;for(;;){mygc(i);if(i!=' '&&i!='\n'&&i!='\r'&&i!='\t'&&i!=EOF) break;}c[s++]=i;for(;;){mygc(i);if(i==' '||i=='\n'||i=='\r'||i=='\t'||i==EOF) break;c[s++]=i;}c[s]='\0';return s;}
template <class T, class S> void reader(T *x, S *y){reader(x);reader(y);}
template <class T, class S, class U> void reader(T *x, S *y, U *z){reader(x);reader(y);reader(z);}
template <class T, class S, class U, class V> void reader(T *x, S *y, U *z, V *w){reader(x);reader(y);reader(z);reader(w);}

void writer(int x, char c){int s=0,m=0;char f[10];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(ll x, char c){int s=0,m=0;char f[20];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(double x, char c){printf("%.15f",x);mypc(c);}
void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}
void writer(const char x[], char c){int i;for(i=0;x[i]!='\0';i++)mypc(x[i]);mypc(c);}
template<class T> void writerLn(T x){writer(x,'\n');}
template<class T, class S> void writerLn(T x, S y){writer(x,' ');writer(y,'\n');}
template<class T, class S, class U> void writerLn(T x, S y, U z){writer(x,' ');writer(y,' ');writer(z,'\n');}
template<class T> void writerArr(T x[], int n){int i;if(!n){mypc('\n');return;}rep(i,n-1)writer(x[i],' ');writer(x[n-1],'\n');}

char memarr[17000000]; void *mem = memarr;
#define MD 1000000007

int P, Q;

int N, M;
int mat[120][120];
int a1,a2,a3,a4,b1,b2,b3;

int ashi[10];

int dist[120][120];

int main(){
  int i, j, k, loop;
  int a,b,c,d,e,f,g,r;

  reader(&P,&Q);

  if(Q==2){
    while(P){
      rep(k,100) if(k*(k-1)*(k-2)/6 > P) break;
      k--;
      P -= k*(k-1)*(k-2)/6;
      
      j = N++;
      rep(i,k) mat[j][N] = mat[N][j] = 1, N++;
    }
  } else {

    a1 = 100000;
    rep(a,20) REP(b,a,20) REP(c,b,20) REP(d,c,20){
      r = P - a*b*c - a*b*d - a*c*d - b*c*d;
      if(r < 0) continue;
      rep(e,20) REP(f,e,20) REP(g,f,20) if(r==e*f*g){
        if(a1+a2+a3+a4+b1+b2+b3 > a+b+c+d+e+f+g){
          a1 = a;
          a2 = b;
          a3 = c;
          a4 = d;
          b1 = e;
          b2 = f;
          b3 = g;
        }
      }
    }

    //  printf("%d %d %d %d, %d %d %d\n",a1,a2,a3,a4,b1,b2,b3);
    
    k = N++;
    if(Q%2==0){
      rep(loop,4){
        j = k;
        rep(i,Q/2-1) mat[j][N] = mat[N][j] = 1, j=N, N++;
        ashi[loop] = j;
      }
    } else {
      rep(i,4) rep(j,4) mat[k+i][k+j] = 1;
      N += 3;
      rep(loop,4){
        j = k+loop;
        rep(i,Q/2-1) mat[j][N] = mat[N][j] = 1, j=N, N++;
        ashi[loop] = j;
      }
    }
    
    k = N++;
    if(Q%2==0){
      rep(loop,3){
      j = k;
      rep(i,Q/2-1) mat[j][N] = mat[N][j] = 1, j=N, N++;
        ashi[4+loop] = j;
      }
    } else {
      rep(i,3) rep(j,3) mat[k+i][k+j] = 1;
      N += 2;
      rep(loop,3){
        j = k+loop;
        rep(i,Q/2-1) mat[j][N] = mat[N][j] = 1, j=N, N++;
        ashi[4+loop] = j;
      }
    }
    
//  printf("ashi %d %d %d %d, %d %d %d\n",ashi[0],ashi[1],ashi[2],ashi[3],ashi[4],ashi[5],ashi[6]);
    
    rep(i,a1) mat[N][ashi[0]] = mat[ashi[0]][N] = 1, N++;
    rep(i,a2) mat[N][ashi[1]] = mat[ashi[1]][N] = 1, N++;
    rep(i,a3) mat[N][ashi[2]] = mat[ashi[2]][N] = 1, N++;
    rep(i,a4) mat[N][ashi[3]] = mat[ashi[3]][N] = 1, N++;
    rep(i,b1) mat[N][ashi[4]] = mat[ashi[4]][N] = 1, N++;
    rep(i,b2) mat[N][ashi[5]] = mat[ashi[5]][N] = 1, N++;
    rep(i,b3) mat[N][ashi[6]] = mat[ashi[6]][N] = 1, N++;
  }
  
  M = 0;
  rep(i,N) REP(j,i+1,N) if(mat[i][j]) M++;
  writerLn(N,M);
  rep(i,N) REP(j,i+1,N) if(mat[i][j]) writerLn(i+1,j+1);


  if(0){
    rep(i,N) rep(j,N) dist[i][j] = 100000;
    rep(i,N) dist[i][i] = 0;
    rep(i,N) rep(j,N) if(mat[i][j]) dist[i][j] = min(dist[i][j],1);
    rep(k,N) rep(i,N) rep(j,N) dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);

    loop = 0;
    rep(i,N) REP(j,i+1,N) REP(k,j+1,N){
      if(dist[i][j]==Q && dist[i][k]==Q && dist[j][k]==Q){
        loop++;
        printf("--- %d %d %d\n",i+1,j+1,k+1);
      }
    }
    printf("total = %d\n",loop);
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.273
advanced
----------
PROBLEM STATEMENT:
Professor GukiZ has hobby — constructing different arrays. His best student, Nenad, gave him the following task that he just can't manage to solve:

Construct an [expression] must be non-negative integers.

[expression]

[expression]

If there is more then one such array, you need to find the lexicographically smallest one. In the case no such array [expression].

Note: An array, [expression].
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
typedef long long LL;
using namespace std;

int main(){
	int q;
	cin >> q;
	for(int Q = 0; Q < q; Q++){
		int n, s, k;
		cin >> n >> s >> k;
		int dp[s+1][k+1];
		for(int i = 0; i <= s; i++){
			for(int j = 0; j <= k; j++){
				dp[i][j] = 0;
			}
		}
		dp[0][0] = 1;
		int done = 0;
		for(int c = 1; c <= n; c++){
			int d = c*(n-c);
			for(int i = 0; i + c <= s; i++){
				for(int j = 0; j + d <= k; j++){
					if(dp[i][j] != 0 && dp[i+c][j+d] == 0){
						dp[i+c][j+d] = c;
					}
				}
			}
			if(dp[s][k]){
				int diff[n];
				for(int i = 0; i < n; i++) diff[i] = 0;
				int cs = s;
				int ck = k;
				while(cs > 0 || ck > 0){
					int a = dp[cs][ck];
					int b = a*(n-a);
					diff[n-a]++;
					cs -= a;
					ck -= b;
				}
				int r = 0;
				for(int i = 0; i < n; i++){
					r += diff[i];
					cout << r << " ";
				}
				cout << endl;
				done = 1;
				break;
			}
		}
		if(!done){
			cout << -1 << endl;
		}
	}
}
----------
====================
----------
ALGORITHMS.274
hard
----------
PROBLEM STATEMENT:
Let's talk about binary numbers. We have an [expression] using the following formula:

[expression]

For example, if binary number [expression], we compute its decimal value like so:

[expression]

Meanwhile, in our well-known decimal number system where each digit ranges from [expression], can be expanded in the same way:

[expression]



Now that we've discussed both systems, let's combine decimal and binary numbers in a new system we call decibinary! In this number system, each digit ranges from [expression] because:

[expression]

Pretty cool system, right? Unfortunately, there's a problem: two different decibinary numbers can evaluate to the same decimal value! For example, the decibinary number [expression]:

[expression]

This is a major problem because our new number system has no real applications beyond this challenge! 



Consider an infinite list of non-negative decibinary numbers that is sorted according to the following rules:


The decibinary numbers are sorted in increasing order of the decimal value that they evaluate to. 
Any two decibinary numbers that evaluate to the same decimal value are ordered by increasing decimal value, meaning the equivalent decibinary values are strictly interpreted and compared as decimal values and the smaller decimal value is ordered first. For example, [expression].


Here is a list of first few decibinary numbers properly ordered:



You will be given [expression] decibinary number in the list on a new line.  

Function Description

Complete the decibinaryNumbers function in the editor below.  For each query, it should return the decibinary number at that one-based index.  

decibinaryNumbers has the following parameter(s):


x: the index of the decibinary number to return   

----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }

int main() {
	int T;
	scanf("%d", &T);
	const int X = 300000, K = 18;
	vector<vector<ll>> dp(K + 2, vector<ll>(X + 1));
	dp[0][0] = 1;
	rer(k, 0, K) {
		rer(d, 0, 9) for (int j = X - (d << k); j >= 0; --j)
			dp[k + 1][j + (d << k)] += dp[k][j];
	}
	vector<ll> sum(X + 2);
	rer(j, 0, X)
		sum[j + 1] = sum[j] + dp[K + 1][j];
	for (int ii = 0; ii < T; ++ii) {
		long long rank;
		scanf("%lld", &rank), --rank;
		int x = (int)(upper_bound(sum.begin(), sum.end(), rank) - sum.begin()) - 1;
		rank -= sum[x];
		string ans;
		bool lz = true;
		for (int k = K; k >= 0; --k) {
			bool ok = false;
			rer(d, 0, 9) {
				ll cnt = x >= d << k ? dp[k][x - (d << k)] : 0;
				if (rank < cnt) {
					ok = true;
					x -= d << k;
					lz &= d == 0 && k != 0;
					if(!lz)
						ans += char('0' + d);
					break;
				}
				rank -= cnt;
			}
			assert(ok);
		}
		puts(ans.c_str());
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.275
medium
----------
PROBLEM STATEMENT:
Li and Lu have [expression]), then the measure of unfairness of this division is: 
[expression]

Find the minimum measure of unfairness that can be obtained with some division of the set of integers where Li gets exactly [expression] integers. 

Note [expression] means Set complement
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

const int maxn = 3100;
i64 dp[maxn][maxn];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int n, k;
    cin >> n >> k;
    vi64 a(n);
    forn(i, n) cin >> a[i];
    sort(all(a));
    forn(i, n + 1) forn(j, n + 1) dp[i][j] = 1e18;
    dp[0][0] = 0;
    forn(i, n) forn(j, i + 1) {
        if (j > k || i - j > n - k) continue;
        uin(dp[i + 1][j + 1], dp[i][j] + a[i] * (i - j - (n - k - (i - j))));
        uin(dp[i + 1][j], dp[i][j] + a[i] * (j - (k - j)));
    }
    cout << dp[n][k] << '\n';

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.276
medium
----------
PROBLEM STATEMENT:
We define subsequence as any subset of an array.  We define a subarray as a contiguous subsequence in an array.  

Given an array, find the maximum possible sum among:


all nonempty subarrays. 
all nonempty subsequences. 


Print the two values as space-separated integers on one line. 

Note that empty subarrays/subsequences should not be considered. 

For example, given an array [expression].  

Function Description  

Complete the maxSubarray function in the editor below.  It should return an array of two integers: the maximum subarray sum and the maximum subsequence sum of [expression].  

maxSubarray has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main()
{
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
    int loop;
    cin >> loop;
    while (loop--) {
        int size;
        cin >> size;
        vector<int> data(size, 0);
        for (int i = 0; i < size; ++i) {
            cin >> data[i];
        }

        vector<int> dp(size, 0);
        int big = 0;
        int sum = 0;
        int start = -1;
        for (int i = 0; i < size; i++) {
            int val = sum + data[i];

            if (val > 0) {
                if (sum == 0) {
                    start = i;
                }
                sum = val;
            } else {
                sum = 0;
            }

            if (sum > big) {
                big = sum;
            }
        }

        if (start == -1) {
            cout << data[0] << " ";
        } else {
            cout << big << " ";
        }

        sum = 0;
        start = -1;
        for (int i = 0; i < size; ++i) {
            if (data[i] > 0) {
                start = i;
                sum += data[i];
            }
        }

        if (start == -1) {
            cout << data[0] << endl;
        } else {
            cout << sum << endl;
        }
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.277
hard
----------
PROBLEM STATEMENT:
Bill Gates is on one of his philanthropic journeys to a village in Utopia. He has brought a box of packets of candies and would like to distribute one packet to each of the children.  Each of the packets contains a number of candies.  He wants to minimize the cumulative difference in the number of candies in the packets he hands out.  This is called the unfairness sum.  Determine the minimum unfairness sum achievable. 

For example, he brings [expression].  We calculate the unfairness sum as:

[expression]				
[expression]
[expression] 
[expression]

[expression]



Function Description

Complete the angryChildren function in the editor below.  It should return an integer that represents the minimum unfairness sum achievable.

angryChildren has the following parameter(s):


k: an integer that represents the number of children  
packets:  an array of integers that represent the number of candies in each packet  

----------
TOP SOLUTION:
----------
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <algorithm>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <cstring>
#include <numeric>
#include <complex>
#include <string>
#include <ctime>
#include <queue>

/*
// C++ 11 stuff

#include <unordered_set>
#include <unordered_map>
#include <tuple>
#include <array>

#define tup(name, pos) get<(pos)>(name)
#define A1(type, size) array <type, size>
#define A2(type, s1, s2) A1(A1(type, s2), s1)
#define A3(type, s1, s2, s3) A1(A2(type, s2, s3), s1)

//*/


using namespace std;

typedef long long LL;
typedef unsigned long long ULL;
typedef pair <int, int> pnt;


#define FI(i,a) for (int i=0; i<(a); ++i)
#define FOR(i,s,e) for (int i=(s); i<(e); ++i)
#define MEMS(a,b) memset(a,b,sizeof(a))
#define pb push_back
#define mp make_pair
#define ALL(a) a.begin(),a.end()
#define V(t) vector < t >
#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)<(b)?(a):(b))
#define ABS(a) ((a)>(0)?(a):(-(a)))
#define ALL(a) a.begin(),a.end()

#define dout(a) cerr << a << endl
#define sout(a) cerr << a << "  "
#define lbl cerr << "debug_label" << endl;

const double pi = 3.14159265358979323846264338327950288419716939937511;
const double eps = 1e-9;

//*
char ch_ch_ch[1<<20];
inline string gs() {scanf("%s",ch_ch_ch); return string(ch_ch_ch);}
inline string gl() {gets(ch_ch_ch); return string(ch_ch_ch);}
inline int gi() {int x; scanf("%d",&x); return x;}
//*/

const int inf = 1000000000;

// code starts here

int n;
V(int) a;
V(LL) sum;

void solution() {


    n = gi();
    int K = gi();
    FI(i,n) a.pb(gi());
    sort(ALL(a));
    sum.resize(n);
    LL res = inf*1ll*inf;
    sum[0] = a[0];
    FOR(i,1,n) sum[i] = a[i] + sum[i-1];
    LL cur = 0;
    FOR(i,1,K) cur += a[i]*1ll*i - sum[i-1];
    res = cur;
    if (K > 1) FOR(i,K,n) {
        cur += (K-1)*1ll*a[i] - (sum[i-1] - sum[i-K]);
        cur -= -(K-1)*1ll*a[i-K]  + (sum[i-1] - sum[i-K]);
        res = min(res,cur);
    }

    cout << res << endl;


}


// code ends here

int main(int argc, char** argv) {

#ifdef IGEL_ACM
    freopen("in.txt","r",stdin);
    //freopen("out.txt", "w", stdout);
    clock_t beg_time = clock();
#else
    //freopen(argv[1],"r",stdin);
    //freopen("painting.in", "r", stdin);
    //freopen("painting.out", "w", stdout);

#endif

    solution();

#ifdef IGEL_ACM
    fprintf(stderr,"*** Time: %.3lf ***\n",1.0*(clock()-beg_time)/CLOCKS_PER_SEC);
#endif

    return 0;
}


----------
====================
----------
ALGORITHMS.278
hard
----------
PROBLEM STATEMENT:
Watson gave Sherlock a collection of arrays [expression]. 

Watson asks Sherlock to merge [expression] into a sorted array. Sherlock is new to coding, but he accepts the challenge and writes the following algorithm:


[expression] (an empty array).
[expression].
While there is at least one non-empty array in [expression]:

[expression].
While [expression]:

If [expression] is not empty:
Remove the first element of [expression].
[expression].
While [expression] is not empty:

Remove the minimum element of [expression].
Return [expression] as the output.


Let's see an example. Let V be [expression].



The image below demonstrates how Sherlock will do the merging according to the algorithm:



Sherlock isn't sure if his algorithm is correct or not. He ran Watson's input, [expression]?

Given [expression].

Notes:


Two collections of arrays are different if one of the following is true:

Their sizes are different.
Their sizes are the same but at least one array is present in one collection but not in the other.
Two arrays, [expression], are different if one of the following is true:

Their sizes are different.
Their sizes are the same, but there exists an index [expression].

----------
TOP SOLUTION:
----------
#include <sstream>
#include <vector>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <string>
#include <cassert>
#include <ctime>
#include <map>
#include <math.h>
#include <cstdio>
#include <set>
#include <deque>
#include <memory.h>
#include <queue>

#pragma comment(linker, "/STACK:64000000")
typedef long long ll;

using namespace std;

const int MAXK = -1;
const int MAXN = 1222;
const int MOD = 1000 * 1000 * 1000 + 7;

int dp[MAXN][MAXN];
int fct[MAXN], ofct[MAXN];



int solve(vector<int> a) {
	int n = a.size();

	memset(dp, 0, sizeof(dp));
	for (int i = 1; i <= n; i++) {
		if (i > 1 && a[i - 1] < a[i - 2]) break;
		dp[i][i] = 1;
	}
	for (int i = 1; i < n; i++) {
		//cerr << i << endl;
		for (int j = 1; j <= i; j++) {
			if (dp[i][j] == 0) continue;
			for (int k = 1; k <= j && i + k <= n; k++) {
				if (k > 1 && a[i + k - 1] < a[i + k - 2]) break;
				dp[i + k][k] = (dp[i + k][k] + dp[i][j] * 1LL * fct[j] % MOD * ofct[j - k]) % MOD;
			}
		}
	}
	int ans = 0;
	for (int i = 0; i <= n; i++) ans = (ans + dp[n][i]) % MOD;
	return ans;
}

int bin(int a, int n) {
	int res = 1;
	while (n) {
		if (n & 1) res = 1LL * res * a % MOD;
		a = 1LL * a * a % MOD;
		n >>= 1;
	}
	return res;
}

int inv(int x) {
	return bin(x, MOD - 2);
}

void precalc() {
	fct[0] = 1;
	for (int i = 1; i < MAXN; i++) {
		fct[i] = 1LL * fct[i - 1] * i % MOD;
	}
	ofct[MAXN - 1] = inv(fct[MAXN - 1]);
	for (int i = MAXN - 2; i >= 0; i--) ofct[i] = 1LL * ofct[i + 1] * (i + 1) % MOD;
}

int main() {
#ifdef _MSC_VER
	freopen("input.txt", "r", stdin);
#endif
	precalc();

	int n;
	while (cin >> n) {
		vector<int> a(n);
		for (int i = 0; i < n; i++) cin >> a[i];

		/*n = 1200;
		a.resize(n);
		for (int i = 0; i < n; i++) a[i] = i + 1;*/

		cout << solve(a) << endl;
	}

	return 0;
}
----------
====================
----------
ALGORITHMS.279
medium
----------
PROBLEM STATEMENT:
Chloe is fascinated by prime numbers. She came across the number [expression] on a sign and, though the number is not prime, found some primes hiding in it by using the following rules:  


Every three consecutive digits sum to a prime:
[expression]
Every four consecutive digits sum to a prime:
[expression]
Every five consecutive digits sum to a prime:
[expression]


You must answer [expression], that satisfy all three of Chloe's rules (i.e., every three, four, and five consecutive digits sum to a prime).
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }


template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
	ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }

	ModInt inverse() const {
		signed a = x, b = MOD, u = 1, v = 0;
		while (b) {
			signed t = a / b;
			a -= t * b; std::swap(a, b);
			u -= t * v; std::swap(u, v);
		}
		if (u < 0) u += Mod;
		ModInt res; res.x = (unsigned)u;
		return res;
	}

	bool operator==(ModInt that) const { return x == that.x; }
	bool operator!=(ModInt that) const { return x != that.x; }
	ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }
};
typedef ModInt<1000000007> mint;

#pragma region for precomputing
int berlekampMassey(const vector<mint> &s, vector<mint> &C) {
	int N = (int)s.size();
	C.assign(N + 1, mint());
	vector<mint> B(N + 1, mint());
	C[0] = B[0] = 1;
	int degB = 0;
	vector<mint> T;
	int L = 0, m = 1;
	mint b = 1;
	for (int n = 0; n < N; ++n) {
		mint d = s[n];
		for (int i = 1; i <= L; ++i)
			d += C[i] * s[n - i];
		if (d == mint()) {
			++m;
		}
		else {
			if (2 * L <= n)
				T.assign(C.begin(), C.begin() + (L + 1));
			mint coeff = -d * b.inverse();
			for (int i = 0; i <= degB; ++i)
				C[m + i] += coeff * B[i];
			if (2 * L <= n) {
				L = n + 1 - L;
				B.swap(T);
				degB = (int)B.size() - 1;
				b = d;
				m = 1;
			}
			else {
				++m;
			}
		}
	}
	C.resize(L + 1);
	return L;
}

void computeMinimumPolynomialForLinearlyRecurrentSequence(const vector<mint> &a, vector<mint> &phi) {
	int n2 = (int)a.size(), n = n2 / 2;
	assert(n2 % 2 == 0);
	int L = berlekampMassey(a, phi);
	reverse(phi.begin(), phi.begin() + (L + 1));
}

template<int MOD> int mintToSigned(ModInt<MOD> a) {
	int x = a.get();
	if (x <= MOD / 2)
		return x;
	else
		return x - MOD;
}

int outputPrecomputedMinimalPolynomial(vector<mint> seq, ostream &os) {
	if (seq.size() % 2 == 1) seq.pop_back();
	vector<mint> phi;
	computeMinimumPolynomialForLinearlyRecurrentSequence(seq, phi);
	if (phi.size() >= seq.size() / 2 - 2) {
		cerr << "warning: maybe not enough terms" << endl;
	}
	cerr << "/*" << phi.size() - 1 << "*/";
	os << "{{ ";
	rep(i, phi.size() - 1) {
		if (i != 0) os << ", ";
		os << seq[i].get();
	}
	os << " }, { ";
	rep(i, phi.size()) {
		if (i != 0) os << ", ";
		os << mintToSigned(phi[i]);
	}
	os << " }}";
	return (int)phi.size() - 1;
}

#pragma endregion

vector<bool> isprime;
vector<int> primes;
void sieve(int n) {
	if ((int)isprime.size() >= n + 1) return;
	isprime.assign(n + 1, true);
	isprime[0] = isprime[1] = false;
	int sqrtn = (int)(sqrt(n * 1.) + .5);
	for (int i = 2; i <= sqrtn; i++) if (isprime[i]) {
		for (int j = i * i; j <= n; j += i)
			isprime[j] = false;
	}
	primes.clear();
	for (int i = 2; i <= n; i++) if (isprime[i])
		primes.push_back(i);
}

int main() {
	int T;
	scanf("%d", &T);
	const vector<mint>
		init = { 1, 9, 90, 303, 280, 218, 95, 101, 295, 513, 737, 668, 578, 1303, 2449, 3655, 3965 },
		phi = { 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, -2, -4, 0, 0, 0, 0, 1 };
	const int N = 400000;
	vector<mint> seq = init;
	while ((int)seq.size() <= N) {
		mint x;
		rep(j, phi.size() - 1)
			x -= phi[j] * seq[seq.size() - phi.size() + 1 + j];
		seq.push_back(x);
	}
	for (int ii = 0; ii < T; ++ii) {
		int n;
		scanf("%d", &n);
		mint ans = seq[n];
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.280
medium
----------
PROBLEM STATEMENT:
HackerRank-city is an acyclic connected graph (or tree). Its not an ordinary place, the construction of the whole tree takes place in [expression] steps. The process is described below:


It initially has [expression] node.
At each step, you must create [expression] copies in the following H shape:




At each [expression].

Calculate the sum of distances between each pair of nodes; as these answers may run large, print your answer modulo [expression].
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

const int maxn = 1100000;
const i64 P = 1000000000 + 7;
i64 cv[maxn], dr[maxn], ds[maxn], dop[maxn];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif
    
    int n;
    cv[0] = 1;
    dr[0] = 0;
    ds[0] = 0;
    dop[0] = 0;
    cin >> n;
    forn(i, n) {
        int x;
        cin >> x;
        cv[i + 1] = (4 * cv[i] + 2) % P;
        dr[i + 1] = (4 * dr[i] + (dop[i] + x) + (dop[i] + 2 * x) + cv[i] * (3 * dop[i] + 8 * x)) % P;
        dop[i + 1] = (2 * dop[i] + 3 * x) % P;
        ds[i + 1] = (4 * ds[i] + 2 * cv[i] * cv[i] % P * (2 * x) + 4 * cv[i] * cv[i] % P * (3 * x) + 12 * dr[i] % P * cv[i] + 8 * dr[i] + 4 * cv[i] * x + 4 * cv[i] * 2 * x + x) % P;
//        cerr << i + 1 << ' ' << cv[i + 1] << ' ' << dr[i + 1] << ' ' << dop[i + 1] << ' ' << ds[i + 1] << '\n';
    }
    cout << ds[n] << '\n';

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.281
medium
----------
PROBLEM STATEMENT:
Consider an array, [expression], we have the following arrays of pieces:


[expression]-element pieces.
[expression] element.
[expression] elements.
[expression]-element piece.


We consider the value of a piece in some array [expression].

Given [expression] on a new line.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define PII pair<int,int>
#define VI vector<int>
#define VPII vector<pair<int,int> >
#define PLL pair<long long,long long>
#define VPLL vector<pair<long long,long long> >
#define F first
#define S second
typedef long long LL;
using namespace std;
const int MOD = 1e9+7;
const int SIZE = 1e6+10;
int a[SIZE];
void ADD(int &x,LL v){
    x=(x+v)%MOD;
    if(x<0)x+=MOD;
}
int get(int L,int R){
    int v=a[R]-a[L-1];
    if(v<0)v+=MOD;
    return v;
}
int two[SIZE];
int main(){
    two[0]=1;
    REPP(i,1,SIZE){
        two[i]=two[i-1]*2%MOD;
    }
    DRI(n);
    REP(i,n)RI(a[i+1]);
    if(n==1){
        printf("%d\n",a[1]);
        return 0;
    }
    REPP(i,1,n+1)ADD(a[i],a[i-1]);
    int now=0;
    int an=0;
    for(int i=1;i*2-1<=n;i++){
        ADD(now,get(i,n+1-i));
        ADD(an,((LL)now-get(1,i)-get(n-i+1,n))*i%MOD*two[max(0,n-2-i)]);
        ADD(an,(get(1,i)+get(n-i+1,n))*(LL)i%MOD*two[n-1-i]);

        if(i==1)ADD(an,now*(LL)n);
        else if(i*2-1!=n){
            int j=n+1-i;
            ADD(an,((LL)now-get(1,j)-get(n-j+1,n))*j%MOD*two[max(0,n-2-j)]);
            ADD(an,(get(1,j)+get(n-j+1,n))*(LL)j%MOD*two[n-1-j]);
        }

    }
    printf("%d\n",an);
    return 0;
}

----------
====================
----------
ALGORITHMS.282
medium
----------
PROBLEM STATEMENT:
Mr K has a rectangular plot of land which may have marshes where fenceposts cannot be set. He wants you to find the perimeter of the largest rectangular fence that can be built on this land.

For example, in the following [expression] marks good land.

....
..x.
..x.
x...


If we number the rows and columns starting with [expression].  

Function Description

Complete the kMarsh function in the editor below.  It should print either an integer or impossible.

kMarsh has the following parameter(s):  


grid: an array of strings that represent the grid  

----------
TOP SOLUTION:
----------
#include <algorithm>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <iterator>
#include <limits>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
using namespace std;


/* Prewritten code begins */
#define REP(i,n)    for(int i=0; i<(n); ++i)
#define FOR(i,a,b)  for(int i=(a); i<=(b); ++i)
/* Prewritten code ends */

const int maxN = 505;
string s[maxN];
int range[maxN][maxN];
int main() {
	int R, C, lastC, res = 0;
	cin >> R >> C;
	REP(r,R) cin >> s[r];
	REP(c,C) range[0][c] = s[0][c] == '.' ? 0 : maxN;
	FOR(r,1,R-1) REP(c,C) if(s[r][c] == '.') range[r][c] = min(range[r-1][c], r); else range[r][c] = maxN;
	REP(r1,R) FOR(r2,r1+1,R-1) {
		lastC = -1;
		REP(c,C) {
			if(s[r1][c] == '.' && s[r2][c] == '.') {
				if(range[r2][c] <= r1) {
					if(lastC != -1) res = max(res, 2*(r2-r1-1)+2*(c-lastC+1));
					else lastC = c; 
				}
			} else {
				lastC = -1;
			}
		}
	}
	if(res == 0) cout << "impossible" << endl;
	else cout << res << endl;
	return 0;
}

----------
====================
----------
ALGORITHMS.283
medium
----------
PROBLEM STATEMENT:
In this problem, we'll use the term "longest common substring" loosely.  It refers to substrings differing at some number or fewer characters when compared index by index.  For example, 'abc' and 'adc' differ in one position, 'aab' and 'aba' differ in two.  

Given two strings and an integer [expression] positions.  

For example, [expression].  

Function Description

Complete the substringDiff function in the editor below.  It should return an integer that represents the length of the longest common substring as defined.  

substringDiff has the following parameter(s):  


k: an integer that represents the maximum number of differing characters in a matching pair  
s1: the first string  
s2: the second string  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <ctime>
using namespace std;

typedef short int sint;
const int N = 2001;

int n, t, K, L1, L2;
char p[N], q[N];
int diff[N][N];

void calc_diff() {
    for(int i = L1; i >= 0; i --)
        for(int j = L2; j >= 0; j --) {
            if(i == L1 || j == L2) diff[i][j] = 0;
            else {
                diff[i][j] = diff[i + 1][j + 1] + (p[i] == q[j] ? 0 : 1);
            }
        }
}

int get_diff(int p1, int p2, int len) {
    int result = diff[p1][p2] - diff[p1 + len][p2 + len];
    return result;
}

int solve() {
    int result = 0;
    // i = pos(p) - pos(q)
    // j = pos(p)
    // pos(q) = j - i >= 0 -> j >= i,
    // j - i < L2 -> j < L2 + i
    int pos = 0, pos2 = 0;
    for(int i = -L2 + 1; i < L1; i ++) {
        int right = 0;
        for(int j = max(0, i); j < min(L1, L2 + i); j ++) {
            int k = j - i;
            right = max(right, j - 1);
            while(right + 1 - j + k < L2 && right + 1 < L1 && get_diff(j, k, right - j + 2) <= K) right ++;
            result = max(result, right - j + 1);
            if(result == right - j + 1) {
                pos = j;
                pos2 = k;
            }
        }
    }
    /*for(int i = 0; i < result; i ++) cout << p[pos + i];
    cout << endl;
    for(int i = 0; i < result; i ++) cout << q[pos2 + i];
    cout << endl;
    cout << get_diff(pos, pos2, result) << endl;*/
    return result;
}

int main() {
    int cl = clock();
    for(cin >> t; t--; ) {
        cin >> K >> p >> q;
        L1 = strlen(p);
        L2 = strlen(q);
        calc_diff();
        cout << solve() << endl;
    }
//    cerr << (clock() - cl) * 0.001 << endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.284
medium
----------
PROBLEM STATEMENT:
You are given two positive integers [expression]:

[expression]

where operation [expression] means binary shift to the left.

Please note, that we consider ideal model of binary integers. That is there is infinite number of bits in each number, and there are no disappearings (or cyclic shifts) of bits.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

#define long long long
#define mod 1000000007ll
#define M 500500
#define N 13001000


const int T = 314159;

string a, b;
long p[M], x[M], s[N];

void pre() {
    p[0] = 1;
    for (int i = 1; i < M; ++i)
        p[i] = (2 * p[i - 1]) % mod;
}

void read() {
    cin >> a >> b;

    for (int i = 0; i < (int) a.length(); ++i)
        x[a.length() - 1 - i] = a[i] == '1' ? 1 : 0;

    for (int i = 0; i < (int) b.length(); ++i)
        s[b.length() - 1 - i + M] = b[i] == '1' ? 1 : 0;

    for (int i = 1; i < N; ++i)
        s[i] += s[i - 1];
}

long sum(int l, int r) {
    return s[r + M] - s[l + M];
}

void kill() {
    long ans = 0;
    for (int i = 0; i < M; ++i)
    if (x[i] == 0)
        ans = (ans + p[i] * sum(i - T - 1, i)) % mod;
    else
        ans = (ans + p[i] * (T + 1 - sum(i - T - 1, i))) % mod;

    cout << ans << "\n";
}


int main() {
#ifdef TROLL
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#else
    ios_base::sync_with_stdio(0);
#endif

    pre();
    read();
    kill();

    return 0;
}
----------
====================
----------
ALGORITHMS.285
medium
----------
PROBLEM STATEMENT:
You have an infinite number of 4 types of lego blocks of sizes given as (depth x height x width):

[expression]
[expression]
[expression]
[expression]
[expression]



Using these blocks, you want to make a wall of height [expression]. Features of the wall are: 

- The wall should not have any holes in it. 
- The wall you build should be one solid structure, so there should not be a straight vertical break across all rows of bricks. 
- The bricks must be laid horizontally.   

How many ways can the wall be built?

For example, the wall's height [expression].  Here are some configurations:  

  

These are not all of the valid permutations.

Function Description  

Complete the legoBlocks function in the editor below.  It should return an integer that represents the number of valid wall formations for the given wall dimensions modulo [expression].

legoBlocks has the following parameter(s):


n: an integer that represents the height of the wall  
m: an integer that represents the width of the wall  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>
 
using namespace std;
  
#define mo(m) if(m > 1000000007) m = m%1000000007
 
 
 
void solve(){
    int t,hMax = 0,wMax = 0;
 
    cin >> t;
    vector <int> vH(t);
    vector <int> vW(t);
 
    for(int i = 0; i < t;i++){
        cin >> vH[i] >> vW[i];
        if(vH[i] > hMax)
            hMax = vH[i];
 
        if(vW[i] > wMax)
            wMax = vW[i];
    }
    if(hMax < 4)
        hMax = 4;
    if(wMax < 4)
        wMax = 4;
 
    vector <int> rNumb(wMax + 1,0);
    vector <vector <int> > rNumbPwh(hMax + 1,rNumb);
    vector <vector <int> > rt(hMax + 1,rNumb);
    vector <int> hNumb(hMax + 1,0);
 
    for(int i = 0; i < t;i++){
        if(vW[i] > hNumb[vH[i]])
             hNumb[vH[i]] = vW[i];
    }
 
    rNumb[0] = 1;
    rNumb[1] = 1;
    rNumb[2] = 2;
    rNumb[3] = 4;
    rNumb[4] = 8;
 
    for(int i = 5; i <= wMax; i++){
        rNumb[i] += rNumb[i-4];
        mo(rNumb[i]);
        rNumb[i] += rNumb[i-3];
        mo(rNumb[i]);
        rNumb[i] += rNumb[i-2];
        mo(rNumb[i]);
        rNumb[i] += rNumb[i-1];
        mo(rNumb[i]);
    }
 
    for(int i = 1; i <= wMax; i++){
        long long rNumbTimes = rNumb[i];
        for(int j = 1;j <= hMax ;j++){
            rNumbPwh[j][i] =  rNumbTimes;
            rNumbTimes *= rNumb[i];
            mo(rNumbTimes);
        }
    }
 
    rt[1][1] = 1;
    rt[1][2] = 1;
    rt[1][3] = 1;
    rt[1][4] = 1;
 
    for(int i = 2 ; i <= hMax ; i++)
        rt[i][1] = 1;
 
 
    for(int j = 2;j <= hMax ;j++){
        for(int i = 2; i <= hNumb[j]; i++){
            long long rTemp = rNumbPwh[j][i];
            for(int k = 1 ;k < i ; k++){
                long long rTemp2 = ((long long) rt[j][k] )* ((long long) rNumbPwh[j][i-k]);
                mo(rTemp2);
 
                if(rTemp2 > rTemp){
                    rTemp = rTemp + 1000000007 - rTemp2;
                }
                else
                    rTemp -= rTemp2;
            }
            rt[j][i] = rTemp;
        }
    }
 
    for(int i = 0; i < t;i++){
        cout << rt[vH[i]][vW[i]]<<endl;
    }
}
 
 
 
int main(){
    solve();
    return 0;
}
----------
====================
----------
ALGORITHMS.286
hard
----------
PROBLEM STATEMENT:
You are given a grid having N rows and M columns. A grid square can either be blocked or empty. Blocked squares are represented by a '#' and empty squares are represented by '.'. Find the number of ways to tile the grid using L shaped bricks. A L brick has one side of length three units while other of length 2 units. All empty squares in the grid should be covered by exactly one of the L shaped tiles, and blocked squares should not be covered by any tile. The bricks can be used in any orientation (they can be rotated or flipped).
----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <queue>
#include <stack>
#include <bitset>
#include <vector>
#include <cstdio>
#include <string>
#include <sstream>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define PB push_back
#define MP make_pair
#define SZ(v) ((int)(v).size())
#define abs(x) ((x) > 0 ? (x) : -(x))
#define FOREACH(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
typedef long long LL;

const int MOD = 1000000007;
const int inf = 0x3f3f3f3f;
const int maxn = 25;
const int maxs = 1 << 8;
LL dp[maxn][maxs][maxs];
int state[maxn];
int cur, nxt;
int n, m, initJ, initK;

bool valid(int mask, int pos) {
	return (mask & (1 << pos)) == 0;
}

void dfs(int dep, int s1, int s2, int s3, int current) {
	if (current >= (1 << m)) return;
	if (current == (1 << m) - 1) {
		dp[nxt][s2][s3] = (dp[nxt][s2][s3] + dp[cur][initJ][initK]) % MOD;
		return;
	}
	if (s1 & (1 << dep)) {
		dfs(dep + 1, s1, s2, s3, current);
	} else {
		// ### <- dep
		//   #
		if (dep + 1 < m && valid(s2, dep) && valid(s3, dep) && valid(s3, dep + 1)) {
			dfs(dep + 1, s1, s2 | (1 << dep), s3 | (1 << dep) | (1 << (dep + 1)), current | (1 << dep));
		}
		//   # 
		// ### <- dep
		if (dep >= 1 && valid(s2, dep) && valid(s3, dep) && valid(s3, dep - 1)) {
			dfs(dep + 1, s1, s2 | (1 << dep), s3 | (1 << dep) | (1 << (dep - 1)), current | (1 << dep));
		}
		// #   <- dep
		// ###
		if (dep + 1 < m && valid(s1, dep + 1) && valid(s2, dep + 1) && valid(s3, dep + 1)) {
			dfs(dep + 2, s1, s2 | (1 << (dep + 1)), s3 | (1 << (dep + 1)), current | (1 << dep) | (1 << (dep + 1)));
		}
		// ### <- dep
		// #  
		if (dep + 1 < m && valid(s1, dep + 1) && valid(s2, dep) && valid(s3, dep)) {
			dfs(dep + 2, s1, s2 | (1 << dep), s3 | (1 << dep), current | (1 << dep) | (1 << (dep + 1)));
		}
		// ## <- dep
		//  #
		//  #
		if (dep + 2 < m && valid(s2, dep) && valid(s2, dep + 1) && valid(s2, dep + 2)) {
			dfs(dep + 1, s1, s2 | (1 << dep) | (1 << (dep + 1)) | (1 << (dep + 2)), s3, current | (1 << dep));
		}
		//  #
		//  #
		// ## <- dep
		if (dep >= 2 && valid(s2, dep) && valid(s2, dep - 1) && valid(s2, dep - 2)) {
			dfs(dep + 1, s1, s2 | (1 << (dep - 2)) | (1 << (dep - 1)) | (1 << dep), s3, current | (1 << dep));
		}
		// ## <- dep
		// #
		// #
		if (dep + 2 < m && valid(s2, dep) && valid(s1, dep + 1) && valid(s1, dep + 2)) {
			dfs(dep + 3, s1, s2 | (1 << dep), s3, current | (1 << dep) | (1 << (dep + 1)) | (1 << (dep + 2)));
		}
		// #  <- dep
		// #
		// ##
		if (dep + 2 < m && valid(s1, dep + 1) && valid(s1, dep + 2) && valid(s2, dep + 2)) {
			dfs(dep + 3, s1, s2 | (1 << (dep + 2)), s3, current | (1 << dep) | (1 << (dep + 1)) | (1 << (dep + 2)));
		}
	}
}

char str[10];
int main() {
	int ts;
	scanf("%d", &ts);
	while (ts--) {
		memset(state, 0, sizeof(state));
		scanf("%d%d", &n, &m);
		for (int i = 1; i <= n; i++) {
			scanf("%s", str);
			for (int j = 0; j < m; j++) {
				if (str[j] == '#') {
					state[i] |= (1 << j);
				}
			}
		}
		if (n == 1) {
			if (state[1] == (1 << m) - 1) puts("1");
			else puts("0");
			continue;
		}

		memset(dp, 0, sizeof(dp));
		dp[2][state[1]][state[2]] = 1;
		for (int i = 2; i <= n; i++) {
			cur = i, nxt = i + 1;
			for (int j = 0; j < (1 << m); j++) {
				for (int k = 0; k < (1 << m); k++) {
					if (dp[cur][j][k] == 0) continue;
					initJ = j; initK = k;
					dfs(0, j, k, state[i + 1], j);
				}
			}
		}
		cout << dp[n + 1][(1 << m) - 1][0] << endl;
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.287
hard
----------
PROBLEM STATEMENT:
Sophia has discovered several alien languages. Suprisingly, all of these languages have an alphabet, and each of them may contain thousands of characters! Also, all the words in a language have the same number of characters in it.

However, the aliens like their words to be aesthetically pleasing, which for them means that for the [expression]):


if [expression] letter may be the last letter of a word, or it may be immediately followed by any letter, including itself.
if [expression].  


Sophia wants to know how many different words exist in this language. Since the result may be large, she wants to know this number, modulo [expression].
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

#define mod 100000007

int a[500005];
inline void ADD(int & x, int y) {
    x += y; if (x >= mod) x -= mod;
}
int S(int l, int r) {
    int answer = 0;
    for (int i = l; i <= r; i ++) {
        ADD(answer, a[i]);
    }
    return answer;
}
void calc(int n, vector<int> & coeff) {
    // lo: [1..n/2]
    // hi: [n/2+1..n]
    a[0] = 0;
    for (int i = 1; i <= n; i ++) {
        a[i] = 1;
    }
    coeff[1] = S(n/2+1, n);
    for (int le = 2; coeff[le - 1] != 0; le ++) {
        for (int i = 1; i <= n; i ++) ADD(a[i], a[i - 1]);
        for (int i = n; i >= 1; i --) {
            a[i] = a[i / 2];
        }
        coeff[le] = S(n/2+1, n);
    }
}

int v[500005];
int main() {
    int tc; cin >> tc;
    for (; tc > 0; tc --) {
        int n, m;
        cin >> n >> m;
        vector<int> coeff (22);
        calc(n, coeff);
        v[0] = 1;
        for (int i = 1; i <= m; i ++) {
            v[i] = 0;
            for (int k = 0; k <= i and k <= 20; k ++) {
                v[i] = (v[i] + (long long) v[i - k] * coeff[k]) % mod;
            }
        }
        cout << v[m] << endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.288
medium
----------
PROBLEM STATEMENT:
Your algorithms have become so good at predicting the market that you now know what the share price of Wooden Orange Toothpicks Inc. (WOT) will be for the next number of days.

Each day, you can either buy one share of WOT, sell any number of shares of WOT that you own, or not make any transaction at all. What is the maximum profit you can obtain with an optimum trading strategy?

For example, if you know that prices for the next two days are [expression], no profit can be made so you don't buy or sell stock those days.  

Function Description  

Complete the stockmax function in the editor below.  It must return an integer that represents the maximum profit achievable.  

stockmax has the following parameter(s):  


prices: an array of integers that represent predicted daily stock prices    

----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		long long int n,a[50005],i,idx,b[50005],sum=0;
		scanf("%lld",&n);
		for(i=1;i<=n;i++)
		{
			scanf("%lld",&a[i]);
		}
		idx=n;
		b[n]=n;
		for(i=n-1;i>0;i--)
		{
			if(a[idx]<a[i])
			idx=i;
			b[i]=idx;
		}
		for(i=1;i<=n;i++)
		{
			if((a[b[i]]-a[i])>=0)
			sum+=(a[b[i]]-a[i]);
		}
		cout<<sum<<endl;
	}
}
----------
====================
----------
ALGORITHMS.289
medium
----------
PROBLEM STATEMENT:
You have a warehouse with [expression] piece of candy and transport it between any two containers.

The robots take instructions in the form of queries consisting of two integers, [expression] until it receives another query.   

Calculate the minimum total distance the robots must travel to execute [expression] queries in order. 

Note: You choose which robot executes each query.
----------
TOP SOLUTION:
----------
/*
-----------------------------------------------------------------------------
Author :            ---------------------------------------------------------
    UTKAR$H $AXENA  ---------------------------------------------------------
    IIT INDORE      ---------------------------------------------------------
-----------------------------------------------------------------------------
*/
#include<bits/stdc++.h>
#include<iostream>
using namespace std;
#define fre 	freopen("0.in","r",stdin);freopen("0.out","w",stdout)
#define abs(x) ((x)>0?(x):-(x))
#define MOD 1000000007
#define fi first
#define se second
#define LL signed long long int
#define scan(x) scanf("%d",&x)
#define print(x) printf("%d\n",x)
#define scanll(x) scanf("%lld",&x)
#define printll(x) printf("%lld\n",x)
#define rep(i,from,to) for(int i=(from);i <= (to); ++i)
#define pii pair<int,int>

vector<int> G[2*100000+5];
int fdp[1005][1005];
LL dp[1005][1005], T=0;
pii Q[1000+5];
LL cost(int i,int j){
	if(i==0)
		return abs(Q[j].fi-Q[j].se);
	return abs(Q[j].fi-Q[j].se) + abs(Q[j].fi-Q[i].se);
}
int N;
LL rec(int i,int j){
	if(i==N or j==N)return 0;
	if(fdp[i][j]==T)
		return dp[i][j];
	fdp[i][j] = T;
	int k = max(i,j) + 1;
	return dp[i][j] = min(rec(k,j)+cost(i,k),rec(i,k)+cost(j,k));
}
int main(){
	//fre;
	int t, M;
	cin>>t;
	while(t--){
		T++;
		cin>>M>>N;
		for(int i=1;i<=N;++i){
			scan(Q[i].fi);
			scan(Q[i].se);
		}
		printll(rec(0,0));
	}
}

----------
====================
----------
ALGORITHMS.290
medium
----------
PROBLEM STATEMENT:
Given a tree T with n nodes, how many subtrees (T') of T have at most K edges connected to (T - T')? 
----------
TOP SOLUTION:
----------
#include <cassert>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <algorithm>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <vector>

using namespace std;

#ifndef ONLINE_JUDGE
#define Eo(x) { cerr << #x << " = " << (x) << endl; }
#else
#define Eo(x)
#endif

typedef long long int64;
const int inf = 0x3f3f3f3f;
const int64 inf64 = 0x3f3f3f3f3f3f3f3fLL;
typedef double real;
const real eps = 1e-6;
typedef pair<int,int> pip;

template <typename A,typename B>
ostream& operator<<(ostream& os, const pair<A,B>& p) {
	return os << p.first << "," << p.second;
}

template <typename A>
ostream& operator<<(ostream& os, const vector<A>& v) {
	for (int i = 0; i < v.size(); i++) {
		os << v[i] << ';';
	}
	return os;
}

template <typename A, typename B>
ostream& operator<<(ostream& os, const map<A,B>& m) {
  for (typename map<A,B>::const_iterator it = m.begin(); it != m.end(); ++it) {
    os << it->first << ":" << it->second << ";";
  }
  return os;
}

int64 gcd(int64 a, int64 b) {
	return a ? gcd(b%a,a) : b;
}

const int maxn = 52;
vector<int> g[maxn];
int n,k;
int64 res[maxn][maxn];
int64 d2[maxn][maxn];
int64 part[maxn][maxn];

void dfs(int v, int par) {
	//Eo(pip(v,par));
	for (int i = 0; i < g[v].size(); i++) {
		int p = g[v][i];
		if (p == par) continue;
		dfs(p,v);
	}
	int z = 0;
	for (int i = 0; i < g[v].size(); i++) {
		int p = g[v][i];
		if (p == par) continue;
		for (int j = 0; j <= n; j++) {
			part[z][j] = res[p][j];
		}
		z++;
	}
	for (int i = 0; i <= z; i++) {
		for (int j = 0; j <= n; j++) {
			d2[i][j]=0;
		}
	}
	d2[0][0]=1;
	for (int i = 0; i < z; i++) {
		for (int j = 0; j <= n; j++) if (d2[i][j]) {
			d2[i+1][j+1] += d2[i][j];
			for (int k = 0; k+j <= n; k++) {
				d2[i+1][j+k] += d2[i][j]*part[i][k];
			}
		}
	}
	for (int i = 0; i <= n; i++) {
		res[v][i] = d2[z][i];
	}
}

int main() {
	cin >> n >> k;
	for (int i = 0; i < n-1; i++) {
		int x,y; scanf("%d%d",&x,&y);
		x--;y--;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	dfs(0,-1);
	int64 sum = 1;
	for (int i = 0; i <= k; i++) {
		sum += res[0][i];
	}
	for (int j = 1; j < n; j++) {
		for (int i = 0; i <= k-1; i++) {
			sum += res[j][i];
		}
	}
	cout << sum << endl;
#if 0
	for (int i =0; i < n; i++) {
		for (int j = 0; j <= n; j++) {
			printf("%d ",int(res[i][j]));
		}
		puts("");
	}
#endif
	return 0;
}

----------
====================
----------
ALGORITHMS.291
hard
----------
PROBLEM STATEMENT:
Tara has an array, [expression] times in the array. 

Let's define [expression].

You are given [expression], on a new line.

Note: Two permutations, [expression].
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
ALGORITHMS.292
medium
----------
PROBLEM STATEMENT:
One day, Wet Shark was given an array [expression]. As always, he started playing with its subsequences. 

When you came to know about this habit, you presented him a task of finding all pairs of subsequences, [expression] 


[expression].
[expression]
[expression]


Please help Wet Shark determine how many possible subsequences [expression]. 

Note: 


Two segments are different if there's exists at least one index [expression] is present in exactly one of them.
Both subsequences can overlap each other.
Subsequences do not necessarily have to be distinct

----------
TOP SOLUTION:
----------
#define _USE_MATH_DEFINES
#include <algorithm>
#include <cstdio>
#include <functional>
#include <iostream>
#include <cfloat>
#include <climits>
#include <cstring>
#include <cmath>
#include <fstream>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <time.h>
#include <vector>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> i_i;
typedef pair<ll, int> ll_i;
typedef pair<double, int> d_i;
typedef pair<ll, ll> ll_ll;
typedef pair<double, double> d_d;
struct edge { ll B, T, F, P; };

unsigned MOD = 1000000007;
ll _MOD = 1000000009;
double EPS = 1e-10;
int UNKO = INT_MAX;

int main() {
	int m, r, s; cin >> m >> r >> s;
	vector<int> x(m);
	for (int i = 0; i < m; i++)
		cin >> x[i];
	if ((r + s) % 2 || r < s) {
		cout << 0 << endl;
		return 0;
	}
	int A = (r + s) / 2, B = (r - s) / 2;
	vector<vector<ll> > dp(m + 1, vector<ll>(2001));
	dp[0][0] = 1;
	for (int i = 0; i < m; i++) {
		vector<vector<ll> > _dp = dp;
		for (int j = 0; j + 1 <= m; j++)
			for (int k = 0; k + x[i] <= 2000; k++)
				_dp[j + 1][k + x[i]] = (_dp[j + 1][k + x[i]] + dp[j][k]) % MOD;
		dp = _dp;
	}
	ll a = 0, b = 0, ans = 0;
	for (int j = 1; j <= m; j++) {
		a = dp[j][A] % MOD;
		b = dp[j][B] % MOD;
		ans = (ans + a * b) % MOD;
	}
	cout << ans << endl;
}
----------
====================
----------
ALGORITHMS.293
medium
----------
PROBLEM STATEMENT:
Nikita just came up with a new array game. The rules are as follows:


Initially, Nikita has an array of integers.
In each move, Nikita must partition the array into [expression] point; otherwise, the game ends.
After each successful move, Nikita discards either the left partition or the right partition and continues playing by using the remaining partition as array [expression].


Nikita loves this game and wants your help getting the best score possible. Given [expression], can you find and print the maximum number of points she can score?

For example, Nikita starts with the array [expression].   

Function Description  

Complete the arraySplitting function in the editor below.  It should return an integer that reperesents the number of times Nikita can split the array.  

arraySplitting has the following parameter(s):  


arr: an array of integers  

----------
TOP SOLUTION:
----------
//start of jonathanirvings' template v3.0.1 (BETA)

#include <stdio.h>
#include <iostream>
#include <algorithm>
#include <deque>
#include <string>
#include <string.h>
#include <vector>
#include <stack>
#include <queue>
#include <math.h>
#include <stdlib.h>
#include <map>
#include <set>
#include <time.h>
#include <bitset>
#include <list>
#include <assert.h>
#include <time.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,"====TESTING====\n")
  #define VALUE(x) cerr << "The value of " << #x << " is " << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,"%lld",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,"%lld",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf("%s",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  freopen ((s + ".in").c_str (), "r", stdin);
  freopen ((s + ".out").c_str (), "w", stdout);
}

//end of jonathanirvings' template v3.0.1 (BETA)

int data[17000];
int n;
int T;

int count(int L,int R)
{
  if (L == R) return 0;
  LL tot = 0;
  FORN(i,L,R) tot += data[i];
  if (tot % 2 == 1) return 0;
  LL now = 0;
  FORN(i,L,R)
  {
    now += data[i];
    if (now == tot/2)
    {
      return 1 + max(count(L,i),count(i+1,R));
    }
  }
  return 0;
}

int main()
{
  scanf("%d",&T);
  TC(T)
  {
    scanf("%d",&n);
    REP(i,n) scanf("%d",&data[i]);
    int risan = count(0,n-1);
    printf("%d\n",risan);
  }
  return 0;
}










----------
====================
----------
ALGORITHMS.294
hard
----------
PROBLEM STATEMENT:
There are [expression]):


Choose an integer, [expression] (inclusive).
Remove the [expression]. You can choose to remove the ball from whichever end in each step maximizing the expected total number of white balls picked at the end.


Given a string describing the initial row of balls as a sequence of [expression].  
----------
TOP SOLUTION:
----------
#pragma GCC diagnostic ignored "-Wunused-result"

#include <cstdio>
#include <algorithm>
#include <cassert>
#include <map>

double e[1 << 24]; // up to 23 bits.
// 0 (23 bits: 1 white 0 black)
// 10 (22 bits: 1 white 0 black)
// 110 (21 bits...
// e[?] -> expected number of taken white balls

const char * toBinStr(int code) {
	static char str[24 + 1] = {};
	for (int i = 0; i < 24; i++) {
		str[23 - i] = (char)('0' + ((code >> i) & 1));
	}
	return str;
}

struct Pair {

	int code; // 1 white 0 black

	int nBalls;

};

bool operator < (const Pair &left, const Pair &right) {
	if (left.code != right.code) {
		return left.code < right.code;
	} else {
		return left.nBalls < right.nBalls;
	}
}

std::map<Pair, double> ee; // {nBalls, code} -> expected number of taken white balls

double getE(const Pair &pair, int remOps) {
	if (remOps == 0) {
		return 0;
	}
	int nBalls = pair.nBalls;
	int code = pair.code;
	if (nBalls == 23) {
		return e[code];
	}
	assert(nBalls > 23);
	if (ee.count(pair) == 0) {
		double sum = 0;
		for (int chosenA = 0; chosenA < nBalls / 2; chosenA++) {
			int ballA = ((code >> chosenA) & 1);
			int codeA = (code & ((1 << chosenA) - 1)) + ((code >> 1) & ~((1 << chosenA) - 1));
			int chosenB = nBalls - 1 - chosenA;
			int ballB = ((code >> chosenB) & 1);
			int codeB = (code & ((1 << chosenB) - 1)) + ((code >> 1) & ~((1 << chosenB) - 1));
			sum += std::max(
				ballA + getE(Pair{codeA, nBalls - 1}, remOps - 1),
				ballB + getE(Pair{codeB, nBalls - 1}, remOps - 1));
		}
		sum *= 2;
		if (nBalls % 2 == 1) {
			int chosenA = nBalls / 2;
			int ballA = ((code >> chosenA) & 1);
			int codeA = (code & ((1 << chosenA) - 1)) + ((code >> 1) & ~((1 << chosenA) - 1));
			sum += ballA + getE(Pair{codeA, nBalls - 1}, remOps - 1);
		}
		ee[pair] = sum / nBalls;
	}
	return ee[pair];
}

int main() {
	int nBalls, nOps;
	scanf("%d %d", &nBalls, &nOps);
	for (int b = nBalls - nOps + 1; b <= 23; b++) {
		for (int code = (1 << 24) - (1 << (b + 1)); code < (1 << 24) - (1 << b); code++) {
			// printf("b=%d code=%s\n", b, toBinStr(code));
			double sum = 0;
			for (int chosenA = 0; chosenA < b / 2; chosenA++) {
				int ballA = ((code >> chosenA) & 1);
				int codeA = (code & ((1 << chosenA) - 1)) + (((code >> 1) + (1 << 23)) & ~((1 << chosenA) - 1));
				// printf("chosenA=%d ballA=%d codeA=%s\n", chosenA, ballA / MUL, toBinStr(codeA));
				int chosenB = b - 1 - chosenA;
				int ballB = ((code >> chosenB) & 1);
				int codeB = (code & ((1 << chosenB) - 1)) + (((code >> 1) + (1 << 23)) & ~((1 << chosenB) - 1));
				// printf("chosenB=%d ballB=%d codeB=%s\n", chosenB, ballB / MUL, toBinStr(codeB));
				sum += std::max(ballA + e[codeA], ballB + e[codeB]);
			}
			sum *= 2;
			if (b % 2 == 1) {
				int chosen = b / 2;
				int ballA = ((code >> chosen) & 1);
				int codeA = (code & ((1 << chosen) - 1)) + (((code >> 1) + (1 << 23)) & ~((1 << chosen) - 1));
				// printf("chosen+=%d ballA=%d codeB=%s\n", chosen, ballA / MUL, toBinStr(codeA));
				sum += ballA + e[codeA];
			}
			e[code] = sum / b;
		}
	}
	int code = 0;
	for (int i = 0; i < nBalls; i++) {
		char c;
		scanf(" %c", &c);
		if (c == 'W') {
			code |= 1 << i;
		}
	}
	if (nBalls <= 23) {
		code += (1 << 24) - (1 << (nBalls + 1));
		printf("%.7f", e[code]);
	} else {
		printf("%.7f", getE(Pair{code, nBalls}, nOps));
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.295
medium
----------
PROBLEM STATEMENT:
The evil forest is guarded by vicious mandragoras. Garnet and her pet must make a journey through.  She starts with [expression] experience points.    

As she encouters each mandragora, her choices are:


Garnet's pet eats mandragora [expression].  
Garnet's pet battles mandragora [expression]. 


Once she defeats a mandragora, it is out of play.  Given a list of mandragoras with various health levels, determine the maximum number of experience points she can collect on her journey.  

For example, as always, she starts out with [expression]attle.  We have the following permutations of choices and outcomes:

Action  s   p
_______ _   __
e, e, e 4   0
e, e, b 3   15
e, b, b 2   14
b, b, b 1   10
b, b, e 2   10
b, e, e 3   9
b, e, b 2   16
e, b, e 3   6


Working through a couple of rows, first, her pet can eat all three and she does not gain any experience points.  In the second row, her pet eats the first two to have [expression] experience points.

Function Description  

Complete the mandragora function in the editor below.  It must return an integer that denotes the maximum number of experience points that Garnet can earn.

mandragora has the following parameter(s):  


H: an array of integers that represents the health values of mandragoras  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

#define pb push_back
#define mp make_pair
#define REP(i, n) for (int i = 0; i < (int)(n); ++i)
typedef long long LL;
typedef pair<int, int> PII;

int tt, n;
int a[100000];
LL sum[100001];

int main() {
    scanf("%d", &tt);
    REP(test, tt) {
        scanf("%d", &n);
        REP(i, n) scanf("%d", a + i);
        sort(a, a + n);
        sum[n] = 0;
        for (int i = n - 1; i >= 0; --i) {
            sum[i] = sum[i + 1] + a[i];
        }
        LL ans = 0;
        REP(i, n) {
            ans = max(ans, (i + 1) * sum[i]);
        }
        printf("%lld\n", ans);
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.296
medium
----------
PROBLEM STATEMENT:
Red John has committed another murder. This time, he doesn't leave a red smiley behind. Instead he leaves a puzzle for Patrick Jane to solve. He also texts Teresa Lisbon that if Patrick is successful, he will turn himself in. The puzzle begins as follows.  

There is a wall of size 4xn in the victim's house. The victim has an infinite supply of bricks of size 4x1 and 1x4 in her house. There is a hidden safe which can only be opened by a particular configuration of bricks. First we must calculate the total number of ways in which the bricks can be arranged so that the entire wall is covered.  The following diagram shows how bricks might be arranged to cover walls where [expression]:



There is one more step to the puzzle.  Call the number of possible arrangements [expression].  

As an example, assume [expression].

A more complex example is [expression].



Function Description  

Complete the redJohn function in the editor below.  It should return the number of primes determined, as an integer.  

redJohn has the following parameter(s):  


n: an integer that denotes the length of the wall  

----------
TOP SOLUTION:
----------
#include <algorithm>
#include <cassert>
#include <cctype>
#include <cstdio>
#include <cstring>
#include <fstream>
#include <iostream>
#include <iterator>
#include <map>
#include <queue>
#include <set>
#include <string>
#include <utility>
#include <vector>

using namespace std;

#define MAX_VAL_ 300000
// 6bits = 1parity bit + 32 different offsets in the same int
int P_[(MAX_VAL_>>6) + 1]; // negative logic (1 bit marks a non-prime)
// ****** only call this for ODD x greater than 1 *****
inline bool is_prime_fast(int x) { return !((P_[x>>6]>>((x>>1)&0x1f))&1); }
// ****** only call this for ODD x greater than 1 *****
inline void mark_nonprime(int x) { P_[x>>6] |= (1<<((x>>1)&0x1f)); }
inline bool is_prime(int x) { return x==2 ? true : x<2||((x&1)==0) ? false : is_prime_fast(x); }
void init_primes() { for (long long x=3; x*x<=MAX_VAL_; x+=2) if (is_prime_fast(x)) { const long long z = x<<1; for (long long y=x*x; y<=MAX_VAL_; y+=z) mark_nonprime(y); } }

int ways[41];
int main() {
    init_primes();

    int T;
    cin >> T;
    for (int testcase=0; testcase<T; ++testcase) {
        int n;
        cin >> n;
        ways[0] = 1;
        for (int i=1; i<=n; ++i) {
            ways[i] = ways[i-1];
            if (i >= 4) {
                ways[i] += ways[i-4];
            }
        }
        int sol = (ways[n]>=2);
        for (int i=3; i<=ways[n]; i+=2) {
            if (is_prime(i)) {
                ++sol;
            }
        }
        cout << sol << '\n';
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.297
medium
----------
PROBLEM STATEMENT:
Given two strings, [expression] such that the length of the Longest Common Subsequence of characters in the two strings increases by one.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

int N, M;
char S[5002];
char T[5002];
int dp[5002][5002];
int dp2[5002][5002];
bool ok[256];

int main()
{
    scanf("%s", S+1);
    N=strlen(S+1);
    scanf("%s", T+1);
    M=strlen(T+1);
    for(int i=1; i<=N; i++) for(int j=1; j<=M; j++)
    {
        if(S[i]==T[j])
            dp[i][j]=dp[i-1][j-1]+1;
        else
            dp[i][j]=max(dp[i-1][j], dp[i][j-1]);
    }
    for(int i=N; i>=1; i--) for(int j=M; j>=1; j--)
    {
        if(S[i]==T[j])
            dp2[i][j]=dp2[i+1][j+1]+1;
        else
            dp2[i][j]=max(dp2[i+1][j], dp2[i][j+1]);
    }
    int lcs=dp[N][M];
    int ans=0;
    for(int i=0; i<=N; i++)
    {
        for(int j=1; j<=M; j++)
        {
            if(dp[i][j-1]+dp2[i+1][j+1]==lcs)
                ok[(int)T[j]]=true;
        }
        for(int j=0; j<256; j++)
        {
            ans+=ok[j];
            ok[j]=false;
        }
    }
    printf("%d\n", ans);
    return 0;
}

----------
====================
----------
ALGORITHMS.298
medium
----------
PROBLEM STATEMENT:
You are situated in an [expression].

For example, you start off in a 3 dimensional grid at position [expression].    

  

If we started at [expression].

Function Description

Complete the gridWalking function in the editor below.  It should return an integer that represents the number of possible moves, modulo [expression].

gridWalking has the following parameter(s):


m: an integer that represents the number of steps  
x: an integer array where each [expression]
D: an integer array where each [expression] dimension  

----------
TOP SOLUTION:
----------
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#define MOD 1000000007

int memo[102][102][302] ;
int solve(int D,int x,int M)
{
 if(x <= 0 || x > D) return 0 ;
 if(M == 0) return 1 ;
 if(memo[D][x][M] != -1) return memo[D][x][M] ;
 return memo[D][x][M] = (solve(D,x - 1,M - 1) + solve(D,x + 1,M - 1)) % MOD ;
}

int n,x[10],D[10] ;
int ncr[302][302],memo2[10][302] ;
int solve2(int k,int M)
{
 if(k == n) return M == 0 ? 1 : 0 ;
 if(memo2[k][M] != -1) return memo2[k][M] ;
 int ret = 0 ;
 for(int i = 0;i <= M;i++)
 {
  long long cret = 1LL * solve(D[k],x[k],i) * ncr[M][i] % MOD ;
  ret += cret * solve2(k + 1,M - i) % MOD ;
  if(ret >= MOD) ret -= MOD ;
 }
 return memo2[k][M] = ret ;
}

int brute(int M)
{
 if(M == 0) return 1 ;
 int ret = 0 ;
 for(int i = 0;i < n;i++)
 {
  x[i]-- ;
  if(x[i] >= 1) ret += brute(M - 1) ;
  x[i] += 2 ;
  if(x[i] <= D[i]) ret += brute(M - 1) ;
  x[i]-- ;
 }
 return ret ;
}

int main()
{
 for(int i = 0;i < 302;i++)
 {
  ncr[i][0] = ncr[i][i] = 1 ;
  for(int j = 1;j < i;j++)
   ncr[i][j] = (ncr[i - 1][j] + ncr[i - 1][j - 1]) % MOD ;
 }
 memset(memo,255,sizeof memo) ;

 int runs ;
 scanf("%d",&runs) ;
 while(runs--)
 {
  int M ;
  scanf("%d%d",&n,&M) ;
  for(int i = 0;i < n;i++) scanf("%d",&x[i]) ;
  for(int i = 0;i < n;i++) scanf("%d",&D[i]) ;
  memset(memo2,255,sizeof memo2) ;
  int ret = solve2(0,M) ;
//  int retB = brute(M) ;
  
//  printf("%d\n",retB) ;
  printf("%d\n",ret) ;
 }
 return 0 ;
}

----------
====================
----------
ALGORITHMS.299
hard
----------
PROBLEM STATEMENT:
You are playing a matrix-based game with the following setup and rules:   


You are given a matrix [expression]. (If the cell number is positive their score increases, otherwise it decreases.)
The player starts from any cell in the first row and can move left, right or down.  
The game is over when the player reaches the last row and stops moving.  


  

Print the maximum score that the player can get. 
----------
TOP SOLUTION:
----------
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdlib> 
#include<vector>
#include<map>
#include<cstring>
#define rep(i,j,k) for(register int i = j; i <= k; ++i)
#define dow(i,j,k) for(register int i = j; i >= k; --i)
#define ll long long
#define mp make_pair
#define fi first
#define se second 
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
 
inline int read() { 
    int s = 0, t = 1; char c = getchar();
    while( !isdigit(c) ) { if( c == '-' ) t = -1; c = getchar(); }
    while( isdigit(c) ) s = s * 10 + c - 48, c = getchar();
    return s * t;
}

const int N = 4e6+5, inf = 1e9+7;
int n, m, maxl, now, pre, f[2][N], v[N], g[N], h[N], sum[N]; 

int main() {
	n = read(), m = read(), now = 0, pre = 1;
	rep(i,1,n) { 
		swap(now,pre); 
		rep(j,1,m) v[j] = read();
		rep(j,1,m) sum[j] = sum[j-1] + v[j];
		rep(j,1,m) g[j] = max(g[j-1]+v[j],0);
		dow(j,m,1) h[j] = max(h[j+1]+v[j],0);
		maxl = -inf;
		rep(j,1,m) { 
			maxl = max(maxl,f[pre][j]-sum[j-1]+g[j-1]);
			f[now][j] = maxl+sum[j]+h[j+1];
		} 
		maxl = -inf;
		dow(j,m,1) { 
			maxl = max(maxl,f[pre][j]+sum[j]+h[j+1]);
			f[now][j] = max(f[now][j],maxl-sum[j-1]+g[j-1]);
		}
	}
	int ans = 0;
	rep(i,1,m) ans = max(ans,f[now][i]);
	cout<<ans<<endl;
	return 0;
}
----------
====================
----------
ALGORITHMS.300
medium
----------
PROBLEM STATEMENT:
Given an array of integers and a target sum, determine the sum nearest to but not exceeding the target that can be created.  To create the sum, use any element of your array zero or more times.

For example, if [expression].  In this case, you can arrive at exactly the target.  

Function Description  

Complete the unboundedKnapsack function in the editor below.  It must return an integer that represents the sum nearest to without exceeding the target value.  

unboundedKnapsack has the following parameter(s):  


k: an integer  
arr: an array of integers  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
int dp[2005]; 
int main() {
    int a; cin >> a;
    for (int g=0;g<a; g++)
        {memset(dp,0,sizeof(dp)); 
        int b,c; cin >> b >> c; vector <int> t;
        for (int y=0;y<b; y++){int d; cin >> d;t.push_back(d);}
        dp[0]=1; int r=0; 
        for (int g=1; g<=c; g++)
            {
            for (int y=0;y<t.size(); y++)
                {
                if (t[y]>g) continue; if (dp[g-t[y]]) dp[g]=1; 
            }
            if (dp[g]) r=g; 
        }
        cout << r << '\n'; 
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.301
medium
----------
PROBLEM STATEMENT:
You and your friend decide to play a game using a stack consisting of N bricks. In this game, you can alternatively remove 1, 2 or 3 bricks from the top, and the numbers etched on the removed bricks are added to your score. You have to play so that you obtain the maximum possible score. It is given that your friend will also play optimally and you make the first move.  

As an example, bricks are numbered [expression] in your first move.  

Function Description  

Complete the bricksGame function in the editor below.  It should return an integer that represents your maximum possible score.  

bricksGame has the following parameter(s):  


arr:  an array of integers  

----------
TOP SOLUTION:
----------
#include<math.h>
#include<algorithm>
#include<cstdlib>
#include<iostream>
#include<stdio.h>
#include<map>
#include<ext/hash_map>
#include<ext/hash_set>
#include<set>
#include<string>
#include<assert.h>
#include<vector>
#include<time.h>
#include<queue>
#include<deque>
#include<sstream>
#include<stack>
#include<sstream>
#define MA(a,b) ((a)>(b)?(a):(b))
#define MI(a,b) ((a)<(b)?(a):(b))
#define AB(a) (-(a)<(a)?(a):-(a))
#define X first
#define Y second
#define mp make_pair
#define pb push_back
#define pob pop_back
#define ep 0.0000000001
#define Pi 3.1415926535897932384626433832795
using namespace std;
using namespace __gnu_cxx;
const long long  MO=1000000000+7;
int i,j,n,m,k;
int a[1000000];
long long s[1000000],su[1000000];
bool f[1000000];
long long sol(int x)
{
    if (x==n+1) return 0;
    if (f[x]) return s[x];
    if (n-x<=2) return s[x]=su[x];
    f[x]=1;
    s[x]=0;
    if (x+1<=n+1)s[x]=max(s[x],su[x]-sol(x+1));
    if (x+2<=n+1)s[x]=max(s[x],su[x]-sol(x+2));
    if (x+3<=n+1)s[x]=max(s[x],su[x]-sol(x+3));
}
int main()
{
    int t;
    cin>>t;
    while (t--)
    {
        cin>>n;
        for (i=1;i<=n;i++)
            scanf("%d",&a[i]);
        for (i=n;i>=1;i--)
            su[i]=su[i+1]+a[i];
        for (i=1;i<=n;i++)
            f[i]=0;
        cout<<sol(1)<<endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.302
advanced
----------
PROBLEM STATEMENT:
An Introduction to the Longest Increasing Subsequence Problem  

The task is to find the length of the longest subsequence in a given array of integers such that all elements of the subsequence are sorted in strictly ascending order. This is called the Longest Increasing Subsequence (LIS) problem.

For example, the length of the LIS for [expression].  

Here's a great YouTube video of a lecture from MIT's Open-CourseWare covering the topic.  

   

This is one approach which solves this in quadratic time using dynamic programming. A more efficient algorithm which solves the problem in [expression] time is available here. 

Given a sequence of integers, find the length of its longest strictly increasing subsequence.

Function Description  

Complete the longestIncreasingSubsequence function in the editor below.  It should return an integer that denotes the array's LIS.  

longestIncreasingSubsequence has the following parameter(s):  


arr: an unordered array of integers  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <cmath>
#include <algorithm>
#include <set>
#include <map>
#include <string>
#include <cstring>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <ctime>

using namespace std;

#define f first
#define s second
#define pb push_back
#define mp make_pair
#define forit(s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it ++)
#define N 1000100
#define all(a) a.begin(), a.end()
#define ll long long
#define pii pair <int, int>
#define sz(a) (int)a.size()
#define vi vector <int>
#define forn(i, n) for(int i = 0; i < n; i ++)

const int inf = (int)(1e9);
const int mod = inf + 7;
const double pi = acos(-1.0);
const double eps = 1e-9;

int n, a[N];

int main () {

    #ifdef LOCAL
    freopen("a.in", "r", stdin);
    freopen("a.out", "w", stdout);
    #endif

    cin >> n;
    for(int i = 0; i < n; i++) scanf("%d", a + i);
    vector <int> d(N, 0);

    d[0] = -inf;
    for(int i = 1; i < N; i++) d[i] = inf;

    for(int i = 0; i < n; i++) {
        int j = upper_bound(all(d), a[i]) - d.begin();
        if(d[j - 1] < a[i] && a[i] < d[j]) d[j] = a[i];
    }

    for(int i = N - 1;; i--) {
        if(d[i] != inf) {
            cout << i;
            return 0;
        }
    }

    return 0;
}

----------
====================
----------
ALGORITHMS.303
medium
----------
PROBLEM STATEMENT:
You have a rectangular board consisting of [expression] - there is a coin on the top-left cell of your board. Each cell of your board contains one of these letters:  


*: Exactly one of your cells has letter '*'.
U: If at time [expression].
L: If at time [expression].
D: If at time [expression].
R: If at time [expression].


When the coin reaches a cell that has letter '*', it will stay there permanently. When you punch on your board, your timer starts and the coin moves between cells. Before starting the game, you can make operations to change the board, such that you are sure that at or before time [expression] the coin will reach the cell having letter '*'. In each operation you can select a cell with some letter other than '*' and change the letter to 'U', 'L', 'R' or 'D'. You need to carry out as few operations as possible in order to achieve your goal. Your task is to find the minimum number of operations. 

For example, given a grid of [expression] columns:

[expression]
[expression]



the goal is to get from [expression].  

Function Description  

Complete the coinOnTheTable function in the editor below.  It should return an integer that represents the minimum operations to achieve the goal, or [expression] if it is not possible.  

coinOnTheTable has the following parameters:  


m: an integer, the number of columns on the board  
k: an integer, the maximum time to reach the goal  
board: an array of strings where each string represents a row of the board  

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <string>
#include <cstring>
using namespace std;

int m,n;
char s[55][55];
int dp[2][55][55];
int last,now;

bool valid(int x,int y) {
	return (x>=0) && (x<n) && (y>=0) && (y<m) && (dp[last][x][y]>=0);
}

int haha(int x,int y,char c) {
	return (s[x][y]==c)?0:1;
}

void better(int &x,int y) {
	if ((x<0) || (x>y)) {
		x=y;
	}
}

int main() {
int i,j,t,x,y,ans;
	scanf("%d%d%d",&n,&m,&t);
	memset(dp[0],0xff,sizeof(dp[0]));
	for (i=0;i<n;++i) {
		scanf("%s",s[i]);
	}
	dp[0][0][0]=0;
	ans=(s[0][0]=='*')?0:(-1);
	for (last=0;t;--t) {
		memset(dp[now=1^last],0xff,sizeof(dp[now]));
		for (i=0;i<n;++i) {
			for (j=0;j<m;++j) {
				x=i-1;
				y=j;
				if (valid(x,y)) {
					better(dp[now][i][j],dp[last][x][y]+haha(x,y,'D'));
				}
				x=i+1;
				if (valid(x,y)) {
					better(dp[now][i][j],dp[last][x][y]+haha(x,y,'U'));
				}
				x=i;
				y=j-1;
				if (valid(x,y)) {
					better(dp[now][i][j],dp[last][x][y]+haha(x,y,'R'));
				}
				y=j+1;
				if (valid(x,y)) {
					better(dp[now][i][j],dp[last][x][y]+haha(x,y,'L'));
				}
				if ((s[i][j]=='*') && (dp[now][i][j]>=0)) {
					better(ans,dp[now][i][j]);
				}
			}
		}
		last=now;
	}
	printf("%d\n",ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.304
medium
----------
PROBLEM STATEMENT:
A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.  Longest common subsequence (LCS) of 2 sequences is a subsequence, with maximal length, which is common to both the sequences. 

Given two sequences of integers, [expression], find the longest common subsequence and print it as a line of space-separated integers. If there are multiple common subsequences with the same maximum length, print any one of them.

In case multiple solutions exist, print any of them. It is guaranteed that at least one non-empty common subsequence will exist.    

Recommended References  

This Youtube video tutorial explains the problem and its solution quite well.  

   

Function Description  

Complete the longestCommonSubsequence function in the editor below.  It should return an integer array of a longest common subsequence.  

longestCommonSubsequence has the following parameter(s):  


a: an array of integers  
b: an array of integers

----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <ctime>
#include <list>
#include <string>
#include <map>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <iostream>
#include <bitset>
#include <sstream>
#include <iterator>
#include <numeric>

using namespace std;

#define F_TO_R          freopen("input.txt", "r" , stdin)
#define _pair(x,y)      make_pair(x,y)
#define INF             (1<<30)
#define sf              scanf
#define pf              printf
#define mem(a,b)        memset(a, b, sizeof(a))
#define fs              first
#define se              second
#define MAX             1010
#define MAXR            205
#define MAXC            5
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int u_int;
const double PI = 2.0 * acos(0.0);
const double eps = 1e-11;
const int _mod = 1000000;
const int save[10][4] = {{0},{0},{6,2,4,8},{1,3,9,7},{6,4},{0},{0},{1,7,9,3},{6,8,4,2},{1,9}};
int todigit(char c) { return ( isdigit(c) ) ?( c - 48 ) : c ; }
int toint(string s) { int r = 0; istringstream sin(s); sin >> r; return r; }
ll tolong(string s) {  ll r = 0; istringstream sin(s); sin >> r; return r; }
double todouble(string s) { double r = 0.0 ; istringstream sin(s); sin >> r; return r; }
bool bit_check(int k , int p){ return (bool)(k&(1 << p)); }
int bit_set(int k , int p) { return k = (k|(1 << p));}
template < class T > string toString(T n) { ostringstream ost; ost << n; ost.flush() ; return ost.str(); }
template < class T > T Abs(T x) { return x > 0 ? x : -x;}
template < class T > T power(T N , T P) { return (P == 0) ?  1 : N * power(N , P - 1); }
template < class T > inline T max_(T a,T b) {return a > b ? a : b ;}
template < class T > inline T min_(T a,T b) {return a < b ? a : b ;}
template < class T > inline T gcd(T a,T b) {if(a < 0) return gcd(-a,b); if(b < 0)return gcd(a,-b); return (b == 0) ? a : gcd(b ,a % b);}
template < class T > inline T lcm(T a,T b) {if(a < 0) return lcm(-a,b); if(b < 0)return lcm(a,-b); return a * (b / gcd(a , b));}

//ll big_mod(ll n , ll  p , ll m)
//{
//  ll sum;
//  if(!p) return 1;
//  if(p % 2 == 0) { sum = big_mod(n  , p / 2 , m); return ((sum % m ) *(sum % m)) % m; }
//  else return (( n % m) * (big_mod( n , p - 1 , m) % m ))% m;
//}

//bool siv[MAX];
//int prime[MAX];
//void is_prime()
//{
//    int k = 0;
//    int n = sqrt(MAX);
//    prime[k++] = 2;
//    for(int i = 3 ; i < n ; i += 2) if(!siv[i]) for(int j = i * i ; j < MAX ; j += (2 * i)) siv[j] = true;
//    for(int i = 3 ; i < MAX ; i += 2) if(!siv[i]) prime[k++] = i;
//}
//
//int one[]={1,0,-1,0}; //4 Direction
//int two[]={0,1,0,-1}; //4 Direction
//int two[]={0,1,1,1,0,-1,-1,-1};//8 direction
//int one[]={2,1,-1,-2,-2,-1,1,2}; //Knight Direction
//int two[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction

///***************************************  END  **********************************************///


int DP[1010][1010];
int one[1010];
int two[1010];
vector < int > ans;
void printLCS(int a , int b);
int main()
{
    int n , m;
    sf("%d %d", &n , &m);
    for(int i = 0 ; i < n ; ++i) sf("%d", &one[i]);
    for(int i = 0 ; i < m ; ++i) sf("%d", &two[i]);
    mem(DP , 0);
    for(int i = 1 ; i <= n ; ++i)
    {
        for(int j = 1 ; j <= m ; ++j)
        {
            if(one[i - 1] == two[j - 1]) DP[i][j] = DP[i - 1][j - 1] + 1;
            else DP[i][j] = max_(DP[i - 1][j] , DP[i][j - 1]);
        }
    }
   // pf("%d", DP[n][m]);
    printLCS(n , m);
    int len = ans.size();
    pf("%d", ans[len - 1]);
    for(int i = len - 2 ; i >= 0 ; --i) pf(" %d", ans[i]);
    return 0;
}

void printLCS(int a , int b)
{
    if(a == 0 || b == 0) return ;
    if(one[a - 1] == two[b - 1])
    {
        ans.push_back(one[a - 1]);
        printLCS(a - 1 , b - 1);
    }
    else if(DP[a][b] == DP[a - 1][b]) printLCS(a - 1 , b);
    else printLCS(a , b - 1);
}
----------
====================
----------
ALGORITHMS.305
medium
----------
PROBLEM STATEMENT:
Shaka and his brother have created a boring game which is played like this:  

They take a word composed of lowercase English letters and try to get the maximum possible score by building exactly 2 palindromic subsequences. The score obtained is the product of the length of these 2 subsequences.

Let's say [expression], then the following statements hold true: 
[expression], 
[expression], & 
[expression]. 
i.e., the positions of the subsequences should not cross over each other. 

Hence the score obtained is the product of lengths of subsequences [expression]. Such subsequences can be numerous for a larger initial word, and hence it becomes harder to find out the maximum possible score. Can you help Shaka and his brother find this out?
----------
TOP SOLUTION:
----------
/*
*/
 
//#pragma comment(linker, "/STACK:16777216")
#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <ctime> 
 
#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
 
#define eps 1e-11
//#define M_PI 3.141592653589793
#define bs1 1000000007ll
#define bs2 1000000009ll
#define P1 173
#define P2 187
#define bsize 256
#define right adsgasgadsg
#define free adsgasdg
 
using namespace std;

string st;
long dp[3050][3050],mpref[3050],msuf[3050];
long n;
long ans;

int main(){
//freopen("lesson.in","r",stdin);
//freopen("lesson.out","w",stdout);
//freopen("C:/input.txt","r",stdin);
//freopen("C:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);
//cin.tie(0);

cin>>st;
n=st.size();
for (int r=0;r<n;r++)
{
 for (int l=r;l>=0;l--)
 {
  if (l==r-1)
  dp[l][r]=(st[l]==st[r]);
  dp[l][r]=max(dp[l][r],n-(n-1));
  dp[l][r]=max(dp[l][r],dp[l+1][r]);
  dp[l][r]=max(dp[l][r],dp[l][r-1]);
  if (st[l]==st[r]&&l<r)
   dp[l][r]=max(dp[l][r],dp[l+1][r-1]+2);
 }
}
/*
for (int i=0;i<n;i++)
{
    for (int j=0;j<n;j++)
     cout<<dp[i][j]<<" ";
    cout<<endl;
}*/

for (int i=0;i<n;i++)
{
 for (int j=0;j<=i;j++)
  mpref[i]=max(mpref[i],dp[j][i]);
 for (int j=i;j<n;j++)
  msuf[i]=max(msuf[i],dp[i][j]);
}

for (int i=1;i<n;i++)
 mpref[i]=max(mpref[i],mpref[i-1]);
for (int i=n-2;i>=0;--i)
 msuf[i]=max(msuf[i],msuf[i+1]);

ans=0;
for (int i=0;i<n;i++)
 ans=max(ans,mpref[i]*msuf[i+1]);
cout<<ans<<endl;


cin.get();cin.get();
return 0;}

----------
====================
----------
ALGORITHMS.306
hard
----------
PROBLEM STATEMENT:
Nikita is making a graph as a birthday gift for her boyfriend, a fellow programmer! She drew an undirected connected graph with [expression] in her notebook.

Each node is shaded in either white or black. We define [expression] to be the number of black nodes. The graph is drawn in such a way that:


No [expression] adjacent nodes have same coloring.
The value of [expression], is minimal.


Nikita's mischievous little brother erased some of the edges and all of the coloring from her graph! As a result, the graph is now decomposed into one or more components. Because you're her best friend, you've decided to help her reconstruct the graph by adding [expression] edges such that the aforementioned graph properties hold true.

Given the decomposed graph, construct and shade a valid connected graph such that the difference [expression] between its shaded nodes is minimal.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
// #include "testlib.h"
using namespace std ;

#define ft first
#define sd second
#define pb push_back
#define all(x) x.begin(),x.end()

#define ll long long int
#define vi vector<int>
#define vii vector<pair<int,int> >
#define pii pair<int,int>
#define vl vector<ll>
#define vll vector<pair<ll,ll> >
#define pll pair<ll,ll>
#define pli pair<ll,int>
#define mp make_pair

#define sc1(x) scanf("%d",&x)
#define sc2(x,y) scanf("%d%d",&x,&y)
#define sc3(x,y,z) scanf("%d%d%d",&x,&y,&z)

#define scll1(x) scanf("%lld",&x)
#define scll2(x,y) scanf("%lld%lld",&x,&y)
#define scll3(x,y,z) scanf("%lld%lld%lld",&x,&y,&z)

#define pr1(x) printf("%d\n",x)
#define pr2(x,y) printf("%d %d\n",x,y)
#define pr3(x,y,z) printf("%d %d %d\n",x,y,z)

#define prll1(x) printf("%lld\n",x)
#define prll2(x,y) printf("%lld %lld\n",x,y)
#define prll3(x,y,z) printf("%lld %lld %lld\n",x,y,z)

#define pr_vec(v) for(int i=0;i<v.size();i++) cout << v[i] << " " ;

#define f_in(st) freopen(st,"r",stdin)
#define f_out(st) freopen(st,"w",stdout)

#define fr(i, a, b) for(i=a; i<=b; i++)
#define fb(i, a, b) for(i=a; i>=b; i--)

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

const int maxn = 1e5 + 10;
const int mod = 1e9 + 7;
const int N=200010;
int w[2];
vector <int> v[N];
int a[N], d[N], p[N], c[N], col[N], sz, ccol[2][N];
bool f[N];
queue<int> q[N];
void dfs(int x,int y){
    f[x]=1;
    w[y]++;
    col[x] = y;
    ccol[y][sz] = x;
    for (int i=0;i<v[x].size();i++)
    if (!f[v[x][i]])
        dfs(v[x][i],(y^1));
    else if( col[v[x][i]] != 1 - y ) 
        assert(0);
}

int main() {
    int n,m;
    scanf("%d%d",&n,&m);
    for (int i=0,x,y;i<m;i++){
        scanf("%d%d",&x,&y);
        v[x].push_back(y);
        v[y].push_back(x);
    }

    int k=0;
    for (int i=1;i<=n;i++) {
        if (!f[i]) {
            w[0] = w[1]=0;
            dfs(i,0);
            c[i] = (w[0] < w[1]);
            k+=abs(w[0]-w[1]);
            a[abs(w[0]-w[1])]++;
            q[abs(w[0]-w[1])].push( i );
        }
    }

    for (int j=1;j<=k;j++) d[j]=N;

    for (int i=1;i<=n;i++)
        if (a[i]) {
            for (int j=0;j+i<=k;j++) {
                if( d[i+j] == N && d[j] != N ) {
                    d[i+j] = d[j] + 1;
                    p[i+j] = j;
                }
            }

            for (int j=1;j<=k;j++) {
                if (d[j]>a[i]) {
                    d[j]=N;
                    p[j]=0;
                } else {
                    d[j]=0;
                }
            }
        }

    int ans=k, v = 0;
    for (int i=0;i<=k;i++) {
        if(d[i]<N) {
            if( ans >= abs(k - 2 * i) ) {
                ans = abs(k - 2 * i);
                v = i;
            }
        }
    }

    memset(f, 0, sizeof f);
    while( v != 0 ) {
        int diff = v - p[v];
        int nd = q[diff].front();
        q[diff].pop();
        sz ++;
        dfs(nd, c[nd]);
        v = p[v];
    }

    for(int i=1; i<=n; i++) {
        if( !f[i] ) {
            sz ++;
            dfs(i, 1 - c[i]);
        }
    }

    int blk, wht, idb, idw;
    blk = wht = idb = idw = -1;
    for(int i=1; i<=sz; i++) {

        if( ccol[0][i] ) {
            blk = ccol[0][i];
            idb = i;
        }

        if( ccol[1][i] ) {
            wht = ccol[1][i];
            idw = i;
        }
    }
    cout << ans << " " << sz - 1 << "\n";
    if( idb != idw ) cout << blk << " " << wht << "\n";
    for(int i=1; i<=sz; i++) {
        if( i != idb && i != idw ) {
            if( ccol[0][i] ) {
                cout << wht << " " << ccol[0][i] << "\n";
            } else {
                cout << blk << " " << ccol[1][i] << "\n";
            }
        }
    }
    return 0;
}
----------
====================
----------
ALGORITHMS.307
medium
----------
PROBLEM STATEMENT:
Given an [expression]. 

A [expression].

For each [expression]).
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }

int main() {
	int T;
	scanf("%d", &T);
	for(int ii = 0; ii < T; ++ ii) {
		static int A[50][50][50];
		int n;
		scanf("%d", &n);
		rep(i, n) rep(j, n) rep(k, n)
			scanf("%d", &A[i][j][k]);
		static int dp[51][51][51], ndp[51][51][51];
		rer(s, 1, n) {
			if(s == 1) {
				rep(i, n) rep(j, n) rep(k, n)
					ndp[i][j][k] = A[i][j][k];
			} else {
				rer(i, 0, n - s) rer(j, 0, n - s) rer(k, 0, n - s) {
					int x = -1;
					rep(di, 2) rep(dj, 2) rep(dk, 2)
						amax(x, dp[i + di][j + dj][k + dk]);
					ndp[i][j][k] = x;
				}
			}
			rer(i, 0, n - s + 1) rer(j, 0, n - s + 1) rer(k, 0, n - s + 1)
				dp[i][j][k] = i <= n - s && j <= n - s && k <= n - s ? ndp[i][j][k] : -1;
			int ans = 0;
			rer(i, 0, n - s) rer(j, 0, n - s) rer(k, 0, n - s)
				ans += dp[i][j][k] == s;
			if(s != 1) putchar(' ');
			printf("%d", ans);
		}
		puts("");
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.308
medium
----------
PROBLEM STATEMENT:
Given a set of [expression] intervals, find the size of its largest possible subset of intervals such that no three intervals in the subset share a common point.
----------
TOP SOLUTION:
----------
#include<iostream>
#include<set>
#include<map>
#include<string>
#include<stdio.h>
#include<sstream>
#include<algorithm>
#include<queue>
#include<cmath>
#include<string.h>
using namespace std ;
#define INF (int)1e9
#define MAXN 1002
int n,s[MAXN],e[MAXN] ;

int bit[1 << 20] ;
int solve1()
{
 int ret = 0 ;
 for(int i = 1;i < 1 << n;i++)
 {
  bit[i] = bit[i / 2] + (i & 1) ;
  int valid = 1,occ[1002] = {} ;
  for(int j = 0;valid && j < n;j++)
   if(i & 1 << j)
    for(int k = s[j];k <= e[j];k++)
     if(++occ[k] > 2)
     {
      valid = 0 ;
      break ;
     }
  if(valid) ret = max(ret,bit[i]) ;
 }
 return ret ;
}

int memo[MAXN][MAXN],memo2[MAXN][MAXN],f[MAXN] ;
int solve2()
{
 if(n <= 2) return n ;

 for(int i = 0;i < n;i++)
  for(int j = i + 1;j < n;j++)
   if(s[i] > s[j])
   {
    swap(s[i],s[j]) ;
    swap(e[i],e[j]) ;
   }

 for(int i = 0;i < n;i++)
 {
  f[i] = n ;
  int low = i,high = n ;
  while(low + 1 < high)
  {
   int mid = low + (high - low) / 2 ;
   if(s[mid] > e[i]) high = mid ;
   else low = mid ;
  }
  f[i] = high ;
 }

 int ret = 2 ;
 memset(memo2,0,sizeof memo2) ;
 memset(memo,0,sizeof memo) ;
 for(int p1 = n - 2;p1 >= 0;p1--)
  for(int p2 = n - 1;p2 > p1;p2--)
  {
   int nstart = max(p2 + 1,min(f[p1],f[p2])) ;
   if(nstart == n) continue ;
   if(e[p1] < e[p2]) memo[p1][p2] = 1 + memo2[p2][nstart] ;
   else memo[p1][p2] = 1 + memo2[p1][nstart] ;
   memo2[p1][p2] = max(memo2[p1][p2 + 1],memo[p1][p2]) ;
   ret = max(ret,2 + memo[p1][p2]) ;
  }
 return ret ;
}

void gen()
{
 n = rand() % 15 + 1 ;
 for(int i = 0;i < n;i++)
 {
  s[i] = rand() % 20 + 1 ;
  e[i] = rand() % 20 + 1 ;
  if(s[i] > e[i]) swap(e[i],s[i]) ;
 }
}

void test()
{
 for(int t = 0;t < 10000;t++)
 {
  gen() ;
  int ret1 = solve1() ;
  int ret2 = solve2() ;
  cout << ret1 << " " << ret2 << endl ;
  if(ret1 != ret2)
  {
   cout << "failed on: " << t << endl ;
   cout << n << endl ;
   for(int i = 0;i < n;i++) cout << s[i] << " " << e[i] << endl ;
   while(1) ;
  }
 }
}

void generate()
{
 char in[] = "in .txt" ;
 for(int test = 0;test < 10;test++)
 {
  in[2] = test + '0' ;
  FILE * fout = fopen(in,"w") ;
  int runs = 100 ;
  fprintf(fout,"%d\n",runs) ;
  for(int t = 0;t < runs;t++)
  {
   int lim ;
   if(test < 2) n = rand() % 10 + 2,lim = rand() % 10 + 1 ;
   else if(test < 5) n = rand() % 100 + 2,lim = rand() % 100 + 1 ;
   else if(test < 8) n = 1000 - rand() % 100,lim = rand() % 1000000000 + 1 ;
   else n = 1000 - rand() % 100,lim = rand() % 1000 + 1 ;
   
   for(int i = 0;i < n;i++)
   {
    s[i] = rand() % lim + 1 ;
    e[i] = rand() % lim + 1 ;
    if(s[i] > e[i]) swap(s[i],e[i]) ;
   }

   fprintf(fout,"%d\n",n) ;
   for(int i = 0;i < n;i++)
   {
    fprintf(fout,"%d %d\n",s[i],e[i]) ;
   }
  }
 }
}

int main()
{
// test() ; return 0 ;
// generate() ; return 0 ;
 
 int runs ;
 scanf("%d",&runs) ;
 while(runs--)
 {
  scanf("%d",&n) ;
  if(n < 1 || n > 1000) while(1) ;
  for(int i = 0;i < n;i++)
  {
   scanf("%d%d",&s[i],&e[i]) ;
   if(s[i] < 1 || e[i] > (int)1e9 || s[i] > e[i]) { cerr << "bad interval" << endl ; while(1) ; }
  }
  int ret = solve2() ;
  printf("%d\n",ret) ;
 }

 return 0 ;
}
----------
====================
----------
ALGORITHMS.309
hard
----------
PROBLEM STATEMENT:
Given a string consisting of the letters [expression], we can perform the following operation: 


Take any two adjacent distinct characters and replace them with the third character. 


Find the shortest string obtainable through applying this operation repeatedly.  

For example, given the string [expression].  

Function Description  

Complete the stringReduction function in the editor below.  It must return an integer that denotes the length of the shortest string obtainable.  

stringReduction has the following parameter: 
- s: a string  
----------
TOP SOLUTION:
----------
/*
 * stringReduction.cpp
 *
 *  Created on: 29-10-2011
 *      Author: Piotr Szczesniak
 */
#include<iostream>
#include<cmath>
#include<algorithm>
#include<vector>
#include<string>
#include<list>
#include<deque>
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<utility>
using namespace std;

int main() {
	string s;
	int T=0, res=0;
	int tab[3];

	cin >> T;

	for (int t = 0; t < T; t++) {
		s.clear();
		tab[0] = 0;
		tab[1] = 0;
		tab[2] = 0;
		res = 0;

		cin >> s;
		for (unsigned int i = 0; i < s.size(); i++) {
			if (s[i] == 'a') tab[0]++;
			else if(s[i] == 'b') tab[1]++;
			else if(s[i] == 'c') tab[2]++;
			else cerr << "dupa!" << endl;
		}

		sort(tab, tab+3);

		while (tab[1] > 0) {
			tab[2]--;
			tab[1]--;
			tab[0]++;
			sort(tab, tab+3);
		}

		cout << tab[2] << endl;
	}


	return 0;
}

----------
====================
----------
ALGORITHMS.310
hard
----------
PROBLEM STATEMENT:
You are given a tree that has N vertices and N-1 edges. Your task is to mark as small number of vertices as possible, such that, the maximum distance between two unmarked vertices is less than or equal to K. Output this value.
Distance between two vertices i and j is defined as the minimum number of edges you have to pass in order to reach vertex i from vertex j.  

Input Format 
The first line of input contains two integers N and K. The next N-1 lines contain two integers (ui,vi) each, where 1 
N is no more than 100. K is less than N.  

Output Format 
Print an integer that denotes the result of the test.

Sample Input:

5 1  
1 2  
1 3  
1 4  
1 5


Sample Output:

3


Sample Input:

5 2  
1 2  
1 3  
1 4  
1 5


Sample Output:

0


Explanation:

In the first case you have to mark at least 3 vertices, and in the second case you don't need to mark any vertices.
----------
TOP SOLUTION:
----------
#include <queue>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <string.h>
#include <limits.h>

using namespace std;

#define rep(i,a,b) for(int i=(a);i<(b);i++)
#define ll long long int
#define ii pair<int,int>
#define Clear(x,val) memset(x,val,sizeof(x))
#define SZ(v) (v).size()
#define maxv 200

vector < vector<int> > vv(200);
int a[maxv][maxv];
int visited[maxv];
int val[maxv];


int main()
{
	for( int i = 0; i < maxv; i++   ) for( int j = 0; j < maxv; j++ ) a[i][j] = 1e9;

	int n , K; cin >> n >> K;
	for( int i = 1;i < n; i++ ) {
		int x , y;
		cin >> x >> y;
		--x;--y;
		a[x][y] = min( a[x][y] , 1 );
		a[y][x] = min( a[y][x] , 1 );		
		vv[x].push_back(y);
		vv[y].push_back(x);
	}
	for( int i = 0; i < n; i++ ) a[i][i] = 0;

	int ans = 0;

	for( int k = 0; k < n; k++ )
		for( int i = 0; i < n; i++ ) 
			for( int j = 0; j < n; j++ )
				a[i][j] = min( a[i][j] , a[i][k]+a[k][j] );





	
	Clear( visited , 0 );Clear( val , 0 );  
	int u = -1;
	for( int i = 0; i < n; i++ ) {
		u = -1;
		for( int j = n-1; j >= 0; j-- ) {		
			if( !visited[j] && ( u<0 || val[j]>val[u] ) )
				u = j;
		}
		
		visited[u] = 1;int tmp = 0;
		for( int i = 0; i < n; i++ ) if( a[u][i] <= K ) {	
			if( visited[i] ) ++tmp;
			else val[i] += 1; 
		}

		ans = max( ans , tmp );

	}
	cout << n-ans << "\n";
	return 0;
}
----------
====================
----------
ALGORITHMS.311
expert
----------
PROBLEM STATEMENT:
Lukas is a Civil Engineer who loves designing road networks to connect [expression]. He can build any number of bidirectional roads as long as the resultant network satisfies these constraints:


It must be possible to reach any city from any other city by traveling along the network of roads.  
No two roads can directly connect the same two cities.   
A road cannot directly connect a city to itself.  


In other words, the roads and cities must form a simple connected labeled graph.

You must answer [expression].
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;
typedef long long num;
typedef vector<num> poly;
const num p=663224321;
 
num pm(num a,num n=p-2,num m=p){
	num r=1;
	for(;n;n>>=1,a=a*a%m)
		if(n&1)r=r*a%m;
	return r;
}
 
struct NTT{
	static const int g=3;
	void go(num *a,size_t n){
		size_t l,b,i,s;
		num d=pm(g,(p-1)/n,p),w,t;
		for(b=n>>1,l=n;b;b>>=1,l>>=1,d=d*d%p)
		for(w=1,s=0;s<b;++s,w=w*d%p)
		for(i=s;i<n;i+=l){
			a[i|b]=(a[i]-(t=a[i|b]))*w%p;
			a[i]=(a[i]+t)%p;
		}
	}
	void back(num *a,size_t n){
		size_t l,b,i,s;
		num d=pm(n,p-2,p),w,t;
		for(i=0;i<n;++i)a[i]=a[i]*d%p;
		for(b=1,l=2;b<n;b<<=1,l<<=1)
		for(d=pm(g,p-1-(p-1)/l,p),w=1,s=0;s<b;++s,w=w*d%p)
		for(i=s;i<n;i+=l){
			t=a[i|b]*w;
			a[i|b]=(a[i]-t)%p;
			a[i]=(a[i]+t)%p;
		}
	}
}ntt;

void sqr(poly& a){
	int n=1,m=a.size();
	for(;n<a.size()*2-1;n<<=1);
	a.resize(n,0);
	ntt.go(&a[0],n);
	for(int i=0;i<n;++i)a[i]=a[i]*a[i]%p;
	ntt.back(&a[0],n);
	a.resize(m*2-1);
}
poly mul(poly a,poly b){
	int n=1,l=a.size()+b.size()-1;
	for(;n<l;n<<=1);
	a.resize(n,0);b.resize(n,0);
	ntt.go(&a[0],n);
	ntt.go(&b[0],n);
	for(int i=0;i<n;++i)a[i]=a[i]*b[i]%p;
	ntt.back(&a[0],n);
	a.resize(l);
	return a;
}
 
poly invM(poly f,int m){
	poly g;int n=1;
	g.push_back(pm(f[0]));
	for(;n<m;){
		n<<=1;
		poly t=g;sqr(t);
		for(auto&x:g)x=(x<<1)%p;
		t=mul(poly(f.begin(),min(f.begin()+n,f.end())),t);
		g.resize(n,0);
		for(int i=0;i<n && i<t.size();++i)g[i]=(g[i]-t[i])%p;
	}
	return poly(g.begin(),g.begin()+m);
}

poly h,g,invG,f;

// comb
#define MAX 300005
#define MOD 663224321
#define ll long long
ll fact[MAX],inverse[MAX],fact_inverse[MAX];

void precalc()
{
	fact[0]=1;
	
	inverse[0]=1;inverse[1]=1;
	
	fact_inverse[0]=1;fact_inverse[1]=1;
	
	for(ll i=1;i<MAX;i++)
		fact[i]=(i*fact[i-1])%MOD;
		
	for(ll i=2;i<MAX;i++)
	{
		inverse[i]=(MOD-((MOD/i) * inverse[MOD % i])%MOD)%MOD;
		fact_inverse[i]=(inverse[i]*fact_inverse[i-1])%MOD;
	}
}
// ENDS

int main(){
	precalc();
	
	int lim=5+(1e5);
	h.resize(lim);g.resize(lim);
	for(int i=0;i<lim;i++){
		h[i]=pm(2,(i*1LL*(i-1))/2);
		h[i]*=fact_inverse[i];
		h[i]%=p;
		
		g[i]=h[i];
		h[i]=i*h[i]%p;
	}
	
	invG=invM(g,lim);
	f=mul(h,invG);
	
	for(int i=1;i<f.size();i++){
		f[i]*=fact[i-1];
		f[i]%=p;
		if(f[i]<0) f[i]+=p;
	}
	
	#define sd(x) scanf("%d",&x)
	int q;sd(q);
	while(q--){
		int n;sd(n);
		printf("%lld\n",f[n]);
	}
}
 
----------
====================
----------
ALGORITHMS.312
hard
----------
PROBLEM STATEMENT:
Superman has been invited to India to celebrate Diwali. Unfortunately, on his arrival he learns that he has been invited mainly to help rescue people from a fire accident that has happened in a posh residential locale of New Delhi, where rescue is proving to be especially difficult. As he reaches the place of the fire, before him there are [expression], which are on fire. Since it is Diwali, some floors of the buildings are empty as the occupants have gone elsewhere for celebrations. In his hurry to start the rescue Superman reaches the top of the building, but realizes that his jumping power is depleted and restricted due to change in his geographical setting.
He soon understands the restrictions of his jumping power, and they are as follows: 


He can use the jumping power any number of times until he reaches the bottom floor, which means he can use the jumping power only until before he reaches the bottom (Ground floor), which means, once he reaches the bottom floor, he cannot move to the top floor again and try to save people. (In one single drop from the top to bottom)
While switching buildings, he loses height [expression] while jumping.


The second restriction is explained below with an example.

Assume [expression].

Given the information about the occupied floors in each of the [expression] buildings, help Superman to determine the maximum number of people he can save in one single drop from the top to the bottom floor with the given restrictions.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;
typedef long long int ll;

const int inf = 1e9, mod = 1e9+7;
const int N = 1905;

int n, H, d, t, mx[N], dp[N][N], ans ,x, h[N][N];

int main(){

	scanf("%d %d %d",&n,&H,&d);

	FOR(i,1,n){
		
		scanf("%d",&t);

		FOR(j,1,t){
			
			scanf("%d",&x);

			h[i][x]++;
			
		}

	}
	
	FOR(j,0,H)
		FOR(i,1,n){

			dp[i][j] = max(dp[i][j-1],mx[j-d]) + h[i][j];
			
			mx[j] = max(mx[j], dp[i][j]);
			
			if(j == H)
				
				ans = max(ans, dp[i][j]);

		}

	cout << ans << endl;

    return 0;
}

----------
====================
----------
ALGORITHMS.313
hard
----------
PROBLEM STATEMENT:
You are given a hexagonal grid consisting of two rows, each row consisting of [expression].  

For example, for [expression]:



(Note that the [expression].)

Your task is to tile this grid with [expression] tiles that look like the following:



As you can see above, there are three possible orientations in which a tile can be placed.

Your goal is to tile the whole grid such that every cell is covered by a tile, and no two tiles occupy the same cell. To add to the woes, certain cells of the hexagonal grid are blackened. No tile must occupy a blackened cell.

Is it possible to tile the grid?

Here's an example. Suppose we want to tile this grid:



Then we can do the tiling as follows:


----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;

char s[2][13];
int n;
bool can(char s[2][13],int x,int y) {
	//printf("x = %d y = %d\n%s\n%s\n",x,y,s[0],s[1]);
	if (y >= n) {
		return can(s, x + 1, 0);
	}
	if (x > 1) {
		return true;
	}
	if (s[x][y] == '1') {
		return can(s, x, y + 1);
	}
	if ((y + 1 < n) && (s[x][y + 1] == '0')) {
		s[x][y] = s[x][y + 1] = '1';
		if (can(s, x, y + 1)) {
			return true;
		}
		s[x][y] = s[x][y + 1] = '0';
	}
	if (x == 0) {
		if (s[1][y] == '0') {
			s[0][y] = s[1][y] = '1';
			if (can(s, x , y + 1)) {
				return true;
			}
			s[0][y] = s[1][y] = '0';
		}
		if ((y)  && (s[1][y - 1] == '0')) {
			s[0][y] = s[1][y - 1] = '1';
			if (can(s, x, y + 1)) {
				return true;
			}
			s[0][y] = s[1][y - 1] = '0';
		}
	}	
	return false;
}
 

int main()  {
int z;
	for (scanf("%d",&z);z;--z) {
		scanf("%d%s%s",&n,s[0],s[1]);
		int sum = 0;
		for (int i = 0; i < n; ++i) {
			sum += s[0][i] - '1';
			sum += s[1][i] - '1';
		}
		puts((((sum & 1) == 0) && can(s, 0, 0))?"YES":"NO");
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.314
hard
----------
PROBLEM STATEMENT:
Queens on Board

You have an N * M chessboard on which some squares are blocked out. In how many ways can you place one or more queens on the board, such that, no two queens attack each other? Two queens attack each other, if one can reach the other by moving horizontally, vertically, or diagonally without passing over any blocked square. At most one queen can be placed on a square. A queen cannot be placed on a blocked square.
----------
TOP SOLUTION:
----------
#include <set>
#include <map>
#include <list>
#include <cmath>
#include <queue>
#include <stack>
#include <cstdio>
#include <string>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <sstream>
#include <iomanip>
#include <iostream>
#include <algorithm>
#include <fstream>
#include <ctime>
#include <deque>
#include <bitset>
#include <cctype>
#include <utility>
#include <cassert>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned int ui;
typedef unsigned long long ull;

#define Rep(i,n) for(int i = 0; i < (n); ++i)
#define Repd(i,n) for(int i = (n)-1; i >= 0; --i)
#define For(i,a,b) for(int i = (a); i <= (b); ++i)
#define Ford(i,a,b) for(int i = (a); i >= (b); --i)
#define Fit(i,v) For(__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++i)
#define Fitd(i,v) For(__typeof((v).rbegin()) i = (v).rbegin(); i != (v).rend(); ++i)
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define sz(a) ((int)(a).size())
#define all(a) (a).begin(), (a).end()
#define ms(a,x) memset(a, x, sizeof(a))

template<class F, class T> T convert(F a, int p = -1) { stringstream ss; if (p >= 0) ss << fixed << setprecision(p); ss << a; T r; ss >> r; return r; }
template<class T> T gcd(T a, T b) { T r; while (b != 0) { r = a % b; a = b; b = r; } return a; }
template<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }
template<class T> T sqr(T x) { return x * x; }
template<class T> T cube(T x) { return x * x * x; }
template<class T> int getbit(T s, int i) { return (s >> i) & 1; }
template<class T> T onbit(T s, int i) { return s | (T(1) << i); }
template<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }
template<class T> int cntbit(T s) { return __builtin_popcount(s); }
const int bfsz = 1 << 16; char bf[bfsz + 5]; int rsz = 0;int ptr = 0;
char gc() { if (rsz <= 0) { ptr = 0; rsz = (int) fread(bf, 1, bfsz, stdin); if (rsz <= 0) return EOF; } --rsz; return bf[ptr++]; }
void ga(char &c) { c = EOF; while (!isalpha(c)) c = gc(); }
int gs(char s[]) { int l = 0; char c = gc(); while (isspace(c)) c = gc(); while (c != EOF && !isspace(c)) { s[l++] = c; c = gc(); } s[l] = '\0'; return l; }
template<class T> bool gi(T &v) {
    v = 0; char c = gc(); while (c != EOF && c != '-' && !isdigit(c)) c = gc(); if (c == EOF) return false; bool neg = c == '-'; if (neg) c = gc();
    while (isdigit(c)) { v = v * 10 + c - '0'; c = gc(); } if (neg) v = -v; return true;
}

typedef pair<int, int> II;

const ld PI = acos(ld(-1.0));
const ld eps = 1e-9;

const int inf = (int)1e9 + 5;
const ll linf = (ll)1e17 + 5;
int dr[8] = {-1, +1, 0, 0, +1, +1, -1, -1};
int dc[8] = {0, 0, +1, -1, -1, +1, -1, +1};
const int mod = 1000000007;

#define maxn 1000005

int n, m;
int f[55][1 << 5][1 << 5][1 << 5];
int nex[3][1 << 5], a[105], b[105];
string s[105];
bool can[1 << 5][1 << 5];

int cal0(int A){
	return A;
}

int cal1(int A, int num){
	int res = 0;
	For(i, 1, num - 1) if(getbit(A, i)) res = onbit(res, i - 1);
	return res;
}

int cal2(int A, int num){
	int res = 0;
	For(i, 0, num - 2) if(getbit(A, i)) res = onbit(res, i + 1);
	return res;
}

void add(int &a, int b){
	a += b;
	if(a >= mod) a -= mod;
}

void solve(){
	cin >> n >> m;
	Rep(mask, (1 << m)){
		nex[0][mask] = mask;
		nex[1][mask] = cal1(mask, m);
		nex[2][mask] = cal2(mask, m);
	}

	ms(can, 0);
	Rep(mask, 1 << m){
		Rep(M, 1 << m) if((mask & M) == M){
			can[mask][M] = 1;
			Rep(i, m) For(j, i + 1, m - 1) if(getbit(M, i) & getbit(M, j)){
				bool ok = false;
				For(k, i, j) if(!getbit(mask, k)) ok = true;
				if(!ok) can[mask][M] = 0;
			}
		}
	}

	ms(f, 0); f[0][0][0][0] = 1;
	Rep(i, n) {
		cin >> s[i];
		a[i] = 0;
		b[i] = 0;
		Rep(j, m) {
			if(s[i][j] == '.') a[i] = onbit(a[i], j);
			else b[i] = onbit(b[i], j);
		}
	}
	Rep(i, n) Rep(mask1, (1 << m)) Rep(mask2, (1 << m)) Rep(mask3, (1 << m)) if(f[i][mask1][mask2][mask3]){
		int M1, M2, M3;
		int mask = (mask1 | mask2 | mask3);
		Rep(m, (1 << m)) if(can[a[i]][m] && (mask & m) == 0){
			M1 = nex[0][(mask1 | m) & a[i]];
			M2 = nex[1][(mask2 | m) & a[i]];
			M3 = nex[2][(mask3 | m) & a[i]];
			add(f[i + 1][M1][M2][M3], f[i][mask1][mask2][mask3]);
		}
	}

	int res = -1;
	Rep(mask1, (1 << m)) Rep(mask2, (1 << m)) Rep(mask3, (1 << m)) {
		add(res, f[n][mask1][mask2][mask3]);
	}
	cout << res << endl;
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
//    freopen("in.txt", "r", stdin);
	int test;
	cin >> test;
	Rep(itest, test){
		solve();
	}

    return 0;
}

----------
====================
----------
ALGORITHMS.315
advanced
----------
PROBLEM STATEMENT:
Shashank loves strings, but he loves palindromic strings the most. He has a list of [expression] such that the following conditions are satisfied:


[expression].
[expression] is a palindromic string, where + denotes the string concatenation operator.


You are given [expression], on a new line.

Note: Two subsequences consisting of the same characters are considered to be different if their characters came from different indices in the original string.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

#define forn(i,n) for (int i = 0; i < int(n); i++)
#define ford(i,n) for (int i = int(n) - 1; i >= 0; i--)
#define fore(i,l,r) for (int i = int(l); i < int(r); i++)
#define all(a) a.begin(), a.end()
#define sz(a) int(a.size())
#define mp make_pair
#define pb push_back
#define ft first
#define sc second
#define x first
#define y second

template<typename X> inline X abs(const X& a) { return a < 0 ? -a : a; }
template<typename X> inline X sqr(const X& a) { return a * a; }

typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;

const int INF = int(1e9);
const li INF64 = li(1e18);
const ld EPS = 1e-9;
const ld PI = acosl(ld(-1));

mt19937 mt(time(NULL));

const int N = 1000 + 13;
int n;
string s[N];
char buf[N];

inline void gen()
{
	n = 50;
	forn (i, n)
	{
		s[i].resize(20);
		forn (j, 20)
			s[i][j] = char(mt() % 2 + 'a');
	}
}

inline bool read()
{
	//gen();
	//return true;
	
	if (scanf ("%d", &n) != 1)
		return false;

	forn (i, n)
	{
		assert(scanf ("%s", buf) == 1);
		
		s[i] = string(buf);
	}
	
	return true;
}

const int MOD = 1000 * 1000 * 1000 + 7;

inline int norm (int val)
{
	if (val >= MOD)
		val -= MOD;
		
	return val;
}

int m;
int poss[N];
char t[N];
int d[N][N][2][2][2];

inline void solve()
{
	m = 0;

	forn (i, n)
		forn (j, sz(s[i]))
		{
			t[m] = s[i][j];
			poss[m++] = i;
		}
		
	memset(d, 0, sizeof d);
	d[0][m - 1][0][0][0] = 1;
	
	int ans = 0;
	
	forn (i, m)
		for(int j = m - 1; j >= i; j--)
			forn(k, 2)
				forn (c1, 2)
					forn (c2, 2)
					{
						int dv = d[i][j][k][c1][c2];
						if (!dv)
							continue;
							
						if (i == j)
						{
							//cerr << 'B' << ' ' << i << ' ' << j << ' ' << k << ' ' << c1 << ' ' << c2 << ' ' << dv << endl;
							ans = norm(ans + dv);
							
							continue;
						}
							
						if (k == 0)
						{
							d[i][j][1][c1][c2] = norm(d[i][j][1][c1][c2] + dv);
							
							if (poss[i + 1] == poss[i] || c1)
							{
								int nc1 = c1;
								if (poss[i + 1] != poss[i])
									nc1 = 0;
									
								d[i + 1][j][0][nc1][c2] = norm(d[i + 1][j][0][nc1][c2] + dv);
							}
						}
						else
						{
							if (poss[j - 1] == poss[j] || c2)
							{
								int nc2 = c2;
								if (poss[j - 1] != poss[j])
									nc2 = 0;
									
								d[i][j - 1][1][c1][nc2] = norm(d[i][j - 1][1][c1][nc2] + dv);
							}
							
							if (t[i] == t[j])
							{
								int nc1, nc2;
								if (poss[i + 1] != poss[i])
									nc1 = 0;
								else
									nc1 = 1;
									
								if (poss[j - 1] != poss[j])
									nc2 = 0;
								else
									nc2 = 1;
									
								if (i + 1 == j)
								{
									//cerr << 'C' << ' ' << i << ' ' << j << ' ' << k << ' ' << c1 << ' ' << c2 << ' ' << dv << endl;
									ans = norm(ans + dv);
								}
								else
								{
									if (poss[i] == poss[j] || poss[i] + 1 == poss[j])
									{
										//cerr << 'A' << ' ' << i << ' ' << j << ' ' << k << ' ' << c1 << ' ' << c2 << ' ' << dv << endl;									
										ans = norm(ans + dv);
									}

									d[i + 1][j - 1][0][nc1][nc2] = norm(d[i + 1][j - 1][0][nc1][nc2] + dv);
								}
							}
						}
					}
					
	cout << ans << endl;
}

int main()
{
#ifdef SU2_PROJ
	assert(freopen("input.txt", "r", stdin));
	assert(freopen("output.txt", "w", stdout));
#endif

	cout << setprecision(25) << fixed;
	cerr << setprecision(10) << fixed;

	srand(int(time(NULL)));
	
	int testCnt;
	assert(scanf ("%d", &testCnt) == 1);

	forn (test, testCnt)
	{
		assert(read());
		solve();
	}

#ifdef SU2_PROJ
	cerr << "TIME: " << clock() << endl;
#endif

	return 0;
}

----------
====================
----------
ALGORITHMS.316
advanced
----------
PROBLEM STATEMENT:
There are N points on an XY plane. In one turn, you can select a set of collinear points on the plane and remove them. Your goal is to remove all the points in the least number of turns. Given the coordinates of the points, calculate two things:


The minimum number of turns (T) needed to remove all the points.
The number of ways to to remove them in T turns. Two ways are considered different if any point is removed in a different turn.

----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */#include<iostream>
#include<set>
#include<map>
#include<string>
#include<stdio.h>
#include<sstream>
#include<algorithm>
#include<queue>
#include<cmath>
#include<string.h>
using namespace std ;
#define MOD 1000000007
#define INF (int)1e9
#define MAXN 20
typedef pair<int,int> P ;

int n,pre[MAXN],fac[MAXN],x[MAXN],y[MAXN] ;
int col[MAXN][MAXN] ;

char bit[1 << MAXN] ;
char good[1 << MAXN] ;
char best[1 << MAXN] ;
char valid[1 << MAXN] ;

char vid,id[1 << MAXN] ;
int memo[1 << MAXN] ;
int solve(int mask)
{
 if(bit[mask] <= 2) return 1 ;
 if(id[mask] == vid) return memo[mask] ;
 if(good[mask]) return pre[bit[mask]] ;
 id[mask] = vid ;

 int j,nmask = mask ;
 for(j = 0;j < n;j++) if(mask & 1 << j)
 {
  nmask ^= 1 << j ;
  break ;
 }

 int ways = 0,can = best[mask] ;
 if(best[nmask] == can - 1) ways = solve(nmask) ;
 for(int i = nmask;i > 0;i = ((i - 1) & nmask))
 {
  int k = i | 1 << j ;
  if(valid[k] && best[mask ^ k] == can - 1)
  {
   ways += solve(mask ^ k) ;
   if(ways >= MOD) ways -= MOD ;
  }
 }
 return memo[mask] = ways ;
}

void generate()
{
 for(int tt = 0;tt < 10;tt++)
 {
  char in[] = "in .txt" ;
  in[2] = tt + '0' ;
  FILE * fout = fopen(in,"w") ;
  
  int runs = 50 ;
  fprintf(fout,"%d\n",runs) ;
  for(int j = 0;j < runs;j++)
  {
   n = rand() % 18 ;
   if(tt == 8) n = 18 ;
   
   char vis[102][102] ;
   memset(vis,0,sizeof vis) ;
   for(int i = 0;i < n;i++)
   {
    if(tt < 3 && j < 15)
    {
     x[i] = rand() % 10 ;
     y[i] = rand() % 10 ;     
    }
    else if(tt < 6 && j < 15)
    {
     x[i] = rand() % 5 ;
     y[i] = rand() % 5 ;
    }
    else if(tt < 10 && j < 15)
    {
     x[i] = i ;
     y[i] = i + (rand() % 5 - 2) ;
     if(y[i] < 0) y[i] = i ;
    }
    else
    {
     x[i] = rand() % 100 + 1 ;
     y[i] = rand() % 100 + 1 ;
    }
    
    if(vis[x[i]][y[i]]) { i-- ; continue ; }
    vis[x[i]][y[i]] = 1 ;
   }


   fprintf(fout,"%d\n",n) ;
   for(int i = 0;i < n;i++) fprintf(fout,"%d %d\n",x[i],y[i]) ;
  }
  fclose(fout) ;
 }
}

int main()
{
 fac[0] = 1 ;
 for(int i = 1;i < MAXN;i++) fac[i] = 1LL * i * fac[i - 1] % MOD ;
 for(int i = 1;i < 1 << MAXN;i++) bit[i] = bit[i >> 1] + (i & 1) ;
 pre[0] = pre[1] = 1 ;
 for(int i = 2;i < MAXN;i++)
 {
  pre[i] = 1LL * pre[i - 2] * (i - 1) % MOD ;
  if(i % 2 == 1) pre[i] += pre[i - 1] ;
  pre[i] %= MOD ;
 }

// generate() ; return 0 ;

 int runs ; 
 scanf("%d",&runs) ;
 while(runs--)
 {
  scanf("%d",&n) ;
  for(int i = 0;i < n;i++) scanf("%d%d",&x[i],&y[i]) ;
  
  memset(col,0,sizeof col) ;
  for(int k1 = 0;k1 < n;k1++)
   for(int k2 = 0;k2 < n;k2++)
   {
    for(int j = 0;j < n;j++)
    {
     int area = x[j] * (y[k1] - y[k2]) + x[k1] * (y[k2] - y[j]) + x[k2] * (y[j] - y[k1]) ;
     if(area == 0) col[k1][k2] |= 1 << j ;
    }
   }
  
  for(int i = 0;i < 1 << n;i++)
  {
   if(bit[i] <= 2) { valid[i] = true ; continue ; }
   for(int j = 0;j < n;j++) if(i & 1 << j)
   {
    int k1 = -1 ;
    for(int k = j + 1;k < n;k++) if(i & 1 << k) { k1 = k ; break ; }
    if((col[j][k1] | i) == col[j][k1]) valid[i] = true ;
    else valid[i] = false ;
    break ;
   }
  }
  
  best[0] = 0 ;
  for(int i = 1;i < 1 << n;i++)
  {
   if(bit[i] == 1) { best[i] = 1 ; continue ; }
   int j;
   for(j = 0;j < n;j++) if(i & 1 << j) break ;
   
   int cret = n ;
   for(int k = j + 1;k < n;k++)
    if(i & 1 << k)
     cret = min(cret,1 + best[i & ~col[j][k]]) ;
   best[i] = cret ;
  }
  
  for(int i = 0;i < 1 << n;i++)
  {
   good[i] = 1 ;
   if(bit[i] <= 2) continue ;
   int j;
   for(j = 0;j < n;j++) if(i & 1 << j) break ;
   if(!good[i ^ 1 << j]) { good[i] = 0 ; continue ; }
   
   for(int k = j + 1;k < n;k++)
    if(i & 1 << k)
     if(bit[i & col[j][k]] > 2)
      good[i] = 0 ;
  }
  
  int tot = best[(1 << n) - 1] ;
  vid++ ;
  int ret = solve((1 << n) - 1) ;
  ret = 1LL * ret * fac[tot] % MOD ;
  printf("%d %d\n",tot,ret) ;
 }
 
 return 0 ;
}

----------
====================
----------
ALGORITHMS.317
hard
----------
PROBLEM STATEMENT:
There are [expression]. 
Each bulb [expression] will be toggled(off-on, on-off). 

Given [expression] bulbs if they're all on initially.
----------
TOP SOLUTION:
----------
/*
*/

#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 350

using namespace std;

const int INF = 1e9;
const int N = 200031;

int n, k, ar[N];

long long solve(int start)
{
	long long res = 0;
	for (int i = start; i <= n; i += 2 * k + 1)
	{
		res += ar[i];
		if (i + k + 1 <= n&&i + k * 2 + 1 > n)
			return 1e18;
	}
	return res;
}

bool good_mask(int mask)
{
	int ar[25];

	for (int i = 0; i < n; i++)
	{
		ar[i] = 1;
	}
	for (int i = 0; i < n; i++)
	{
		if (mask&(1 << i))
		{
			for (int j = i - k; j <= i + k; j++)
			{
				if (j >= 0 && j < n)
					ar[j] ^= 1;
			}
		}
	}
	for (int i = 0; i < n; i++)
	{
		if (ar[i])
			return 0;
	}
	return 1;
}

int ans_mask;

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);

	while (true)
	{
		cin >> n >> k;
		for (int i = 1; i <= n; i++)
		{
			cin >> ar[i];
			//ar[i] = rand() % 10;
		}

		long long ans = 1e18;

		/*for (int mask = 0; mask < (1 << n); mask++)
		{
		if (good_mask(mask))
		{
		int here = 0;
		for (int i = 0; i < n; i++)
		{
		if (mask&(1 << i))
		here += ar[i + 1];
		}
		if (here < ans)
		ans = min(ans, 0ll + here),
		ans_mask = mask;
		}
		}*/
		long long ans2 = 1e18;

		for (int F = 1; F <= k + 1&&F<=n; F++)
		{
			ans2 = min(ans2, solve(F));
		}

		/*if (ans != ans2)
		{
		cout << "!" << endl;
		for (int i = 1; i <= n; i++)
		{
		cout << ar[i] << " ";
		}
		cout << endl;
		cout << ans << " " << ans2 << " " << ans_mask << endl;
		while (true);
		}

		else
		cout << "OK" << endl;*/

		cout << ans2 << endl;
		return 0;
	}
	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.318
hard
----------
PROBLEM STATEMENT:
Capeta is working part-time for an animal shipping company. He needs to pick up animals from various zoos and drop them to other zoos. The company ships four kinds of animals: elephants, dogs, cats, and mice.

There are [expression] where Capeta needs to deliver it to. 



Capeta is given a truck with a huge capacity where [expression] animals can easily fit. He is also given additional instructions:


He must visit the zoos in increasing order. He also cannot skip zoos. 
Dogs are scared of elephants, so he is not allowed to bring them together at the same time. 
Cats are scared of dogs, so he is not allowed to bring them together at the same time. 
Mice are scared of cats, so he is not allowed to bring them together at the same time. 
Elephants are scared of mice, so he is not allowed to bring them together at the same time. 


Also, loading and unloading animals are complicated, so once an animal is loaded onto the truck, that animal will only be unloaded at its destination. 

Because of these reasons, Capeta might not be able to transport all animals. He will need to ignore some animals. Which ones? The company decided to leave that decision for Capeta. He is asked to prepare a report and present it at a board meeting of the company.

Capeta needs to report the minimum number of zoos that must be reached so that she is able to transport [expression]. 

Complete the function minimumZooNumbers and return an integer array where the [expression] animals. 

He is good at driving, but not so much at planning. Hence, he needs your help.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define f first
#define s second
#define mp make_pair
#define pb push_back
#define lp(i,a,n) for(int i=a;i<=n;++i)
#define lpd(i,a,n) for(int i=a;i>=n;--i)
#define mem(a,b) memset(a,b,sizeof a)
#define all(v) v.begin(),v.end()
#define println(a) cout <<(a) <<endl
#define sz(x) ((int)(x).size())
#define readi(x) scanf("%d",&x)
#define read2i(x,y) scanf("%d%d",&x,&y)
#define read3i(x,y,z) scanf("%d%d%d",&x,&y,&z)
#define mod 1000000007
#define eps 1e-8
#define infi 1000000000
#define infll 1000000000000000000ll
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vll;
typedef set<int> si;
typedef map<int,int> mii;

const int N = 50002;
int t,m,n,dp[N][2];
int tree[4*N][2],lazy[4*N][2];
int type[N],s[N],d[N];
vvi g(N);

void propagate(int i, int j, bool leaf){
    tree[i][j] += lazy[i][j];
    if(!leaf){
        lazy[2*i][j] += lazy[i][j];
        lazy[2*i+1][j] += lazy[i][j];
    }
    lazy[i][j] = 0;
}

int query(int i, int start, int end, int l, int r, int j){
    propagate(i, j, start == end);
    if(l <= start && r >= end) return tree[i][j];
    if(r < start || l > end) return 0;
    int mid = (start+end)/2;
    return max(query(2*i,start,mid,l,r,j), query(2*i+1,mid+1,end,l,r,j));
}

void update(int i, int start, int end, int l, int r, int j, int v){
    propagate(i, j, start == end);
    if(l <= start && r >= end){
        lazy[i][j] += v;
        propagate(i, j, start == end);
        return;
    }
    if(r < start || l > end) return;

    int mid = (start+end)/2;
    update(2*i, start, mid, l, r, j, v);
    update(2*i+1, mid+1, end, l, r, j, v);

    tree[i][j] = max(tree[2*i][j], tree[2*i+1][j]);
}

int main(){
    readi(t);
    while(t--){
        read2i(m,n);
        lp(i,1,n){
            char c;
            scanf(" %c", &c);
            type[i] = c == 'D' or c == 'M' ? 0 : 1;
        }
        lp(i,1,n) readi(s[i]);
        lp(i,1,n) readi(d[i]), g[d[i]].pb(i);

        lp(i,1,m){
            for(int idx : g[i]) if(s[idx] < i) update(1,1,m, 1, s[idx], !type[idx], 1);
            dp[i][0] = query(1,1,m, 1, i, 1);
            dp[i][1] = query(1,1,m, 1, i, 0);
            update(1,1,m, i, i, 0, dp[i][0]);
            update(1,1,m, i, i, 1, dp[i][1]);
        }

        vi ans;
        lp(i,1,m) ans.pb(max(dp[i][0], dp[i][1]));
        lp(i,1,n){
            int x = lower_bound(all(ans), i) - ans.begin() + 1;
            if(x == m+1) x = -1;
            printf("%d ", x);
        }
        puts("");

        g.clear();
        g.resize(N);
        mem(tree, 0);
        mem(lazy, 0);
    }
}

/*
freopen("input.txt","r",stdin);
freopen("output.txt","w",stdout);
*/

----------
====================
----------
ALGORITHMS.319
medium
----------
PROBLEM STATEMENT:
It is the Indian version of the famous heist “The Italian Job”. N robbers have already broken into the National Museum and are just about to get inside the main vault which is full of jewels. They were lucky that just as they broke into the museum, the guard was leaving the museum for exactly G minutes. But there are other problems too. The main vault has heat sensors that if at any moment of time there are more than two people present in the vault, the alarm goes off.  

To collect the jewels, the ith robber needs to be inside the vault for exactly A[i] minutes, 0 , in one continuous stretch. As guard will return after G minutes, they have to finish their tasks within G minutes. The robbers want to know if there exists any arrangement such that demands of each robber is satisfied and also they are not caught?

Gotchas 
If a robber goes inside the vault at a time "X" and at the same time another robber comes out, it's equivalent to saying they were never in the vault at the same time. 
Similarly, when the guard gets inside vault at time G and a robber comes out exactly at time G, the guard will not be able see the robber.
----------
TOP SOLUTION:
----------
#include <stdio.h>
#include <string.h>

#define NMAX 101
#define VMAX 10001

int A[NMAX];
char ok[VMAX];
int N, G, i, j, sum;

int main() {
	int T;
	scanf("%d", &T);

	while (T--) {
		scanf("%d %d", &N, &G);
		for (sum = 0, i = 1; i <= N; i++) {
			scanf("%d", &(A[i]));
			sum += A[i];
		}

		memset(ok, 0, sizeof(ok));
		ok[0] = 1;
		for (i = 1; i <= N; i++)
			for (j = VMAX - 1 - A[i]; j >= 0; j--)
				if (ok[j]) ok[j + A[i]] = 1;

		for (i = 0; i < VMAX; i++)
			if (ok[i] && i <= G && (sum - i) <= G) {
				printf("YES\n");
				break;
			}

		if (i == VMAX)
			printf("NO\n");
	}

	return 0;
}

----------
====================
----------
ALGORITHMS.320
advanced
----------
PROBLEM STATEMENT:
There are [expression] variable. 

Your task is to assign non-negative numbers smaller than [expression].
----------
TOP SOLUTION:
----------
#include <cstdlib>
#include <cctype>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <fstream>
#include <numeric>
#include <iomanip>
#include <bitset>
#include <list>
#include <stdexcept>
#include <functional>
#include <utility>
#include <ctime>
#include <complex>
using namespace std;

// begin insert defines
#define two(x) (1LL<<(x))
#define forE(elem,v)  for(__typeof__(v.begin()) _it = v.begin(); _it != v.end();++_it) for(int _once=1, _done=0; _once; (!_done) ? (_it=v.end(), --_it) :_it ) for(__typeof__(*_it) & elem = * _it; _once && !(_once=0); _done=1)
#define Rep(i,n) for(int n_ = (n), i = 0; i< n_; ++i)

// end insert defines

const int N = 13, B = 1 << 13, M = 1007, L = 10;

vector<int> lnk[N];
int ls[B], f[L][B];

void madd(int &a, int b)
{
  a += b;
  if (a >= M) a -= M;
}

int dp(int lv, int s)
{
  if (lv >= 10) return !s;
  int &ret = f[lv][s];
  if (ret != -1) return ret;
  ret = 0;
  for (int subset = s; subset > 0; subset = (subset - 1) & s) {
    if (!(ls[subset] & (~s))) {
      madd(ret, dp(lv + 1, s ^ subset));
    }
  }
  madd(ret, dp(lv + 1, s));
  return ret;
}

int n, m;

int main(int argc, char *argv[])
{
  cin >> n >> m;
  Rep(i, n) lnk[i].clear();
  Rep(i, m) {
    int x, y;
    cin >> x >> y;
    lnk[x].push_back(y);
  }
  Rep(i, two(n)) {
    ls[i] = 0;
    Rep(j, n) if (two(j) & i) forE(v, lnk[j]) ls[i] |= two(v);
  }
  memset(f, -1, sizeof(f));
  cout << dp(0, two(n) - 1) << endl;
  return 0;
}

----------
====================
----------
ALGORITHMS.321
hard
----------
PROBLEM STATEMENT:
Ma5termind is crazy about Action Games. He just bought a new one and got down to play it. Ma5termind usually finishes all the levels of a game very fast. But, This time however he got stuck at the very first level of this new game. Can you help him play this game.  

To finish the game, Ma5termind has to cross [expression]. To knock down an enemy, Ma5termind needs to shoot him with one or multiple bullets whose collective count is equal to the power of the enemy. If Ma5termind manages to knock down any one enemy at a level, the rest of them run away and the level is cleared.   

Here comes the challenging part of the game. 
Ma5termind acquires all the bullets of an enemy once he has knocked him down. Ma5termind can use the bullets acquired after killing an enemy at [expression] level.  

However, the bullets Ma5termind carried before the start of the game can be taken forward and can be used to kill more enemies.  

Now, Ma5termind has to guess the minimum number of bullets he must have before the start of the game so that he clears all the [expression] levels successfully.  

NOTE  


Bullets carried before the start of the game can be used to kill an enemy at any level.  
One bullet decreases the power of an enemy by 1 Unit.  
For better understanding of the problem look at the sample testcases.  

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define MX 105
#define INF 100000000
using namespace std;

int val[MX][1005], N, M;
vector <int> P[MX], B[MX];

int calc(int n, int b) {
	int &ret = val[n][b];
	if (ret != -1) return ret;
	if (n == N) return ret = 0;
	ret = INF;
	for (int i = 0; i < M; i++) ret = min(ret, max(P[n][i] - b, 0)  + calc(n + 1, B[n][i]));
	return ret;
}

int main() {
	int T, i, j, k;
	for (scanf("%d", &T); T--; ) {
		scanf("%d%d", &N, &M);
		memset(val, -1, sizeof val);
		for (i = 0; i < N; i++) {
			P[i].clear();
			B[i].clear();
			P[i].resize(M + 1);
			B[i].resize(M + 1);
		}
		for (i = 0; i < N; i++) for (j = 0; j < M; j++) scanf("%d", &P[i][j]);
		for (i = 0; i < N; i++) for (j = 0; j < M; j++) scanf("%d", &B[i][j]);
		printf("%d\n", calc(0, 0));
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.322
hard
----------
PROBLEM STATEMENT:
Logan and Veronica live in Neptune, which has [expression].

Logan and Veronica are looking for clues and need to find the number of different paths of length [expression] edge in the path. Two paths are different if the binary sequences characterizing these paths are distinct. Note that they may need to visit the same house several times or use the same road several times to find all possible paths.

Given a map of Neptune, help Logan and Veronica find and print the number of different paths of length [expression] to the other houses in Neptune.
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
ALGORITHMS.323
hard
----------
PROBLEM STATEMENT:
Byteland has [expression] or more connected roads. It is guaranteed that there is a path from any city to any other city.

Steven is a road maintenance worker in Byteland. He is required to maintain exactly [expression] roads). Steven can start his workday in any city and, once he has finished maintaining a path, teleport to his next starting city.

Given [expression].
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }


template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
};
typedef ModInt<1000000007> mint;

int M;
vector<vector<int> > g;
vector<mint> memo;
mint rec(int i, int j, int p, int d1s, int m) {
	if(d1s > M)
		return mint();
	if(j == g[i].size())
		return m == 0 ? 1 : 0;
	if(g[i][j] == p)
		return rec(i, j + 1, p, d1s, m);
	int c = g[i][j];
	mint &r = memo[(c * (M + 1) + d1s) * (M + 1) + m];
	if(r.x != -1)
		return r;
	r = mint();
	rer(n, 0, m) {
		r +=
			rec(c, 0, i, 0, n) *
			rec(i, j + 1, p, d1s, m - n);
	}
	rer(n, 0, m - 1) {
		r +=
			rec(c, 0, i, 1, n) *
			rec(i, j + 1, p, d1s + 1, m - 1 - n);
	}
	if(d1s > 0) rer(n, 0, m) {
		r +=
			rec(c, 0, i, 1, n) *
			rec(i, j + 1, p, d1s - 1, m - n) *
			d1s;
	}
	return r;
}

int main() {
	int N;
	while(~scanf("%d%d", &N, &M)) {
		g.assign(N, vi());
		for(int i = 0; i < N - 1; ++ i) {
			int u, v;
			scanf("%d%d", &u, &v), -- u, -- v;
			g[u].push_back(v);
			g[v].push_back(u);
		}
		mint undef; undef.x = -1;
		memo.assign(N * (M + 1) * (M + 1), undef);
		mint ans = rec(0, 0, -1, 0, M);
		printf("%d\n", ans.get());
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.324
advanced
----------
PROBLEM STATEMENT:
ADZEN is a popular advertising firm in your city that owns all [expression], ADZEN must remove either the middle billboard, the first two billboards, the last two billboards or the first and last billboard.

Being a for-profit company, ADZEN wants to lose as little advertising revenue as possible when removing the billboards. They want to comply with the new ordinance in such a way that the remaining billboards maximize their total revenues (i.e., the sum of  revenues generated by the billboards left standing on Main street).

Given [expression] billboards that can be removed but cannot be reordered in any way.  

For example, if there are [expression].  

Function Description  

Complete the billboards function in the editor below.  It should return an integer that represents the maximum revenue that can be generated under the rules.  

billboards has the following parameter(s):  


k: an integer that represents the longest contiguous group of billboards allowed  
revenue: an integer array where each element represents the revenue potential for a billboard at that index  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <list>
const int maxn = 100001;
long long mindec[maxn];

long long answer;

int main(){
        int n,k;
        std::cin>>n>>k;
        std::list<int> prev;
        mindec[0] = 0;
        prev.push_back(0);
        for (int i=1; i<=n; ++i){
                long long v;
                std::cin>>v;
                answer += v;
                if (prev.front() < i-k-1) prev.pop_front();
                mindec[i] = v + mindec[prev.front()];
                while (! prev.empty() && mindec[prev.back()] >= mindec[i]) prev.pop_back();
                prev.push_back(i);
        }
        if (prev.front() < n-k) prev.pop_front();
        std::cout<<answer-mindec[prev.front()]<<std::endl;
}

----------
====================
----------
ALGORITHMS.325
hard
----------
PROBLEM STATEMENT:
You are given a string, [expression], consisting of lowercase English letters.

A string is beautiful with respect to [expression] characters.

Find and print the number of different strings that are beautiful with respect to [expression].
----------
TOP SOLUTION:
----------
/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 512

const int N = 1031;

using namespace std;

string st;
int naive(string st)
{
	set<string> res;
	for (int i = 0; i < st.size(); i++)
	{
		for (int j = i + 1; j < st.size(); j++)
		{
			string temp = "";
			for (int q = 0; q < st.size(); q++)
			{
				if (q != i&&q != j)
					temp += st[q];
			}
			res.insert(temp);
		}
	}

	set<string>::iterator it;
	/*for (it = res.begin(); it != res.end(); it++)
	{
		cout << *it << endl;
	}*/
	return res.size();
}

long long smart(string st)
{
	int cnt = 0;
	vector<int> v;
	long long ans = 0;
	for (int i = 0; i < st.size(); i++)
	{
		if (i == 0 || st[i] == st[i - 1])
			++cnt;
		else
		{
			v.push_back(cnt);
			cnt = 1;
		}
	}
	v.push_back(cnt);
	for (int i = 0; i < v.size(); i++)
	{
		if (v[i]>1)
			++ans;
	}

	for (int i = 1; i +1< st.size(); i++)
	{
		if (st[i - 1] == st[i + 1] && st[i] != st[i - 1])
			--ans;
	}
	ans += v.size() * 1ll * (v.size() - 1) / 2;
	return ans;
}

int main(){
//	freopen("hospital.in","r",stdin);
//	freopen("hospital.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);
	
	cin >> st;
//	cout << naive(st) << endl;

	cout << smart(st) << endl;
	cin.get(); cin.get();
	return 0;
}
----------
====================
----------
ALGORITHMS.326
hard
----------
PROBLEM STATEMENT:
There is a huge blanket on your bed but unfortunately it has N stains. You cover them using 
a single, rectangular silk cloth. The silk is expensive, which is why the rectangular piece needs to have the least area as possible. You love this blanket and decide to minimize the area covering the  stains. You buy some cleaning liquid to remove the stains but sadly it isn't enough to clean all of them. You can just remove exactly K stains. The rest of the stains need to be covered using a single, rectangular fragment of silk cloth.

Let X denote the area of the smallest possible silk cloth that may cover all the stains originally. You need to find the number of different ways in which you may remove K stains so that the remaining N-K stains can be covered with silk of area strictly less than X (We are looking for any configuration that will reduce the cost).

Assume that each stain is a point and that the rectangle is aligned parallel to the axes.  
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

const int MOD = 1000000007, MAXN = 1005;

int binom[MAXN][MAXN];

int N, K;
int X[MAXN], Y[MAXN];
int Xmin, Xmax, Ymin, Ymax;
pair<int, int> dude[4];

inline int calc(vector<pair<int, int> > vec) {
	int num = 0;
	for(int i = 0 ; i < N ; i++) {
		for(int j = 0 ; j < (int)vec.size() ; j++) {
			if (vec[j].first == 0 && X[i] == vec[j].second) {
				num++;
				break;
			}	else if (vec[j].first == 1 && Y[i] == vec[j].second) {
				num++;
				break;
			}
		}
	}
	if (num > K) {
		return 0;
	}	else {
		return binom[N - num][K - num];
	}
}

int main() {
	scanf("%d %d", &N, &K);
	binom[0][0] = 1;
	for(int i = 1 ; i <= N ; i++) {
		binom[i][0] = 1;
		for(int j = 1 ; j <= i ; j++) {
			binom[i][j] = (binom[i - 1][j] + binom[i - 1][j - 1]) % MOD;
		}
	}
	
	for(int i = 0 ; i < N ; i++) {
		scanf("%d %d", &X[i], &Y[i]);
	}
	Xmin = X[0];
	Xmax = X[0];
	Ymin = Y[0];
	Ymax = Y[1];
	for(int i = 1 ; i < N ; i++) {
		Xmin = min(Xmin, X[i]);
		Xmax = max(Xmax, X[i]);
		Ymin = min(Ymin, Y[i]);
		Ymax = max(Ymax, Y[i]);
	}
	dude[0] = make_pair(0, Xmin);
	dude[1] = make_pair(0, Xmax);
	dude[2] = make_pair(1, Ymin);
	dude[3] = make_pair(1, Ymax);
	int ans = 0;
	for(int mask = 1 ; mask < 16 ; mask++) {
		int sgn = __builtin_popcount(mask);
		vector<pair<int,int> > v;
		for(int i = 0 ; i < 4 ; i++) {
			if ((mask >> i) & 1) {
				v.push_back(dude[i]);
			}
		}
		if (sgn & 1) {
			ans = (ans + calc(v)) % MOD;
		}	else {
			ans = (ans - calc(v)) % MOD;
		}
	}
	ans = (ans + MOD) % MOD;
	ans = (ans + MOD) % MOD;
	printf("%d\n", ans);
	return 0;
}

----------
====================
----------
ALGORITHMS.327
hard
----------
PROBLEM STATEMENT:
Alex has two arrays defined as [expression]. 

For example, if [expression] like so:




  [expression]
  [expression]
  [expression]



  [expression]
  [expression]
  [expression]


  [expression]
  [expression]
  [expression]




Alex's friend Kiara loves matrices, so he gives her [expression]. For each question, find and print the number of distinct integers in the given submatrix on a new line.
----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#pragma comment(linker, "/stack:16777216")
#include <string>
#include <vector>
#include <map>
#include <list>
#include <iterator>
#include <set>
#include <queue>
#include <iostream>
#include <sstream>
#include <stack>
#include <deque>
#include <cmath>
#include <memory.h>
#include <cstdlib>
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <utility>
#include <assert.h>
#include <time.h>
#include <complex.h>


#include <fstream>
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>
using namespace std;

#define FOR(i, a, b) for(int i=(a);i<(b);i++)
#define RFOR(i, b, a) for(int i=(b)-1;i>=(a);--i)
#define FILL(A,value) memset(A,value,sizeof(A))
#define ALL(V) V.begin(), V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair
#define Pi 3.14159265358979

typedef long long Int;
typedef unsigned long long UInt;
typedef vector<int> VI;
typedef pair<Int, Int> PII;

const int INF = 1000000000;
const int MAX = 100007;
const int MAXD = 20;
const int MOD = 1000000007;

int a[MAX];
int b[MAX];
int ca[MAX];
int cb[MAX];

Int A[MAX];

int main()
{
    //freopen("in.txt" , "r" , stdin);
    //freopen("out.txt" , "w" , stdout);
    
    int n , m;
    cin >> n >> m;
    
    int q;
    cin >> q;
    
    FOR(i,0,n) cin >> a[i];
    FOR(i,0,m) cin >> b[i];
    
    
    FOR(i,0,q)
    {
        int r1,c1,r2,c2;
        cin >> r1 >> c1 >> r2 >> c2;
        FILL(ca , 0);
        FILL(cb , 0);
        
        FOR(i,r1,r2 + 1)
            ca[a[i]] ++;
        FOR(i,c1,c2 + 1)
            cb[b[i]] ++;
        
        FILL(A, 0);
        FOR(i,1,MAX)
        {
            int cntA = 0;
            int cntB = 0;
            for(int j = i; j < MAX; j += i)
            {
                cntA += ca[j];
                cntB += cb[j];
            }
            A[i] = 1LL * cntA * cntB;
        }
        int res = 0;
        RFOR(i,MAX,1)
        {
            for(int j = 2 * i; j < MAX; j += i)
                A[i] -= A[j];
            if (A[i]) ++ res;
        }
        cout << res << endl;
    
    }
    
    
    return 0;
}

----------
====================
----------
ALGORITHMS.328
advanced
----------
PROBLEM STATEMENT:
Let's play Fairy Chess!

You have an [expression]) within the confines of the chessboard, meaning that diagonal moves are not allowed. In addition, the leaper cannot leap to any square that is occupied by a pawn.

Given the layout of the chessboard, can you determine the number of ways a leaper can move [expression] times within the chessboard?

Note: [expression].
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstring>

using namespace std;

#define long long long

const int maxn = 210;
const int mod = 1000000007;

int n, m, s;
char map[maxn][maxn];
long ans[maxn][maxn];
long sum[maxn][2*maxn];

void init()
{
	cin>>n>>m>>s;
	for(int i=0; i<n; ++i)
		cin>>map[i];
}

long getsum(int x, int y)
{
	if(x<0) {
		y += x;
		x = 0;
	}
	if(x>=n) {
		y = y - x + n - 1;
		x = n - 1;
	}
	if(y<0)
		return 0;
	return sum[x][y];
}

void calc_sum()
{
	for(int j=0; j<2*n; ++j)
		for(int i=0; i<n; ++i)
		{
			if(j>=n)
				sum[i][j] = 0;
			else
				sum[i][j] = ans[i][j];
			sum[i][j] = (sum[i][j] + getsum(i-1, j-1) + getsum(i+1, j-1) - getsum(i, j-2) + mod) % mod;
		}
}

void solve() {
	memset(ans, 0, sizeof(ans));
	for(int i=0; i<n; ++i)
		for(int j=0; j<n; ++j)
			if(map[i][j] == 'L')
				ans[i][j] = 1;
	for(int k=1; k<=m; ++k) {
		calc_sum();
		for(int i=0; i<n; ++i)
			for(int j=0; j<n; ++j)
				if(map[i][j] == 'P')
					ans[i][j] = 0;
				else
				{
					ans[i][j] = (getsum(i, j+s) - getsum(i-s-1, j-1) - getsum(i+s+1, j-1) + getsum(i, j-s-2) + mod + mod)%mod;
					ans[i][j] = (ans[i][j] + getsum(i, j+s-1) - getsum(i-s, j-1) - getsum(i+s, j-1) + getsum(i, j-s-1) + mod + mod)%mod;
				}
	}

	long res = 0;
	for(int i=0; i<n; ++i)
		for(int j=0; j<n; ++j)
			res = (res + ans[i][j])%mod;
	cout<<res<<endl;
}

int main() {
	int t;
	cin>>t;
	while(t--)
	{
		init();
		solve();
	}
}

----------
====================
----------
ALGORITHMS.329
expert
----------
PROBLEM STATEMENT:
Megan is playing a string game with the following rules:


It starts with a string, [expression].
During each turn, she performs the following move:

Choose an index in [expression]. The chosen index must be strictly greater than any index chosen in a prior move. 
Perform one or more circular rotations (in either direction) of the suffix starting at the chosen index.

For example, let's say [expression]: 
 
Note that this counts as one move.
The goal of the game is to convert [expression] into the lexicographically smallest possible string in as few moves as possible. In other words, we want the characters to be in alphabetical order.


Megan plays this game [expression] into the lexicographically smallest string and print that number on a new line.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

#define N 1010
#define inf 1010

int t;
char s[N];
map <string, int> mp;

int solve(char *s) {
//	puts(s);
	int len = strlen(s);
	if (!len) return 0;
	if (mp.count(s)) return mp[s];
	char c = *min_element(s, s + len);
	if (s[0] == c) return mp[s] = solve(s + 1);
	int rlt = 0;
	char ss[N];
	int runs = 0;
	bool vis[N];
	for (int i = 0; i < len; i ++) if (s[i] != c) {
		ss[runs] = s[i];
		int prv = i ? i - 1 : len - 1;
		vis[runs++] = s[prv] == c;
		if (i < len - 1 && s[i+1] == c) rlt ++;
	}
	ss[runs] = 0;
	len = runs;
	c = *min_element(ss, ss + len);
	bool start_c = 0;
	for (int i = 0; i < len; i ++) {
		if (vis[i] && ss[i] == c) {
			start_c = 1; break;
		}
	}
	int mn = inf;
    char sss[N];
	for (int i = 0; i < len; i ++) if (vis[i]) {
		if (start_c && ss[i] != c) continue;
		for (int j = 0; j < len; j ++) sss[j] = ss[(j+i)%len];
		sss[len] = 0;
		mn = min(mn, solve(sss));
	}
	return mp[s] = rlt + mn;
}

int main() {
//	freopen("s.in", "r", stdin);
//	freopen("s.out", "w", stdout);
	scanf("%d", &t);
	while (t --) {
		scanf("%s", s);
		printf("%d\n", solve(s));
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.330
hard
----------
PROBLEM STATEMENT:
Nina received an odd New Year's present from a student: a set of [expression]. Deciding to turn the gift into a lesson, Nina asks her students the following:

How many ways can you build a square using exactly [expression] of these unbreakable sticks? 

Note: Two ways are distinct if they use at least one different stick. As there are [expression] choices of sticks, we must determine which combinations of sticks can build a square.
----------
TOP SOLUTION:
----------
#include <algorithm>
#include <iostream>
#include <map>
#include <stdint.h>
#include <string.h>
#include <utility>
#include <vector>

using namespace std;

int main()
{
	const int max_l = 10000000;
	const int max_sticks = 3000;
	const int max_r = 4;
	
	// Precompute binomial coefficients up to choose 4
	uint64_t bin_coeff[1 + max_sticks][1 + max_r];
	
	for(uint64_t n = 1; n <= max_sticks; n++)
	{
		bin_coeff[n][0] = 1ULL;
		
		for(uint64_t r = 1; r <= ((n < max_r) ? n : max_r); r++)
			bin_coeff[n][r] = (bin_coeff[n][r - 1] * (n - (r - 1))) / r;
	}
	
	int n;
	
	cin >> n;
	
	vector<int> sticks;
	map<int,int> sticks_multiplicity;
	vector<pair<int,int> > sticks_multiplicity_sorted;
	
	vector<int> sticks_multiplicity_array(1 + max_l, 0);
	
	for(int i = 0; i < n; i++)
	{
		int a;
		
		cin >> a;
		
		sticks.push_back(a);
		
		if(sticks_multiplicity.find(a) == sticks_multiplicity.end())
			sticks_multiplicity[a] = 0;
			
		sticks_multiplicity[a]++;
		sticks_multiplicity_array[a]++;
	}
	
	sort(sticks.begin(), sticks.end());
	
	for(auto i = sticks_multiplicity.begin(); i != sticks_multiplicity.end(); i++)
		sticks_multiplicity_sorted.push_back(pair<int,int>(i->first,i->second));
		
	uint64_t count = 0ULL;
	
	// (1,1,1,3) case
	// Need to find sticks of multiplicity >= 3
	vector<pair<int,int> > sticks_multiplicity_3;
	
	for(int i = 0; i < sticks_multiplicity_sorted.size(); i++)
		if(sticks_multiplicity_sorted[i].second >= 3)
			sticks_multiplicity_3.push_back(sticks_multiplicity_sorted[i]);
	
	// a + b + c, 2a + b, 3a
	// Strategy is to hash all possible pairs of integers a + b
	vector<uint64_t> pair_hash(2 * max_l + 1, 0);
	
	pair_hash[sticks[0] + sticks[1]] = 1;
	
	// O(n^2)
	for(int i = 2; i < sticks.size(); i++)
	{
		for(int j = 0; j < sticks_multiplicity_3.size(); j++)
			if(sticks_multiplicity_3[j].first - sticks[i] >= 0)
				count += bin_coeff[sticks_multiplicity_3[j].second][3] * (uint64_t) pair_hash[sticks_multiplicity_3[j].first - sticks[i]];
		
		// Update pair_hash
		for(int j = 0; j < i; j++)
			pair_hash[sticks[i] + sticks[j]]++;
	}
	
	// (1,1,2,2) case
	// Sub-cases: (2a,2a), (2a,b+c), (a+b,a+b) and (a+b,c+d)
	fill(pair_hash.begin(), pair_hash.end(), 0);
	
	vector<uint64_t> &unique_pair_hash = pair_hash;
	
	// Data structures for (a+b,c+d)
	vector<uint64_t> pair_accum(2 * max_l + 1, 0ULL);
	vector<uint64_t> pair_combo(2 * max_l + 1, 0ULL);
	
	for(int i = 0; i < sticks_multiplicity_sorted.size(); i++)
		for(int j = i + 1; j < sticks_multiplicity_sorted.size(); j++)
		{
			// (a+b) data structure
			unique_pair_hash[sticks_multiplicity_sorted[i].first + sticks_multiplicity_sorted[j].first] +=
				sticks_multiplicity_sorted[i].second * sticks_multiplicity_sorted[j].second;
				
			// (a+b,c+d) data structure
			pair_combo[sticks_multiplicity_sorted[i].first + sticks_multiplicity_sorted[j].first] +=
				pair_accum[sticks_multiplicity_sorted[i].first + sticks_multiplicity_sorted[j].first] * 
				sticks_multiplicity_sorted[i].second * sticks_multiplicity_sorted[j].second;
				
			pair_accum[sticks_multiplicity_sorted[i].first + sticks_multiplicity_sorted[j].first] +=
				sticks_multiplicity_sorted[i].second * sticks_multiplicity_sorted[j].second;
		}
	
	vector<pair<int,int> > sticks_multiplicity_2;
	
	for(int i = 0; i < sticks_multiplicity_sorted.size(); i++)
		if(sticks_multiplicity_sorted[i].second >= 2)
		{
			sticks_multiplicity_2.push_back(sticks_multiplicity_sorted[i]);
			
			// (2a,2a)
			if(((sticks_multiplicity_sorted[i].first % 2) == 0) && (sticks_multiplicity_array[sticks_multiplicity_sorted[i].first / 2] >= 4))
				count += bin_coeff[sticks_multiplicity_sorted[i].second][2] * bin_coeff[sticks_multiplicity_array[sticks_multiplicity_sorted[i].first / 2]][4];
				
			// (2a,b+c)
			if(((sticks_multiplicity_sorted[i].first % 2) == 0) && (sticks_multiplicity_array[sticks_multiplicity_sorted[i].first / 2] >= 2))
				count += bin_coeff[sticks_multiplicity_sorted[i].second][2]
					* bin_coeff[sticks_multiplicity_array[sticks_multiplicity_sorted[i].first / 2]][2]
					* (uint64_t) unique_pair_hash[sticks_multiplicity_sorted[i].first];
					
			// (a+b,c+d)
			count += bin_coeff[sticks_multiplicity_sorted[i].second][2] *
				pair_combo[sticks_multiplicity_sorted[i].first];
		}
		
	// (a+b,a+b)
	// a and b must occur at least with a multiplicity of 2
	fill(pair_hash.begin(), pair_hash.end(), 0);
	
	for(int i = 0; i < sticks_multiplicity_2.size(); i++)
		for(int j = i + 1; j < sticks_multiplicity_2.size(); j++)
			unique_pair_hash[sticks_multiplicity_2[i].first + sticks_multiplicity_2[j].first] +=
				bin_coeff[sticks_multiplicity_2[i].second][2] * bin_coeff[sticks_multiplicity_2[j].second][2];
				
	for(int i = 0; i < sticks_multiplicity_2.size(); i++)
		count += bin_coeff[sticks_multiplicity_2[i].second][2] *
			(uint64_t) unique_pair_hash[sticks_multiplicity_2[i].first];
			
	cout << count << endl;
	
	return 0;
}
----------
====================
----------
ALGORITHMS.331
medium
----------
PROBLEM STATEMENT:
There are N cities and N directed roads in Steven's world. The cities are numbered from 0 to N - 1. Steven can travel from city i to city (i + 1) % N, ( 0- 1 - 2 - .... - N - 1 - 0). 

Steven wants to travel around the world by car. The capacity of his car's fuel tank is C gallons. There are a[i] gallons he can use at the beginning of city i and the car takes b[i] gallons to travel from city i to (i + 1) % N.  

How many cities can Steven start his car from so that he can travel around the world and reach the same city he started? 

Note  

The fuel tank is initially empty. 
----------
TOP SOLUTION:
----------
/******************************************************************************\
*                         Author:  Dumbear                                     *
*                         Email:   dumbear[#at]163.com                         *
*                         Website: http://dumbear.com                          *
\******************************************************************************/
#include <algorithm>
#include <bitset>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <typeinfo>
#include <utility>
#include <vector>

using namespace std;

#define output(x) cout << #x << ": " << (x) << endl;

typedef long long LL;
typedef vector<int> VI;
typedef vector<long long> VL;
typedef vector<double> VD;
typedef vector<string> VS;

const int max_n = 100000 + 10;

int n, a[max_n], b[max_n];
LL c, fuel[max_n];

int get_start() {
    int valid_start = -1;
    int start_city = 0, current_city = 0;
    LL current_fuel = 0;
    for (int i = 0; i < n * 2 + 10; ++i) {
        fuel[current_city] = current_fuel;
        int next_city = (current_city + 1) % n;
        LL next_fuel = min(current_fuel + a[current_city], c) - b[current_city];
        if (next_fuel < 0) {
            start_city = current_city = next_city;
            current_fuel = 0;
        } else if (next_city == start_city) {
            valid_start = start_city;
            break;
        } else {
            current_city = next_city;
            current_fuel = next_fuel;
        }
    }
    return valid_start;
}

int count_start() {
    int start = get_start();
    if (start == -1)
        return 0;
    int current = start;
    while (true) {
        int pre = (current + n - 1) % n;
        LL tmp = min(max(fuel[current] + b[pre] - a[pre], 0LL), c);
        if (tmp == fuel[pre])
            break;
        fuel[pre] = tmp;
        current = pre;
    }
    return count(fuel, fuel + n, 0);
}

void solve() {
    cin >> n >> c;
    for (int i = 0; i < n; ++i)
        scanf("%d", &a[i]);
    for (int i = 0; i < n; ++i)
        scanf("%d", &b[i]);
    printf("%d\n", count_start());
}

int main() {
    solve();
    return 0;
}

----------
====================
----------
ALGORITHMS.332
hard
----------
PROBLEM STATEMENT:
Steve loves playing with palindromes. He has a string, [expression]. Two ways are considered to be different if either of the following conditions are satisfied:


The positions of insertion are different.
The inserted characters are different. 


This means there are at most [expression].

Given [expression].
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define PII pair<int,int>
#define VI vector<int>
#define VPII vector<pair<int,int> >
#define PLL pair<long long,long long>
#define VPLL vector<pair<long long,long long> >
#define F first
#define S second
typedef long long LL;
using namespace std;
const int MOD = 1e9+7;
const int SIZE = 3005;
int dp[SIZE][SIZE];
int dp2[SIZE][SIZE];
char s[SIZE];
int main(){
    CASET{
        DRII(n,K);
        RS(s+1);
        if(K>2)puts("0");
        else if(K==0){
            printf("%d\n",n*26+26);
        }
        else{
            MS0(dp);
            MS0(dp2);
            REPP(i,1,n+1)dp2[i][i]=1;
            REPP(j,1,n){
                for(int k=1;k+j<=n;k++){
                    int ll=k,rr=k+j;
                    if(s[ll]==s[rr])dp2[ll][rr]=max(dp2[ll][rr],dp2[ll+1][rr-1]+2);
                    dp2[ll][rr]=max(dp2[ll][rr],dp2[ll+1][rr]);
                    dp2[ll][rr]=max(dp2[ll][rr],dp2[ll][rr-1]);
                }
            }
            int ma=0;
            for(int i=1;i<n;i++){
                for(int j=n;j>i;j--){
                    if(s[i]==s[j])dp[i][j]=dp[i-1][j+1]+2;
                    else dp[i][j]=max(dp[i-1][j],dp[i][j+1]);
                    ma=max(ma,dp[i][j]);
                }
            }
            REPP(i,1,n+1)ma=max(ma,dp[i-1][i+1]+1);
            int an=0;
            REP(i,n+1){
                int me=0;
                me=dp[i][i+1]+1;
                if(me>=ma+K){
                    an+=26;
                    continue;
                }
                bool used[26]={};
                REPP(j,1,n+1){
                    if(j<=i){
                        if(dp2[j+1][i]+dp[j-1][i+1]+2>=ma+K)used[s[j]-'a']=1;
                    }
                    else{
                        if(dp2[i+1][j-1]+dp[i][j+1]+2>=ma+K)used[s[j]-'a']=1;
                    }
                }
                REP(j,26)
                    if(used[j]){
                        an++;
                    }
            }
            printf("%d\n",an);
        }
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.333
medium
----------
PROBLEM STATEMENT:
Tim is visiting his grandma for two days and is bored due to the lack of the electricity over there. That's why he starts to play with grandma's colorful candle collection.

He aligned the [expression], the number of colors. 

Now he stares at the sequence of candles and wonders, how many strictly increasing ( in height ) colorful subsequences are there? A subsequence is considered as colorful if every of the [expression] colors appears at least one times in the subsequence. 

As the number of subsequences fulfilling the requirement can be large, print the result modulo [expression].
----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#include <bitset>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt(): x(0) { }
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }
	
	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }
	
	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
};
typedef ModInt<1000000007> mint;

struct FenwickTree {
	typedef mint T;
	vector<T> v;
	void init(int n) { v.assign(n, 0); }
	void add(int i, T x) {
		for(; i < (int)v.size(); i |= i+1) v[i] += x;
	}
	T sum(int i) const {	//[0, i)
		T r = 0;
		for(-- i; i >= 0; i = (i & (i+1)) - 1) r += v[i];
		return r;
	}
	T sum(int left, int right) const {	//[left, right)
		return sum(right) - sum(left);
	}
};

int main() {
	int N, K;
	scanf("%d%d", &N, &K);
	vector<int> H(N), C(N);
	rep(i, N)
		scanf("%d%d", &H[i], &C[i]), -- C[i];
	vector<FenwickTree> dp(1 << K);
	rep(k, 1 << K) dp[k].init(50001);
	dp[0].add(0, mint(1));
	rep(i, N) {
		int c = C[i], h = H[i];
		for(int j = (1 << K)-1; j >= 0; -- j) {
			mint x = dp[j].sum(h);
			dp[j | 1 << c].add(h, x);
		}
	}
	mint ans = dp[(1 << K)-1].sum(50001);
	printf("%d\n", ans.get());
	return 0;
}

----------
====================
----------
ALGORITHMS.334
advanced
----------
PROBLEM STATEMENT:
String [expression] is called a Super String if and only if:


[expression];
For any [expression]


Given a set of Super Strings [expression]. We can use each Super String as many times as we want.

Given set [expression].  
----------
TOP SOLUTION:
----------
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <map>
#include <vector>
#include <cstring>

using namespace std;
#define ll long long int 
vector<string> vs , distr;
map<string , int > mp;

void f( string s , int &N   ) {
	if( mp[s] ) return;
	mp[s] = 1;
	char ch = s[s.size()-1];
	for( int i = 0; i < N; i++ ) {	
		if( vs[i][0] > ch ) f( s+vs[i] , N );
	}
	distr.push_back(s);
}

long long int dp[200][12];
int DISTR;

long long int MOD = 1000000007;

long long int f1( int len , int lastchar ) {
	
	if( len <= 0 ) return 1;
	long long int &ret = dp[len][lastchar];
	if( ret == -1ll ) { 
		ret = 0ll;
		for( int i = 0; i < DISTR; i++ ) {
			int tsz = distr[i].size();
			int fs = distr[i][0]-'a' , ls = distr[i][tsz-1]-'a';
			if( (tsz <= len) &&  (fs) <= lastchar ) ret += f1( len-tsz , ls );
			ret %= MOD;
		}
	}
	return ret;
}
int main () {
	int N , L;mp.clear();
	scanf("%d %d" , &N , &L );	
	for( int i = 0; i < N; i++ ) {
		string s; cin >> s;
		vs.push_back(s);
	}
	
	f( "" , N );	
	int sz = distr.size()-1;	
	distr.resize(sz);DISTR = sz;

	sort( distr.begin()  , distr.end() );
/*	cout << DISTR << "\n";
	for( int i = 0; i < DISTR; i++ ) cout << distr[i] << "\n";
*/
	memset( dp , -1  , sizeof(dp) );		
	ll ans = 0;
	for( int i = 0; i <= L; i++ ) {
		ans += f1( i , 11 );
		ans %= MOD;
	}
	cout << ans << "\n";
 
	return 0;
}
----------
====================
----------
ALGORITHMS.335
medium
----------
PROBLEM STATEMENT:
You are given an array A = [1, 2, 3, ..., n]:     


How many sequences (S1) can you get after exact k adjacent swaps on A? 
How many sequences (S2) can you get after at most k swaps on A?  


An adjacent swap can be made between two elements of the Array A, A[i] and A[i+1] or A[i] and A[i-1]. 
A swap otherwise can be between any two elements of the array A[i] and A[j] ∀ 1 ≤ i, j ≤ N, i ≠ j.
----------
TOP SOLUTION:
----------
#include <stdio.h>

#define MOD 1000000007
#define NMAX 2501

long long cnt1[NMAX][NMAX], scnt1[NMAX][NMAX], cnt2[NMAX][NMAX];
int N, K, i, j;

int main() {
//	freopen("x.txt", "r", stdin);
	scanf("%d %d", &N, &K);
	
	for (i = 0; i <= K; i++) {
		cnt1[2][i] = 1;
		scnt1[2][i] = i + 1;
	}

	for (i = 3; i <= N; i++)
		for (j = 0; j <= K; j++) {
			cnt1[i][j] = scnt1[i - 1][j];
			if (j - i >= 0) {
				cnt1[i][j] -= scnt1[i - 1][j - i];
				if (cnt1[i][j] < 0) cnt1[i][j] += MOD;
			}			
			scnt1[i][j] = cnt1[i][j];
			if (j > 0) {
				scnt1[i][j] += scnt1[i][j - 1];
				if (scnt1[i][j] >= MOD) scnt1[i][j] -= MOD;
			}
		}

	for (j = 0; j <= K; j++)
		cnt2[1][j] = 1;
	for (i = 2; i <= N; i++)
		for (j = 0; j <= K; j++) {
			cnt2[i][j] = cnt2[i - 1][j];
			if (j > 0) {
				cnt2[i][j] = (cnt2[i][j] + cnt2[i - 1][j - 1] * (long long) (i - 1)) % MOD;
			}
		}

		
	printf("%lld %lld\n", cnt1[N][K], cnt2[N][K]);
	return 0;
}

----------
====================
----------
ALGORITHMS.336
medium
----------
PROBLEM STATEMENT:
Let's consider a permutation P = {p1, p2, ..., pN} of the set of N = {1, 2, 3, ..., N} elements .  

P is called a magic set if it satisfies both of the following constraints:  


Given a set of K integers, the elements in positions a1, a2, ..., aK are less than their adjacent elements, i.e., pai-1  pai ai+1
Given a set of L integers, elements in positions b1, b2, ..., bL are  greater than their adjacent elements, i.e., pbi-1 bi  pbi+1


How many such magic sets are there?

Input Format 
The first line of input contains three integers N, K, L separated by a single space. 
The second line contains K integers, a1, a2, ... aK each separated by single space. 
the third line contains L integers, b1, b2, ... bL each separated by single space. 

Output Format 
Output the answer modulo 1000000007 (109+7).

Constraints 
3 N 
1 
2 i, bj 

Sample Input #00  

4 1 1
2
3


Sample Output #00  

5


Explanation #00

Here, N = 4 a1 = 2 and b1 = 3. The 5 permutations of {1,2,3,4} that satisfy the condition are 


2 1 4 3
3 2 4 1
4 2 3 1
3 1 4 2
4 1 3 2


Sample Input #01

10 2 2
2 4
3 9


Sample Output #01

161280

----------
TOP SOLUTION:
----------
#include<math.h>
#include<algorithm>
#include<cstdlib>
#include<iostream>
#include<stdio.h>
#include<map>
#include<ext/hash_map>
#include<ext/hash_set>
#include<set>
#include<string>
#include<assert.h>
#include<vector>
#include<time.h>
#include<queue>
#include<deque>
#include<sstream>
#include<stack>
#include<sstream>
#define MA(a,b) ((a)>(b)?(a):(b))
#define MI(a,b) ((a)<(b)?(a):(b))
#define AB(a) (-(a)<(a)?(a):-(a))
#define X first
#define Y second
#define mp make_pair
#define pb push_back
#define pob pop_back
#define ep 0.0000000001
#define pi 3.1415926535897932384626433832795

using namespace std;
using namespace __gnu_cxx;
const long long P=1000000000+7;
const int N=5001;

int n,m,i,j,kk,k,l,r;
int a[N];
long long d[N],dd[N];
int main()
{
    cin>>n>>k>>l;
    for (i=1;i<=k;i++)
    {
        cin>>j;
        a[j]|=1;
        a[j+1]|=2;
    }
    for (i=1;i<=l;i++)
    {
        cin>>j;
        a[j]|=2;
        a[j+1]|=1;
    }
    for (i=2;i<=n;i++)
    if (a[i]==3) {cout<<0<<endl; return 0;}
    d[1]=1;
    for (i=2;i<=n;i++)
    {
        for (j=1;j<=n;j++)
            d[j]=(d[j]+d[j-1])%P;
        if (a[i]==2)
        {
            for (j=1;j<=i;j++)
            dd[j]=d[j-1];
        } else
        if (a[i]==1)
        {
            for (j=1;j<=i;j++)
            dd[j]=(d[n]-d[j-1]+P)%P;
        }else
            for (j=1;j<=i;j++)
            dd[j]=d[n];

        for (j=1;j<=n;j++) d[j]=0;
      for (j=1;j<=i;j++)
    d[j]=dd[j];
    // for (j=1;j<=i;j++)
   //  cout<<d[j]<<" ";cout<<endl;
    }
    long long ans=0;
    for (i=1;i<=n;i++) ans=(ans+d[i])%P;
    cout<<ans<<endl;
    return 0;
}


----------
====================
----------
ALGORITHMS.337
hard
----------
PROBLEM STATEMENT:
Square Subsequences

A string is called a square string if it can be obtained by concatenating two copies of the same string. For example, "abab", "aa" are square strings, while "aaa", "abba" are not. Given a string, how many (non-empty) subsequences of the string are square strings? A subsequence of a string can be obtained by deleting zero or more characters from it, and maintaining the relative order of the remaining characters.
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include<iostream>
#include<set>
#include<map>
#include<string>
#include<stdio.h>
#include<sstream>
#include<algorithm>
#include<queue>
#include<cmath>
#include<string.h>
using namespace std ;
#define MAXN 305
#define INF (int)1e9
#define MOD 1000000007

int brute(string s)
{
 int n = s.size() ;
 int ret = 0 ;
 for(int i = 1;i < 1 << n;i++)
 {
  string t ;
  for(int j = 0;j < n;j++)
   if(i & 1 << j)
    t.push_back(s[j]) ;
  if(t.size() % 2 == 1) continue ;
  int tt = t.size() ;
  bool valid = true ;
  for(int j = 0;j < tt / 2;j++)
   if(t[j] != t[tt / 2 + j])
    valid = false ;
  if(valid) ret++ ;
 }
 return ret ;
}

string s ;
int n ;
int start1,start2 ;

int memo[MAXN][MAXN] ;
int solve(int k1,int k2)
{
 if(k1 == start2 || k2 == n) return 0 ;
 int ret = s[k1] == s[k2] ? 1 : 0 ;
 if(memo[k1][k2] != -1) return memo[k1][k2] ;
 ret += solve(k1 + 1,k2) ;
 ret += solve(k1,k2 + 1) ;
 if(ret >= MOD) ret -= MOD ; 
 ret -= solve(k1 + 1,k2 + 1) ;
 if(ret < 0) ret += MOD ;
 if(s[k1] == s[k2]) ret += solve(k1 + 1,k2 + 1) ;
 if(ret >= MOD) ret -= MOD ; 
 return memo[k1][k2] = ret ;
}

int solve(string _s)
{
 s = _s ;
 n = s.size() ;
 int ret = 0 ;
 for(start2 = 0;start2 < n;start2++)
 {
  memset(memo,255,sizeof memo) ;
  for(start1 = 0;start1 < start2;start1++)
   if(s[start1] == s[start2])
   {
    int cret = 1 + solve(start1 + 1,start2 + 1) ;
    ret += cret ;
    if(ret >= MOD) ret -= MOD ;
   }
 }
 return ret ;
}

void test()
{
 for(int test = 0;test < 10000;test++)
 {
  int n = rand() % 10 + 1 ;
  string t ;
  for(int j = 0;j < n;j++) t.push_back('a' + rand() % 2) ;
  int ret1 = brute(t) ;
  int ret2 = solve(t) ;
  cout << ret1 << " " << ret2 << endl ;
  if(ret1 != ret2)
  {
   cout << "Failed on: " << test << endl ;
   cout << t << endl ;
   while(1) ;
  }
 }
}

void generate()
{
 char in[10] = "in .txt" ;
 for(int test = 0;test < 10;test++)
 {
  in[2] = test + '0' ;
  FILE * fout = fopen(in,"w") ;
  
  int runs = 20 ;
  fprintf(fout,"%d\n",runs) ;
  for(int t = 0;t < runs;t++)
  {
   string c ;
   int n = rand() % 200 + 1 ;
   if(test < 2) n = rand() % 20 + 1 ;
   
   if(test < 4) for(int i = 0;i < n;i++) c.push_back(rand() % 26 + 'a') ;
   else if(test < 7) for(int i = 0;i < n;i++) c.push_back(rand() % 3 + 'a') ;
   else if(test < 10) for(int i = 0;i < n;i++) c.push_back(rand() % 2 + 'a') ;

   fprintf(fout,"%s\n",c.c_str()) ;
  }
 }
}


int main()
{
// test() ; return 0 ;
// generate() ; return 0 ;

 int runs ;
 cin >> runs ;
 while(runs--)
 {
  string s ;
  cin >> s ;
  int ret = solve(s) ;
  cout << ret << endl ;
 }
 return 0 ;
}
----------
====================
----------
ALGORITHMS.338
advanced
----------
PROBLEM STATEMENT:
Mr. Dorsey Dawson recently stole [expression] grams of gold from ACME Jewellers. He is now on a train back home. To avoid getting caught by the police, he has to convert all the gold he has into paper money. He turns into a salesman and starts selling the gold in the train.  

There are [expression] dollars. Dawson wants to escape from the police and also maximize the profit. Can you help him maximize the profit?

Note: The [expression] grams if the transaction is successful.
----------
TOP SOLUTION:
----------
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cassert>
#include <iomanip>
#include <climits>
#include <cstdio>
#include <vector>
#include <string>
#include <stack>
#include <cmath>
#include <ctime>
#include <queue>
#include <list>
#include <map>
#include <set>

#define REP(i,n) for(int i = 0; i <(int)n; i++)
#define foreach(it,x) for(__typeof(x.begin()) it = x.begin() ; it!=x.end() ; it++ )

#ifdef KAZAR
    #define eprintf(...) fprintf(stderr, __VA_ARGS__)
#else
    #define eprintf(...)
#endif

using namespace std;

const int inf = (int)1e9 + 5757;

template<class T> inline void umax(T &a,T b){if(a<b) a = b;}
template<class T> inline void umin(T &a,T b){if(a>b) a = b;}
template<class T> inline T abs(T a){return a>0 ? a : -a;}
template<class T> inline T lcm(T a,T b){return a/gcd(a,b)*b;}

inline int read(){int x;scanf(" %d",&x);return x;}

const int N = 5050;

long long dp[N];
vector<int> g[N];
vector<int> a,b;

int main(){

#ifdef KAZAR
    freopen("f.i","r",stdin);
    freopen("f.cik","w",stdout);
    freopen("error","w",stderr);
#endif

    int n = read();
    int x = read();

    for(int i = 1; i <= n; i++){
        int a = read(), v = read();
        if(v <= x){
            g[v].push_back(a);
        }
    }

    for(int i = 1; i <= x; i++){
        sort(g[i].begin(), g[i].end());
        reverse(g[i].begin(), g[i].end());
        int cnt = min(5000 / i + 1,(int)g[i].size());
        for(int j = 0; j < cnt; j++){
            a.push_back(i);
            b.push_back(g[i][j]);
        }
    }

    memset(dp, -1, sizeof dp);

    dp[0] = 0;

    eprintf("%d\n",a.size());

    for(int i = 0; i < (int)a.size(); i++){
        for(int j = x; j >= 0; j--)
            if(dp[j] != -1 && j + a[i] <= x)
                umax(dp[j + a[i]],dp[j] + b[i]);
    }

    if(dp[x] == -1){
        puts("Got caught!");
    }else{
        cout << dp[x] << endl;
    }

    return 0;
}

----------
====================
----------
ALGORITHMS.339
advanced
----------
PROBLEM STATEMENT:
There are [expression] mines where it can be picked up by trucks. We do this according to the following rules:


You can move gold between any pair of mines (i.e., [expression]).
All the gold at some pickup mine [expression].
Move [expression].


Given [expression] pickup locations according to the above conditions.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
// iostream is too mainstream
#include <cstdio>
// bitch please
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <list>
#include <cmath>
#include <iomanip>
#include <time.h>
#define dibs reserve
#define OVER9000 1234567890123456789LL
#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)
#define tisic 47
#define soclose 1e-8
#define chocolate win
// so much chocolate
#define patkan 9
#define ff first
#define ss second
#define abs(x) ((x < 0)?-(x):x)
#define uint unsigned int
#define dbl long double
#define pi 3.14159265358979323846
using namespace std;
// mylittledoge

#ifdef DONLINE_JUDGE
	// palindromic tree is better than splay tree!
	#define lld I64d
#endif

int main() {
	cin.sync_with_stdio(0);
	cin.tie(0);
	cout << fixed << setprecision(10);
	int N,K;
	cin >> N >> K;
	vector<long long> W(N),X(N);
	for(int i =0; i < N; i++) cin >> X[i] >> W[i];
	vector<long long> sumW(N+1,0),sumWX(N+1,0);
	for(int i =0; i < N; i++) sumW[i+1] =sumW[i]+W[i], sumWX[i+1] =sumWX[i]+W[i]*X[i];
	vector< vector<long long> > ansL(K+1,vector<long long>(N+1,OVER9000));
	vector< vector<long long> > ansR(K+1,vector<long long>(N+1,OVER9000));
	ansR[0][0] =0;

	for(int i =0; i < N; i++) for(int k =0; k < K; k++) {
		if(K-k > N-i+3) continue;
		if(k > i+3) break;
		for(int j =i; j >= 0; j--) {
			ansL[k+1][i+1] =min(ansL[k+1][i+1],(ansR[k][j]+sumWX[j])-sumW[j]*X[i]);
			if(sumWX[j]-sumW[j]*X[i] > ansL[k+1][i+1]) break;}
		ansL[k+1][i+1] +=sumW[i+1]*X[i]-sumWX[i+1];
		for(int j =i; j >= 0; j--) {
			ansR[k+1][i+1] =min(ansR[k+1][i+1],(ansL[k+1][j+1]+X[j]*sumW[j]-sumWX[j])-X[j]*sumW[i+1]);
			if(X[j]*sumW[j]-sumWX[j]-X[j]*sumW[i+1] > ansR[k+1][i+1]) break;}
		ansR[k+1][i+1] +=sumWX[i+1];
		}

	cout << ansR[K][N] << "\n";
	return 0;}

// look at my code
// my code is amazing

----------
====================
----------
ALGORITHMS.340
hard
----------
PROBLEM STATEMENT:
Roy is helping the police department of his city in crime fighting. Today, they informed him about a new planned operation.

Think of the city as a [expression] criminals live there. No two criminals live at the same position.

To catch these criminals, the police department has to recruit some police officers and give each of them USD [expression] ).

The police department asks Roy to plan this operation. So Roy has to tell them the number of officers to recruit and the routes these officers should take in order to catch all the criminals. Roy has to provide this information while minimizing the total expenses of this operation.

Find out the minimum amount of money required to complete the operation.
----------
TOP SOLUTION:
----------
#include <stdio.h>
int n, h, st, ed;
long long inp[2000010], deq[2000010], dp[2000010];
inline long long sq(long long x) {
    return x * x;
}
inline long long calc(long long x1, long long v1, long long x2, long long v2) {
    return (v1 - v2 - x2*x2 + x1*x1 + 2*(x1-x2) - 1) / ( 2*(x1-x2));
}
int main() {
    scanf("%d%d", &n, &h);
    for (int i=1; i<=n; i++) scanf("%lld", &inp[i]);
    st = 0;
    ed = 0;
    deq[st++] = 0;
    for (int i=1; i<=n; i++) {
        while (st > ed + 1 && dp[deq[ed]] + sq(inp[i] - inp[deq[ed]+1]) >=
                              dp[deq[ed+1]] + sq(inp[i] - inp[deq[ed+1]+1])) {
            ed ++;
        }
        dp[i] = dp[deq[ed]] + sq(inp[i] - inp[deq[ed]+1]) + h;
        if (i < n) {
            while (st > ed + 1 && calc(inp[deq[st-1]+1], dp[deq[st-1]], inp[deq[st-2]+1], dp[deq[st-2]]) >=
                                  calc(inp[i+1], dp[i], inp[deq[st-1]+1], dp[deq[st-1]])) {
                st --;
            }
            deq[st++] = i;
        }
    }
    printf("%lld\n", dp[n]);
    return 0;
}

----------
====================
----------
ALGORITHMS.341
hard
----------
PROBLEM STATEMENT:
Zurikela is creating a graph with a special graph maker. At the begining, it is empty and has no nodes or edges. He can perform [expression] types of operations:    


[expression].    
[expression].      
[expression]. Note that each node can only exist in one set, so other sets become empty.     


The first [expression] is referring to the index of new set:

K = [index of last created set] + 1


Create the graph by completing the [expression] operations specified during input. Then calculate the maximum number of independent nodes (i.e.:how many nodes in the final graph which don't have direct edge between them).
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

vector<int> weight;
vector<vi> tree;
vector<int> child;
vector<int> memo;
int K;

int recTree(int i, int p, int j, bool b) {
	if(tree[i].size() == j) {
		int &r = memo[(K + i) * 2 + b];
		if(r != -1) return r;
		if(!b) {
			return r = 0;
		} else if(child[i] == -1) {
			return r = weight[i];
		} else {
			r = 0;
			rep(cb, 2)
				amax(r, recTree(child[i], -1, 0, cb != 0));
			return r;
		}
	}
	int c = tree[i][j];
	if(c == p)
		return recTree(i, p, j + 1, b);
	int &r = memo[c * 2 + b];
	if(r != -1) return r;
	r = 0;
	amax(r, recTree(c, i, 0, false) + recTree(i, p, j + 1, b));
	if(!b)
		amax(r, recTree(c, i, 0, true) + recTree(i, p, j + 1, b));
	return r;
}

void traverse(int x, vi &q, vector<bool> &vis) {
	q.clear();
	q.push_back(x);
	for(int h = 0; h != q.size(); ++ h) {
		int i = q[h];
		for(int j : tree[i]) if(!vis[j]) {
			vis[j] = true;
			q.push_back(j);
		}
	}
}

int main() {
	int Q;
	while(~scanf("%d", &Q)) {
		K = 0;
		weight.assign(Q, -1);
		tree.assign(Q, vi());
		child.assign(Q, -1);
		vi q;
		vector<bool> vis(Q, false);
		for(int ii = 0; ii < Q; ++ ii) {
			char ty[10];
			scanf("%s", ty);
			if(*ty == 'A') {
				int x;
				scanf("%d", &x);
				weight[K] = x;
				++ K;
			} else if(*ty == 'B') {
				int x; int y;
				scanf("%d%d", &x, &y), -- x, -- y;
				if(!vis[x] && !vis[y]) {
					tree[x].push_back(y);
					tree[y].push_back(x);
				}
			} else if(*ty == 'C') {
				int x;
				scanf("%d", &x), -- x;
				traverse(x, q, vis);
				child[K] = x;
				++ K;
			} else abort();
		}
		memo.assign(K * 4, -1);
		int ans = 0;
		rep(i, K) if(!vis[i]) {
			traverse(i, q, vis);
			int x = 0;
			rep(b, 2)
				amax(x, recTree(i, -1, 0, b != 0));
			ans += x;
		}
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.342
advanced
----------
PROBLEM STATEMENT:
You are given a sequence of integers a1,a2,a3.....an. You are free to replace any integer with any other positive integer. How many integers must be replaced to make the resulting sequence strictly increasing? 

Input Format 
The first line of the test case contains an integer [expression] - the number of entries in the sequence. 
The next line contains [expression].

Output Format 
Output the minimal number of integers that should be replaced to make the sequence strictly increasing.

Constraints 
[expression] 
[expression]  

Sample Input #00

3
4 10 20


Sample Output #00

0


Sample Input #01

6
1 7 10 2 20 22


Sample Output #01

1


Sample Input #02

5
1 2 2 3 4 


Sample Output #02

3


Explanation 
In the first sample input, we need not replace anything, hence the output is 0. 
In the second sample input, we can replace 2 with any integer between 11 and 19 to make the sequence strictly increasing, hence the output is 1. 
In the third sample input, we can obtain 1, 2, 3, 4, 5 by changing the last three elements of the sequence.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <ctime>
#include <fstream>
#include <cmath>
#include <cstring>
#include <cassert>
#include <cstdio>
#include <algorithm>
#include <iomanip>
#include <vector>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <complex>
#include <utility>
#include <cctype>
#include <list>

using namespace std;

#define FORALL(i,a,b) for(int i=(a);i<=(b);++i)
#define FOR(i,n) for(int i=0;i<(n);++i)
#define FORB(i,a,b) for(int i=(a);i>=(b);--i)

typedef long long ll;
typedef long double ld;
typedef complex<ld> vec;

typedef pair<int,int> pii;
typedef map<int,int> mii;

#define pb push_back
#define mp make_pair

#define INF 2000000001
#define MAXN 1000100
int A[MAXN];
int dp[MAXN];

int main() {
	int N;
	cin >> N;
	A[0] = 1;
	FORALL(i,1,N) scanf("%d",A+i);
	FORALL(i,1,N) A[i] -= i;
	FORALL(i,0,N) dp[i] = INF;
	//FORALL(i,1,N) cout << A[i] << " "; cout << endl;
	dp[0] = 0;
	FORALL(i,1,N) {
		if (A[i] < 0) continue;
		int idx = upper_bound(dp,dp+N,A[i]) - dp - 1;
		//cout << i <<  " " << A[i] << " " << idx << endl;
		assert(idx >= 0);
		dp[idx+1] = A[i];
	}
	/*
	FOR(i,N) cout << A[i] << endl;
	*/
	int ans = 0;
	FORALL(i,0,N) if (dp[i] < INF) ans = max(ans,i);
	/*
	FORALL(i,0,N) {
		cout << i << " " << dp[i] << endl;
	}*/
	
	cout << N-ans << endl;
}










----------
====================
----------
ALGORITHMS.343
hard
----------
PROBLEM STATEMENT:
In the middle of a nightmare, Maxine suddenly finds herself in a mysterious room with the following items: 


A piece of paper with the word score and the integer [expression] written on it.
A map of the castle where the room is located.
There are [expression].  
There are [expression] bidirectional corridors connecting pairs of rooms. The value of score changes every time she travels up or down a corridor, and this value differs depending on her direction of travel along the corridor. Each corridor can be traveled any number of times in either direction.
Every room is reachable from every other room.  
Maxine is located in the room labeled [expression].  
The exit is located in the room labeled [expression] and Maxine can (but is not required to) exit that level! 


Assume some corridor [expression]. Then:


Traveling corridor [expression].
Traveling corridor [expression]. 


There are [expression]. Given the above information, help Maxine by finding and printing her maximum possible score for each level. Only you can help her wake up from this nightmare!

Note: Recall that the result of a modulo operation is always non-negative.  For example, [expression].  
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }

struct UnionFind {
	vector<int> data;
	void init(int n) { data.assign(n, -1); }
	bool unionSet(int x, int y) {
		x = root(x); y = root(y);
		if(x != y) {
			if(data[y] < data[x]) swap(x, y);
			data[x] += data[y]; data[y] = x;
		}
		return x != y;
	}
	bool findSet(int x, int y) { return root(x) == root(y); }
	int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }
	int size(int x) { return -data[root(x)]; }
};

vector<int> t_parent;
vi t_ord;

void tree_getorder(const vector<vi> &g, int root) {
	int n = g.size();
	t_parent.assign(n, -1);
	t_ord.clear();

	vector<int> stk; stk.push_back(root);
	while(!stk.empty()) {
		int i = stk.back(); stk.pop_back();
		t_ord.push_back(i);
		for(int j = (int)g[i].size() - 1; j >= 0; j --) {
			int c = g[i][j];
			if(t_parent[c] == -1 && c != root)
				stk.push_back(c);
			else
				t_parent[i] = c;
		}
	}
}

template<typename T>T gcd(T x, T y) { if(y == 0)return x; else return gcd(y, x%y); }

int main() {
	int N;
	while(~scanf("%d", &N)) {
		UnionFind uf; uf.init(N);
		vector<vi> tree(N);
		map<pii, int> weight;
		pair<pii,int> addedge;
		rep(i, N) {
			int a; int b; int x;
			scanf("%d%d%d", &a, &b, &x), -- a, -- b;
			if(uf.unionSet(a, b)) {
				tree[a].push_back(b);
				tree[b].push_back(a);
				weight[make_pair(a, b)] = x;
				weight[make_pair(b, a)] = -x;
			} else {
				addedge = make_pair(make_pair(a, b), x);;
			}
		}
		tree_getorder(tree, 0);
		vector<ll> sum(N, 0);
		for(int ix = 1; ix < (int)t_ord.size(); ++ ix) {
			int i = t_ord[ix], p = t_parent[i];
			sum[i] = sum[p] + weight[make_pair(i, p)];
		}

		auto getw = [&](int a, int b) -> ll {
			return sum[a] - sum[b];
		};

		ll cyclew;
		{
			int a, b;
			tie(a, b) = addedge.first;
			cyclew = addedge.second + getw(b, a);
		}

		int Q;
		scanf("%d", &Q);
		rep(ii, Q) {
			int S; int E; int M;
			scanf("%d%d%d", &S, &E, &M), -- S, -- E;

			int a = cyclew % M;
			int b = getw(S, E) % M;
			if(a < 0) a += M;
			if(b < 0) b += M;

			int g = gcd(a, M);
			int ans = M - g + b % g;
			printf("%d\n", ans);
		}
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.344
hard
----------
PROBLEM STATEMENT:
We call a sequence of N natural numbers (a1, a2, ..., aN) a P-sequence, if the product of any two adjacent numbers in it is not greater than P. In other words, if a sequence (a1, a2, ..., aN) is a P-sequence, then ai * ai+1 ≤ P ∀ 1 ≤ i 

You are given N and P. Your task is to find the number of such P-sequences of N integers modulo 109+7.
----------
TOP SOLUTION:
----------
#include<math.h>
#include<algorithm>
#include<cstdlib>
#include<iostream>
#include<stdio.h>
#include<map>
#include<ext/hash_map>
#include<ext/hash_set>
#include<set>
#include<string>
#include<assert.h>
#include<vector>
#include<time.h>
#include<queue>
#include<deque>
#include<sstream>
#include<stack>
#include<sstream>
#define MA(a,b) ((a)>(b)?(a):(b))
#define MI(a,b) ((a)<(b)?(a):(b))
#define AB(a) (-(a)<(a)?(a):-(a))
#define X first
#define Y second
#define mp make_pair
#define pb push_back
#define pob pop_back
#define ep 0.0000000001
#define Pi 3.1415926535897932384626433832795
using namespace std;
using namespace __gnu_cxx;
const long long  MO=1000000000+7;
int x,y,i,j,k,n,m,mid,l,r;
int a[100000],p,kk;
long long b[2][100000];
int main()
{
    cin>>n>>p;
    kk=k=int(sqrt(p));
    for (i=1;i<=k;i++) a[i]=i;
    for (i=kk;i>=1;i--)
    {
        if (p/i>a[k]) {k++; a[k]=p/i;}
    }
    for (i=1;i<=k;i++)
    b[1][i]=a[i];
    b[0][0]=0;
    b[1][0]=0;
    for (i=2;i<=n;i++)
    {
        r=k;
        for (j=1;j<=k;j++){
            while (a[r]*a[j]>p) r--;
            b[(i&1)][j]=(b[(!(i&1))][r]*(a[j]-a[j-1])+b[(i&1)][j-1])%MO;
   //     cout<<b[(i&1)][j]<<" "<<a[j]<<" -- ";
        }
   //     cout<<endl;
    }
    cout<<b[(n&1)][k]<<endl;

    return 0;
}

----------
====================
----------
ALGORITHMS.345
advanced
----------
PROBLEM STATEMENT:
You have two arrays of integers, [expression] number of elements. Consider the following function:

score = 0

int Go(step, energy) {
    if (step == N) {
        score += V[step];
        return (score);
    }
    else {
        int way = random(1, 2);
        if (way == 1) {
            score += V[step];
        }
        else {
            energy = P[step];
        }
        if (energy  0) {
            Go(step + 1, energy - 1);
        }
        else {
            KillTheWorld();
        }
    }
}


What is the maximum possible value of score that we can get in the end, if we call [expression]?. 
Note that the function should never invoke KillTheWorld function. And [expression] generates a random integer from set  [1, 2]. 
It is guaranteed there will be a solution that wont kill the world.
----------
TOP SOLUTION:
----------
#include <vector> 
#include <list> 
#include <map> 
#include <set> 
#include <queue>
#include <stack> 
#include <bitset> 
#include <algorithm> 
#include <numeric> 
#include <utility> 
#include <sstream> 
#include <iostream> 
#include <iomanip> 
#include <cstdio> 
#include <cmath> 
#include <cstdlib> 
#include <ctime> 
#include <cstring> 

using namespace std; 

typedef long long ll; 
typedef pair<int, long long> pii;

#define INF 1000000000
#define pb push_back 
#define itr iterator 
#define sz size() 
#define mp make_pair

multiset<long long> values;
vector< long long> adj[6000000];
int v, p;
int n;

int main() {
	scanf("%d", &n);

	adj[1].push_back(0);
	values.insert(0);
	long long tot = 0;

	for (int i = 0; i < n; i++) {
		scanf("%d %d", &v, &p);
		tot += v;

		for (int k = 0; k < adj[i].size(); k++) {
			values.erase(values.find(adj[i][k]));
		}

		long long cur = -v + *values.rbegin();
		//printf("cur = %lld %d %lld\n", tot, -v, *values.rbegin());
		values.insert(cur);
		int will_rem = min(n, i + p + 1);
		adj[will_rem].push_back(cur);

		if (i == n-1) {
			printf("%lld\n", tot + cur + v);
			return 0;
		}
	}
}
----------
====================
----------
ALGORITHMS.346
expert
----------
PROBLEM STATEMENT:
A number is called lucky if the sum of its digits, as well as the sum of the squares of its digits is a prime number. How many numbers between [expression] inclusive, are lucky?

For example, [expression].  Each number is tested below:  

        digit   digit   squares
value   sum     squares sum 
20      2       4,0     4
21      3       4,1     5
22      4       4,4     8
23      5       4,9     13
24      6       4,16    20
25      7       4,25    29


We see that two numbers, [expression] are lucky.

Note: These lucky numbers are not to be confused with Lucky Numbers

Function Description  

Complete the luckyNumbers function in the editor below.  It should return an integer that represents the number of lucky numbers in the given range.  

luckyNumbers has the following parameter(s):  


a: an integer, the lower range bound  
b: an integer, the higher range bound  

----------
TOP SOLUTION:
----------
#include<iostream>
#include<set>
#include<map>
#include<string>
#include<stdio.h>
#include<sstream>
#include<algorithm>
#include<queue>
#include<cmath>
#include<string.h>
using namespace std ;
#define MAXN 2000
#define INF (int)1e9
bool sieve[MAXN] ;

void generate()
{
 for(int tt = 0;tt < 10;tt++)
 {
  char in[] = "in .txt" ;
  in[2] = tt + '0' ;
  FILE * fout = fopen(in,"w") ;
  int n,p,runs ;
  runs = 10000 ;
  fprintf(fout,"%d\n",runs) ;
  for(int i = 0;i < runs;i++)
  {
   int L = 1000000000 ;
   long long a = 1LL * (rand() % L) * (rand() % L) + 1 ;
   long long b = 1LL * (rand() % L) * (rand() % L) + 1 ;
   if(rand() % 10 == 0) a = rand() % L + 1 ;
   if(a > b) swap(a,b) ;
   fprintf(fout,"%lld %lld\n",a,b) ;
  }
 }
}

int brute(int a,int b)
{
 int ret = 0 ;
 for(int i = a;i <= b;i++)
 {
  int sum1 = 0,sum2 = 0 ;
  for(int temp = i;temp > 0;temp /= 10) { sum1 += temp % 10 ; sum2 += (temp % 10) * (temp % 10) ; }
  if(sieve[sum1] && sieve[sum2]) ret++ ;
 }
 return ret ;
}

int d,D[20] ;
long long memo[20][200][2000] ;
long long solve(int k,int st,int sum1,int sum2)
{
 if(k == -1) return sieve[sum1] && sieve[sum2] ? 1 : 0 ;
 if(st == 0 && memo[k][sum1][sum2] != -1) return memo[k][sum1][sum2] ;
 long long ret = 0 ;
 for(int i = 0;i < 10;i++) if(!st || i <= D[k])
 {
  ret += solve(k - 1,st && i == D[k] ? 1 : 0,sum1 + i,sum2 + i * i) ;
 }
 if(st == 0) memo[k][sum1][sum2] = ret ;
 return ret ;
}

long long solve(long long n)
{
 d = 0 ;
 while(n > 0)
 {
  D[d++] = n % 10 ;
  n /= 10 ;
 }
 long long ret = 0 ;
 for(int i = d - 1;i >= 0;i--)
  for(int j = 1;j < 10;j++)
   if(i < d - 1 || j <= D[i])
    ret += solve(i - 1,i == d - 1 && j == D[i],j,j * j) ;
 return ret ;
}


int main()
{
 for(int i = 2;i < MAXN;i++) sieve[i] = true ;
 for(int i = 2;i < MAXN;i++)
  for(int j = i + i;j < MAXN;j += i)
   sieve[j] = false ;

 memset(memo,255,sizeof memo) ;
// generate() ; return 0 ;
 int runs ;
 cin >> runs ;
 while(runs--)
 {
  long long a,b ;
  cin >> a >> b ;
  if(a < 1 || a > b || b > 1000000000000000000LL) { cout << "bad input\n" ; return 1 ; }
  long long ret = solve(b) ;
  if(a > 1) ret -= solve(a - 1) ;
  cout << ret << endl ;
//  cout << brute(a,b) << endl ;
 }
 return 0 ;
}

----------
====================
----------
ALGORITHMS.347
advanced
----------
PROBLEM STATEMENT:
You are playing a game of Nim with a friend. The rules are are follows:

1) Initially, there are N piles of stones. Two players play alternately.

2) In each turn, a player can choose one non empty pile and remove any number of stones from it. At least one stone must be removed.

3) The player who picks the last stone from the last non empty pile wins the game.

It is currently your friend's turn. You suddenly realize that if your friend was to play optimally in that position, you would lose the game. So while he is not looking, you decide to cheat and add some (possibly 0) stones to each pile. You want the resultant position to be such that your friend has no guaranteed winning strategy, even if plays optimally. You cannot create a new pile of stones. You can only add stones, and not remove stones from a pile. What is the least number of stones you need to add?
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

#define REP(i,n) for(int (i)=0,_n=(n);(i)<_n;(i)++)
#define FOR(i,a,b) for(int (i)=(a),_n=(b);(i)<=_n;(i)++)
#define FORD(i,a,b) for(int (i)=(a),_n=(b);(i)>=_n;(i)--)

typedef long long LL;

const LL inf = 0x7ffffffffffffffLL;

int main()
{
	int T;
	scanf( "%d", &T );
	while ( T-- ) {
		int n;
		LL  ts[20];
		scanf( "%d", &n );
		REP(i,n) cin >> ts[i];
		LL  ans = inf;


		REP(bit,1<<n) {
			LL s[20];
			REP(i,n) s[i] = ts[i];
			
			LL tans = 0;
			FORD(x,40,0) {
				bool odd = false;
				REP(i,n) if ( s[i] & (1LL << x) ) odd = !odd;
				if ( !odd ) continue;
				
				if ( __builtin_popcount(bit) <= 1 ) goto done;

				int choose = 0;
				LL  cost   = inf;
				LL  value  = 1LL << x;
				LL  mask   = value - 1;
				REP(i,n) if ( (bit & (1 << i)) && !(s[i] & (1LL << x)) && value - (s[i] & mask) < cost ) 
					cost = value - (s[i] & mask), choose = i;

				if ( cost == inf ) {
					do {
						x++;
						value = 1LL << x;
						mask  = value - 1;
						REP(i,n) if ( (bit & (1 << i)) && !(s[i] & (1LL << x)) && value - (s[i] & mask) < cost )
							cost = value - (s[i] & mask), choose = i;
						if ( cost == inf ) continue;
						s[choose] = (s[choose] & ~mask) | (1LL << x);
						tans += cost;
						break;
					} while ( true );
					x++;
				}
				else {
					s[choose] = (s[choose] & ~mask) | (1LL << x);
					tans += cost;
				}
			}
			ans = min(ans,tans);
			done:;
		}
		cout << ans << endl;
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.348
hard
----------
PROBLEM STATEMENT:
Mr. Road Runner bought a piece of land in the middle of a desert for a nominal amount. It turns out that the piece of land is now worth millions of dollars as it has an oil reserve under it. Mr. Road Runner contacts the ACME corp to set up the oil wells on his land. Setting up oil wells is a costly affair and the charges of setting up oil wells are as follows. 

The rectangular plot bought by Mr. Road Runner is divided into r * c blocks. Only some blocks are suitable for setting up the oil well and these blocks have been marked. ACME charges nothing for building the first oil well. For every subsequent oil well built, the cost would be the maximum ACME distance between the new oil well and the existing oil wells. 

If (x,y) is the position of the block where a new oil well is setup and (x1, y1) is the position of the block of an existing oil well, the ACME distance is given by 

max(|x-x1|, |y-y1|)


the maximum ACME distance is the maximum among all the ACME distance between existing oil wells and new wells. 

If the distance of any two adjacent blocks (horizontal or vertical) is considered 1 unit, what is the minimum cost (E) in units it takes to set up oil wells across all the marked blocks?
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <cassert>
#include <algorithm>
#include <cmath>
#include <ctime>
#include <stdint.h>

#include <vector>
#include <map>
#include <set>
#include <queue>
#include <cstring>
#include <bitset>
#include <deque>
#include <list>
#include <stack>

using namespace std;

typedef long long ll;

#define mp make_pair
#define pb push_back
#define all(v) (v).begin(), (v).end()
#define forn(i, n) for(int i = 0; i < int(n); ++i)
#define foreach(it, v) for(__typeof((v).begin()) it = (v).begin(); it != (v).end(); ++it)
#define sz(v) int((v).size())

const int max_n = 50, inf = 1e9;

bool is_oil[max_n][max_n];
bool used[max_n][max_n][max_n][max_n];
int d[max_n][max_n][max_n][max_n];

inline int get_penalty(int x0, int y0, int x1, int y1, int x, int y) {
  return max(max(abs(x - x0), abs(x - x1)), max(abs(y - y0), abs(y - y1)));
}

int rec(int x0, int y0, int x1, int y1, int n, int m) {
  assert(x0 <= x1 && x0 >= 0 && x1 < n);
  assert(y0 <= y1 && y0 >= 0 && y1 < m);

  if(used[x0][y0][x1][y1]) {
    return d[x0][y0][x1][y1];
  }
  
  int result = inf;

  if(x0 == 0 && y0 == 0 && x1 == n - 1 && y1 == m - 1) {
    result = 0;
  } else {
    if(x0 > 0) {
      int add = 0;
      for(int y = y0; y <= y1; y++) {
        if(is_oil[x0 - 1][y]) {
          add += get_penalty(x0 - 1, y0, x1, y1, x0 - 1, y);
        }
      }
      result = min(result, add + rec(x0 - 1, y0, x1, y1, n, m));
    }
    if(y0 > 0) {
      int add = 0;
      for(int x = x0; x <= x1; x++) {
        if(is_oil[x][y0 - 1]) {
          add += get_penalty(x0, y0 - 1, x1, y1, x, y0 - 1);
        }
      }
      result = min(result, add + rec(x0, y0 - 1, x1, y1, n, m));
    }
    if(x1 + 1 < n) {
      int add = 0;
      for(int y = y0; y <= y1; y++) {
        if(is_oil[x1 + 1][y]) {
          add += get_penalty(x0, y0, x1 + 1, y1, x1 + 1, y);
        }
      }
      result = min(result, add + rec(x0, y0, x1 + 1, y1, n, m));
    }
    if(y1 + 1 < m) {
      int add = 0;
      for(int x = x0; x <= x1; x++) {
        if(is_oil[x][y1 + 1]) {
          add += get_penalty(x0, y0, x1, y1 + 1, x, y1 + 1);
        }
      }
      result = min(result, add + rec(x0, y0, x1, y1 + 1, n, m));
    }
  }

  used[x0][y0][x1][y1] = true;
  return d[x0][y0][x1][y1] = result;
}

int main() {
  int n, m;
  scanf("%d%d", &n, &m);
  bool empty = true;
  forn(i, n) {
    forn(j, m) {
      int k;
      scanf("%d", &k);
      is_oil[i][j] = (k == 1);
      if(is_oil[i][j]) {
        empty = false;
      }
    }
  }
  int result = (empty) ? 0 : inf;
  forn(i, n) {
    forn(j, m) {
      if(is_oil[i][j]) {
        result = min(result, rec(i, j, i, j, n, m));
      }
    }
  }
  printf("%d\n", result);
  return 0;
}

----------
====================
----------
ALGORITHMS.349
advanced
----------
PROBLEM STATEMENT:
A company needs random numbers for its operation. [expression] numbers as seeds and the following recurrence formula:

[expression]

The numbers used as seeds are [expression] term of the recurrence.

Due to a failure on the servers, the company lost its seed numbers. Now they just have the recurrence formula and the previously generated [expression] random numbers.

The company wants to recover the numbers used as seeds, so they have hired you for doing this task.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

typedef long long ll;

ll MOD = 1000000007;
ll powe(ll a, ll b) {
    if (b == 0) return 1;
    if (b % 2 == 0) return powe( (a*a)%MOD, b/2);
    return (a*powe(a, b-1)) % MOD;
}

ll inv(ll a) {
    return powe(a, MOD-2);
}

struct matrix {
    vector<vector<ll>> M;
    matrix I() const {
        matrix ans;
        ans.M = M;
        for (int i = 0; i < M.size(); ++i)
            for (int j = 0; j < M.size(); ++j)
            ans.M[i][j] = !!(i==j);
        return ans;
    }
    matrix operator*(const matrix& rhs) const {
        matrix ans;
        ans.M = M;
        int N = M.size();
        for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j) {
            ans.M[i][j] = 0;
            for (int k = 0; k < N; ++k)
                ans.M[i][j] = (ans.M[i][j] + M[i][k]*rhs.M[k][j]) % MOD;
        }
        return ans;
    }
};

matrix powm(const matrix& M, int b) {
    if (b == 0) return M.I();
    if (b % 2 == 0) return powm( M*M, b/2);
    return M*powm(M, b-1);
}

int main() {
    ll N, K;
    cin >> N >> K;
    vector<ll> F(N);
    for (ll &x : F) cin >> x;
    vector<ll> C(N);
    for (ll &x : C) cin >> x;
    matrix M;
    M.M = vector<vector<ll>>(N, vector<ll>(N));
    for (int i = 0; i < N-1; ++i)
        for (int j = 0; j < N; ++j)
            M.M[i][j] = !!((i+1) == j);
    ll cinv = inv(C.back());
    M.M[N-1][0] = cinv;
    for (int j = 1; j < N; ++j)
        M.M[N-1][j] = ((MOD - C[j-1])*cinv)%MOD;
    auto M2 = powm(M, K-N+1);
    vector<ll> ans(N);
    for (int i = 0; i < N; ++i) {
        ans[i] = 0;
        for (int j = 0; j < N; ++j)
            ans[i] = (ans[i] + F[j]*M2.M[i][j]) % MOD;
    }
    for (int i = 0; i < N; ++i) {
        if (i) printf(" ");
        printf("%lld", ans[i]);
    }
    printf("\n");
    return 0;
}

----------
====================
----------
ALGORITHMS.350
advanced
----------
PROBLEM STATEMENT:
A new gangster is trying to take control of the city. He makes a list of his [expression]) and plans to get rid of them.

[expression].

While our new gangster wants to kill all of them, he also wants to pay the least amount of money. All mercenaries charge a different amount to kill different people. So he asks you to help him minimize his expenses.  
----------
TOP SOLUTION:
----------
//Coder: Balajiganapathi
#define TRACE
#define DEBUG

#include <algorithm>
#include <bitset>
#include <deque>
#include <cassert>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <utility>
#include <vector>

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pi;
typedef vector<string> vs;

// Basic macros
#define st          first
#define se          second
#define all(x)      (x).begin(), (x).end()
#define ini(a, v)   memset(a, v, sizeof(a))
#define re(i,s,n)  	for(int i=s;i<(n);++i)
#define rep(i,s,n)  for(int i=s;i<=(n);++i)
#define fr(i,n)     re(i,0,n)
#define repv(i,f,t) for(int i = f; i >= t; --i)
#define rev(i,f,t)  repv(i,f - 1,t)
#define frv(i,n)    rev(i,n,0)
#define pu          push_back
#define mp          make_pair
#define sz(x)       (int)(x.size())

const int oo = 1000000009;
const double eps = 1e-9;

#ifdef TRACE
    #define trace1(x)                cerr << #x << ": " << x << endl;
    #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;
    #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;
    #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;
    #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl;
    #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;

#else

    #define trace1(x)
    #define trace2(x, y)
    #define trace3(x, y, z)
    #define trace4(a, b, c, d)
    #define trace5(a, b, c, d, e)
    #define trace6(a, b, c, d, e, f)

#endif

int n, k;
const int mx = 25;
int a[mx], b[mx], c[mx][mx];
int dp[mx][(1 << 10) + 10];

int solve(int i, int mask) {
    if(i == n) return 0;
    if(mask == (1 << k) - 1) return oo;
    int &ret = dp[i][mask];
    if(ret != -1) return ret;
    ret = oo;

    fr(nxt, k) if((mask & (1 << nxt)) == 0) {
        int cur = 0;
        re(j, i, n) {
            cur += c[nxt][j];
            ret = min(ret, cur + solve(j + 1, mask | (1 << nxt)));
        }
    }

    return ret;
}

int main() {
    scanf("%d %d", &n, &k);
    fr(i, k) {
        fr(j, n) scanf("%d", &c[i][j]);
    }


    ini(dp, -1);
    printf("%d\n", solve(0, 0));
    
	return 0;
}

----------
====================
----------
ALGORITHMS.351
advanced
----------
PROBLEM STATEMENT:
A tree, [expression]. 

Given [expression]'s maximal total weight on a new line.

Note: If [expression] nodes.
----------
TOP SOLUTION:
----------
#include <fstream>
#include <iostream>
#include <vector>
#include <bitset>
using namespace std;
const int NMAX = 100004;
const long long INF = 1LL<<60;
vector <int> Tree[NMAX], Level[NMAX];
long long dp[NMAX][201], sum[NMAX];
int n, Father[NMAX], v[NMAX], val[NMAX], First[NMAX], Last[NMAX], ind;
inline void DFS(const int node,const int father){
    First[node] = ++ind;
    v[ind] = node;
    for(vector < int >::iterator it = Tree[node].begin();it != Tree[node].end();++it)
        if(*it != father)
            DFS(*it,node);
    Last[node] = ind;
}

int main(){
    int n, k;
    cin.sync_with_stdio(false);
    cin >> n >> k;
    for(int i = 1;i <= n; ++i)
        cin >> val[i];    
    for(int i=1;i<n;++i){
        int x,y;
        cin >> x >> y;
        Tree[x].push_back(y);
        Tree[y].push_back(x);
    }
    DFS(1,0);
    for(int i = 1;i <= n; ++i){
        for(int j=0;j<=k;++j)
            dp[i][j] = -INF;
    }
    dp[1][0] = 0;
    for(int i = 1;i <= n; ++i)
    {
        int node = v[i];
        for(int j = 0;j <= k; ++j)
            if(dp[i][j]!=-INF)
            {
                dp[i + 1][j] =max(dp[i+1][j],dp[i][j]+val[node]);
                if(j+1<=k)
                    dp[Last[node]+1][j+1] =  max(dp[i][j],dp[Last[node]+1][j+1]);
            }
    }
    long long sol = 0;
    for(int j = 0;j <= k;++j)
        sol = max(sol,dp[n+1][j]);
    cout<<sol<<"\n";
    return 0;
}
----------
====================
----------
ALGORITHMS.352
hard
----------
PROBLEM STATEMENT:
You are using at most A number of 1s and at most B number of 2s. How many different evaluation results are possible when they are formed in an expression containing only addition + sign and multiplication * sign are allowed?

Note that, multiplication takes precedence over addition.

For example, if A=2 and B=2, then we have the following expressions:


1, 1*1 = 1
2, 1*2, 1*1*2, 1+1 = 2
1+2, 1+1*2 = 3
2+2, 2*2, 1+1+2, 1*2*2, 1*1*2*2, 1*2+1*2, 1*1*2+2, 1*2+2 = 4
1+2+2, 1+1*2+2 = 5
1+1+2+2,  1+1+2*2 = 6


So there are 6 unique results that can be formed if A = 2 and B = 2. 
----------
TOP SOLUTION:
----------
#include<stdio.h>
#include<algorithm>
#include<string.h>
using namespace std;
const int MOD = 1e9 + 7;
int dp_sum[1001][1001],dp_bit[1001][1001];
void add(int &x,long long v){
    v%=MOD;
    x+=v;
    if(x>=MOD)x-=MOD;
}
int f_bit(int lv,int B);
int f_sum(int lv,int B){
    if(lv>B)return 1;
    if(dp_sum[lv][B]!=-1)return dp_sum[lv][B];
    int tmp=f_sum(lv+1,B);
    add(tmp,f_bit(lv,B));
    return dp_sum[lv][B]=tmp;

}
int f_bit(int lv,int B){
    if(lv>B)return 0;
    if(dp_bit[lv][B]!=-1)return dp_bit[lv][B];
    return dp_bit[lv][B]=f_sum(lv+1,B-lv);
}
int main(){
    int T,A,B;
    scanf("%d",&T);
    memset(dp_sum,-1,sizeof(dp_sum));
    memset(dp_bit,-1,sizeof(dp_bit));
    while(T--){
        scanf("%d%d",&A,&B);
        int an=0;
        if(A==0)an=f_sum(1,B);
        else{
            int k=1;
            while((1LL<<k)<=A)k++;
            k++;
            add(an,(long long)(A+1)*f_sum(k,B));
            long long ha=(1LL<<k)-A-1;
            int now=0,i=1;
            long long last=0;
            while(ha>0){
                now++;
                if(B<now)break;
                add(an,min((1LL<<i)-last,ha)*f_sum(k,B-now));
                ha-=(1LL<<i)-last;
                last=1LL<<i;
                i++;
                if(i==k){
                    last=0;
                    i=1;
                }
            }
            /*
            long long last=A;
            for(int i=1;i<=B;i++){
                if(last+1>=(1LL<<k))break;
                add(an,(min(((long long)A+(1LL<<i)),(1LL<<k)-1)-last)*f_sum(k,B-i));
                last=min((long long)A+(1LL<<i),(1LL<<k)-1);
            }*/
        }
        printf("%d\n",(an+MOD-1)%MOD);
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.353
expert
----------
PROBLEM STATEMENT:
In a tournament, [expression] players play against each other exactly once. Each game results in exactly one player winning. There are no ties. You have been given a scorecard containing the scores of each player at the end of the tournament. The score of a player is the total number of games the player won in the tournament. However, the scores of some players might have been erased from the scorecard. How many possible scorecards are consistent with the input scorecard?
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include<iostream>
#include<vector>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<algorithm>
using namespace std ;
#define MAXN 42
#define MOD 1000000007

int n ;
vector<int> G ;

int check(vector<int> gg)
{
 sort(gg.begin(),gg.end()) ;
 int sum = 0 ;
 for(int i = 0;i < n;i++)
 {
  sum += gg[i] ;
  if(sum < i * (i + 1) / 2) return 0 ;
 }
 return 1 ;
}

int solve1(int k,int sum)
{
 if(sum > n * (n - 1) / 2) return 0 ;
 if(k == n) return sum == n * (n - 1) / 2 && check(G) ? 1 : 0 ;
 if(G[k] != -1) return solve1(k + 1,sum + G[k]) ;
 
 int ret = 0 ;
 for(int i = 0;i < n;i++)
 {
  G[k] = i ;
  ret += solve1(k + 1,sum + i) ;
  G[k] = -1 ;
 }
 return ret ;
}

int solve1(vector<int> g)
{
 G = g ;
 n = G.size() ;
 int ret = solve1(0,0) ;
 return ret ;
}

int fac[MAXN],inv[MAXN] ;
int pow(int a,int b)
{
 if(b == 0) return 1 ;
 int ret = pow(a,b / 2) ;
 ret = 1LL * ret * ret % MOD ;
 if(b & 1) ret = 1LL * ret * a % MOD ;
 return ret ;
}

int occ[MAXN],big[MAXN] ;
int memo[MAXN][MAXN][MAXN * MAXN] ;
int solve2(int k,int last,int sum)
{
 if(last == n) return 0 ;
 if(sum > n * (n - 1) / 2) return 0 ;
 if(k == n) return big[last + 1] == 0 && sum == n * (n - 1) / 2 ? 1 : 0 ;
 if(memo[k][last + 1][sum] != -1) return memo[k][last + 1][sum] ;
 int occr = occ[last + 1] ;
 int ret = 0,added = 0 ;
 for(int i = 0;k + i <= n;i++)
 {
  if(sum + added < (k + i) * (k + i - 1) / 2) break ;
  if(i >= occr) ret += 1LL * inv[i - occr] * solve2(k + i,last + 1,sum + added) % MOD ;
  if(ret >= MOD) ret -= MOD ;
  added += last + 1 ;
 }
 return memo[k][last + 1][sum] = ret ;
}

int solve2(vector<int> g)
{
 fac[0] = inv[0] = 1 ;
 for(int i = 1;i < MAXN;i++)
 {
  fac[i] = 1LL * i * fac[i - 1] % MOD ;
  inv[i] = pow(fac[i],MOD - 2) ;
 }
 n = g.size() ;

 int start = 0 ;
 memset(occ,0,sizeof occ) ;
 memset(big,0,sizeof big) ;
 for(int i = 0;i < g.size();i++) if(g[i] != -1) occ[g[i]]++,start++ ;
 for(int i = 0;i < n;i++)
  for(int j = i;j < n;j++)
   big[i] += occ[j] ;
 memset(memo,255,sizeof memo) ;
 int ret = solve2(0,-1,0) ; 
 ret = 1LL * ret * fac[n - start] % MOD ;
 return ret ;
}


vector<int> gen()
{
 int n = rand() % 10 + 1 ;
 vector<int> ret ;
 for(int i = 0;i < n;i++)
 {
  if(rand() % 2 == 0) ret.push_back(-1) ;
  else ret.push_back(rand() % n) ;
 }
 return ret ;
}

void test()
{
 for(int t = 1;t < 100;t++)
 {
  vector<int> g = gen() ;
  int ret1 = solve1(g) ;
  int ret2 = solve2(g) ;

  cout << ret1 << " " << ret2 << endl ;
  if(ret1 != ret2)
  {
   cout << "failed on: " << t << endl ;
   cout << g.size() << " : " ;
   for(int i = 0;i < g.size();i++) cout << g[i] << " " ; cout << endl ;
   while(1) ;
  }
 }
}

void generate()
{
 char in[] = "in .txt" ;
 for(int test = 0;test < 10;test++)
 {
  in[2] = test + '0' ;
  FILE * fout = fopen(in,"w") ;
  int runs = 20 ;
  fprintf(fout,"%d\n",runs) ;
  for(int t = 0;t < runs;t++)
  {
   if(rand() % 3 != 0) n = rand() % 40 + 1 ;
   else n = 40 - rand() % 10 ;
   int per = 70 ;
   
   vector<int> g ;
   for(int i = 0;i < n;i++)
   {
    if(rand() % 100 < per) g.push_back(-1) ;
    else g.push_back(rand() % n) ;
   }

   fprintf(fout,"%d\n",n) ;
   for(int i = 0;i < n;i++)
   {
    if(i) fprintf(fout," ") ;
    fprintf(fout,"%d",g[i]) ;
   }
   fprintf(fout,"\n") ;
  }
 }
}

int main()
{
// srand(time(NULL)) ; 
// generate() ; return 0 ;
// test() ; return 0 ;
 
 int runs ;
 cin >> runs ;
 while(runs--)
 {
  int n ;
  vector<int> g ;
  cin >> n ;
  for(int i = 0;i < n;i++)
  {
   int k ;
   cin >> k ;
   g.push_back(k) ;
  }
  int ret = solve2(g) ;
  printf("%d\n",ret) ;
 } 
 return 0 ;
}
----------
====================
----------
ALGORITHMS.354
advanced
----------
PROBLEM STATEMENT:
A war has broken down between Vim and Emacs. Gedit, being Vim's ally, is captured by Emacs as a prisoner of war and it is up to Vim to rescue him by defeating Emacs.

For this task, Vim has to assemble an army of appropriate skills. He can choose a non-empty subset of soldiers from a set of [expression]. 

Note : The chosen army's skill-set must exactly match the skill-set requirement of Vim (i.e no extra skills must be present in the army's skill-set than what is required).
----------
TOP SOLUTION:
----------
/*
*/
 
//#pragma comment(linker, "/STACK:16777216")
#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <ctime> 

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 512

using namespace std;

int pw[1<<20];

int cbits(int x)
{
	return x==0?0:cbits(x/2)+x%2;
}

int n,m,ans[1<<20];
string st;
int sub[1<<20];
int cnt[1<<20];
int nmask;

int main(){
//freopen("enigmatic.in","r",stdin);
//freopen("enigmatic.out","w",stdout);
//freopen("F:/in.txt","r",stdin);
//freopen("F:/output.txt","w",stdout);
ios_base::sync_with_stdio(0);
//cin.tie(0)

pw[0]=1;
for (int i=1;i<(1<<20);i++)
	pw[i]=pw[i-1]*2%bs;

cin>>m>>n;
for (int i=0;i<m;i++)
{
	cin>>st;
	int mask=0;
	for (int j=0;j<n;j++)
		mask=mask*2+st[j]-48;
	cnt[mask]++;
}

string st;
cin>>st;
for (int i=0;i<n;i++)
	nmask=nmask*2+st[i]-48;
	
for (int i=0;i<(1<<n);i++)
	sub[i]=cnt[i];
	
for (int ps=0;ps<n;ps++)
	for (int mask=0;mask<(1<<n);mask++)
		if (mask&(1<<ps))
			sub[mask]+=sub[mask-(1<<ps)];

ans[nmask]=pw[sub[nmask]];

for (int mask=nmask-1;mask>=0;--mask)
{
	int tmask=(mask|nmask);
	if (tmask!=nmask)continue;
	int dif=cbits(mask^nmask);
	
	if (dif%2==1)
		ans[nmask]-=pw[sub[mask]]%bs;
	else
		ans[nmask]+=pw[sub[mask]]%bs;
	
	ans[nmask]%=bs;
}

if (nmask==0)
	ans[nmask]-=1;

cout<<(ans[nmask]%bs+bs)%bs<<endl;

//cin.get();cin.get();
return 0;}

----------
====================
----------
ALGORITHMS.355
advanced
----------
PROBLEM STATEMENT:
In Chile, land are partitioned into a one large grid, where each element represents a land of size 1x1. 

Shaka is a newcomer in Chile and is trying to start his own business. He is planning to build a store. He has his own ideas for the "perfect store" which can be represented by a HxW grid. Element at position (i, j) represents height of land at index (i, j) in the grid. 

Shaka has purchased a land area which can be represented RxC grid (H ). Shaka is interested in finding best HxW sub-grid in the acquired land. In order to compare the possible sub-grids, Shaka will be using the sum of squared difference between each cell of his "perfect store" and  it's corresponding cell in the subgrid. Amongst all possible sub-grids, he will choose the one with smallest such sum.

Note


The grids are 1-indexed and rows increase from top to bottom and columns increase from left to right. 
If x is the height of a cell in the "perfect store" and y is the height of the corresponding cell in a sub-grid of the acquired land, then the squared difference is defined as (x-y)2 

----------
TOP SOLUTION:
----------
#include <stdio.h>
#include <algorithm>
#include <stdio.h>
#include <ctime>
#include <math.h>
using namespace std;
#define N 510
#define M 1000000000
#define L 600100
int m[N][N], g[N][N], s[N][N];
int na, nb, a[L], b[L];
double PI=2*acos(0.0);
struct C
{
	double r, i;
	C(double r=0, double i=0): r(r), i(i) {}
};
inline C add(const C &a, const C &b) { return C(a.r+b.r, a.i+b.i); }
inline C sub(const C &a, const C &b) { return C(a.r-b.r, a.i-b.i); }
inline C mul(const C &a, const C &b) { return C(a.r*b.r-a.i*b.i, a.r*b.i+a.i*b.r); }
int z[L];
C v[L], u[L];
void fft(int n)
{
	int i, j, k;
	C t, a, b;
	for(i=0; i<n; u[i]=v[z[i]], i++);
	for(i=1; i<n; i*=2)
		for(a=C(cos(PI/i), sin(PI/i)), j=0; j<n; j+=2*i)
			for(b=C(1, 0), k=j; k<j+i; t=mul(u[k+i], b), u[k+i]=sub(u[k], t), u[k]=add(u[k], t), b=mul(b, a), k++);
}
long long fl(double x) { return x>0?x+0.5:x-0.5; }
void mul(int *a, int na, int *b, int nb, int *c, int &nc)
{
	int i, j, n;
	for(nc=na+nb-1, n=1; n<nc; n*=2);
	for(z[0]=0, j=1; j<n; j*=2)
		for(i=0; i<j; z[i]+=z[i], z[i+j]=z[i]+1, i++);
	for(i=0; i<n; v[i]=C(a[i], b[i]), i++);
	for(fft(n), u[n]=u[0], i=0; i<n; v[i]=mul(C((u[i].r+u[n-i].r)/2, (u[i].i-u[n-i].i)/2), C((u[i].i+u[n-i].i)/2, (u[n-i].r-u[i].r)/2)), i++);
	for(fft(n), u[n]=u[0], i=0; i<n; c[i]=fl(u[n-i].r/n), i++);
}
int main()
{
   int i, j, r, c, w, h, k, l, bi, bj;
   scanf("%d%d", &h, &w);
   for(na=h*w, i=0; i<h; i++)
	   for(j=0; j<w; scanf("%d", &m[i][j]), a[i*w+j]=m[i][j], j++);
   scanf("%d%d", &r, &c);
   for(i=0; i<r; i++)
	   for(j=0; j<c; scanf("%d", &g[i][j]), j++);
   for(nb=0, i=r-1; i>=0; i--)
   {
	   for(j=c-1; j>=0; b[nb++]=g[i][j], j--);
	   if(i>0)
		   for(j=0; j<w-c; b[nb++]=0, j++);
   }
   mul(a, na, b, nb, a, na);
   for(i=0; i<h; i++)
	   for(j=0; j<w; s[i+1][j+1]=s[i][j+1]+s[i+1][j]-s[i][j]+m[i][j]*m[i][j], j++);
   for(k=M, i=0; i+r<=h; i++)
	   for(j=0; j+c<=w; j++)
	   {
		   l=s[i+r][j+c]-s[i][j+c]-s[i+r][j]+s[i][j];
		   l-=2*a[(i+r-1)*w+j+c-1];
		   if(l<k) { bi=i; bj=j; k=l; }
	   }
   for(i=0; i<r; i++)
	   for(j=0; j<c; k+=g[i][j]*g[i][j], j++);
   printf("%d\n%d %d\n", k, bi+1, bj+1);
   return 0;
}

----------
====================
----------
ALGORITHMS.356
expert
----------
PROBLEM STATEMENT:
Given an integer, [expression]) and satisfies the following properties:


[expression] must not contain zeroes in its decimal representation. 
The sum of [expression]'s digits. 


Given [expression]'s decimal representation. 
----------
TOP SOLUTION:
----------
#include <iostream>
#include <algorithm>
#include <math.h>

using namespace std;

#define M 30300
#define N 300
#define INF 100000000

int d[M][N], p[M][N], n, len = 1, bon = 10;

void pre(void){
	for (int i = 0; i < n; ++i)
	for (int j = 0; j < N; ++j)
		p[i][j] = d[i][j] = INF;

	for (int i = 1; i <= 9; ++i)
		p[i][i] = i;
}

bool din(void){
	for (int i = 0; i < n; ++i)
	for (int j = 0; j < N && j <= len * 9; ++j)
	for (int k = 1, to = i + bon; k <= 9 && j + k<N; ++k, to += bon){
		if (to >= n)
			to -= n;
		d[to][j + k] = min(d[to][j + k], p[i][j] * k);
	}

	for (int j = 0; j < N; ++j)
	if (p[0][j] <= j)
		return 1;

	for (int i = 0; i < n; ++i)
	for (int j = 0; j < N; ++j){
		p[i][j] = d[i][j];
		d[i][j] = INF;
	}

	return 0;
}

int ans[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 3, 3, 5, 3, 2, 3, 3, 0, 2, 4, 3, 4, 6, 4, 3, 3, 3, 0, 2, 5, 4, 3, 5, 5, 3, 4, 4, 0, 2, 3, 3, 5, 18, 3, 3, 3, 3, 0, 2, 4, 4, 4, 5, 3, 4, 5, 4, 0, 2, 5, 3, 6, 7, 6, 3, 3, 3, 0, 2, 4, 4, 5, 6, 4, 4, 4, 5, 0, 2, 5, 4, 7, 5, 4, 4, 5, 12, 0, 4, 4, 5, 3, 7, 3, 3, 5, 5, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 4, 5, 5, 5, 6, 4, 0, 3, 3, 5, 5, 12, 5, 3, 5, 4, 0, 3, 5, 6, 5, 6, 6, 4, 6, 5, 0, 3, 6, 5, 6, 7, 3, 6, 7, 4, 0, 3, 6, 4, 4, 21, 5, 5, 5, 4, 0, 3, 5, 4, 6, 6, 4, 5, 5, 4, 0, 3, 5, 4, 7, 30, 4, 4, 7, 5, 0, 3, 4, 7, 6, 5, 5, 5, 12, 6, 0, 4, 4, 4, 8, 5, 5, 5, 6, 5, 0, 3, 3, 3, 8, 9, 6, 6, 5, 5, 0, 3, 6, 4, 5, 13, 8, 5, 8, 5, 0, 3, 5, 6, 6, 11, 6, 3, 7, 5, 0, 5, 5, 5, 8, 11, 6, 4, 6, 6, 0, 6, 5, 5, 9, 8, 6, 4, 8, 6, 0, 5, 6, 6, 4, 9, 7, 5, 6, 4, 0, 5, 5, 4, 6, 32, 7, 5, 4, 4, 0, 4, 9, 4, 5, 5, 6, 5, 5, 8, 0, 4, 6, 6, 5, 6, 6, 13, 5, 9, 0, 8, 4, 4, 8, 7, 5, 7, 6, 5, 0, 3, 3, 6, 7, 12, 7, 4, 6, 5, 0, 3, 6, 6, 6, 14, 7, 5, 4, 6, 0, 6, 6, 6, 6, 9, 5, 5, 8, 8, 0, 6, 11, 6, 6, 9, 6, 7, 6, 6, 0, 5, 4, 4, 6, 6, 7, 7, 5, 6, 0, 5, 5, 7, 5, 12, 8, 5, 9, 9, 0, 4, 4, 4, 4, 7, 7, 4, 6, 6, 0, 5, 6, 6, 6, 18, 8, 4, 7, 4, 0, 5, 5, 6, 7, 14, 12, 4, 7, 6, 0, 7, 9, 8, 4, 12, 5, 4, 8, 6, 0, 3, 5, 5, 5, 10, 10, 7, 5, 5, 0, 7, 6, 5, 6, 13, 6, 6, 8, 6, 0, 6, 6, 7, 7, 10, 7, 4, 6, 5, 0, 5, 8, 6, 6, 5, 9, 6, 10, 7, 0, 7, 8, 6, 8, 18, 8, 8, 10, 5, 0, 7, 8, 5, 9, 7, 8, 8, 6, 5, 0, 8, 6, 8, 7, 15, 9, 6, 10, 7, 0, 6, 6, 7, 5, 14, 7, 8, 8, 7, 0, 5, 6, 5, 9, 27, 8, 5, 6, 8, 0, 6, 8, 7, 5, 20, 5, 8, 9, 5, 0, 3, 7, 5, 4, 5, 8, 7, 6, 7, 0, 6, 6, 5, 6, 15, 6, 5, 4, 5, 0, 5, 10, 7, 5, 12, 6, 4, 7, 6, 0, 7, 23, 7, 7, 12, 6, 4, 6, 5, 0, 5, 7, 9, 8, 61, 4, 4, 4, 4, 0, 4, 4, 8, 9, 14, 4, 6, 7, 6, 0, 4, 6, 6, 6, 12, 6, 7, 8, 7, 0, 8, 6, 7, 8, 5, 9, 5, 5, 5, 0, 5, 8, 8, 13, 10, 5, 7, 9, 6, 0, 7, 8, 9, 8, 18, 4, 4, 11, 7, 0, 3, 9, 8, 10, 9, 6, 5, 5, 5, 0, 5, 7, 5, 8, 23, 9, 8, 7, 9, 0, 5, 7, 6, 5, 6, 6, 4, 5, 5, 0, 7, 8, 10, 6, 13, 6, 7, 7, 7, 0, 6, 8, 6, 5, 10, 4, 5, 9, 5, 0, 7, 6, 7, 6, 7, 6, 6, 8, 7, 0, 7, 5, 5, 9, 13, 8, 7, 8, 4, 0, 5, 9, 5, 12, 16, 6, 6, 9, 7, 0, 5, 6, 12, 9, 9, 6, 5, 7, 6, 0, 7, 13, 7, 4, 15, 4, 4, 6, 6, 0, 3, 7, 5, 8, 18, 9, 6, 9, 6, 0, 8, 9, 5, 8, 12, 8, 6, 5, 5, 0, 6, 8, 9, 8, 15, 9, 4, 13, 7, 0, 5, 7, 8, 8, 9, 9, 6, 8, 8, 0, 8, 10, 6, 5, 7, 6, 5, 10, 7, 0, 7, 10, 5, 12, 12, 9, 6, 6, 8, 0, 8, 8, 6, 9, 14, 7, 6, 4, 8, 0, 7, 5, 5, 5, 16, 6, 8, 7, 7, 0, 6, 12, 5, 5, 13, 7, 7, 7, 5, 0, 5, 11, 8, 9, 11, 12, 7, 5, 6, 0, 3, 5, 8, 8, 14, 10, 6, 8, 6, 0, 9, 6, 6, 8, 34, 11, 8, 7, 8, 0, 8, 11, 6, 10, 16, 8, 6, 9, 5, 0, 8, 9, 7, 8, 16, 11, 6, 6, 5, 0, 6, 6, 9, 8, 5, 8, 5, 8, 8, 0, 6, 7, 8, 11, 14, 9, 8, 9, 10, 0, 6, 7, 4, 8, 6, 6, 6, 8, 6, 0, 8, 5, 6, 8, 14, 8, 6, 6, 6, 0, 13, 9, 5, 6, 15, 11, 9, 7, 9, 0, 8, 9, 8, 8, 15, 9, 8, 8, 12, 0, 3, 11, 7, 10, 15, 11, 6, 5, 8, 0, 7, 9, 9, 8, 53, 5, 5, 10, 9, 0, 8, 8, 6, 8, 20, 9, 8, 9, 6, 0, 7, 11, 8, 6, 12, 11, 5, 7, 8, 0, 5, 12, 7, 6, 13, 11, 8, 7, 6, 0, 9, 6, 10, 6, 15, 13, 6, 8, 6, 0, 6, 7, 6, 8, 18, 8, 7, 8, 8, 0, 7, 6, 8, 6, 14, 7, 9, 9, 11, 0, 8, 8, 6, 7, 8, 6, 11, 9, 21, 0, 6, 6, 8, 8, 15, 9, 7, 5, 8, 0, 5, 5, 7, 8, 11, 9, 9, 10, 8, 0, 5, 11, 8, 7, 17, 11, 7, 4, 6, 0, 8, 9, 7, 7, 13, 6, 4, 7, 6, 0, 8, 9, 8, 6, 18, 9, 8, 8, 9, 0, 7, 6, 9, 9, 15, 4, 4, 8, 9, 0, 7, 10, 8, 10, 15, 8, 7, 7, 8, 0, 11, 10, 6, 12, 14, 7, 9, 6, 10, 0, 8, 7, 10, 23, 15, 11, 8, 7, 12, 0, 6, 6, 7, 8, 12, 6, 7, 10, 13, 0, 5, 5, 6, 9, 9, 9, 9, 8, 9, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 13, 10, 7, 9, 8, 0, 4, 4, 8, 6, 14, 7, 6, 6, 7, 0, 4, 4, 7, 6, 9, 6, 8, 7, 8, 0, 4, 6, 5, 8, 21, 8, 11, 12, 8, 0, 4, 10, 9, 7, 14, 8, 7, 10, 5, 0, 4, 9, 5, 13, 15, 5, 8, 7, 8, 0, 4, 12, 8, 8, 15, 8, 7, 13, 10, 0, 4, 5, 6, 8, 13, 9, 6, 12, 8, 0, 5, 9, 8, 10, 15, 9, 9, 8, 8, 0, 4, 4, 4, 4, 21, 11, 7, 11, 10, 0, 4, 14, 7, 9, 18, 9, 6, 10, 8, 0, 4, 6, 11, 9, 5, 5, 5, 5, 5, 0, 4, 5, 5, 7, 13, 5, 7, 10, 5, 0, 12, 9, 7, 8, 10, 7, 5, 9, 5, 0, 8, 8, 9, 7, 21, 13, 8, 5, 5, 0, 5, 6, 8, 6, 13, 10, 9, 9, 5, 0, 7, 11, 6, 8, 14, 12, 12, 10, 7, 0, 6, 6, 8, 10, 38, 13, 6, 12, 8, 0, 11, 7, 9, 8, 20, 11, 7, 7, 7, 0, 4, 4, 7, 13, 7, 9, 7, 11, 6, 0, 4, 10, 6, 6, 15, 13, 8, 9, 6, 0, 6, 6, 8, 7, 15, 8, 8, 9, 9, 0, 6, 8, 7, 11, 14, 5, 9, 9, 5, 0, 9, 9, 8, 7, 52, 10, 5, 12, 6, 0, 9, 12, 9, 10, 50, 10, 7, 12, 7, 0, 8, 6, 6, 13, 32, 11, 10, 12, 5, 0, 9, 5, 9, 7, 14, 12, 6, 9, 5, 0, 8, 9, 8, 5, 13, 7, 10, 8, 9, 0, 8, 9, 8, 13, 16, 8, 10, 11, 6, 0, 4, 4, 11, 5, 12, 6, 8, 7, 9, 0, 4, 9, 5, 7, 18, 8, 9, 9, 10, 0, 11, 9, 8, 13, 15, 12, 7, 12, 5, 0, 6, 11, 6, 9, 12, 6, 7, 10, 11, 0, 8, 8, 6, 12, 15, 6, 5, 10, 5, 0, 8, 6, 7, 8, 14, 11, 9, 8, 6, 0, 7, 10, 6, 11, 15, 13, 6, 13, 5, 0, 7, 9, 7, 7, 27, 9, 11, 8, 8, 0, 5, 12, 9, 6, 14, 8, 8, 8, 11, 0, 9, 8, 6, 10, 14, 9, 8, 5, 11, 0, 4, 7, 5, 5, 21, 11, 9, 9, 6, 0, 11, 8, 5, 10, 12, 9, 8, 12, 7, 0, 8, 9, 8, 6, 7, 13, 7, 9, 9, 0, 8, 8, 8, 8, 18, 6, 7, 9, 8, 0, 9, 7, 8, 6, 16, 4, 9, 12, 8, 0, 8, 7, 10, 9, 6, 11, 10, 5, 5, 0, 6, 6, 6, 12, 21, 7, 6, 8, 5, 0, 9, 11, 10, 13, 14, 12, 9, 5, 5, 0, 10, 7, 5, 7, 18, 12, 7, 9, 9, 0, 10, 5, 5, 11, 14, 11, 10, 9, 8, 0, 4, 12, 8, 7, 15, 5, 7, 8, 6, 0, 8, 10, 11, 5, 14, 32, 5, 8, 10, 0, 6, 13, 7, 6, 17, 8, 10, 6, 5, 0, 8, 11, 7, 6, 11, 9, 5, 8, 8, 0, 7, 11, 8, 11, 14, 7, 9, 10, 10, 0, 7, 8, 6, 13, 61, 7, 8, 10, 8, 0, 7, 8, 5, 10, 9, 9, 8, 10, 5, 0, 5, 14, 12, 9, 19, 8, 8, 8, 8, 0, 9, 11, 7, 10, 15, 6, 7, 8, 6, 0, 7, 12, 6, 8, 18, 9, 9, 8, 11, 0, 4, 14, 5, 12, 14, 8, 8, 10, 12, 0, 8, 14, 8, 11, 15, 11, 7, 13, 7, 0, 8, 9, 5, 8, 9, 10, 7, 12, 7, 0, 9, 6, 8, 12, 15, 13, 10, 9, 7, 0, 13, 9, 10, 11, 21, 8, 6, 13, 8, 0, 7, 8, 9, 5, 12, 7, 6, 8, 10, 0, 9, 8, 5, 12, 16, 8, 8, 9, 8, 0, 8, 13, 6, 9, 12, 9, 9, 6, 9, 0, 7, 14, 8, 9, 17, 7, 6, 9, 8, 0, 7, 8, 9, 9, 16, 11, 7, 12, 10, 0, 4, 9, 6, 9, 21, 8, 10, 12, 9, 0, 6, 6, 9, 11, 29, 10, 9, 10, 8, 0, 8, 11, 9, 8, 17, 11, 8, 10, 8, 0, 8, 14, 10, 11, 21, 11, 7, 8, 10, 0, 10, 5, 5, 5, 16, 12, 5, 9, 9, 0, 7, 9, 6, 8, 14, 13, 10, 8, 5, 0, 9, 10, 5, 12, 23, 9, 8, 11, 9, 0, 12, 10, 10, 11, 6, 8, 9, 11, 5, 0, 10, 11, 5, 10, 12, 7, 8, 12, 9, 0, 8, 5, 7, 13, 15, 11, 11, 6, 8, 0, 4, 11, 9, 14, 13, 7, 9, 6, 10, 0, 5, 13, 10, 6, 34, 10, 10, 10, 10, 0, 11, 13, 6, 10, 13, 11, 8, 15, 10, 0, 9, 13, 7, 7, 13, 7, 8, 8, 12, 0, 9, 12, 6, 11, 17, 8, 9, 12, 8, 0, 9, 7, 7, 6, 10, 13, 8, 6, 9, 0, 11, 12, 6, 9, 14, 9, 11, 11, 10, 0, 7, 10, 10, 12, 14, 6, 11, 7, 11, 0, 8, 6, 8, 12, 7, 9, 13, 22, 10, 0, 6, 6, 11, 14, 12, 13, 10, 8, 7, 0, 5, 9, 7, 7, 14, 5, 10, 13, 5, 0, 11, 12, 8, 9, 13, 11, 10, 8, 10, 0, 7, 9, 9, 11, 30, 10, 4, 8, 8, 0, 8, 12, 11, 11, 15, 9, 7, 7, 8, 0, 6, 13, 10, 7, 23, 4, 8, 6, 7, 0, 6, 8, 9, 9, 14, 11, 7, 7, 11, 0, 7, 12, 11, 14, 17, 7, 9, 6, 13, 0, 7, 9, 8, 9, 21, 8, 8, 6, 8, 0, 9, 9, 11, 14, 11, 8, 6, 13, 8, 0, 5, 8, 7, 6, 13, 13, 9, 9, 7, 0, 4, 4, 4, 4, 20, 8, 8, 9, 9, 0, 4, 12, 8, 10, 13, 13, 7, 10, 8, 0, 4, 9, 9, 7, 11, 7, 6, 13, 11, 0, 4, 13, 10, 13, 22, 12, 10, 13, 9, 0, 6, 7, 9, 13, 14, 6, 8, 10, 7, 0, 8, 9, 8, 8, 15, 13, 8, 23, 5, 0, 8, 11, 5, 8, 15, 7, 6, 12, 9, 0, 6, 8, 11, 8, 13, 8, 8, 8, 7, 0, 8, 13, 11, 12, 18, 12, 9, 14, 11, 0, 8, 10, 9, 10, 21, 10, 6, 13, 7, 0, 4, 9, 8, 13, 15, 9, 11, 12, 9, 0, 8, 12, 5, 12, 5, 7, 9, 12, 9, 0, 8, 9, 9, 11, 9, 9, 8, 13, 8, 0, 10, 12, 5, 8, 10, 9, 8, 8, 7, 0, 9, 10, 11, 7, 23, 11, 8, 12, 9, 0, 10, 14, 7, 8, 7, 12, 7, 6, 6, 0, 11, 11, 9, 13, 90, 6, 12, 14, 7, 0, 7, 8, 9, 5, 8, 13, 6, 6, 6, 0, 9, 13, 10, 8, 12, 7, 10, 13, 8, 0, 11, 10, 12, 6, 11, 8, 8, 8, 11, 0, 4, 8, 8, 13, 14, 12, 6, 8, 6, 0, 6, 9, 8, 10, 21, 11, 9, 7, 6, 0, 6, 8, 8, 14, 19, 11, 8, 9, 9, 0, 10, 14, 13, 9, 16, 5, 12, 13, 5, 0, 9, 5, 8, 11, 16, 10, 8, 13, 8, 0, 8, 13, 11, 12, 21, 11, 10, 19, 9, 0, 9, 10, 11, 9, 15, 13, 11, 13, 5, 0, 11, 9, 9, 11, 13, 10, 8, 11, 10, 0, 7, 9, 7, 12, 14, 13, 9, 12, 6, 0, 8, 13, 7, 9, 56, 11, 10, 10, 9, 0, 4, 9, 7, 11, 15, 10, 11, 13, 6, 0, 7, 6, 5, 8, 26, 15, 6, 6, 8, 0, 7, 14, 8, 11, 16, 11, 11, 11, 17, 0, 10, 8, 10, 14, 15, 11, 12, 13, 8, 0, 9, 9, 8, 8, 7, 10, 9, 11, 8, 0, 10, 7, 9, 10, 14, 13, 8, 9, 9, 0, 9, 8, 10, 13, 45, 13, 7, 11, 11, 0, 11, 10, 10, 11, 21, 8, 10, 7, 10, 0, 9, 7, 11, 9, 15, 11, 7, 10, 11, 0, 9, 14, 10, 9, 18, 15, 11, 8, 11, 0, 10, 8, 6, 13, 17, 9, 8, 13, 13, 0, 11, 13, 8, 8, 92, 9, 9, 12, 11, 0, 8, 13, 9, 10, 16, 7, 7, 11, 10, 0, 8, 9, 11, 6, 19, 8, 5, 6, 9, 0, 7, 10, 6, 9, 12, 9, 9, 11, 9, 0, 7, 8, 10, 11, 21, 11, 7, 8, 8, 0, 6, 12, 8, 12, 8, 10, 8, 7, 10, 0, 7, 11, 9, 6, 22, 13, 6, 10, 9, 0, 9, 13, 10, 12, 16, 12, 7, 9, 8, 0, 9, 13, 8, 10, 22, 9, 10, 9, 10, 0, 9, 11, 11, 7, 18, 7, 10, 11, 11, 0, 7, 9, 10, 14, 15, 8, 7, 13, 10, 0, 6, 12, 7, 8, 18, 11, 11, 9, 5, 0, 12, 12, 8, 10, 10, 6, 10, 6, 10, 0, 7, 13, 11, 8, 21, 11, 5, 8, 7, 0, 9, 10, 11, 6, 10, 13, 11, 10, 9, 0, 7, 9, 13, 17, 14, 9, 6, 12, 5, 0, 9, 6, 9, 8, 15, 11, 6, 11, 10, 0, 11, 9, 11, 9, 20, 9, 10, 12, 8, 0, 9, 10, 9, 15, 14, 9, 8, 7, 12, 0, 6, 10, 9, 8, 15, 12, 7, 10, 11, 0, 8, 13, 12, 14, 16, 10, 13, 10, 8, 0, 6, 10, 8, 10, 15, 13, 7, 12, 8, 0, 10, 11, 6, 7, 20, 12, 9, 13, 7, 0, 8, 11, 7, 11, 14, 13, 10, 13, 11, 0, 12, 9, 11, 5, 16, 13, 7, 12, 13, 0, 7, 13, 8, 10, 189, 9, 10, 5, 5, 0, 5, 12, 5, 17, 7, 10, 9, 5, 8, 0, 9, 7, 8, 12, 14, 8, 9, 13, 6, 0, 7, 9, 5, 11, 22, 10, 12, 13, 8, 0, 8, 8, 10, 13, 15, 18, 6, 9, 12, 0, 8, 13, 7, 9, 15, 13, 9, 5, 8, 0, 8, 6, 12, 8, 12, 7, 9, 12, 8, 0, 8, 7, 10, 9, 22, 11, 8, 7, 6, 0, 13, 8, 5, 10, 11, 13, 13, 13, 7, 0, 13, 11, 10, 10, 23, 13, 11, 13, 12, 0, 12, 12, 8, 7, 12, 14, 6, 5, 9, 0, 11, 10, 9, 12, 16, 6, 13, 9, 10, 0, 7, 6, 13, 14, 15, 10, 8, 13, 8, 0, 6, 13, 12, 13, 10, 6, 6, 12, 11, 0, 7, 12, 9, 10, 23, 12, 7, 10, 10, 0, 7, 8, 10, 6, 30, 12, 11, 8, 9, 0, 8, 11, 10, 11, 19, 11, 8, 11, 8, 0, 11, 12, 11, 11, 11, 6, 7, 11, 8, 0, 8, 13, 12, 6, 21, 13, 11, 14, 10, 0, 10, 13, 7, 9, 12, 11, 13, 7, 10, 0, 10, 9, 9, 11, 20, 8, 8, 11, 7, 0, 8, 14, 10, 13, 18, 13, 10, 6, 10, 0, 11, 10, 9, 9, 17, 8, 21, 15, 12, 0, 11, 10, 6, 8, 17, 6, 7, 10, 11, 0, 9, 9, 11, 10, 21, 5, 8, 14, 8, 0, 7, 13, 11, 13, 32, 12, 8, 5, 8, 0, 9, 11, 6, 9, 10, 9, 4, 9, 10, 0, 8, 13, 7, 10, 21, 9, 10, 10, 11, 0, 11, 9, 5, 12, 20, 13, 8, 7, 11, 0, 7, 11, 10, 9, 17, 11, 9, 6, 12, 0, 6, 13, 5, 7, 27, 9, 13, 13, 8, 0, 8, 13, 8, 8, 21, 10, 6, 13, 8, 0, 9, 6, 9, 12, 18, 9, 7, 8, 8, 0, 8, 13, 11, 11, 21, 10, 10, 6, 8, 0, 4, 4, 7, 11, 16, 12, 6, 9, 9, 0, 4, 9, 11, 7, 139, 11, 11, 9, 11, 0, 8, 11, 9, 14, 21, 13, 10, 16, 10, 0, 10, 6, 10, 8, 33, 12, 9, 12, 8, 0, 8, 7, 8, 11, 18, 8, 8, 9, 9, 0, 6, 11, 11, 14, 15, 11, 8, 13, 9, 0, 8, 13, 5, 11, 6, 11, 12, 10, 10, 0, 8, 12, 11, 7, 24, 10, 10, 7, 11, 0, 9, 12, 10, 7, 21, 9, 6, 9, 10, 0, 9, 10, 9, 7, 12, 11, 12, 11, 12, 0, 4, 11, 11, 12, 12, 11, 9, 13, 6, 0, 8, 12, 11, 13, 23, 12, 10, 7, 11, 0, 10, 8, 8, 12, 23, 13, 10, 9, 11, 0, 8, 8, 9, 12, 23, 12, 7, 10, 13, 0, 13, 32, 12, 14, 15, 8, 8, 13, 12, 0, 11, 12, 7, 13, 9, 15, 13, 6, 8, 0, 6, 8, 8, 10, 23, 6, 9, 5, 7, 0, 10, 8, 9, 11, 12, 7, 12, 6, 11, 0, 11, 9, 13, 13, 17, 8, 13, 9, 11, 0, 13, 9, 6, 11, 17, 13, 7, 11, 8, 0, 9, 13, 8, 9, 9, 10, 12, 14, 11, 0, 11, 12, 8, 8, 20, 11, 11, 17, 8, 0, 9, 15, 9, 11, 11, 10, 7, 11, 11, 0, 9, 14, 8, 8, 18, 16, 9, 10, 9, 0, 6, 9, 10, 9, 27, 10, 11, 13, 8, 0, 9, 12, 8, 14, 14, 13, 6, 9, 14, 0, 9, 8, 10, 8, 13, 12, 10, 12, 8, 0, 7, 16, 7, 11, 16, 12, 8, 10, 10, 0, 12, 6, 9, 10, 18, 8, 9, 15, 8, 0, 9, 7, 9, 12, 18, 10, 8, 15, 10, 0, 11, 9, 9, 13, 18, 8, 11, 12, 11, 0, 6, 15, 8, 15, 23, 5, 10, 12, 12, 0, 10, 8, 11, 11, 9, 10, 8, 13, 7, 0, 8, 12, 10, 14, 22, 9, 13, 11, 10, 0, 7, 11, 8, 13, 10, 13, 5, 11, 5, 0, 6, 8, 7, 9, 27, 14, 12, 8, 12, 0, 11, 14, 10, 13, 19, 12, 8, 9, 5, 0, 11, 16, 10, 6, 15, 13, 7, 20, 9, 0, 11, 13, 12, 12, 15, 9, 11, 8, 11, 0, 12, 16, 10, 17, 19, 13, 12, 12, 10, 0, 11, 11, 13, 8, 33, 13, 10, 13, 5, 0, 10, 14, 8, 8, 15, 9, 8, 5, 9, 0, 8, 7, 10, 7, 32, 11, 9, 10, 14, 0, 13, 10, 13, 8, 18, 13, 10, 12, 9, 0, 10, 8, 9, 12, 21, 9, 11, 13, 11, 0, 11, 12, 9, 13, 19, 6, 10, 11, 8, 0, 12, 9, 12, 9, 36, 6, 11, 9, 6, 0, 7, 14, 10, 15, 23, 12, 11, 9, 8, 0, 6, 7, 8, 14, 15, 9, 8, 8, 10, 0, 10, 13, 11, 8, 19, 9, 12, 9, 8, 0, 9, 11, 12, 7, 15, 12, 8, 13, 10, 0, 9, 14, 8, 9, 12, 17, 11, 9, 6, 0, 9, 14, 10, 12, 14, 13, 7, 12, 10, 0, 10, 6, 7, 8, 21, 13, 6, 11, 10, 0, 9, 10, 12, 11, 23, 10, 10, 12, 9, 0, 9, 11, 13, 14, 18, 14, 7, 8, 12, 0, 8, 11, 12, 13, 21, 10, 7, 9, 5, 0, 6, 12, 8, 14, 20, 12, 8, 11, 10, 0, 11, 11, 7, 13, 15, 13, 10, 12, 12, 0, 7, 13, 9, 5, 5, 5, 5, 5, 9, 0, 5, 12, 12, 5, 14, 9, 5, 12, 7, 0, 11, 8, 6, 13, 14, 14, 5, 11, 11, 0, 8, 13, 8, 11, 13, 8, 5, 5, 9, 0, 9, 11, 7, 10, 14, 11, 5, 12, 6, 0, 9, 9, 13, 14, 24, 11, 11, 12, 9, 0, 9, 12, 7, 10, 16, 14, 9, 11, 12, 0, 5, 8, 11, 9, 16, 11, 5, 5, 8, 0, 10, 10, 10, 11, 24, 10, 12, 10, 11, 0, 8, 13, 9, 23, 21, 12, 9, 13, 8, 0, 9, 12, 12, 5, 15, 8, 5, 20, 10, 0, 8, 13, 9, 12, 12, 6, 9, 11, 11, 0, 7, 11, 12, 19, 13, 13, 7, 14, 8, 0, 13, 7, 9, 13, 6, 6, 5, 10, 6, 0, 6, 13, 10, 13, 16, 16, 9, 12, 6, 0, 8, 11, 9, 14, 20, 10, 9, 16, 6, 0, 13, 15, 8, 13, 15, 6, 9, 10, 7, 0, 10, 14, 11, 12, 14, 15, 12, 12, 13, 0, 10, 13, 10, 13, 109, 12, 11, 13, 5, 0, 8, 7, 8, 12, 17, 12, 13, 13, 7, 0, 13, 15, 13, 14, 23, 13, 13, 11, 11, 0, 8, 8, 9, 17, 21, 13, 11, 13, 11, 0, 8, 14, 9, 7, 19, 10, 7, 6, 8, 0, 8, 13, 12, 9, 13, 21, 5, 14, 8, 0, 11, 13, 9, 12, 7, 15, 14, 9, 8, 0, 13, 11, 6, 11, 14, 11, 9, 11, 9, 0, 9, 15, 11, 14, 15, 10, 7, 12, 6, 0, 11, 6, 8, 13, 15, 7, 11, 13, 6, 0, 11, 12, 10, 13, 14, 12, 6, 12, 12, 0, 9, 9, 9, 13, 14, 22, 7, 11, 8, 0, 10, 14, 9, 6, 20, 14, 8, 14, 11, 0, 12, 13, 9, 10, 18, 8, 9, 7, 9, 0, 13, 11, 11, 9, 12, 8, 11, 14, 11, 0, 11, 13, 11, 10, 14, 13, 5, 5, 11, 0, 12, 11, 6, 12, 21, 13, 5, 9, 9, 0, 15, 11, 12, 10, 14, 9, 8, 10, 13, 0, 12, 7, 10, 17, 52, 12, 8, 11, 10, 0, 9, 10, 13, 14, 18, 8, 10, 15, 11, 0, 7, 16, 9, 12, 16, 12, 11, 11, 12, 0, 9, 13, 12, 8, 61, 7, 10, 14, 7, 0, 10, 16, 9, 13, 18, 12, 7, 11, 11, 0, 4, 4, 12, 11, 21, 6, 9, 7, 6, 0, 4, 13, 6, 10, 34, 11, 9, 12, 8, 0, 12, 12, 12, 15, 22, 7, 5, 11, 12, 0, 7, 17, 9, 13, 17, 16, 11, 14, 12, 0, 11, 7, 6, 9, 18, 6, 10, 13, 13, 0, 6, 13, 7, 9, 17, 14, 9, 9, 12, 0, 10, 13, 8, 11, 23, 13, 9, 13, 10, 0, 11, 14, 5, 9, 19, 13, 9, 15, 9, 0, 10, 15, 6, 12, 21, 13, 9, 11, 11, 0, 10, 12, 11, 8, 13, 14, 9, 15, 12, 0, 4, 13, 9, 13, 21, 9, 9, 8, 10, 0, 10, 12, 5, 13, 23, 9, 11, 8, 8, 0, 9, 11, 14, 15, 25, 9, 11, 11, 13, 0, 7, 13, 10, 13, 12, 8, 9, 10, 8, 0, 8, 13, 12, 13, 30, 15, 12, 11, 12, 0, 7, 12, 13, 9, 16, 13, 10, 7, 5, 0, 9, 18, 9, 6, 21, 13, 10, 12, 8, 0, 9, 14, 10, 13, 18, 10, 11, 17, 12, 0, 9, 12, 11, 12, 18, 13, 8, 15, 13, 0, 10, 13, 11, 11, 21, 12, 8, 14, 6, 0, 10, 6, 12, 16, 8, 10, 11, 14, 11, 0, 6, 12, 9, 13, 19, 12, 7, 8, 6, 0, 13, 13, 9, 13, 12, 26, 7, 13, 9, 0, 11, 14, 9, 13, 25, 11, 12, 13, 13, 0, 7, 7, 11, 13, 17, 13, 9, 10, 11, 0, 8, 15, 10, 8, 21, 13, 10, 13, 9, 0, 5, 8, 9, 12, 23, 8, 5, 10, 11, 0, 8, 9, 10, 13, 13, 14, 10, 12, 12, 0, 10, 12, 11, 10, 15, 14, 9, 13, 7, 0, 9, 9, 12, 15, 20, 13, 11, 10, 10, 0, 12, 10, 11, 14, 14, 13, 12, 13, 6, 0, 12, 13, 11, 9, 30, 8, 13, 13, 12, 0, 9, 13, 8, 16, 15, 12, 5, 15, 9, 0, 11, 15, 11, 12, 6, 13, 8, 19, 11, 0, 8, 9, 8, 12, 27, 12, 12, 9, 10, 0, 13, 11, 9, 12, 17, 14, 10, 11, 14, 0, 9, 9, 5, 8, 17, 14, 9, 15, 9, 0, 12, 13, 7, 12, 21, 6, 11, 8, 12, 0, 9, 9, 6, 8, 22, 8, 11, 10, 14, 0, 11, 13, 9, 12, 18, 12, 10, 13, 6, 0, 7, 14, 6, 8, 15, 12, 11, 13, 8, 0, 9, 12, 6, 14, 19, 16, 13, 8, 13, 0, 11, 12, 11, 10, 15, 7, 8, 14, 11, 0, 10, 14, 7, 11, 28, 12, 11, 13, 10, 0, 9, 6, 9, 12, 15, 14, 10, 11, 13, 0, 13, 9, 13, 8, 21, 13, 8, 5, 5, 0, 11, 14, 9, 8, 23, 12, 7, 13, 5, 0, 12, 13, 7, 13, 15, 10, 10, 8, 10, 0, 10, 13, 8, 14, 23, 13, 10, 8, 11, 0, 10, 13, 11, 10, 7, 16, 13, 13, 10, 0, 7, 8, 10, 10, 15, 8, 9, 11, 12, 0, 10, 10, 13, 12, 53, 13, 8, 13, 11, 0, 10, 12, 9, 6, 19, 8, 13, 6, 10, 0, 7, 12, 7, 9, 16, 12, 8, 10, 7, 0, 8, 11, 13, 14, 17, 15, 12, 10, 8, 0, 12, 6, 10, 11, 18, 11, 12, 14, 7, 0, 9, 11, 9, 16, 34, 9, 12, 9, 5, 0, 7, 13, 9, 14, 14, 14, 13, 11, 11, 0, 10, 9, 11, 12, 15, 13, 7, 11, 12, 0, 14, 12, 10, 5, 18, 8, 5, 12, 11, 0, 8, 10, 6, 17, 21, 13, 13, 14, 8, 0, 15, 15, 8, 13, 29, 16, 8, 12, 10, 0, 11, 12, 13, 13, 12, 40, 5, 12, 13, 0, 9, 13, 9, 10, 17, 11, 12, 9, 10, 0, 8, 13, 12, 14, 18, 13, 10, 12, 13, 0, 9, 14, 8, 9, 18, 15, 8, 15, 9, 0, 8, 10, 10, 12, 20, 11, 14, 17, 12, 0, 11, 7, 13, 13, 21, 13, 7, 12, 11, 0, 7, 14, 10, 9, 16, 12, 9, 6, 12, 0, 12, 13, 10, 13, 15, 7, 11, 9, 7, 0, 7, 11, 11, 14, 19, 11, 16, 13, 9, 0, 12, 12, 7, 9, 33, 14, 8, 11, 8, 0, 6, 14, 13, 16, 17, 13, 6, 6, 9, 0, 7, 7, 9, 6, 15, 13, 8, 8, 9, 0, 12, 15, 12, 14, 16, 6, 6, 9, 7, 0, 10, 12, 9, 14, 23, 12, 11, 11, 12, 0, 9, 11, 9, 15, 18, 11, 7, 36, 12, 0, 11, 12, 14, 8, 21, 14, 11, 14, 9, 0, 10, 11, 6, 15, 28, 13, 11, 12, 9, 0, 11, 13, 8, 9, 21, 12, 10, 8, 10, 0, 10, 14, 8, 22, 8, 13, 13, 12, 8, 0, 12, 12, 8, 7, 33, 13, 12, 10, 7, 0, 12, 13, 14, 8, 15, 9, 9, 9, 12, 0, 13, 12, 10, 8, 14, 13, 9, 13, 10, 0, 12, 13, 11, 7, 15, 11, 9, 11, 9, 0, 12, 13, 7, 10, 15, 11, 7, 11, 10, 0, 9, 8, 9, 10, 20, 11, 10, 15, 9, 0, 8, 12, 7, 7, 16, 13, 10, 9, 10, 0, 10, 13, 12, 12, 78, 10, 13, 17, 11, 0, 8, 12, 10, 14, 18, 14, 11, 12, 12, 0, 14, 15, 11, 13, 17, 8, 13, 12, 11, 0, 10, 14, 14, 8, 23, 12, 12, 13, 13, 0, 12, 9, 8, 17, 21, 13, 5, 14, 9, 0, 11, 11, 14, 13, 17, 14, 10, 8, 13, 0, 6, 12, 11, 15, 21, 12, 13, 11, 10, 0, 8, 12, 8, 13, 16, 18, 11, 12, 9, 0, 7, 11, 10, 11, 12, 11, 10, 13, 14, 0, 11, 12, 10, 9, 21, 14, 11, 6, 9, 0, 7, 8, 8, 14, 21, 6, 6, 12, 12, 0, 13, 15, 8, 13, 15, 12, 10, 9, 10, 0, 4, 9, 10, 12, 22, 12, 12, 15, 12, 0, 10, 13, 13, 8, 17, 12, 11, 11, 14, 0, 9, 11, 8, 9, 17, 14, 8, 8, 5, 0, 8, 12, 12, 12, 17, 13, 11, 13, 12, 0, 8, 10, 10, 13, 19, 9, 12, 12, 10, 0, 10, 14, 12, 11, 15, 14, 9, 12, 8, 0, 11, 14, 9, 11, 21, 10, 9, 17, 9, 0, 8, 14, 9, 13, 20, 11, 9, 12, 9, 0, 9, 12, 10, 10, 21, 9, 8, 12, 12, 0, 10, 11, 12, 13, 9, 10, 11, 10, 9, 0, 13, 9, 8, 18, 10, 9, 7, 13, 8, 0, 11, 9, 13, 11, 32, 14, 14, 7, 10, 0, 11, 14, 11, 14, 15, 12, 11, 13, 12, 0, 13, 17, 13, 9, 17, 12, 14, 14, 14, 0, 8, 8, 13, 12, 22, 13, 8, 13, 10, 0, 8, 12, 14, 15, 21, 7, 6, 8, 8, 0, 6, 11, 10, 13, 23, 9, 12, 5, 12, 0, 11, 13, 12, 12, 10, 8, 11, 10, 9, 0, 6, 6, 8, 10, 12, 6, 11, 10, 7, 0, 6, 13, 5, 13, 17, 13, 13, 8, 10, 0, 9, 11, 9, 18, 15, 8, 13, 15, 8, 0, 9, 15, 12, 10, 24, 12, 8, 13, 11, 0, 12, 13, 9, 14, 31, 10, 11, 18, 12, 0, 6, 12, 8, 14, 14, 13, 12, 17, 12, 0, 12, 9, 9, 11, 12, 12, 8, 13, 13, 0, 9, 13, 11, 6, 36, 13, 12, 8, 7, 0, 11, 14, 7, 10, 14, 17, 13, 14, 14, 0, 13, 13, 9, 9, 21, 13, 8, 9, 8, 0, 6, 12, 11, 13, 12, 14, 8, 8, 8, 0, 12, 16, 12, 10, 26, 14, 12, 19, 13, 0, 7, 9, 8, 8, 18, 7, 11, 12, 11, 0, 11, 14, 10, 16, 23, 13, 10, 8, 12, 0, 7, 12, 11, 12, 13, 13, 9, 11, 6, 0, 11, 16, 13, 13, 27, 13, 13, 14, 10, 0, 12, 10, 8, 13, 12, 11, 11, 8, 11, 0, 13, 14, 6, 10, 21, 14, 11, 10, 13, 0, 12, 14, 10, 7, 29, 12, 9, 13, 8, 0, 9, 11, 12, 11, 20, 20, 12, 13, 13, 0, 13, 12, 8, 14, 19, 13, 11, 15, 9, 0, 10, 8, 11, 11, 17, 7, 10, 11, 11, 0, 13, 13, 8, 10, 20, 15, 13, 15, 11, 0, 11, 12, 11, 9, 17, 14, 8, 5, 13, 0, 9, 13, 10, 14, 21, 16, 11, 16, 9, 0, 7, 10, 11, 13, 27, 14, 13, 10, 10, 0, 7, 9, 11, 12, 129, 5, 5, 5, 5, 0, 5, 5, 13, 12, 16, 5, 9, 18, 10, 0, 5, 10, 12, 9, 25, 5, 9, 17, 12, 0, 14, 9, 7, 7, 15, 9, 9, 12, 7, 0, 11, 8, 9, 14, 22, 13, 11, 13, 11, 0, 13, 11, 10, 9, 14, 5, 5, 11, 10, 0, 5, 10, 11, 15, 23, 14, 9, 12, 13, 0, 10, 15, 10, 8, 29, 14, 13, 13, 9, 0, 8, 18, 11, 13, 11, 9, 9, 13, 12, 0, 10, 12, 13, 14, 18, 14, 14, 11, 11, 0, 9, 13, 11, 11, 18, 5, 12, 8, 14, 0, 13, 13, 13, 11, 30, 12, 8, 13, 7, 0, 9, 7, 11, 13, 16, 13, 13, 16, 5, 0, 9, 14, 10, 13, 18, 14, 11, 9, 7, 0, 12, 11, 10, 14, 24, 7, 9, 60, 13, 0, 10, 13, 8, 12, 17, 5, 11, 10, 8, 0, 15, 14, 7, 15, 20, 13, 11, 14, 13, 0, 12, 13, 10, 13, 20, 10, 9, 10, 8, 0, 11, 13, 6, 16, 41, 13, 11, 13, 13, 0, 9, 14, 13, 15, 18, 12, 9, 7, 11, 0, 11, 14, 8, 6, 23, 5, 13, 9, 10, 0, 13, 15, 11, 10, 25, 16, 12, 12, 11, 0, 13, 6, 11, 16, 34, 12, 12, 10, 10, 0, 10, 13, 11, 11, 14, 14, 12, 14, 8, 0, 6, 10, 13, 13, 18, 13, 12, 11, 8, 0, 13, 12, 13, 15, 21, 14, 11, 14, 12, 0, 9, 6, 10, 21, 19, 12, 10, 17, 12, 0, 7, 7, 9, 12, 28, 13, 8, 13, 10, 0, 11, 13, 11, 18, 15, 13, 7, 10, 9, 0, 12, 12, 12, 8, 24, 12, 13, 6, 6, 0, 7, 12, 11, 11, 18, 14, 13, 12, 6, 0, 9, 11, 8, 11, 23, 17, 6, 11, 6, 0, 15, 17, 5, 13, 15, 12, 10, 14, 7, 0, 14, 16, 9, 12, 21, 13, 13, 20, 9, 0, 10, 6, 12, 14, 29, 11, 13, 14, 10, 0, 11, 12, 10, 14, 15, 15, 9, 18, 14, 0, 13, 13, 13, 14, 30, 14, 12, 13, 15, 0, 7, 14, 13, 13, 21, 11, 10, 9, 9, 0, 12, 16, 9, 13, 16, 16, 11, 11, 12, 0, 10, 13, 7, 9, 10, 10, 9, 11, 13, 0, 9, 14, 7, 12, 21, 11, 11, 14, 10, 0, 11, 27, 9, 15, 17, 15, 13, 13, 12, 0, 9, 13, 8, 14, 20, 6, 14, 17, 11, 0, 10, 14, 13, 19, 26, 9, 12, 9, 11, 0, 13, 8, 13, 22, 29, 15, 18, 19, 8, 0, 10, 11, 6, 14, 16, 8, 8, 8, 12, 0, 9, 14, 12, 19, 12, 14, 9, 16, 8, 0, 13, 14, 13, 9, 17, 11, 11, 13, 10, 0, 16, 14, 14, 13, 16, 14, 5, 13, 12, 0, 9, 7, 10, 13, 22, 12, 11, 29, 8, 0, 12, 12, 12, 13, 16, 5, 5, 12, 6, 0, 5, 10, 12, 14, 14, 12, 13, 9, 12, 0, 14, 9, 14, 15, 21, 9, 10, 13, 13, 0, 11, 17, 11, 13, 19, 7, 11, 10, 7, 0, 11, 9, 7, 12, 23, 14, 11, 13, 13, 0, 9, 11, 8, 9, 61, 5, 11, 12, 13, 0, 4, 13, 7, 8, 17, 7, 15, 15, 10, 0, 8, 13, 8, 11, 18, 13, 8, 12, 11, 0, 9, 11, 10, 9, 15, 6, 9, 13, 16, 0, 7, 6, 11, 27, 20, 15, 12, 7, 12, 0, 13, 13, 12, 13, 29, 13, 8, 14, 10, 0, 9, 16, 7, 13, 29, 8, 13, 8, 13, 0, 8, 13, 6, 6, 23, 16, 10, 12, 6, 0, 10, 12, 11, 6, 22, 13, 10, 12, 9, 0, 7, 13, 12, 7, 24, 9, 8, 11, 10, 0, 13, 8, 10, 13, 23, 16, 11, 11, 7, 0, 13, 14, 10, 16, 31, 12, 9, 14, 12, 0, 8, 15, 9, 16, 19, 16, 11, 11, 6, 0, 9, 12, 8, 6, 21, 9, 13, 13, 8, 0, 10, 10, 15, 9, 18, 13, 9, 7, 10, 0, 13, 11, 9, 13, 21, 13, 8, 14, 14, 0, 8, 8, 11, 11, 18, 13, 8, 14, 6, 0, 8, 13, 9, 16, 11, 17, 10, 10, 11, 0, 14, 14, 12, 6, 17, 10, 12, 8, 9, 0, 6, 13, 13, 13, 15, 12, 10, 16, 12, 0, 8, 13, 13, 7, 26, 8, 10, 11, 12, 0, 12, 13, 9, 14, 13, 9, 14, 14, 8, 0, 12, 14, 10, 11, 32, 17, 7, 14, 10, 0, 15, 11, 10, 12, 17, 13, 11, 10, 11, 0, 7, 15, 10, 16, 21, 9, 12, 11, 13, 0, 8, 14, 11, 12, 17, 10, 11, 13, 11, 0, 11, 11, 13, 14, 22, 13, 12, 10, 13, 0, 13, 10, 13, 16, 13, 7, 8, 13, 9, 0, 7, 12, 12, 14, 10, 15, 13, 7, 5, 0, 10, 11, 11, 17, 26, 9, 10, 10, 9, 0, 12, 9, 11, 10, 18, 12, 10, 7, 11, 0, 12, 11, 11, 16, 23, 14, 11, 13, 12, 0, 11, 12, 8, 11, 25, 13, 9, 16, 10, 0, 9, 16, 13, 10, 28, 13, 11, 12, 9, 0, 11, 10, 10, 13, 25, 11, 10, 18, 11, 0, 14, 12, 11, 13, 13, 7, 10, 16, 9, 0, 11, 13, 10, 19, 14, 9, 12, 13, 12, 0, 13, 14, 12, 13, 53, 9, 13, 13, 12, 0, 14, 8, 8, 8, 32, 14, 8, 12, 13, 0, 10, 12, 10, 13, 15, 10, 11, 13, 11, 0, 8, 15, 11, 32, 16, 16, 12, 14, 11, 0, 9, 19, 13, 14, 20, 14, 11, 14, 11, 0, 13, 11, 8, 15, 21, 11, 10, 13, 11, 0, 11, 15, 13, 13, 19, 6, 10, 17, 10, 0, 12, 6, 6, 8, 20, 14, 12, 10, 11, 0, 9, 13, 9, 18, 15, 5, 15, 11, 13, 0, 10, 12, 13, 8, 21, 9, 8, 13, 12, 0, 12, 11, 11, 15, 15, 13, 10, 13, 13, 0, 10, 17, 6, 9, 18, 14, 12, 13, 7, 0, 11, 8, 10, 17, 6, 9, 13, 15, 12, 0, 12, 16, 9, 9, 25, 14, 10, 11, 13, 0, 11, 17, 10, 7, 29, 11, 12, 11, 14, 0, 13, 12, 11, 13, 15, 19, 10, 9, 10, 0, 16, 10, 13, 18, 15, 16, 11, 16, 10, 0, 14, 13, 10, 12, 15, 8, 11, 12, 9, 0, 12, 11, 8, 14, 25, 18, 12, 14, 10, 0, 9, 18, 15, 15, 20, 19, 12, 11, 9, 0, 11, 19, 9, 17, 26, 15, 9, 13, 11, 0, 9, 13, 14, 14, 21, 8, 9, 20, 7, 0, 9, 18, 13, 9, 17, 10, 14, 9, 9, 0, 12, 11, 10, 18, 21, 13, 14, 9, 10, 0, 14, 10, 6, 13, 17, 15, 14, 17, 9, 0, 13, 9, 12, 14, 16, 15, 9, 14, 6, 0, 14, 13, 9, 6, 23, 12, 11, 14, 8, 0, 10, 13, 13, 8, 15, 15, 12, 11, 13, 0, 11, 12, 11, 12, 25, 12, 9, 13, 11, 0, 11, 13, 10, 16, 33, 7, 11, 13, 11, 0, 8, 12, 7, 12, 52, 10, 9, 14, 11, 0, 13, 13, 11, 6, 20, 14, 12, 14, 9, 0, 12, 8, 12, 10, 21, 16, 12, 14, 13, 0, 7, 9, 13, 7, 21, 12, 13, 12, 8, 0, 6, 10, 11, 16, 18, 15, 7, 15, 9, 0, 11, 13, 14, 14, 109, 13, 9, 13, 13, 0, 13, 8, 7, 18, 14, 12, 9, 13, 11, 0, 14, 17, 7, 15, 38, 8, 12, 15, 12, 0, 14, 5, 8, 11, 21, 12, 9, 14, 12, 0, 8, 16, 15, 13, 18, 13, 12, 11, 8, 0, 9, 10, 9, 11, 52, 13, 9, 7, 10, 0, 11, 8, 12, 13, 12, 12, 7, 14, 10, 0, 13, 9, 9, 13, 17, 14, 8, 12, 11, 0, 10, 7, 11, 11, 17, 11, 12, 13, 13, 0, 8, 13, 12, 14, 15, 11, 10, 15, 9, 0, 10, 15, 15, 8, 20, 14, 11, 16, 7, 0, 11, 14, 10, 15, 21, 8, 9, 15, 13, 0, 12, 13, 11, 14, 23, 14, 6, 13, 12, 0, 6, 12, 12, 8, 17, 11, 6, 7, 9, 0, 10, 17, 13, 16, 18, 14, 14, 6, 8, 0, 11, 13, 13, 7, 21, 20, 10, 16, 14, 0, 13, 11, 12, 13, 32, 19, 8, 12, 7, 0, 14, 16, 21, 11, 21, 8, 12, 11, 8, 0, 12, 14, 9, 16, 21, 12, 6, 18, 10, 0, 13, 13, 10, 14, 11, 12, 9, 15, 9, 0, 11, 18, 13, 19, 32, 15, 14, 8, 13, 0, 11, 13, 7, 14, 16, 13, 5, 5, 8, 0, 12, 11, 8, 14, 16, 23, 5, 10, 7, 0, 11, 9, 12, 8, 10, 5, 11, 16, 8, 0, 12, 14, 9, 7, 26, 10, 12, 10, 12, 0, 9, 16, 11, 14, 24, 10, 8, 17, 7, 0, 13, 13, 11, 10, 17, 16, 10, 12, 11, 0, 11, 13, 10, 12, 21, 14, 10, 11, 12, 0, 13, 10, 7, 19, 11, 11, 13, 12, 14, 0, 4, 9, 13, 11, 14, 13, 13, 16, 11, 0, 9, 11, 9, 12, 21, 12, 9, 13, 8, 0, 12, 6, 10, 14, 21, 15, 5, 11, 13, 0, 7, 19, 14, 9, 14, 13, 10, 9, 11, 0, 10, 11, 12, 13, 21, 9, 13, 15, 9, 0, 8, 13, 7, 14, 20, 11, 10, 15, 13, 0, 10, 12, 11, 15, 22, 9, 10, 9, 11, 0, 14, 13, 6, 9, 26, 8, 12, 14, 10, 0, 13, 9, 11, 13, 14, 8, 9, 11, 12, 0, 8, 15, 10, 13, 18, 17, 11, 14, 7, 0, 8, 9, 11, 18, 64, 14, 12, 12, 12, 0, 15, 17, 14, 11, 13, 12, 13, 7, 13, 0, 11, 12, 7, 13, 27, 13, 11, 10, 8, 0, 13, 13, 12, 14, 20, 14, 9, 10, 12, 0, 13, 17, 13, 14, 18, 9, 6, 18, 7, 0, 8, 10, 11, 18, 20, 14, 11, 12, 11, 0, 8, 13, 9, 15, 26, 12, 9, 16, 11, 0, 13, 10, 8, 6, 24, 18, 10, 8, 8, 0, 9, 13, 7, 11, 22, 14, 13, 12, 12, 0, 8, 11, 5, 10, 16, 12, 11, 11, 15, 0, 12, 19, 13, 11, 18, 13, 17, 10, 13, 0, 11, 19, 13, 13, 26, 14, 12, 21, 10, 0, 13, 14, 9, 16, 21, 8, 10, 18, 13, 0, 14, 13, 13, 13, 23, 13, 13, 14, 12, 0, 14, 10, 9, 14, 25, 9, 8, 15, 8, 0, 7, 10, 13, 12, 7, 14, 13, 14, 10, 0, 9, 12, 8, 13, 15, 14, 13, 13, 12, 0, 13, 15, 13, 11, 15, 7, 11, 13, 9, 0, 13, 13, 13, 12, 15, 12, 10, 13, 13, 0, 8, 12, 12, 13, 17, 15, 13, 12, 11, 0, 11, 12, 12, 11, 16, 13, 11, 12, 11, 0, 14, 13, 8, 21, 45, 13, 11, 13, 8, 0, 10, 11, 12, 13, 18, 12, 11, 12, 9, 0, 13, 11, 11, 8, 14, 17, 10, 14, 10, 0, 8, 14, 9, 11, 21, 20, 10, 19, 10, 0, 13, 15, 8, 13, 15, 13, 11, 11, 12, 0, 13, 8, 14, 8, 33, 7, 14, 10, 11, 0, 10, 9, 13, 11, 15, 10, 10, 13, 8, 0, 7, 11, 13, 14, 20, 12, 11, 10, 15, 0, 13, 9, 9, 13, 25, 15, 14, 14, 11, 0, 12, 11, 11, 13, 20, 12, 13, 17, 13, 0, 13, 15, 7, 13, 14, 7, 13, 10, 11, 0, 11, 14, 10, 18, 32, 14, 11, 15, 11, 0, 13, 13, 10, 8, 21, 14, 11, 9, 10, 0, 9, 11, 10, 13, 27, 5, 13, 11, 8, 0, 12, 16, 12, 10, 24, 13, 10, 11, 13, 0, 13, 10, 13, 15, 92, 10, 11, 13, 7, 0, 13, 11, 12, 14, 53, 17, 11, 23, 15, 0, 9, 14, 8, 10, 18, 13, 14, 8, 9, 0, 10, 18, 10, 12, 21, 15, 10, 11, 10, 0, 13, 8, 7, 11, 21, 20, 12, 17, 8, 0, 11, 8, 12, 13, 12, 11, 11, 12, 11, 0, 14, 6, 10, 9, 23, 11, 8, 11, 13, 0, 12, 15, 7, 13, 30, 13, 11, 19, 12, 0, 10, 13, 7, 13, 15, 14, 11, 8, 6, 0, 8, 13, 12, 15, 12, 13, 12, 14, 9, 0, 9, 6, 9, 14, 24, 10, 14, 16, 11, 0, 10, 14, 13, 13, 20, 10, 12, 16, 12, 0, 14, 17, 16, 14, 21, 13, 11, 17, 11, 0, 9, 13, 13, 11, 14, 16, 8, 14, 11, 0, 7, 10, 6, 13, 19, 17, 16, 17, 8, 0, 9, 29, 7, 15, 23, 12, 9, 13, 10, 0, 9, 10, 8, 9, 25, 12, 10, 10, 14, 0, 8, 10, 9, 16, 14, 11, 12, 13, 9, 0, 9, 15, 8, 19, 22, 12, 6, 14, 15, 0, 10, 14, 11, 13, 17, 12, 10, 14, 13, 0, 10, 12, 9, 15, 23, 13, 7, 5, 11, 0, 13, 13, 10, 7, 19, 17, 9, 13, 9, 0, 7, 14, 9, 14, 25, 13, 13, 16, 9, 0, 15, 17, 11, 15, 13, 13, 13, 18, 8, 0, 10, 14, 7, 14, 22, 11, 14, 14, 6, 0, 13, 11, 6, 11, 29, 12, 11, 17, 11, 0, 12, 13, 11, 17, 19, 13, 11, 15, 11, 0, 13, 8, 14, 14, 18, 14, 7, 7, 13, 0, 10, 13, 11, 13, 21, 6, 12, 8, 16, 0, 9, 8, 12, 13, 22, 12, 14, 9, 12, 0, 13, 21, 12, 16, 21, 14, 13, 9, 10, 0, 7, 18, 11, 13, 11, 12, 12, 19, 12, 0, 7, 15, 6, 15, 24, 15, 9, 15, 13, 0, 12, 13, 8, 11, 18, 6, 7, 11, 12, 0, 13, 11, 11, 13, 22, 19, 9, 9, 12, 0, 11, 11, 12, 17, 28, 19, 11, 14, 12, 0, 8, 10, 9, 18, 10, 14, 6, 6, 13, 0, 13, 11, 10, 6, 16, 16, 10, 13, 8, 0, 11, 13, 8, 14, 33, 13, 13, 6, 11, 0, 13, 12, 13, 12, 21, 19, 12, 13, 12, 0, 8, 12, 11, 14, 32, 14, 10, 12, 9, 0, 11, 14, 14, 9, 15, 14, 9, 13, 13, 0, 12, 22, 9, 13, 10, 14, 10, 16, 7, 0, 12, 16, 10, 14, 19, 14, 12, 6, 13, 0, 13, 14, 10, 13, 22, 14, 11, 12, 13, 0, 7, 17, 12, 13, 26, 10, 13, 13, 13, 0, 8, 19, 10, 12, 23, 7, 5, 13, 13, 0, 11, 15, 13, 11, 23, 13, 13, 18, 10, 0, 11, 8, 7, 11, 21, 14, 13, 14, 9, 0, 6, 14, 12, 13, 16, 15, 13, 10, 10, 0, 9, 13, 11, 12, 28, 14, 11, 17, 11, 0, 14, 16, 8, 11, 34, 12, 11, 12, 10, 0, 10, 13, 7, 14, 18, 10, 8, 16, 12, 0, 14, 18, 9, 11, 23, 18, 13, 10, 10, 0, 4, 19, 10, 13, 21, 10, 11, 14, 9, 0, 13, 12, 12, 7, 25, 10, 13, 17, 7, 0, 12, 12, 11, 13, 24, 13, 8, 10, 9, 0, 13, 14, 11, 10, 28, 15, 8, 15, 13, 0, 12, 8, 13, 10, 14, 15, 11, 15, 13, 0, 13, 14, 13, 16, 22, 14, 9, 12, 14, 0, 7, 14, 10, 13, 23, 14, 12, 14, 13, 0, 13, 13, 14, 14, 20, 16, 12, 8, 9, 0, 14, 7, 6, 17, 32, 17, 13, 13, 13, 0, 13, 10, 12, 16, 15, 14, 10, 13, 7, 0, 13, 12, 9, 12, 13, 13, 13, 15, 13, 0, 13, 11, 12, 11, 19, 13, 8, 11, 13, 0, 13, 13, 10, 18, 28, 7, 10, 16, 12, 0, 10, 13, 12, 13, 15, 7, 12, 10, 15, 0, 8, 11, 13, 15, 24, 12, 9, 16, 17, 0, 13, 14, 8, 12, 14, 12, 13, 15, 11, 0, 14, 11, 10, 13, 29, 11, 13, 15, 13, 0, 9, 9, 13, 17, 30, 11, 8, 19, 11, 0, 9, 16, 11, 17, 23, 14, 13, 13, 9, 0, 11, 12, 11, 12, 26, 14, 13, 9, 12, 0, 12, 15, 11, 14, 20, 13, 7, 14, 11, 0, 16, 17, 13, 13, 195, 14, 10, 9, 9, 0, 10, 14, 12, 13, 17, 10, 8, 15, 13, 0, 8, 11, 13, 13, 16, 19, 12, 11, 13, 0, 13, 22, 11, 14, 7, 13, 8, 19, 12, 0, 13, 11, 13, 14, 20, 15, 8, 15, 10, 0, 12, 13, 14, 9, 9, 15, 13, 12, 13, 0, 15, 14, 13, 15, 21, 14, 11, 13, 11, 0, 15, 14, 11, 13, 22, 11, 11, 12, 13, 0, 15, 16, 7, 12, 22, 13, 14, 11, 11, 0, 7, 14, 12, 9, 27, 18, 12, 14, 14, 0, 13, 12, 10, 14, 21, 12, 9, 13, 11, 0, 15, 11, 10, 17, 21, 8, 7, 17, 11, 0, 11, 13, 12, 12, 15, 11, 9, 18, 13, 0, 10, 14, 14, 17, 16, 8, 13, 12, 14, 0, 11, 9, 8, 15, 23, 15, 7, 15, 10, 0, 9, 9, 11, 13, 23, 11, 7, 13, 9, 0, 9, 7, 8, 13, 14, 15, 14, 13, 12, 0, 12, 8, 8, 16, 19, 13, 12, 14, 13, 0, 14, 8, 9, 13, 29, 15, 10, 13, 10, 0, 9, 15, 13, 12, 14, 11, 13, 12, 14, 0, 13, 12, 13, 13, 32, 18, 15, 9, 13, 0, 11, 13, 13, 12, 23, 7, 12, 11, 10, 0, 11, 15, 7, 22, 25, 13, 6, 6, 12, 0, 11, 16, 13, 16, 6, 12, 6, 14, 13, 0, 13, 15, 7, 14, 20, 14, 10, 13, 8, 0, 18, 10, 12, 13, 26, 20, 12, 12, 10, 0, 7, 14, 13, 12, 29, 13, 10, 13, 11, 0, 12, 19, 13, 17, 29, 15, 12, 15, 16, 0, 12, 12, 11, 13, 16, 14, 12, 11, 10, 0, 11, 12, 13, 12, 23, 14, 14, 12, 11, 0, 8, 14, 12, 6, 15, 12, 6, 16, 7, 0, 11, 12, 16, 13, 28, 14, 14, 13, 7, 0, 11, 6, 11, 13, 18, 10, 6, 16, 11, 0, 6, 12, 9, 12, 18, 12, 12, 6, 6, 0, 13, 15, 9, 15, 18, 13, 10, 13, 12, 0, 11, 26, 11, 15, 26, 13, 8, 9, 13, 0, 9, 14, 10, 14, 21, 9, 16, 14, 13, 0, 12, 11, 12, 13, 30, 13, 17, 15, 13, 0, 6, 12, 11, 7, 16, 18, 11, 13, 13, 0, 12, 13, 11, 14, 18, 12, 10, 13, 12, 0, 13, 9, 7, 15, 19, 12, 14, 13, 11, 0, 11, 13, 11, 16, 17, 13, 9, 12, 13, 0, 12, 13, 10, 8, 28, 14, 9, 12, 7, 0, 14, 8, 12, 14, 21, 10, 13, 17, 10, 0, 11, 14, 9, 9, 18, 13, 11, 13, 10, 0, 12, 15, 11, 19, 54, 12, 12, 13, 14, 0, 13, 17, 11, 13, 10, 17, 9, 10, 11, 0, 10, 16, 13, 15, 23, 18, 14, 19, 14, 0, 14, 11, 10, 9, 19, 17, 8, 15, 12, 0, 13, 13, 10, 11, 24, 20, 8, 13, 13, 0, 12, 15, 14, 11, 20, 12, 12, 14, 13, 0, 9, 13, 13, 12, 22, 16, 10, 6, 8, 0, 11, 18, 13, 13, 11, 17, 11, 16, 12, 0, 8, 8, 8, 13, 21, 13, 13, 15, 14, 0, 13, 15, 12, 13, 21, 12, 14, 16, 10, 0, 14, 12, 13, 14, 16, 16, 13, 13, 10, 0, 10, 12, 13, 15, 21, 15, 14, 12, 7, 0, 9, 13, 13, 8, 12, 19, 9, 13, 13, 0, 13, 21, 9, 9, 27, 16, 10, 12, 14, 0, 13, 17, 13, 16, 24, 9, 11, 17, 10, 0, 13, 14, 11, 11, 23, 18, 11, 14, 10, 0, 9, 14, 13, 15, 22, 11, 12, 15, 12, 0, 13, 12, 17, 9, 22, 14, 8, 13, 11, 0, 10, 14, 14, 14, 21, 15, 11, 13, 11, 0, 12, 12, 7, 13, 18, 11, 14, 13, 11, 0, 8, 8, 13, 17, 33, 10, 10, 13, 13, 0, 15, 20, 10, 9, 26, 11, 11, 8, 10, 0, 21, 8, 7, 15, 14, 11, 13, 14, 16, 0, 13, 12, 13, 13, 23, 16, 10, 16, 12, 0, 15, 12, 9, 13, 23, 13, 10, 14, 13, 0, 11, 14, 9, 14, 19, 13, 11, 8, 12, 0, 11, 12, 9, 11, 25, 13, 13, 13, 13, 0, 10, 13, 9, 12, 21, 10, 11, 14, 8, 0, 13, 16, 12, 14, 17, 8, 8, 15, 14, 0, 15, 13, 11, 12, 38, 13, 13, 10, 11, 0, 12, 14, 9, 10, 34, 17, 15, 13, 13, 0, 11, 17, 12, 14, 24, 12, 8, 11, 10, 0, 10, 12, 10, 19, 18, 13, 10, 12, 14, 0, 8, 9, 9, 14, 23, 9, 15, 13, 12, 0, 4, 14, 16, 18, 17, 12, 13, 13, 11, 0, 11, 16, 16, 9, 29, 20, 6, 8, 13, 0, 11, 13, 9, 17, 21, 18, 14, 12, 12, 0, 13, 17, 12, 14, 23, 14, 12, 8, 13, 0, 13, 12, 12, 11, 22, 17, 11, 16, 11, 0, 11, 14, 10, 15, 30, 9, 14, 13, 9, 0, 11, 10, 9, 14, 31, 8, 12, 12, 13, 0, 15, 16, 7, 14, 25, 11, 8, 15, 10, 0, 7, 14, 11, 15, 17, 8, 13, 15, 13, 0, 13, 13, 11, 13, 16, 17, 13, 10, 14, 0, 13, 16, 6, 23, 19, 13, 9, 13, 7, 0, 10, 10, 11, 8, 53, 11, 9, 13, 10, 0, 13, 15, 11, 13, 11, 11, 8, 17, 8, 0, 12, 10, 13, 10, 21, 13, 15, 16, 11, 0, 8, 13, 9, 21, 21, 13, 13, 13, 12, 0, 6, 14, 10, 17, 17, 17, 8, 6, 11, 0, 13, 8, 9, 19, 25, 6, 10, 15, 13, 0, 9, 13, 15, 12, 21, 15, 9, 9, 8, 0, 11, 12, 12, 11, 27, 13, 13, 81, 16, 0, 6, 15, 8, 11, 14, 13, 12, 14, 15, 0, 11, 19, 11, 22, 21, 10, 6, 14, 10, 0, 13, 12, 12, 6, 23, 12, 8, 11, 13, 0, 8, 11, 11, 14, 15, 14, 10, 7, 7, 0, 9, 11, 6, 11, 17, 18, 6, 16, 12, 0, 6, 9, 14, 16, 23, 9, 13, 11, 11, 0, 13, 15, 12, 13, 26, 9, 12, 14, 13, 0, 10, 14, 12, 15, 139, 11, 8, 11, 9, 0, 14, 14, 10, 9, 13, 15, 11, 12, 12, 0, 11, 17, 8, 12, 17, 11, 7, 18, 13, 0, 11, 14, 13, 15, 28, 14, 12, 13, 10, 0, 13, 8, 13, 20, 22, 14, 13, 14, 9, 0, 11, 16, 13, 10, 24, 6, 10, 17, 11, 0, 11, 13, 10, 16, 61, 14, 11, 12, 12, 0, 9, 18, 13, 17, 15, 13, 11, 13, 12, 0, 9, 16, 8, 11, 23, 14, 15, 20, 13, 0, 11, 19, 13, 12, 18, 14, 7, 13, 14, 0, 14, 42, 11, 15, 22, 12, 10, 18, 10, 0, 8, 14, 6, 13, 52, 13, 9, 10, 12, 0, 11, 17, 14, 12, 21, 9, 12, 11, 13, 0, 14, 11, 12, 13, 14, 14, 9, 14, 8, 0, 12, 13, 10, 10, 30, 17, 12, 20, 13, 0, 11, 14, 11, 14, 35, 14, 12, 13, 13, 0, 12, 15, 10, 14, 21, 15, 13, 13, 12, 0, 10, 16, 8, 10, 21, 12, 6, 12, 11, 0, 12, 14, 14, 18, 50, 18, 11, 13, 13, 0, 11, 14, 12, 7, 16, 18, 12, 13, 10, 0, 12, 13, 12, 13, 29, 12, 11, 11, 14, 0, 12, 7, 7, 19, 21, 19, 12, 9, 15, 0, 11, 12, 10, 14, 20, 6, 14, 15, 13, 0, 15, 14, 14, 13, 15, 16, 11, 13, 12, 0, 11, 7, 7, 12, 12, 9, 15, 14, 12, 0, 12, 19, 14, 11, 34, 11, 12, 14, 14, 0, 14, 19, 10, 16, 16, 13, 13, 20, 12, 0, 14, 17, 15, 12, 12, 18, 11, 13, 13, 0, 11, 14, 8, 13, 16, 11, 6, 8, 12, 0, 9, 16, 8, 14, 21, 14, 11, 16, 14, 0, 12, 13, 9, 16, 29, 6, 9, 12, 8, 0, 11, 18, 9, 7, 9, 15, 12, 11, 11, 0, 10, 16, 13, 15, 17, 8, 10, 16, 8, 0, 14, 12, 10, 15, 23, 18, 14, 14, 12, 0, 10, 9, 8, 13, 23, 9, 11, 15, 13, 0, 11, 17, 8, 12, 22, 14, 9, 15, 9, 0, 14, 12, 10, 16, 34, 11, 9, 13, 15, 0, 13, 19, 12, 16, 20, 18, 13, 15, 13, 0, 14, 11, 13, 14, 22, 36, 9, 18, 12, 0, 12, 14, 12, 16, 21, 16, 13, 8, 12, 0, 13, 14, 12, 13, 25, 14, 12, 16, 14, 0, 8, 10, 13, 11, 24, 12, 9, 15, 14, 0, 14, 13, 9, 11, 23, 12, 12, 19, 12, 0, 13, 12, 10, 13, 38, 16, 8, 19, 12, 0, 14, 12, 9, 16, 24, 8, 14, 15, 12, 0, 10, 10, 10, 19, 35, 15, 12, 22, 13, 0, 12, 17, 8, 14, 20, 12, 13, 11, 14, 0, 12, 12, 14, 12, 27, 20, 7, 7, 10, 0, 13, 13, 16, 13, 12, 13, 13, 7, 11, 0, 12, 12, 13, 13, 16, 19, 13, 8, 12, 0, 9, 15, 13, 9, 14, 9, 10, 12, 13, 0, 10, 14, 14, 14, 18, 19, 9, 8, 15, 0, 13, 17, 12, 9, 12, 13, 16, 12, 17, 0, 11, 14, 13, 13, 18, 14, 14, 7, 13, 0, 9, 11, 13, 9, 19, 11, 10, 13, 11, 0, 7, 13, 14, 13, 26, 7, 9, 10, 14, 0, 11, 13, 9, 14, 24, 14, 13, 14, 8, 0, 10, 9, 13, 8, 28, 9, 11, 10, 11, 0, 13, 21, 14, 14, 23, 15, 15, 9, 13, 0, 13, 16, 13, 12, 19, 19, 9, 11, 15, 0, 12, 13, 9, 15, 27, 9, 13, 19, 12, 0, 11, 18, 14, 17, 23, 14, 13, 14, 12, 0, 12, 10, 9, 17, 25, 19, 17, 12, 30, 0, 8, 20, 17, 12, 23, 19, 14, 14, 16, 0, 7, 14, 12, 17, 14, 22, 11, 14, 11, 0, 12, 14, 13, 15, 33, 14, 12, 14, 8, 0, 12, 13, 9, 15, 19, 12, 11, 16, 12, 0, 11, 19, 10, 14, 16, 20, 12, 16, 13, 0, 13, 12, 6, 12, 22, 15, 8, 13, 10, 0, 14, 12, 11, 17, 27, 16, 12, 18, 12, 0, 13, 16, 11, 13, 20, 14, 9, 18, 11, 0, 14, 11, 11, 15, 14, 14, 6, 13, 13, 0, 8, 14, 6, 11, 18, 13, 8, 13, 17, 0, 6, 6, 6, 12, 19, 11, 14, 15, 14, 0, 6, 14, 9, 13, 12, 11, 13, 18, 13, 0, 6, 11, 12, 12, 13, 14, 13, 14, 14, 0, 13, 18, 13, 14, 25, 12, 8, 19, 11, 0, 15, 14, 13, 20, 18, 19, 8, 13, 11, 0, 12, 11, 10, 11, 24, 13, 13, 19, 12, 0, 13, 11, 10, 18, 20, 15, 12, 9, 10, 0, 14, 14, 13, 13, 56, 6, 11, 12, 9, 0, 13, 10, 15, 8, 18, 8, 14, 14, 11, 0, 9, 6, 10, 17, 17, 15, 12, 15, 15, 0, 6, 19, 13, 18, 25, 13, 14, 18, 9, 0, 13, 12, 10, 14, 21, 9, 9, 15, 9, 0, 8, 8, 12, 15, 18, 15, 15, 13, 11, 0, 13, 12, 12, 16, 30, 15, 13, 12, 12, 0, 11, 13, 9, 13, 18, 17, 13, 8, 14, 0, 11, 13, 14, 15, 17, 11, 11, 18, 13, 0, 11, 15, 8, 11, 19, 15, 12, 9, 11, 0, 6, 21, 13, 14, 23, 8, 11, 5, 13, 0, 11, 15, 6, 12, 25, 12, 12, 12, 7, 0, 6, 17, 14, 15, 14, 13, 10, 23, 14, 0, 6, 15, 13, 10, 29, 17, 13, 13, 10, 0, 12, 9, 13, 13, 29, 12, 10, 13, 11, 0, 11, 17, 13, 14, 33, 13, 10, 11, 13, 0, 15, 14, 11, 12, 22, 12, 11, 19, 12, 0, 14, 18, 16, 14, 23, 14, 13, 11, 14, 0, 12, 10, 15, 9, 14, 17, 12, 10, 10, 0, 13, 13, 12, 14, 23, 16, 12, 13, 11, 0, 5, 14, 11, 12, 17, 12, 5, 17, 7, 0, 13, 19, 12, 12, 17, 13, 15, 13, 11, 0, 12, 9, 10, 17, 53, 16, 9, 17, 11, 0, 13, 12, 7, 11, 17, 12, 13, 13, 11, 0, 13, 10, 13, 11, 23, 14, 12, 15, 13, 0, 11, 14, 11, 9, 32, 14, 13, 19, 11, 0, 11, 9, 9, 9, 17, 15, 5, 14, 10, 0, 9, 12, 11, 15, 20, 16, 12, 11, 10, 0, 13, 14, 9, 17, 21, 7, 10, 13, 13, 0, 13, 11, 12, 20, 35, 17, 11, 15, 7, 0, 11, 12, 11, 16, 23, 13, 10, 15, 13, 0, 13, 17, 10, 17, 21, 20, 10, 9, 13, 0, 14, 14, 11, 14, 23, 14, 11, 15, 14, 0, 10, 8, 13, 8, 32, 16, 10, 12, 10, 0, 15, 20, 11, 8, 23, 13, 8, 13, 13, 0, 13, 8, 9, 12, 33, 19, 14, 16, 12, 0, 9, 15, 11, 14, 17, 11, 11, 14, 13, 0, 9, 14, 10, 16, 61, 16, 8, 13, 10, 0, 12, 9, 14, 17, 14, 5, 5, 13, 9, 0, 5, 18, 16, 13, 20, 14, 13, 12, 8, 0, 13, 8, 7, 13, 29, 13, 13, 9, 8, 0, 8, 41, 7, 13, 14, 15, 12, 10, 12, 0, 8, 12, 13, 18, 29, 10, 14, 16, 11, 0, 10, 20, 12, 14, 40, 5, 9, 14, 12, 0, 12, 13, 8, 17, 24, 8, 15, 17, 13, 0, 11, 17, 13, 11, 35, 13, 12, 19, 13, 0, 11, 8, 10, 15, 23, 15, 10, 13, 12, 0, 11, 9, 11, 15, 21, 14, 12, 10, 12, 0, 9, 12, 13, 8, 17, 14, 15, 11, 14, 0, 9, 12, 9, 13, 29, 15, 11, 14, 8, 0, 13, 10, 14, 13, 12, 18, 11, 12, 11, 0, 6, 18, 13, 12, 22, 13, 9, 14, 12, 0, 13, 13, 13, 15, 27, 17, 13, 14, 9, 0, 13, 15, 7, 14, 10, 12, 13, 11, 10, 0, 11, 12, 12, 8, 23, 13, 14, 14, 12, 0, 11, 9, 6, 13, 52, 16, 14, 6, 11, 0, 11, 13, 8, 17, 14, 14, 13, 12, 13, 0, 11, 14, 11, 14, 21, 21, 14, 19, 10, 0, 12, 18, 13, 13, 47, 14, 13, 18, 7, 0, 13, 16, 13, 13, 25, 13, 8, 17, 10, 0, 7, 13, 12, 12, 33, 9, 12, 8, 14, 0, 8, 14, 12, 18, 15, 11, 14, 13, 12, 0, 12, 14, 11, 8, 16, 8, 11, 8, 8, 0, 16, 12, 11, 16, 10, 18, 7, 10, 14, 0, 10, 14, 8, 12, 23, 21, 9, 13, 8, 0, 13, 7, 16, 9, 15, 8, 12, 9, 10, 0, 11, 19, 13, 18, 24, 13, 7, 14, 12, 0, 13, 12, 8, 14, 21, 18, 13, 17, 8, 0, 10, 13, 14, 14, 19, 13, 13, 15, 12, 0, 14, 11, 12, 15, 24, 14, 14, 12, 11, 0, 16, 13, 12, 17, 21, 11, 9, 17, 11, 0, 13, 17, 11, 16, 23, 16, 12, 13, 15, 0, 12, 14, 13, 14, 17, 18, 11, 14, 13, 0, 9, 12, 13, 12, 21, 13, 8, 13, 13, 0, 7, 14, 13, 18, 38, 8, 13, 11, 12, 0, 11, 14, 13, 14, 33, 6, 8, 18, 14, 0, 12, 17, 14, 12, 21, 10, 11, 17, 7, 0, 11, 17, 14, 14, 18, 10, 10, 13, 14, 0, 9, 13, 13, 17, 16, 13, 10, 8, 15, 0, 13, 11, 14, 13, 23, 14, 11, 11, 12, 0, 10, 20, 9, 13, 21, 19, 9, 19, 13, 0, 14, 14, 11, 12, 19, 13, 9, 14, 26, 0, 15, 14, 11, 13, 18, 15, 13, 14, 14, 0, 7, 16, 10, 8, 22, 13, 13, 21, 10, 0, 6, 7, 8, 15, 21, 11, 11, 13, 13, 0, 7, 14, 12, 15, 21, 19, 13, 10, 12, 0, 7, 17, 11, 14, 30, 15, 5, 17, 13, 0, 13, 17, 13, 12, 30, 16, 13, 9, 13, 0, 13, 14, 13, 14, 34, 5, 8, 16, 13, 0, 11, 14, 11, 13, 19, 15, 11, 14, 9, 0, 12, 16, 13, 11, 34, 17, 14, 11, 9, 0, 10, 13, 12, 11, 15, 17, 12, 13, 14, 0, 12, 15, 12, 14, 17, 10, 12, 18, 13, 0, 6, 12, 7, 24, 23, 13, 13, 17, 15, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 17, 9, 12, 10, 0, 5, 5, 5, 14, 16, 18, 12, 16, 13, 0, 5, 5, 11, 10, 21, 15, 12, 9, 12, 0, 5, 5, 8, 17, 21, 17, 15, 13, 15, 0, 5, 19, 15, 9, 26, 15, 14, 13, 6, 0, 5, 14, 12, 9, 22, 12, 8, 14, 10, 0, 5, 16, 12, 18, 25, 9, 13, 15, 12, 0, 5, 13, 9, 12, 24, 13, 12, 11, 11, 0, 14, 14, 14, 11, 21, 16, 12, 9, 11, 0, 5, 5, 5, 5, 5, 11, 10, 22, 10, 0, 5, 5, 11, 10, 33, 11, 16, 17, 9, 0, 5, 20, 16, 17, 26, 12, 13, 18, 13, 0, 5, 12, 15, 15, 29, 12, 15, 11, 11, 0, 5, 14, 9, 13, 18, 13, 13, 15, 14, 0, 11, 17, 11, 39, 24, 11, 11, 13, 6, 0, 11, 9, 10, 15, 49, 17, 13, 14, 14, 0, 12, 12, 13, 12, 30, 13, 12, 14, 10, 0, 14, 14, 8, 16, 21, 13, 11, 15, 15, 0, 9, 10, 8, 13, 17, 19, 12, 17, 11, 0, 5, 5, 5, 12, 23, 8, 14, 18, 12, 0, 5, 14, 12, 14, 26, 14, 12, 11, 15, 0, 5, 12, 13, 12, 22, 14, 8, 7, 7, 0, 16, 16, 16, 7, 20, 17, 9, 13, 11, 0, 12, 13, 9, 17, 26, 16, 10, 14, 12, 0, 12, 9, 10, 14, 24, 12, 13, 16, 11, 0, 11, 14, 8, 11, 90, 13, 8, 12, 13, 0, 10, 32, 11, 15, 28, 13, 10, 14, 13, 0, 13, 14, 10, 19, 26, 60, 13, 13, 11, 0, 13, 17, 12, 13, 8, 14, 7, 15, 13, 0, 5, 5, 12, 11, 26, 10, 12, 8, 12, 0, 5, 19, 9, 21, 26, 17, 13, 15, 14, 0, 13, 13, 8, 19, 16, 14, 11, 17, 9, 0, 13, 12, 9, 13, 21, 17, 12, 13, 11, 0, 9, 16, 13, 13, 18, 16, 12, 13, 13, 0, 13, 16, 7, 13, 29, 12, 14, 16, 16, 0, 8, 19, 10, 18, 13, 13, 8, 15, 14, 0, 13, 9, 13, 14, 24, 17, 8, 19, 12, 0, 11, 12, 13, 11, 27, 7, 8, 11, 13, 0, 7, 14, 13, 14, 30, 13, 15, 6, 13, 0, 5, 5, 15, 14, 22, 9, 8, 14, 8, 0, 5, 15, 6, 15, 30, 17, 10, 10, 13, 0, 14, 16, 12, 15, 18, 14, 12, 20, 15, 0, 14, 19, 11, 12, 15, 11, 13, 17, 14, 0, 16, 15, 8, 15, 23, 11, 9, 10, 9, 0, 10, 14, 7, 13, 21, 15, 11, 13, 9, 0, 9, 14, 12, 20, 14, 14, 17, 14, 14, 0, 12, 14, 13, 10, 15, 17, 10, 14, 12, 0, 12, 13, 14, 13, 21, 11, 14, 17, 9, 0, 14, 17, 14, 12, 28, 18, 8, 15, 15, 0, 5, 14, 16, 12, 32, 14, 10, 14, 13, 0, 15, 13, 8, 6, 21, 15, 15, 21, 9, 0, 17, 12, 13, 14, 23, 17, 13, 14, 14, 0, 10, 13, 14, 7, 16, 13, 13, 13, 12, 0, 13, 13, 13, 16, 114, 13, 14, 17, 12, 0, 11, 18, 7, 13, 15, 17, 15, 18, 11, 0, 11, 13, 13, 12, 21, 10, 16, 11, 8, 0, 8, 12, 8, 12, 24, 16, 11, 13, 11, 0, 13, 12, 11, 14, 16, 21, 7, 10, 7, 0, 12, 15, 14, 12, 16, 15, 14, 11, 13, 0, 5, 14, 9, 17, 34, 12, 9, 13, 13, 0, 13, 9, 14, 11, 31, 15, 13, 12, 6, 0, 11, 17, 8, 6, 19, 11, 16, 16, 12, 0, 17, 18, 10, 22, 29, 13, 12, 13, 13, 0, 12, 12, 11, 13, 21, 14, 11, 17, 13, 0, 12, 14, 13, 16, 26, 14, 14, 12, 9, 0, 12, 13, 12, 18, 26, 22, 12, 19, 13, 0, 12, 10, 12, 6, 19, 15, 13, 14, 10, 0, 13, 14, 8, 13, 21, 14, 14, 16, 12, 0, 9, 13, 9, 12, 17, 18, 13, 21, 15, 0, 5, 15, 12, 14, 19, 18, 13, 16, 9, 0, 11, 13, 11, 14, 32, 13, 11, 14, 12, 0, 7, 14, 10, 18, 21, 13, 11, 19, 11, 0, 15, 12, 15, 15, 20, 17, 13, 14, 8, 0, 10, 11, 13, 14, 19, 11, 9, 12, 13, 0, 13, 20, 15, 17, 18, 18, 12, 13, 13, 0, 9, 16, 11, 11, 36, 11, 9, 12, 10, 0, 9, 19, 10, 13, 27, 19, 8, 12, 11, 0, 13, 17, 6, 15, 15, 11, 13, 14, 11, 0, 7, 10, 13, 16, 25, 13, 8, 12, 13, 0, 5, 11, 14, 18, 24, 14, 14, 12, 8, 0, 6, 15, 15, 27, 38, 9, 9, 15, 14, 0, 11, 15, 14, 14, 20, 15, 13, 12, 13, 0, 16, 19, 13, 13, 15, 14, 14, 18, 10, 0, 14, 13, 11, 14, 15, 17, 13, 12, 12, 0, 12, 15, 12, 14, 28, 17, 13, 19, 14, 0, 9, 9, 11, 15, 32, 9, 15, 15, 13, 0, 13, 13, 12, 15, 18, 17, 15, 22, 15, 0, 11, 15, 12, 23, 24, 19, 12, 13, 15, 0, 11, 17, 12, 17, 24, 22, 14, 14, 12, 0, 7, 8, 14, 14, 21, 8, 12, 18, 10, 0, 11, 19, 14, 14, 56, 19, 14, 19, 13, 0, 11, 14, 12, 18, 15, 17, 11, 8, 14, 0, 14, 14, 16, 15, 34, 14, 10, 18, 9, 0, 13, 11, 12, 14, 7, 13, 12, 19, 10, 0, 15, 18, 13, 23, 21, 18, 12, 13, 14, 0, 11, 15, 8, 18, 15, 13, 13, 12, 11, 0, 13, 15, 13, 14, 16, 18, 13, 13, 16, 0, 14, 12, 13, 15, 19, 29, 12, 16, 11, 0, 6, 14, 11, 12, 29, 14, 9, 14, 11, 0, 5, 5, 5, 5, 5, 13, 13, 12, 9, 0, 5, 5, 14, 10, 26, 15, 9, 14, 14, 0, 5, 12, 13, 17, 21, 11, 14, 13, 8, 0, 5, 20, 11, 9, 23, 17, 9, 15, 16, 0, 5, 14, 16, 14, 25, 19, 15, 18, 13, 0, 12, 13, 11, 17, 23, 18, 9, 13, 14, 0, 8, 11, 12, 15, 25, 19, 13, 16, 11, 0, 10, 20, 15, 9, 24, 7, 12, 13, 13, 0, 10, 21, 10, 17, 71, 15, 13, 14, 13, 0, 8, 9, 10, 11, 22, 9, 12, 17, 10, 0, 5, 5, 13, 13, 24, 12, 14, 18, 13, 0, 5, 14, 15, 13, 35, 15, 11, 8, 14, 0, 11, 7, 10, 15, 21, 17, 15, 17, 12, 0, 13, 17, 7, 13, 26, 18, 14, 11, 14, 0, 12, 13, 10, 12, 23, 21, 13, 14, 18, 0, 11, 14, 9, 11, 25, 17, 13, 15, 14, 0, 10, 13, 10, 15, 29, 13, 14, 16, 13, 0, 10, 13, 15, 6, 72, 15, 9, 28, 12, 0, 11, 18, 10, 14, 20, 7, 7, 12, 9, 0, 11, 14, 10, 19, 16, 17, 8, 15, 10, 0, 5, 13, 10, 8, 18, 14, 12, 17, 11, 0, 7, 12, 11, 16, 15, 22, 11, 14, 12, 0, 7, 8, 15, 13, 18, 8, 11, 14, 13, 0, 14, 14, 14, 13, 21, 6, 6, 6, 6, 0, 14, 16, 15, 10, 24, 13, 6, 6, 6, 0, 17, 14, 13, 12, 15, 13, 9, 6, 6, 0, 9, 13, 14, 18, 45, 12, 13, 14, 6, 0, 12, 10, 10, 27, 15, 14, 13, 13, 13, 0, 8, 9, 12, 11, 38, 15, 9, 19, 15, 0, 13, 15, 16, 8, 24, 15, 13, 13, 9, 0, 5, 16, 12, 11, 19, 11, 16, 19, 8, 0, 13, 13, 8, 14, 31, 17, 11, 19, 12, 0, 12, 13, 12, 9, 17, 14, 13, 21, 11, 0, 13, 13, 8, 15, 23, 14, 13, 16, 16, 0, 11, 16, 13, 11, 25, 11, 6, 6, 6, 0, 15, 9, 14, 13, 21, 30, 10, 6, 6, 0, 13, 9, 11, 13, 27, 15, 13, 15, 6, 0, 13, 15, 6, 10, 32, 15, 12, 9, 7, 0, 10, 13, 11, 9, 26, 7, 13, 14, 7, 0, 11, 16, 15, 11, 15, 17, 14, 13, 11, 0, 5, 20, 11, 8, 16, 15, 11, 14, 10, 0, 13, 11, 12, 8, 23, 13, 12, 14, 12, 0, 13, 13, 10, 13, 23, 14, 10, 13, 13, 0, 14, 8, 11, 15, 19, 14, 10, 16, 10, 0, 14, 17, 11, 12, 21, 10, 18, 13, 10, 0, 16, 14, 15, 21, 17, 14, 9, 6, 6, 0, 11, 12, 13, 13, 33, 25, 9, 9, 6, 0, 17, 14, 8, 13, 21, 14, 11, 13, 10, 0, 9, 19, 11, 17, 32, 16, 11, 16, 7, 0, 13, 12, 11, 13, 26, 14, 11, 7, 11, 0, 14, 8, 12, 17, 21, 11, 10, 14, 8, 0, 9, 12, 8, 17, 92, 20, 12, 14, 8, 0, 14, 9, 13, 14, 17, 14, 8, 11, 14, 0, 8, 15, 13, 14, 21, 15, 13, 11, 7, 0, 14, 17, 17, 14, 24, 14, 14, 17, 13, 0, 11, 17, 10, 16, 9, 17, 13, 14, 11, 0, 14, 13, 9, 11, 30, 14, 10, 14, 6, 0, 12, 16, 12, 15, 20, 13, 8, 19, 13, 0, 17, 10, 9, 19, 18, 11, 8, 13, 14, 0, 13, 17, 9, 23, 28, 11, 12, 13, 8, 0, 13, 10, 8, 13, 18, 13, 13, 19, 10, 0, 13, 14, 11, 16, 19, 13, 12, 16, 15, 0, 12, 13, 14, 19, 12, 10, 12, 14, 11, 0, 9, 18, 17, 10, 21, 16, 12, 16, 8, 0, 12, 15, 11, 8, 24, 13, 12, 9, 13, 0, 19, 13, 16, 17, 61, 12, 11, 15, 14, 0, 13, 15, 7, 17, 29, 7, 16, 5, 10, 0, 14, 10, 7, 11, 19, 13, 9, 17, 14, 0, 14, 9, 13, 17, 31, 10, 14, 14, 11, 0, 13, 17, 12, 9, 20, 14, 12, 17, 11, 0, 11, 16, 16, 13, 30, 21, 11, 19, 9, 0, 15, 15, 13, 11, 37, 13, 10, 16, 13, 0, 12, 20, 12, 20, 10, 14, 14, 17, 14, 0, 11, 13, 13, 12, 18, 16, 14, 11, 10, 0, 14, 13, 13, 17, 18, 16, 11, 10, 13, 0, 13, 16, 10, 19, 13, 16, 14, 10, 9, 0, 8, 13, 14, 16, 8, 12, 14, 16, 11, 0, 14, 17, 16, 10, 18, 10, 9, 13, 10, 0, 14, 11, 11, 17, 25, 22, 15, 20, 12, 0, 14, 18, 15, 12, 19, 13, 14, 16, 14, 0, 15, 11, 14, 16, 21, 16, 13, 15, 13, 0, 11, 12, 12, 14, 34, 11, 16, 26, 13, 0, 17, 9, 10, 18, 22, 13, 17, 12, 12, 0, 13, 20, 13, 17, 23, 13, 13, 13, 12, 0, 13, 9, 14, 14, 23, 13, 11, 16, 12, 0, 17, 15, 6, 8, 25, 13, 9, 8, 13, 0, 11, 16, 12, 20, 35, 18, 10, 14, 10, 0, 13, 13, 10, 12, 21, 10, 22, 13, 12, 0, 12, 21, 13, 16, 16, 13, 14, 17, 15, 0, 13, 13, 12, 15, 12, 11, 15, 36, 15, 0, 7, 16, 9, 13, 23, 15, 9, 18, 13, 0, 10, 18, 13, 19, 24, 18, 7, 14, 9, 0, 9, 14, 15, 14, 34, 14, 10, 11, 11, 0, 12, 16, 13, 13, 23, 12, 15, 15, 11, 0, 11, 12, 14, 15, 16, 13, 13, 11, 13, 0, 14, 19, 12, 15, 26, 18, 15, 13, 10, 0, 14, 13, 14, 19, 27, 19, 13, 11, 13, 0, 10, 15, 8, 17, 23, 19, 12, 8, 10, 0, 13, 14, 15, 12, 21, 10, 13, 13, 8, 0, 14, 20, 13, 13, 27, 16, 12, 18, 9, 0, 5, 5, 5, 17, 27, 11, 14, 14, 9, 0, 5, 20, 13, 12, 23, 20, 16, 8, 14, 0, 5, 9, 12, 14, 38, 15, 13, 14, 12, 0, 12, 19, 8, 11, 38, 13, 12, 15, 13, 0, 9, 13, 11, 15, 19, 13, 11, 14, 11, 0, 10, 13, 9, 17, 28, 18, 12, 15, 12, 0, 15, 19, 16, 12, 23, 13, 15, 20, 13, 0, 11, 17, 13, 8, 21, 16, 11, 17, 13, 0, 13, 9, 13, 13, 30, 16, 7, 12, 13, 0, 10, 13, 9, 16, 24, 9, 12, 9, 12, 0, 5, 21, 12, 15, 23, 11, 12, 13, 8, 0, 13, 13, 11, 17, 30, 14, 13, 7, 13, 0, 9, 11, 13, 19, 14, 11, 13, 18, 11, 0, 11, 14, 11, 14, 23, 16, 13, 13, 11, 0, 12, 19, 12, 13, 30, 9, 6, 10, 14, 0, 14, 16, 13, 13, 14, 13, 7, 18, 11, 0, 13, 18, 14, 16, 30, 16, 14, 16, 16, 0, 13, 18, 13, 13, 32, 12, 14, 12, 13, 0, 13, 8, 14, 18, 17, 13, 13, 15, 8, 0, 11, 21, 14, 11, 15, 9, 14, 14, 9, 0, 5, 28, 14, 17, 15, 15, 13, 11, 14, 0, 7, 16, 11, 18, 32, 15, 13, 21, 11, 0, 14, 19, 13, 13, 23, 11, 11, 13, 11, 0, 8, 19, 11, 19, 25, 14, 14, 17, 16, 0, 13, 15, 8, 9, 26, 13, 14, 11, 8, 0, 10, 13, 13, 13, 28, 17, 9, 14, 10, 0, 12, 8, 12, 9, 14, 20, 11, 18, 11, 0, 11, 19, 14, 18, 25, 19, 7, 9, 9, 0, 14, 14, 14, 19, 21, 13, 11, 14, 7, 0, 10, 12, 14, 11, 17, 16, 16, 22, 15, 0, 7, 13, 13, 14, 19, 9, 11, 11, 13, 0, 11, 14, 13, 13, 35, 6, 13, 14, 18, 0, 9, 15, 10, 18, 23, 17, 9, 14, 15, 0, 13, 15, 17, 9, 28, 20, 15, 15, 12, 0, 14, 15, 7, 13, 21, 18, 6, 6, 6, 0, 11, 18, 10, 13, 19, 16, 16, 6, 6, 0, 15, 22, 9, 20, 40, 14, 14, 19, 6, 0, 7, 21, 13, 13, 23, 14, 13, 8, 12, 0, 13, 15, 14, 14, 26, 11, 14, 17, 12, 0, 13, 18, 14, 19, 38, 14, 11, 12, 9, 0, 12, 12, 13, 20, 18, 13, 11, 14, 8, 0, 12, 16, 10, 13, 29, 13, 6, 16, 7, 0, 12, 11, 15, 14, 16, 14, 13, 19, 13, 0, 12, 8, 14, 12, 19, 19, 14, 12, 16, 0, 18, 17, 12, 14, 27, 14, 13, 16, 11, 0, 17, 15, 13, 13, 29, 17, 17, 6, 6, 0, 11, 14, 14, 18, 34, 14, 13, 19, 6, 0, 13, 12, 15, 8, 18, 14, 14, 18, 13, 0, 13, 16, 11, 13, 15, 14, 13, 14, 13, 0, 15, 14, 9, 9, 15, 13, 13, 7, 11, 0, 13, 12, 14, 18, 24, 14, 12, 14, 7, 0, 15, 16, 12, 14, 16, 14, 9, 16, 8, 0, 11, 15, 14, 13, 28, 15, 16, 12, 15, 0, 11, 19, 15, 13, 28, 18, 11, 14, 13, 0, 12, 13, 13, 20, 16, 13, 11, 17, 11, 0, 14, 13, 10, 23, 15, 16, 8, 18, 11, 0, 10, 12, 8, 14, 21, 13, 14, 11, 6, 0, 9, 18, 13, 17, 22, 17, 12, 16, 13, 0, 15, 8, 14, 19, 21, 18, 14, 13, 9, 0, 8, 17, 13, 5, 27, 13, 5, 11, 14, 0, 11, 18, 11, 20, 30, 14, 8, 15, 10, 0, 13, 8, 9, 17, 37, 19, 17, 13, 15, 0, 7, 13, 12, 13, 22, 12, 5, 13, 14, 0, 11, 13, 13, 20, 13, 16, 12, 12, 7, 0, 17, 13, 14, 9, 15, 12, 12, 10, 11, 0, 12, 21, 13, 8, 24, 12, 12, 13, 11, 0, 8, 12, 10, 7, 19, 14, 11, 14, 13, 0, 13, 14, 9, 9, 23, 12, 14, 13, 14, 0, 15, 14, 12, 8, 14, 15, 11, 16, 15, 0, 11, 13, 13, 15, 32, 13, 12, 14, 15, 0, 13, 11, 12, 18, 21, 14, 11, 16, 12, 0, 18, 14, 15, 13, 27, 21, 13, 16, 10, 0, 11, 11, 12, 17, 26, 17, 8, 15, 11, 0, 7, 10, 15, 15, 15, 16, 11, 8, 13, 0, 11, 17, 11, 11, 16, 22, 15, 8, 14, 0, 10, 20, 11, 14, 24, 17, 14, 15, 13, 0, 12, 16, 15, 17, 189, 18, 13, 20, 12, 0, 18, 19, 11, 13, 23, 13, 11, 14, 6, 0, 15, 17, 10, 6, 22, 13, 15, 16, 9, 0, 11, 6, 9, 12, 29, 15, 11, 8, 13, 0, 13, 11, 13, 6, 22, 7, 18, 9, 15, 0, 17, 16, 12, 18, 33, 13, 9, 16, 15, 0, 13, 14, 12, 14, 27, 14, 14, 14, 6, 0, 13, 15, 14, 13, 20, 13, 17, 7, 12, 0, 9, 24, 14, 12, 15, 17, 12, 17, 14, 0, 14, 14, 12, 11, 24, 13, 11, 20, 8, 0, 13, 19, 18, 13, 35, 12, 14, 9, 13, 0, 7, 18, 12, 20, 28, 22, 11, 13, 10, 0, 12, 14, 11, 14, 21, 17, 15, 14, 12, 0, 13, 12, 15, 14, 23, 14, 14, 18, 12, 0, 13, 12, 14, 6, 24, 18, 14, 13, 9, 0, 14, 20, 12, 13, 34, 17, 17, 14, 15, 0, 12, 16, 14, 9, 23, 15, 5, 14, 12, 0, 17, 20, 12, 19, 19, 19, 15, 22, 19, 0, 8, 15, 17, 14, 21, 8, 13, 14, 13, 0, 13, 17, 11, 15, 29, 7, 11, 14, 15, 0, 15, 13, 13, 19, 34, 9, 14, 16, 15, 0, 15, 16, 12, 11, 21, 12, 13, 14, 12, 0, 7, 23, 12, 18, 21, 14, 12, 7, 8, 0, 11, 18, 14, 9, 36, 12, 11, 8, 14, 0, 5, 5, 13, 17, 18, 17, 8, 11, 16, 0, 5, 16, 13, 14, 15, 17, 14, 7, 11, 0, 11, 10, 9, 17, 24, 10, 14, 13, 6, 0, 13, 21, 14, 16, 21, 12, 18, 14, 8, 0, 13, 10, 13, 14, 18, 17, 12, 17, 15, 0, 14, 16, 15, 13, 24, 15, 15, 10, 15, 0, 12, 16, 14, 13, 29, 18, 9, 16, 9, 0, 8, 18, 6, 13, 30, 15, 12, 12, 10, 0, 16, 19, 11, 13, 22, 16, 13, 23, 13, 0, 11, 14, 13, 10, 23, 7, 14, 42, 11, 0, 5, 11, 11, 13, 11, 14, 13, 16, 13, 0, 12, 12, 9, 9, 25, 13, 16, 11, 9, 0, 13, 13, 11, 14, 21, 17, 12, 21, 11, 0, 13, 11, 13, 11, 131, 18, 12, 13, 9, 0, 17, 12, 8, 10, 25, 13, 11, 19, 15, 0, 11, 14, 11, 6, 22, 10, 8, 14, 17, 0, 16, 15, 12, 12, 25, 11, 13, 18, 12, 0, 15, 12, 14, 19, 29, 17, 13, 14, 8, 0, 13, 13, 13, 19, 18, 9, 14, 15, 10, 0, 13, 15, 10, 26, 16, 15, 12, 14, 16, 0, 15, 13, 8, 17, 15, 15, 14, 13, 13, 0, 12, 18, 15, 14, 23, 13, 13, 14, 11, 0, 15, 11, 14, 17, 23, 29, 13, 16, 8, 0, 14, 13, 13, 16, 24, 20, 12, 15, 13, 0, 14, 13, 11, 15, 34, 9, 15, 13, 13, 0, 9, 20, 17, 13, 20, 11, 12, 9, 13, 0, 13, 14, 13, 14, 33, 14, 9, 18, 14, 0, 13, 15, 7, 17, 23, 18, 8, 14, 6, 0, 9, 8, 17, 9, 25, 11, 13, 12, 12, 0, 10, 14, 12, 15, 14, 16, 9, 14, 12, 0, 13, 17, 7, 15, 21, 14, 13, 7, 8, 0, 12, 14, 14, 13, 25, 13, 14, 18, 12, 0, 13, 20, 7, 17, 29, 12, 9, 15, 15, 0, 10, 15, 7, 17, 21, 17, 10, 11, 8, 0, 16, 13, 10, 13, 24, 7, 13, 18, 7, 0, 12, 11, 12, 18, 22, 18, 14, 13, 7, 0, 8, 13, 13, 15, 35, 10, 14, 14, 13, 0, 13, 14, 11, 13, 17, 12, 8, 14, 16, 0, 16, 14, 12, 13, 23, 14, 11, 16, 14, 0, 12, 19, 16, 17, 17, 17, 9, 14, 14, 0, 11, 21, 13, 6, 21, 18, 13, 16, 13, 0, 10, 16, 10, 16, 31, 11, 10, 18, 10, 0, 13, 14, 15, 17, 26, 12, 11, 13, 10, 0, 8, 16, 12, 14, 20, 17, 9, 15, 16, 0, 14, 12, 13, 14, 22, 16, 15, 17, 12, 0, 16, 14, 10, 10, 23, 14, 14, 6, 6, 0, 13, 18, 7, 15, 38, 18, 11, 14, 6, 0, 14, 20, 13, 17, 21, 13, 11, 11, 13, 0, 8, 14, 12, 14, 23, 12, 12, 12, 13, 0, 14, 8, 14, 11, 24, 19, 13, 11, 14, 0, 13, 15, 11, 11, 30, 11, 14, 15, 9, 0, 14, 16, 18, 19, 30, 17, 7, 11, 13, 0, 7, 14, 16, 36, 22, 10, 14, 13, 11, 0, 9, 14, 13, 19, 28, 16, 9, 13, 14, 0, 11, 14, 17, 12, 23, 21, 15, 17, 10, 0, 13, 19, 10, 14, 25, 18, 14, 16, 14, 0, 11, 8, 13, 10, 25, 18, 15, 13, 6, 0, 10, 17, 11, 13, 28, 17, 12, 13, 12, 0, 11, 13, 8, 19, 18, 14, 9, 19, 15, 0, 11, 17, 11, 16, 23, 13, 11, 14, 8, 0, 14, 9, 14, 11, 21, 15, 10, 14, 11, 0, 13, 18, 11, 10, 33, 14, 15, 12, 12, 0, 11, 19, 10, 16, 28, 17, 13, 13, 12, 0, 10, 22, 11, 12, 21, 16, 7, 13, 11, 0, 13, 25, 12, 13, 18, 14, 11, 18, 17, 0, 16, 16, 12, 19, 21, 19, 8, 11, 13, 0, 13, 7, 12, 13, 35, 13, 7, 13, 15, 0, 12, 13, 11, 13, 24, 22, 13, 12, 12, 0, 16, 12, 15, 19, 30, 13, 10, 16, 16, 0, 13, 8, 16, 12, 21, 16, 15, 17, 13, 0, 9, 15, 14, 19, 7, 12, 13, 13, 15, 0, 14, 17, 14, 12, 23, 12, 15, 11, 10, 0, 13, 14, 9, 17, 15, 12, 14, 13, 14, 0, 11, 15, 12, 14, 28, 18, 13, 21, 13, 0, 12, 13, 14, 19, 16, 13, 9, 16, 13, 0, 11, 17, 15, 20, 15, 15, 7, 13, 11, 0, 9, 12, 10, 11, 20, 12, 9, 12, 10, 0, 11, 17, 14, 18, 9, 13, 16, 8, 9, 0, 16, 17, 12, 13, 29, 15, 11, 17, 7, 0, 13, 19, 15, 14, 52, 12, 13, 11, 12, 0, 13, 20, 13, 17, 26, 19, 9, 16, 18, 0, 14, 22, 10, 15, 29, 13, 11, 19, 8, 0, 18, 21, 14, 18, 21, 11, 14, 17, 9, 0, 11, 15, 11, 16, 11, 14, 12, 8, 13, 0, 12, 7, 10, 16, 23, 10, 11, 13, 12, 0, 10, 19, 13, 9, 21, 17, 10, 14, 14, 0, 11, 10, 14, 16, 26, 13, 15, 13, 12, 0, 11, 12, 13, 12, 78, 14, 10, 14, 8, 0, 14, 12, 12, 21, 27, 18, 21, 16, 16, 0, 18, 14, 20, 12, 24, 17, 13, 13, 13, 0, 14, 21, 9, 18, 50, 14, 14, 17, 17, 0, 14, 17, 12, 13, 29, 18, 12, 13, 14, 0, 13, 12, 14, 13, 15, 17, 13, 17, 11, 0, 11, 13, 19, 15, 17, 17, 14, 13, 8, 0, 13, 7, 11, 17, 26, 10, 11, 12, 9, 0, 13, 18, 11, 14, 18, 21, 8, 18, 16, 0, 15, 14, 11, 11, 30, 15, 12, 16, 14, 0, 13, 16, 14, 13, 28, 14, 13, 18, 11, 0, 14, 14, 13, 16, 23, 9, 10, 13, 8, 0, 11, 22, 12, 24, 26, 13, 12, 13, 11, 0, 5, 5, 13, 14, 15, 11, 12, 17, 13, 0, 5, 15, 13, 16, 32, 15, 15, 10, 14, 0, 9, 14, 13, 13, 21, 11, 11, 14, 6, 0, 14, 15, 12, 10, 20, 14, 13, 15, 9, 0, 11, 10, 11, 17, 15, 14, 16, 17, 11, 0, 9, 15, 15, 11, 21, 12, 15, 14, 13, 0, 13, 19, 13, 11, 32, 23, 13, 17, 14, 0, 13, 12, 12, 19, 25, 17, 13, 10, 9, 0, 13, 13, 14, 14, 16, 8, 13, 19, 8, 0, 13, 13, 15, 18, 31, 14, 9, 12, 16, 0, 5, 15, 13, 15, 15, 11, 15, 13, 10, 0, 7, 14, 14, 10, 35, 20, 8, 11, 11, 0, 11, 20, 10, 17, 23, 17, 14, 14, 11, 0, 9, 17, 11, 8, 24, 12, 9, 14, 13, 0, 8, 11, 12, 19, 29, 17, 12, 14, 11, 0, 14, 16, 14, 6, 19, 17, 9, 9, 14, 0, 11, 11, 14, 8, 32, 11, 12, 17, 8, 0, 12, 22, 18, 15, 23, 21, 8, 13, 14, 0, 6, 13, 14, 21, 15, 19, 15, 17, 14, 0, 12, 12, 13, 13, 26, 19, 12, 13, 8, 0, 10, 14, 9, 18, 15, 8, 10, 14, 11, 0, 10, 13, 10, 17, 30, 20, 13, 18, 14, 0, 12, 13, 10, 14, 18, 14, 12, 18, 10, 0, 14, 14, 14, 13, 28, 13, 13, 14, 9, 0, 12, 10, 14, 21, 30, 17, 12, 18, 12, 0, 15, 15, 10, 14, 21, 13, 13, 13, 16, 0, 13, 13, 14, 14, 27, 17, 12, 12, 11, 0, 11, 18, 14, 17, 24, 16, 15, 14, 14, 0, 16, 19, 17, 15, 23, 17, 12, 11, 12, 0, 15, 9, 13, 13, 24, 16, 11, 14, 14, 0, 8, 16, 15, 14, 23, 14, 13, 12, 11, 0, 13, 11, 15, 10, 24, 15, 11, 13, 12, 0, 9, 17, 11, 16, 29, 19, 16, 13, 13, 0, 16, 13, 13, 29, 26, 7, 12, 15, 10, 0, 10, 12, 12, 11, 32, 13, 15, 16, 13, 0, 8, 14, 9, 10, 21, 8, 13, 9, 8, 0, 13, 18, 12, 16, 23, 10, 13, 21, 13, 0, 11, 15, 14, 18, 28, 19, 13, 17, 13, 0, 16, 11, 9, 14, 15, 13, 9, 14, 13, 0, 12, 12, 12, 19, 25, 8, 14, 19, 13, 0, 14, 14, 14, 19, 25, 14, 14, 16, 13, 0, 13, 16, 15, 16, 30, 13, 9, 15, 9, 0, 14, 16, 13, 20, 17, 14, 9, 15, 14, 0, 12, 10, 13, 12, 13, 14, 8, 15, 9, 0, 13, 13, 9, 12, 20, 5, 14, 11, 11, 0, 9, 13, 12, 13, 32, 18, 9, 13, 15, 0, 7, 19, 9, 13, 26, 13, 12, 15, 12, 0, 9, 13, 10, 26, 21, 16, 11, 14, 13, 0, 8, 13, 9, 16, 27, 16, 13, 12, 13, 0, 13, 19, 12, 17, 11, 11, 12, 15, 13, 0, 13, 16, 15, 17, 29, 19, 12, 13, 10, 0, 13, 18, 14, 14, 465, 9, 9, 14, 11, 0, 13, 14, 19, 19, 27, 14, 9, 12, 8, 0, 14, 29, 14, 11, 21, 16, 12, 18, 11, 0, 7, 14, 13, 13, 32, 17, 14, 13, 14, 0, 9, 12, 11, 16, 24, 13, 13, 17, 13, 0, 9, 13, 12, 11, 34, 19, 10, 14, 6, 0, 14, 13, 13, 19, 27, 19, 10, 14, 16, 0, 11, 14, 11, 20, 29, 14, 13, 19, 11, 0, 14, 15, 9, 19, 21, 11, 13, 13, 11, 0, 13, 22, 12, 13, 23, 8, 14, 23, 13, 0, 13, 14, 13, 8, 53, 17, 13, 18, 13, 0, 15, 15, 14, 19, 21, 14, 13, 12, 12, 0, 14, 18, 7, 21, 22, 15, 14, 16, 16, 0, 15, 14, 13, 16, 16, 9, 13, 14, 13, 0, 15, 12, 12, 18, 22, 11, 14, 13, 12, 0, 11, 12, 10, 13, 29, 20, 13, 20, 12, 0, 14, 17, 8, 15, 23, 14, 11, 15, 17, 0, 7, 16, 13, 17, 27, 15, 11, 22, 16, 0, 14, 14, 13, 13, 23, 15, 8, 11, 8, 0, 14, 6, 13, 17, 23, 11, 10, 19, 16, 0, 15, 14, 12, 11, 23, 15, 11, 16, 11, 0, 13, 19, 11, 17, 24, 9, 14, 12, 12, 0, 12, 15, 18, 11, 20, 15, 13, 17, 12, 0, 11, 19, 14, 20, 23, 14, 13, 14, 12, 0, 13, 18, 12, 10, 32, 18, 14, 18, 10, 0, 15, 26, 6, 6, 6, 6, 14, 13, 11, 0, 16, 14, 6, 16, 12, 18, 13, 6, 19, 0, 11, 16, 6, 10, 34, 13, 15, 9, 9, 0, 14, 17, 6, 27, 28, 14, 7, 14, 13, 0, 15, 13, 18, 13, 32, 6, 7, 15, 14, 0, 14, 14, 13, 12, 90, 14, 18, 12, 10, 0, 15, 19, 17, 12, 27, 13, 7, 18, 13, 0, 11, 18, 14, 12, 23, 14, 15, 14, 10, 0, 13, 16, 9, 15, 23, 14, 8, 16, 12, 0, 10, 17, 14, 14, 21, 22, 12, 9, 14, 0, 17, 14, 6, 16, 29, 13, 13, 14, 8, 0, 12, 17, 15, 22, 28, 9, 13, 13, 16, 0, 13, 14, 12, 16, 20, 16, 14, 12, 12, 0, 12, 14, 15, 16, 34, 21, 16, 16, 8, 0, 14, 14, 18, 18, 14, 6, 12, 18, 16, 0, 17, 18, 6, 14, 20, 21, 13, 13, 11, 0, 12, 14, 10, 14, 15, 12, 12, 13, 11, 0, 13, 10, 11, 17, 18, 12, 13, 20, 15, 0, 11, 15, 14, 14, 23, 13, 10, 17, 9, 0, 12, 18, 11, 19, 12, 13, 13, 12, 12, 0, 8, 7, 6, 13, 32, 18, 14, 19, 12, 0, 14, 11, 12, 16, 21, 13, 11, 11, 16, 0, 12, 13, 12, 13, 61, 19, 8, 19, 14, 0, 19, 11, 15, 8, 27, 7, 12, 11, 7, 0, 5, 18, 14, 17, 30, 14, 13, 15, 7, 0, 13, 10, 12, 14, 23, 16, 13, 23, 20, 0, 17, 15, 11, 20, 15, 10, 14, 12, 11, 0, 17, 15, 16, 22, 33, 13, 13, 12, 13, 0, 14, 16, 12, 17, 21, 17, 14, 14, 6, 0, 14, 14, 12, 16, 20, 16, 14, 11, 9, 0, 11, 12, 6, 13, 33, 12, 12, 10, 14, 0, 12, 13, 15, 13, 26, 9, 15, 14, 16, 0, 13, 10, 15, 8, 16, 16, 8, 13, 8, 0, 14, 19, 13, 18, 23, 16, 13, 13, 13, 0, 11, 18, 8, 13, 29, 13, 7, 14, 7, 0, 12, 19, 9, 22, 34, 18, 14, 20, 14, 0, 11, 12, 16, 16, 24, 14, 11, 15, 8, 0, 11, 17, 11, 19, 29, 15, 6, 7, 15, 0, 13, 18, 15, 13, 17, 17, 15, 15, 14, 0, 9, 18, 14, 12, 26, 14, 15, 13, 12, 0, 12, 20, 15, 19, 35, 10, 11, 13, 13, 0, 10, 17, 12, 14, 17, 15, 16, 21, 12, 0, 15, 15, 13, 15, 18, 15, 12, 14, 13, 0, 13, 13, 6, 18, 15, 18, 9, 13, 14, 0, 14, 15, 13, 11, 20, 15, 6, 15, 13, 0, 12, 19, 16, 14, 32, 20, 15, 16, 13, 0, 8, 14, 9, 18, 27, 15, 12, 14, 13, 0, 15, 18, 8, 14, 21, 12, 14, 13, 13, 0, 10, 19, 12, 17, 24, 14, 11, 18, 12, 0, 13, 13, 13, 19, 26, 18, 13, 14, 10, 0, 13, 16, 13, 14, 23, 12, 13, 18, 12, 0, 16, 14, 14, 7, 17, 17, 10, 17, 6, 0, 13, 17, 14, 16, 21, 13, 15, 14, 14, 0, 13, 14, 17, 10, 24, 17, 13, 17, 14, 0, 9, 14, 15, 19, 22, 22, 12, 16, 11, 0, 8, 13, 10, 12, 29, 12, 16, 12, 13, 0, 15, 19, 8, 13, 20, 16, 8, 20, 16, 0, 14, 13, 11, 11, 22, 17, 12, 12, 13, 0, 13, 13, 7, 21, 26, 11, 10, 20, 16, 0, 13, 14, 10, 16, 38, 19, 13, 18, 9, 0, 14, 7, 18, 15, 18, 19, 13, 17, 10, 0, 15, 14, 13, 13, 26, 16, 7, 13, 13, 0, 12, 12, 13, 15, 16, 13, 14, 20, 9, 0, 12, 14, 17, 11, 21, 13, 12, 15, 13, 0, 12, 24, 12, 13, 29, 16, 8, 17, 14, 0, 10, 14, 18, 14, 25, 16, 11, 14, 13, 0, 16, 15, 13, 19, 23, 15, 13, 15, 8, 0, 13, 21, 9, 16, 27, 14, 6, 17, 13, 0, 13, 11, 14, 16, 21, 15, 11, 21, 14, 0, 14, 11, 11, 9, 16, 14, 11, 17, 11, 0, 9, 11, 15, 14, 24, 45, 13, 14, 14, 0, 12, 18, 12, 16, 14, 18, 13, 17, 9, 0, 10, 16, 9, 15, 22, 13, 15, 16, 14, 0, 16, 14, 12, 12, 29, 12, 13, 22, 7, 0, 11, 14, 12, 21, 26, 9, 9, 19, 8, 0, 9, 13, 7, 15, 20, 11, 14, 14, 11, 0, 9, 13, 15, 7, 27, 14, 15, 14, 16, 0, 13, 19, 9, 17, 24, 19, 13, 13, 14, 0, 9, 14, 7, 15, 29, 9, 15, 13, 11, 0, 15, 17, 15, 14, 129, 24, 13, 13, 14, 0, 15, 10, 12, 17, 12, 15, 13, 14, 11, 0, 9, 8, 12, 11, 25, 20, 14, 15, 13, 0, 13, 19, 11, 12, 20, 11, 12, 14, 16, 0, 14, 13, 10, 22, 31, 20, 12, 16, 11, 0, 15, 13, 9, 14, 24, 19, 10, 12, 15, 0, 11, 13, 13, 11, 29, 15, 13, 16, 9, 0, 12, 15, 7, 17, 14, 19, 12, 15, 13, 0, 14, 16, 18, 13, 25, 18, 13, 9, 10, 0, 12, 18, 12, 14, 15, 17, 14, 14, 8, 0, 9, 20, 14, 14, 22, 16, 13, 17, 13, 0, 18, 18, 12, 13, 40, 13, 13, 11, 9, 0, 9, 19, 11, 14, 29, 16, 15, 13, 8, 0, 17, 11, 9, 13, 27, 12, 14, 14, 13, 0, 12, 26, 13, 16, 14, 15, 8, 16, 13, 0, 15, 13, 16, 14, 29, 20, 10, 21, 13, 0, 7, 17, 12, 14, 19, 17, 12, 9, 14, 0, 17, 18, 10, 13, 109, 14, 13, 21, 11, 0, 15, 19, 12, 12, 23, 23, 13, 14, 15, 0, 13, 12, 12, 17, 16, 13, 13, 11, 11, 0, 9, 19, 10, 27, 18, 20, 12, 17, 13, 0, 13, 8, 6, 12, 29, 17, 13, 14, 10, 0, 16, 11, 11, 13, 30, 15, 13, 14, 15, 0, 7, 11, 13, 16, 26, 18, 9, 16, 14, 0, 16, 15, 13, 14, 26, 19, 10, 17, 8, 0, 9, 18, 13, 13, 25, 12, 12, 19, 14, 0, 14, 13, 10, 9, 24, 17, 17, 27, 13, 0, 12, 15, 13, 21, 18, 15, 20, 14, 11, 0, 14, 19, 10, 11, 16, 14, 12, 13, 18, 0, 14, 13, 10, 12, 25, 14, 10, 13, 11, 0, 8, 19, 15, 16, 21, 20, 11, 13, 10, 0, 12, 15, 14, 14, 26, 17, 14, 12, 14, 0, 8, 20, 21, 8, 26, 13, 15, 16, 14, 0, 8, 22, 12, 14, 34, 17, 15, 13, 8, 0, 13, 14, 9, 16, 18, 12, 13, 18, 11, 0, 14, 15, 13, 20, 23, 13, 7, 10, 13, 0, 9, 16, 15, 15, 18, 18, 16, 13, 8, 0, 16, 13, 7, 16, 17, 12, 5, 15, 8, 0, 13, 15, 9, 12, 25, 14, 13, 13, 18, 0, 18, 18, 10, 15, 28, 27, 11, 14, 13, 0, 14, 16, 11, 13, 9, 18, 12, 12, 12, 0, 8, 7, 17, 12, 25, 11, 14, 18, 10, 0, 14, 14, 14, 18, 25, 18, 15, 22, 17, 0, 11, 15, 15, 60, 22, 18, 13, 14, 13, 0, 16, 15, 10, 20, 25, 13, 13, 16, 14, 0, 5, 12, 15, 14, 27, 14, 12, 14, 11, 0, 11, 19, 12, 15, 23, 20, 13, 14, 14, 0, 13, 14, 15, 11, 25, 14, 16, 19, 8, 0, 17, 21, 13, 15, 21, 14, 13, 13, 11, 0, 11, 24, 13, 14, 20, 14, 15, 15, 10, 0, 14, 9, 13, 14, 26, 16, 15, 19, 17, 0, 17, 13, 17, 12, 35, 13, 11, 17, 13, 0, 13, 16, 15, 22, 24, 14, 8, 17, 10, 0, 10, 15, 15, 16, 29, 15, 14, 16, 14, 0, 10, 17, 10, 19, 61, 11, 13, 13, 11, 0, 15, 14, 15, 13, 18, 15, 13, 13, 16, 0, 11, 19, 16, 12, 24, 14, 11, 12, 15, 0, 15, 19, 11, 21, 27, 12, 10, 18, 14, 0, 9, 8, 12, 14, 20, 12, 13, 13, 14, 0, 14, 18, 11, 17, 14, 19, 16, 19, 8, 0, 16, 13, 10, 13, 23, 16, 15, 13, 9, 0, 13, 14, 12, 18, 38, 13, 13, 15, 13, 0, 9, 17, 15, 6, 12, 19, 10, 13, 13, 0, 8, 10, 9, 19, 32, 20, 9, 20, 14, 0, 16, 6, 6, 12, 26, 14, 12, 12, 13, 0, 14, 20, 16, 15, 15, 6, 12, 13, 13, 0, 17, 17, 13, 15, 46, 13, 12, 15, 10, 0, 16, 13, 13, 10, 22, 13, 12, 19, 10, 0, 16, 14, 14, 30, 15, 13, 16, 15, 11, 0, 16, 13, 11, 15, 32, 9, 12, 14, 9, 0, 12, 19, 13, 14, 25, 10, 11, 17, 12, 0, 11, 9, 6, 17, 22, 14, 13, 13, 18, 0, 11, 14, 13, 11, 18, 14, 12, 21, 11, 0, 12, 13, 10, 17, 24, 15, 15, 18, 16, 0, 11, 19, 14, 12, 29, 14, 12, 7, 13, 0, 14, 18, 17, 14, 29, 15, 13, 21, 16, 0, 11, 18, 13, 14, 27, 11, 12, 18, 10, 0, 14, 12, 11, 10, 32, 13, 9, 19, 10, 0, 12, 21, 8, 9, 26, 12, 11, 15, 12, 0, 13, 23, 14, 17, 16, 16, 14, 16, 15, 0, 8, 16, 13, 13, 16, 19, 14, 16, 9, 0, 10, 13, 13, 17, 29, 12, 12, 13, 8, 0, 13, 13, 10, 13, 17, 10, 13, 13, 9, 0, 16, 14, 11, 13, 25, 13, 15, 16, 11, 0, 14, 19, 16, 21, 29, 13, 17, 14, 9, 0, 13, 10, 12, 21, 23, 17, 13, 18, 15, 0, 12, 19, 13, 14, 34, 17, 8, 9, 14, 0, 13, 14, 7, 18, 24, 13, 13, 12, 7, 0, 13, 15, 11, 15, 18, 19, 10, 19, 12, 0, 14, 14, 16, 19, 23, 13, 12, 14, 11, 0, 15, 15, 11, 17, 18, 18, 12, 14, 14, 0, 17, 17, 13, 19, 53, 10, 10, 11, 12, 0, 16, 12, 11, 22, 15, 14, 10, 15, 18, 0, 13, 18, 6, 16, 26, 19, 11, 17, 15, 0, 6, 19, 8, 11, 24, 18, 12, 15, 16, 0, 10, 17, 16, 19, 52, 17, 8, 16, 18, 0, 14, 13, 11, 13, 15, 18, 14, 17, 8, 0, 10, 20, 14, 18, 15, 14, 7, 17, 6, 0, 9, 19, 14, 15, 29, 17, 18, 11, 13, 0, 13, 12, 13, 15, 21, 16, 14, 14, 6, 0, 16, 10, 8, 20, 17, 13, 13, 12, 13, 0, 14, 16, 12, 18, 92, 6, 10, 15, 14, 0, 8, 14, 12, 18, 29, 19, 16, 13, 10, 0, 17, 17, 16, 14, 27, 22, 13, 13, 13, 0, 11, 17, 13, 8, 20, 17, 12, 16, 12, 0, 13, 14, 15, 16, 15, 15, 10, 15, 14, 0, 14, 16, 8, 18, 28, 12, 14, 15, 13, 0, 10, 12, 13, 14, 20, 16, 15, 10, 13, 0, 12, 14, 17, 12, 50, 15, 16, 14, 11, 0, 14, 16, 8, 13, 14, 13, 17, 10, 13, 0, 14, 20, 12, 14, 32, 14, 15, 15, 15, 0, 10, 15, 15, 15, 21, 12, 15, 11, 13, 0, 14, 9, 14, 13, 17, 15, 9, 8, 12, 0, 10, 20, 19, 14, 17, 16, 7, 14, 14, 0, 11, 13, 10, 21, 32, 14, 14, 16, 14, 0, 12, 16, 13, 11, 24, 12, 13, 19, 13, 0, 9, 19, 14, 19, 22, 13, 10, 16, 13, 0, 10, 9, 14, 13, 10, 17, 13, 10, 12, 0, 9, 14, 12, 19, 25, 12, 13, 11, 11, 0, 10, 18, 13, 12, 25, 14, 9, 18, 13, 0, 15, 13, 8, 14, 21, 13, 8, 15, 12, 0, 11, 15, 6, 21, 36, 18, 13, 17, 14, 0, 14, 20, 13, 12, 22, 47, 11, 19, 17, 0, 12, 15, 15, 19, 21, 13, 10, 19, 12, 0, 13, 19, 14, 14, 25, 14, 15, 14, 10, 0, 8, 15, 9, 18, 21, 13, 15, 13, 13, 0, 14, 14, 17, 12, 27, 7, 11, 14, 11, 0, 18, 11, 15, 19, 28, 22, 11, 11, 15, 0, 12, 8, 11, 14, 38, 14, 11, 19, 14, 0, 14, 19, 9, 18, 30, 14, 13, 19, 15, 0, 16, 19, 14, 20, 27, 14, 11, 9, 10, 0, 10, 11, 13, 11, 15, 8, 10, 10, 13, 0, 14, 22, 15, 8, 29, 10, 14, 15, 11, 0, 19, 11, 12, 19, 25, 14, 8, 17, 11, 0, 14, 16, 16, 12, 20, 13, 12, 13, 14, 0, 14, 16, 14, 14, 25, 16, 12, 12, 15, 0, 13, 19, 16, 14, 29, 15, 14, 13, 13, 0, 12, 13, 9, 10, 21, 14, 12, 20, 12, 0, 12, 19, 10, 14, 12, 19, 12, 14, 11, 0, 9, 13, 17, 22, 30, 8, 8, 21, 12, 0, 12, 11, 19, 17, 23, 14, 13, 11, 13, 0, 12, 13, 11, 13, 35, 13, 12, 13, 9, 0, 14, 18, 19, 13, 14, 20, 15, 12, 11, 0, 15, 16, 16, 20, 36, 14, 13, 19, 14, 0, 17, 14, 13, 16, 24, 19, 13, 14, 10, 0, 5, 14, 15, 18, 24, 15, 13, 14, 8, 0, 12, 16, 9, 19, 52, 11, 11, 14, 11, 0, 13, 13, 14, 19, 22, 10, 14, 18, 14, 0, 13, 12, 13, 30, 25, 15, 8, 13, 17, 0, 17, 17, 12, 15, 19, 13, 12, 19, 13, 0, 14, 13, 10, 19, 16, 21, 14, 14, 14, 0, 9, 13, 12, 12, 24, 16, 12, 18, 15, 0, 15, 10, 8, 12, 24, 10, 11, 19, 12, 0, 16, 14, 14, 14, 14, 14, 13, 14, 16, 0, 13, 21, 9, 9, 32, 9, 12, 17, 13, 0, 16, 9, 14, 16, 7, 13, 16, 20, 17, 0, 13, 15, 14, 21, 29, 18, 12, 19, 12, 0, 15, 12, 13, 13, 24, 15, 17, 18, 11, 0, 13, 16, 13, 16, 21, 17, 13, 9, 13, 0, 7, 20, 10, 6, 21, 18, 14, 18, 14, 0, 13, 16, 15, 13, 25, 20, 14, 17, 11, 0, 14, 20, 17, 17, 25, 12, 9, 12, 13, 0, 12, 13, 15, 17, 23, 16, 9, 14, 14, 0, 11, 14, 12, 13, 20, 8, 13, 21, 13, 0, 13, 14, 11, 13, 25, 20, 14, 11, 13, 0, 11, 17, 14, 11, 61, 20, 11, 14, 14, 0, 15, 21, 11, 20, 33, 17, 16, 15, 11, 0, 12, 9, 12, 15, 25, 13, 11, 14, 15, 0, 10, 13, 13, 10, 27, 14, 11, 14, 14, 0, 15, 8, 15, 18, 29, 13, 14, 20, 11, 0, 12, 15, 13, 16, 27, 14, 11, 14, 13, 0, 15, 11, 14, 15, 21, 17, 12, 13, 10, 0, 14, 12, 13, 19, 30, 12, 11, 15, 13, 0, 8, 16, 9, 13, 24, 15, 11, 18, 16, 0, 14, 17, 12, 13, 21, 14, 17, 13, 7, 0, 14, 17, 12, 14, 17, 12, 17, 15, 13, 0, 10, 20, 13, 16, 34, 6, 15, 23, 16, 0, 13, 30, 12, 12, 20, 13, 13, 18, 12, 0, 12, 10, 15, 15, 29, 11, 12, 12, 12, 0, 10, 11, 17, 20, 24, 13, 8, 11, 12, 0, 12, 14, 9, 25, 29, 18, 15, 13, 13, 0, 13, 11, 8, 14, 33, 17, 13, 14, 13, 0, 13, 13, 9, 10, 20, 20, 13, 10, 11, 0, 14, 13, 16, 22, 29, 16, 15, 14, 13, 0, 17, 18, 15, 13, 28, 13, 13, 21, 19, 0, 8, 14, 13, 16, 24, 13, 14, 20, 6, 0, 6, 6, 11, 14, 35, 20, 6, 18, 13, 0, 13, 17, 8, 15, 25, 6, 6, 16, 11, 0, 12, 16, 16, 10, 25, 18, 6, 19, 14, 0, 18, 6, 13, 12, 33, 15, 18, 13, 17, 0, 16, 9, 10, 13, 26, 17, 10, 13, 13, 0, 12, 15, 8, 9, 25, 13, 14, 8, 13, 0, 13, 19, 12, 12, 29, 12, 12, 11, 17, 0, 11, 13, 16, 15, 24, 81, 13, 20, 13, 0, 9, 6, 13, 15, 29, 8, 15, 19, 14, 0, 14, 13, 13, 16, 23, 17, 18, 17, 11, 0, 14, 20, 16, 19, 14, 11, 15, 22, 12, 0, 17, 10, 14, 10, 28, 14, 17, 11, 11, 0, 12, 16, 14, 12, 34, 12, 11, 13, 13, 0, 9, 12, 11, 19, 41, 18, 12, 14, 14, 0, 11, 15, 8, 14, 30, 15, 15, 14, 12, 0, 9, 18, 17, 14, 38, 10, 15, 19, 11, 0, 11, 15, 16, 11, 44, 6, 6, 28, 14, 0, 15, 18, 9, 15, 23, 16, 15, 21, 8, 0, 13, 6, 9, 13, 21, 14, 11, 16, 17, 0, 13, 19, 15, 15, 26, 11, 15, 22, 10, 0, 9, 14, 10, 15, 14, 19, 16, 13, 17, 0, 11, 9, 6, 15, 18, 14, 17, 13, 14, 0, 14, 15, 13, 14, 14, 12, 14, 15, 12, 0, 11, 11, 13, 8, 32, 11, 12, 18, 9, 0, 14, 16, 14, 14, 21, 21, 14, 22, 10, 0, 11, 15, 13, 14, 28, 12, 14, 13, 16, 0, 13, 20, 13, 17, 27, 8, 9, 13, 13, 0, 16, 11, 14, 14, 18, 18, 12, 13, 16, 0, 11, 11, 14, 14, 24, 19, 11, 15, 9, 0, 11, 16, 13, 12, 22, 13, 15, 17, 9, 0, 8, 16, 10, 15, 35, 20, 13, 22, 14, 0, 14, 16, 13, 14, 15, 14, 13, 14, 14, 0, 13, 19, 14, 16, 29, 14, 15, 22, 14, 0, 16, 6, 14, 17, 29, 17, 11, 20, 12, 0, 12, 14, 13, 21, 30, 10, 15, 16, 13, 0, 10, 14, 6, 14, 16, 19, 9, 17, 13, 0, 13, 13, 12, 18, 15, 17, 9, 17, 6, 0, 20, 13, 15, 16, 14, 13, 13, 12, 13, 0, 11, 15, 11, 16, 18, 13, 10, 11, 13, 0, 16, 14, 16, 20, 26, 20, 16, 20, 16, 0, 15, 13, 13, 19, 37, 19, 18, 15, 9, 0, 15, 14, 12, 14, 22, 13, 14, 15, 9, 0, 15, 14, 14, 42, 13, 21, 10, 15, 15, 0, 14, 12, 13, 14, 19, 18, 14, 10, 11, 0, 15, 20, 13, 14, 13, 14, 16, 13, 15, 0, 11, 13, 14, 18, 46, 21, 14, 17, 13, 0, 21, 17, 15, 17, 25, 20, 14, 12, 11, 0, 13, 9, 15, 12, 27, 11, 16, 17, 13, 0, 18, 14, 14, 11, 26, 17, 16, 13, 16, 0, 12, 14, 11, 10, 18, 14, 14, 11, 7, 0, 17, 16, 16, 13, 34, 15, 13, 10, 13, 0, 15, 17, 15, 16, 29, 20, 12, 21, 15, 0, 13, 19, 8, 14, 31, 18, 14, 14, 11, 0, 7, 14, 13, 13, 38, 19, 14, 13, 11, 0, 14, 14, 13, 15, 24, 10, 13, 17, 17, 0, 11, 15, 17, 13, 34, 22, 11, 15, 15, 0, 8, 20, 17, 17, 32, 15, 10, 19, 13, 0, 12, 14, 14, 16, 23, 18, 11, 13, 8, 0, 14, 12, 17, 22, 24, 16, 13, 18, 13, 0, 5, 18, 17, 11, 27, 13, 16, 18, 13, 0, 9, 18, 12, 15, 13, 19, 15, 7, 9, 0, 8, 19, 14, 13, 22, 13, 15, 18, 13, 0, 15, 14, 13, 13, 27, 12, 13, 13, 13, 0, 12, 14, 12, 17, 15, 11, 17, 16, 7, 0, 13, 16, 17, 7, 20, 13, 16, 26, 16, 0, 14, 19, 13, 20, 29, 12, 13, 20, 11, 0, 11, 17, 11, 12, 26, 10, 14, 14, 16, 0, 12, 6, 11, 22, 29, 20, 14, 17, 17, 0, 6, 17, 12, 14, 22, 14, 12, 13, 11, 0, 14, 19, 11, 13, 20, 19, 12, 17, 10, 0, 13, 19, 13, 7, 34, 13, 11, 15, 14, 0, 16, 19, 12, 17, 31, 14, 13, 12, 18, 0, 16, 21, 15, 19, 27, 17, 12, 14, 13, 0, 13, 16, 10, 13, 23, 14, 15, 17, 14, 0, 13, 17, 11, 19, 24, 17, 9, 16, 13, 0, 18, 13, 11, 20, 30, 20, 11, 13, 16, 0, 10, 16, 11, 17, 24, 17, 14, 13, 13, 0, 14, 18, 16, 16, 21, 22, 11, 15, 14, 0, 7, 11, 14, 14, 28, 18, 13, 13, 18, 0, 11, 11, 13, 14, 15, 8, 13, 12, 15, 0, 14, 15, 13, 16, 24, 17, 12, 14, 11, 0, 11, 14, 13, 11, 29, 16, 14, 14, 15, 0, 14, 14, 11, 22, 25, 19, 11, 16, 13, 0, 17, 6, 18, 9, 16, 12, 10, 12, 12, 0, 13, 13, 11, 18, 18, 18, 14, 7, 7, 0, 14, 15, 18, 17, 31, 21, 13, 15, 12, 0, 10, 10, 13, 16, 27, 20, 12, 15, 11, 0, 16, 19, 13, 21, 14, 18, 13, 9, 17, 0, 12, 19, 14, 13, 33, 18, 13, 16, 16, 0, 14, 18, 14, 16, 24, 14, 15, 19, 14, 0, 15, 13, 16, 21, 189, 16, 13, 13, 14, 0, 13, 9, 13, 21, 23, 15, 12, 22, 10, 0, 14, 17, 15, 17, 14, 8, 13, 12, 13, 0, 16, 14, 12, 16, 33, 15, 12, 14, 13, 0, 8, 21, 14, 12, 9, 13, 14, 16, 13, 0, 14, 11, 10, 15, 27, 20, 14, 19, 10, 0, 12, 13, 16, 19, 21, 14, 14, 22, 13, 0, 11, 18, 10, 13, 7, 16, 11, 13, 14, 0, 16, 14, 13, 18, 17, 16, 10, 14, 11, 0, 13, 36, 12, 18, 18, 18, 9, 17, 11, 0, 14, 14, 8, 14, 32, 21, 11, 16, 13, 0, 10, 18, 11, 16, 23, 19, 10, 12, 13, 0, 14, 14, 11, 16, 24, 16, 18, 14, 15, 0, 11, 16, 13, 14, 14, 20, 11, 14, 15, 0, 13, 8, 13, 10, 41, 22, 16, 23, 8, 0, 11, 17, 12, 20, 30, 15, 10, 14, 11, 0, 10, 19, 16, 13, 24, 20, 11, 11, 14, 0, 10, 12, 11, 16, 22, 19, 13, 20, 13, 0, 16, 13, 13, 12, 27, 10, 14, 13, 17, 0, 14, 16, 14, 22, 23, 20, 15, 20, 12, 0, 11, 17, 16, 12, 19, 17, 18, 16, 11, 0, 8, 8, 15, 18, 28, 15, 10, 14, 13, 0, 15, 10, 13, 10, 23, 18, 13, 19, 12, 0, 12, 15, 15, 14, 24, 22, 13, 14, 14, 0, 14, 19, 18, 19, 21, 19, 12, 16, 11, 0, 17, 12, 11, 13, 33, 11, 15, 14, 12, 0, 15, 18, 14, 12, 26, 14, 16, 12, 16, 0, 13, 21, 15, 23, 21, 20, 14, 18, 13, 0, 13, 19, 13, 13, 29, 17, 12, 13, 17, 0, 15, 18, 15, 13, 24, 16, 15, 18, 13, 0, 13, 15, 16, 17, 15, 21, 13, 13, 16, 0, 14, 19, 13, 13, 30, 8, 13, 16, 13, 0, 10, 9, 16, 22, 32, 21, 15, 12, 14, 0, 13, 9, 12, 15, 21, 12, 14, 14, 16, 0, 14, 19, 13, 20, 24, 14, 14, 14, 12, 0, 12, 19, 14, 14, 33, 8, 10, 15, 16, 0, 13, 22, 9, 17, 32, 18, 13, 9, 11, 0, 13, 13, 13, 19, 33, 12, 13, 22, 15, 0, 17, 12, 17, 14, 27, 19, 14, 16, 11, 0, 15, 14, 14, 19, 33, 7, 12, 14, 15, 0, 16, 14, 12, 11, 28, 22, 13, 9, 11, 0, 12, 11, 13, 18, 21, 22, 15, 15, 10, 0, 13, 7, 12, 16, 29, 20, 17, 13, 12, 0, 14, 7, 14, 14, 32, 18, 15, 17, 17, 0, 11, 18, 13, 16, 25, 12, 13, 14, 11, 0, 16, 14, 14, 17, 15, 14, 7, 19, 15, 0, 11, 14, 15, 9, 17, 15, 13, 12, 14, 0, 9, 9, 16, 23, 30, 10, 13, 12, 13, 0, 13, 18, 9, 21, 15, 19, 13, 19, 13, 0, 11, 15, 14, 17, 24, 9, 13, 17, 15, 0, 12, 16, 14, 16, 28, 13, 11, 12, 10, 0, 16, 19, 13, 9, 29, 14, 14, 17, 12, 0, 13, 15, 9, 13, 19, 9, 11, 15, 14, 0, 15, 9, 13, 13, 24, 19, 13, 18, 9, 0, 13, 14, 12, 18, 27, 19, 13, 18, 12, 0, 13, 15, 13, 14, 37, 14, 15, 15, 16, 0, 15, 21, 16, 20, 27, 18, 11, 17, 15, 0, 16, 19, 16, 22, 27, 12, 19, 30, 13, 0, 18, 8, 10, 20, 20, 18, 13, 12, 14, 0, 15, 19, 12, 14, 18, 22, 14, 16, 11, 0, 15, 19, 7, 14, 37, 16, 13, 17, 11, 0, 9, 22, 14, 13, 15, 17, 11, 11, 16, 0, 10, 21, 13, 14, 26, 13, 12, 22, 14, 0, 18, 14, 12, 28, 26, 14, 13, 8, 15, 0, 15, 19, 12, 20, 20, 16, 9, 15, 13, 0, 17, 12, 16, 18, 36, 18, 10, 18, 13, 0, 14, 15, 13, 19, 24, 10, 15, 14, 15, 0, 14, 20, 10, 18, 20, 16, 13, 17, 14, 0, 6, 17, 16, 12, 26, 13, 14, 12, 10, 0, 12, 18, 12, 19, 21, 17, 14, 14, 16, 0, 16, 21, 12, 13, 12, 18, 11, 19, 13, 0, 8, 16, 14, 17, 25, 19, 8, 18, 6, 0, 11, 13, 13, 18, 27, 11, 16, 18, 10, 0, 14, 14, 14, 18, 24, 18, 9, 19, 13, 0, 17, 20, 13, 11, 38, 11, 15, 15, 12, 0, 15, 14, 6, 19, 35, 15, 17, 22, 12, 0, 9, 20, 16, 14, 38, 6, 6, 14, 8, 0, 10, 18, 14, 11, 27, 13, 13, 17, 9, 0, 18, 6, 13, 16, 29, 16, 15, 22, 14, 0, 17, 11, 12, 14, 24, 15, 15, 18, 8, 0, 13, 18, 10, 25, 35, 14, 15, 13, 14, 0, 15, 11, 9, 18, 15, 18, 11, 15, 8, 0, 13, 15, 11, 11, 25, 15, 14, 12, 14, 0, 13, 14, 11, 21, 27, 19, 14, 19, 13, 0, 17, 19, 13, 18, 25, 19, 15, 14, 15, 0, 16, 16, 12, 18, 14, 19, 14, 11, 11, 0, 17, 15, 18, 16, 25, 13, 12, 20, 10, 0, 12, 19, 8, 8, 53, 13, 12, 11, 13, 0, 11, 17, 13, 13, 14, 12, 13, 11, 14, 0, 18, 13, 8, 18, 17, 19, 14, 17, 13, 0, 16, 20, 11, 11, 52, 19, 12, 18, 19, 0, 13, 15, 15, 14, 26, 14, 11, 15, 12, 0, 15, 17, 13, 14, 15, 13, 12, 13, 14, 0, 18, 6, 14, 17, 29, 12, 13, 14, 14, 0, 13, 13, 13, 17, 20, 19, 19, 11, 14, 0, 16, 8, 17, 14, 18, 15, 7, 14, 12, 0, 14, 17, 11, 13, 21, 21, 14, 17, 9, 0, 12, 15, 12, 14, 25, 15, 13, 19, 10, 0, 14, 16, 12, 19, 38, 16, 14, 18, 19, 0, 9, 13, 13, 15, 21, 18, 12, 18, 15, 0, 14, 19, 16, 12, 32, 10, 8, 14, 16, 0, 14, 17, 14, 13, 17, 15, 13, 18, 13, 0, 15, 17, 14, 15, 18, 21, 15, 15, 9, 0, 14, 15, 13, 15, 31, 13, 9, 12, 9, 0, 18, 20, 17, 19, 17, 13, 16, 17, 15, 0, 14, 15, 15, 19, 115, 12, 13, 19, 16, 0, 12, 18, 12, 13, 25, 18, 14, 13, 13, 0, 10, 19, 13, 14, 24, 8, 12, 18, 13, 0, 16, 18, 9, 13, 15, 17, 15, 15, 18, 0, 14, 11, 10, 21, 30, 18, 11, 17, 13, 0, 13, 17, 16, 15, 33, 19, 11, 21, 7, 0, 15, 15, 12, 19, 61, 9, 10, 11, 13, 0, 17, 18, 12, 21, 21, 13, 14, 14, 13, 0, 10, 13, 14, 13, 20, 5, 13, 16, 8, 0, 11, 11, 11, 15, 21, 11, 15, 12, 14, 0, 11, 12, 13, 14, 33, 19, 17, 7, 15, 0, 9, 21, 11, 17, 25, 18, 12, 15, 16, 0, 8, 13, 13, 12, 18, 23, 14, 16, 17, 0, 13, 17, 10, 15, 32, 18, 8, 13, 13, 0, 15, 17, 11, 19, 28, 13, 7, 21, 12, 0, 10, 14, 17, 9, 52, 13, 19, 13, 7, 0, 13, 12, 15, 18, 26, 13, 13, 18, 14, 0, 18, 13, 11, 17, 14, 14, 8, 16, 16, 0, 17, 17, 8, 19, 21, 20, 8, 19, 10, 0, 16, 19, 16, 14, 18, 19, 10, 12, 16, 0, 16, 20, 13, 12, 33, 19, 14, 14, 9, 0, 13, 14, 12, 19, 32, 20, 17, 14, 14, 0, 13, 18, 8, 15, 30, 11, 14, 16, 12, 0, 11, 12, 13, 19, 32, 15, 12, 9, 13, 0, 14, 17, 14, 18, 26, 10, 11, 20, 17, 0, 14, 17, 17, 13, 22, 15, 13, 17, 11, 0, 11, 16, 13, 14, 30, 20, 14, 15, 17, 0, 10, 14, 11, 14, 29, 14, 13, 12, 14, 0, 14, 18, 17, 21, 22, 17, 9, 21, 14, 0, 11, 13, 10, 19, 28, 16, 8, 15, 15, 0, 11, 21, 10, 15, 32, 13, 9, 14, 11, 0, 12, 17, 14, 21, 29, 10, 11, 17, 15, 0, 17, 16, 11, 19, 34, 17, 14, 23, 13, 0, 12, 19, 8, 12, 21, 18, 17, 11, 11, 0, 19, 12, 13, 18, 23, 18, 13, 16, 11, 0, 11, 13, 13, 10, 28, 13, 13, 11, 13, 0, 8, 16, 14, 12, 27, 15, 15, 17, 14, 0, 17, 21, 14, 21, 28, 18, 13, 19, 17, 0, 17, 15, 13, 14, 25, 19, 13, 18, 12, 0, 17, 22, 12, 18, 22, 16, 8, 11, 14, 0, 12, 15, 12, 14, 23, 14, 16, 12, 13, 0, 16, 9, 14, 18, 18, 18, 11, 15, 13, 0, 11, 16, 11, 12, 29, 23, 13, 14, 14, 0, 15, 19, 12, 14, 38, 14, 13, 17, 16, 0, 12, 7, 16, 19, 24, 13, 14, 13, 14, 0, 9, 19, 12, 11, 38, 17, 17, 20, 15, 0, 13, 17, 12, 20, 31, 15, 16, 17, 15, 0, 14, 14, 13, 18, 17, 11, 13, 19, 13, 0, 16, 13, 17, 19, 34, 15, 13, 19, 9, 0, 13, 13, 14, 17, 17, 14, 7, 17, 15, 0, 17, 20, 14, 14, 24, 22, 14, 13, 21, 0, 15, 19, 12, 14, 21, 15, 7, 14, 13, 0, 12, 33, 18, 17, 16, 15, 14, 18, 11, 0, 13, 23, 12, 8, 24, 14, 13, 9, 11, 0, 7, 16, 8, 10, 21, 12, 15, 17, 19, 0, 7, 19, 11, 30, 33, 13, 10, 8, 13, 0, 16, 13, 20, 8, 23, 13, 10, 18, 13, 0, 18, 14, 13, 8, 35, 13, 8, 12, 11, 0, 13, 19, 13, 19, 23, 25, 11, 21, 9, 0, 14, 9, 13, 15, 34, 19, 14, 14, 15, 0, 13, 19, 10, 17, 35, 14, 17, 22, 17, 0, 14, 17, 17, 14, 17, 10, 13, 24, 17, 0, 13, 16, 11, 16, 25, 13, 18, 13, 13, 0, 12, 21, 15, 16, 26, 18, 14, 17, 12, 0, 5, 5, 5, 5, 5, 13, 8, 20, 12, 0, 5, 5, 12, 18, 23, 17, 9, 13, 8, 0, 5, 14, 13, 13, 27, 12, 14, 32, 13, 0, 5, 19, 14, 14, 18, 21, 7, 13, 14, 0, 5, 13, 14, 13, 25, 9, 13, 18, 12, 0, 17, 8, 14, 41, 30, 17, 11, 21, 11, 0, 13, 15, 11, 17, 40, 10, 13, 18, 16, 0, 14, 13, 17, 12, 19, 14, 12, 18, 13, 0, 11, 10, 15, 17, 29, 16, 14, 16, 12, 0, 12, 19, 11, 20, 24, 20, 12, 14, 17, 0, 5, 5, 9, 16, 30, 16, 9, 21, 17, 0, 5, 14, 14, 13, 35, 17, 15, 18, 11, 0, 13, 12, 11, 19, 23, 17, 7, 17, 13, 0, 15, 17, 13, 17, 25, 13, 8, 21, 13, 0, 17, 13, 14, 15, 26, 19, 10, 16, 17, 0, 10, 11, 12, 22, 30, 14, 13, 15, 10, 0, 10, 15, 14, 10, 53, 14, 14, 14, 10, 0, 12, 12, 18, 11, 35, 12, 14, 15, 9, 0, 13, 19, 13, 21, 24, 11, 14, 20, 14, 0, 14, 9, 13, 12, 24, 13, 12, 18, 7, 0, 5, 22, 17, 20, 26, 11, 18, 19, 14, 0, 13, 9, 13, 12, 29, 9, 15, 15, 16, 0, 11, 18, 18, 11, 27, 14, 14, 8, 13, 0, 13, 16, 13, 19, 21, 14, 9, 13, 18, 0, 14, 18, 9, 16, 25, 12, 11, 19, 13, 0, 12, 14, 9, 18, 25, 15, 14, 12, 9, 0, 14, 13, 12, 19, 21, 26, 16, 12, 10, 0, 19, 21, 13, 13, 36, 17, 18, 15, 11, 0, 11, 18, 12, 14, 24, 14, 17, 9, 16, 0, 19, 20, 13, 17, 21, 7, 13, 18, 8, 0, 5, 12, 11, 17, 26, 14, 13, 19, 14, 0, 16, 18, 7, 20, 34, 19, 13, 8, 14, 0, 15, 13, 11, 14, 22, 14, 15, 20, 17, 0, 14, 11, 14, 9, 24, 18, 11, 15, 13, 0, 13, 16, 15, 14, 17, 16, 15, 11, 15, 0, 12, 13, 15, 15, 28, 15, 12, 19, 9, 0, 13, 14, 16, 21, 33, 13, 11, 22, 16, 0, 9, 20, 13, 16, 24, 13, 16, 16, 9, 0, 12, 21, 10, 14, 26, 20, 17, 11, 14, 0, 19, 21, 14, 30, 34, 14, 16, 13, 13, 0, 5, 14, 13, 13, 14, 18, 11, 7, 11, 0, 14, 18, 17, 16, 27, 18, 12, 13, 10, 0, 13, 13, 10, 9, 27, 21, 11, 16, 13, 0, 17, 7, 14, 13, 26, 13, 10, 12, 13, 0, 10, 9, 11, 18, 30, 18, 17, 17, 10, 0, 14, 19, 10, 14, 27, 12, 13, 18, 12, 0, 9, 11, 13, 14, 8, 13, 15, 12, 11, 0, 11, 13, 12, 18, 14, 19, 16, 8, 10, 0, 13, 8, 18, 11, 23, 12, 14, 12, 15, 0, 14, 17, 14, 12, 23, 15, 9, 16, 10, 0, 17, 18, 12, 12, 34, 24, 14, 22, 14, 0, 16, 14, 16, 14, 19, 13, 7, 12, 17, 0, 14, 26, 15, 13, 27, 13, 18, 18, 11, 0, 16, 18, 16, 7, 69, 16, 17, 14, 11, 0, 16, 8, 8, 12, 17, 9, 17, 17, 17, 0, 13, 11, 18, 26, 18, 17, 17, 18, 16, 0, 10, 13, 16, 19, 13, 14, 18, 12, 15, 0, 13, 14, 16, 12, 19, 9, 16, 14, 11, 0, 12, 19, 11, 14, 25, 17, 8, 17, 13, 0, 19, 13, 11, 13, 30, 14, 13, 14, 15, 0, 14, 17, 16, 19, 25, 15, 13, 12, 14, 0, 14, 19, 13, 21, 32, 13, 8, 29, 12, 0, 17, 14, 15, 20, 29, 12, 18, 14, 14, 0, 9, 17, 14, 14, 31, 16, 12, 17, 11, 0, 9, 11, 13, 19, 25, 17, 14, 11, 13, 0, 14, 20, 17, 17, 18, 19, 12, 16, 11, 0, 13, 16, 17, 18, 33, 17, 7, 21, 14, 0, 14, 14, 8, 14, 26, 13, 14, 14, 13, 0, 7, 18, 14, 19, 27, 14, 16, 14, 13, 0, 14, 23, 12, 12, 17, 20, 13, 14, 8, 0, 11, 13, 18, 16, 19, 13, 15, 15, 14, 0, 19, 19, 14, 14, 30, 19, 16, 20, 13, 0, 11, 8, 9, 20, 34, 13, 12, 15, 11, 0, 16, 15, 13, 14, 23, 18, 10, 14, 8, 0, 15, 6, 18, 19, 24, 21, 16, 18, 8, 0, 13, 14, 12, 17, 22, 18, 8, 18, 16, 0, 17, 18, 14, 21, 144, 17, 14, 17, 12, 0, 14, 11, 13, 18, 22, 14, 10, 14, 18, 0, 13, 10, 13, 19, 26, 13, 12, 22, 13, 0, 13, 9, 11, 13, 30, 13, 11, 17, 11, 0, 12, 13, 11, 20, 29, 8, 10, 15, 12, 0, 11, 13, 8, 11, 26, 18, 16, 13, 17, 0, 13, 14, 13, 16, 17, 19, 15, 17, 16, 0, 19, 13, 16, 20, 33, 15, 16, 13, 17, 0, 17, 19, 11, 14, 27, 19, 13, 16, 13, 0, 9, 19, 11, 14, 23, 19, 13, 14, 13, 0, 14, 17, 16, 17, 35, 14, 11, 47, 14, 0, 13, 19, 16, 21, 30, 19, 10, 13, 18, 0, 16, 15, 13, 17, 13, 14, 13, 15, 9, 0, 13, 16, 15, 16, 21, 14, 10, 8, 14, 0, 14, 13, 14, 21, 38, 21, 16, 13, 13, 0, 10, 12, 14, 15, 23, 18, 13, 15, 14, 0, 10, 14, 11, 16, 30, 19, 11, 13, 15, 0, 13, 18, 15, 14, 30, 12, 14, 21, 17, 0, 14, 19, 16, 16, 30, 10, 13, 15, 11, 0, 7, 14, 15, 19, 33, 20, 12, 14, 17, 0, 17, 18, 16, 15, 29, 17, 13, 19, 12, 0, 13, 19, 15, 17, 18, 21, 17, 12, 13, 0, 17, 16, 15, 15, 29, 20, 16, 16, 11, 0, 13, 20, 16, 14, 17, 19, 14, 14, 13, 0, 5, 5, 9, 19, 32, 16, 16, 16, 9, 0, 5, 13, 10, 14, 30, 18, 18, 14, 10, 0, 18, 15, 12, 13, 25, 15, 12, 17, 10, 0, 15, 15, 13, 26, 23, 19, 14, 19, 13, 0, 12, 17, 15, 14, 15, 21, 12, 20, 16, 0, 11, 21, 15, 13, 34, 16, 13, 11, 14, 0, 15, 17, 16, 14, 31, 13, 17, 14, 13, 0, 16, 12, 13, 15, 29, 21, 13, 16, 12, 0, 10, 15, 15, 13, 24, 18, 14, 18, 19, 0, 11, 11, 13, 13, 25, 16, 7, 28, 14, 0, 5, 13, 11, 15, 21, 19, 16, 15, 16, 0, 19, 30, 6, 19, 6, 14, 11, 18, 12, 0, 12, 17, 17, 17, 17, 14, 17, 12, 12, 0, 11, 14, 6, 13, 16, 18, 13, 13, 16, 0, 11, 18, 13, 16, 21, 15, 13, 21, 13, 0, 13, 17, 17, 14, 28, 14, 8, 16, 8, 0, 15, 28, 15, 17, 45, 16, 14, 13, 11, 0, 11, 15, 12, 13, 29, 19, 8, 13, 8, 0, 15, 15, 10, 15, 30, 11, 12, 14, 12, 0, 14, 13, 17, 21, 26, 16, 11, 18, 15, 0, 14, 17, 16, 17, 21, 15, 10, 17, 10, 0, 12, 19, 13, 19, 33, 18, 13, 9, 11, 0, 14, 15, 14, 19, 26, 23, 17, 27, 13, 0, 10, 18, 7, 14, 21, 20, 13, 9, 18, 0, 16, 17, 8, 15, 22, 20, 15, 11, 12, 0, 13, 11, 13, 19, 21, 16, 13, 26, 10, 0, 12, 9, 12, 29, 17, 15, 16, 19, 11, 0, 14, 16, 13, 20, 38, 16, 12, 12, 8, 0, 15, 13, 11, 16, 23, 11, 15, 14, 8, 0, 16, 15, 17, 14, 19, 21, 14, 11, 11, 0, 19, 16, 16, 23, 17, 9, 12, 11, 14, 0, 11, 8, 6, 14, 35, 18, 17, 7, 12, 0, 15, 11, 18, 10, 26, 22, 11, 13, 12, 0, 14, 16, 16, 13, 24, 21, 12, 14, 13, 0, 18, 11, 13, 17, 29, 17, 16, 18, 11, 0, 10, 12, 15, 20, 19, 18, 13, 17, 11, 0, 12, 12, 12, 18, 22, 18, 12, 18, 13, 0, 15, 14, 10, 12, 26, 21, 16, 15, 13, 0, 11, 12, 13, 18, 18, 22, 15, 20, 10, 0, 16, 16, 13, 16, 21, 9, 16, 13, 9, 0, 18, 19, 18, 19, 27, 15, 17, 21, 10, 0, 14, 18, 17, 17, 22, 14, 13, 56, 8, 0, 16, 11, 12, 16, 24, 13, 14, 15, 13, 0, 17, 13, 15, 9, 30, 18, 11, 15, 10, 0, 13, 17, 12, 18, 24, 18, 13, 20, 15, 0, 14, 18, 13, 12, 21, 20, 17, 17, 11, 0, 7, 13, 13, 17, 29, 19, 11, 10, 10, 0, 13, 24, 12, 17, 26, 8, 11, 16, 14, 0, 12, 13, 14, 18, 24, 16, 15, 20, 13, 0, 13, 22, 11, 18, 34, 12, 12, 14, 12, 0, 14, 19, 13, 21, 20, 17, 13, 22, 14, 0, 12, 20, 13, 16, 19, 21, 11, 12, 16, 0, 8, 8, 13, 19, 29, 18, 17, 14, 9, 0, 13, 19, 9, 14, 29, 12, 13, 14, 15, 0, 16, 14, 13, 15, 28, 11, 6, 17, 10, 0, 14, 13, 9, 12, 27, 13, 11, 12, 10, 0, 13, 19, 12, 17, 32, 7, 15, 7, 7, 0, 17, 19, 12, 16, 17, 16, 12, 7, 13, 0, 16, 17, 16, 20, 29, 16, 15, 13, 10, 0, 19, 19, 19, 13, 13, 17, 14, 17, 14, 0, 16, 16, 18, 13, 34, 14, 9, 22, 14, 0, 15, 15, 15, 9, 116, 12, 10, 14, 16, 0, 14, 12, 18, 13, 20, 25, 7, 18, 7, 0, 13, 13, 13, 14, 14, 19, 16, 11, 13, 0, 11, 14, 13, 12, 61, 12, 13, 18, 14, 0, 13, 20, 15, 32, 25, 11, 15, 18, 17, 0, 13, 13, 16, 22, 36, 14, 9, 20, 12, 0, 16, 19, 11, 27, 18, 20, 14, 20, 18, 0, 14, 60, 12, 13, 26, 13, 15, 18, 15, 0, 13, 19, 14, 17, 20, 20, 14, 13, 18, 0, 13, 14, 15, 19, 27, 15, 16, 17, 17, 0, 15, 17, 15, 14, 36, 12, 15, 19, 19, 0, 15, 11, 13, 12, 26, 8, 13, 18, 7, 0, 12, 11, 9, 19, 21, 15, 12, 21, 13, 0, 15, 17, 16, 17, 28, 15, 17, 17, 12, 0, 8, 18, 12, 17, 14, 8, 18, 19, 13, 0, 14, 14, 14, 11, 23, 17, 15, 13, 14, 0, 11, 16, 15, 12, 20, 20, 11, 16, 13, 0, 15, 17, 17, 20, 30, 15, 15, 11, 13, 0, 19, 9, 14, 16, 29, 16, 15, 13, 16, 0, 16, 25, 14, 20, 20, 13, 19, 14, 9, 0, 12, 13, 20, 16, 25, 19, 12, 15, 12, 0, 12, 13, 11, 20, 34, 16, 13, 18, 9, 0, 13, 18, 15, 19, 23, 14, 17, 18, 16, 0, 15, 13, 10, 19, 27, 15, 12, 20, 13, 0, 16, 13, 13, 19, 15, 19, 11, 14, 10, 0, 14, 20, 10, 8, 33, 23, 21, 17, 13, 0, 10, 19, 18, 12, 27, 13, 18, 11, 17, 0, 16, 16, 14, 20, 12, 11, 13, 13, 14, 0, 14, 7, 15, 15, 14, 20, 9, 14, 15, 0, 12, 13, 14, 17, 24, 6, 8, 17, 13, 0, 16, 14, 11, 17, 32, 19, 15, 14, 11, 0, 14, 9, 9, 18, 52, 14, 11, 21, 15, 0, 10, 16, 18, 15, 29, 14, 11, 15, 13, 0, 14, 17, 13, 11, 27, 15, 16, 13, 9, 0, 15, 19, 10, 16, 22, 17, 12, 15, 14, 0, 17, 25, 15, 17, 20, 20, 17, 17, 16, 0, 12, 14, 13, 19, 21, 16, 16, 13, 17, 0, 14, 18, 15, 21, 15, 17, 11, 14, 13, 0, 14, 19, 13, 15, 18, 16, 14, 15, 14, 0, 5, 11, 8, 9, 30, 10, 15, 16, 13, 0, 14, 11, 11, 14, 53, 17, 13, 13, 10, 0, 18, 15, 7, 18, 24, 21, 17, 9, 13, 0, 14, 13, 14, 14, 24, 16, 17, 20, 7, 0, 16, 19, 13, 17, 33, 14, 8, 14, 14, 0, 14, 16, 9, 14, 22, 29, 11, 10, 7, 0, 13, 19, 13, 13, 37, 14, 18, 12, 16, 0, 11, 13, 16, 13, 23, 21, 15, 13, 17, 0, 19, 11, 9, 17, 32, 17, 12, 9, 8, 0, 11, 14, 13, 17, 50, 18, 9, 12, 8, 0, 13, 18, 10, 13, 29, 15, 17, 15, 14, 0, 7, 16, 16, 14, 35, 22, 15, 12, 13, 0, 15, 19, 16, 20, 25, 14, 16, 21, 12, 0, 14, 16, 12, 13, 111, 19, 11, 17, 9, 0, 11, 15, 9, 18, 18, 21, 12, 11, 8, 0, 13, 21, 17, 14, 45, 13, 9, 14, 17, 0, 10, 17, 13, 14, 20, 14, 15, 14, 16, 0, 12, 16, 10, 13, 29, 14, 16, 7, 11, 0, 11, 13, 10, 23, 29, 17, 15, 12, 14, 0, 14, 19, 15, 14, 18, 23, 15, 16, 14, 0, 17, 21, 14, 17, 23, 17, 18, 12, 13, 0, 8, 21, 12, 19, 23, 17, 14, 13, 13, 0, 9, 17, 13, 16, 23, 18, 16, 12, 10, 0, 14, 12, 13, 14, 11, 13, 18, 12, 17, 0, 8, 10, 8, 20, 29, 19, 16, 19, 16, 0, 16, 13, 13, 13, 19, 22, 9, 12, 16, 0, 8, 16, 13, 20, 34, 14, 19, 17, 9, 0, 14, 21, 18, 12, 29, 14, 13, 17, 10, 0, 14, 21, 17, 18, 23, 15, 9, 12, 12, 0, 14, 22, 16, 15, 20, 17, 13, 16, 11, 0, 11, 15, 12, 15, 30, 11, 17, 13, 11, 0, 13, 16, 13, 19, 15, 19, 13, 17, 11, 0, 16, 12, 13, 24, 23, 14, 10, 18, 13, 0, 16, 22, 13, 9, 22, 14, 14, 11, 12, 0, 19, 16, 17, 14, 32, 20, 6, 6, 6, 0, 11, 16, 13, 17, 23, 11, 7, 6, 6, 0, 16, 14, 13, 16, 33, 17, 9, 12, 6, 0, 11, 17, 16, 18, 32, 20, 14, 22, 14, 0, 15, 13, 16, 15, 41, 13, 14, 17, 11, 0, 13, 17, 13, 14, 22, 15, 11, 13, 16, 0, 11, 14, 14, 16, 22, 17, 13, 14, 16, 0, 12, 17, 17, 14, 24, 21, 18, 16, 14, 0, 16, 14, 9, 14, 28, 19, 14, 14, 15, 0, 12, 19, 11, 13, 19, 22, 16, 18, 11, 0, 8, 28, 13, 17, 32, 19, 11, 20, 13, 0, 11, 13, 14, 10, 30, 23, 14, 6, 6, 0, 12, 15, 15, 16, 22, 14, 18, 19, 6, 0, 16, 13, 14, 21, 33, 19, 12, 13, 12, 0, 13, 14, 11, 18, 22, 16, 13, 21, 17, 0, 14, 13, 12, 13, 33, 14, 12, 12, 10, 0, 10, 20, 14, 22, 17, 21, 19, 17, 15, 0, 15, 16, 12, 15, 29, 12, 16, 14, 17, 0, 14, 19, 13, 14, 27, 18, 13, 9, 15, 0, 7, 16, 7, 13, 14, 18, 12, 25, 11, 0, 10, 13, 14, 19, 29, 15, 14, 12, 15, 0, 12, 7, 7, 22, 21, 17, 18, 18, 19, 0, 16, 13, 13, 16, 32, 19, 9, 19, 6, 0, 18, 16, 13, 12, 30, 22, 18, 15, 15, 0, 13, 19, 11, 19, 26, 15, 13, 21, 13, 0, 8, 12, 14, 11, 27, 21, 11, 14, 8, 0, 10, 11, 14, 9, 21, 18, 17, 16, 11, 0, 13, 19, 13, 20, 36, 20, 13, 22, 13, 0, 18, 19, 13, 18, 36, 22, 13, 13, 13, 0, 16, 13, 13, 16, 23, 14, 9, 19, 14, 0, 9, 11, 11, 9, 27, 12, 12, 22, 15, 0, 12, 9, 11, 19, 25, 11, 14, 16, 13, 0, 12, 19, 17, 8, 37, 26, 14, 20, 14, 0, 14, 21, 14, 17, 17, 17, 12, 15, 15, 0, 17, 17, 8, 18, 21, 14, 14, 12, 9, 0, 11, 19, 8, 10, 13, 14, 10, 26, 12, 0, 13, 13, 15, 13, 30, 15, 13, 13, 8, 0, 17, 16, 13, 18, 27, 19, 12, 18, 13, 0, 12, 14, 11, 14, 25, 12, 16, 18, 14, 0, 12, 19, 11, 15, 28, 16, 8, 27, 14, 0, 11, 9, 14, 17, 25, 19, 13, 14, 13, 0, 13, 14, 15, 15, 61, 19, 14, 14, 10, 0, 13, 15, 13, 20, 23, 12, 11, 14, 11, 0, 13, 16, 14, 19, 25, 14, 10, 20, 14, 0, 13, 14, 16, 23, 29, 21, 9, 19, 9, 0, 17, 16, 13, 13, 23, 19, 18, 14, 12, 0, 14, 17, 20, 18, 19, 17, 12, 17, 11, 0, 10, 21, 12, 18, 52, 16, 13, 14, 11, 0, 14, 17, 13, 19, 26, 19, 9, 20, 11, 0, 18, 14, 16, 17, 28, 25, 6, 16, 19, 0, 18, 25, 19, 20, 23, 15, 11, 14, 14, 0, 9, 19, 11, 13, 21, 21, 13, 15, 16, 0, 13, 19, 17, 18, 23, 22, 16, 19, 9, 0, 15, 13, 16, 15, 21, 17, 14, 23, 13, 0, 18, 19, 16, 20, 32, 13, 15, 15, 8, 0, 11, 18, 12, 17, 30, 17, 11, 18, 10, 0, 15, 22, 14, 15, 23, 17, 11, 19, 14, 0, 14, 20, 14, 8, 35, 14, 13, 14, 16, 0, 13, 21, 13, 15, 34, 18, 13, 12, 13, 0, 16, 14, 15, 19, 23, 18, 14, 14, 16, 0, 11, 19, 11, 22, 25, 19, 13, 21, 11, 0, 14, 11, 15, 19, 24, 22, 18, 18, 16, 0, 16, 17, 10, 18, 37, 8, 14, 16, 10, 0, 13, 20, 9, 14, 30, 23, 13, 15, 11, 0, 12, 14, 14, 22, 20, 19, 19, 9, 14, 0, 10, 21, 16, 11, 26, 15, 13, 14, 16, 0, 5, 13, 16, 19, 35, 19, 13, 17, 16, 0, 14, 17, 13, 18, 33, 15, 18, 23, 13, 0, 15, 18, 9, 12, 24, 13, 12, 14, 12, 0, 14, 14, 11, 22, 23, 15, 20, 19, 12, 0, 13, 18, 12, 13, 19, 13, 7, 11, 7, 0, 15, 16, 9, 15, 21, 15, 9, 14, 14, 0, 13, 19, 13, 14, 35, 13, 16, 18, 16, 0, 10, 18, 6, 12, 32, 14, 17, 15, 13, 0, 17, 29, 10, 18, 24, 16, 14, 15, 16, 0, 13, 14, 13, 14, 26, 13, 10, 15, 14, 0, 12, 14, 14, 19, 23, 14, 17, 13, 11, 0, 12, 19, 6, 25, 38, 9, 15, 14, 8, 0, 11, 16, 16, 19, 38, 18, 14, 20, 13, 0, 7, 15, 14, 17, 24, 22, 14, 10, 14, 0, 17, 18, 8, 19, 45, 14, 8, 17, 17, 0, 15, 20, 15, 12, 15, 20, 16, 19, 14, 0, 13, 22, 13, 14, 20, 13, 10, 18, 7, 0, 12, 14, 14, 21, 18, 13, 13, 13, 12, 0, 20, 17, 13, 19, 29, 15, 13, 20, 14, 0, 16, 14, 14, 18, 26, 18, 14, 14, 15, 0, 15, 19, 10, 22, 23, 19, 15, 22, 9, 0, 17, 19, 14, 13, 34, 14, 20, 17, 20, 0, 16, 18, 10, 21, 25, 22, 12, 20, 17, 0, 11, 22, 13, 11, 21, 17, 15, 15, 17, 0, 18, 22, 14, 14, 25, 16, 17, 13, 14, 0, 19, 19, 13, 20, 32, 16, 16, 14, 16, 0, 17, 7, 17, 22, 81, 13, 8, 16, 12, 0, 14, 10, 15, 21, 21, 16, 14, 17, 11, 0, 16, 15, 12, 21, 20, 14, 15, 19, 13, 0, 15, 13, 11, 9, 29, 17, 13, 16, 13, 0, 8, 14, 15, 15, 29, 23, 13, 17, 15, 0, 17, 18, 13, 18, 33, 14, 13, 13, 11, 0, 15, 19, 11, 18, 29, 19, 15, 18, 14, 0, 11, 12, 14, 21, 18, 19, 13, 13, 13, 0, 13, 15, 12, 17, 21, 8, 11, 14, 16, 0, 14, 20, 12, 20, 33, 10, 17, 15, 14, 0, 13, 17, 13, 16, 42, 18, 16, 14, 14, 0, 16, 20, 18, 17, 19, 14, 10, 13, 13, 0, 15, 18, 15, 20, 26, 11, 16, 14, 15, 0, 13, 19, 14, 13, 25, 14, 14, 16, 13, 0, 12, 21, 7, 23, 24, 14, 12, 21, 14, 0, 13, 13, 16, 14, 38, 17, 16, 17, 13, 0, 12, 17, 15, 14, 29, 15, 13, 17, 14, 0, 11, 16, 13, 25, 15, 19, 14, 16, 14, 0, 15, 14, 13, 20, 24, 17, 17, 17, 15, 0, 13, 20, 12, 15, 32, 18, 11, 6, 6, 0, 13, 15, 14, 13, 21, 28, 11, 20, 6, 0, 13, 20, 14, 18, 34, 17, 10, 21, 13, 0, 13, 13, 13, 17, 26, 14, 14, 16, 10, 0, 9, 21, 13, 14, 38, 20, 10, 25, 17, 0, 11, 17, 16, 14, 21, 18, 13, 14, 12, 0, 13, 20, 15, 22, 33, 17, 8, 8, 15, 0, 12, 14, 13, 16, 23, 17, 13, 16, 12, 0, 14, 13, 12, 12, 13, 20, 11, 16, 11, 0, 13, 24, 16, 17, 21, 20, 16, 14, 14, 0, 8, 18, 13, 14, 22, 22, 14, 13, 12, 0, 11, 22, 12, 14, 26, 14, 14, 22, 6, 0, 8, 18, 19, 14, 24, 19, 14, 16, 17, 0, 16, 12, 14, 15, 34, 14, 15, 21, 13, 0, 16, 19, 12, 18, 29, 18, 16, 17, 13, 0, 13, 13, 14, 21, 10, 15, 14, 20, 15, 0, 13, 22, 14, 14, 33, 14, 11, 12, 12, 0, 15, 14, 12, 17, 15, 9, 14, 7, 7, 0, 12, 13, 14, 13, 36, 23, 16, 19, 10, 0, 15, 18, 8, 13, 15, 20, 16, 16, 14, 0, 18, 19, 10, 10, 24, 10, 14, 29, 15, 0, 9, 14, 16, 17, 35, 13, 21, 21, 13, 0, 18, 21, 13, 16, 24, 20, 16, 11, 13, 0, 14, 17, 16, 13, 29, 19, 13, 15, 11, 0, 18, 14, 15, 15, 32, 16, 16, 8, 10, 0, 10, 15, 14, 19, 27, 19, 13, 9, 10, 0, 17, 13, 15, 16, 29, 17, 8, 11, 10, 0, 13, 12, 17, 21, 16, 19, 13, 18, 7, 0, 11, 17, 9, 13, 20, 9, 17, 14, 13, 0, 14, 17, 15, 19, 34, 19, 12, 14, 11, 0, 8, 12, 16, 19, 28, 12, 14, 13, 15, 0, 12, 14, 14, 20, 20, 21, 12, 21, 11, 0, 13, 19, 15, 13, 29, 15, 11, 15, 14, 0, 14, 14, 16, 13, 24, 24, 9, 17, 13, 0, 14, 21, 14, 16, 16, 13, 11, 11, 17, 0, 15, 13, 16, 10, 34, 14, 15, 14, 17, 0, 13, 21, 13, 9, 16, 18, 19, 26, 14, 0, 11, 30, 13, 13, 30, 15, 14, 19, 13, 0, 9, 18, 15, 19, 26, 18, 12, 13, 14, 0, 14, 15, 16, 19, 31, 16, 14, 21, 10, 0, 11, 17, 19, 15, 14, 21, 16, 10, 16, 0, 9, 15, 15, 14, 204, 18, 15, 14, 17, 0, 13, 12, 14, 14, 27, 18, 9, 17, 14, 0, 13, 19, 14, 17, 34, 14, 15, 23, 14, 0, 19, 20, 16, 16, 29, 17, 13, 22, 18, 0, 12, 17, 14, 19, 32, 13, 13, 18, 17, 0, 9, 15, 8, 20, 90, 15, 13, 20, 13, 0, 10, 15, 16, 23, 29, 14, 16, 20, 14, 0, 18, 13, 15, 11, 21, 16, 13, 8, 9, 0, 14, 17, 13, 18, 19, 22, 13, 19, 13, 0, 13, 19, 15, 13, 21, 21, 14, 13, 9, 0, 8, 19, 19, 21, 25, 15, 17, 18, 16, 0, 17, 18, 13, 8, 20, 11, 16, 15, 14, 0, 12, 14, 13, 10, 23, 18, 17, 16, 14, 0, 13, 18, 15, 19, 30, 23, 10, 12, 16, 0, 5, 10, 15, 19, 30, 13, 9, 10, 14, 0, 9, 19, 17, 14, 23, 16, 16, 21, 13, 0, 15, 14, 14, 13, 23, 18, 14, 13, 14, 0, 14, 16, 16, 12, 26, 14, 11, 13, 14, 0, 15, 25, 14, 20, 21, 9, 12, 14, 8, 0, 13, 20, 9, 14, 24, 12, 11, 17, 17, 0, 12, 15, 17, 19, 35, 14, 12, 21, 12, 0, 11, 13, 14, 28, 29, 14, 14, 17, 10, 0, 14, 16, 17, 17, 20, 16, 13, 19, 17, 0, 11, 13, 15, 14, 28, 18, 13, 13, 9, 0, 13, 14, 14, 23, 23, 19, 13, 20, 11, 0, 15, 19, 13, 17, 30, 14, 20, 17, 14, 0, 18, 15, 11, 19, 24, 14, 14, 22, 13, 0, 18, 9, 10, 12, 28, 18, 16, 19, 16, 0, 13, 21, 7, 14, 24, 14, 14, 16, 12, 0, 16, 14, 13, 22, 15, 17, 10, 14, 13, 0, 17, 14, 16, 17, 21, 11, 14, 18, 16, 0, 9, 17, 16, 15, 24, 13, 17, 14, 16, 0, 14, 15, 15, 19, 25, 11, 14, 7, 19, 0, 8, 17, 14, 17, 21, 18, 13, 14, 12, 0, 14, 14, 10, 19, 25, 17, 14, 13, 13, 0, 12, 16, 18, 17, 31, 13, 14, 21, 15, 0, 14, 17, 13, 16, 29, 14, 13, 11, 12, 0, 9, 18, 11, 30, 38, 15, 16, 11, 15, 0, 12, 14, 13, 14, 32, 14, 14, 20, 14, 0, 17, 20, 9, 16, 26, 16, 16, 15, 18, 0, 13, 13, 10, 12, 12, 23, 14, 17, 14, 0, 13, 17, 14, 18, 24, 9, 17, 19, 13, 0, 18, 15, 12, 19, 26, 13, 11, 21, 16, 0, 13, 23, 11, 17, 13, 15, 14, 25, 16, 0, 17, 19, 9, 13, 30, 13, 14, 22, 11, 0, 16, 13, 13, 18, 30, 8, 14, 13, 14, 0, 12, 13, 11, 14, 33, 19, 14, 18, 19, 0, 16, 20, 12, 18, 25, 18, 11, 16, 8, 0, 10, 13, 19, 13, 29, 25, 18, 21, 19, 0, 14, 12, 6, 13, 27, 16, 14, 19, 18, 0, 14, 10, 17, 27, 33, 14, 14, 15, 11, 0, 11, 19, 14, 18, 23, 21, 11, 22, 14, 0, 14, 16, 17, 17, 27, 16, 13, 8, 14, 0, 16, 17, 14, 21, 28, 21, 16, 8, 9, 0, 14, 17, 15, 16, 29, 9, 15, 15, 13, 0, 10, 19, 15, 13, 23, 19, 13, 17, 16, 0, 14, 12, 12, 19, 21, 15, 13, 19, 15, 0, 12, 13, 14, 15, 26, 14, 15, 17, 14, 0, 13, 17, 12, 20, 25, 5, 17, 14, 19, 0, 13, 17, 13, 10, 30, 18, 19, 14, 13, 0, 18, 13, 11, 14, 34, 17, 16, 22, 11, 0, 17, 19, 12, 9, 25, 19, 13, 17, 17, 0, 14, 10, 11, 15, 24, 14, 12, 11, 13, 0, 11, 22, 11, 17, 29, 21, 8, 9, 15, 0, 16, 14, 9, 22, 19, 20, 18, 17, 13, 0, 11, 19, 13, 16, 84, 18, 20, 13, 7, 0, 12, 22, 19, 12, 26, 20, 18, 19, 13, 0, 14, 18, 9, 17, 20, 19, 12, 19, 11, 0, 13, 19, 15, 16, 24, 16, 12, 21, 13, 0, 8, 17, 15, 20, 34, 12, 9, 20, 12, 0, 16, 14, 18, 14, 26, 21, 13, 14, 6, 0, 13, 16, 13, 13, 27, 21, 13, 12, 7, 0, 13, 16, 10, 20, 20, 11, 10, 14, 11, 0, 11, 15, 15, 13, 33, 24, 8, 21, 16, 0, 16, 16, 20, 21, 38, 10, 12, 14, 17, 0, 12, 13, 16, 16, 37, 19, 11, 20, 16, 0, 12, 16, 13, 14, 19, 11, 17, 19, 16, 0, 13, 12, 14, 22, 52, 14, 13, 16, 13, 0, 15, 12, 11, 20, 40, 16, 14, 14, 18, 0, 13, 23, 14, 17, 29, 19, 14, 10, 13, 0, 13, 14, 14, 16, 36, 22, 15, 17, 13, 0, 8, 20, 11, 11, 30, 19, 16, 17, 18, 0, 14, 22, 16, 15, 20, 21, 17, 12, 13, 0, 17, 17, 13, 18, 14, 19, 16, 14, 16, 0, 13, 13, 13, 19, 21, 16, 19, 14, 17, 0, 13, 19, 15, 11, 34, 19, 11, 16, 14, 0, 15, 16, 14, 20, 19, 17, 15, 19, 14, 0, 8, 17, 13, 15, 23, 16, 7, 14, 14, 0, 15, 11, 20, 17, 27, 27, 14, 14, 11, 0, 12, 23, 8, 9, 29, 19, 12, 18, 14, 0, 8, 13, 6, 20, 21, 12, 7, 12, 10, 0, 12, 13, 14, 22, 25, 16, 7, 18, 11, 0, 16, 13, 13, 18, 22, 13, 12, 16, 17, 0, 15, 13, 14, 12, 28, 14, 15, 14, 13, 0, 19, 13, 9, 13, 14, 18, 7, 19, 10, 0, 17, 19, 17, 15, 38, 6, 15, 8, 13, 0, 13, 13, 18, 19, 50, 8, 18, 14, 14, 0, 9, 13, 15, 16, 23, 13, 14, 20, 8, 0, 14, 26, 16, 21, 26, 14, 9, 23, 14, 0, 16, 19, 17, 16, 21, 16, 8, 12, 15, 0, 12, 17, 12, 22, 37, 13, 13, 13, 13, 0, 16, 18, 13, 21, 14, 15, 10, 16, 9, 0, 15, 20, 13, 17, 18, 17, 17, 16, 14, 0, 10, 14, 18, 13, 21, 21, 12, 15, 16, 0, 16, 11, 16, 19, 32, 36, 13, 19, 11, 0, 11, 15, 8, 16, 26, 12, 15, 13, 13, 0, 8, 25, 12, 9, 23, 18, 13, 19, 14, 0, 9, 12, 14, 18, 21, 14, 15, 19, 12, 0, 15, 18, 15, 8, 29, 14, 13, 9, 15, 0, 17, 16, 13, 14, 30, 18, 13, 14, 16, 0, 18, 14, 14, 16, 14, 11, 7, 21, 13, 0, 9, 22, 16, 16, 61, 21, 14, 13, 19, 0, 19, 12, 9, 15, 22, 21, 16, 20, 18, 0, 11, 16, 19, 14, 23, 14, 18, 15, 14, 0, 15, 13, 14, 18, 26, 11, 16, 19, 10, 0, 13, 19, 16, 19, 32, 18, 13, 22, 14, 0, 14, 18, 12, 19, 26, 13, 12, 17, 16, 0, 14, 14, 18, 27, 21, 16, 16, 19, 14, 0, 13, 19, 11, 20, 27, 11, 12, 18, 12, 0, 14, 17, 13, 15, 24, 22, 14, 17, 7, 0, 16, 21, 9, 12, 35, 21, 20, 23, 11, 0, 14, 18, 15, 14, 34, 19, 19, 12, 18, 0, 12, 18, 11, 19, 23, 13, 16, 8, 17, 0, 15, 19, 13, 20, 23, 20, 12, 13, 11, 0, 11, 16, 11, 20, 34, 18, 13, 21, 13, 0, 15, 11, 13, 16, 34, 20, 12, 17, 12, 0, 17, 13, 15, 14, 28, 15, 19, 15, 15, 0, 12, 9, 13, 20, 28, 21, 9, 12, 12, 0, 15, 20, 14, 21, 17, 8, 16, 22, 17, 0, 14, 14, 17, 9, 21, 19, 15, 18, 15, 0, 14, 23, 16, 19, 26, 14, 11, 19, 17, 0, 16, 18, 16, 19, 30, 14, 16, 11, 14, 0, 12, 13, 15, 19, 26, 15, 9, 22, 13, 0, 13, 20, 13, 13, 26, 15, 13, 15, 11, 0, 9, 13, 17, 16, 28, 22, 8, 19, 11, 0, 16, 19, 13, 13, 54, 21, 14, 17, 19, 0, 12, 18, 13, 13, 19, 19, 14, 15, 15, 0, 7, 19, 13, 19, 25, 19, 11, 12, 14, 0, 17, 21, 16, 15, 16, 20, 9, 17, 13, 0, 12, 15, 14, 19, 10, 16, 14, 19, 16, 0, 13, 16, 17, 18, 23, 19, 13, 19, 15, 0, 14, 16, 13, 19, 26, 18, 11, 21, 6, 0, 14, 16, 14, 19, 26, 12, 14, 21, 14, 0, 16, 12, 19, 13, 19, 11, 14, 16, 17, 0, 11, 9, 19, 17, 21, 9, 13, 17, 12, 0, 15, 18, 13, 21, 27, 19, 18, 15, 13, 0, 9, 11, 13, 17, 24, 13, 17, 20, 16, 0, 16, 13, 19, 13, 26, 19, 15, 23, 8, 0, 13, 20, 10, 13, 94, 7, 13, 13, 15, 0, 13, 12, 15, 11, 25, 19, 10, 19, 14, 0, 11, 11, 16, 20, 32, 19, 15, 13, 15, 0, 14, 19, 12, 14, 27, 18, 14, 14, 13, 0, 15, 16, 9, 21, 26, 13, 19, 12, 13, 0, 17, 12, 12, 19, 22, 22, 12, 19, 12, 0, 16, 19, 12, 6, 25, 17, 8, 15, 11, 0, 16, 14, 14, 16, 33, 19, 13, 13, 13, 0, 11, 13, 10, 7, 21, 18, 11, 20, 17, 0, 13, 20, 13, 19, 30, 14, 18, 16, 15, 0, 13, 16, 17, 19, 18, 16, 14, 26, 11, 0, 15, 13, 10, 18, 21, 16, 12, 13, 17, 0, 14, 12, 16, 19, 19, 17, 14, 16, 13, 0, 15, 17, 13, 8, 25, 15, 15, 18, 15, 0, 16, 13, 15, 15, 29, 17, 11, 18, 14, 0, 15, 17, 11, 21, 20, 19, 11, 19, 13, 0, 15, 9, 14, 16, 20, 19, 16, 18, 16, 0, 14, 14, 12, 30, 26, 18, 17, 18, 14, 0, 13, 15, 19, 22, 24, 11, 13, 19, 10, 0, 16, 19, 10, 16, 25, 22, 17, 18, 13, 0, 16, 15, 13, 16, 21, 24, 14, 22, 12, 0, 14, 15, 13, 19, 13, 22, 14, 13, 13, 0, 18, 12, 14, 15, 36, 15, 12, 18, 17, 0, 13, 8, 13, 20, 12, 19, 16, 24, 14, 0, 16, 14, 18, 21, 29, 17, 13, 17, 17, 0, 18, 18, 20, 20, 26, 23, 9, 9, 9, 0, 18, 13, 15, 19, 33, 11, 13, 16, 18, 0, 13, 17, 7, 19, 20, 13, 17, 13, 14, 0, 16, 17, 14, 21, 23, 17, 12, 20, 13, 0, 12, 16, 16, 15, 24, 21, 15, 9, 19, 0, 11, 21, 16, 17, 28, 18, 10, 20, 11, 0, 12, 13, 13, 19, 32, 14, 15, 20, 18, 0, 16, 19, 19, 16, 38, 9, 16, 18, 8, 0, 11, 19, 10, 22, 32, 17, 15, 19, 16, 0, 9, 13, 13, 11, 22, 14, 16, 21, 13, 0, 14, 15, 17, 12, 32, 17, 15, 11, 14, 0, 13, 16, 13, 18, 22, 22, 17, 18, 9, 0, 12, 19, 13, 13, 53, 18, 16, 14, 17, 0, 15, 9, 13, 17, 29, 11, 19, 14, 17, 0, 15, 18, 9, 14, 35, 19, 12, 27, 17, 0, 10, 6, 13, 20, 26, 14, 13, 18, 16, 0, 14, 14, 11, 23, 29, 10, 19, 18, 14, 0, 14, 17, 13, 13, 33, 21, 18, 18, 14, 0, 12, 16, 12, 15, 30, 19, 14, 11, 17, 0, 8, 20, 17, 17, 34, 25, 16, 19, 17, 0, 14, 21, 8, 15, 24, 19, 11, 13, 15, 0, 10, 18, 8, 18, 16, 11, 15, 21, 14, 0, 12, 17, 9, 18, 35, 21, 13, 14, 18, 0, 16, 18, 13, 17, 26, 12, 13, 16, 13, 0, 14, 20, 15, 22, 33, 20, 13, 20, 14, 0, 12, 17, 12, 17, 29, 19, 14, 11, 18, 0, 12, 16, 14, 21, 25, 13, 14, 14, 14, 0, 12, 14, 21, 19, 33, 8, 10, 14, 13, 0, 12, 20, 16, 15, 27, 25, 19, 17, 13, 0, 21, 13, 8, 14, 27, 18, 17, 12, 13, 0, 11, 20, 13, 18, 32, 19, 11, 19, 13, 0, 14, 14, 12, 17, 23, 16, 19, 22, 14, 0, 14, 12, 10, 19, 33, 19, 13, 20, 16, 0, 8, 13, 16, 23, 26, 14, 5, 16, 9, 0, 16, 21, 16, 16, 29, 12, 12, 13, 15, 0, 18, 13, 17, 14, 22, 20, 13, 16, 16, 0, 11, 14, 13, 11, 30, 22, 18, 14, 9, 0, 12, 14, 14, 14, 35, 19, 17, 17, 16, 0, 20, 21, 8, 8, 32, 14, 13, 12, 13, 0, 12, 19, 14, 17, 31, 12, 14, 18, 15, 0, 7, 21, 13, 22, 32, 16, 13, 21, 11, 0, 16, 17, 18, 13, 32, 19, 13, 16, 12, 0, 17, 17, 13, 15, 23, 13, 14, 13, 14, 0, 14, 17, 17, 21, 21, 28, 18, 10, 17, 0, 11, 19, 15, 14, 27, 14, 8, 18, 16, 0, 10, 14, 13, 19, 23, 19, 14, 19, 15, 0, 12, 14, 14, 12, 23, 18, 13, 8, 8, 0, 11, 15, 13, 15, 34, 18, 15, 17, 8, 0, 12, 23, 19, 16, 27, 20, 15, 14, 11, 0, 10, 14, 10, 23, 109, 14, 9, 13, 14, 0, 13, 17, 12, 14, 26, 9, 13, 9, 11, 0, 14, 18, 17, 19, 26, 21, 14, 13, 15, 0, 14, 17, 14, 12, 45, 17, 17, 18, 15, 0, 17, 19, 13, 13, 26, 17, 13, 14, 9, 0, 12, 22, 13, 16, 25, 19, 12, 22, 17, 0, 10, 14, 15, 15, 24, 16, 13, 13, 16, 0, 12, 19, 14, 19, 24, 16, 11, 13, 14, 0, 7, 15, 10, 17, 35, 12, 15, 18, 13, 0, 15, 19, 15, 19, 18, 19, 15, 13, 18, 0, 14, 18, 16, 17, 36, 24, 14, 14, 19, 0, 13, 12, 8, 13, 23, 13, 16, 20, 14, 0, 13, 15, 11, 19, 27, 17, 13, 21, 17, 0, 15, 20, 11, 16, 35, 11, 16, 24, 14, 0, 9, 16, 13, 18, 32, 18, 10, 19, 18, 0, 15, 21, 14, 12, 24, 8, 14, 14, 17, 0, 14, 13, 15, 17, 29, 11, 14, 20, 12, 0, 14, 21, 11, 20, 30, 16, 17, 17, 19, 0, 7, 17, 13, 18, 29, 22, 15, 21, 17, 0, 12, 19, 10, 8, 28, 19, 13, 19, 13, 0, 14, 30, 13, 19, 22, 13, 16, 21, 14, 0, 14, 22, 13, 17, 29, 20, 14, 20, 14, 0, 14, 13, 19, 14, 21, 11, 12, 14, 14, 0, 11, 21, 13, 20, 33, 17, 14, 20, 12, 0, 14, 14, 14, 22, 23, 15, 20, 15, 11, 0, 13, 14, 7, 8, 36, 21, 18, 18, 19, 0, 14, 19, 14, 22, 25, 13, 13, 20, 12, 0, 11, 22, 8, 16, 29, 18, 12, 20, 14, 0, 16, 13, 14, 17, 19, 13, 14, 14, 15, 0, 16, 13, 15, 13, 13, 20, 15, 28, 15, 0, 19, 19, 17, 20, 30, 14, 10, 17, 17, 0, 15, 22, 8, 13, 24, 14, 15, 17, 14, 0, 12, 18, 13, 16, 23, 10, 12, 19, 9, 0, 8, 14, 14, 21, 32, 15, 14, 8, 12, 0, 12, 12, 12, 12, 10, 13, 13, 25, 10, 0, 16, 22, 16, 12, 26, 18, 10, 7, 13, 0, 15, 30, 14, 12, 34, 14, 12, 21, 8, 0, 18, 21, 13, 15, 38, 20, 10, 20, 19, 0, 8, 12, 12, 21, 31, 14, 12, 20, 11, 0, 14, 15, 14, 14, 29, 14, 18, 8, 17, 0, 13, 15, 9, 19, 26, 19, 15, 21, 11, 0, 15, 17, 13, 13, 27, 17, 17, 15, 18, 0, 13, 13, 11, 16, 16, 15, 17, 17, 14, 0, 13, 19, 14, 11, 17, 24, 18, 18, 18, 0, 11, 14, 13, 19, 32, 16, 12, 13, 6, 0, 8, 32, 16, 14, 19, 21, 13, 13, 16, 0, 9, 21, 10, 13, 17, 16, 14, 17, 10, 0, 13, 20, 11, 16, 21, 15, 13, 17, 12, 0, 15, 17, 17, 16, 53, 15, 13, 11, 13, 0, 14, 18, 13, 13, 29, 19, 13, 16, 14, 0, 16, 16, 13, 20, 13, 22, 13, 13, 11, 0, 16, 20, 14, 17, 23, 11, 11, 11, 17, 0, 8, 22, 13, 17, 25, 15, 11, 16, 16, 0, 8, 19, 13, 20, 35, 11, 16, 22, 13, 0, 11, 17, 13, 19, 21, 15, 16, 13, 12, 0, 19, 17, 18, 16, 27, 17, 14, 17, 15, 0, 15, 18, 8, 18, 41, 20, 9, 13, 13, 0, 13, 23, 14, 19, 21, 20, 12, 13, 15, 0, 13, 13, 10, 13, 705, 14, 16, 6, 6, 0, 6, 18, 6, 18, 22, 14, 12, 6, 10, 0, 15, 22, 13, 17, 29, 16, 11, 17, 11, 0, 13, 20, 6, 6, 30, 16, 11, 12, 13, 0, 15, 15, 13, 13, 23, 8, 11, 21, 12, 0, 13, 20, 15, 19, 35, 19, 9, 6, 18, 0, 16, 7, 14, 21, 26, 9, 14, 19, 12, 0, 8, 21, 13, 20, 25, 13, 10, 18, 19, 0, 12, 13, 6, 18, 21, 16, 18, 15, 18, 0, 9, 20, 18, 14, 20, 12, 16, 15, 16, 0, 13, 16, 20, 16, 25, 14, 13, 6, 16, 0, 17, 13, 14, 20, 28, 14, 18, 13, 17, 0, 14, 13, 15, 95, 34, 7, 16, 17, 12, 0, 16, 14, 6, 27, 24, 15, 13, 17, 13, 0, 15, 17, 17, 13, 26, 17, 17, 15, 16, 0, 18, 17, 18, 14, 16, 12, 20, 13, 10, 0, 10, 17, 13, 19, 38, 22, 9, 25, 11, 0, 11, 22, 12, 19, 29, 19, 17, 13, 16, 0, 13, 19, 14, 14, 25, 20, 10, 13, 13, 0, 19, 19, 13, 18, 21, 12, 13, 27, 15, 0, 14, 22, 14, 14, 34, 13, 13, 17, 8, 0, 19, 21, 17, 14, 26, 11, 13, 16, 15, 0, 11, 17, 8, 17, 36, 14, 16, 17, 15, 0, 9, 14, 16, 12, 15, 19, 10, 14, 13, 0, 17, 14, 8, 25, 20, 20, 13, 12, 12, 0, 15, 15, 14, 17, 15, 21, 11, 6, 6, 0, 18, 18, 14, 19, 21, 13, 11, 18, 15, 0, 11, 18, 15, 20, 31, 19, 13, 18, 15, 0, 7, 17, 6, 22, 28, 14, 14, 18, 16, 0, 7, 21, 11, 16, 29, 19, 10, 9, 17, 0, 13, 15, 16, 11, 26, 14, 18, 13, 10, 0, 14, 23, 13, 20, 32, 18, 17, 19, 19, 0, 9, 19, 9, 18, 26, 22, 16, 22, 13, 0, 16, 15, 11, 15, 18, 21, 13, 14, 15, 0, 10, 8, 13, 20, 23, 14, 17, 17, 12, 0, 18, 22, 15, 17, 142, 18, 9, 23, 13, 0, 14, 15, 14, 11, 23, 14, 9, 20, 17, 0, 11, 17, 14, 13, 30, 14, 13, 19, 14, 0, 14, 9, 14, 20, 13, 16, 15, 19, 15, 0, 12, 20, 16, 16, 28, 21, 12, 11, 9, 0, 14, 14, 16, 16, 33, 17, 7, 24, 12, 0, 18, 12, 9, 23, 17, 17, 17, 20, 15, 0, 7, 27, 12, 18, 22, 14, 13, 15, 15, 0, 16, 26, 12, 18, 21, 14, 15, 9, 13, 0, 12, 17, 15, 11, 28, 9, 16, 15, 16, 0, 18, 21, 14, 13, 33, 20, 13, 17, 13, 0, 14, 17, 13, 21, 20, 11, 14, 18, 13, 0, 14, 20, 21, 16, 26, 13, 11, 14, 15, 0, 13, 17, 16, 14, 19, 24, 11, 11, 8, 0, 12, 18, 13, 10, 22, 16, 18, 17, 13, 0, 12, 19, 13, 23, 24, 13, 17, 6, 16, 0, 14, 23, 6, 21, 29, 15, 14, 16, 13, 0, 17, 12, 17, 19, 23, 14, 8, 8, 10, 0, 6, 16, 15, 19, 61, 20, 13, 14, 13, 0, 13, 18, 15, 12, 21, 17, 13, 17, 12, 0, 17, 19, 9, 16, 38, 19, 9, 13, 17, 0, 19, 21, 14, 19, 15, 10, 15, 19, 10, 0, 18, 19, 9, 16, 30, 18, 14, 14, 15, 0, 12, 18, 11, 15, 19, 16, 17, 19, 13, 0, 18, 11, 14, 20, 23, 22, 17, 14, 12, 0, 15, 16, 15, 22, 16, 16, 14, 10, 12, 0, 12, 21, 11, 26, 25, 20, 13, 13, 16, 0, 9, 16, 12, 13, 29, 23, 10, 18, 16, 0, 16, 11, 15, 14, 23, 14, 15, 10, 17, 0, 12, 14, 14, 17, 25, 42, 19, 19, 11, 0, 8, 21, 16, 11, 24, 16, 13, 13, 15, 0, 10, 16, 15, 21, 34, 16, 14, 13, 16, 0, 16, 13, 8, 12, 18, 14, 9, 25, 11, 0, 18, 13, 16, 17, 52, 11, 15, 13, 15, 0, 15, 19, 11, 22, 29, 11, 13, 20, 15, 0, 15, 17, 11, 13, 34, 21, 13, 19, 18, 0, 14, 15, 10, 11, 21, 20, 13, 11, 17, 0, 13, 18, 13, 21, 23, 13, 13, 9, 15, 0, 15, 18, 19, 12, 29, 11, 11, 10, 12, 0, 14, 13, 13, 13, 27, 19, 14, 15, 14, 0, 10, 19, 15, 14, 18, 17, 8, 6, 19, 0, 18, 10, 13, 20, 25, 16, 18, 21, 11, 0, 12, 17, 15, 15, 33, 22, 17, 20, 7, 0, 12, 11, 15, 20, 19, 18, 13, 12, 16, 0, 11, 16, 16, 19, 30, 16, 7, 19, 19, 0, 8, 17, 18, 18, 38, 14, 13, 14, 13, 0, 14, 18, 11, 13, 24, 19, 13, 19, 8, 0, 12, 18, 12, 14, 28, 15, 14, 10, 13, 0, 14, 14, 15, 20, 21, 18, 16, 26, 11, 0, 13, 17, 12, 13, 30, 14, 14, 23, 18, 0, 11, 16, 15, 20, 20, 16, 8, 17, 15, 0, 17, 15, 13, 14, 21, 16, 10, 14, 13, 0, 16, 17, 12, 18, 21, 15, 11, 14, 13, 0, 14, 13, 14, 21, 25, 14, 14, 19, 16, 0, 18, 18, 18, 11, 61, 16, 14, 19, 14, 0, 15, 30, 12, 13, 53, 17, 13, 17, 18, 0, 17, 15, 18, 13, 21, 14, 11, 18, 13, 0, 10, 20, 14, 21, 23, 15, 11, 19, 12, 0, 13, 24, 12, 13, 24, 13, 10, 21, 15, 0, 15, 9, 14, 18, 29, 13, 15, 16, 12, 0, 13, 13, 14, 20, 35, 23, 11, 13, 16, 0, 13, 11, 15, 17, 32, 9, 14, 16, 16, 0, 19, 15, 14, 14, 22, 13, 9, 14, 7, 0, 19, 20, 12, 23, 29, 18, 16, 20, 12, 0, 17, 20, 11, 15, 28, 20, 15, 21, 15, 0, 11, 18, 13, 22, 27, 14, 12, 6, 13, 0, 15, 14, 10, 8, 40, 19, 15, 9, 16, 0, 14, 11, 9, 24, 33, 12, 13, 12, 10, 0, 13, 20, 15, 14, 31, 19, 11, 15, 14, 0, 9, 22, 14, 13, 15, 16, 17, 22, 15, 0, 11, 19, 12, 17, 33, 7, 12, 15, 9, 0, 19, 22, 15, 21, 28, 7, 11, 8, 7, 0, 16, 12, 10, 14, 12, 24, 9, 19, 7, 0, 16, 13, 12, 14, 16, 19, 12, 17, 13, 0, 14, 13, 12, 20, 33, 19, 12, 17, 16, 0, 15, 12, 18, 14, 34, 19, 11, 19, 8, 0, 12, 11, 16, 15, 33, 12, 14, 17, 18, 0, 9, 17, 17, 13, 23, 24, 13, 19, 11, 0, 13, 19, 13, 17, 23, 15, 14, 13, 8, 0, 13, 21, 18, 20, 12, 18, 13, 20, 23, 0, 14, 21, 14, 15, 14, 21, 17, 18, 16, 0, 16, 18, 16, 19, 12, 13, 15, 18, 13, 0, 13, 20, 8, 14, 22, 18, 13, 15, 10, 0, 15, 16, 11, 19, 27, 14, 16, 18, 8, 0, 12, 13, 17, 14, 18, 18, 15, 13, 13, 0, 21, 15, 17, 8, 24, 19, 18, 18, 16, 0, 13, 20, 11, 14, 29, 20, 8, 13, 13, 0, 16, 14, 15, 18, 21, 16, 12, 18, 16, 0, 11, 15, 16, 19, 26, 18, 14, 19, 14, 0, 8, 17, 12, 20, 17, 14, 15, 16, 9, 0, 16, 19, 10, 21, 29, 14, 14, 6, 11, 0, 14, 18, 14, 14, 25, 18, 8, 18, 13, 0, 11, 13, 13, 16, 38, 18, 17, 16, 12, 0, 18, 11, 14, 10, 9, 18, 11, 17, 14, 0, 12, 20, 15, 14, 29, 15, 15, 17, 19, 0, 13, 20, 15, 25, 34, 18, 14, 20, 20, 0, 15, 15, 15, 16, 18, 23, 14, 30, 12, 0, 11, 17, 11, 24, 34, 15, 20, 18, 13, 0, 6, 14, 14, 19, 32, 13, 12, 14, 15, 0, 14, 16, 15, 15, 37, 17, 14, 18, 14, 0, 14, 23, 16, 14, 28, 12, 14, 10, 13, 0, 12, 14, 10, 18, 17, 9, 12, 17, 18, 0, 13, 13, 9, 18, 23, 21, 15, 15, 16, 0, 13, 26, 12, 19, 20, 14, 13, 20, 8, 0, 16, 14, 16, 20, 15, 17, 13, 18, 13, 0, 7, 13, 17, 15, 24, 11, 11, 14, 10, 0, 13, 21, 12, 27, 33, 16, 14, 14, 14, 0, 10, 18, 14, 14, 28, 12, 15, 16, 18, 0, 14, 18, 12, 18, 34, 20, 13, 11, 11, 0, 10, 19, 18, 13, 19, 11, 16, 18, 16, 0, 10, 19, 13, 15, 28, 19, 8, 11, 14, 0, 16, 22, 17, 20, 23, 15, 17, 18, 14, 0, 13, 14, 14, 16, 18, 20, 13, 25, 14, 0, 11, 18, 17, 17, 30, 11, 13, 19, 13, 0, 16, 14, 9, 16, 26, 17, 17, 36, 15, 0, 9, 16, 12, 19, 28, 13, 12, 11, 18, 0, 16, 20, 14, 14, 20, 14, 11, 19, 15, 0, 15, 16, 11, 9, 29, 19, 15, 16, 13, 0, 13, 13, 18, 14, 23, 18, 14, 12, 10, 0, 9, 21, 14, 19, 27, 17, 8, 17, 17, 0, 7, 14, 12, 19, 26, 18, 18, 14, 18, 0, 12, 18, 18, 20, 24, 16, 14, 17, 18, 0, 17, 11, 16, 24, 25, 18, 15, 10, 13, 0, 11, 18, 17, 18, 33, 13, 14, 12, 10, 0, 13, 17, 10, 18, 21, 19, 14, 13, 18, 0, 13, 17, 16, 20, 42, 13, 16, 13, 11, 0, 14, 25, 16, 13, 28, 17, 11, 19, 14, 0, 14, 17, 11, 21, 33, 19, 13, 19, 15, 0, 13, 23, 13, 17, 24, 21, 11, 26, 17, 0, 19, 13, 15, 18, 61, 14, 16, 21, 14, 0, 13, 21, 16, 19, 32, 19, 17, 11, 14, 0, 8, 15, 14, 15, 21, 14, 13, 12, 11, 0, 15, 23, 12, 20, 32, 13, 14, 10, 13, 0, 18, 14, 19, 15, 23, 16, 14, 18, 14, 0, 16, 11, 15, 19, 28, 10, 11, 16, 13, 0, 14, 28, 8, 16, 38, 13, 17, 19, 14, 0, 13, 14, 16, 22, 19, 19, 14, 20, 17, 0, 16, 16, 12, 15, 23, 17, 15, 13, 8, 0, 15, 14, 7, 25, 32, 21, 17, 17, 17, 0, 13, 14, 19, 11, 33, 18, 14, 20, 9, 0, 13, 18, 14, 16, 26, 12, 8, 19, 14, 0, 16, 19, 13, 25, 27, 27, 18, 27, 16, 0, 17, 18, 9, 7, 32, 16, 10, 13, 17, 0, 9, 15, 18, 19, 14, 13, 17, 15, 16, 0, 19, 13, 16, 17, 21, 18, 16, 13, 18, 0, 14, 22, 13, 21, 90, 12, 11, 22, 15, 0, 16, 20, 12, 19, 31, 15, 10, 19, 13, 0, 17, 13, 15, 17, 21, 16, 16, 19, 18, 0, 13, 22, 14, 8, 23, 19, 16, 16, 16, 0, 12, 20, 12, 19, 22, 17, 17, 22, 13, 0, 12, 9, 19, 15, 21, 20, 16, 21, 16, 0, 14, 19, 17, 16, 23, 13, 13, 16, 13, 0, 11, 23, 10, 17, 40, 21, 13, 12, 14, 0, 16, 17, 12, 17, 21, 11, 15, 22, 11, 0, 14, 13, 14, 14, 23, 18, 18, 17, 13, 0, 13, 12, 19, 20, 32, 19, 17, 14, 13, 0, 14, 14, 13, 15, 12, 16, 15, 16, 8, 0, 20, 20, 15, 19, 25, 21, 17, 20, 16, 0, 10, 18, 11, 13, 23, 14, 13, 19, 13, 0, 10, 16, 11, 18, 18, 16, 12, 14, 15, 0, 17, 18, 12, 17, 22, 20, 14, 20, 16, 0, 15, 15, 9, 7, 31, 13, 8, 18, 14, 0, 7, 9, 8, 18, 29, 22, 16, 11, 15, 0, 18, 12, 16, 13, 26, 12, 11, 12, 12, 0, 11, 18, 13, 17, 29, 14, 14, 18, 15, 0, 13, 13, 10, 20, 34, 18, 18, 16, 14, 0, 9, 21, 13, 18, 38, 12, 16, 14, 14, 0, 16, 15, 13, 15, 20, 17, 9, 7, 12, 0, 11, 14, 15, 19, 27, 18, 14, 14, 11, 0, 13, 12, 14, 14, 29, 11, 20, 22, 13, 0, 16, 17, 16, 20, 26, 21, 12, 17, 13, 0, 17, 19, 13, 20, 28, 18, 14, 19, 12, 0, 17, 16, 13, 22, 24, 17, 11, 15, 13, 0, 19, 13, 13, 14, 24, 25, 13, 17, 14, 0, 17, 19, 16, 21, 28, 20, 15, 18, 17, 0, 15, 18, 14, 14, 20, 17, 17, 20, 17, 0, 12, 11, 13, 17, 28, 17, 12, 16, 13, 0, 11, 17, 9, 15, 23, 8, 15, 29, 13, 0, 9, 16, 15, 21, 29, 18, 19, 21, 13, 0, 15, 10, 14, 20, 25, 13, 12, 15, 9, 0, 13, 15, 13, 19, 45, 13, 16, 9, 11, 0, 15, 17, 19, 21, 29, 17, 12, 19, 13, 0, 15, 14, 13, 10, 26, 18, 17, 16, 17, 0, 8, 20, 13, 18, 23, 13, 11, 20, 17, 0, 13, 17, 15, 14, 15, 21, 15, 21, 19, 0, 19, 14, 18, 18, 32, 14, 11, 8, 9, 0, 16, 17, 12, 19, 28, 23, 15, 21, 15, 0, 20, 18, 11, 27, 26, 17, 30, 24, 21, 0 };

int main()
{
	cin >> n;
	cout << ans[n - 1] << endl;
	return 0;
}
----------
====================
----------
ALGORITHMS.357
advanced
----------
PROBLEM STATEMENT:
Divide-and-Conquer on a tree is a powerful approach to solving tree problems. 

Imagine a tree, [expression].

The Divide-and-Conquer approach can be described as follows:


Initially, there is a tree, [expression] vertices.
Find vertex [expression].
Remove [expression].
Perform this approach recursively for each of the connected components.


We can prove that if we find such a vertex [expression] that we can choose.

Given [expression].
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define trav(a, x) for (auto& a : x)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

ll mod;
vector<ll> fact, ifact;

vector<int> mem;
vector<vector<int>> mem2;
ll solve2(int left, int max);

ll rsolve(int n) {
	if (n <= 5) return n != 2;
	return solve2(n-1, (n-1)/2);
}

ll solve(int n) {
	assert(n > 0);
	int& out = mem[n];
	if (out != -1) return out;
	return out = (int)(rsolve(n) * n % mod);
}

ll solve2(int left, int max) {
	if (left == 0) return 1;
	if (!max) return 0;
	int& out = mem2[left][max];
	if (out != -1) return out;
	ll res = solve2(left, max-1);
	if (max > left) return out = (int)res;
	int lim = left / max;
	ll one = solve(max) * max % mod * ifact[max] % mod;
	ll mult = one * fact[left] % mod;
	for (int i = 1;; i++) {
		ll bin = ifact[i] * ifact[left - i * max] % mod;
		res += solve2(left - i * max, max-1) * mult % mod * bin;
		if (i == lim) break;
		if (i % 4 == 0) res %= mod;
		mult = mult * one % mod;
	}
	res %= mod;
	return out = (int)res;
}

int main() {
	cin.sync_with_stdio(false);
	cin.exceptions(cin.failbit);
	int N;
	cin >> N >> mod;
	mem.assign(N+1, -1);
	mem2.assign(N+1, vector<int>(N+1, -1));
	int LIM = N+1;
	ll* inv = new ll[LIM] - 1; inv[1] = 1;
	rep(i,2,LIM) inv[i] = mod - (mod / i) * inv[mod % i] % mod;
	fact.resize(N+1);
	ifact.resize(N+1);
	fact[0] = ifact[0] = 1;
	rep(i,1,N+1) {
		fact[i] = fact[i-1] * i % mod;
		ifact[i] = ifact[i-1] * inv[i] % mod;
	}
	cout << solve(N) << endl;
	exit(0);
}

----------
====================
----------
ALGORITHMS.358
expert
----------
PROBLEM STATEMENT:
The King of Byteland wants to grow his territory by conquering [expression] heirs for the future, he decides they must work together to capture each country. 

The King has an army, [expression], the heirs will fight alone without any help.

The battalions chosen for battle must be selected in the following way:


A subsequence of [expression]). 
The [expression]. 


The soldiers within a battalion have unique strengths. For a battalion of size [expression]

The King tasks you with finding the number of ways of selecting [expression].
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;
#define FOR(i,a,b) for(int i = (a); i <= (b); ++i)
#define FORD(i,a,b) for(int i = (a); i >= (b); --i)
#define RI(i,n) FOR(i,1,(n))
#define REP(i,n) FOR(i,0,(n)-1)
#define mini(a,b) a=min(a,b)
#define maxi(a,b) a=max(a,b)
#define mp make_pair
#define pb push_back
#define st first
#define nd second
#define sz(w) (int) w.size()
typedef vector<int> vi;
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
const int inf = 1e9 + 5;
const int nax = 1e6 + 5;
const int mod = 1e9 + 7;

pii mul(pii a, pii b) {
	ll c = (ll) a.st * b.st - (ll) a.nd * b.nd;
	ll d = (ll) a.st * b.nd + (ll) a.nd * b.st;
	c %= mod;
	d %= mod;
	if(c < 0) c += mod;
	if(d < 0) d += mod;
	return mp((int) c, (int) d);
}

pii pw(pii a, int k) {
	pii r = mp(1, 0);
	while(k) {
		if(k % 2) r = mul(r, a);
		a = mul(a, a);
		k /= 2;
	}
	return r;
}
int pw(int a, int k) {
	int r = 1;
	while(k) {
		if(k % 2) r = (ll) r * a % mod;
		a = (ll) a * a % mod;
		k /= 2;
	}
	return r;
}

int f(int n) {
	int r = pw(mp(1,mod-1), n).st + pw(mp(1,1), n).st;
	r %= mod;
	r += pw(2, n);
	r %= mod;
	r = (ll) r * pw(4, mod - 2) % mod;
	return r;
}

int dp[105];

int main() {
	int n, k;
	scanf("%d%d", &n, &k);
	dp[0] = 1;
	REP(_, n) {
		int a;
		scanf("%d", &a);
		a = f(a);
		FORD(j, k, 1)
			dp[j] = (dp[j] + (ll) dp[j-1] * a) % mod;
	}
	printf("%d\n", dp[k]);
	return 0;
}

----------
====================
----------
ALGORITHMS.359
advanced
----------
PROBLEM STATEMENT:
Borussia Dortmund are a famous football ( soccer ) club from Germany. Apart from their fast-paced style of playing, the thing that makes them unique is the hard to pronounce names of their players ( błaszczykowski , papastathopoulos , großkreutz etc. ).

The team's coach is your friend. He is in a dilemma as he can't decide how to make it easier to call the players by name, during practice sessions. So, you advise him to assign easy names to his players. A name is easy to him if 

1. It consists of only one word. 
2. It consists of only lowercase english letters. 
3. Its length is exactly [expression]. 
4. It contains exactly [expression] letters of English alphabet. 
5. At least one of its proper prefixes matches with its proper suffix of same length.

Given, [expression].

Note : A prefix [expression].

Input Format 
The first line of the input will contain [expression] ( the number of testcases ).
Each of the next [expression].

Output Format 
For each testcase, output the number of ways the coach can assign names to his players modulo [expression].

Constraints 
[expression] 
[expression] 
[expression]

Sample Input #1

3
1 1
2 1
4 2


Sample Output #1

0  
26 
2600  


Sample Input #2

5  
2 2
5 1
3 2
6 2
1 3


Sample Output #2

0
26
650
13650
0

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
typedef long long LL;
using namespace std;
const int SIZE = 1e5+5;
const int MOD = 1e9+9;
LL C[27][27],an[27][SIZE],tmp[27][SIZE],pp[27][SIZE],tmp2[27][SIZE],ha[27];
int main(){
    REPP(i,1,27){
        pp[i][0]=1;
        REPP(j,1,SIZE)pp[i][j]=pp[i][j-1]*i%MOD;
    }
    REP(i,27){
        C[i][0]=1;
        REPP(j,1,i+1){
            C[i][j]=C[i-1][j-1]+C[i-1][j];
        }
    }
    REPP(i,1,27){
        an[i][1]=i;
        tmp[i][1]=i;
        REPP(j,2,SIZE){
            if(j%2==0)an[i][j]=tmp[i][j/2];
            else an[i][j]=tmp[i][j/2]*i%MOD;
            an[i][j]=pp[i][j]-an[i][j];
            REPP(k,1,i){
                an[i][j]=(an[i][j]-an[k][j]*C[i][k])%MOD;
            }
            if(an[i][j]<0)an[i][j]+=MOD;
            tmp[i][j]=tmp[i][j-1]*i*i%MOD;
            REPP(k,1,i+1){
                tmp[i][j]=(tmp[i][j]+C[i][k]*an[k][j])%MOD;
            }

        }

    }
    CASET{ 
        DRII(N,K);
        if(N==1){
            puts("0");
            continue;
        }
        LL res=0;
        if(N%2==0){
            ha[1]=tmp[1][N/2];
            REPP(i,2,K+1){
                ha[i]=tmp[i][N/2];
                REPP(j,1,i)ha[i]=(ha[i]-ha[j]*C[i][j])%MOD;
                if(ha[i]<0)ha[i]+=MOD;
            }
            res=ha[K]*C[26][K]%MOD;
        }
        else{
            ha[1]=tmp[1][N/2];
            REPP(i,2,K+1){
                ha[i]=tmp[i][N/2]*i%MOD;
                REPP(j,1,i)ha[i]=(ha[i]-ha[j]*C[i][j])%MOD;
                if(ha[i]<0)ha[i]+=MOD;
            }
            res=ha[K]*C[26][K]%MOD;
        }
        if(K==1)res=26;
        if(res<0)res+=MOD;
        printf("%lld\n",res);
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.360
advanced
----------
PROBLEM STATEMENT:
Given an array of [expression].

Two subsequences [expression].
----------
TOP SOLUTION:
----------
#include <algorithm>
#include <cassert>
#include <cstring>
#include <iostream>

using namespace std;

#define FOR(i, a, b) for (int i = (a); i < (b); ++i)
#define REP(i, n) FOR(i, 0, n)
#define TRACE(x) cout << #x << " = " << x << endl
#define _ << " _ " <<

typedef long long llint;

const int MAX = 100100;
const llint inf = 2e18;

int L[MAX];

int getMax(int x) {
  int r = 0;
  for (++x; x; x -= x&-x)
    r = max(r, L[x]);
  return r;
}

void update(int x, int v) {
  for (++x; x < MAX; x += x&-x)
    L[x] = max(L[x], v);
}

llint S[MAX];

llint add(llint x, llint y) { return min(inf, x + y); }
llint mul(llint x, llint y) {
  if (x == 0 || y == 0) return 0;
  if (x < (inf + y - 1) / y) return min(x * y, inf);
  return inf;
}

llint sum(int x) {
  llint r = 0;
  for (++x; x; x -= x&-x)
    r = add(r, S[x]);
  return r;
}

void add(int x, llint v) {
  for (++x; x < MAX; x += x&-x)
    S[x] = add(S[x], v);
}

void clear(int x) {
  for (++x; x < MAX; x += x&-x)
    S[x] = 0;
}

int a[MAX];
int f[MAX];
llint g[MAX];
vector<int> v[MAX];

int main(void) {
  int N;
  llint K;
  scanf("%d %lld", &N, &K);
  REP(i, N) scanf("%d", &a[i]);

  for (int i = N-1; i >= 0; --i) {
    f[i] = getMax(N-a[i]-1) + 1;
    update(N-a[i], f[i]);
  }

  int L = getMax(N);
  REP(i, N) v[f[i]].push_back(i);
  
  for (int i = 1; i <= L; ++i) {
    int p = (int)v[i - 1].size() - 1;
    for (int j = (int)v[i].size() - 1; j >= 0; --j) {
      while (p >= 0 && v[i-1][p] > v[i][j]) {
        add(N-a[v[i-1][p]], g[v[i-1][p]]);
        p--;
      }
      if (i == 1) g[v[i][j]] = 1;
      else g[v[i][j]] = sum(N-a[v[i][j]]-1);
    }
    while (++p < (int)v[i-1].size()) clear(N-a[v[i-1][p]]);
  }

  llint total = 0;
  for (int x: v[L]) total = add(total, g[x]);
  if (total < K) {
    puts("-1");
    return 0;
  }

  vector<pair<int, llint>> cur = {{-1, 1}};
  vector<int> ans;
  int last = 0;
  for (int i = L; i > 0; --i) {
    auto count = [&] (int x) {
      int p = (int)v[i].size() - 1;
      llint total = 0;
      llint rsum = 0;
      for (int j = (int)cur.size() - 1; j >= 0; --j) {
        while (p >= 0 && v[i][p] > cur[j].first) {
          if (last < a[v[i][p]] && a[v[i][p]] <= x) rsum = add(rsum, g[v[i][p]]);
          p--;
        }
        total = add(total, mul(rsum, cur[j].second));
      }
      return total;
    };


    int lo = last + 1, hi = N;
    while (lo < hi) {
      int mid = (lo + hi) / 2;
      if (count(mid) < K) lo = mid + 1;
      else hi = mid;
    }

    K -= count(lo - 1);
    
    vector<pair<int, llint>> ncur;
    int p = 0;
    llint rsum = 0;
    REP(j, (int)v[i].size()) {
      while (p < (int)cur.size() && cur[p].first < v[i][j]) rsum = add(rsum, cur[p++].second);
      if (a[v[i][j]] == lo) ncur.push_back({v[i][j], rsum});
    }

    cur = ncur;
    ans.push_back(lo);
    last = lo;
  }

  for (int x: ans) printf("%d ", x); printf("\n");
  return 0;
}

----------
====================
----------
ALGORITHMS.361
expert
----------
PROBLEM STATEMENT:
Little Walter likes playing with his toy scales. He has [expression]. There are infinitely many weights of each type.

Recently, Walter defined a function, [expression]. Ways are considered to be different if there is a type which has a different number of weights used in these two ways.

For example, if there are [expression]:


Use [expression].
Use [expression].
Use [expression].
Use [expression].


Given [expression]?
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <cctype>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <set>
#include <map>
#include <sstream>
#include <iostream>
#include <functional>

using namespace std;

#define forn(i, n) for (int i = 0; i < (int)(n); i++)
#define forit(i, a) for (__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)
#define pb push_back
#define mp make_pair
#define sz(a) (int)(a).size()
#define all(a) (a).begin(), (a).end()

typedef long long ll;
typedef vector <int> vi;
typedef pair <int, int> pii;

int a[11]; // weights
int N;
int prod;

int DP[11][100001*11]; // DP[k][n] is number of ways with k weights of achieving total <= n

#define MOD 1000000007

ll mul_inv(ll a, ll b)
{
	ll b0 = b, t, q;
	ll x0 = 0, x1 = 1;
	if (b == 1) return 1;
	while (a > 1) {
		q = a / b;
		t = b, b = a % b, a = t;
		t = x0, x0 = x1 - q * x0, x1 = t;
	}
	if (x1 < 0) x1 += b0;
	return x1;
}

// Count ways of combining weights to make target of top
ll f(ll top) {
	ll total = 0;
	int b = top % prod;
	ll top2 = top / prod;
	// denumerant evaluated at position a.x+b is polynomial of degree at most 10
	// so evaluate at 11 points
	int last = 10*prod+b; // last location to evaluate
	forn(i,last+1)
		DP[0][i] = 1; // Consider weight 0 to be of value 1
	for(int k=1;k<=N;k++) {
		int w=a[k-1];
		forn(i,last+1) {
			DP[k][i] = (i>=w) ? ((DP[k][i-w] + DP[k-1][i]) % MOD) : DP[k-1][i];
		}
	}
	forn(x,11) {
		ll y = DP[N][x*prod+b];
		ll den = 1;
		forn(i,11) {
			if (i==x) continue;
			y = y*(((top2-i)+MOD)%MOD)%MOD;
			den = den*(((x-i)+MOD)%MOD)%MOD;
		}
		total = (total + y*mul_inv(den,MOD)%MOD) % MOD;
	}
	return total;
}

int main(int argc,char *argv[])
{
	ll total = 0;
	ll L,R;
	cin >> N;
	prod = 1;
	forn(n,N) {
		int x,y;
		cin >> a[n];
		prod *= a[n];
	}
	cin >> L >> R;
	total = (f(R) - f(L-1) + MOD) % MOD;
	cout << total << endl;
	return 0;
}





----------
====================
----------
ALGORITHMS.362
expert
----------
PROBLEM STATEMENT:
There are [expression] pairs of hard disk drives (HDDs) in a cluster. Each HDD is located at an integer coordinate on an infinite straight line, and each pair consists of one primary HDD and one backup HDD.

Next, you want to place [expression] computers at integer coordinates on the same infinite straight line. Each pair of HDDs must then be connected to a single computer via wires, but a computer can have any number (even zero) of HDDs connected to it. The length of a wire connecting a single HDD to a computer is the absolute value of the distance between their respective coordinates on the infinite line. We consider the total length of wire used to connect all the HDDs to computers to be the sum of the lengths of all the wires used to connect HDDs to computers. Note that both the primary and secondary HDDs in a pair must connect to the same computer.

Given the locations of [expression] computers in such a way that the total length of wire needed to connect each pair of HDDs to computers is minimal. Then print the total length on a new line.
----------
TOP SOLUTION:
----------
#include <sstream>
#include <vector>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <string>
#include <cassert>
#include <ctime>
#include <map>
#include <math.h>
#include <cstdio>
#include <set>
#include <deque>
#include <memory.h>
#include <queue>
#include <unordered_map>

#pragma comment(linker, "/STACK:64000000")
typedef long long ll;

using namespace std;

const int MAXN = 1 << 18;
const int MOD = 1; // 1000 * 1000 * 1000 + 7;
const ll INF = (ll)(1e18);

int n, k, m;
vector<int> a, b, vct;
vector<vector<ll> > dp;
vector<vector<int> > id[2];

vector<pair<int, int> > t[2][MAXN * 2];
vector<int> tt[2][MAXN * 2];
vector<ll> s[2][MAXN * 2];

void make(int tp, int v) {
	s[tp][v].resize(t[tp][v].size());
	for (int i = 0; i < (int)t[tp][v].size(); i++) {
		s[tp][v][i] = (i ? s[tp][v][i - 1] : 0) + t[tp][v][i].second;
	}
	tt[tp][v].resize(t[tp][v].size());
	for (int i = 0; i < (int)t[tp][v].size(); i++) {
		tt[tp][v][i] = t[tp][v][i].first;
	}
}

void build(int tp, int v, int tl, int tr) {
	t[tp][v].clear();
	if (tl == tr) {
		t[tp][v].reserve(id[tp][tl].size());
		for (int r : id[tp][tl]) {
			if (tp == 0) {
				t[tp][v].push_back(make_pair(vct[a[r]] + vct[b[r]], vct[a[r]]));
			}
			else {
				t[tp][v].push_back(make_pair(-vct[a[r]] - vct[b[r]], -vct[b[r]]));
			}
		}
		sort(t[tp][v].begin(), t[tp][v].end());
		make(tp, v);
		return;
	}
	int tm = (tl + tr) >> 1;
	build(tp, v * 2, tl, tm);
	build(tp, v * 2 + 1, tm + 1, tr);
	t[tp][v].resize(t[tp][v * 2].size() + t[tp][v * 2 + 1].size());
	merge(t[tp][v * 2].begin(), t[tp][v * 2].end(), t[tp][v * 2 + 1].begin(), t[tp][v * 2 + 1].end(), t[tp][v].begin());
	make(tp, v);
}

ll coef;
ll get(int tp, int v, int tl, int tr, int l, int r, int x) {
	if (l > r) return 0;
	if (l == tl && r == tr) {
		//int id = lower_bound(t[tp][v].begin(), t[tp][v].end(), make_pair(x, -(int)(1.1e9))) - t[tp][v].begin();
		int id = lower_bound(tt[tp][v].begin(), tt[tp][v].end(), x) - tt[tp][v].begin();
		return (id > 0) ? (id * coef + s[tp][v][id - 1]) : 0LL;
	}
	int tm = (tl + tr) >> 1;
	return get(tp, v * 2, tl, tm, l, min(r, tm), x) + get(tp, v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, x);
}


unordered_map<ll, ll> mp;

ll cost(int l, int j) {
	if (l > j) return INF;
	ll hh = ((ll)l << 32) + j;
	if (mp.count(hh)) {
		return mp[hh];
	}
	ll cost = 0;

	coef = -vct[l];
	cost += get(0, 1, 0, m - 1, l, j, vct[l] + vct[j] + 1);

	coef = vct[j];
	cost += get(1, 1, 0, m - 1, l, j, -vct[l] - vct[j]);

	cost *= 2;

	mp[hh] = cost;
	return cost;
}

void rec(int k, int l, int r, int optL, int optR) {
	if (l > r) return;
	int m = (l + r) >> 1;
	int opt = -1;
	for (int i = optL; i <= optR; i++) {
		if (dp[k - 1][i] >= dp[k][m]) continue;
		if (dp[k][m] > dp[k - 1][i] + cost(i, m)) {
			dp[k][m] = dp[k - 1][i] + cost(i, m);
			opt = i;
		}
	}
	rec(k, l, m - 1, optL, opt);
	rec(k, m + 1, r, opt, optR);
}


int main() {
#ifdef _MSC_VER
	freopen("input.txt", "r", stdin);
#endif
	mp.reserve((int)(5e6));

	while (scanf("%d%d", &n, &k) == 2) {
		a.resize(n);
		b.resize(n);
		for (int i = 0; i < n; i++) {
			int x, y;
			scanf("%d%d", &x, &y);
			a[i] = x;
			b[i] = y;
			if (a[i] > b[i]) swap(a[i], b[i]);
		}

		vct.clear();
		for (int i = 0; i < n; i++) {
			vct.push_back(a[i]);
			vct.push_back(b[i]);
		}
		vct.push_back(-1.001e9);
		vct.push_back(1.001e9);
		sort(vct.begin(), vct.end());
		vct.resize(unique(vct.begin(), vct.end()) - vct.begin());

		m = vct.size();

		for (int i = 0; i < n; i++) {
			a[i] = lower_bound(vct.begin(), vct.end(), a[i]) - vct.begin();
			b[i] = lower_bound(vct.begin(), vct.end(), b[i]) - vct.begin();
		}

		id[0].assign(m, vector<int>());
		id[1].assign(m, vector<int>());
		for (int i = 0; i < n; i++) {
			id[0][a[i]].push_back(i);
			id[1][b[i]].push_back(i);
		}
		build(0, 1, 0, m - 1);
		build(1, 1, 0, m - 1);

		ll sum = 0;
		for (int i = 0; i < n; i++) sum += vct[b[i]] - vct[a[i]];

		dp.assign(k + 1, vector<ll>(m, INF));
		dp[0][0] = 0;
		cerr << clock() / (double)CLOCKS_PER_SEC << endl;
		for (int i = 1; i <= k; i++) {
			rec(i, 1, m - 1, 0, m - 1);
		}

		ll mn = INF;
		ll ssum = 0;
		int cnt = 0;
		for (int i = m - 1; i >= 0; i--) {
			mn = min(mn, dp[k][i] + 2 * (ssum - 1LL * cnt * vct[i]));
			for (int ii = 0; ii < (int)id[0][i].size(); ii++) {
				int iid = id[0][i][ii];
				cnt++;
				ssum += vct[a[iid]];
			}
		}
		//ll mn = dp[k + 1][m - 1];
		cout << sum + mn << endl;
	}
	cerr << clock() / (double)CLOCKS_PER_SEC << endl;

	return 0;
}
----------
====================
----------
ALGORITHMS.363
expert
----------
PROBLEM STATEMENT:
Chinese Version
Russian Version

Tom and Derpina have a rectangular shaped chocolate bar with chocolates labeled T, D and U. They want to split the bar into exactly two pieces such that:


Tom's piece can not contain any chocolate labeled D and similarly, Derpina's piece can not contain any chocolate labeled T and U can be used by either of the two.  
All chocolates in each piece must be connected (two chocolates are connected if they share an edge), i.e. the chocolates should form one connected component
The absolute difference between the number of chocolates in pieces should be at most K
After dividing it into exactly two pieces, in any piece, there should not be 4 adjacent chocolates that form a square, i.e. there should not be a fragment like this: 
XX 
XX

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <string>
#include <map>
#include <cstring>
#include <cassert>
using namespace std;

typedef unsigned long long llu;
struct node {
int  num;   // black - white
char a[9];  //the number of the grid even-white odd-black
char no;   //the forbideen color the 0-white 1-black 2-both can
char vwb;  //the valid color 0-white 1-black 2-both 3-neither
char dwb;  //0-dead white (Never can appear a white grid) 1-dead black 3-neither dead
};

int m,n,last,now,pp,un;
llu ans;
char s[10][10];


inline bool operator<(const node &a,const node &b) {
    if (a.no < b.no) {
        return true;
    }
    if (a.no > b.no) {
        return false;
    }
    if (a.dwb < b.dwb) {
        return true;
    }
    if (a.dwb > b.dwb) {
        return false;
    }
    if (a.vwb < b.vwb) {
        return true;
    }
    if (a.vwb > b.vwb) {
        return false;
    }
        if (a.num<b.num) {
            return true;
        }
        if (a.num>b.num) {
            return false;
        }
    for (int i = 0;i < n;++i) {
        if (a.a[i] < b.a[i]) {
            return true;
        }
        if (a.a[i] > b.a[i]) {
            return false;
        }
    }
    return false;
}

map<node,llu> save[2];

inline bool iswhite(int x) {
    return !(x & 1);
}

inline bool isblack(int x) {
    return (x & 1);
}

void makelone(node &temp,int y,int x,int n) {
int i,j,z = (y << 1) + x;
    temp.a[y] = z;
    z = (y << 1);
    for (i = y + 1;i < n;++i) {
        if (temp.a[i] == z) {
            break;
        }
    }
    for (j = i,i <<= 1; j < n; ++j) {
        if (temp.a[j] == z) {
            temp.a[j] = i;
        }
    }
    z = (y << 1) | 1;
    for (i = y + 1;i < n;++i) {
        if (temp.a[i] == z) {
            break;
        }
    }
    for (j = i,i = (i << 1) | 1;j < n;++j) {
        if (temp.a[j] == z) {
            temp.a[j] = i;
        }
    }

}

void makeunion(node &temp,int x,int y,int n) {
    if (x < y) {
        x ^= y ^= x ^= y;
    }
    for (int i = 0; i < n;++i) {
        if (temp.a[i] == x) {
            temp.a[i] = y;
        }
    }
}


void makewhite(int x,int y,node temp,llu ans,int add) {
bool yes;
int i,j,k,ll,uu;
map<node,llu>::iterator t;

    if ((temp.no == 0) || (temp.dwb == 0))  { 
        return;
    }
    temp.num += add;
    if ((temp.num + un < -pp) || (temp.num - un > pp)) {
        return;
    }
    yes = (temp.dwb == 1);

    if ((x) && (temp.a[y] == ((y << 1) | 1))) { //above is the head of black
        for (i = y + 1;i < n;++i) {
            if (temp.a[i] == temp.a[y]) {
                break;
            }
        }
        if (i >= n) {
            if ((temp.vwb != 1) && (temp.vwb != 2)) { //make black dead
                return;
            }
            yes = true;
        }
    }
    ll = ((y) && iswhite(temp.a[y - 1]))?temp.a[y - 1]:(-1);
    uu = ((x) && iswhite(temp.a[y]))?temp.a[y]:(-1);
    k = x?n:(y + 1);
    if (uu < 0) {
        makelone(temp, y,0 ,k);
        if (ll >= 0) {
            temp.a[y] = ll;
        }
    }
    else if ((ll >= 0) && (ll != uu)) {
        makeunion(temp,ll,uu,k);

    }
    for (i = j = 0;i < k;++i) {
        if ((temp.a[i]== (i<<1)) && (++j > 1)) {
            break;
        }
    }
    if (j == 1) {
        temp.vwb = ((temp.vwb == 1) || (temp.vwb == 2))?2:0;
    }
    else { //j > 1
        temp.vwb = ((temp.vwb == 1) || (temp.vwb == 2))?1:3;
    }
    temp.dwb = yes?1:3;
    temp.no = ((uu >= 0) && (y + 1 < n) && ((temp.a[y + 1] & 1) == 0))?0:2;
    save[now][temp] += ans;

}


void makeblack(int x,int y,node temp,llu ans,int add) {
bool yes;
int i,j,k,ll,uu;
map<node,llu>::iterator t;

    if ((temp.no == 1) || (temp.dwb == 1))  { 
        return;
    }
    temp.num += add;
    if ((temp.num + un < -pp) || (temp.num - un > pp)) {
        return;
    }

    yes = (temp.dwb == 0);
    if ((x) && (temp.a[y]==(y << 1))) { //above is the head of white
        for (i = y + 1;i < n;++i) {
            if (temp.a[i] == temp.a[y]) {
                break;
            }
        }
        if (i >= n) {
            if ((temp.vwb != 0) && (temp.vwb != 2)) { ///make black dead
                return;
            }
            yes = true;
        }
    }

    ll = ((y) && isblack(temp.a[ y - 1]))?temp.a[y - 1]:(-1);
    uu = ((x) && isblack(temp.a[y]))?temp.a[y]:(-1);
    k = x?n:(y + 1);
    if (uu < 0) {
        makelone(temp,y,1,k);
        if (ll >= 0) {
            temp.a[y] = ll;
        }
    }
    else if ((ll >= 0) && (ll != uu)) {
        makeunion(temp,ll,uu,k);
    }
    for (i = j = 0;i < k;++i) {
        if ((temp.a[i]==((i << 1) | 1)) && (++j > 1)) {
            break;
        }
    }
    if (j == 1) {
        temp.vwb = ((temp.vwb==0) || (temp.vwb==2))?2:1;
    }
    else { //j>1
        temp.vwb = ((temp.vwb==0) || (temp.vwb==2))?0:3;
    }
    temp.dwb = yes?0:3;
    temp.no = ((uu >= 0) && (y + 1 < n) && ((temp.a[ y + 1] & 1) == 1))?1:2;
    save[now][temp] += ans;

}


int main() {
int z;
node temp;
    scanf("%d%d%d",&m,&n,&pp);
    assert(0 <= m && m <= 8);
    assert(0 <= n && n <= 8);
    assert(0 <= pp <= m*n);
    memset(temp.a,0,sizeof(temp.a));
    temp.num = 0;
    temp.no = temp.vwb = 2;
    temp.dwb = 3;
    save[0].clear();
    un = 0;
    for (int i  = 0;i < m;++i) {
        scanf("%s",s[i]);
        for (int j = 0; j < n; ++j) {
            if (s[i][j] == 'T') {
                ++temp.num;
            }
            else if (s[i][j] == 'D') {
                --temp.num;
            }
            else {
                ++un;
            }
        }
    }
    save[last = 0][temp] = 1;
    //printf("un = %d\n",un);
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n;++j) {
            save[now = 1 ^ last].clear();
            if (s[i][j] == 'U') {
                --un;
            }   
            for (map<node,llu>::iterator t = save[last].begin();t != save[last].end();++t) {
                if (s[i][j] == 'T') {
                    makeblack(i,j,t->first,t->second, 0);
                }
                else if (s[i][j] == 'D') {
                    makewhite(i,j,t->first,t->second, 0);
                }
                else {
                    makeblack(i,j,t->first,t->second, 1);
                    makewhite(i,j,t->first,t->second, -1);
                }
            }
            last = now;
        }

    }
    ans = 0;
    //printf("un = %d\n",un);
    assert(un == 0);
    for (map<node,llu>::iterator t = save[last].begin();t != save[last].end();++t) {
        if (t->first.vwb == 2) {
            assert((t->first.num >= -pp) && (t->first.num <= pp));
            //printf("%d %llu\n",t->first.num, t->second);
            ans += t->second;
        }
    }
    printf("%llu\n",ans);
    return 0;
}
----------
====================
----------
ALGORITHMS.364
easy
----------
PROBLEM STATEMENT:
You will be given an array of integers.  All of the integers except one occur twice.  That one is unique in the array.

Given an array of integers, find and print the unique element.  

For example, [expression].  

Function Description  

Complete the lonelyinteger function in the editor below.  It should return the integer which occurs only once in the input array.  

lonelyinteger has the following parameter(s):  


a: an array of integers  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <cstdlib>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
using namespace std;
int lonelyinteger(vector < int > a) {
int ans=0;
    vector<int> ::iterator it;
    for(it=a.begin();it!=a.end();it++)
        {
        ans^=(*it);
    }
    return ans;

}
int main() {
    int res;
    
    int _a_size;
    cin >> _a_size;
    cin.ignore (std::numeric_limits<std::streamsize>::max(), '\n'); 
    vector<int> _a;
    int _a_item;
    for(int _a_i=0; _a_i<_a_size; _a_i++) {
        cin >> _a_item;
        _a.push_back(_a_item);
    }
    
    res = lonelyinteger(_a);
    cout << res;
    
    return 0;
}

----------
====================
----------
ALGORITHMS.365
easy
----------
PROBLEM STATEMENT:
Given two integers, [expression] satisfy the following condition:

[expression]  

For example, if [expression], then 
[expression] 
[expression] 
[expression]  

Our maximum value is [expression].  

Function Description

Complete the maximizingXor function in the editor below.  It must return an integer representing the maximum value calculated.  

maximizingXor has the following parameter(s):


l: an integer, the lower bound, inclusive  
r: an integer, the upper bound, inclusive  

----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <cstdlib>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
using namespace std;
/*
 * Complete the function below.
 */
int maxXor(int l, int r) {
    int a=0;
    for (int i=l;i<=r;i++)
        for (int j=i;j<=r;j++)
        a=max(a,(i^j));
        return a;

}

int main() {
    int res;
    int _l;
    cin >> _l;
    
    int _r;
    cin >> _r;
    
    res = maxXor(_l, _r);
    cout << res;
    
    return 0;
}

----------
====================
----------
ALGORITHMS.366
medium
----------
PROBLEM STATEMENT:
Louise and Richard have developed a numbers game.  They pick a number and check to see if it is a power of [expression] wins the game.  Louise always starts.

Given an initial value, determine who wins the game.

As an example, let the initial value [expression].  She wins the game.

Update If they initially set counter to [expression], Richard wins.  Louise cannot make a move so she loses.

Function Description  

Complete the counterGame function in the editor below.  It should return the winner's name, either Richard or Louise.  

counterGame has the following parameter(s):  


n: an integer to initialize the game counter  

----------
TOP SOLUTION:
----------
#include<vector>
#include<iostream>
#include<stdio.h>
#include<bitset>
#include<algorithm>
#include<functional>
#include<numeric>
#include<utility>
#include<sstream>
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cmath>
#include<math.h>
#include<cstdlib>
#include<ctime>
#include<cstring>
#include<climits>
#include<sstream>
#include<string>
#include<set>
#include<map>
#include<utility>
#include<stack>
#include<queue>
#include<deque>
#include<list>
#include<bitset>
#define ll unsigned long long
 
#define FL(i,a,b) for(ll i=a;i<b;i++)
#define FOR(i,n) for(ll i=0;i<n;i++)
#define SORTF(x) sort(x.begin(),x.end(),func);
#define SORT(x) sort(x.begin(),x.end())
#define pb(x) push_back(x)
#define SET(v, val) memset(v, val, sizeof(v)) ;
#define RSORT(v) { SORT(v) ; REVERSE(v) ; }
#define ALL(v) v.begin(),v.end()
#define REVERSE(v) { reverse(ALL(v)) ; }
#define UNIQUE(v) unique((v).begin(), (v).end())
#define RUNIQUE(v) { SORT(v) ; (v).resize(UNIQUE(v) - (v).begin()) ; }
#define fill(x,n) memset(x,n,sizeof(x))
#define si(x) scanf("%d",&x)
#define si2(x,y) scanf("%d %d",&x,&y)
#define si3(x,y,z) scanf("%d %d %d",&x,&y,&z)
 
#define ss(x) scanf("%s",x)
 
#define sc(x) scanf("%c",&x)
 
#define sf(x) scanf("%f",&x)
 
#define sl(x) scanf("%lld",&x)
#define sl2(x,y) scanf("%lld %lld",&x,&y)
#define sl3(x,y,z) scanf("%lld %lld %lld",&x,&y,&z)
 
#define str string
#define lli long long int
#define ch char
#define fl float
 
#define out(x) cout << x << endl
#define out2(x,y) cout << x << " " << y << endl
#define out3(x,y,z) cout << x << " " << y << " " << z << endl
 
#define printi(x) printf("%lld\n",x)
#define printi2(x,y) printf("%lld %lld\n",x,y)
#define printi3(x,y,z) printf("%lld %lld %lld\n",x,y,z)
#define prints(x) printf("%s\n",x)
#define mod 1000000007
using namespace std;

int main()
{
	ll t,n;
	cin >> t;
	while(t--)
	{
		int c=0;
		cin >> n;
		while(n!=1)
		{
			if((n&(n-1))==0){
				n=n/2;
			}
			else{
				ll x = (ll)log2(n);
				n = n - (ll)pow(2,x);
			}
			c++;
		}
		if(c%2) cout << "Louise" << endl;
		else cout << "Richard" << endl;
	}
	return 0;
}
----------
====================
----------
ALGORITHMS.367
medium
----------
PROBLEM STATEMENT:
An array, [expression], is defined as follows: 


[expression]
[expression] is the symbol for XOR


You will be given a left and right index [expression]. 

For example, [expression]. 

Print the answer to each question.

Function Description  

Complete the xorSequence function in the editor below.  It should return the integer value calculated.  

xorSequence has the following parameter(s):  


l: the lower index of the range to sum  
r: the higher index of the range to sum  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

i64 xorp(i64 x) {
    i64 ans = 0;
    while (x) {
        if (x % 4 == 3) break;
        ans ^= x;
        --x;
    }
    return ans;
}

i64 xorpp(i64 x) {
    i64 ans = 0;
    while (x) {
        if (x % 8 == 7) break;
        ans ^= xorp(x);
        --x;
    }
    return ans;
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int q;
    cin >> q;
    forn(i, q) {
        i64 l, r;
        cin >> l >> r;
        cout << (xorpp(r) ^ xorpp(l - 1)) << '\n';
    }

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.368
easy
----------
PROBLEM STATEMENT:
Given an integer [expression] such that:


[expression]
[expression]


where [expression]'s satisfying the criteria.

For example, if [expression], there are four values:  


[expression]
[expression]
[expression]
[expression].  


Function Description

Complete the sumXor function in the editor below.  It should return the number of values determined, as an integer.  

sumXor has the following parameter(s): 
- n: an integer  
----------
TOP SOLUTION:
----------
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;


int main(){
    long long n;
    scanf("%lld", &n);
    long long res=1;
    while(n){
        if(n%2 == 0) res *= 2;
        n /= 2;
    }
    printf("%lld", res);
    return 0;
}

----------
====================
----------
ALGORITHMS.369
medium
----------
PROBLEM STATEMENT:
Given a long integer [expression] satisfying the following conditions:  


[expression]
[expression]


where [expression] is the bitwise XOR operator.  

You are given [expression] satisfying the conditions above on a new line.

For example, you are given the value [expression].  The following tests are run:  

[expression] 
[expression] 
[expression] 
[expression]   

We find that there are [expression].  

Function Description  

Complete the theGreatXor function in the editor below.  It should return an integer that represents the number of values satisfying the constraints.  

theGreatXor has the following parameter(s):


x: an integer  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;

typedef int _loop_int;
#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)
#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)
#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)

#define DEBUG(x) cout<<#x<<": "<<x<<endl
#define DEBUG_VEC(v) cout<<#v<<":";REP(i,v.size())cout<<" "<<v[i];cout<<endl
#define ALL(a) (a).begin(),(a).end()

#define CHMIN(a,b) a=min((a),(b))
#define CHMAX(a,b) a=max((a),(b))

// mod
const ll MOD = 1000000007ll;
#define FIX(a) ((a)%MOD+MOD)%MOD

// floating
typedef double Real;
const Real EPS = 1e-11;
#define EQ0(x) (abs(x)<EPS)
#define EQ(a,b) (abs(a-b)<EPS)
typedef complex<Real> P;

int main(){
    int q;
    scanf("%d",&q);
    while(q--){
        ll n;
        scanf("%lld",&n);
        ll b = 1;
        ll ans = 0;
        while(b < n){
            if(!(b&n)){
                ans += b;
            }
            b<<=1;
        }
        printf("%lld\n",ans);
    }
  return 0;
}

----------
====================
----------
ALGORITHMS.370
easy
----------
PROBLEM STATEMENT:
You will be given a list of 32 bit unsigned integers. Flip all the bits ([expression]) and print the result as an unsigned integer.  

For example, your decimal input [expression].  We're working with 32 bits, so:  

[expression] 
[expression]  

Function Description

Complete the flippingBits function in the editor below.  It should return the unsigned decimal integer result.  

flippingBits has the following parameter(s):


n: an integer

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
#define infinity (1000000007)
#define pii pair<int,int>
#define ppi pair<pii,int>
#define ppp pair<pii,pii>
#define pip pair<int,pii>
#define ll long long
#define pb push_back
const int mod=1000000007;
long long pwr(long long a,long long b,long long mod)
{
  if(b==0)
    return 1;
  long long temp=pwr(a,b/2,mod);
  temp=(temp*temp)%mod;
  if(b&1)
    temp=(temp*a)%mod;
  return temp;
}
long long pwr(long long a,long long b)
{
  if(b==0)
    return 1;
  long long temp=pwr(a,b/2);
  temp=(temp*temp);
  if(b&1)
    temp=(temp*a);
  return temp;
}
long long gcd(long long a,long long b)
{
  return b==0?a:gcd(b,a%b);
}
long long lcm(long long a,long long b)
{  
  return (a/gcd(a,b))*b;
}
long long modularInverse(long long a,long long m)
{
      return pwr(a,m-2,m);
}
bool* isPrime;
void generatePrimeSieve(const int lim)
{
  isPrime=(bool *)malloc(lim+1);
  memset(isPrime,true,lim+1);
  isPrime[0]=false;
  isPrime[1]=false;
  for(int i=2;i<=lim;++i)
    if(isPrime[i])
      for(int j=i+i;j<=lim;j+=i)
        isPrime[j]=false;
}
#define matrix vector<vector<int> >
matrix identityMatrix;
matrix mul(const matrix &a,const matrix &b)
{
  int n=a.size();
  matrix ans(n,vector<int> (n) );
  for (int i = 0; i < n; ++i)
  {
    for (int j = 0; j < n; ++j)
    {
      for (int k = 0; k < n; ++k)
      {
        ans[i][j]+= ((long long)a[i][k]*b[k][j])%mod;
        ans[i][j]%=mod;
      }
    }
  }
  return ans;
} 
matrix pwr(const matrix &a,long long n)
{
    if(n==0)
    {
      /*define identity */
      assert(false);
      return identityMatrix;
    }
    if(n==1)
     return a;
    matrix tmp=pwr(a,n/2);
    tmp=mul(tmp,tmp);
    if(n&1)
      tmp=mul(a,tmp);
    return tmp;
}
int main()
{
  std::ios::sync_with_stdio(false);
  
  
  int t;
  cin>>t;
  while(t--)
  {
  	unsigned int n;
  	cin>>n;
  	cout<<~n<<"\n";
  }




  
}
----------
====================
----------
ALGORITHMS.371
medium
----------
PROBLEM STATEMENT:
You are given [expression]. 

Find the permutation with the minimum possible score and print its score.

Note: [expression] is the exclusive-OR (XOR) operator.
----------
TOP SOLUTION:
----------
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

int main() {
	int n;
	while(~scanf("%d", &n)) {
		vector<int> a(n);
		for(int i = 0; i < n; ++ i)
			scanf("%d", &a[i]);
		int ans = 0;
		for(int b = 30; b >= 0; -- b) {
			int cnt = 0;
			rep(i, n)
				cnt += a[i] >> b & 1;
			if(cnt != 0 && cnt != n) {
				vi v, w;
				rep(i, n)
					(a[i] >> b & 1 ? v : w).push_back(a[i]);
				ans = 2147483647;
				for(int x : v) for(int y : w)
					amin(ans, x ^ y);
				break;
			}
		}
		printf("%d\n", ans);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.372
medium
----------
PROBLEM STATEMENT:
Sansa has an array. She wants to find the value obtained by XOR-ing the contiguous subarrays, followed by XOR-ing the values thus obtained. Determine this value.  

For example, if [expression]: 

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



Now we take the resultant values and XOR them together:

[expression]  

Function Description  

Complete the sansaXor function in the editor below.  It should return an integer that represents the results of the calculations.  

sansaXor has the following parameter(s):  


arr:  an array of integers  

----------
TOP SOLUTION:
----------
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <algorithm>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <limits>
#include <cstring>
#include <string>
using namespace std;

#define pairii pair<int, int>
#define llong long long
#define pb push_back
#define sortall(x) sort((x).begin(), (x).end())
#define INFI  numeric_limits<int>::max()
#define INFLL numeric_limits<llong>::max()
#define INFD  numeric_limits<double>::max()
#define FOR(i,s,n) for (int (i) = (s); (i) < (n); (i)++)
#define FORZ(i,n) FOR((i),0,(n))

void solve() {
  int n;
  scanf("%d",&n);
  int res = 0;
  FORZ(i,n) {
    int x;
    scanf("%d",&x);
    if ((i+1)%2 && (n-i)%2) {
      res ^= x;
    }
  }
  printf("%d\n",res);
}

int main() {
#ifdef DEBUG
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  int t;
  scanf("%d",&t);
  FORZ(i,t) solve();
  return 0;
}

----------
====================
----------
ALGORITHMS.373
medium
----------
PROBLEM STATEMENT:
Consider two non-negative long integers, [expression] is the bitwise AND operator. 

Given [expression].

For example, if [expression].  

Function Description  

Complete the andProduct in the editor below.  It should return the computed value as an integer.  

andProduct has the following parameter(s):  


a: an integer  
b: an integer  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
ll a, b, o = 1;

bool all(ll x, ll a, ll b) {
	return (a&x) && (b&x) && (b - a) < x;
}

int main() {
	int T; scanf("%d", &T); for(int ks = 1; ks <= T; ++ks) {
		scanf("%llu%llu", &a, &b);
		ll bb = 0;
		for(int i = 0; i < 63; ++i) {
			ll t = o << i;
			if(all(t, a, b)) bb |= t;
		}
		printf("%llu\n", bb);
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.374
medium
----------
PROBLEM STATEMENT:
The SuperBowl Lottery is about to commence, and there are several lottery tickets being sold, and each ticket is identified with a ticket ID. In one of the many winning scenarios in the Superbowl lottery, a winning pair of tickets is:


Concatenation of the two ticket IDs in the pair, in any order, contains each digit from [expression] at least once.


For example, if there are [expression] is a winning pair. 

NOTE: The ticket IDs can be concantenated in any order. Digits in the ticket ID can occur in any order. 

Your task is to find the number of winning pairs of distinct tickets, such that concatenation of their ticket IDs (in any order) makes for a winning scenario. Complete the function winningLotteryTicket which takes a string array of ticket IDs as input, and return the number of winning pairs. 
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
ALGORITHMS.375
hard
----------
PROBLEM STATEMENT:
An XOR operation on a list is defined here as the xor ([expression]). 

The [expression] can be expressed as:

[expression]     

For example: Given set [expression]


The set of possible non-empty subsets is: [expression]     
The [expression] of these non-empty subsets is then calculated as follows: 
[expression]


Given a list of [expression].    

For example, [expression].  

Note: The cardinality of powerset[expression] subsets.

Function Description  

Complete the xoringNinja function in the editor below.  It should return an integer that represents the XorSum of the input array, modulo [expression].  

xoringNinja has the following parameter(s):  


arr: an integer array

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <cstring>
#include <string>
#include <ctime>
#include <cassert>
#include <utility>

using namespace std;

#define MAXN 100005
#define MOD 1000000007

int T, N;
int A[MAXN];
long long dp[MAXN][2];

int main() {
//	freopen("date.in", "r", stdin);
	
	cin >> T;
	while(T--) {
        cin >> N;
        for(int i = 0; i < N; i++)
            cin >> A[i];
        
        long long ans = 0;
        for(int bit = 0; bit < 32; bit++) {
            memset(dp, 0, sizeof(dp)); 
            dp[0][0] = 1;
            dp[0][1] = 0;
            for(int i = 0; i < N; i++) {
                int crt = 0;
                if(A[i] & (1 << bit))
                    crt = 1;
                for(int j = 0; j < 2; j++) {
                    int nj = j ^ crt;
                    dp[i + 1][nj] += dp[i][j];
                    dp[i + 1][j] += dp[i][j];
                    dp[i + 1][nj] %= MOD;
                    dp[i + 1][j] %= MOD;
                }
            }
            long long cnt = dp[N][1];
            ans += cnt * (1LL << bit);
            ans %= MOD;
        }
        
        cout << ans << '\n';
	}
	
	return 0;
}

----------
====================
----------
ALGORITHMS.376
medium
----------
PROBLEM STATEMENT:
Jack and Daniel are friends.  They want to encrypt their conversations so that they can save themselves from interception by a detective agency so they invent a new cipher.  

Every message is encoded to its binary representation. Then it is written down [expression] bits. Each of the columns is XORed together to get the final encoded string.

If [expression] it looks like so:  

1001011     shift 0 
01001011    shift 1
001001011   shift 2
0001001011  shift 3
----------
1110101001  <- XORed/encoded string s


Now we have to decode the message.  We know that [expression] position of the original string.  Continue with that logic until the end.

Then the encoded message [expression] are sent to Daniel.   

Jack is using this encoding algorithm and asks Daniel to implement a decoding algorithm. 
Can you help Daniel implement this?  

Function Description  

Complete the cipher function in the editor below.  It should return the decoded string.  

cipher has the following parameter(s):  


k: an integer that represents the number of times the string is shifted 
s: an encoded string of binary digits

----------
TOP SOLUTION:
----------
// template by is_prime
#undef NDEBUG
#ifdef ssu1
#define _GLIBCXX_DEBUG
#endif

#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cassert>
#include <cstring>
#include <ctime>
#include <bitset>
#include <vector>
#include <unordered_map>
#include <cmath>
#include <algorithm>

using namespace std;

typedef unsigned int uint;
typedef unsigned long ulong;
typedef long long ll;
typedef unsigned long long ull;
typedef double dbl;
typedef string str;

#define endl '\n'
#define elif else if
#define gcd __gcd
#define lg __lg
#define ln log
#define bitcount __builtin_popcount
#define fabsl __builtin_fabsl
#define sqrtl __builtin_sqrtl
#define atan2l __builtin_atan2l
#define cosl __builtin_cosl
#define sinl __builtin_sinl
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define len(a) (a).size()
#define key first
#define val second
#define pb push_back
#define del remove
#define all(a) (a).begin(),(a).end()
#define iter(a,b) for (__typeof(b)a=0;a<(b);++a)
#define reti(a,b) for (__typeof(b)a=(b)-1;a>=0;--a)
#define foreach(a,b) for (auto&a:(b))

void init() {ios_base::sync_with_stdio(0);cin.tie(0);}

void algo() {
    /* solve problem */
    int n, k;
    str b;
    vector<bool> prob;
    bool temp;
    int j;

    cin >> n >> k;
    cin >> b;

    prob.reserve(n + k - 1);
    vector<bool> ans (k - 1, 0);

    foreach (i, b) {prob.pb(i == '0' ? 0 : 1);}
    b = "";

    ans.pb(prob[0]);
    cout << prob[0];
    for (int i = 1; i < n; ++i) {
        temp = prob[i]^prob[i-1]^ans[len(ans) - k];

        ans.pb(temp);
        cout << temp;
    }
    cout << endl;
}

int main(int agrc, char **argv) {
    init();
#ifdef ssu1
    assert(freopen(argv[1], "rt", stdin));
#endif

    algo();

#ifdef ssu1
    cerr << double(clock()) / CLOCKS_PER_SEC << 's' << endl;
#endif

    return 0;
}

----------
====================
----------
ALGORITHMS.377
hard
----------
PROBLEM STATEMENT:
Consider a zero-indexed matrix with [expression] columns, where each row is filled gradually. Given the first row of the matrix, you can generate the elements in the subsequent rows using the following formula:


[expression]
[expression]


Each row is generated one by one, from the second row through the last row. Given the first row of the matrix, find and print the elements of the last row as a single line of space-separated integers.

Note: The [expression] operator denotes bitwise XOR.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <ctype.h>
#include <deque>
#include <queue>
#include <cstring>
#include <set>
#include <list>
#include <map>
#include <random>
#include <unordered_map>
#include <stdio.h>

using namespace std;

typedef long long ll;
typedef std::vector<int> vi;
typedef std::vector<bool> vb;
typedef std::vector<string> vs;
typedef std::vector<double> vd;
typedef std::vector<long long> vll;
typedef std::vector<std::vector<int> > vvi;
typedef vector<vvi> vvvi;
typedef vector<vll> vvll;
typedef std::vector<std::pair<int, int> > vpi;
typedef vector<vpi> vvpi;
typedef std::pair<int, int> pi;
typedef std::pair<ll, ll> pll;
typedef std::vector<pll> vpll;

const long long mod = 1000000007;

#define all(c) (c).begin(),(c).end()
#define sz(c) (int)(c).size()
#define forn(i, a, b) for(int i = a; i < b; i++)

#define pb push_back
#define mp make_pair

int main()
{

    int n;
    ll m;
    scanf("%d %lld", &n, &m);
    m--;
    vi a(n);
    vll d2(1,1);
    forn(i,0,60) d2.pb(d2.back()*2);
    forn(i,0,n) scanf("%d", &a[i]);
    for(int bit = 60; bit>=0; bit--) {
        if(m>=d2[bit]) {
            vi b(n);
            forn(i,0,n) {
                
                b[i] = a[i]^a[((ll)i+d2[bit])%n];
                
            }
            a=std::move(b);
            m-=d2[bit];
        }
    }
    forn(i,0,n) printf("%d ", a[i]);
    
    
}



----------
====================
----------
ALGORITHMS.378
medium
----------
PROBLEM STATEMENT:
Johnny is playing with a large binary number, [expression].       

For example, suppose we have array [expression], as shown in this diagram:



When we assemble the sequential alternating sequences of [expression].

We define setCount([expression]).

Johnny isn't sure how to solve the problem. Given array [expression] as a single line of space-separated integers.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

int main()
{
  int T;
  scanf("%d", &T);
  for (int testcase = 0; testcase < T; testcase++)
  {
    int n;
    scanf("%d", &n);
    vector<long long> dat(n);
    for (int i = 0; i < n; i++) {
      scanf("%lld", &dat[i]);
    }
    vector<long long> ans;
    if (n == 1) {
      ans.push_back(1);
      ans.push_back(1);
      ans.push_back(dat[0] - 1);
    }
    else if (n == 2) {
      ans.push_back(1);
      ans.push_back(1 + dat[1]);
      ans.push_back(dat[0] - 1);
    }
    else if (n % 2 == 0) {
      for (int i = 0; i < n - 3; i++) {
        ans.push_back(dat[i]);
      }
      ans.push_back(dat[n - 3] - 1);
      ans.push_back(1);
      ans.push_back(1 + dat[n - 1]);
      ans.push_back(dat[n - 2] - 1);
    }
    else {
      for (int i = 0; i < n - 2; i++) {
        ans.push_back(dat[i]);
      }
      ans.push_back(dat[n - 2] - 1);
      ans.push_back(1);
      ans.push_back(1);
      ans.push_back(dat[n - 1] - 1);
    }
    for (;;)
    {
      vector<long long> res;
      for (int i = 0; i < ans.size(); i++)
      {
        long long v = ans[i];
        if (v == 0) {
          if (i + 1 < ans.size()) {
            res.back() += ans[i + 1];
            i++;
          }
          continue;
        }
        res.push_back(v);
      }
      if (res == ans)
        break;
      ans = res;
    }
    printf("%d\n", (int)ans.size());
    for (int i = 0; i < ans.size(); i++) {
      printf("%lld%c", ans[i], " \n"[i + 1 == ans.size()]);
    }
  }
  return 0;
}
----------
====================
----------
ALGORITHMS.379
hard
----------
PROBLEM STATEMENT:
Bob has received a binary string of length N transmitted by Alice. He knows that due to errors in transmission, up to K bits might have been corrupted (and hence flipped). However, he also knows that the string Alice had intended to transmit was not periodic. A string is not periodic if it cannot be represented as a smaller string concatenated some number of times. For example, "0001", "0110" are not periodic while "00000", "010101" are periodic strings.

Now he wonders how many possible strings could Alice have transmitted.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>

const int mod = 1000000007;

#define MAXN 1005

int T, N, K;
char b[ MAXN ];

int c[ MAXN ][ MAXN ];
int cnt[ MAXN ][ 2 ];
int dp[ MAXN ];
int p[ MAXN ];

int main( void )
{
  scanf( "%d", &T );

  for( int i = 0; i < MAXN; ++i ) {
    for( int j = 0; j < MAXN; ++j ) {
      if( j > i ) continue;
      if( i == 0 ) { c[i][j] = 1; continue; }
      c[i][j] = c[i-1][j] + c[i-1][j-1];
      if( c[i][j] > mod ) c[i][j] -= mod;
    }
  }

  while( T-- ) {
    scanf( "%d%d", &N, &K );
    scanf( "%s", b );

    for( int i = 1; i < N; ++i )
      p[i] = 0;

    int periodic = 0;

    for( int i = 1; i < N; ++i ) {
      if( N % i != 0 ) continue;

      for( int j = 0; j < i; ++j ) 
	cnt[j][0] = cnt[j][1] = 0;

      for( int j = 0; j < N; ++j )
	cnt[j%i][1-b[j]+'0']++;

      for( int j = 0; j <= K; ++j )
	dp[j] = 1;

      for( int j = 0; j < i; ++j ) {
	for( int k = K; k >= 0; --k ) {
	  dp[k] = ( !cnt[j][0] || !cnt[j][1] ) ? dp[k] : 0;
	  if( k >= cnt[j][0] && cnt[j][0] ) dp[k] += dp[k-cnt[j][0]];
	  if( k >= cnt[j][1] && cnt[j][1] ) dp[k] += dp[k-cnt[j][1]];
	  if( dp[k] > mod ) dp[k] -= mod;
	}
      }

      p[i] = dp[K];

      for( int j = 1; j < i; ++j ) {
	if( i % j == 0 ) p[i] = p[i] + mod - p[j];
	if( p[i] > mod ) p[i] -= mod;
      }

      periodic += p[i];
      if( periodic >= mod ) periodic -= mod;
    }

    int total = 0;

    for( int i = 0; i <= K; ++i ) {
      total += c[N][i];
      if( total >= mod ) total -= mod;
    }

    int Sol = total - periodic + mod;
    if( Sol >= mod ) Sol -= mod;

    printf( "%d\n", Sol );
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.380
medium
----------
PROBLEM STATEMENT:
Consider four numbers: [expression]. Here, the | symbol denotes the bitwise OR operation.

Given [expression] as small as possible. 

Notes: 


[expression] is given in decimal (base 10).
If the number of bits changed in [expression].

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;

#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define trav(a, x) for (auto& a : x)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
void PR(vi &v) { trav(x, v) cout << x << ' '; cout << endl; }

void unhex(char& c) {
	if (0 <= c && c < 10) c = (char)('0' + c);
	else c = (char)('A' + (c - 10));
}

void rehex(char& c) {
	if ('0' <= c && c <= '9') c = (char)(c - '0');
	else c = (char)(c - 'A' + 10);
}

string trim0(string& s) {
	trav(x, s) unhex(x);
	rep(i,0,sz(s)) {
		if (s[i] != '0') return s.substr(i);
	}
	return "0";
}

bool solve() {
	int K, N;
	string a, b, c;
	cin >> K;
	cin >> a >> b >> c;
	N = max(max(sz(a), sz(b)), sz(c));
	a = string(N-sz(a), '0') + a;
	b = string(N-sz(b), '0') + b;
	c = string(N-sz(c), '0') + c;
	trav(x, a) rehex(x);
	trav(x, b) rehex(x);
	trav(x, c) rehex(x);
	int bits[4] = {8,4,2,1};

	rep(i,0,N) trav(bi, bits) {
		if (!(c[i]&bi)) {
			if (a[i]&bi) {
				a[i] &= ~bi;
				--K;
			}
			if (b[i]&bi) {
				b[i] &= ~bi;
				--K;
			}
		}
		else {
			if (!((a[i]&bi) || (b[i]&bi))) {
				b[i] |= bi;
				--K;
			}
		}
	}

	if (K < 0) return false;

	rep(i,0,N) trav(bi, bits) {
		if (c[i]&bi) {
			if ((a[i]&bi) && (b[i]&bi) && K >= 1) {
				a[i] &= ~bi;
				K--;
			}
			else if ((a[i]&bi) && K >= 2) {
				a[i] &= ~bi;
				b[i] |= bi;
				K -= 2;
			}
		}
	}

	cout << trim0(a) << endl;
	cout << trim0(b) << endl;
	return true;
}

int main() {
	cin.sync_with_stdio(false);
	cin.exceptions(cin.failbit);
	int N;
	cin >> N;
	rep(i,0,N) {
		if (!solve()) cout << -1 << endl;
	}
}

----------
====================
----------
ALGORITHMS.381
hard
----------
PROBLEM STATEMENT:
Suppose that [expression] is a permutation of these numbers, we say B is K-Manipulative if and only if:

[expression] represents the XOR operator.

You are given [expression].

Input:

The first line is an integer [expression].  

Output: 
The largest possible [expression] if there is no solution.

Constraints:  


[expression] 
[expression] 

----------
TOP SOLUTION:
----------
#include <cstdio>
#include <iostream>
#include <cmath>
#include <sstream>
#include <vector>
#include <map>
#include <set>
#include <complex>
#include <algorithm>
#include <functional>
#include <fstream>
#include <numeric>
#include <string>
#include <valarray>
#define int long long

using namespace std;

typedef pair<int,int> Pair;

template<class t>
ostream & operator << (ostream & tout,const vector<t> &s){
  tout<<'[';
  for (int i=0;i<s.size();i++)
    if (i+1 == s.size())
      tout<<s[i];
    else
      tout<<s[i]<<',';
  tout<<']';
  return(tout);
}

template<class a,class b>
ostream & operator << (ostream & tout,const pair<a,b> &c){
  return(tout<<'('<<c.first<<','<<c.second<<')');
}

template<class T> struct __set__print{
  __set__print(ostream& out) : tout(out), count(0) {}
  void operator() (T x) { 
    if (count > 0)
      tout<<',';
    tout<<x;
    ++count; 
  }
  ostream& tout;
  int count;
};

template<class T>
ostream & operator << (ostream & tout,const set<T> &s){
  tout<<'{';
  for_each(s.begin(),s.end(),__set__print<T>(tout));
  return(tout<<'}');
}

template<class T,class Q> struct print_map{
  print_map(ostream& out) : tout(out), count(0) {}
  void operator() (const pair<T,Q> &x) { 
    if (count > 0)
      tout<<',';
    tout<<'('<<x.first<<" => "<<x.second<<')';
    ++count; 
  }
  ostream& tout;
  int count;
};

template<class T,class Q>
ostream & operator << (ostream & tout,map<T,Q> s){
  tout<<'{';
  for_each(s.begin(),s.end(),print_map<T,Q>(tout));
  return(tout<<'}');
}

template<class T>
string to_string(T s){
  stringstream tin;
  tin<<s;
  string res;
  getline(tin,res);
  return(res);
}


template<class T>
vector<T> to_vector(T *s,int n){
  vector<T> result;
  for (int i=0;i<n;i++)
    result.push_back(s[i]);
  return(result);
}

// *********************************** MY CODE ***************************

const int MAX_N = 100+20;

int n,num[MAX_N];


bool good(int k){
  map<int,int> mp;
  for (int i=1;i<=n;i++)
    mp[num[i]>>k]++;
  for (map<int,int> :: iterator i=mp.begin();i!=mp.end();i++)
    if (i->second*2 > n)
      return(false);
  return(true);
}

#undef int
int main(){
#define int long long
  ios_base::sync_with_stdio(false) ;

  cin>>n;
  for (int i=1;i<=n;i++)
    cin>>num[i];

  int biggest = 40;
  while (!good(biggest) && biggest >= 0)
    biggest--;
  cout<<biggest<<endl;
}
----------
====================
----------
ALGORITHMS.382
hard
----------
PROBLEM STATEMENT:
Alice and Bob are playing the game of Nim with [expression].

Since Bob already knows who will win (assuming optimal play), he decides to cheat by removing some stones in some piles before the game starts. However, to reduce the risk of suspicion, he must keep at least one pile unchanged. Your task is to count the number of ways Bob can remove the stones to force Alice into losing the game. Since the number can be very large, output the number of ways modulo [expression]. Assume that both players will try to optimize their strategy and try to win the game.
----------
TOP SOLUTION:
----------
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<complex>
#include<vector>
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<string>
#include<cstdlib>
#include<memory.h>
#include<ctime>

using namespace std;


typedef long double ld;

typedef long long ll;
typedef pair<int,int>	pii;
typedef pair<ld,ld>	pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
typedef pair<ll,ll> pl;

#define FOR(i,a,b)		for(int i=(a);i<(b);i++)
#define REP(i,n)		FOR(i,0,n)
#define SORT(v)			sort((v).begin(),(v).end())
#define UN(v)			SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b)			memset(a,b,sizeof a)
#define pb				push_back

const int mod = 1000000007;

int n;
int a[111],b[111];
void add(ll &x,ll v){
	x+=v;
	x%=mod;
}
ll r[111][2];

ll qp(ll c,ll st){
	ll r = 1;
	while(st){
		if(st&1)r*=c,r%=mod;
		c*=c,c%=mod;
		st>>=1;
	}
	return r;
}

int solve(){
	ll res = 0;
	for(int pos=30;pos>=0;pos--){
		vi v;
		REP(j,n)if(a[j]&(1<<pos))v.pb(j);

		CL(r,0);
		r[0][0] = 1;
		REP(j,n)REP(t,2)if(r[j][t]){
			ll val = r[j][t];
			if(a[j]&(1<<pos)){
				add(r[j+1][t], val * (1<<pos));
				add(r[j+1][t^1], val * (a[j] - (1<<pos) + 1));
			}else{
				add(r[j+1][t], val * (a[j]+1));
			}
		}
		//cout<<"start "<<pos<<" -> "<<res<<' '<<r[n][0]<<endl;
		res += r[n][0] * qp((1<<pos),mod-2);
		res %= mod;
		//cout<<"add "<<res<<endl;
		if(v.size()%2==0){
			ll t = 1;

			REP(j,n)if(a[j]&(1<<pos)) t=(t*(a[j]-(1<<pos)+1))%mod;//,cout<<"mult1 "<<a[j]-(1<<pos)+1<<endl;
			else t=(t*(a[j]+1))%mod;//,cout<<"mult2 "<<a[j]+1<<endl;
			//cout<<t<<endl;
			t *= qp((1<<pos),mod-2);
			t%=mod;
		//	cout<<pos<<' '<<t<<endl;

			res -= t;
			res %= mod;
			if(res<0) res += mod;
		}else return res;

		REP(j,n)if(a[j]&(1<<pos))a[j]^=(1<<pos);
	}
	res++;
	//cout<<"!"<<res<<endl;
	return res;
}

int main(){
#ifdef LocalHost
	freopen("input.txt","r",stdin);
	//freopen("output.txt","w",stdout);
#endif

	cin>>n;
	REP(i,n) cin>>a[i],b[i]=a[i];

	int res = solve();
	REP(i,n) a[i]=b[i]-1;
	res -= solve();
	if(res<0) res += mod;
	cout<<res<<endl;
	//stupid();
	//cout<<rr<<endl;
#ifdef LocalHost
//	printf("TIME: %.3lf\n",ld(clock())/CLOCKS_PER_SEC);
#endif
	return 0;
}

----------
====================
----------
ALGORITHMS.383
advanced
----------
PROBLEM STATEMENT:
Understanding [expression]'s would you write down in all?  

For example, using an [expression].  The two's complement representations for a few numbers are shown below:  

        |Number|                Representation in
Number   Binary     Inverse     Two's Complement
-3      00000011    11111100    11111101
-2      00000010    11111101    11111110
-1      00000001    11111110    11111111
 0      00000000                00000000
 1      00000001                00000001
 2      00000010                00000010
 3      00000011                00000011


To write down that range of numbers' two's complements in [expression] bit representation was chosen to reduce apparent complexity in the example.  

Function Description  

Complete the twosCompliment function in the editor below.  It should return an integer.  

twosCompliment has the following parameter(s): 
- a: an integer, the range minimum 
- b: an integer, the range maximum  
----------
TOP SOLUTION:
----------
// C++

/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>

using namespace std;

long long c(long long A)
{
  int ret = 0;
  for (int i = 0; i < 32; i++) {
    ret += (A & (1<<i)) > 0;
  }
  return (long long)ret;
}

int high(long long A)
{
  int i;
  for (i = 32; i >= 0; i--) {
    if((A & (1LL<<i)) != 0)
      return i;
  }
  return 0;
}

long long res(long long A)
{
  assert(A >= 0LL);
  if(A == 0LL) return 0LL;

 // if(A > 1000000LL)
 //   printf("%lld: %d\n", A, high(A));
  fflush(stdout);
  long long h = high(A);

  long long ret;
  if(A == (long long)(1LL << (h + 1LL)) - 1LL)
  {
    ret = 2LL * res(A >> 1LL) + ((A + 1LL) >> 1LL);
  } else {
    long long mask = (1LL<<h);
    ret = res((1LL << h)- 1LL) + res(A ^ mask) + (A - (1LL << h) + 1LL);
  }
  return ret;
}

long long comp2(int a)
{
  long long ret = 0;
  //cout << "------" << endl << a << endl;
  for(int i = 0;i < 32; i++)
  {
    if( (a & (1 << i)) != 0)
    {
    //  cout << "1";
      ret += (1LL << i);
    } else {
     // cout << "0";
    }
  }
 // cout << endl << "--------" << endl;
  return ret;
}

int main()
{
  int sA,sB;
  long long A, B;
  int N;
  scanf("%d", &N);
  while(N--)
  {
    scanf("%d%d", &sA, &sB);
    A = comp2(sA);
    B = comp2(sB);

    long long ret;
    if(A == 0) {
      ret = res(B);
    } else if(sB < 0) {
      ret = res(B) - res(A) + c(A);
    } else if(sA < 0) {
      ret = res(comp2(-1)) - res(A) + c(A) + res(B);
    } else {
      ret = res(B) - res(A) + c(A);
    }

    printf("%lld\n", ret);
    //cout << endl;
    //cout << ret << endl;
  }

  return 0;
}
----------
====================
----------
ALGORITHMS.384
advanced
----------
PROBLEM STATEMENT:
Let a and b be binary numbers of length n (MSB to the left). The following commands may be performed:


set_a idx x: Set [expression].  
set_b idx x: Set [expression].  
get_c idx: Print [expression].  


Given [expression].  Print an answer string that contains the results of all commands on one line.  A series of commands and their results follow:


Starting 
ans = '' (empty string) 
a   b 
000 111 
set_a 1 1 
010 111 
set_b 0 1 
010 111 
get_c 3 
a + b = 1001 
ans = '1' 
010 111 
get_c 4 
a + b = 01001 
ans = '10' 


Note: When the command is get_c 4, [expression] to be long enough to return a value.  

Function Description  

Complete the changeBits function in the editor below.  For each get_c command, it should print either a 0 or a 1 without a newline until all commands have been processed. At that point, add a newline.   

changeBits has the following parameters: 
- a, b: two integers represented as binary strings 
- queries[queries[0]-queries[n-1]]: an array of query strings in the format described  
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

const int maxn = 100010;
int a[maxn], b[maxn], c[maxn];
int n, q;
char ss[maxn*5];
int l[maxn*2], r[maxn*2], s[maxn*2], tn;

int build(int ll, int rr)
{
	if(ll>=rr)
		return -1;
	int ret = tn++;
	if(ll + 1 == rr)
	{
		l[ret] = r[ret] = -1;
		s[ret] = c[ll];
		return ret;
	}
	int mid = (ll + rr) / 2;
	l[ret] = build(ll, mid);
	r[ret] = build(mid, rr);
	s[ret] = (s[l[ret]] == s[r[ret]] ? s[l[ret]] : 2);
	return ret;
}

void init() {
	scanf("%d%d", &n, &q);
	//printf("%d %d\n", n, q);
	memset(c, 0, sizeof(c));
	scanf("%s", ss);
	//printf("%s\n", ss);
	for(int i=0; i<n; ++i) {
		a[i] = c[i] = ss[n - i - 1] - '0';
	}
	scanf("%s", ss);
	//printf("%s\n", ss);
	for(int i=0; i<n; ++i) {
		b[i] = ss[n - 1 - i] - '0';
		c[i] += ss[n - 1 - i] - '0';
		if(c[i] >= 2)
		{
			c[i] -= 2;
			c[i+1] ++;
		}
	}
	a[n] = b[n] = 0;
	//memset(a, 0, sizeof(a));
	//memset(b, 0, sizeof(b));
	//memset(c, 0, sizeof(c));
	n++;
	tn = 0;
	build(0, n);
}

void push_down(int id) {
	if(s[id] == 2)
		return;
	if(l[id] < 0)
		return;
	s[l[id]] = s[r[id]] = s[id];
}

int findright(int id, int ll, int rr, int i, int bit)
{
	if(rr <= i)
		return -1;
	if(s[id] == bit)
		return i < ll ? ll : i;
	if(s[id] == (bit ^ 1))
		return -1;
	push_down(id);
	int mid = (ll + rr) / 2;
	int t = findright(l[id], ll, mid, i, bit);
	if(t >= 0)
		return t;
	return findright(r[id], mid, rr, i, bit);
}

void change(int id, int ll, int rr, int bl, int br, int bit)
{
	if(br <= ll || rr <= bl)
		return;
	if(bl <= ll && rr <= br)
	{
		s[id] = bit;
		return;
	}
	push_down(id);
	int mid = (ll + rr) / 2;
	change(l[id], ll, mid, bl, br, bit);
	change(r[id], mid, rr, bl, br, bit);
	if(s[l[id]] == s[r[id]])
		s[id] = s[l[id]];
	else
		s[id] = 2;
}

int getbit(int id, int ll, int rr, int i)
{
	if(i<ll || i>=rr)
		return 0;
	if(s[id] < 2)
		return s[id];
	int mid = (ll + rr) / 2;
	if(i < mid)
		return getbit(l[id], ll, mid, i);
	else
		return getbit(r[id], mid, rr, i);
}

void work() {
	int i, bit;
	int pn = 0;
	char cmd[10];
	while(q--) {
		scanf("%s", cmd);
		//printf("%s ", cmd);
		if(cmd[4]=='a' || cmd[4] == 'b')
		{
			scanf("%d%d", &i, &bit);
			//printf("%d %d\n", i, bit);
			if(cmd[4] == 'a' && a[i] == bit)
				continue;
			if(cmd[4] == 'b' && b[i] == bit)
				continue;
			if(cmd[4] == 'a') a[i] = bit;
			else b[i] = bit;
			int lmb = findright(0, 0, n, i, bit ^ 1);
			if(lmb == -1)
				lmb = n;
			change(0, 0, n, i, lmb, bit ^ 1);
			change(0, 0, n, lmb, lmb + 1, bit);
		}
		else
		{
			scanf("%d", &i);
			//printf("%d\n", i);
			ss[pn++] = getbit(0, 0, n, i) + '0';
			//printf("%c\n", ss[pn-1]);
		}
	}
	ss[pn] = 0;
	printf("%s\n", ss);
}

int main() {
	init();
	work();
}

----------
====================
----------
ALGORITHMS.385
advanced
----------
PROBLEM STATEMENT:
Xorq has invented an encryption algorithm which uses bitwise XOR operations extensively. This encryption algorithm uses a sequence of non-negative integers [expression]. Help Xorq implement this function.  

For example, [expression] inclusive:

j   x[j]    x[j]^4
1   3       7
2   5       1
3   9       13


Our maximum value is [expression].

Function Description

Complete the xorKey function in the editor below.  It should return an integer array where each value is the response to a query.

xorKey has the following parameters:  


x: a list of integers  
queries: a two dimensional array where each element is an integer array that consists of [expression] respectively.  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <cstdio>
#include <cstring>
#include <cassert>
#include <algorithm>
#include <ctime>
using namespace std;

const int MB = 14;
const int N = 100000;
int arr[N], t, n, q, a, b, c;

int sorted_arrs[N * (MB + 2)];
struct XorqNode {
    int child[2], idx, len;
} nodes[512 + N * (MB - 6)]; // 
int arr_cnt, node_cnt;

int split(int idx, int len, int bm, int r) {
    int cnt = 0;
    for(int i = 0; i < len; i ++) {
        if((bm & arr[sorted_arrs[i + idx]]) == r) {
            sorted_arrs[arr_cnt++] = sorted_arrs[i + idx];
            cnt ++;
        }
    }
    return cnt;
}

void build(int root, int idx, int len, int bit = MB) {
    nodes[root].idx = idx;
    nodes[root].len = len;
    if(bit == -1) return;
    int bm = (1 << bit);
    int sidx1 = arr_cnt;
    int left_cnt = split(idx, len, bm, 0);
    int sidx2 = arr_cnt;
    int right_cnt = split(idx, len, bm, bm);
    assert(left_cnt + right_cnt == len);
    if(left_cnt) {
        nodes[root].child[0] = node_cnt;
        build(node_cnt ++, sidx1, left_cnt, bit - 1);
    } else {
        nodes[root].child[0] = -1;
    }
    if(right_cnt) {
        nodes[root].child[1] = node_cnt;
        build(node_cnt ++, sidx2, right_cnt, bit - 1);
    } else {
        nodes[root].child[1] = -1;
    }
}

bool search(int root, int from, int to) {
    int left = nodes[root].idx;
    int right = left + nodes[root].len - 1;
    int r = N;
    while(left <= right) {
        int mid = (left + right) / 2;
        int val = sorted_arrs[mid];
        if(val >= from) {
            r = val;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return r <= to;
}

int query(int root, int n, int from, int to, int bit = MB) {
    if(bit == -1) return 0;
    int mybit = ((1 << bit) & n) ? 1 : 0;
    if(nodes[root].child[1 - mybit] != -1 && search(nodes[root].child[1 - mybit], from, to)) {
        return query(nodes[root].child[1 - mybit], n, from, to, bit - 1) + (1 << bit);
    } else {

        return query(nodes[root].child[mybit], n, from, to, bit - 1);
    }
}

int query2(int n, int from, int to) {
    int r = 0;
    for(int i = from; i <= to; i ++) {
        r = max(r, arr[i] ^ n);
    }
    return r;
}

int main() {
    int cl = clock();
    int err_cnt = 0;
    for(scanf("%d", &t); t--; ) {
        arr_cnt = node_cnt = 0;
        scanf("%d %d", &n, &q);
        for(int i = 0; i < n; i ++) {
            scanf("%d", &arr[i]);
        }
        for(int i = 0; i < n; i ++) {
            sorted_arrs[arr_cnt++] = i;
        }
        node_cnt = 1;
        build(0, 0, n);
        for(int i = 0; i < q; i ++) {
            scanf("%d %d %d", &a, &b, &c);
            int r1 = query(0, a, b - 1, c - 1);
            cout << r1 << endl;
        }
    }
    //cerr << (clock() - cl) * 0.001 << endl;
    return 0;
}

----------
====================
----------
ALGORITHMS.386
hard
----------
PROBLEM STATEMENT:
Consider an array of [expression].

Let [expression]:
[expression]

Given array [expression]. 

Note: Each query is independent and considered separately from all other queries, so changes made in one query have no effect on the other queries. 
----------
TOP SOLUTION:
----------
#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }

int main() {
	int n; int q;
	while(~scanf("%d%d", &n, &q)) {
		vector<int> a(n);
		for(int i = 0; i < n; ++ i)
			scanf("%d", &a[i]);
		vector<int> sum(n + 1);
		rep(i, n) sum[i + 1] = sum[i] ^ a[i];
		vector<int> sum2(n + 2);
		rep(i, n + 1) sum2[i + 1] = sum2[i] + sum[i];
		rep(ii, q) {
			int x; int y; int k;
			scanf("%d%d%d", &x, &y, &k), ++ y;
			int cnt0 = sum2[y + 1] - sum2[x];
			int cnt1 = (y + 1 - x) - cnt0;
			if(cnt0 > cnt1) swap(cnt0, cnt1);
			ll ans = k == 0 ? (ll)cnt0 * cnt1 :
				(ll)((y + 1 - x) / 2) * ((y + 1 - x + 1) / 2);
			printf("%lld\n", ans);
		}
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.387
advanced
----------
PROBLEM STATEMENT:
Consider an array, [expression]). 
We take all consecutive subsequences of integers from the array that satisfy the following:
[expression] 

For example, if [expression] our subsequences will be:


[expression]
[expression]    
[expression]    
[expression]
[expression]
[expression] 


For each subsequence, we apply the bitwise XOR ([expression] numbers.   

Given array [expression] and determine the frequency at which each number occurs. Then print the number and its respective frequency as two space-separated values on a single line.  
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <string>

using namespace std;

const int MAXN = 100005, MAX = (1 << 16);

int mem[MAXN], N, sum[MAXN];
long long total[1 << 16];

inline void walk(int digits) {
	int n = (1 << digits);
	for(int i = 1 ; i <= digits ; i++) {
		int m = (1 << i);
		int mh = m >> 1;
		for(int r = 0 ; r < n ; r += m) {
			int t1 = r;
			int t2 = r + mh;
			for(int j = 0 ; j < mh ; j++, t1++, t2++) {
				long long u = total[t1];
				long long v = total[t2];
				total[t1] = u + v;
				total[t2] = u - v;
			}
		}
	}
}

int main() {
	scanf("%d", &N);
	for(int i = 1 ; i <= N ; i++) {
		scanf("%d", &mem[i]);
		sum[i] = sum[i - 1] ^ mem[i];
	}

	for(int i = 0 ; i <= N ; i++) {
		total[sum[i]]++;
	}

	walk(16);
	for(int i = 0 ; i < MAX ; i++) {
		total[i] = total[i] * total[i];
	}
	walk(16);
	for(int i = 0 ; i < MAX ; i++) {
		total[i] /= MAX;
	}
	total[0] -= (N + 1);
	for(int i = 0 ; i < MAX ; i++) {
		total[i] /= 2.0;
	}

	int ans = 0;
	long long best = 0;
	for(int i = 0 ; i < MAX ; i++) {
		if (total[i] > best) {
			best = total[i];
			ans = i;
		}
	}
	printf("%d %lld\n", ans, best);
	return 0;
}

----------
====================
----------
ALGORITHMS.388
expert
----------
PROBLEM STATEMENT:
Consider the following pseudocode, run on an array [expression]:

[expression]
[expression]
    [expression]
    [expression]
        [expression]
    [expression]
    [expression]



Given the values of [expression] after the pseudocode above terminates; if the loop will never terminate, print -1 instead.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <cstdio>
#include <string.h>
#include <algorithm>
#include <vector>
#include <string>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <sstream>
#include <cmath>
#include <ctime>
#include <bitset>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<string> vs;
typedef vector< vector<int> > vvi;
typedef vector<ll> vl;
typedef vector< vector<ll> > vvl;

#define forn(i, n) for (int i = 0; i < (int)(n); i++)
#define forv(i, v) forn(i, v.size())
#define all(v) v.begin(), v.end()
#define mp make_pair
#define pb push_back

const int N = 50005;

typedef bitset<N> mask;

int gcd(int x, int y) {
    if (!y) return x;
    return gcd(y, x % y);
}

int main() {
#ifdef NEREVAR_PROJECT
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    int n; cin >> n;
    vi a(n);
    forn(i, n) {
        scanf("%d", &a[i]);
    }
    sort(all(a));
    a.erase(unique(all(a)), a.end());
    n = (int)a.size();
    mask diffs;
    mask present;
    for (int i = n - 1; i >= 0; i--) {
        diffs |= present >> a[i];
        present.set(a[i]);
    }
    vi s;
    forn(i, N) {
        if (diffs.test(i)) {
            s.pb(i);
        }
    }
    if (s.empty()) {
        cout << 1 << endl;
        return 0;
    }
    int g = 0;
    forv(i, s) g = gcd(g, s[i]);
    forv(i, s) s[i] /= g;
    
    diffs.reset();
    present.reset();
    for (int i = (int)s.size() - 1; i >= 0; i--) {
        diffs |= present >> (s[i] + 1);
        present.set(s[i]);
    }
    
    int steps = 2, m = s.back() - s[0];
    while (m && !diffs.test(0)) {
        mask next;
        int mNext = m;
        forn(i, m) {
            if (diffs.test(i)) {
                if (mNext == m) {
                    mNext = m - i - 1;
                }
                next |= diffs >> (i + 1);
            }
        }
        m = mNext;
        steps++;
        diffs = next;
    }
    
    cout << steps + m << endl;
    
    return 0;
}

----------
====================
----------
ALGORITHMS.389
expert
----------
PROBLEM STATEMENT:
You are given a string [expression] queries to process. The queries are as follows:


C [expression];  
S [expression];   
R [expression] one;  
W [expression] one;  
H [expression].  


Everything is 1-indexed here.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I < (N); ++I)
#define REPP(I, A, B) for (int I = (A); I < (B); ++I)
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define RS(X) scanf("%s", (X))
#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
typedef long long LL;
using namespace std;
const int LEN = 20;
const int BOUND = 1<<LEN;
int rev[BOUND],bit_cnt[BOUND];
int ONES;
void init(){
    REP(i,LEN)ONES|=1<<i;
    REP(i,BOUND){
        bit_cnt[i]=bit_cnt[i>>1]+(i&1);
        int tmp=i;
        REP(j,LEN){
            rev[i]<<=1;
            rev[i]|=tmp&1;
            tmp>>=1;
        }
    }
}
int a[50010];
char s[50010];
int tmp1[50010],tmp2[50010],tmp3[50010];
void get(int tmp[],int st,int len){
    if(!len){
        tmp[0]=0;
        return;
    }
    int w=len/LEN;
    int r=st%LEN;
    int x=st/LEN;
    int mask1=(1<<r)-1;
    int mask2=(1<<LEN)-1-mask1;
    REP(i,w){
        tmp[i]=((a[x+i]&mask2)>>r)|((a[x+i+1]&mask1)<<(LEN-r));
    }

    r=len-LEN*w;
    tmp[w]=0;
    REP(i,r){
        if((a[(st+w*LEN+i)/LEN]>>((st+w*LEN+i)%LEN))&1)
            tmp[w]|=1<<i;
    }
}
void put(int tmp[],int st,int len){
    if(!len)return;
    int w=len/LEN;
    int r=st%LEN;
    int x=st/LEN;
    int mask1=(1<<r)-1;
    int mask2=(1<<LEN)-1-mask1;

    int mask3=(1<<(LEN-r))-1;
    int mask4=(1<<LEN)-1-mask3;
    REP(i,w){
        a[x+i]&=mask1;
        a[x+i]|=(tmp[i]&mask3)<<r;
        a[x+i+1]&=mask2;
        a[x+i+1]|=(tmp[i]&mask4)>>(LEN-r);
    }

    r=len-LEN*w;
    int xx=(st+w*LEN)/LEN;
    int yy=(st+w*LEN)%LEN;
    REP(i,r){
        if(((tmp[w]>>i)&1) != ((a[xx]>>yy)&1))
            a[xx]^=1<<yy;
        yy++;
        if(yy==LEN){
            xx++;
            yy=0;
        }
    }
}
int main(){
    init();
    DRII(N,M);
    RS(s);
    int sn=LEN(s);
    {
        int x=0,y=0;
        REP(i,sn){
            if(s[i]=='b')a[x]|=1<<y;
            y++;
            if(y==LEN){
                x++;
                y=0;
            }
        }
    }
    DRI(Q);
    while(Q--){
        //REP(i,5)printf("%d",a[i]);
        //puts("");
        char c[4];
        RS(c);
        if(c[0]=='C'){
            DRII(ll,rr);
            ll--;rr--;
            int st=(ll+LEN-1)/LEN,ed=(rr+1)/LEN;
            RS(c);
            int len=(rr-ll+LEN)/LEN;
            if(c[0]=='a'){
                REP(i,len)tmp1[i]=0;
            }
            else{
                REP(i,len)tmp1[i]=ONES;
            }
            put(tmp1,ll,rr-ll+1);
        }
        else if(c[0]=='S'){
            DRII(ll1,rr1);
            DRII(ll2,rr2);
            ll1--;rr1--;ll2--;rr2--;
            get(tmp1,ll1,rr1-ll1+1);
            get(tmp2,rr1+1,ll2-1-rr1);
            get(tmp3,ll2,rr2-ll2+1);
           // printf("[[%d%d]]\n",tmp1[0],tmp1[1]);
            //printf("[[%d]]\n",tmp3[0]);
            put(tmp3,ll1,rr2-ll2+1);
            put(tmp2,ll1+rr2-ll2+1,ll2-1-rr1);
            put(tmp1,ll1+rr2-rr1,rr1-ll1+1);
        }
        else if(c[0]=='R'){
            DRII(ll,rr);
            ll--;rr--;
            int len=rr-ll+1;
            get(tmp1,ll,len);
            //REP(i,5)printf("[%d]",tmp1[i]);
            if(len%LEN==0){
                int w=len/LEN;
                REP(i,w)tmp2[i]=rev[tmp1[w-i-1]];
            }
            else{
                int w=len/LEN;
                int r=len%LEN;
                int mask1=(1<<r)-1;
                int mask2=(1<<LEN)-1-mask1;
                REP(i,w)tmp2[i]=rev[((tmp1[w-i]&mask1)<<(LEN-r))|((tmp1[w-i-1]&mask2)>>r)];
                tmp2[w]=0;
                REP(i,r)
                    if((tmp1[0]>>(r-i-1))&1)tmp2[w]|=1<<i;
            }
            put(tmp2,ll,len);
        }
        else if(c[0]=='W'){
            DRII(ll,rr);
            ll--;
            int x=ll/LEN;
            int y=ll%LEN;
            REPP(i,ll,rr){
                int now=(a[x]>>y)&1;
                if(now)putchar('b');
                else putchar('a');
                y++;
                if(y==LEN){
                    x++;
                    y=0;
                }
            }
            puts("");
        }
        else if(c[0]=='H'){
            DRIII(st1,st2,len);
            st1--;st2--;
            get(tmp1,st1,len);
            get(tmp2,st2,len);
            len=(len+LEN-1)/LEN;
            int an=0;
            REP(i,len)an+=bit_cnt[tmp1[i]^tmp2[i]];
            printf("%d\n",an);
        }
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.390
hard
----------
PROBLEM STATEMENT:
Some scientists are working on protein recombination, and during their research, they have found a remarkable fact: there are 4 proteins in the protein ring that mutate after every second according to a fixed pattern. For simplicity, proteins are called [expression] (you know, protein names can be very complicated). A protein mutates into another one depending on itself and the protein right after it. Scientists determined that the mutation table goes like this:  

    A   B   C   D
    _   _   _   _
A|  A   B   C   D
B|  B   A   D   C
C|  C   D   A   B
D|  D   C   B   A


Here rows denote the protein at current position, while columns denote the protein at the next position. And the corresponding value in the table denotes the new protein that will emerge. So for example, if protein i is A, and protein i + 1 is B, protein i will change to B. All mutations take place simultaneously. The protein ring is seen as a circular list, so last protein of the list mutates depending on the first protein. 

Using this data, they have written a small simulation software to get mutations second by second. The problem is that the protein rings can be very long (up to 1 million proteins in a single ring) and they want to know the state of the ring after upto [expression] seconds. Thus their software takes too long to report the  results. They ask you for your help.  
----------
TOP SOLUTION:
----------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
#include <vector>

using namespace std;

#define NMAX 1111111

char ch;
int A[2][NMAX];
int N, K, i, b, p, c, step;

int main() {
//	freopen("x.txt", "r", stdin);
	scanf("%d %d", &N, &K);
	for (i = 0; i < N; i++) {
		scanf(" %c", &ch);
		A[0][i] = ch - 'A';
	}

	for (c = 0, b = 30; b >= 0; b--)
		if (K & (1 << b)) {
			p = c;
			c = 1 - c;
			step = (1 << b) % N;
			for (i = 0; i < N; i++)
				A[c][i] = A[p][i] ^ A[p][(i + step) % N];
		}

	for (i = 0; i < N; i++)
		printf("%c", A[c][i] + 'A');
	printf("\n");
	return 0;
}

----------
====================
----------
ALGORITHMS.391
medium
----------
PROBLEM STATEMENT:
Find the number of ways that a given integer, [expression] powers of unique, natural numbers. 

For example, if [expression].  

Function Description

Complete the powerSum function in the editor below.  It should return an integer that represents the number of possible combinations.  

powerSum has the following parameter(s):  


X: the integer to sum to  
N: the integer power to raise numbers to  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>

using namespace std;

int power (int a, int n) {
    if(n == 0)
        return 1;
    // else
    if(n % 2 == 0) {
        int temp = power(a, n / 2);
        return temp * temp;
    }
    // else
    return a * power(a, n - 1);
}

int solve(int x, const vector<int> &powers, int index) {
    if(index == 0) {
        return (x == 1) ? 1 : 0;
    }
    // else
    if(x == powers[index])
        return 1 + solve(x, powers, index - 1);
    // else
    int res = 0;
    res += solve(x - powers[index], powers, index - 1);
    res += solve(x, powers, index - 1);
    return res;
}


int main() {
    int x, n;
    cin >> x >> n;
    
    int pow = 1;
    vector<int> powers;
    for(int a = 2; pow <= x; a++) {
        powers.push_back(pow);
        pow = power(a, n);
    }
    
    cout << solve(x, powers, powers.size() - 1) << endl;        
    return 0;
}

----------
====================
----------
ALGORITHMS.392
medium
----------
PROBLEM STATEMENT:
A [expression] Crossword grid is provided to you, along with a set of words (or names of places) which need to be filled into the grid.  Cells are marked either + or -.  Cells marked with a - are to be filled with the word list.  

The following shows an example crossword from the input [expression]:

[expression]

[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]
[expression]



Function Description

Complete the crosswordPuzzle function in the editor below.  It should return an array of strings, each representing a row of the finished puzzle.

crosswordPuzzle has the following parameter(s):  


crossword: an array of [expression] representing the empty grid  
words: a string consisting of semicolon delimited strings to fit into [expression]  

----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <sstream>
#include <algorithm>
using namespace std; 

const int GRID_SIZE = 10; 

typedef struct {
	int x; 
	int y; 
	bool isHoriz; 
	int len; 
} placement; 
bool sortLongestFirst(const placement& left, const placement& right){
	if (left.len != right.len) return left.len > right.len; 
	if (left.x != right.x) return left.x < right.x; 
	return left.y < right.y; 
}

bool longfirst(const string& left, const string& right){
	return left.length() > right.length(); 
}

bool solve(const vector<vector<char> >& grid, 
	const vector<placement>& spots, 
	const vector<string>& words){

	if (words.empty() && spots.empty()){
		for(int i=0; i<GRID_SIZE; i++){
			for(int j=0; j<GRID_SIZE; j++){
				cout << grid[i][j]; 
			}
			cout << endl; 
		}
		return true; 
	}
	if (words.empty() || spots.empty()) return false; 
	if (words[0].length() != spots[0].len) return false; 
	vector<placement> spots2(spots.begin()+1, spots.end()); 
	vector<string> words2; 
	for(int i=0; i<words.size(); i++){
		const string& w = words[i]; 
		vector<vector<char> > g2 = grid; 
		int x = spots[0].x; 
		int y = spots[0].y; 
		bool valid = true; 
		for(int l = 0; l<spots[0].len; l++){
			if (g2[x][y]=='-' || g2[x][y]==w[l]){
				g2[x][y] = w[l]; 
			} else {
				valid = false; 
				break; 
			}
			if (spots[0].isHoriz) y++; 
			else x++; 
		}
		if (!valid) continue; 

		words2.clear(); 
		for(int i2=0; i2<i; i2++)              words2.push_back(words[i2]); 
		for(int i2=i+1; i2<words.size(); i2++) words2.push_back(words[i2]); 
		if (solve(g2, spots2, words2)) return true; 
	}
	return false; 
}

int main(void){
	vector<vector<char> > grid(GRID_SIZE, vector<char>(GRID_SIZE)); 
	for(int i=0; i<GRID_SIZE; i++){
		string line; 
		cin >> line; 
		for(int j=0; j<GRID_SIZE; j++){
			grid[i][j] = line[j]; 
		}
	}
	string wordline; 
	cin >> wordline; 
	vector<string> words; 
	wordline+=";"; 
	istringstream iss(wordline); 
	string item; 
	while(getline(iss, item, ';')) words.push_back(item); 

	vector<placement> spots; 
	placement empty_spot; 
	for(int i=0; i<GRID_SIZE; i++){
		int gap_start = -1; 
		int gap_len = -1; 
		for(int j=0; j<GRID_SIZE; j++){
			if (grid[i][j]=='-'){
				if (gap_start>=0) gap_len++; 
				else {
					gap_start = j; 
					gap_len = 1; 
				}
			} else {
				if (gap_len>1){
					empty_spot.x = i; 
					empty_spot.y = gap_start; 
					empty_spot.isHoriz = true; 
					empty_spot.len = gap_len; 
					spots.push_back(empty_spot); 
				}
				gap_start = -1; 
				gap_len = -1; 
			}
		}
		if (gap_len>1){
			empty_spot.x = i; 
			empty_spot.y = gap_start; 
			empty_spot.isHoriz = true; 
			empty_spot.len = gap_len; 
			spots.push_back(empty_spot); 
		}
	}
	for(int j=0; j<GRID_SIZE; j++){
		int gap_start = -1; 
		int gap_len = -1; 
		for(int i=0; i<GRID_SIZE; i++){
			if (grid[i][j]=='-'){
				if (gap_start>=0) gap_len++; 
				else {
					gap_start = i; 
					gap_len = 1; 
				}
			} else {
				if (gap_len>1){
					empty_spot.x = gap_start; 
					empty_spot.y = j; 
					empty_spot.isHoriz = false; 
					empty_spot.len = gap_len; 
					spots.push_back(empty_spot); 
				}
				gap_start = -1; 
				gap_len = -1; 
			}
		}
		if (gap_len>1){
			empty_spot.x = gap_start; 
			empty_spot.y = j; 
			empty_spot.isHoriz = false; 
			empty_spot.len = gap_len; 
			spots.push_back(empty_spot); 
		}
	}
	sort(spots.begin(), spots.end(), sortLongestFirst); 
	sort(words.begin(), words.end(), longfirst); 
	solve(grid, spots, words); 
	return 0; 
}

----------
====================
----------
ALGORITHMS.393
medium
----------
PROBLEM STATEMENT:
We define super digit of an integer [expression] using the following rules:  

Given an integer, we need to find the super digit of the integer.


If [expression].   
Otherwise, the super digit of [expression].  


For example, the super digit of [expression] will be calculated as:

[expression] 
	[expression]
	[expression]
	[expression]  



You are given two numbers [expression] (spaces added for clarity).

[expression]
                  [expression]
    [expression]
                  [expression]
    [expression]



All of the digits of [expression] is only one digit, so it's the super digit.

Function Description

Complete the function superDigit in the editor below.  It must return the calculated super digit as an integer.  

superDigit has the following parameter(s):  


n: a string representation of an integer  
k: an integer, the times to concatenate [expression]  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
int k=0,flag=1;
int sum(string s){
   int64_t a=0,b;
    for(int i=0;i<s.size();i++){
        b=s[i]-48;
        a+=b;
    }
    return a;
}
void super(int64_t a){
    if(a/10==0)
        {
        if(flag){
            flag=0;
        super(a*k);
            }
        else
            cout<<a;
     }
    else{
      int64_t val=0;
        while(a){
            val+=a%10;
            a=a/10;
        }
        super(val);
     }
}

int main() {
    string s;
    int64_t a;
    cin>>s>>k;
    a=sum(s);
    super(a);
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
ALGORITHMS.394
medium
----------
PROBLEM STATEMENT:
Chess is a very popular game played by hundreds of millions of people. Nowadays, we have chess engines such as Stockfish and Komodo to help us analyze games. These engines are very powerful pieces of well-developed software that use intelligent ideas and algorithms to analyze positions and sequences of moves, as well as find tactical ideas. Consider the following simplified version of chess:


Board: It's played on a [expression] board between two players named Black and White. 
Pieces and Movement: 
White initially has [expression] pieces. 
There are no Kings and no Pawns on the board. Each player has exactly one Queen, at most two Rooks, and at most two minor pieces (i.e., a Bishop and/or Knight). 
Each piece's possible moves are the same as in classical chess, and each move made by any player counts as a single move.
There is no draw when positions are repeated as there is in classical chess.
Objective: The goal of the game is to capture the opponent’s Queen without losing your own. 


Given [expression] moves (regardless of how Black plays) if White always moves first. For each game, print YES on a new line if White can win under the specified conditions; otherwise, print NO.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <ctype.h>
#include <deque>
#include <queue>
#include <cstring>
#include <set>
#include <list>
#include <map>
#include <random>
#include <unordered_map>
#include <stdio.h>

using namespace std;

typedef long long ll;
typedef std::vector<int> vi;
typedef std::vector<bool> vb;
typedef std::vector<string> vs;
typedef std::vector<double> vd;
typedef std::vector<long long> vll;
typedef std::vector<std::vector<int> > vvi;
typedef vector<vvi> vvvi;
typedef vector<vll> vvll;
typedef std::vector<std::pair<int, int> > vpi;
typedef vector<vpi> vvpi;
typedef std::pair<int, int> pi;
typedef std::pair<ll, ll> pll;
typedef std::vector<pll> vpll;

const long long mod = 1000000007;

#define all(c) (c).begin(),(c).end()
#define sz(c) (int)(c).size()
#define forn(i, a, b) for(int i = a; i < b; i++)

#define pb push_back
#define mp make_pair
int w,b,m;
pi a[4][4];
vvpi moves(5);
// 1 Q
// 2 R
// 3 N
// 4 B

vpi rook({{1,0}, {0,1}, {-1,0}, {0, -1}});
vpi bish({{1,1}, {-1,1}, {-1,-1}, {1, -1}});
vpi knight({{2,1},{1,2},{2,-1},{-1,2},{-2,1},{1,-2},{-2,-1},{-1,-2}});
vpi queen;
bool go(int turn) {
    if(m==0) return false;
    bool f = false;
    if(turn == 1) f = false;
    else f = true;
    forn(i,0,4) forn(j,0,4) {
        if(a[i][j].second != turn) continue;
        for(auto s : moves[a[i][j].first]) {
            int sx = s.first;
            int sy = s.second;
            int x = i+sx;
            int y = j+sy;
            while(x >=0 && x< 4 && y>=0 && y<4) {
                if(a[x][y].second == turn) break;
                if(a[x][y].second == 3-turn) {
                    if(a[x][y].first == 1) {
                        if(turn == 1) return true;
                        else return false;
                    }
                }
                m--;
                pi was = a[x][y];
                a[x][y] = a[i][j];
                a[i][j] = mp(0,0);
                if(turn == 1) f |= go(3-turn);
                else if(turn == 2) f &= go(3-turn);
                a[i][j] = a[x][y];
                a[x][y] = was;
                m++;
                if(a[x][y].second == 3-turn) {
                    break;
                }
                x+=sx;
                y+=sy;
            }
        }
    }
    return f;
}

int main()
{

    for(auto y : bish) queen.pb(y);
    for(auto y : rook) queen.pb(y);
    moves[1] = queen;
    moves[2] = rook;
    moves[3] = knight;
    moves[4] = bish;
    int t;
    cin>>t;
    forn(kappa,0,t){
        cin>>w>>b>>m;
        if (m==6) m = 5;
        forn(i,0,4) forn(j,0,4) a[i][j] = mp(0,0);
        forn(i,0,w) {
            char p, c;
            int u;
            cin>>p>>c>>u;
            int x = c-'A';
            int y= u-1;
            int v = 1;
            if(p=='R') v=2;
            if(p=='N') v=3;
            if(p=='B') v=4;
            a[x][y] = mp(v, 1);
        }
        forn(i,0,b) {
            char p, c;
            int u;
            cin>>p>>c>>u;
            int x = c-'A';
            int y= u-1;
            int v = 1;
            if(p=='R') v=2;
            if(p=='N') v=3;
            if(p=='B') v=4;
            a[x][y] = mp(v, 2);
        }
        if(go(1)) cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
    }
    
}



----------
====================
----------
ALGORITHMS.395
medium
----------
PROBLEM STATEMENT:
There are N users registered on a website CuteKittens.com. Each of them has a unique password represented by pass[1], pass[2], ..., pass[N]. As this a very lovely site, many people want to access those awesomely cute pics of the kittens. But the adamant admin does not want the site to be available to the general public, so only those people who have passwords can access it.

Yu, being an awesome hacker finds a loophole in the password verification system. A string which is a concatenation of one or more passwords, in any order, is also accepted by the password verification system. Any password can appear [expression]loginAttempt$ string can be created by concatenating password strings, it is accepted.

For example, if there are 3 users with [expression] and so on.  Supplying abra ka dabra, concatenated, passes authentication.

Function Description

Complete the passwordCracker function in the editor below.  It should return the passwords as a single string in the order required for the password to be accepted, each separated by a space. If it is not possible to form the string, return the string WRONG PASSWORD.  

passwordCracker has the following parameters: 
- passwords: a list of password strings 
- loginAttempt: the string to attempt to create  
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>

#include <unordered_set>

using namespace std;


void putReverses(vector< string > &words, unordered_set< string > &wordSet)
{
    int n = words.size();
    for(int i = 0;i != n;i++)
    {
        reverse(words[i].begin(), words[i].end());
        wordSet.insert(words[i]);
    }
}

vector< string > findComb(const string &str, vector< string > &words)
{
    vector< string > result;
    int m = str.size();
    
    unordered_set< string > wordSet;
    putReverses(words, wordSet);
    
    vector< char > valid(m + 1, 0);
    valid[0] = 1;
    vector< int > validLens(m + 1);
    
    for(int len = 1;len <= m;len++)
    {
        int i = len - 1;
        string word;
        for(int j = i;j >= 0;j--)
        {
            word += str[j];
            if(valid[j] && wordSet.find(word) != wordSet.end())
            {
                valid[len] = 1;
                validLens[len] = len - j;
                break;
            }
        }
    }
    
    if(valid[m] == 0) { return result; }
    
    int len = m;
    while(len)
    {
        result.push_back(str.substr(len - validLens[len], validLens[len]));
        len -= validLens[len];
    }
    
    reverse(result.begin(), result.end());
    return result;
}


int main()
{
    int T, N;
    string word, str;
    cin >> T;
    while(T--)
    {
        cin >> N;
        vector< string > words;
        while(N--)
        {
            cin >> word;
            words.push_back(word);
        }
        
        cin >> str;
        
        vector< string > comb(findComb(str, words));
        if(comb.empty()) { cout << "WRONG PASSWORD"; }
        else
        {
            int m = comb.size();
            cout << comb[0];
            for(int i = 1;i != m;i++)
            {
                cout << " " << comb[i];
            }
        }
        
        cout << endl;
    }
    
    return 0;
}

----------
====================
----------
ALGORITHMS.396
hard
----------
PROBLEM STATEMENT:
5-year-old Shinchan had just started learning mathematics. Meanwhile, one of his studious classmates, Kazama, had already written a basic calculator which supports only three operations on integers: multiplication [expression].  Since he had just learned about these operations, he didn't know about operator precedence, and so, in his calculator, all operators had the same precedence and were left-associative.

As always, Shinchan started to irritate him with his silly questions. He gave Kazama a list of [expression]. At his core, Shinchan is actually a good guy, so he only gave lists of integers for which an answer exists.  

Can you help Kazama create the required expression? If multiple solutions exist, print any one of them.   
----------
TOP SOLUTION:
----------
// Intention is a project that we can change with impunity

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <fstream>
#include <string>
#include <map>
#include <set>
#include <memory>
#include <cstring>
#include <chrono>
#include <climits>


using namespace std;


#ifdef WIN32
#define INPUT my_file
const char* input_file_root = "Input";
const char* input_file_suffix = ".txt";

class OutputCompare
{
public:
	~OutputCompare() {
		if (use_file) {
			if (problems == 0) {
				cout << "Output identical to expected file\n";
			}
			else {
				cout << "Output incorrect, found " << problems << " differences\n";
			}
		}
	}

	void set_file(const char* name) {
		expected_file.open(name);
		use_file = true;
	}

	OutputCompare& operator<<(char c) {
		if (use_file) {
			if (!iswspace(c)) {
				char expected;
				expected_file >> expected;
				if (c != expected) {
					cout << "Expected " << expected << " but program output was " << c << '\n';
					++problems;
				}
			}
		}
		else {
			cout << c;
		}
		return *this;
	}

	template <class T>
	OutputCompare& operator<<(const T& value) {
		if (use_file) {
			T expected;
			expected_file >> expected;
			if (value != expected) {
				cout << "Expected " << expected << " but program output was " << value << '\n';
				++problems;
			}
		}
		else {
			cout << value;
		}
		return *this;
	}

private:
	ifstream expected_file;
	int problems = 0;
	bool use_file = false;
};
#define OUTPUT my_output_compare

#else
#define INPUT cin
#define OUTPUT cout
#define _ASSERT(x)
#endif

int main(int argc, const char * argv[])
{
	// Read in problem
#ifdef WIN32
	// Read from a file.  Command line argument [1] is appended to the file name.
	ifstream my_file;
	string input_file_name(input_file_root);
	if (argc >= 2) {
		input_file_name.append(argv[1]);
	}
	input_file_name.append(input_file_suffix);
	my_file.open(input_file_name);

	OutputCompare my_output_compare;
	if (argc < 3 || *argv[2] != 'x') {
		string output_file_name("Output");
		if (argc >= 3) {
			output_file_name.append(argv[2]);
		}
		else if (argc >= 2) {
			output_file_name.append(argv[1]);
		}
		output_file_name.append(".txt");
		my_output_compare.set_file(output_file_name.c_str());
	}
	auto start_time = std::chrono::system_clock::now();
#endif

	int n;
	INPUT >> n;
	int* data = new int[n];
	char* operators = new char[n * 101];
	char* follows = new char[n * 101];

	for (int i = 0; i < n; ++i) {
		INPUT >> data[i];

		for (int j = 0; j < 101; ++j) {
			operators[i * 101 + j] = ' ';
		}
	}

	// Specify that the first input number can be reached
	operators[data[0]] = '+';

	for (int i = 1; i < n; ++i) {
		char* last_ops = operators + (i - 1) * 101;
		char* this_ops = operators + i * 101;
		char* this_follows = follows + i * 101;

		// See what numbers can be reached by combining numbers reachable after i-1 steps with data[i]
		// Note that once we've found a solution, multiplying each later operand will give correct answer
		// So we shortcircuit once entry 0 is filled in
		for (int j = 0; j < 101 && this_ops[0] == ' '; ++j) {
			if (last_ops[j] != ' ') {
				int reachable = j + data[i];
				reachable %= 101;
				if (this_ops[reachable] == ' ') {
					this_ops[reachable] = '+';
					this_follows[reachable] = j;
				}

				reachable = j - data[i];
				if (reachable < 0) reachable += 101;
				if (this_ops[reachable] == ' ') {
					this_ops[reachable] = '-';
					this_follows[reachable] = j;
				}

				reachable = j * data[i];
				reachable %= 101;
				if (this_ops[reachable] == ' ') {
					this_ops[reachable] = '*';
					this_follows[reachable] = j;
				}
			}
		}
	}

	// We should have a result (i.e. 0 should be included in last one)
	if (operators[(n - 1) * 101] == ' ') {
		OUTPUT << "ERROR!!!!!\n";
	}
	else {
		// We obtain the result in reverse order
		vector<char> result;
		result.reserve(n);
		int x = 0;
		for (int i = n - 1; i > 0; --i) {
			result.push_back(operators[i * 101 + x]);
			x = follows[i * 101 + x];
		}
		_ASSERT(x == data[0]);
		OUTPUT << data[0];
		auto it = result.rbegin();
		for (int i = 1; i < n; ++i, ++it) {
			OUTPUT << (*it);
			OUTPUT << data[i];
		}
		OUTPUT << '\n';
	}


	return 0;

#ifdef WIN32
	my_file.close();
	cout << "time=" << std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - start_time).count() << "ms\n";
#endif
	return 0;
}

----------
====================
----------
ALGORITHMS.397
medium
----------
PROBLEM STATEMENT:
You have a pile of [expression] distinct integers. We define a move as follows:


First, choose a pile of stones. Let's say that the chosen pile contains [expression] stones. 
Next, look for some [expression] equal smaller piles.


You are given [expression]. For each query, calculate the maximum possible number of moves you can perform and print it on a new line.
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
ALGORITHMS.398
hard
----------
PROBLEM STATEMENT:
At the time when Pythagoreanism was prevalent, people were also focused on different ways to factorize a number. In one class, Pythagoras asked his disciples to solve one such problem, Reverse Factorization. They were given a set of integer, [expression]. So they decided to find a way in which number of states are least. All of sudden they started on this new problem. People solved it and then started shouting their answer. CRAP!!!. There still exists multiple answers. So finally after much consideration, they settled on the lexicographically smallest series among those solutions which contains the least number of states.

For example, if [expression] then following ways exists  

[expression]
       [expression]

[expression]
       [expression]

[expression]
       [expression]



Here (a) is not the minimal state, as it has [expression] print -1.   
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std; 

bool isLess(const vector<uint32_t>& left, const vector<uint32_t>& right){
	if (left.size() != right.size()) return left.size()<right.size(); 
	for(int i=0; i<left.size(); i++){
		if (left[i]!=right[i]) return left[i]<right[i]; 
	}
	return false; 
}

bool eval(const uint32_t N, const vector<uint32_t>& vals, 
	vector<uint32_t>& answer, vector<uint32_t> current){
	if (N==1){
		sort(current.begin(), current.end()); 
		if (answer.empty()) answer = current; 
		else if (isLess(current, answer)) answer.swap(current); 
		return true; 
	}
	if (answer.size()>0 && current.size()>=answer.size()) return false; 
	bool retval = false; 
	for(int i=vals.size()-1; i>=0; i--){
		if (vals[i]<=N && (N%vals[i])==0){
			current.push_back(vals[i]); 
			retval |= eval(N/vals[i], vals, answer, current); 
		}
	}
	return retval; 
}

int main(void){
	uint32_t N; 
	cin >> N; 	// 1 - 1,000,000,000
	int K; 
	cin >> K; // 1 - 20
	vector<uint32_t> vals(K); 
	for(int i=0; i<K; i++) cin >> vals[i]; // each 2 - 20 and distinct
	sort(vals.begin(), vals.end()); 

	vector<uint32_t> answer, temp; 
	if (eval(N, vals, answer, temp)){
		uint32_t v = 1; 
		cout << v << " "; 
		for(int i=0; i<answer.size(); i++){
			v *= answer[i]; 
			cout << v << " "; 
		}
		cout << endl; 
	} else {
		cout << -1 << endl; 
	}
	return 0; 
}

----------
====================
----------
ALGORITHMS.399
hard
----------
PROBLEM STATEMENT:
Bowling is a sport in which a player rolls a bowling ball towards a group of pins, the target being to knock down the pins at the end of a lane.



In this challenge, the rules of the game are slightly modified. Now, there are a given number of pins, and the pins are arranged in a horizontal line instead of a triangular formation. Two players have to play this game, taking alternate turns. Whoever knocks down the last pin(s) will be declared the winner.  

You are playing this game with your friend, and both of you have become proficient at it. You can knock down any single pin, or any two adjacent pins at one throw of a bowling ball, however, these are the only moves that you can perform. Some moves have already been played. Suddenly, you realize that it is possible to determine whether this game can be won or not, assuming optimal play. And luckily it's your turn right now.  

A configuration is represented by a string consisting of the letters X and I, where: 


I represents a position containing a pin.
X represents a position where a pin has been knocked down.


An example of such a configuration is shown in the image below. Here, the number of pins is [expression] pin has already been knocked down.  



Its representation will be IXIIIIIIIIIII.

Complete the function isWinning that takes the number of pins and the configuration of the pins as input, and return WIN or LOSE based on whether or not you will win. 

Given the current configuration of the pins, if both of you play optimally, determine whether you will win this game or not. 

Note   


A player has to knock down at least one pin in his turn.
Both players play optimally.  

----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <set>
#include <iostream>
#include <algorithm>
using namespace std;

const int Maxn = 305;

int nim[Maxn];
int t;
int n;
char str[Maxn];

int main() {
    for (int i = 1; i < Maxn; i++) {
        set <int> S;
        for (int j = 0; j < i; j++)
            S.insert(nim[j] ^ nim[i - 1 - j]);
        for (int j = 0; j + 1 < i; j++)
            S.insert(nim[j] ^ nim[i - 2 - j]);
        while (S.find(nim[i]) != S.end()) nim[i]++;
    }  
    scanf("%d", &t);
    while (t--) {
        scanf("%d", &n);
        scanf("%s", str);
        int res = 0;
        for (int i = 0; i < n; i++) if (str[i] == 'I') {
            int j = i;
            while (j < n && str[j] == 'I') j++;
            res ^= nim[j - i];
            i = j;
        }
        printf("%s\n", res? "WIN": "LOSE");
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.400
hard
----------
PROBLEM STATEMENT:
Chess is a very popular game played by hundreds of millions of people. Nowadays, we have chess engines such as Stockfish and Komodo to help us analyze games. These engines are very powerful pieces of well-developed software that use intelligent ideas and algorithms to analyze positions and sequences of moves, as well as to find tactical ideas. Consider the following simplified version of chess:


Board: 
It's played on a [expression] board between two players named Black and White.
Rows are numbered from [expression].  
Columns are lettered from [expression].
Pieces and Movement: 
White initially has [expression] pieces.
There are no Kings on the board. Each player initially has exactly [expression] minor pieces (i.e., a Bishop and/or Knight).
White's Pawns move up the board, while Black's Pawns move down the board.
Each move made by any player counts as a single move.
Each piece's possible moves are the same as in classical chess, with the following exceptions:
Pawns cannot move two squares forward.
The en passant move is not possible.
Promotion:
Pawns promote to either a Bishop, Knight, or Rook when they reach the back row (promotion to a Queen is not allowed). 
The players must perform promotions whenever possible. This means White must promote their Pawns when they reach any cell in the top row, and Black must promote their Pawns when they reach any cell in the bottom row. 
Objective: 
The goal of the game is to capture the opponent’s Queen without losing your own.
There will never be a draw or tie scenario like you might see in classical chess.




Given [expression] moves; otherwise, print NO.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <string>
#include <iostream>
#include <algorithm>
#include <utility>
using namespace std;

#define CLEAN_BOARD "................"
#define Z(x, i, j) x[(i)+(j)*4]

void debug(const string B) {
    cout << B[0] << B[1] << B[2] << B[3] << endl;
    cout << B[4] << B[5] << B[6] << B[7] << endl;
    cout << B[8] << B[9] << B[10]<< B[11] << endl;
    cout << B[12]<< B[13]<< B[14]<< B[15] << endl;
}

bool has_figure(const string &b, char c) {
    return b.find(c) != std::string::npos;
}

vector<string> knight_moves(const string &B, int color, int i, int j) {
    vector<string> res;
    int sign = color == 1 ? 0 : 32;
    
    if (i+2 < 4 && j+1 < 4)
        if ((Z(B,i+2,j+1)&32) != sign || Z(B,i+2,j+1) == '.') { string M(B); Z(M,i+2,j+1) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M); }
    if (i+2 < 4 && j-1 >= 0)
        if ((Z(B,i+2,j-1)&32) != sign || Z(B,i+2,j-1) == '.') { string M(B); Z(M,i+2,j-1) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M); }
    if (i+1 < 4 && j+2 < 4)
        if ((Z(B,i+1,j+2)&32) != sign || Z(B,i+1,j+2) == '.') { string M(B); Z(M,i+1,j+2) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M); }
    if (i+1 < 4 && j-2 >= 0)
        if ((Z(B,i+1,j-2)&32) != sign || Z(B,i+1,j-2) == '.') { string M(B); Z(M,i+1,j-2) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M); }
    if (i-2 >= 0 && j+1 < 4)
        if ((Z(B,i-2,j+1)&32) != sign || Z(B,i-2,j+1) == '.') { string M(B); Z(M,i-2,j+1) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M); }
    if (i-2 >= 0 && j-1 >= 0)
        if ((Z(B,i-2,j-1)&32) != sign || Z(B,i-2,j-1) == '.') { string M(B); Z(M,i-2,j-1) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M); }
    if (i-1 >= 0 && j+2 < 4)
        if ((Z(B,i-1,j+2)&32) != sign || Z(B,i-1,j+2) == '.') { string M(B); Z(M,i-1,j+2) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M); }
    if (i-1 >= 0 && j-2 >= 0)
        if ((Z(B,i-1,j-2)&32) != sign || Z(B,i-1,j-2) == '.') { string M(B); Z(M,i-1,j-2) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M); }
    return res;
}

vector<string> bishop_moves(const string &B, int color, int i, int j) {
    vector<string> res;
    int sign = color == 1 ? 0 : 32;
    
    int ii=i-1, jj=j-1;
    while (ii>=0 && jj>=0) {
        if (Z(B,ii,jj) == '.') {
            string M(B); Z(M,ii,jj) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
        }
        else if ((Z(B,ii,jj)&32) != sign) {
            string M(B); Z(M,ii,jj) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
            break;
        }
        else { break; }
        --ii;--jj;
    }
    
    ii=i+1, jj=j-1;
    while (ii<4 && jj>=0) {
        if (Z(B,ii,jj) == '.') {
            string M(B); Z(M,ii,jj) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
        }
        else if ((Z(B,ii,jj)&32) != sign) {
            string M(B); Z(M,ii,jj) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
            break;
        }
        else { break; }
        ++ii;--jj;
    }
    
    ii=i+1, jj=j+1;
    while (ii<4 && jj<4) {
        if (Z(B,ii,jj) == '.') {
            string M(B); Z(M,ii,jj) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
        }
        else if ((Z(B,ii,jj)&32) != sign) {
            string M(B); Z(M,ii,jj) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
            break;
        }
        else { break; }
        ++ii;++jj;
    }
    
    ii=i-1, jj=j+1;
    while (ii>=0 && jj<4) {
        if (Z(B,ii,jj) == '.') {
            string M(B); Z(M,ii,jj) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
        }
        else if ((Z(B,ii,jj)&32) != sign) {
            string M(B); Z(M,ii,jj) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
            break;
        }
        else { break; }
        --ii;++jj;
    }
    
    return res;
}

vector<string> rook_moves(const string &B, int color, int i, int j) {
    vector<string> res;
    int sign = color == 1 ? 0 : 32;
    
    int ii=i-1;
    while (ii>=0) {
        if (Z(B,ii,j) == '.') {
            string M(B); Z(M,ii,j) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
        }
        else if ((Z(B,ii,j)&32) != sign) {
            string M(B); Z(M,ii,j) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
            break;
        }
        else { break; }
        --ii;
    }

    ii=i+1;
    while (ii<4) {
        if (Z(B,ii,j) == '.') {
            string M(B); Z(M,ii,j) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
        }
        else if ((Z(B,ii,j)&32) != sign) {
            string M(B); Z(M,ii,j) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
            break;
        }
        else { break; }
        ++ii;
    }
    
    int jj=j-1;
    while (jj>=0) {
        if (Z(B,i,jj) == '.') {
            string M(B); Z(M,i,jj) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
        }
        else if ((Z(B,i,jj)&32) != sign) {
            string M(B); Z(M,i,jj) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
            break;
        }
        else { break; }
        --jj;
    }
    
    jj=j+1;
    while (jj<4) {
        if (Z(B,i,jj) == '.') {
            string M(B); Z(M,i,jj) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
        }
        else if ((Z(B,i,jj)&32) != sign) {
            string M(B); Z(M,i,jj) = Z(M,i,j); Z(M,i,j) = '.'; res.push_back(M);
            break;
        }
        else { break; }
        ++jj;
    }
    
    return res;
}

vector<string> pawn_moves(const string &B, int color, int i, int j) {
    vector<string> res;

    if (color == 1) {
        if (Z(B,i,j+1) == '.') {
            string M(B); Z(M,i,j) = '.';
            if (j == 2) {
                Z(M,i,j+1) = 'B'; res.push_back(M);
                Z(M,i,j+1) = 'R'; res.push_back(M);
                Z(M,i,j+1) = 'N'; res.push_back(M);
            }
            else {
                Z(M,i,j+1) = 'P'; res.push_back(M);
            }            
        }
        if (i!=3 && (Z(B,i+1,j+1) == 'q' || Z(B,i+1,j+1) == 'b' || Z(B,i+1,j+1) == 'r' || Z(B,i+1,j+1) == 'n' || Z(B,i+1,j+1) == 'p')) {
            string M(B); Z(M,i,j) = '.';
            if (j == 2) {
                Z(M,i+1,j+1) = 'B'; res.push_back(M);
                Z(M,i+1,j+1) = 'R'; res.push_back(M);
                Z(M,i+1,j+1) = 'N'; res.push_back(M);
            }
            else {
                Z(M,i+1,j+1) = 'P'; res.push_back(M);
            }            
        }
        if (i!=0 && (Z(B,i-1,j+1) == 'q' || Z(B,i-1,j+1) == 'b' || Z(B,i-1,j+1) == 'r' || Z(B,i-1,j+1) == 'n' || Z(B,i-1,j+1) == 'p')) {
            string M(B); Z(M,i,j) = '.';
            if (j == 2) {
                Z(M,i-1,j+1) = 'B'; res.push_back(M);
                Z(M,i-1,j+1) = 'R'; res.push_back(M);
                Z(M,i-1,j+1) = 'N'; res.push_back(M);
            }
            else {
                Z(M,i-1,j+1) = 'P'; res.push_back(M);
            }            
        }
    }
    else {
        if (Z(B,i,j-1) == '.') {
            string M(B); Z(M,i,j) = '.';
            if (j == 1) {
                Z(M,i,j-1) = 'b'; res.push_back(M);
                Z(M,i,j-1) = 'r'; res.push_back(M);
                Z(M,i,j-1) = 'n'; res.push_back(M);
            }
            else {
                Z(M,i,j-1) = 'p'; res.push_back(M);
            }            
        }
        if (i!=3 && (Z(B,i+1,j-1) == 'Q' || Z(B,i+1,j-1) == 'B' || Z(B,i+1,j-1) == 'R' || Z(B,i+1,j-1) == 'N' || Z(B,i+1,j-1) == 'P')) {
            string M(B); Z(M,i,j) = '.';
            if (j == 1) {
                Z(M,i+1,j-1) = 'b'; res.push_back(M);
                Z(M,i+1,j-1) = 'r'; res.push_back(M);
                Z(M,i+1,j-1) = 'n'; res.push_back(M);
            }
            else {
                Z(M,i+1,j-1) = 'p'; res.push_back(M);
            }            
        }
        if (i!=0 && (Z(B,i-1,j-1) == 'Q' || Z(B,i-1,j-1) == 'B' || Z(B,i-1,j-1) == 'R' || Z(B,i-1,j-1) == 'N' || Z(B,i-1,j-1) == 'P')) {
            string M(B); Z(M,i,j) = '.';
            if (j == 1) {
                Z(M,i-1,j-1) = 'b'; res.push_back(M);
                Z(M,i-1,j-1) = 'r'; res.push_back(M);
                Z(M,i-1,j-1) = 'n'; res.push_back(M);
            }
            else {
                Z(M,i-1,j-1) = 'p'; res.push_back(M);
            }            
        }
    }
    
    return res;
}

vector<string> queen_moves(const string &B, int color, int i, int j) {
    vector<string> res;
    
    vector<string> A1 = bishop_moves(B, color, i, j);
    vector<string> A2 = rook_moves(B, color, i, j);
    
    res.insert(res.end(), A1.begin(), A1.end());
    res.insert(res.end(), A2.begin(), A2.end());
    
    return res;
}

int moves_to_win(const string &B, int depth, int max_depth) {
    if (depth >= max_depth) return 1000000;

    vector<string> moves;
    for(int j=0; j<4; ++j) {
        for(int i=0; i<4; ++i) {
            switch(Z(B, i, j)) {
                case 'Q':
                {
                    vector<string> Q = queen_moves(B, 1, i, j);
                    moves.insert(moves.end(), Q.begin(), Q.end());
                    break;
                }
                case 'N':
                {
                    vector<string> N = knight_moves(B, 1, i, j);
                    moves.insert(moves.end(), N.begin(), N.end());
                    break;
                }
                case 'B':
                {
                    vector<string> Bi = bishop_moves(B, 1, i, j);
                    moves.insert(moves.end(), Bi.begin(), Bi.end());
                    break;
                }
                case 'R':
                {
                    vector<string> R = rook_moves(B, 1, i, j);
                    moves.insert(moves.end(), R.begin(), R.end());
                    break;
                }
                case 'P':
                {
                    vector<string> P = pawn_moves(B, 1, i, j);
                    moves.insert(moves.end(), P.begin(), P.end());
                    break;
                }
            }
        }
    }
    
    int ans = 1000000;
    vector<string> good_moves;
    
    for(string m: moves)
        if (!has_figure(m, 'q'))
            return depth+1;
        
    if (depth+2 > max_depth)
        return ans;
        
    for(string m: moves) {
        vector<string> op_moves;
        for(int j=0; j<4; ++j) {
            for(int i=0; i<4; ++i) {
                switch(Z(m, i, j)) {
                    case 'q':
                    {
                        vector<string> Q = queen_moves(m, 2, i, j);
                        op_moves.insert(op_moves.end(), Q.begin(), Q.end());
                        break;
                    }
                    case 'n':
                    {
                        vector<string> N = knight_moves(m, 2, i, j);
                        op_moves.insert(op_moves.end(), N.begin(), N.end());
                        break;
                    }
                    case 'b':
                    {
                        vector<string> Bi = bishop_moves(m, 2, i, j);
                        op_moves.insert(op_moves.end(), Bi.begin(), Bi.end());
                        break;
                    }
                    case 'r':
                    {
                        vector<string> R = rook_moves(m, 2, i, j);
                        op_moves.insert(op_moves.end(), R.begin(), R.end());
                        break;
                    }
                    case 'p':
                    {
                        vector<string> P = pawn_moves(m, 2, i, j);
                        op_moves.insert(op_moves.end(), P.begin(), P.end());
                        break;
                    }
                }
            }
        }
        
        bool is_good = true;
        for(auto o: op_moves) {
            if (!has_figure(o, 'Q')) {
                is_good = false;
                break;
            }
        }
        
        if (is_good) {
            int ans_next = 0;
            for(auto o: op_moves) {
                ans_next = max(ans_next, moves_to_win(o, depth+2, max_depth));
                if (ans_next > max_depth) break;
            }
            ans = min(ans, ans_next);
        }
    }

    return ans;
}

int main() {
    int T; cin >> T;
    for(int t=0; t<T; ++t) {
        string B(CLEAN_BOARD);
        
        int w,b,m; cin >> w >> b >> m;
        
        for(int i=0; i<w; ++i) {
            char f, col; cin >> f >> col;
            int row; cin >> row;
            B[col-'A' + (row-1)*4] = f;
        }
        for(int i=0; i<b; ++i) {
            char f, col; cin >> f >> col;
            int row; cin >> row;
            B[col-'A' + (row-1)*4] = f + ('a' - 'A');
        }

        cout << (moves_to_win(B, 0, m%2==0 ? m-1 : m) <= m ? "YES" : "NO") << endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.401
advanced
----------
PROBLEM STATEMENT:
Alice thinks of a non-decreasing sequence of non-negative integers and wants Bob to guess it by providing him the set of all its K-sums with repetitions. 

What is this? Let the sequence be {A[1], A[2], ..., A[N]} and K be some positive integer that both Alice and Bob know. Alice gives Bob the set of all possible values that can be genereated by this - A[i1] + A[i2] + ... + A[iK], where 1 ≤ i1 ≤ i2 ≤ ... ≤ iK ≤ N. She can provide the values generated in any order she wishes to. Bob's task is to restore the initial sequence.

Consider an example. Let N = 3 and K = 2. The sequence is {A[1], A[2], A[3]}. The sequence of its 2-sums with repetitions is {A[1] + A[1], A[1] + A[2], A[1] + A[3], A[2] + A[2], A[2] + A[3], A[3] + A[3]}. But its elements could be provided in any order. For example any permutation of {2, 3, 4, 4, 5, 6} corresponds to the sequence {1, 2, 3}.
----------
TOP SOLUTION:
----------
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>
#include <vector>
#include <set>
#include <map>
#include <algorithm>
#include <queue>
using namespace std;

int Tot;

long long a[100010];
map <long long,int> mp;

void dfs(int now,int ee,int les)
{
    if (les==0||now+1==ee)
    {
        Tot++;
        return;
    }
    for (int i=0;i<=les;i++)
        dfs(now+1,ee,les-i);
}

void dfs2(int now,long long num,int les)
{
    if (now==0) num+=les*a[0];
    if (les==0||now==0)
    {
        mp[num]--;
        if (mp[num]==0) mp.erase(num);
        return;
    }
    for (int i=0;i<=les;i++)
        dfs2(now-1,num+i*a[now],les-i);
}

int main()
{
    int T;
    scanf("%d",&T);
    while (T--)
    {
        int n,m;
        scanf("%d%d",&n,&m);
        Tot=0;
        dfs(0,n,m);
        for (int i=0;i<Tot;i++)
        {
            long long x;
            scanf("%lld",&x);
            mp[x]++;
        }
        for (int i=0;i<n;i++)
        {
            long long now=mp.begin()->first;
            if (i==0)
            {
                a[i]=now/m;
                mp[now]--;
                if (mp[now]==0) mp.erase(now);
            }
            else
            {
                a[i]=now-a[0]*(m-1);
                for (int j=1;j<=m;j++)
                {
                    dfs2(i-1,a[i]*j,m-j);
                }
            }
        }
        for (int i=0;i<n;i++)
        {
            if (i) printf(" ");
            printf("%lld",a[i]);
        }
        puts("");
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.402
easy
----------
PROBLEM STATEMENT:
Two players called [expression] always plays first, and the two players move in alternating turns. The game's rules are as follows:


In a single move, a player can remove either [expression] stones from the game board. 
If a player is unable to make a move, that player loses the game.


Given the starting number of stones, find and print the name of the winner.  [expression] is named Second.  Each player plays optimally, meaning they will not make a move that causes them to lose the game if a winning move exists.

For example, if [expression] can make the following moves:  


[expression] stones and win.
[expression] cannot move and loses.


[expression] would make the second play and win the game.

Function Description

Complete the gameOfStones function in the editor below.  It should return a string, either First or Second.  

gameOfStones has the following parameter(s):


n: an integer that represents the starting number of stones

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
long DP[101];
bool dp(long x)
{
	if (DP[x]!=-1) return DP[x];
	bool res=!dp(x-2);
	if (x>3) res=res|(!dp(x-3));
	if (x>5) res=res|(!dp(x-5));
	DP[x]=res;
	return res;
}
int main()
{
	long nTest,n;
	memset(DP,-1,sizeof(DP));
	DP[1]=0;
	DP[2]=DP[3]=DP[5]=1;
	scanf("%ld",&nTest);
	while (nTest--)
	{
		scanf("%ld",&n);
		puts(dp(n)?"First":"Second");
	}
}

----------
====================
----------
ALGORITHMS.403
easy
----------
PROBLEM STATEMENT:
Two players are playing a game of Tower Breakers! The rules of the game are as follows:
 
- Player [expression] always moves first, and both players always play optimally. 
- Initially there are [expression]. 
- The players move in alternating turns. In each turn, a player can choose a tower of height [expression]. 
- If the current player is unable to make a move, they lose the game. 
 
Given the values of [expression].  

For example, there are [expression] with no move.

Function Description  

Complete the towerBreakers function in the editor below.  It should return an integer that represents the winning player.  

towerBreakers has the following paramter(s):  


n: an integer that represents the number of towers  
m: an integer that represents the height of each tower  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
using namespace std;

int main()
{
	long nTest,n,m;
	scanf("%ld",&nTest);
	while (nTest--)
	{
		scanf("%ld%ld",&n,&m);
		if (m==1) puts("2");
		else puts((n&1)?"1":"2");
	}
}

----------
====================
----------
ALGORITHMS.404
easy
----------
PROBLEM STATEMENT:
Two players are playing a game on a [expression] chessboard. The rules of the game are as follows:


The game starts with a single coin located at some [expression].
In each move, a player must move the coin from cell [expression] to one of the following locations:

[expression] 
[expression] 
[expression] 
[expression]

Note: The coin must remain inside the confines of the board.
Beginning with player 1, the players alternate turns. The first player who is unable to make a move loses the game.


The figure below shows all four possible moves using an [expression] board for illustration:



Given the initial coordinates of the players' coins, assuming optimal play, determine which player will win the game. 

Function Description

Complete the chessboardGame function in the editor below.  It should return a string, either First or Second.

chessboardGame has the following parameter(s):  


x: an integer that represents the starting column position   
y: an integer that represents the starting row position  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
long DP[16][16];
long dx[4]={-2,-2,1,-1};
long dy[4]={1,-1,-2,-2};
bool inside(long u,long v)
{
	return (u>0 && v>0 && u<=15 && v<=15);
}

bool dp(long x,long y)
{
	if (DP[x][y]!=-1) return DP[x][y];
	bool res=false;
	for (long i=0; i<4; ++i)
	{
		long xx=x+dx[i],yy=y+dy[i];
		if (inside(xx,yy)) res=res|(!dp(xx,yy));
	}
	DP[x][y]=res;
	return res;
}
int main()
{
	long nTest,x,y;
	memset(DP,-1,sizeof(DP));
	DP[1][1]=DP[1][2]=DP[2][1]=DP[2][2]=false;
	scanf("%ld",&nTest);
	while (nTest--)
	{
		scanf("%ld%ld",&x,&y);
		puts(dp(x,y)?"First":"Second");
	}
}

----------
====================
----------
ALGORITHMS.405
easy
----------
PROBLEM STATEMENT:
Nim is the most famous two-player algorithm game. The basic rules for this game are as follows:


The game starts with a number of piles of stones.  The number of stones in each pile may not be equal.
The players alternately pick up [expression] pile
The player to remove the last stone wins.


For example, there are [expression] stones in them.  Play may proceed as follows:

Player  Takes           Leaving
                        pile=[3,2,4]
1       2 from pile[1]  pile=[3,4]
2       2 from pile[1]  pile=[3,2]
1       1 from pile[0]  pile=[2,2]
2       1 from pile[0]  pile=[1,2]
1       1 from pile[1]  pile=[1,1]
2       1 from pile[0]  pile=[0,1]
1       1 from pile[1]  WIN


Given the value of [expression] and the number of stones in each pile, determine the game's winner if both players play optimally.

Function Desctription  

Complete the nimGame function in the editor below.  It should return a string, either First or Second.  

nimGame has the following parameter(s):  


pile: an integer array that represents the number of stones in each pile  

----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
using namespace std;

int main()
{
	long nTest,n,res,x;
	scanf("%ld",&nTest);
	while (nTest--)
	{
		scanf("%ld%ld",&n,&res);
		for (long i=1; i<n; ++i) scanf("%ld",&x),res^=x;
		puts((!res)?"Second":"First");
	}
}

----------
====================
----------
ALGORITHMS.406
easy
----------
PROBLEM STATEMENT:
Two people are playing game of Misère Nim. The basic rules for this game are as follows:


The game starts with [expression] stones.
The players move in alternating turns. During each move, the current player must  remove one or more stones from a single pile. 
The player who removes the last stone loses the game.


Given the value of [expression] and the number of stones in each pile, determine whether the person who wins the game is the first or second person to move. If the first player to move wins, print First on a new line; otherwise, print Second. Assume both players move optimally. 
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
using namespace std;

int main()
{
	long nTest,n;
	scanf("%ld",&nTest);
	while (nTest--)
	{
		long res=0,cnt=0,x;
		scanf("%ld",&n);
		for (long i=0; i<n; ++i)
		{
			scanf("%ld",&x);
			if (x==1) ++cnt;
			res^=x;
		}
		if (cnt==n) puts((cnt&1)?"Second":"First");
		else puts((res>0)?"First":"Second");
	}
}

----------
====================
----------
ALGORITHMS.407
easy
----------
PROBLEM STATEMENT:
Two people are playing Nimble! The rules of the game are:


The game is played on a line of [expression] coins. For example: 

The players move in alternating turns. During each move, the current player must  remove exactly [expression].
The game ends when all coins are in square [expression] and nobody can make a move. The first player to have no available move loses the game.


Given the value of [expression] and the number of coins in each square, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
using namespace std;

int main()
{
	long nTest,n;
	scanf("%ld",&nTest);
	while (nTest--)
	{
		ll res=0,x;
		scanf("%ld",&n);
		for (long i=0; i<n; ++i)
		{
			scanf("%lld",&x);
			if (x&1LL && i>0) res^=i;
		}
		if (n==1) puts("Second");
		else puts((!res)?"Second":"First");
	}
}
----------
====================
----------
ALGORITHMS.408
medium
----------
PROBLEM STATEMENT:
Alice and Bob invented the following silly game:


The game starts with an integer, [expression]).
Alice always plays first, and the two players move in alternating turns.
During each move, the current player chooses a prime number, [expression].
The first player to be unable to make a move loses the game.


Alice and Bob play [expression] for each game, print the name of the game's winner on a new line. If Alice wins, print Alice; otherwise, print Bob.

Note: Each player always plays optimally, meaning they will not make a move that causes them to lose the game if some better, winning move exists.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
using namespace std;
#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cerr << *x, 0);
sim > char dud(...);
struct debug{
#ifdef LOCAL
~debug() { cerr << endl; }
eni(!=) cerr << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
  ris << "(" << d.first << ", " << d.second << ")";
}
sim dor(rge<c> d) {
  *this << "[";
  for (auto it = d.b; it != d.e; ++it)
    *this << ", " + 2 * (it == d.b) << *it;
  ris << "]";
}
#else
sim dor(const c &) { ris; }
#endif
};
#define imie(x) " [" << #x ": " << (x) << "] "

const int nax = 1e5 + 5;
int ans[nax];
bool is[nax];

int main() {
	for(int i = 2; i < nax; ++i) is[i] = true;
	for(int i = 2; i  * i < nax; ++i) if(is[i])
		for(int j = i * i; j < nax; j += i) is[j] = false;
	for(int i = 2; i < nax; ++i) ans[i] = ans[i-1] + int(is[i]);
	int t;
	scanf("%d", &t);
	while(t--) {
		int n;
		scanf("%d", &n);
		puts(ans[n] % 2 ? "Alice" : "Bob");
	}
}

----------
====================
----------
ALGORITHMS.409
easy
----------
PROBLEM STATEMENT:
Poker Nim is another [expression]-player game that's a simple variation on a Nim game. The rules of the games are as follows:


The game starts with [expression] chips.
The players move in alternating turns. During each move, the current player must perform either of the following actions:

Remove one or more chips from a single pile. 
Add one or more chips to a single pile.     

At least [expression] chip must be added or removed during each turn.
To ensure that the game ends in finite time, a player cannot add chips to any pile [expression] times.
The player who removes the last chip wins the game.


Given the values of [expression] piles, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
using namespace std;

int main()
{
	long nTest,n,res,x,k;
	scanf("%ld",&nTest);
	while (nTest--)
	{
		scanf("%ld%ld%ld",&n,&k,&res);
		for (long i=1; i<n; ++i) scanf("%ld",&x),res^=x;
		puts((!res)?"Second":"First");
	}
}

----------
====================
----------
ALGORITHMS.410
medium
----------
PROBLEM STATEMENT:
Two players (numbered [expression]) are playing a game of Tower Breakers! The rules of the game are as follows:


Player [expression] always moves first, and both players always move optimally.
Initially there are [expression] towers of various heights.
The players move in alternating turns. In each turn, a player can choose a tower of height [expression].
If the current player is unable to make any move, they lose the game.


Given the value of [expression].
----------
TOP SOLUTION:
----------
#include <ios>
#include <iostream>
#include <vector>
#include <algorithm>

int g[1000005] = {};
std::vector<std::vector<int> > factors;
std::vector<int> grundys;

int main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    factors.resize(1000005);
    for (int i = 1; i < 1000005; i++)
        for (int j = 2*i; j < 1000005; j+=i)
            factors[j].push_back(i);
    g[1] = 0;
    for (int i = 2; i < 1000005; i++)
    {
        g[i] = -1;
        grundys.clear();
        for (std::vector<int>::iterator it = factors[i].begin(); it != factors[i].end(); it++)
            grundys.push_back(g[*it]);
        std::sort(grundys.begin(), grundys.end());
        int last = -1;
        for (std::vector<int>::iterator it = grundys.begin(); it != grundys.end(); it++)
        {
            if (*it != last && *it != last+1)
            {
                g[*it] = last+1;
                break;
            }
            else if (*it == last+1)
            {
                last++;
            }
        }
        if (g[i] == -1)
            g[i] = last+1;
    }
    int tc, n, x;
    std::cin >> tc;
    while (tc--)
    {
        std::cin >> n;
        int grundy_total = 0;
        while (n--)
        {
            std::cin >> x;
            grundy_total ^= g[x];
        }
        if (grundy_total == 0)
            std::cout << "2\n";
        else
            std::cout << "1\n";
    }
}
----------
====================
----------
ALGORITHMS.411
medium
----------
PROBLEM STATEMENT:
Two players (numbered [expression]) are playing a game of Tower Breakers! The rules of the game are as follows:


Player [expression] always moves first.
Initially there are [expression] towers of various heights.
The players move in alternating turns. In each turn, a player must choose a tower of height [expression].  
If the current player is unable to make any move, they lose the game.


Given the value of [expression].
----------
TOP SOLUTION:
----------
#include <ios>
#include <iostream>
#include <vector>
#include <algorithm>

int g[100005] = {};
std::vector<std::vector<int> > factors;
std::vector<int> grundys;

int main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    factors.resize(100005);
    for (int i = 1; i < 100005; i++)
        for (int j = 2*i; j < 100005; j+=i)
            factors[j].push_back(i);
    g[1] = 0;
    for (int i = 2; i < 100005; i++)
    {
        g[i] = -1;
        grundys.clear();
        for (std::vector<int>::iterator it = factors[i].begin(); it != factors[i].end(); it++)
        {
            if ((i/(*it)) & 1)
                grundys.push_back(g[*it]);
            else
                grundys.push_back(0);
        }
        std::sort(grundys.begin(), grundys.end());
        int last = -1;
        for (std::vector<int>::iterator it = grundys.begin(); it != grundys.end(); it++)
        {
            if (*it != last && *it != last+1)
            {
                g[*it] = last+1;
                break;
            }
            else if (*it == last+1)
            {
                last++;
            }
        }
        if (g[i] == -1)
            g[i] = last+1;
    }
    int tc, n, x;
    std::cin >> tc;
    while (tc--)
    {
        std::cin >> n;
        int grundy_total = 0;
        while (n--)
        {
            std::cin >> x;
            grundy_total ^= g[x];
        }
        if (grundy_total == 0)
            std::cout << "2\n";
        else
            std::cout << "1\n";
    }
}
----------
====================
----------
ALGORITHMS.412
medium
----------
PROBLEM STATEMENT:

  Nim is a famous game in which two players take turns removing items from [expression] distinct piles. During each turn, a player must remove one or more items from a single, non-empty pile. The winner of the game is whichever player removes the last item from the last non-empty pile.


John and Kate modified Nim by adding the following rule, which they call a Zero-Move:

For each non-empty pile, either player can remove [expression]; that said, either player is free to perform a Zero-Move on any other non-empty pile that hasn't had a Zero-Move performed on it yet.

John and Kate play [expression] games of Zero-Move Nim. Given the number of items in each pile for each game, determine whether or not John can win the game if he always moves first and each player always moves optimally (i.e., never makes a move that causes them to lose if some better, winning move exists). For each game, print W on a new line if John can win; otherwise, print L instead.
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;

typedef int _loop_int;
#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)
#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)
#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)

#define DEBUG(x) cout<<#x<<": "<<x<<endl
#define DEBUG_VEC(v) cout<<#v<<":";REP(i,v.size())cout<<" "<<v[i];cout<<endl
#define ALL(a) (a).begin(),(a).end()

#define CHMIN(a,b) a=min((a),(b))
#define CHMAX(a,b) a=max((a),(b))

// mod
const ll MOD = 1000000007ll;
#define FIX(a) ((a)%MOD+MOD)%MOD

// floating
typedef double Real;
const Real EPS = 1e-11;
#define EQ0(x) (abs(x)<EPS)
#define EQ(a,b) (abs(a-b)<EPS)
typedef complex<Real> P;

void solve(){
  int n;
  scanf("%d",&n);
  int x = 0;
  while(n--){
    int v;
    scanf("%d",&v);
    if(v&1)v++;
    else v--;
    x ^= v;
  }
  puts(x==0?"L":"W");
}

int main(){
  int g;
  scanf("%d",&g);
  while(g--)solve();
  return 0;
}

----------
====================
----------
ALGORITHMS.413
medium
----------
PROBLEM STATEMENT:
Two players are playing a game on a [expression] chessboard. The rules of the game are as follows:


The game starts with [expression].
In each move, a player must move a single coin from some cell [expression] to one of the following locations:

[expression] 
[expression] 
[expression] 
[expression]. 

Note: The coin must remain inside the confines of the board.
The players move in alternating turns. The first player who is unable to make a move loses the game.


The figure below shows all four possible moves:



Note: While the figure shows a [expression] board.

Given the value of [expression] coins, determine which player will win the game. Assume both players always move optimally.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <set>

using namespace std ;

vector < vector < int > > grundy ( 16 , vector < int > ( 16 , - 1 ) ) ;

int find_grundy ( int x , int y )
{
    if ( x < 1 || y > 15 || x > 15 || y < 1 )
    {
        return - 1 ;    
    }
    if ( grundy [ x ] [ y ] != - 1 )
    {
        return grundy [ x ] [ y ] ;    
    }
    set < int > s ;
    int i = 0 ;
    set < int > :: iterator it ;
    s.insert ( find_grundy ( x - 2 , y + 1 ) ) ;
    s.insert ( find_grundy ( x - 2 , y - 1 ) ) ;
    s.insert ( find_grundy ( x + 1 , y - 2 ) ) ;
    s.insert ( find_grundy ( x - 1 , y - 2 ) ) ;
    while ( 1 )
    {
        it = s.find ( i ) ;
        if ( it == s.end () )
        {
            grundy [ x ] [ y ] = i ;
            return i ;
        }
        i ++ ;
    }
    return - 1 ;
}

int main ()
{
    for ( int i = 1 ; i < 16 ; i ++ )
    {
        for ( int j = 1 ; j < 16 ; j ++ )
        {
            find_grundy ( i , j ) ;
            //cout << grundy [ i ] [ j ] << " " ;
        }
        //cout << endl ;
    }
    
    int t ;
    cin >> t;
    while ( t -- )
    {
        int k ;
        cin >> k ;
        int allxor = 0 ;
        while ( k -- )
        {
            int x , y ;
            cin >> x >> y ;
            allxor = allxor ^ grundy [ x ] [ y ] ;   
        }
        if ( allxor == 0 )
        {
            cout <<  "Second" << endl ;   
        }
        else
        {
            cout << "First" << endl ;    
        }
    }
    return 0 ;
}
----------
====================
----------
ALGORITHMS.414
medium
----------
PROBLEM STATEMENT:
Two HackerRank staffers found a secret room with a mysterious [expression] square board and decided to play a game with it. The game has the following rules:


At the beginning of the game, the players write a single digit (given as input) ranging from [expression] square board. 
The players move in alternating turns. In each move, the current player performs the following actions:

Chooses a board that has at least one non-prime number written on it and has more than one cell (i.e., dimensions [expression]). 
Cuts the chosen board into [expression] smaller boards by breaking it along any horizontal or vertical line at the edge of a cell.

Note: Although the game starts with one [expression] pieces of the original board (as long as it can have a legal move performed on it).
The game ends when there are no more cuttable boards (i.e., there are [expression] boards, or all boards have only prime numbers written on them). The first player who is unable to make a move loses.


Given the value of [expression] cell of the board, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally.

Time Limit


Python: 18 seconds
Pypy2: 5 seconds


For other languages, the time limit is standard.
----------
TOP SOLUTION:
----------
#include <ios>
#include <iostream>
#include <algorithm>
#include <vector>

bool comp[35][35][35][35] = {};
int dp[35][35][35][35] = {};
int cul[35][35] = {};

int grundy(int x1, int x2, int y1, int y2)
{
    if (x1 == x2 && y1 == y2)
        return 0;
    else if (!comp[x1][x2][y1][y2])
    {
        comp[x1][x2][y1][y2] = true;
        if (cul[x2][y2] - cul[x1-1][y2] - cul[x2][y1-1] + cul[x1-1][y1-1] == (x2-x1+1)*(y2-y1+1))
            dp[x1][x2][y1][y2] = 0;
        else
        {
            std::vector<int> reachable;
            for (int i = x1; i < x2; i++)
            {
                reachable.push_back(grundy(x1, i, y1, y2) ^ grundy(i+1, x2, y1, y2));
            }
            for (int i = y1; i < y2; i++)
            {
                reachable.push_back(grundy(x1, x2, y1, i) ^ grundy(x1, x2, i+1, y2));
            }
            std::sort(reachable.begin(), reachable.end());
            int last = -1;
            dp[x1][x2][y1][y2] = -1;
            for (std::vector<int>::iterator it = reachable.begin(); it != reachable.end(); it++)
            {
                if (*it != last && *it != last+1)
                {
                    dp[x1][x2][y1][y2] = last+1;
                    break;
                }
                else if (*it == last+1)
                    last++;
            }
            if (dp[x1][x2][y1][y2] == -1)
                dp[x1][x2][y1][y2] = last+1;
        }
    }
    return dp[x1][x2][y1][y2];
}

int main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    int tc, n, x;
    std::cin >> tc;
    while (tc--)
    {
        std::cin >> n;
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                std::cin >> x;
                if (x == 2 || x == 3 || x == 5 || x == 7)
                    cul[i][j] = 1;
                else
                    cul[i][j] = 0;
            }
        }
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                for (int k = 1; k <= n; k++)
                {
                    for (int l = 1; l <= n; l++)
                    {
                        dp[i][j][k][l] = false;
                        comp[i][j][k][l] = false;
                    }
                }
            }
        }
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                cul[i][j] += cul[i-1][j];
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                cul[i][j] += cul[i][j-1];
        std::cout << (grundy(1, n, 1, n) != 0 ? "First" : "Second") << '\n';
    }
}
----------
====================
----------
ALGORITHMS.415
medium
----------
PROBLEM STATEMENT:
Kyle and Mike are bored on a rainy day and decide to pass the time by creating a new game having the following rules:


The game starts with two [expression]. 
The players move in alternating turns, with [expression] points.
Each value of [expression] moves.
The player with the maximum number of points wins.
The arrays A and B are accessible to both the players P1 and P2. So the players make a optimal move at every turn. 


Given the values of [expression] if they will tie. Assume both players always move optimally.
----------
TOP SOLUTION:
----------
#include <ios>
#include <iostream>

int a[1005] = {};
int b[1005] = {};
bool avail[1005] = {};

int main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
    int n, tc;
    std::cin >> tc;
    while (tc--)
    {
        std::cin >> n;
        for (int i = 0; i < n; i++)
            avail[i] = true;
        for (int i = 0; i < n; i++)
            std::cin >> a[i];
        for (int i = 0; i < n; i++)
            std::cin >> b[i];
        int p1score = 0;
        int p2score = 0;
        bool p1 = true;
        for (int move = 0; move < n; move++)
        {
            int best = -1000000000;
            int bestindex = 0;
            for (int i = 0; i < n; i++)
            {
                if (avail[i])
                {
                    if (a[i] + b[i] > best)
                    {
                        best = a[i]+b[i];
                        bestindex = i;
                    }
                }
            }
            /*
            std::cout << "Player";
            if (p1) std::cout << ' ' << 1 << ' ';
            else std::cout << ' ' << 2 << ' ';
            std::cout << "chooses " << bestindex << "!" << '\n';
            */
            if (p1)
                p1score += a[bestindex];
            else
                p2score += b[bestindex];
            avail[bestindex] = false;
            p1 = !p1;
        }
        if (p1score == p2score)
            std::cout << "Tie" << '\n';
        else
            std::cout << (p1score > p2score ? "First" : "Second") << '\n';
    }
}
----------
====================
----------
ALGORITHMS.416
hard
----------
PROBLEM STATEMENT:
Consider the following game:


There are two players, First and Second, sitting in front of a pile of [expression] stones. First always plays first.
There is a set, [expression].
The players move in alternating turns. During each turn, a player chooses some [expression] equal smaller piles, the player loses.
Both players always play optimally.


Given [expression], find and print the winner of the game. If First wins, print First; otherwise, print Second.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <map>
using namespace std;

long long N, M;
long long int S[12];

map<long long int, int> dp;

bool win(long long int n)
{
    int& res = dp[n];
    if(!res){
        for(int i = 0; i < M; i++)
            if(n % S[i] == 0){
                if(!(S[i] & 1))
                    res = 1;
                else if(!win(n / S[i]))
                    res = 1;            
            }
        res++;
    }
    return res - 1;
    
}

int main() {
    
    cin >> N >> M;
    for(int i = 0; i < M; i++)
        cin >> S[i];
    cout << (win(N)? "First": "Second") << '\n';
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    return 0;
}

----------
====================
----------
ALGORITHMS.417
medium
----------
PROBLEM STATEMENT:
Dexter and Debra are playing a game. They have N containers each having one or more chocolates. Containers are numbered from 1 to N, where ith container has A[i] number of chocolates.

The game goes like this. First player will choose a container and take one or more chocolates from it. Then, second player will choose a non-empty container and take one or more chocolates from it. And then they alternate turns. This process will continue, until one of the players is not able to take any chocolates (because no chocolates are left). One who is not able to take any chocolates loses the game. Note that player can choose only non-empty container.

The game between Dexter and Debra has just started, and Dexter has got the first Chance. He wants to know the number of ways to make a first move such that under optimal play, the first player always wins.
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <string>
#include <cstring>
using namespace std;

int a[1000006];
int main() {
int x = 0, n;
	scanf("%d",&n);
	for (int i = 0; i < n; ++i) {
		scanf("%d", a + i);
		x ^= a[i];
	}
	int y = 0;
	for (int i = 0; i < n; ++i) {
		if ((x ^ a[i]) < a[i]) {
			++y;
		}
	}
	printf("%d\n",y);
	return 0;
}

----------
====================
----------
ALGORITHMS.418
medium
----------
PROBLEM STATEMENT:
Kitty and Katty have [expression] and begin playing a game in turns, with Kitty always taking the first turn. The game's rules are as follows:


For each turn, the player removes [expression], write the result on a new block, and insert the new block into the set. 
The game ends when only [expression]:
If [expression], then Kitty wins.
If [expression], then Katty wins.
If [expression], then the player who moved last wins.


Recall that [expression] is the Modulo Operation.

Given the value of [expression], can you find and print the name of the winner? Assume that both play optimally.

Note: The selection order for [expression].


----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cstdio>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <cstdlib>
#include <string>
#include <cstring>
#include <algorithm>
#include <numeric>

#define mp make_pair
#define mt make_tuple
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define forn(i, n) for (int i = 0; i < (int)(n); ++i)
#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)
#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)
#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;
typedef vector<vi> vvi;
typedef long long i64;
typedef vector<i64> vi64;
typedef vector<vi64> vvi64;

template<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }
template<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.precision(10);
    cout << fixed;
#ifdef LOCAL_DEFINE
    freopen("input.txt", "rt", stdin);
#endif

    int t;
    cin >> t;
    forn(i, t) {
        int n;
        cin >> n;
        cout << (n == 1 || n % 2 == 0 ? "Kitty" : "Katty") << '\n';
    }

#ifdef LOCAL_DEFINE
    cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC << " s.\n";
#endif
    return 0;
}

----------
====================
----------
ALGORITHMS.419
medium
----------
PROBLEM STATEMENT:
After their success in coming up with Fun Game, Kyle and Mike invented another game having the following rules:


The game starts with an [expression]. 
The players move in alternating turns, with [expression]) in the above sequence and changes it to either a + (plus) or a - (minus) sign.  
The game ends when there are no more asterisks ([expression] wins.


Given the value of [expression] will win. Assume both players always move optimally.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int tcase;
    cin >> tcase;
    int n;
    while(tcase--) {
        cin >> n;
        if(n % 8) {
            puts("First");
        } else {
            puts("Second");
        }
    }
    return 0;
}
----------
====================
----------
ALGORITHMS.420
medium
----------
PROBLEM STATEMENT:
Alice and Bob are playing a game with a rooted tree. The tree has [expression], is always the root. Here are the basic rules:


They move in alternating turns, and both players always move optimally.
During each move, a player removes an edge from the tree, disconnecting one of its leaves or branches. The leaf or branch that was disconnected from the rooted tree is removed from the game. 
The first player to be unable to make a move loses the game.
Alice always makes the first move. 


For example, the diagram below shows a tree of size [expression]:


Now, if a player removes the edge between [expression] become disconnected from the root and are removed from the game:



Given the structure of the tree, determine and print the winner of the game. If Alice wins, print [expression].
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
#define N 1010
int n;

vector <int> v[N];
int f[N];

void dfs(int r, int p) {
  f[r] = 0;
  for(int i = 0; i < (int)v[r].size(); i ++) {
    if(p == v[r][i]) continue;
    dfs(v[r][i], r);
    f[r] ^= f[v[r][i]] + 1;
  }
}

int main() {
    int T;
  scanf("%d", &T);
    while(T --) {
      scanf("%d", &n);
      for(int i = 1; i <= n; i ++) v[i].clear();
      for(int i = 1; i < n; i ++) {
        int x, y;
        scanf("%d%d", &x, &y);
        v[x].push_back(y);
        v[y].push_back(x);
      }
      dfs(1, 0);
      if(f[1]) puts("Alice"); else puts("Bob");
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.421
medium
----------
PROBLEM STATEMENT:
Bob and Ben are playing a game with forests! The game's rules are as follows:


The game starts with a forest of [expression] trees.
Bob always moves first and they take alternating turns. The first player with no available move loses the game.
During each move, the player removes one node. If the node is not a leaf, then the whole tree vanishes; otherwise, the rest of the tree remains in the forest. We define a leaf to be a node with exactly [expression] connected edge.
Both players play optimally, meaning they will not make a move that causes them to lose the game if some better, winning move exists.


We define each tree [expression]-tree forest as follows:


Tree [expression] (a constant). 
Its nodes are numbered sequentially from [expression].
Its edges are numbered sequentially from [expression].


Given the values of [expression] for each tree in the forest, can you determine who will win the game?
----------
TOP SOLUTION:
----------
#include <bits/stdc++.h>
typedef long long LL;
using namespace std;

int main(){
	int g;
	cin >> g;
	for(int G = 0; G < g; G++){
		int n;
		cin >> n;
		int ans = 0;
		for(int i = 0; i < n; i++){
			int m, k;
			cin >> m >> k;
			if(m % 2){
				ans ^= 1;
			} else if(m >= 4){
				ans ^= 2;
			}
		}
		if(ans == 0){
			cout << "BEN" << endl;
		} else {
			cout << "BOB" << endl;
		}
	}
}
----------
====================
----------
ALGORITHMS.422
medium
----------
PROBLEM STATEMENT:
Our unsung tower-breaking heroes (players [expression] days of Game Theory! The rules are as follows:


[expression] always moves first, and both players always move optimally.
Initially there is [expression].
The players move in alternating turns. The moves performed by each player are different:
At each turn, [expression] new tower.
At each turn, [expression] and the game continues.
The game is over when no valid move can be made by [expression].
[expression]'s goal is to earn as many coins as possible. 


Can you predict the number of coins that [expression] will earn?
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <math.h>
using namespace std;
int main(){
	static const int arr[]={1,1,1,1,2,3,4,5,7,11,16,22,30};
	vector<double> high (arr,arr+13);
	for (int i = 13; i < 150; i++) {
		int sq = sqrt(i);
		double h = 0;
		for(int j=1;j<=sq;j++){h+=high[i-j*j];}
		high.push_back(h);
	}
	int tc;double n;
	cin>>tc;
	for(int itc=0;itc<tc;itc++) {
		cin>>n;
		for (int i=0;i<high.size();i++) {
			if (high[i] >= n){cout<<i<<endl;break;}
		}
	}
	return 0;
}
----------
====================
----------
ALGORITHMS.423
hard
----------
PROBLEM STATEMENT:
Big Cat and Little Cat love playing games. Today, they decide to play a Game of Stones, the Kitties are Coming edition. The game's rules are as follows: 


The game starts with [expression] piles. 
The cats move in alternating turns, and Little Cat always moves first.
During a move, a cat picks a pile having a number of stones [expression]. 
The first cat to be unable to make a move (e.g., because all piles contain exactly [expression] stone) loses the game. 


Little Cat is curious about the number of ways in which the stones can be initially arranged so that she is guaranteed to win. Two arrangements of stone piles are considered to be different if they contain different sequences of values. For example, arrangements [expression] are different.

Given the values for [expression]. 

Note: Each cat always moves optimally, meaning that they're both playing to win and neither cat will make a move that causes them to lose the game if some other (winning) sequence of moves can be made.
----------
TOP SOLUTION:
----------
/* no greedy easy life */

#include <cstring>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cassert>
#include <cstdlib>
#include <queue>
#include <ctime>

#define pii pair<int, int>
  
#define pb push_back
#define mp make_pair
  
#define f first
#define s second
  
using namespace std;

typedef long long ll;
typedef double ld;

typedef vector<int> vi;

const double EPS = 1e-9;
const double PI = acos(-1);
  
const int MOD = (int) 1e9 + 7;
const int MAXN = (int) 666 + 7;

int n, m, k;

int g[MAXN];
bool used[MAXN];

int dp[11][MAXN][MAXN];

void add(int &x, int y) {
  x += y;
  if (x >= MOD) {
    x -= MOD;
  }
}

int get(int x) {
  if (k <= 3)
    return g[x];
  else
    return x - 1;
}

int main() {                                       
  #ifdef LOCAL
  freopen("in", "r", stdin);
  //freopen("out", "w", stdout);
  #endif         

  cin >> n >> m >> k;

  g[1] = 0;
  for (int i = 2; i <= n; i++) {
    memset(used, 0, sizeof used);
    for (int x = 1; x < i; x++)
      used[g[x] ^ g[i - x]] = true;
    if (k > 2) {
      for (int x = 1; x < i; x++)
        for (int y = x; x + y < i; y++)
          used[g[x] ^ g[y] ^ g[i - x - y]] = true;
    }
    while (used[g[i]]) {
      g[i]++;
    }
  }

  dp[0][0][0] = 1;
  for (int len = 0; len < m; len++) {
    for (int sum = 0; sum <= n; sum++) {
      for (int xor_sum = 0; xor_sum <= n; xor_sum++) {
        if (!dp[len][sum][xor_sum]) continue;
        for (int last = 1; last <= n - sum; last++) {
          add(dp[len + 1][sum + last][xor_sum ^ get(last)], dp[len][sum][xor_sum]);
        }
      }
    }
  }
  int ans = 0;
  for (int x = 1; x <= n; x++)
    add(ans, dp[m][n][x]);
  cout << ans;
  return 0;
}
----------
====================
----------
ALGORITHMS.424
medium
----------
PROBLEM STATEMENT:
Alice and Bob play the following game:


They choose a permutation of the numbers [expression].  
Alice plays first and they alternate.  
In a turn, they can remove any one remaining number from the permutation.  
The game ends when the remaining numbers form an increasing sequence of [expression] or more numbers. The person who played the last turn (after which the sequence becomes increasing) wins the game.  


Assuming both play optimally, who wins the game?  

For example, if [expression].  Since this is a decreasing sequence, Bob can remove any number for optimum play (he will lose regardless).  Alice then removes any number leaving an array of only one element.  Since Alice removed the last element to create an increasing sequence, Alice wins. 

Function Description  

Complete the permutationGame function in the editor below.  It should return a string that represents the winner of the game, either Bob or Alice.  

permutationGame has the following parameter: 
- arr: an array of integers that represents the starting permutation  
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <cctype>
#include <numeric>
#include <queue>
#include <iostream>
#include <iomanip>
#include <sstream>
#define FOR(i,s,e) for(int i=(s);i<(int)(e);i++)
#define FOE(i,s,e) for(int i=(s);i<=(int)(e);i++)
#define ALL(x) (x).begin(), (x).end()
#define CLR(s) memset(s,0,sizeof(s))
#define PB push_back
using namespace std;
typedef long long LL;
typedef pair<int,int> pii;
typedef map<int,int> mii;
typedef vector<int> vi;
#define x first
#define y second

int n, a[16];
bool win[1<<15];
int dp[1<<15];

int go(int x) {
        int &res = dp[x];
        if (res != -1) return res;
        res = 0;
        if (win[x]) return res;
        FOR(i, 0, n)
                if ((x>>i)&1)
                        res |= !go(x ^ (1<<i));
        return res;
}

int main() {
        int z;
        scanf("%d", &z);
        while (z--) {
                scanf("%d", &n);
                FOR(i, 0, n) scanf("%d", a+i);
                FOR(i, 0, 1<<n) {
                        win[i] = 1;
                        int last = -1;
                        FOR(j, 0, n) {
                                if ((i>>j)&1) {
                                        if (last == -1) last = j;
                                        else win[i] &= (a[last] < a[j]), last = j;
                                }
                        }
                }
                FOR(i, 0, 1<<n) dp[i] = -1;
                int ans = go((1<<n) - 1);
                puts(ans ? "Alice" : "Bob");
        }
        return 0;
}

----------
====================
----------
ALGORITHMS.425
hard
----------
PROBLEM STATEMENT:
Alice and Bob are playing a game, defined below:


There is an undirected tree graph with [expression] nodes that has the following properties: 
Each node has [expression] golden coins. 
Node [expression] is root of the tree. 
The parent node of some node [expression].
Moves
Players move in turns. 
During a move, a player can select a node [expression]. 
If the current player can't make any move, they lose the game.


The game quickly becomes boring because the result is determined by the tree's configuration and the number of coins in each node (assuming that both players play optimally).

Alice decides to instead challenge Bob by asking him [expression]:


Alice picks a node [expression]. 
She picks another node [expression].


Bob must determine if the first player has a winning strategy for the new tree or not. It's possible that after Alice draws the new edge, the graph will no longer be a tree; if that happens, the question is invalid. Each question is independent, so the answer depends on the initial state of the graph (and not on previous questions).

Given the tree and the number of coins in each node, can you help Bob answer all [expression] questions?
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <iostream>
#include <ctime>
#include <iomanip>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
#include <string>
#include <cstring>
using namespace std;

#define N 1000000
int Time, n, x, y, q, c[N]; 
int L[N], R[N], ni[N][2], dep[N];
vector <int> ve[N];


void dfs(int k, int f) {
	L[k] = ++Time;
	ni[k][dep[k]] = c[k];
	for (int i = 0; i < (int) ve[k].size(); i++)
		if (ve[k][i] != f) {
			dep[ve[k][i]] = dep[k] ^ 1;
			dfs(ve[k][i], k);
			ni[k][0] ^= ni[ve[k][i]][0];
			ni[k][1] ^= ni[ve[k][i]][1];
		}
	R[k] = Time;
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%d", &c[i]);
	for (int i = 1; i < n; i++) {
		scanf("%d%d", &x, &y);
		ve[x].push_back(y);
		ve[y].push_back(x);
	}
	dep[1] = 0;
	dfs(1, 0);
	scanf("%d", &q);
	while (q--) {
		scanf("%d%d", &x, &y);
		if (L[x] <= L[y] && L[y] <= R[x])
			printf("INVALID\n");
		else {
			if ((dep[y] + dep[x]) % 2 == 1) {
				if (ni[1][1])
					printf("YES\n");
				else
					printf("NO\n");
			}else {
				if (ni[1][1] ^ ni[x][1] ^ ni[x][0])
					printf("YES\n");
				else
					printf("NO\n");
			}
		}
	}
}
----------
====================
----------
ALGORITHMS.426
medium
----------
PROBLEM STATEMENT:
General Iroh and Commandant Bumi are heading to the Republic City to stop a rebellion. But it's quite a long travel, so in the meantime they have started discussing about possible attacking plans. Right now, they're arguing about best ways for moving soldiers during the battle. Tired of not getting a final and concise strategy, Iroh proposed a particularly original idea.

Iroh:

Bumi, look at this map: here we have all possible locations in the battle field soldiers can occupy. I know a game which can give us some ideas.


Bumi:

A game? How will a game help us here?


Iroh:

It's pretty simple, we know which location is connected to each one, and also, that all those paths between locations are one-way (it's too dangerous to have two ways paths), so we place some soldiers at random initial locations, take turns, and in each turn, we try to make a valid move with one soldier from one location to another. Eventually, we won't be able to move any man so, the first one which is not able to perform any valid move, loses. One important thing is, at some moment, we may have some men at the same field location.


Bumi:

Are you sure we are gonna end this? We have so many locations and paths... don't know, soldiers could be moving in circles for ever.


Iroh:

Take it easy man, those paths were built by the best architects I've ever known, so there is no way that could happen.


Bumi:

Well, I still don't get how does this help us.


Iroh:

Me neither, but greatest generals from the Earth Kingdom created their strategies from this game, so, who knows?


Bumi:

Ok, I'm in. Who plays first?


Iroh:

You go first my friend. Just make sure you always do your best, because I will show no mercy to you :).

----------
TOP SOLUTION:
----------
#define _CRT_SECURE_NO_WARNINGS
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <complex>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;
typedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;
typedef vector<string> vs; typedef long double ld;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

bool topologicalSort(const vector<vi> &g, vi &ord) {
	int n = g.size();
	vi deg(n);
	rep(i, n) each(j, g[i]) deg[*j] ++;
	ord.assign(n, -1);
	int t = 0;
	rep(i, n) if(deg[i] == 0) ord[t ++] = i;
	for(int h = 0; h < t; h ++) {
		int v = ord[h];
		each(j, g[v])
			if(-- deg[*j] == 0)
				ord[t ++] = *j;
	}
	return t == n;
}

int dp[100000];
int main() {
	int N, M;
	scanf("%d%d", &N, &M);
	vector<vi> g(N);
	rep(i, M) {
		int a, b;
		scanf("%d%d", &a, &b), a --, b --;
		g[a].pb(b);
	}
	vi ord;
	topologicalSort(g, ord);
	vi q;
	for(int ix = N-1; ix >= 0; ix --) {
		int i = ord[ix];
		q.clear();
//		cerr << i+1 << ": ";
		each(j, g[i]) {
			q.push_back(dp[*j]);
//			cerr << dp[*j] << ", ";
		}
//		cerr << "; ";
		make_heap(all(q), greater<int>());
		int x = 0;
		while(!q.empty() && q[0] == x) {
			do {
				pop_heap(all(q), greater<int>());
				q.pop_back();
			}while(!q.empty() && q[0] == x);
			x ++;
		}
//		cerr << x << endl;
		dp[i] = x;
	}
	int Q;
	scanf("%d", &Q);
	rep(ii, Q) {
		int K;
		scanf("%d", &K);
		int x = 0;
		rep(i, K) {
			int v;
			scanf("%d", &v), v --;
			x ^= dp[v];
		}
		puts(x != 0 ? "Bumi" : "Iroh");
	}
	return 0;
}

----------
====================
----------
ALGORITHMS.427
medium
----------
PROBLEM STATEMENT:
It's New Year's Day, and Balsa and Koca are stuck inside watching the rain. They decide to invent a game, the rules for which are described below.

Given array [expression] integers, they take turns making a single move. Balsa always moves first, and both players are moving optimally (playing to win and making no mistakes).

During each move, the current player chooses one element from [expression]; otherwise Balsa wins. 

Given [expression], determine the winner.

Note: [expression].
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

#define ll long long
#define ull unsigned ll

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(ll *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void reader(double *x){scanf("%lf",x);}
int reader(char c[]){int i,s=0;for(;;){mygc(i);if(i!=' '&&i!='\n'&&i!='\r'&&i!='\t'&&i!=EOF) break;}c[s++]=i;for(;;){mygc(i);if(i==' '||i=='\n'||i=='\r'||i=='\t'||i==EOF) break;c[s++]=i;}c[s]='\0';return s;}
template <class T, class S> void reader(T *x, S *y){reader(x);reader(y);}
template <class T, class S, class U> void reader(T *x, S *y, U *z){reader(x);reader(y);reader(z);}
template <class T, class S, class U, class V> void reader(T *x, S *y, U *z, V *w){reader(x);reader(y);reader(z);reader(w);}

void writer(int x, char c){int s=0,m=0;char f[10];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(ll x, char c){int s=0,m=0;char f[20];if(x<0)m=1,x=-x;while(x)f[s++]=x%10,x/=10;if(!s)f[s++]=0;if(m)mypc('-');while(s--)mypc(f[s]+'0');mypc(c);}
void writer(double x, char c){printf("%.15f",x);mypc(c);}
void writer(const char c[]){int i;for(i=0;c[i]!='\0';i++)mypc(c[i]);}
void writer(const char x[], char c){int i;for(i=0;x[i]!='\0';i++)mypc(x[i]);mypc(c);}
template<class T> void writerLn(T x){writer(x,'\n');}
template<class T, class S> void writerLn(T x, S y){writer(x,' ');writer(y,'\n');}
template<class T, class S, class U> void writerLn(T x, S y, U z){writer(x,' ');writer(y,' ');writer(z,'\n');}
template<class T> void writerArr(T x[], int n){int i;if(!n){mypc('\n');return;}rep(i,n-1)writer(x[i],' ');writer(x[n-1],'\n');}

char memarr[17000000]; void *mem = memarr;
#define MD 1000000007

int T, N, A[10000];
int in[3];

int dp[2][2][2010][2010][3];

int solve(int t, int a0, int a1, int a2, int sum){
  int i, j, k;
  int res = 0;

  if(dp[t][a0][a1][a2][sum] >= 0) return dp[t][a0][a1][a2][sum];

  if(a0+a1+a2==0){
    if(t==0 && sum!=0) res = 1;
    if(t==1 && sum==0) res = 1;
  } else {
    if(a0){
      k = solve(t^1, a0-1, a1, a2, sum);
      if(k==0) res = 1;
    }
    if(a1){
      k = solve(t^1, a0, a1-1, a2, (sum+(t==0?1:2))%3);
      if(k==0) res = 1;
    }
    if(a2){
      k = solve(t^1, a0, a1, a2-1, (sum+(t==0?2:1))%3);
      if(k==0) res = 1;
    }
  }

  return dp[t][a0][a1][a2][sum] = res;
}

int main(){
  int i, j, k, l, m;

  rep(m,2) rep(i,2) rep(j,2010) rep(k,2010) rep(l,3) dp[m][i][j][k][l] = -1;

  reader(&T);
  while(T--){
    reader(&N);
    rep(i,N) reader(A+i);

    rep(i,3) in[i] = 0;
    rep(i,N) in[A[i]%3]++;

    k = solve(0, in[0]%2, in[1], in[2], 0);
    if(k) writerLn("Balsa"); else writerLn("Koca");
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.428
hard
----------
PROBLEM STATEMENT:
There are [expression] stones in it. Alice and Bob play the following game:


Alice starts, and they alternate turns.
In a turn, a player can choose any one of the piles of stones and divide the stones in it into any number of unequal piles such that no two of the newly created piles have the same number of stones. For example, if there 8 stones in a pile, it can be divided into one of these set of piles: [expression].&nbsp;
The player who cannot make a move (because all the remaining piles are indivisible) loses the game.


Given the starting set of piles, who wins the game assuming both players play optimally (that means they will not make a move that causes them to lose the game if some better, winning move exists)?
----------
TOP SOLUTION:
----------
/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <cctype>
#include <numeric>
#include <queue>
#include <iostream>
#include <iomanip>
#include <sstream>
#define FOR(i,s,e) for(int i=(s);i<(int)(e);i++)
#define FOE(i,s,e) for(int i=(s);i<=(int)(e);i++)
#define ALL(x) (x).begin(), (x).end()
#define CLR(s) memset(s,0,sizeof(s))
#define PB push_back
using namespace std;
typedef long long LL;
typedef pair<int,int> pii;
typedef map<int,int> mii;
typedef vector<int> vi;
#define x first
#define y second

const int N = 60;

int sum = 0;
int sg[N+5];

int a[1000];
int kk = 0;

void F(int n, int f, int xr, vi &v) {
        // create a pile of size "f"
        n  -= f;
        xr ^= sg[f];

        if (n<0) return;
        if (n==0) {

//              FOR(i,0,kk) printf("%d ", a[i]); puts("");
//              FOR(i,0,kk) printf("%s%d ", (i==0?"(":""), sg[a[i]]); puts(")");

                v.PB(xr);
                return;
        }
        for(int k=f+1;k<=n;k++) {
                a[kk++] = k;
                F(n, k, xr, v);
                kk--;
        }
}

void init() {
        CLR(sg);
        FOE(i,1,N) {
                vi v;
                F(i, 0, 0, v);
                sort(v.begin(), v.end());

                v.erase(v.begin());     // single..
//              FOR(r,0,v.size()) printf("->%d",v[r]);puts("");

                v.erase(unique(v.begin(), v.end()), v.end());
                // mex
                int lt = -1;
                FOR(j,0,v.size()) {
                        if(v[j] != lt+1) break;
                        lt = v[j];
                }
                sg[i] = lt+1;
//              printf("[%d] %d\n\n", i, sg[i]);
        }
}

int main() {
        init();

        int n, t;
        cin >> t;
        while (t--) {
                cin >> n;
                int xr = 0, x;
                while (n--) {
                        cin >> x;
                        xr ^= sg[x];
                }
                cout << (xr ? "ALICE" : "BOB") << endl;
        }
        return 0;
}

----------
====================
----------
ALGORITHMS.429
hard
----------
PROBLEM STATEMENT:
Laurel and Hardy have [expression] piles of chocolates with each pile containing some number of chocolates. The piles are arranged from left to right in a non decreasing order based on the number of chocolates in each pile. They play the following game. 

For every continuous subsequence of chocolate piles (at least 2 piles form a subsequence), Laurel and Hardy will play game on this subsequence of chocolate piles, Laurel plays first, and they play in turn. In one move, the player can choose one of the piles and remove at least one chocolate from it, but the non-decreasing order of the chocolate piles must be maintained. The last person to make a valid move wins. 

How many continuous subsequences of chocolate piles will Laurel win if both of them play optimally? The number of chocolates of each pile will be recovered after the game ends for each subsequences. 
----------
TOP SOLUTION:
----------
#pragma comment(linker, "/STACK:16777216")

#include<stdio.h>
#include<string.h>
#include<math.h>
#include<stdlib.h>
#include<ctype.h>
#include<iostream>
#include<vector>
#include<stack>
#include<queue>
#include<set>
#include<map>
#include<string>
#include<utility>
#include<algorithm>
#include<list>
using namespace std;

#define pb push_back
#define MS( a ) memset( a,0,sizeof(a))
#define MSV( a,v ) memset( a,v,sizeof(a))

#define MP make_pair

typedef long long Long;
typedef vector<long> VL;
typedef pair<long,long> pll;

#define MAX 100007

long N,K;
long A[MAX+7];
long X[MAX+7];

long Find( long *A,long n )
{
    long i;
    for( i=1;i<=n;i++ ){
        if( i&1 ) X[i] = X[i-1];
        else X[i] = X[i-2]^(A[i-1]-A[i]);
    }
    long Cnt = 0;
    map<long,long> Map;
    Map[0] = 1;
    for( i=2;i<=n;i++ ){
        if( i&1 ){
            long v = X[i-1]^A[i];
            Map[v] += 0;
            Cnt += Map[v];
            Map[X[i-1]]++;
        }
        else{
            long v = X[i];
            Map[v] += 0;
            Cnt += Map[v];
        }
    }
    return Cnt;
}

int main( void )
{
    long i,j,v,Icase,k = 0;

    //freopen("text1.txt","r",stdin );

    scanf("%ld",&N );
    for( i=1;i<=N;i++ ){
        scanf("%ld",&A[i] );
    }
    reverse( A+1,A+N+1 );
    Long Ans = ((Long)N*(N-1))/2 - Find( A,N ) - Find( A+1,N-1 );
    cout<<Ans<<endl;

    return 0;
}

----------
====================
----------
ALGORITHMS.430
hard
----------
PROBLEM STATEMENT:
Manasa loves the nim game, in which there are [expression]

The whole game can now be described as follows:   

There are [expression]. A player loses if there are no more available moves.

Manasa plays the first move against Sandy. Who will win if both of them play optimally?
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <unordered_set>
using namespace std;
const int M = 1000100;
vector<int> val = {2,3,5,7,11,13};
vector<int> sg;
int n;

void SGFun(int u, unordered_set<int> &st){
    if(u == 0 || u == 1){
        st.insert(0);
        return ;
    }
    for(int i = 0; i < val.size(); ++ i){
        int v = u - val[i];
        if(v < 0)
            break;
        if(sg[v] != -1)
            st.insert(sg[v]);
        else
            SGFun(v, st);
    }
}

void init(){
//    sg.resize(14);
    sg.resize(M);
    
    for(int i = 0; i < M; ++ i)
        sg[i] = -1;
    
    sg[0] = sg[1] = 0;
    sg[2] = 1;//sg[3] = sg[5] = sg[7] = sg[11] = sg[13] = 1;
    
    for(int i = 3; i < 100; ++ i){
        if(sg[i] != -1)
            continue;
        unordered_set<int> st;
        SGFun(i, st);
        sg[i] = 0;
        for(int j = 0; st.find(j) != st.end(); sg[i] = ++ j) ;
    }
 /*   
    for(int i = 0; i < 31; ++ i){
        printf("%d -> %d\n",i,sg[i]);
    }
    
    sg[0] = sg[1] = 0;
    sg[2] = sg[3] = sg[5] = sg[7] = sg[11] = sg[13] = 1;
    sg[4] = 2;
    sg[6] = 3;
    sg[8] = sg[9] = 4;
    sg[10] = 5;
    sg[12] = 6;
    */
}

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
//    init();
    int T;
    scanf("%d",&T);
    while(T --){
        scanf("%d",&n);
        long long ans = 0;
        for(int i = 0; i < n; ++ i){
            long long x;
            scanf("%lld",&x);
            long long val = x%9;
            if(val <= 1)
                x = 0;
            else if(val <= 3)
                x = 1;
            else if(val <= 5)
                x = 2;
            else if(val <= 7)
                x = 3;
            else
                x = 4;
            ans ^= x;
        }
        if(ans)
            puts("Manasa");
        else
            puts("Sandy");
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.431
medium
----------
PROBLEM STATEMENT:
HackerChess is a variant of chess played at HackerRank. It is a game played between two players who make moves in turns until one of them cannot make any move. The player who cannot make a move loses the game and the other player is declared the winner. The game is played on a board with [expression] columns of the board.

Given the initial position of the rooks and knowing that the second player makes the first move, decide who will win the game if both players play optimally.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n), b(n);
        for (int i=0; i<n; i++)
            cin >> a[i];
        for (int i=0; i<n; i++)
            cin >> b[i];
        int s = 0;
        for (int i=0; i<n; i++)
            s ^= abs(a[i]-b[i])-1;
        cout << (s? "player-2": "player-1") << endl;
    }
    return 0;
}

----------
====================
----------
ALGORITHMS.432
medium
----------
PROBLEM STATEMENT:
Koga and Ryuho, new generation Athena's saints, are training to improve their control over the cosmos. According to the ancient Masters, a saint's power to control the cosmos strengthens, when one allows the energy of the universe to flow within the body and then concentrates it. This energy can even be used to explode the objects. 

Today's training is based on a game, and the goal is to use as little cosmos as possible to win. Two saints play as follows: 

Initially there are [expression] stones. The saints take turns and in each turn, a saint must select a non-empty pile and destroy at least half of the stones in it. The winner is the saint who destroys the last available stone . 

For example, from a pile of [expression] stones, leaving a single (and possibly empty) pile at most 3 stones. With such game, saints learn how to use the appropriate amount of cosmos in a single strike: too much will destroy more stones than desired, too little won't be enough. They also improve their battle thinking and strategy skills.

Ryuho suspects that such game is not as random as it appears to be at first glance. He strongly believes that with the correct single blow, you're assured to win from the very first turn, if you play optimally, no matter how good the other saint plays. Moreover, he is particularly interested in knowing the minimum number of stones he needs to destroy at that first move. Can you help him?  
----------
TOP SOLUTION:
----------
#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define mygc(c) (c)=getchar_unlocked()
#define mypc(c) putchar_unlocked(c)

void reader(int *x){int k,m=0;*x=0;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){*x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||k>'9')break;*x=(*x)*10+k-'0';}if(m)(*x)=-(*x);}
void writer(int x, char c){int i,sz=0,m=0;char buf[10];if(x<0)m=1,x=-x;while(x)buf[sz++]=x%10,x/=10;if(!sz)buf[sz++]=0;if(m)mypc('-');while(sz--)mypc(buf[sz]+'0');mypc(c);}

int main(){
  int T, N;
  int i, j, k, h, x;
  int res, tmp;

  reader(&T);
  while(T--){
    reader(&N);
    res = 1000000000;

    if(N%2==1){
      res = 1;
    } else {
      k = N;
      h = 0;
      while(k) h++, k/=2;
      x = (h^1);
      for(i=h;i;i--) for(j=i-1;j>=0;j--) if((x^i^j) == 0){
        tmp = (1<<(i-1)) - ((1<<j)-1);
        if(j==i-1) tmp = (1<<(i-1))/2;
        res = min(res, tmp);
      }
    }

    writer(res, '\n');
  }

  return 0;
}

----------
====================
----------
ALGORITHMS.433
expert
----------
PROBLEM STATEMENT:
Stephanie just learned about a game called Nim in which there are two players and [expression] piles of stones. During each turn, a player must choose any non-empty pile and take as many stones as they want. The first player who cannot complete their turn (i.e., because all piles are empty) loses.  

Stephanie knows that, for each start position in this game, it's possible to know which player will win (i.e., the first or second player) if both players play optimally. Now she wants to know the number of different games that exist that satisfy all of the following conditions:


The game starts with [expression] stones.
All the piles contain pairwise different numbers of stones.
The first player wins if that player moves optimally.


Help Stephanie by finding and printing the number of such games satisfying all the above criteria, modulo [expression].
----------
TOP SOLUTION:
----------
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <iostream>
#include <set>
#include <vector>
#include <cstring>
#include <string>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <complex>
#include <map>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vi> vvi;
typedef long double ld;
typedef vector<double> vd;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef vector<pii> vii;
typedef vector<string> vs;
const int mod = 1000000007;

ll mpow(ll x, ll n) {
    ll res = 1;
    while (n) {
        if (n & 1) res = res * x % mod;
        x = x * x % mod;
        n /= 2;
    }
    return res;
}

int stupid(int n, int m) {
    int c = 0;
    int all = (1 << m) - 1;
    for (int mask = 1; mask < (1 << all); ++mask) if (__builtin_popcount(mask) == n) {
        int xr = 0;
        for (int i = 0; i < all; ++i) if (mask & (1 << i)) {
            xr ^= 1 + i;
        }
        if (xr) ++c;
    }
    for (int i = 2; i <= n; ++i) c = c * (ll)i % mod;
    return c;
}

int solve(int n, int m) {
    vi d(n + 1);
    vi a(n + 1);
    d[0] = 1;
    d[1] = 0;
    ll dif = mpow(2, m) - 1;
    a[0] = 1;
    for (int i = 1; i <= n; ++i) a[i] = a[i-1] * (dif - i + 1) % mod;
    for (int i = 2; i <= n; ++i) {
        d[i] = (a[i-1] - d[i-2] * (dif - i + 2) % mod * (i-1) - d[i-1]) % mod;
        //cerr << i << ' ' << d[i] << endl;
    }
    return (a[n] - (ll)d[n] + 2*mod) % mod;
}

int main() {
    int n,m;
    cin >> n >> m;
    cout << solve(n, m) << endl;
    //cerr << stupid(n,m) << ' ' << a[n] << endl;
    return 0;
}
----------
====================
----------
ALGORITHMS.434
hard
----------
PROBLEM STATEMENT:
Jenna is playing a computer game involving a large map with [expression] bidirectional roads. The game's objective is to travel to as many cities as possible without visiting any city more than once. The more cities the player visits, the more points they earn.

As Jenna's fellow student at Hackerland University, she asks you for help choosing an optimal path. Given the map, can you help her find a path that maximizes her score?

Note: She can start and end her path at any two distinct cities.
----------
TOP SOLUTION:
----------
#include <iostream>
#include <vector>
#include <string>
#include <ostream>
#include <algorithm>
#include <iterator>
#include <array>
#include <set>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <ctime>
#include <cassert>
#include <bitset>
#include <queue>
#include <stack>
#include <chrono>
#include <sys/resource.h>
    

using namespace std;


template <class T> 
std::ostream& operator<<(std::ostream& os, const vector<T>& rhs)
{
	for (const auto& x : rhs)
		os << x << " ";
	return os;
}

template <class T> 
std::ostream& operator<<(std::ostream& os, const vector<vector<T>>& A)
{
	os << endl;
	for (int i = 1; i < A.size(); ++i)
		os << i << ": [" << A[i] << "]" <<endl;
	return os;
}

std::ostream& operator<<(std::ostream& os, const map<long,long>& t)
{
	for (auto p : t)
		os << p.first << "^" << p.second << "*";
	os << endl;
	return os;
}


template <class T> 
T max(const vector<T>& v)
{
// 	if (v.size() == 0)
// 		cout << "SHIT!" << endl;
	T m = v[0];
	size_t sz = v.size();
	for (size_t i = 0; i < sz; ++i)
	{
		if (v[i] > m)
			m = v[i];
	}
	return m;
}

template <class T> std::vector<T> range (T n) 
{
	std::vector<T> toReturn(n, 0);
	for (T i = 1; i < n ; ++i)
		toReturn[i] = i;
	return toReturn;
}

typedef std::chrono::time_point<std::chrono::high_resolution_clock> clockt;

inline double diffclockt(clockt a, clockt b)
{
	
	const double t = 0.000001;
	return std::chrono::duration_cast<std::chrono::microseconds>(a-b).count()*t;
}

class Chronometer
{
public:
	Chronometer() : m_timer(std::chrono::high_resolution_clock::now()) {}
	
	double Reset()
	{
		auto tlast = m_timer;
		m_timer = std::chrono::high_resolution_clock::now();
	
		return diffclockt(m_timer, tlast);
	}
	
	double Peek() const
	{
		auto tnow = std::chrono::high_resolution_clock::now();
	
		return diffclockt(tnow, m_timer);
	}
	
	std::chrono::time_point<std::chrono::high_resolution_clock> m_timer;
};

inline double TimeFromStart()
{
	static Chronometer C;
	return C.Peek();
}

inline std::default_random_engine & random_engine()
{
	static std::default_random_engine e{};
	return e;
}

inline void randomize()
{
	static std::random_device rd{};
	random_engine().seed(rd());
}

inline bool probability_of_true(double p)
{
	static std::bernoulli_distribution d(p);
	return d(random_engine());
}

inline double random_real( double from, double upto )
{
	static std::uniform_real_distribution<> d{};
	using parm_t = decltype(d)::param_type;
	return d( random_engine(), parm_t{from, upto} );
}

inline int random_integer(int from, int to)
{
	static std::uniform_int_distribution<> d{};
	using parm_t = decltype(d)::param_type;
	return d( random_engine(), parm_t{from, to-1} );
}

inline int random_give_priority_to_primeros(int a, int b)
{
	int n = b-a;
	random_engine();
	int t = random_integer(0,(n*(n+1))/2);
	int u = n-1;
	int i = n-1;
	int toreturn = a;
	while (u < t && i > 0)
	{
		u += i;
		--i;
		++toreturn;
	}
	return toreturn;
}


using node_t = int;
const node_t INVALID_NODE = -1;

using weight_t = int;

// something larger than weight_t for when you have that weight_t doesn't properly hold a sum of weight_t
using sumweight_t = int;
// const sumweight_t INF = 200000000;

struct NeighborNode
{
	explicit NeighborNode() : node(INVALID_NODE) {} 
	
	explicit NeighborNode(node_t v, weight_t w) : node(v) {}
	
	inline operator node_t() const
	{
		return node;
	}
	
	weight_t Weight() const
	{
// 		return weight;
		return 1;
	}
	
	node_t node;
// 	weight_t weight{1}; //comment 
};

class Path
{
public:
    Path(size_t n) : m_path(), m_explored(n), m_value(0) {}
    Path(size_t n, node_t initialnode) : m_path(), m_explored(n), m_value(0) 
    {
        emplace_back(initialnode,0);
    }
    const deque<NeighborNode>& get_path() const { return m_path; }
    inline operator const deque<NeighborNode>&() const { return m_path; }
//     inline operator vector<NeighborNode>&()  { return m_path; }
    long value() const { return m_value; }
    long cost() const { return m_value; }
    long weight() const { return m_value; }
    
    bool is_node_in_path(node_t v) const
	{
		return m_explored[v] > 0;
	}
    
    void push_back(const NeighborNode& v)
    {
//         assert(v.weight == 0 || !m_path.empty());
        assert(v < m_explored.size());

        ++m_explored[v];
//         m_value += v.weight;
        m_path.push_back(v);
    }
    
    void emplace_back(node_t node, weight_t weight = 1)
    {
        assert(weight == 0 || !m_path.empty());
        assert(node < m_explored.size());
        ++m_explored[node];
        m_value += weight;
        m_path.emplace_back(node,weight);
    }
    
    void push_front(NeighborNode v)
	{
//         swap(m_path.front().weight,v.weight);
        assert(!m_path.empty() && "Use push_back when it's empty");
        assert(v < m_explored.size());
//         m_path.front().weight = v.weight;
        m_path.emplace_front(v,0);
		m_value += v.Weight();
        ++m_explored[v];
	}
	
    void emplace_front(node_t node, weight_t weight = 1)
	{
//         auto w = m_path.front().weight;
        assert(!m_path.empty() && "Use emplace_back when it's empty");
        assert(node < m_explored.size());
// 		m_path.front().weight = weight;
		m_path.emplace_front(node,0);
		m_value += weight;
        ++m_explored[node];
	}
    
    void pop_back()
    {
        assert(!m_path.empty() && "Can't pop when it's already empty!");
        auto v = m_path.back();
        --m_explored[v];
        m_value -= v.Weight();
        m_path.pop_back();
    }
    
    void pop_front()
    {
        assert(!m_path.empty() && "Can't pop when it's already empty!");
        auto v = m_path.front();
        --m_explored[v];
        m_path.pop_front();
        m_value -= m_path.front().Weight();
//         m_path.front().weight = 0;
    }
    
    void clear()
    {
        m_value = 0;
//         m_explored = vector<char>(m_explored.size(),0);
        auto n = m_explored.size();
        m_explored.clear();
        m_explored.resize(n,0);
        m_path.clear();
    }
    
    NeighborNode operator[](size_t i) const { return m_path[i]; }
    NeighborNode& operator[](size_t i) { return m_path[i]; }
    
    bool empty() const
    {
        return m_path.empty();
    }
    
    size_t size() const
    {
        return m_path.size();
    }
    
    template <class Compare>
    NeighborNode first_not_explored_binary(const vector<NeighborNode>& Nodes, node_t start, Compare comp) const
    {
        auto it = std::upper_bound(Nodes.begin(), Nodes.end(), start, comp);
    // 	++it;
        while (it != Nodes.end() && m_explored[*it])
            ++it;
        if (it == Nodes.end())
            return NeighborNode(INVALID_NODE,0);
        return *it;
    }
    
    NeighborNode first_not_explored_binary(const vector<NeighborNode>& Nodes, node_t start) const
    {
        return first_not_explored_binary(Nodes,start,std::less<node_t>());
    }
    
    NeighborNode first_not_explored(const vector<NeighborNode>& Nodes, node_t start) const
    {
        bool seenstart = false;
        for (auto x : Nodes)
        {
            if (x == start)
            {
                seenstart = true;
                continue;
            }	
            
            if (seenstart && !m_explored[x])
                return x;
        }
        return NeighborNode(INVALID_NODE,0);
    }
    
    NeighborNode first_not_explored(const vector<NeighborNode>& Nodes) const
    {
        for (auto x : Nodes)
        {
            if (!m_explored[x])
                return x;
        }
        return NeighborNode(INVALID_NODE,0);
    }
    
    NeighborNode back() const
    {
        return m_path.back();
    }
    
    NeighborNode front() const
    {
        return m_path.front();
    }
    
    
private:
    deque<NeighborNode> m_path;
    vector<char> m_explored;
//     vector<bool> m_explored;
    long m_value;
public:
    const decltype(m_path)& data() const { return m_path; }

};

// inline std::ostream& operator<<(std::ostream& os, const Path& P)
// {
//     auto B = P.get_path();
//     for (size_t i = 0; i < B.size()-1; ++i)
// 	{
// 	}
// 	os << P.get_digraph()->get_vertex_name(B.back()) << endl;
// 	return os;
// }

struct Edge
{
	Edge() : from(INVALID_NODE), to(INVALID_NODE), weight(0) {}
	Edge(node_t f, node_t t, weight_t w = 1) : from(f), to(t), weight(w) {}
	node_t operator[](bool i)
	{
		if (i)
			return to;
		return from;
	}
	node_t from;
	node_t to;
	weight_t weight;
};


class PseudoTopoOrder;

using ParamType = std::array<double, 8>;


class DiGraph
{
public:
    explicit DiGraph(node_t numberOfNodes);
    explicit DiGraph(const vector<string>& vertex_names);

	//		Graph modification functions
	void add_edge(node_t from, node_t to, weight_t weight = 1);
	void add_edge(const string& from, const string& to, weight_t weight = 1);
	
	// Find connected components, heuristics, etc.
	void process(); // WARNING! Since it removes and renames nodes, after "processing" your nodes might have been renamed!

	// Get Graph Info
	node_t get_size() const { return m_n; }
	node_t num_vertices() const { return m_n; }
	size_t num_edges() const;
    
    const string& get_vertex_name(node_t i) const { return m_node_names[i]; }
    node_t get_vertex_index(const string& name) const 
    { 
        auto it = m_namemap.find(name);
        return (*it).second; 
        
    }
    const vector<string>& get_vertex_names() const { return m_node_names; } 
    
    void set_parameters(const ParamType& new_params) 
    {
        m_params = new_params;
        heuristic_processing();
    }
    
    static DiGraph ReadFromStdin(int n, int m);
    
	int rank_out(node_t node) const { return 0; }
	int rank_in(node_t node) const { return 0; }
	
	inline const vector<NeighborNode>& outneighbors(node_t n) const { return m_outgraph[n]; }
	inline const vector<NeighborNode>& inneighbors(node_t n) const { return m_ingraph[n]; }
// 	inline const weight_t edge_value(node_t from, node_t to) const { return m_edge_values(from,to); }
	
	// This is the order in which the outneighbors are sorted
	inline bool ex_compare(node_t a, node_t b) const { return m_basic_topological_ordering_inverse[a] < m_basic_topological_ordering_inverse[b]; }

	// This is the order in which the outneighbors are sorted
	inline bool in_compare(node_t a, node_t b) const { return m_basic_topological_ordering_inverse_in[a] < m_basic_topological_ordering_inverse_in[b]; }
	
	// Functions related to paths
	
	void dfs_search_path_forward(Path& P, double maxnumseconds) const;
	void dfs_search_path_reverse(Path& P, double maxnumseconds) const;
	
	Path dfs_search_path_forward(node_t start, double maxnumseconds) const;
	Path dfs_search_path_reverse(node_t start, double maxnumseconds) const;

	Path dfs_search(double maxnumsecondswithoutimprovement) const;
    void pto_search(Path& A, double maxnumseconds) const;
    
	PseudoTopoOrder get_random_pseudotopological_order() const;
	//Paths
	Path FindLongestSimplePath(double numseconds);
	Path FindLongestSimplePathPureDFS(double numseconds);
	
	bool TopologicalLessThan(node_t a, node_t b) const { return m_basic_topological_ordering_inverse[a] < m_basic_topological_ordering_inverse[b]; }
	
	static DiGraph CreateRandomDiGraph(int n, double p);
	static DiGraph CreateRandomWeightedDiGraph(int n, double p, weight_t minweight, weight_t maxweight);
	
private:
    // Utils for creating the graph
	void remove_bad_nodes();
	void remove_nodes(vector<node_t>& toRemove);
	
	DiGraph with_nodes_removed(vector<node_t>& toRemove) const;
	
	void heuristic_processing();
	double get_heuristic_out(node_t node);
	double get_heuristic_in(node_t node);
	
// 	void branch_and_bound();
	
	// Utils to find connected components
// 	void find_weakly_connected_components();
	void find_strongly_connected_components();
	void find_strongly_connected_componentsBOOST();
	void topo_fill_order( node_t v, vector< char >& visited, stack< node_t >& Stack ); 
	void topo_fill_order( node_t v, vector< char >& visited, vector< node_t >& Stack ); 
    void DFSUtil( node_t v, vector< bool >& visited );
    void DFSUtilReversed( node_t v, vector< char >& visited, int current );
//     void DFSUtilWeak(node_t start, int minvalidcoloring);
	
protected:
	// DiGraph insides
	node_t m_n;
	vector<vector<NeighborNode>> m_outgraph;
	vector<vector<NeighborNode>> m_ingraph;

private:
	bool m_processed;
	//Heuristics
	vector<double> m_heuristic_out;
	vector<double> m_heuristic_in;
	
	vector<node_t> m_basic_topological_ordering;
	vector<node_t> m_basic_topological_ordering_in;
	vector<node_t> m_basic_topological_ordering_inverse;
	vector<node_t> m_basic_topological_ordering_inverse_in;
	
    vector<string> m_node_names;
    unordered_map<string, node_t> m_namemap;
    
    
    ParamType m_params {{-43,31,11,58,-4,23,43,45}};
//     ParamType m_params {{1,4,16,64,1,4,16,64}};
    
	friend class PseudoTopoOrder;
};

DiGraph DiGraph::ReadFromStdin(int n, int m)
{
	DiGraph D(n);
	for (int i = 0; i < m; ++i)
	{
		int x,y;
		cin >> x >> y;
		--x;
		--y;
		D.add_edge(x,y);
		D.add_edge(y,x);
	}
	return D;
}


std::ostream& operator<<(std::ostream& os, const DiGraph& M);
std::ostream& operator<<(std::ostream& os, const ParamType& a);



void ExpandGreedyBack(const DiGraph& G, Path& P);


void ExpandGreedyFront(const DiGraph& G, Path& P);

template <class Compare>
bool dfs_outnext(const DiGraph& G, Path& P, Compare comp)
{
    auto lastNode = P.back();
    
    auto Neighs = &G.outneighbors(lastNode);

    auto t = P.first_not_explored(*Neighs);

    while (t == INVALID_NODE && P.size() > 1) //this means all nodes in Neigh have been explored
    {
        lastNode = P.back();
        P.pop_back();
        int father = P.back();
        Neighs = &G.outneighbors(father);
        t = P.first_not_explored_binary(*Neighs,lastNode, comp);
    }
    if (t == INVALID_NODE)
        return false; // this means we have finished DFS!!
    P.push_back(t);
	ExpandGreedyBack(G,P);
    return true;
}

template <class Compare>
bool dfs_innext(const DiGraph& G, Path& P, Compare comp)
{
    auto firstNode = P.front();
    
    auto Neighs = &G.inneighbors(firstNode);

    auto t = P.first_not_explored(*Neighs);

    while (t == INVALID_NODE && P.size() > 1) //this means all nodes in Neigh have been explored
    {
        firstNode = P.front();
        P.pop_front();
        int father = P.front();
        Neighs = &G.inneighbors(father);
        t = P.first_not_explored_binary(*Neighs,firstNode, comp);
    }
    if (t == INVALID_NODE)
        return false; // this means we have finished DFS!!
    P.push_front(t);
	ExpandGreedyFront(G,P);
    return true;
}


class PseudoTopoOrder
{
public:
	PseudoTopoOrder(const DiGraph& m, const vector<node_t>& ts, const vector<node_t>& tsi) : 
	pto(ts), 
	pto_inverse(tsi), 
	dynamic_programming(ts.size(),0), 
	best_index(0), 
	first_unknown(0),
	path_filled(false),
	m_path(),
	m_parent(m) {}

	size_t size() const { return dynamic_programming.size(); }
	
	inline void set(int i, int v)
	{
		pto[i] = v;
		pto_inverse[v] = i;
		AnnounceModification(i);
	}

	inline void transpose(int i, int j)
	{
		swap(pto[i],pto[j]);
		pto_inverse[pto[i]] = i;
		pto_inverse[pto[j]] = j;
		AnnounceModification(i);
		AnnounceModification(j);
	}
	
	void transfer(int a, int b, int c, int d, int h);
	
	void reverse_order(int a, int b);
	
	Path get_path();

	void shuffle(int  a, int b); // this assumes already a < b and they belong to the same component
	sumweight_t  Value() { FillDP(); return dynamic_programming[best_index]; }
	void apply(const Path& P);
	void apply(const Path& P, int u, int v);
// 	void random_apply(const Path& P);
	
	bool eXtreme_edge_opener();
	
	void open_edges_until_no_more_improvement_found(double maxnumseconds);
	
	void open_edge();
	
	void randomize();
	
	// sorts range from a to b (must be same scc) according to a heuristic so as to maximize the improvement chance.
	void heuristic_sort(int a, int b, int numtimes);
	int get_outneighbor_in_range(int a, int b, node_t node);

private:
	void FillDP();
	void FillPath();
	void RecalcTopoInverse();
	
	inline void AnnounceModification(node_t i) { if  (i < first_unknown) first_unknown = i; path_filled = false; }
	inline void transpose_na(int i, int j)
	{
		swap(pto[i],pto[j]);
		pto_inverse[pto[i]] = i;
		pto_inverse[pto[j]] = j;
	}
	
	inline void set_na(int i, int v)
	{
		pto[i] = v;
		pto_inverse[v] = i;
	}
	
	vector<node_t> pto;
	vector<node_t> pto_inverse;
	vector<sumweight_t> dynamic_programming;
	int best_index;
	int first_unknown;
	bool path_filled;
	vector<NeighborNode> m_path; //Path is filled with indices in REVERSE ORDER
	const DiGraph& m_parent;
};



void PseudoTopoOrder::shuffle(int a, int b)
{
	random_shuffle(pto.begin()+a, pto.begin()+b);
	for (int i = a; i < b; ++i)
	{
		pto_inverse[pto[i]] = i;
	}
	AnnounceModification(a);
}

void PseudoTopoOrder::RecalcTopoInverse()
{
	int n = pto.size();
	for (int i = 0; i < n; ++i)
	{
		pto_inverse[pto[i]] = i;
	}
	AnnounceModification(0);
}

void PseudoTopoOrder::apply(const Path& P)
{
	auto it = P.get_path().begin();
	int fu = -1;
	int n = pto.size();
	for (int i = 0; i < n; ++i)
	{
		int x = pto[i];
		if (P.is_node_in_path(x))
		{
			if (fu == -1)
				fu = i;
			pto[i] = *it;
			pto_inverse[*it] = i;
			++it;
		}
	}
	AnnounceModification(fu);
}

void PseudoTopoOrder::apply(const Path& P, int u, int v)
{

	vector<int> indexesofPbetweenuandv;
	vector<int> nodesofPbetweenuandv;
	for (auto x : P.get_path())
	{
		int index = pto_inverse[x];
		if (u <= index && index < v)
		{
			indexesofPbetweenuandv.push_back(index);
			nodesofPbetweenuandv.push_back(x);
		}
	}
	sort(indexesofPbetweenuandv.begin(), indexesofPbetweenuandv.end());
	int i = 0;
	for (auto p : indexesofPbetweenuandv)
	{
		pto[p] = nodesofPbetweenuandv[i];
		pto_inverse[pto[p]] = p;
		++i;
	}
	AnnounceModification(u);
}


Path PseudoTopoOrder::get_path()
{
	FillPath();
	Path P(size());
	for (auto i : m_path)
	{
		P.emplace_front(pto[i],i.Weight());
	}
	return P;
}

void PseudoTopoOrder::FillDP()
{
	int n = pto.size();
	int best_val = 0;
	if (best_index < first_unknown)
		best_val = dynamic_programming[best_index];
	
	for ( ; first_unknown < n; ++first_unknown)
	{
		int u = pto[first_unknown];
		dynamic_programming[first_unknown] = 0;
		
		auto& neigh = m_parent.inneighbors(u);
		for (auto v : neigh)
		{
			auto j = pto_inverse[v];
			if (first_unknown < j) // should be ignored
				continue;
			auto candidate = dynamic_programming[j] + v.Weight();
			if (candidate > dynamic_programming[first_unknown])
			{
				dynamic_programming[first_unknown] = candidate;
				if (candidate > best_val)
				{
					best_val = candidate;
					best_index = first_unknown;
				}
			}
		}
	}
}

void PseudoTopoOrder::randomize()
{
	random_shuffle(pto.begin(), pto.end());
	for (int i = 0; i < pto.size(); ++i)
	{
		pto_inverse[pto[i]] = i;
	}
	
	AnnounceModification(0);
}

void PseudoTopoOrder::transfer(int a, int b, int c, int d, int h)
{
	if (h == b-a)
	{
		return;
	}
	
	while (h > b-a) // we must transfer from end to start
	{
		transpose(b,c);
		++b;
		++c;
	}
	
	
	while (h < b-a) // we must transfer from start to end
	{
		--b;
		--c;
		transpose(b,c);
	}
}

void PseudoTopoOrder::reverse_order(int a, int b)
{
	std::reverse(pto.begin()+a, pto.begin()+b);
	for (int i = a; i < b; ++i)
	{
		pto_inverse[pto[i]] = i;
	}
	AnnounceModification(a);
}

void PseudoTopoOrder::heuristic_sort(int a, int b, int numtimes)
{
	if (a == b)
		return;
	for (int r = b-1; r >= a; --r)
	{
		node_t node = pto[r];
		int iu = get_outneighbor_in_range(a,r,node);
		if (iu != -1)
			transpose(iu,r);
	}
	for (int i = 0; i < numtimes; ++i)
	{
		int r = rand()%(b-a)+a;
		node_t node = pto[r];
		int iu = get_outneighbor_in_range(a,r,node);
		if (iu != -1)
			transpose(iu,r);
	}
}

int PseudoTopoOrder::get_outneighbor_in_range(int a, int b, node_t node)
{
	for (auto u : m_parent.outneighbors(node))
	{
		int iu = pto_inverse[u];
		if (a <= iu && iu < b)
			return iu;
	}
	return -1;
}

bool PseudoTopoOrder::eXtreme_edge_opener()
{
	auto oldval = Value();
	FillPath();

// 	for (const auto& x : m_parent.big_scc())
// 	{
		int a = 0;
		int d = pto.size();
// 		if (d - a < 5)
// 			continue;
		
		// true true true *false false
		auto f = std::partition_point(m_path.rbegin(), m_path.rend(), [this,a](node_t i) -> bool
		{
			return i < a;
		});

		int aa = a;
		while (*f < d && f != m_path.rend())
		{
			if (*f != aa)
				transpose(aa,*f);
			++f;
			++aa;
		}
		
		int c = d;
		int b = aa;
		
		auto order = range<int>(b-a+1);
		random_shuffle(order.begin(), order.end());
		shuffle(b,c);
		for (auto h : order)
		{
			transfer(a,b,c,d,h);
			int total = b-a + d-c;
			b = a+h;
			c = d-(total-h);
			heuristic_sort(b,c,10000);
			if (Value() > oldval)
			{
				FillPath();
				return true;
			}
		}
// 	}
	FillPath();
	return false;
}

void PseudoTopoOrder::open_edges_until_no_more_improvement_found(double maxnumseconds)
{
	Chronometer C;
	while (C.Peek() < maxnumseconds)
	{
		eXtreme_edge_opener();
	}
}


void PseudoTopoOrder::FillPath()
{
	if (path_filled)
		return;
	m_path.clear();
	FillDP();
	auto m = Value();
	weight_t currweight = 0;
	int a = best_index;
	path_filled = true;

	while (true)
	{
		bool found = false;
		node_t u = pto[a];
		m_path.emplace_back(a,currweight);
		for (auto v : m_parent.inneighbors(u))
		{
			node_t b = pto_inverse[v];
			if (b > a)
				continue;
			if (dynamic_programming[b] == dynamic_programming[a] - v.Weight())
			{
				a = b;
				m = dynamic_programming[b];
				currweight = v.Weight();
				found = true;
				break;
			}
		}
		if (!found)
		{
			return;
		}
	}
}


DiGraph::DiGraph(node_t numNodes) :
			m_n(numNodes),
			m_outgraph(numNodes),
			m_ingraph(numNodes),
			m_processed(false),
			m_heuristic_out(),
			m_heuristic_in(),
			m_basic_topological_ordering(),
			m_basic_topological_ordering_in(),
			m_basic_topological_ordering_inverse(),
			m_basic_topological_ordering_inverse_in(),
			m_node_names(numNodes),
			m_namemap()
{
	for (node_t i = 0; i < numNodes; ++i)
    {
        m_node_names[i] = to_string(i);
        m_namemap[to_string(i)] = i;
    }
    
}

DiGraph::DiGraph(const vector<string>& vnames) :
			m_n(vnames.size()),
			m_outgraph(vnames.size()),
			m_ingraph(vnames.size()),
			m_processed(false),
			m_heuristic_out(),
			m_heuristic_in(),
			m_basic_topological_ordering(),
			m_basic_topological_ordering_in(),
			m_basic_topological_ordering_inverse(),
			m_basic_topological_ordering_inverse_in(),
			m_node_names(vnames),
			m_namemap()
{
	for (node_t i = 0; i < vnames.size(); ++i)
    {
        m_namemap[vnames[i]] = i;
    }
    
}

void DiGraph::add_edge(node_t from, node_t to, weight_t weight)
{
// 	if (m_edge_values(from,to) == 0)
// 	{
		m_outgraph[from].emplace_back(to,weight);
		m_ingraph[to].emplace_back(from,weight);
// 	}
// 	m_edge_values(from,to) = weight;
	m_processed = false;
}

void DiGraph::add_edge(const string& from, const string& to, weight_t weight)
{
    add_edge(m_namemap[from],m_namemap[to],weight);
}


void DiGraph::process()
{
	if (!m_processed)
	{
		heuristic_processing();
		
		m_processed = true;
	}
}

Path DiGraph::dfs_search(double mnswi) const
{
	Chronometer C;
	Path A = dfs_search_path_forward(m_basic_topological_ordering[0],mnswi);
	for (int i = 1; i < min(4,num_vertices()); ++i)
	{
		Path P = dfs_search_path_forward(m_basic_topological_ordering[i],mnswi);
		if (P.value() > A.value())
			A = P;
	}
    return A;
}


Path DiGraph::FindLongestSimplePath(double numseconds)
{
    Chronometer C;
	process();
	
	double dfstime = 0.02 + numseconds/20.0; 
	
	Path best = dfs_search(dfstime);
// 	double timeleft = numseconds-C.Peek();
	
	
// 	pto_search(best,timeleft);
	
	return best;
}

void DiGraph::pto_search(Path& A, double maxnumseconds) const
{
	Chronometer C;
	
    PseudoTopoOrder PTO = get_random_pseudotopological_order();
	PTO.apply(A);
	
	PTO.open_edges_until_no_more_improvement_found(maxnumseconds);
	
	
    if (A.value() < PTO.Value())
        A = PTO.get_path();
	
	
}
size_t DiGraph::num_edges() const
{
	size_t toReturn = 0;
	for (node_t i = 0; i < m_n; ++i)
	{
		toReturn += m_outgraph[i].size();
	}
	return toReturn;
}


void DiGraph::dfs_search_path_forward(Path& P, double maxnumseconds) const
{
	ExpandGreedyBack(*this,P);
	
	Chronometer C;
	Path Q = P;
	auto comp = [this](node_t a, node_t b)
	{
		return ex_compare(a,b);
	};
	while (C.Peek() < maxnumseconds && dfs_outnext(*this,Q,comp))
	{
		if (Q.value() > P.value())
		{
			P = Q;
			C.Reset();
		}
	}
}

void DiGraph::dfs_search_path_reverse(Path& P, double maxnumseconds) const
{
	ExpandGreedyBack(*this,P);
	
	Chronometer C;
	Path Q = P;
	auto comp = [this](node_t a, node_t b)
	{
		return in_compare(a,b);
	};
	while (C.Peek() < maxnumseconds && dfs_innext(*this,Q,comp))
	{
		if (Q.value() > P.value())
		{
			P = Q;
			C.Reset();
		}
	}
}

Path DiGraph::dfs_search_path_forward(node_t start, double maxnumseconds) const
{
	Path P(num_vertices(),start);
	dfs_search_path_forward(P,maxnumseconds);
	return P;
}

Path DiGraph::dfs_search_path_reverse(node_t start, double maxnumseconds) const
{
	Path P(num_vertices(),start);
	dfs_search_path_reverse(P,maxnumseconds);
	return P;
}

void DiGraph::heuristic_processing()
{
	m_heuristic_out.resize(m_n,0);
	m_heuristic_in.resize(m_n,0);
	
	// 	double maxtime = 0.2/n;
	
// 	#pragma omp parallel for
	for (node_t i = 0; i < m_n; ++i)
	{
		m_heuristic_out[i] = get_heuristic_out(i);
		m_heuristic_in[i] = get_heuristic_in(i);
	}
	
	m_basic_topological_ordering = range<node_t>(m_n);
	
	for (auto a : m_basic_topological_ordering)
	{
		if (a >= m_n) cout << "SUPER ERROR!" << endl;
		assert(a < m_n);
	}
	
	sort (m_basic_topological_ordering.begin(), m_basic_topological_ordering.end(), [this](node_t a, node_t b) -> bool
	{
		assert(a < m_n && b < m_n);
		if (rank_out(a) == rank_out(b))
		{
			if (m_heuristic_out[a] == 0)
			{
				return false;
			}
			if (m_heuristic_out[b] == 0)
			{
				return true;
			}
			
			if (m_ingraph[a].size() == 1 )
				return true;
			if (m_ingraph[b].size() == 1)
				return false;
			return m_heuristic_out[a] < m_heuristic_out[b];
		}
		
		
		return rank_out(a) > rank_out(b);
		
	});
	
	m_basic_topological_ordering_inverse.resize(m_n);
	for (node_t i = 0; i < m_n; ++i)
	{
		m_basic_topological_ordering_inverse[m_basic_topological_ordering[i]] = i; 
	}
	
	m_basic_topological_ordering_in = range<node_t>(m_n);
	sort (m_basic_topological_ordering_in.begin(), m_basic_topological_ordering_in.end(), [this](node_t a, node_t b) -> bool
	{
		if (rank_in(a) < rank_in(b))
			return true;
		if (rank_in(a) > rank_in(b))
			return false;
		
// 		if (m_heuristic_in[a] == 0 && m_heuristic_in[b] == 0)
// 		{
// 			return vertex_values[a] > vertex_values[b];
// 		}
		
		if (m_heuristic_in[a] == 0)
			return false;
		if (m_heuristic_in[b] == 0)
			return true;
		
// 		if (ingraph[a].size() == 1 && ingraph[b].size() == 1)
// 			return heuristic_out[a] < heuristic_out[b];
		
		if (m_outgraph[a].size() == 1 )
			return true;
		if (m_outgraph[b].size() == 1)
			return false;
		
		return m_heuristic_in[a] < m_heuristic_in[b];
	});
// 	random_shuffle(basic_topological_ordering.begin(), basic_topological_ordering.end());
	m_basic_topological_ordering_inverse_in.resize(m_n);
	for (node_t i = 0; i < m_n; ++i)
	{
		m_basic_topological_ordering_inverse_in[m_basic_topological_ordering_in[i]] = i; 
	}
	
	
	for (size_t i = 0; i < m_n; ++i)
	{
// 		random_shuffle(outgraph[i].begin(), outgraph[i].end());
// 		random_shuffle(ingraph[i].begin(), ingraph[i].end());
		sort(m_outgraph[i].begin(), m_outgraph[i].end(), [this] (node_t a, node_t b) -> bool
		{
			return ex_compare(a,b);
		});
		
		sort(m_ingraph[i].begin(), m_ingraph[i].end(), [this] (node_t a, node_t b) -> bool
		{
			return in_compare(a,b);
		});
	}
	
}

PseudoTopoOrder DiGraph::get_random_pseudotopological_order() const
{
	vector<int> topo_sort(num_vertices());
	for (int i = 0; i < topo_sort.size(); ++i)
	{
		topo_sort[i] = i;
	}
	random_shuffle(topo_sort.begin(),topo_sort.end());
	vector<int> topo_sort_inverse(num_vertices());
	for (int i = 0; i < topo_sort.size(); ++i)
	{
		topo_sort_inverse[topo_sort[i]] = i;
	}
	return PseudoTopoOrder(*this, std::move(topo_sort),std::move(topo_sort_inverse));
}


double DiGraph::get_heuristic_out(node_t node)
{
    double a1 = m_params[0];
	double a2 = m_params[1];
	double a3 = m_params[2];
	double a4 = m_params[3];
	double heuristicex = 0;
	
	for (auto x : m_outgraph[node])
	{
		heuristicex += a1;
		for (auto y : m_outgraph[x])
		{
			heuristicex += a2;
			for (auto z : m_outgraph[y])
			{
				heuristicex += a3+a4*m_outgraph[z].size();
// 				for (auto r : outgraph[z])
// 				{
// 					heuristicex += a4+a5*outgraph[r]./*size()*/;
// 				}
			}
		}
	}
	return heuristicex;
}


double DiGraph::get_heuristic_in(node_t node)
{
// 	return 0;
	double a1 = m_params[4];
	double a2 = m_params[5];
	double a3 = m_params[6];
	double a4 = m_params[7];
	double heuristicin = 0;

	for (auto x : m_ingraph[node])
	{
		heuristicin += a1;
		for (auto y : m_ingraph[x])
		{
			heuristicin  += a2;
			for (auto z : m_ingraph[y])
			{
				heuristicin  += a3+a4*m_ingraph[z].size(); 
			}
		}
	}
	return heuristicin;
}

DiGraph DiGraph::CreateRandomDiGraph(int n, double p)
{
	DiGraph D(n);
	
	for (int i = 0; i < n; ++i)
	{
		for (int j = i+1; j < n; ++j)
		{
			if (probability_of_true(p))
			{
				int a = i;
				int b = j;
				if (rand()%2 == 1) swap(a,b);
				D.add_edge(a,b);
			}
		}
	}
	return D;
}


DiGraph DiGraph::CreateRandomWeightedDiGraph(int n, double p, weight_t minweight, weight_t maxweight)
{
	DiGraph D(n);
	
	for (int i = 0; i < n; ++i)
	{
		for (int j = i+1; j < n; ++j)
		{
			if (probability_of_true(p))
			{
				int a = i;
				int b = j;
				weight_t w = random_real(minweight,maxweight);
				if (rand()%2 == 1) swap(a,b);
				D.add_edge(a,b,w);
			}
		}
	}
// 	D.process();
	return D;
}

std::ostream& operator<<(std::ostream& os, const ParamType& a)
{
	os << endl << "\tex: ";
	for (int i = 0; i < 4; ++i)
		os << a[i] << " ";
	os << endl;
	
	os << "\tin: ";
	for (int i = 4; i < 8; ++i)
		os << a[i] << " ";
	os << endl;
	return os;
}

std::ostream& operator<<(std::ostream& os, const DiGraph& M)
{
    cout << "Digraph on " << M.num_vertices() << " vertices: " << M.get_vertex_names() << endl;
    for (int i = 0; i < M.num_vertices(); ++i)
    {
        string name = M.get_vertex_name(i);
        for (auto v : M.outneighbors(i))
        {
            string vname = M.get_vertex_name(v);
        }
    }
    return os;
}

void ExpandGreedyBack(const DiGraph& G, Path& P)
{
	while (true)
	{
		auto l = P.back();
		auto& Neighs = G.outneighbors(l);
		
		auto t = P.first_not_explored(Neighs);
		if (t == INVALID_NODE)
			break;
		P.emplace_back(t,t.Weight());
	}
}


void ExpandGreedyFront(const DiGraph& G, Path& P)
{
	while (true)
	{
		auto l = P.front();
		auto& Neighs = G.inneighbors(l);
		
		auto t = P.first_not_explored(Neighs);
		if (t == INVALID_NODE)
			break;
		P.emplace_front(t,t.Weight());
	}
}



int main() 
{
	
	int n,m;
	cin >> n >> m;
	DiGraph D = DiGraph::ReadFromStdin(n,m);
	auto P = D.FindLongestSimplePath(1.5);
	cout << P.size() << endl;
	for (int p : P.data())
		cout << p+1 << " ";
	return 0; 
}

----------
====================
----------
ALGORITHMS.435
advanced
----------
PROBLEM STATEMENT:
Sam invented a new puzzle game played on an [expression].

The Moves

A move consists of two steps:


Choose a sub-square of [expression].
Rotate the sub-square in the clockwise direction.


For example: 



We describe a move as the clockwise rotation of a [expression].

Good Pairs of Cells

A pair of cell is good if one of the following is true:


They're located in the same row and the number in the left cell is less than the number in the right cell. 
They're located in the same column and the number in the upper cell is less than the number in the lower cell.


The diagram below depicts all the good pairs of cells located in the same row:



The diagram below depicts all the good pairs of cells located in the same column:



Goodness of a Square

We define the goodness of a sub-square to be the total number of good pairs of cells in the sub-square.

The Goal

Given the initial value of [expression] moves. Then print the necessary moves according to the Output Format specified below.
----------
TOP SOLUTION:
----------
#include <algorithm>
#include <bitset>
#include <cassert>
#include <climits>
#include <chrono>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <fstream>
#include <functional>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <tuple>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <utility>

using namespace std;

static default_random_engine dre;

class CField
{
public:
	unsigned n;
	vector<unsigned> vmap;

	CField() : n(0) {}
	CField(unsigned _n) : n(_n) { vmap.resize(n*n); }

	void Set(unsigned pos, unsigned value) { vmap[pos] = value;	}

	void Read()
	{
		cin >> n;
		vmap.resize(n*n);
		for (unsigned i = 0; i < n * n; ++i)
		{
			int x;
			cin >> x;
			Set(i, x - 1);
		}
		AddCurrentPenalty();
	}

	static unsigned PenaltyBase(unsigned n, const vector<unsigned>& vmap)
	{
		unsigned penalty = 0;
		for (unsigned i = 0; i < n; ++i)
		{
			for (unsigned j = 0; j < n; ++j)
			{
				unsigned x = vmap[i * n + j];
				for (unsigned i1 = i + 1; i1 < n; ++i1)
				{
					if (vmap[i1 * n + j] < x) ++penalty;
				}
				for (unsigned j1 = j + 1; j1 < n; ++j1)
				{
					if (vmap[i * n + j1] < x) ++penalty;
				}
			}
		}
		return penalty;
	}

	unsigned PenaltyBase() const { return PenaltyBase(n, vmap); }

	void Rotate(unsigned i, unsigned j, unsigned k)
	{
		unsigned kh0 = k / 2, kh1 = (k + 1) / 2;
		for (unsigned i1 = 0; i1 < kh0; ++i1)
		{
			for (unsigned j1 = 0; j1 < kh1; ++j1)
			{
				unsigned x = vmap[(i1 + i) * n + (j1 + j)];
				Set((i1 + i) * n + (j1 + j), vmap[(k - j1 - 1 + i) * n + (i1 + j)]);
				Set((k - j1 - 1 + i) * n + (i1 + j), vmap[(k - i1 - 1 + i) * n + (k - j1 - 1 + j)]);
				Set((k - i1 - 1 + i) * n + (k - j1 - 1 + j), vmap[(j1 + i) * n + (k - i1 - 1 + j)]);
				Set((j1 + i) * n + (k - i1 - 1 + j), x);
			}
		}
	}

	void Rotate(const vector<unsigned>& v)
	{
		assert(v.size() == 3);
		Rotate(v[0], v[1], v[2]);
	}

	void RotateI(unsigned i, unsigned j, unsigned k)
	{
		unsigned kh0 = k / 2, kh1 = (k + 1) / 2;
		for (unsigned i1 = 0; i1 < kh0; ++i1)
		{
			for (unsigned j1 = 0; j1 < kh1; ++j1)
			{
				unsigned x = vmap[(i1 + i) * n + (j1 + j)];
				Set((i1 + i) * n + (j1 + j), vmap[(j1 + i) * n + (k - i1 - 1 + j)]);
				Set((j1 + i) * n + (k - i1 - 1 + j), vmap[(k - i1 - 1 + i) * n + (k - j1 - 1 + j)]);
				Set((k - i1 - 1 + i) * n + (k - j1 - 1 + j), vmap[(k - j1 - 1 + i) * n + (i1 + j)]);
				Set((k - j1 - 1 + i) * n + (i1 + j), x);
			}
		}
	}

	void RotateI(const vector<unsigned>& v)
	{
		assert(v.size() == 3);
		RotateI(v[0], v[1], v[2]);
	}

	static void CalcAccumSumS(unsigned n, const vector<unsigned>& vmap, vector<vector<unsigned>>& output)
	{
		assert(vmap.size() == n*n);
		if (output.size() != (n + 1))
		{
			output.resize(n + 1);
			for (unsigned i = 0; i < output.size(); ++i)
				output[i].resize(n + 1);
		}
		for (unsigned i = 0; i <= n; ++i)
		{
			output[i][0] = output[0][0] = 0;
		}
		for (unsigned i = 0; i < n; ++i)
		{
			for (unsigned j = 0; j < n; ++j)
			{
				output[i + 1][j + 1] = output[i + 1][j] + output[i][j + 1] - output[i][j] + vmap[i * n + j];
			}
		}
	}

	static void CalcAccumSumS(unsigned n, const vector<unsigned>& vmap, vector<vector<vector<unsigned>>>& output)
	{
		assert(vmap.size() == n*n);
		if (output.size() != 3)
			output.resize(3);
		for (unsigned l = 0; l < 3; ++l)
		{
			if (output[l].size() != (n + 1))
			{
				output[l].resize(n + 1);
				for (unsigned i = 0; i < output[l].size(); ++i)
					output[l][i].resize(n + 1);
			}
		}
		for (unsigned l = 0; l < 3; ++l)
		{
			for (unsigned i = 0; i <= n; ++i)
			{
				output[l][i][0] = output[l][0][0] = 0;
			}
		}
		for (unsigned i = 0; i < n; ++i)
		{
			for (unsigned j = 0; j < n; ++j)
			{
				output[0][i + 1][j + 1] = output[0][i + 1][j] + output[0][i][j + 1] - output[0][i][j] + vmap[i * n + j];
				output[1][i + 1][j + 1] = output[1][i + 1][j] + output[1][i][j + 1] - output[1][i][j] + i * vmap[i * n + j];
				output[2][i + 1][j + 1] = output[2][i + 1][j] + output[2][i][j + 1] - output[2][i][j] + j * vmap[i * n + j];
			}
		}
	}

	static void CalcAccumSumS(unsigned n, const vector<unsigned>& vmap, double noise_amplitude, vector<vector<vector<double>>>& output)
	{
		static uniform_real_distribution<double> urd(0.0, 1.0);
		assert(vmap.size() == n*n);
		if (output.size() != 3)
			output.resize(3);
		for (unsigned l = 0; l < 3; ++l)
		{
			if (output[l].size() != (n + 1))
			{
				output[l].resize(n + 1);
				for (unsigned i = 0; i < output[l].size(); ++i)
					output[l][i].resize(n + 1);
			}
		}
		for (unsigned l = 0; l < 3; ++l)
		{
			for (unsigned i = 0; i <= n; ++i)
			{
				output[l][i][0] = output[l][0][0] = 0;
			}
		}
		for (unsigned i = 0; i < n; ++i)
		{
			for (unsigned j = 0; j < n; ++j)
			{
				double d = vmap[i * n + j] + noise_amplitude * urd(dre);
				output[0][i + 1][j + 1] = output[0][i + 1][j] + output[0][i][j + 1] - output[0][i][j] + d;
				output[1][i + 1][j + 1] = output[1][i + 1][j] + output[1][i][j + 1] - output[1][i][j] + i * d;
				output[2][i + 1][j + 1] = output[2][i + 1][j] + output[2][i][j + 1] - output[2][i][j] + j * d;
			}
		}
	}

	void CalcAccumSum(vector<vector<unsigned>>& output) const { CalcAccumSumS(n, vmap, output); }
	void CalcAccumSum(vector<vector<vector<unsigned>>>& output) const { CalcAccumSumS(n, vmap, output); }
	void CalcAccumSum(double noise_amplitude, vector<vector<vector<double>>>& output) const { CalcAccumSumS(n, vmap, noise_amplitude, output); }

	static void FindBestMove(unsigned n, const vector<vector<vector<unsigned>>>& accum, vector<unsigned>& output_move)
	{
		output_move.resize(3); output_move[2] = 0;
		unsigned best_score = 0;
		for (unsigned k = 2; k <= n; ++k)
		{
			for (unsigned i = 0; i + k <= n; ++i)
			{
				for (unsigned j = 0; j + k <= n; ++j)
				{
					unsigned a000 = accum[0][i][j];
					unsigned a001 = accum[0][i][j + k];
					unsigned a010 = accum[0][i + k][j];
					unsigned a011 = accum[0][i + k][j + k];
					unsigned a100 = accum[1][i][j];
					unsigned a101 = accum[1][i][j + k];
					unsigned a110 = accum[1][i + k][j];
					unsigned a111 = accum[1][i + k][j + k];
					unsigned a200 = accum[2][i][j];
					unsigned a201 = accum[2][i][j + k];
					unsigned a210 = accum[2][i + k][j];
					unsigned a211 = accum[2][i + k][j + k];

					unsigned s0 = a011 + a000 - a001 - a010;
					unsigned s1 = a111 + a100 - a101 - a110;
					unsigned s2 = a211 + a200 - a201 - a210;

					if (best_score + 2 * s1 < (k - 1 + 2 * i) * s0)
					{
						best_score = (k - 1 + 2 * i) * s0 - 2 * s1;
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
					if (2 * best_score + 2 * (s1 + s2) < 2 * (k - 1 + i + j) * s0)
					{
						best_score = (k - 1 + i + j) * s0 - (s1 + s2);
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
					if (3 * best_score + 2 * s2 < (k - 1 + 2 * j) * s0)
					{
						best_score = ((k - 1 + 2 * j) * s0 - 2 * s2) / 3;
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
				}
			}
		}
	}

	static void FindBestMove(unsigned n, const vector<vector<vector<double>>>& accum, vector<unsigned>& output_move)
	{
		output_move.resize(3); output_move[2] = 0;
		double best_score = 0;
		for (unsigned k = 2; k <= n; ++k)
		{
			for (unsigned i = 0; i + k <= n; ++i)
			{
				for (unsigned j = 0; j + k <= n; ++j)
				{
					double a000 = accum[0][i][j];
					double a001 = accum[0][i][j + k];
					double a010 = accum[0][i + k][j];
					double a011 = accum[0][i + k][j + k];
					double a100 = accum[1][i][j];
					double a101 = accum[1][i][j + k];
					double a110 = accum[1][i + k][j];
					double a111 = accum[1][i + k][j + k];
					double a200 = accum[2][i][j];
					double a201 = accum[2][i][j + k];
					double a210 = accum[2][i + k][j];
					double a211 = accum[2][i + k][j + k];

					double s0 = a011 + a000 - a001 - a010;
					double s1 = a111 + a100 - a101 - a110;
					double s2 = a211 + a200 - a201 - a210;

					if (best_score + 2 * s1 < (k - 1 + 2 * i) * s0)
					{
						best_score = (k - 1 + 2 * i) * s0 - 2 * s1;
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
					if (2 * best_score + 2 * (s1 + s2) < 2 * (k - 1 + i + j) * s0)
					{
						best_score = (k - 1 + i + j) * s0 - (s1 + s2);
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
					if (3 * best_score + 2 * s2 < (k - 1 + 2 * j) * s0)
					{
						best_score = ((k - 1 + 2 * j) * s0 - 2 * s2) / 3;
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
				}
			}
		}
	}

	void FindBestMoveBase(vector<unsigned>& output_move)
	{
		output_move.resize(3); output_move[2] = 0;
		unsigned best_score = PenaltyBase();
		for (unsigned k = 2; k <= n; ++k)
		{
			for (unsigned i = 0; i + k <= n; ++i)
			{
				for (unsigned j = 0; j + k <= n; ++j)
				{
					Rotate(i, j, k);
					unsigned p = PenaltyBase();
					RotateI(i, j, k);
					if (best_score > p)
					{
						best_score = p;
						output_move[0] = i; output_move[1] = j; output_move[2] = k;
					}
				}
			}
		}
	}

	vector<vector<unsigned>> moves;
	vector<unsigned> penalties;

	void AddCurrentPenalty() { penalties.push_back(PenaltyBase()); }
	void MakeMove(const vector<unsigned>& move)
	{
		moves.push_back(move);
		Rotate(move);
		AddCurrentPenalty();
	}

	unsigned GetBestPenalty() const
	{
		unsigned best_penalty = penalties[0];
		for (unsigned p : penalties)
			best_penalty = min(p, best_penalty);
		return best_penalty;
	}

	void PrintMoves() const
	{
		unsigned best_index = 0;
		for (unsigned i = 1; i < penalties.size(); ++i)
		{
			if (penalties[i] < penalties[best_index])
			{
				best_index = i;
			}
		}
		// assert(penalties[best_index] == penalties.back());
		cout << best_index << endl;
		for (unsigned i = 0; i < best_index; ++i)
		{
			const auto& p = moves[i];
			cout << p[0] + 1 << " " << p[1] + 1 << " " << p[2] << endl;
		}
	}

	void SolveGreedy(double min_noise, double max_noise)
	{
		unsigned moves_so_far = 0;
		unsigned max_moves = 500;
		vector<unsigned> move;
		// vector<vector<unsigned>> accum;
		// vector<vector<vector<unsigned>>> accum;
		vector<vector<vector<double>>> accum;
		for (; moves_so_far < max_moves; ++moves_so_far)
		{
			// CalcAccumSum(accum);
			double noise = (min_noise * moves_so_far + max_noise * (max_moves - moves_so_far - 1)) / (max_moves - 1);
			CalcAccumSum(noise, accum);
			FindBestMove(n, accum, move);
			// FindBestMoveBase(move);
			if (move[2] != 0)
				MakeMove(move);
			else
				break;
		}
		// PrintMoves();
	}
};

int main()
{
	auto start_time = chrono::system_clock::now();
	dre.seed(0);
	CField fbase;
	fbase.Read();
	CField fbest = fbase, ftemp;
	fbest.SolveGreedy(0.0, 0.0);
	unsigned best_penalty = fbest.GetBestPenalty();
	for (; best_penalty > 0;)
	{
		ftemp = fbase;
		ftemp.SolveGreedy(1.0, 1.0);
		unsigned p = ftemp.GetBestPenalty();
		if (best_penalty > p)
		{
			best_penalty = p;
			fbest = ftemp;
		}
		auto now_time = chrono::system_clock::now();
		auto time_ms = chrono::duration_cast<std::chrono::milliseconds>(now_time - start_time);
		if (time_ms.count() > 1800)
			break;
	}
	fbest.PrintMoves();
	return 0;
}

----------
====================
----------
ALGORITHMS.436
expert
----------
PROBLEM STATEMENT:
Two spies in a grid will have their covers blown if:


They are both in the same row.  
They are both in the same column.  
They can see each other diagonally (i.e., lie in a line inclined [expression]° to the base of the grid).


The level of danger is now increased! In addition to the conditions above, no [expression]° to the base of grid.

Write a program in the language of your choice to place [expression] lines describing a valid configuration:


The value of [expression].
A space-separated list of [expression]).


Solve this problem for [expression].

Note: Run and Custom Input are not available for this challenge; you must click Submit Code for your submission to be scored. Your score for this challenge will always be the maximum value scored by any of your submissions.

Examples 
In the examples below, [expression] denotes a spy and * denotes an empty cell.

Sample Configuration 0  

A valid configuration for [expression]:
&nbsp;

[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 



Sample Output 0     

This C++ code:

[expression]
[expression]  

[expression]  
    [expression]  
    [expression]  
    [expression]  
[expression]  



Produces this output:

11
2 4 7 1 8 11 5 3 9 6 10&nbsp;


This configuration will earn a score of [expression].

Sample Configuration 1      

A valid configuration for [expression]:

[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression]



Sample Output 1     

This Python code:

[expression]  
[expression]



Produces this output:

13
1 3 12 10 7 2 11 5 8 13 9 4 6


This configuration will earn a score of [expression].

Sample Configuration 2  

An invalid configuration for [expression]:

[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 
[expression] 



Sample Output 2         

The following output:

7
1 3 5 7 2 4 6&nbsp;


will earn a score of [expression] rows.      
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
ALGORITHMS.437
expert
----------
PROBLEM STATEMENT:
Quality Blimps Inc. is looking to expand their sales to other cities ([expression]), so they hired you as a salesman to fly to other cities to sell blimps. Blimps can be expensive to travel with, so you will need to determine how many blimps to take along with you on each trip and when to return to headquarters to get more. Quality Blimps has an unlimited supply of blimps. 

You will be able to sell only one blimp in each city you visit, but you do not need to visit every city, since some have expensive travel costs. Each city has an initial price that blimps sell for, but this goes down by a certain percentage as more blimps are sold (and the novelty wears off). Find a good route that will maximize profits. 

Details

Blimp Decline  - The blimps will decline ([expression]).

Note that if the price declines after you visit some city, then it will only happen after you made the sale on that city, so your sale on that city will not be affected. In particular, each blimp you sell in the first [expression] of the cities will always be sold at their corresponding city's initial price.
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
ALGORITHMS.438
medium
----------
PROBLEM STATEMENT:
In this challenge, the task is to debug the existing code to successfully execute all provided test files.



Given two dates each in the format dd-mm-yyyy, you have to find the number of lucky dates between them (inclusive). To see if a date is lucky,


Firstly, sequentially concatinate the date, month and year, into a new integer [expression] erasing the leading zeroes. 
Now if [expression], then we call the date a lucky date.


For example, let's take the date "02-08-2024". After concatinating the day, month and year, we get [expression] so the date "02-08-2024" is called a lucky date.

Debug the given function findPrimeDates and/or other lines of code, to find the correct lucky dates from the given input.

Note: You can modify at most five lines in the given code and you cannot add or remove lines to the code.

To restore the original code in the editor, create a new buffer by clicking on the top left icon in the editor.
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
ALGORITHMS.439
medium
----------
PROBLEM STATEMENT:
In this challenge, the task is to debug the existing code to successfully execute all provided test files.



There are [expression] blue balls. 

You want to separate the balls by their color. In each operation, you can pick a single ball from some box and put it into another box. The balls are separated if no box contains balls of more than one color.

Debug the given function min_operations and compute the minimal number of operations required to separate the balls.

Note: In this problem you can modify at most six lines of code and you cannot add any new lines.

To restore the original code in the editor, create a new buffer by clicking on the top left icon in the editor.
----------
TOP SOLUTION:
----------
#include <cstdio> 
#include <cstdlib> 
#include <cstring> 
#include <algorithm> 
#include <vector> 
#include <cmath> 
#include <iostream> 
#include <map> 
using namespace std; 

int dp[110][1<<3];

int min_operations(vector <int> red, vector <int> green, vector <int> blue) {

    int n = (int)red.size(), i, j;
    for (i = 0; i <= n; i++) {
        for (j = 0; j < 8; j++) {
            dp[i][j] = 1<<30;
        }
    }

    dp[0][0] = 0;
    for (i = 0; i < n; i++){
        for (j = 0; j < 8; j++){
            dp[i + 1][j | 1] = min(dp[i + 1][j | 1], dp[i][j] + green[i] + blue[i]);
            dp[i + 1][j | 2] = min(dp[i + 1][j | 2], dp[i][j] + red[i] + blue[i]);
            dp[i + 1][j | 4] = min(dp[i + 1][j | 4], dp[i][j] + red[i] + green[i]);
        }
    }
    j = 0;
    for (i = 0; i < n; i++){
        if (red[i]) j |= 1;
        if (green[i]) j |= 2;
        if (blue[i]) j |= 4;
    }

    if (dp[n][j] >= (1<<30))
        dp[n][j] = -1;

    return dp[n][j];
}

int main() {

    int n, r, g, b;
    cin >> n;
    vector<int> red, blue, green;

    for(int i = 0; i < n; i++){

        cin >> r >> g >> b;
        red.push_back(r);
        green.push_back(g);
        blue.push_back(b);
    }

    cout << min_operations(red, green, blue) << "\n";
    return 0;
}

----------
====================
----------
ALGORITHMS.440
easy
----------
PROBLEM STATEMENT:
In this challenge, the task is to debug the existing code to successfully execute all provided test files.



Given two strings consisting of digits 0 and 1 only, find the XOR of the two strings.

To know more about XOR Click Here

Debug the given function strings_xor to find the XOR of the two given strings appropriately. 

Note: You can modify at most three lines in the given code and you cannot add or remove lines to the code.

To restore the original code in the editor, create a new buffer by clicking on the top left icon in the editor.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

string strings_xor(string s, string t) {
    
    string res = "";
    for(int i = 0; i < s.size(); i++) {
        if(s[i] == t[i])
            res += '0';
        else
            res += '1';
    }
    
    return res;
}

int main() {
    string s, t;
    cin >> s >> t;
    cout << strings_xor(s, t) << endl;
    return 0;
}


----------
====================
----------
ALGORITHMS.441
medium
----------
PROBLEM STATEMENT:
In this challenge, the task is to debug the existing code to successfully execute all provided test files.



Given an array of [expression]. You need to find the lexicographically smallest zig zag sequence of the given array.

For example let's say [expression], the result is a zig zag sequence.

Debug the given function findZigZagSequence to return the appropriate zig zag sequence for the given input array.

Note: You can modify at most three lines in the given code and you cannot add or remove lines to the code.

To restore the original code in the editor, create a new buffer by clicking on the top left icon in the editor.
----------
TOP SOLUTION:
----------
{"models":[],"page":1,"total":0}
----------
====================
----------
ALGORITHMS.442
easy
----------
PROBLEM STATEMENT:
In this challenge, the task is to debug the existing code to successfully execute all provided test files.



A number is called a smart number if it has an odd number of factors. Given some numbers, find whether they are smart numbers or not.

Debug the given function is_smart_number to correctly check if a given number is a smart number. 

Note: You can modify only one line in the given code and you cannot add or remove any new lines.

To restore the original code in the editor, create a new buffer by clicking on the top left icon in the editor.
----------
TOP SOLUTION:
----------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

bool is_smart_number(int num) {
    int val = (int) sqrt(num);
    if(num == val*val)
        return true;
    return false;
}

int main() {
    
    int test_cases;
    cin >> test_cases;
    int num;
    for(int i = 0; i < test_cases; i++) {
        cin >> num;
        bool ans = is_smart_number(num);
        if(ans) {
            cout << "YES" << endl;
        }
        else cout << "NO" << endl;
    }
    return 0;
}

----------
====================